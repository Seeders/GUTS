{
  "objectTypes": {
    "attackSounds": {
      "laser": {
        "title": "Laser",
        "audio": {
          "waveform": "triangle",
          "frequency": 197,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0.076,
            "sustain": 0.5,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.41,
            "end": 0.23,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 400,
              "Q": 1
            },
            "distortion": 5,
            "delay": {
              "time": 0.27,
              "feedback": 0.09
            },
            "reverb": 0,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "missileLaunch": {
        "title": "Missile Launch",
        "audio": {
          "waveform": "noise",
          "frequency": 341,
          "duration": 0.4,
          "noise": {
            "type": "brown",
            "amount": 0.63,
            "filter": {
              "type": "bandpass",
              "frequency": 20
            }
          },
          "envelope": {
            "attack": 0.252,
            "decay": 0.4,
            "sustain": 0,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.38,
            "end": 0.59,
            "time": 0.4
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 20000,
              "Q": 1
            },
            "distortion": 0,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0.11,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "gunshot": {
        "title": "GunShot",
        "audio": {
          "waveform": "noise",
          "frequency": 200,
          "duration": 0.5,
          "noise": {
            "type": "pink",
            "amount": 0.8,
            "filter": {
              "type": "lowpass",
              "frequency": 400
            }
          },
          "envelope": {
            "attack": 0.01,
            "decay": 0.3,
            "sustain": 0.2,
            "release": 0.1
          },
          "pitchEnvelope": {
            "start": 4,
            "end": 2,
            "time": 0.5
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 800,
              "Q": 1
            },
            "distortion": 2,
            "delay": {
              "time": 0.1,
              "feedback": 0.3
            },
            "reverb": 0.4,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "plasma": {
        "title": "Plasma",
        "audio": {
          "waveform": "triangle",
          "frequency": 197,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0.076,
            "sustain": 0.5,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.41,
            "end": 0.23,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 400,
              "Q": 1
            },
            "distortion": 5,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "TeslaAttack": {
        "title": "Tesla Attack",
        "audio": {
          "waveform": "noise",
          "frequency": 200,
          "duration": 0.15,
          "envelope": {
            "attack": 0.001,
            "decay": 0.03,
            "sustain": 0.4,
            "release": 0.02
          },
          "pitchEnvelope": {
            "start": 2.5,
            "end": 0.8,
            "time": 0.15
          },
          "effects": {
            "filter": {
              "type": "bandpass",
              "frequency": 1200,
              "Q": 3
            },
            "distortion": 30,
            "delay": {
              "time": 0.05,
              "feedback": 0.05
            },
            "reverb": 0.05,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      }
    },
    "hitSounds": {
      "explosion": {
        "title": "Explosion",
        "audio": {
          "waveform": "noise",
          "frequency": 100,
          "duration": 1,
          "noise": {
            "type": "white",
            "amount": 0,
            "filter": {
              "type": "none",
              "frequency": 2000
            }
          },
          "envelope": {
            "attack": 0.005,
            "decay": 0.2,
            "sustain": 0.3,
            "release": 0.3
          },
          "pitchEnvelope": {
            "start": 2,
            "end": 0.5,
            "time": 1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 800,
              "Q": 1
            },
            "distortion": 3,
            "delay": {
              "time": 0.15,
              "feedback": 0.25
            },
            "reverb": 0.5,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "plasma": {
        "title": "Plasma",
        "audio": {
          "waveform": "noise",
          "frequency": 73,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 2,
            "sustain": 0,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 0.97,
            "end": 1.01,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 70,
              "Q": 2
            },
            "distortion": 3,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0,
            "bitcrusher": 0.1,
            "pan": 0
          }
        }
      }
    },
    "sounds": {
      "pickup": {
        "title": "Pickup",
        "audio": {
          "waveform": "triangle",
          "frequency": 200,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0,
            "sustain": 0,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 0.34,
            "end": 1.89,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 400,
              "Q": 1
            },
            "distortion": 20,
            "delay": {
              "time": 0,
              "feedback": 0.2
            },
            "reverb": 0,
            "bitcrusher": 0.1,
            "pan": 0
          }
        }
      },
      "placeTower": {
        "title": "Place Tower",
        "audio": {
          "waveform": "sine",
          "frequency": 20,
          "duration": 0.2,
          "noise": {
            "type": "pink",
            "amount": 0.8,
            "filter": {
              "type": "lowpass",
              "frequency": 400
            }
          },
          "envelope": {
            "attack": 0.01,
            "decay": 0,
            "sustain": 0.1,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 4,
            "end": 4,
            "time": 0.2
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 500,
              "Q": 1
            },
            "distortion": 0,
            "delay": {
              "time": 0.05,
              "feedback": 0.2
            },
            "reverb": 0.3,
            "bitcrusher": 0.4,
            "pan": 0
          }
        }
      },
      "test": {
        "title": "test",
        "audio": {
          "waveform": "noise",
          "frequency": 440,
          "duration": 0.6,
          "noise": {
            "type": "pink",
            "amount": 1,
            "filter": {
              "type": "bandpass",
              "frequency": 1200,
              "Q": 1.8
            }
          },
          "envelope": {
            "attack": 0.02,
            "decay": 0.4,
            "sustain": 0,
            "release": 0
          },
          "pitchEnvelope": {
            "start": 1.8,
            "end": 0.4,
            "time": 0.5
          },
          "effects": {
            "filter": {
              "type": "none",
              "frequency": 20000,
              "Q": 1
            },
            "distortion": 0.2,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0.15,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      }
    },
    "colliders": {
      "NPC": {
        "title": "NPC",
        "size": 2,
        "type": "sphere",
        "offset": "{ \"x\": 0, \"y\": 3, \"z\": 0 }",
        "mass": 10,
        "gravity": false,
        "restitution": 0.7,
        "static": true
      },
      "fighterCollider": {
        "title": "Fighter Collider",
        "size": 2,
        "type": "sphere",
        "offset": "{ \"x\": 0, \"y\": 3, \"z\": 0 }",
        "mass": 10,
        "gravity": false,
        "restitution": 0.7
      },
      "plasmaBolt": {
        "title": "Plasma Bolt",
        "size": 1,
        "type": "sphere",
        "offset": "{ \"x\": 0, \"y\": 0, \"z\": 0 }",
        "mass": 1,
        "gravity": true,
        "restitution": 0.6,
        "friction": 0.5
      }
    },
    "infiniWorlds": {
      "shire": {
        "title": "Shire",
        "world": "shire",
        "palette": "main"
      }
    },
    "projectiles": {
      "plasmaBall": {
        "title": "Plasma Ball",
        "speed": 400,
        "hitSound": "",
        "attackSound": "",
        "particlePrefab": "",
        "impactParticlePrefab": "",
        "offset": "{ \"x\": -1.5, \"y\": 17, \"z\": 3 }"
      },
      "plasmaBolt": {
        "title": "Plasma Bolt",
        "speed": 2000,
        "hitSound": "",
        "attackSound": "",
        "particlePrefab": "",
        "impactParticlePrefab": ""
      }
    },
    "biomes": {
      "desert": {
        "title": "Desert",
        "groundColor": "#d9b38c",
        "elevationNoiseSetting": "desertElevation",
        "detailNoiseSetting": "desertDetail",
        "worldObjectSpawns": [
          "desertRocks",
          "desertTrees",
          "desertGrass"
        ],
        "range": [
          0.7,
          1
        ],
        "groundRestitution": 0,
        "groundFriction": 1
      },
      "forest": {
        "title": "Forest",
        "groundColor": "#5a8a4f",
        "elevationNoiseSetting": "forestElevation",
        "detailNoiseSetting": "forestDetail",
        "worldObjectSpawns": [
          "forestRocks",
          "forestTrees",
          "forestGrass"
        ],
        "range": [
          0.2,
          0.6
        ],
        "groundRestitution": 0.5,
        "groundFriction": 0.5
      },
      "plains": {
        "title": "Plains",
        "groundColor": "#a3d39c",
        "elevationNoiseSetting": "plainsElevation",
        "detailNoiseSetting": "plainsDetail",
        "worldObjectSpawns": [
          "plainsRocks",
          "plainsTrees",
          "plainsGrass"
        ],
        "range": [
          0,
          0.4
        ],
        "groundRestitution": 0.5,
        "groundFriction": 0.7
      },
      "mountain": {
        "title": "Mountain",
        "groundColor": "#cfd8dc",
        "elevationNoiseSetting": "mountainElevation",
        "detailNoiseSetting": "mountainDetail",
        "ridgeNoiseSetting": "mountainRidge",
        "worldObjectSpawns": [
          "mountainRocks",
          "mountainTrees",
          "mountainGrass"
        ],
        "range": [
          0.5,
          0.8
        ],
        "groundRestitution": 0.8,
        "groundFriction": 0.2
      }
    },
    "cameras": {
      "main": {
        "title": "Main",
        "fov": 45,
        "near": 0.25,
        "far": 28000,
        "position": "{ \"x\": 384, \"y\": 500, \"z\": 1152 }",
        "lookAt": "{ \"x\": 384, \"y\": 15, \"z\": 384 }"
      }
    },
    "fogs": {
      "sunnyDayFog": {
        "title": "Sunny Day Fog",
        "color": "#b3e5fc",
        "density": 0.1,
        "enabled": false
      }
    },
    "heightMaps": {
      "fiveStep": {
        "title": "Ten",
        "heightScale": 10,
        "chunkResolution": 32,
        "chunkSize": 1024,
        "renderDistance": 2
      }
    },
    "levels": {
      "level1": {
        "title": "Level 1",
        "world": "shire",
        "grassShader": "grass",
        "waterShader": "water"
      }
    },
    "lightings": {
      "sunnyDayLighting": {
        "title": "Sunny Day Lighting",
        "ambientColor": "#b3e5fc",
        "ambientIntensity": 0.4,
        "directionalColor": "#ffcc80",
        "directionalIntensity": 0.7,
        "skyColor": "#0288d1",
        "groundColor": "#5a8a4f",
        "hemisphereIntensity": 0.5
      }
    },
    "noiseSettings": {
      "desertDetail": {
        "title": "Desert Detail",
        "scale": 0.001,
        "octaves": 2,
        "persistence": 0.5,
        "lacunarity": 1.3,
        "heightScale": 1
      },
      "desertElevation": {
        "title": "Desert Elevation",
        "scale": 0.0001,
        "octaves": 3,
        "persistence": 0.4,
        "lacunarity": 1.8,
        "heightScale": 5
      },
      "forestElevation": {
        "title": "Forest Elevation",
        "scale": 0.0003,
        "octaves": 5,
        "persistence": 0.6,
        "lacunarity": 2.2,
        "heightScale": 15
      },
      "forestDetail": {
        "title": "Forest Detail",
        "scale": 0.001,
        "octaves": 3,
        "persistence": 0.7,
        "lacunarity": 1.8,
        "heightScale": 3
      },
      "mountainDetail": {
        "title": "Mountain Detail",
        "scale": 0.002,
        "octaves": 4,
        "persistence": 0.6,
        "lacunarity": 2,
        "heightScale": 5
      },
      "mountainRidge": {
        "title": "Mountain Ridge",
        "scale": 0.001,
        "power": 2.5,
        "heightScale": 20
      },
      "mountainElevation": {
        "title": "Mountain Elevation",
        "scale": 0.00005,
        "octaves": 6,
        "persistence": 0.7,
        "lacunarity": 2.5,
        "heightScale": 200
      },
      "plainsDetail": {
        "title": "Plains Detail",
        "scale": 0.001,
        "octaves": 2,
        "persistence": 0.8,
        "lacunarity": 1.5,
        "heightScale": 2
      },
      "plainsElevation": {
        "title": "Plains Elevation",
        "scale": 0.0002,
        "octaves": 4,
        "persistence": 0.5,
        "lacunarity": 2,
        "heightScale": 10
      }
    },
    "scenes": {
      "main": {
        "title": "Main",
        "sceneData": [
          {
            "id": 7,
            "type": "game",
            "objectType": "gamePrefabs",
            "spawnType": "infiniworldShire",
            "parent": null,
            "children": [],
            "components": [
              {
                "type": "transform",
                "parameters": {
                  "position": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 1,
                    "y": 1,
                    "z": 1
                  }
                }
              },
              {
                "type": "InfiniWorld",
                "parameters": {
                  "world": "shire"
                }
              }
            ]
          },
          {
            "id": 8,
            "type": "enemy",
            "objectType": "enemyPrefabs",
            "spawnType": "waving_npc",
            "parent": null,
            "children": [],
            "components": [
              {
                "type": "transform",
                "parameters": {
                  "position": {
                    "x": -76.21048883638852,
                    "y": 29.45508128887155,
                    "z": 129.59387462050228
                  },
                  "rotation": {
                    "x": 0,
                    "y": 3,
                    "z": 0
                  },
                  "scale": {
                    "x": 1,
                    "y": 1,
                    "z": 1
                  }
                }
              },
              {
                "type": "Collider",
                "parameters": {
                  "collider": "fighterCollider"
                }
              }
            ]
          },
          {
            "id": 9,
            "type": "enemy",
            "objectType": "enemyPrefabs",
            "spawnType": "monster",
            "parent": null,
            "children": [],
            "components": [
              {
                "type": "transform",
                "parameters": {
                  "position": {
                    "x": -43.5327299539353,
                    "y": 30.283653808417835,
                    "z": 120.71566069649644
                  },
                  "rotation": {
                    "x": 0,
                    "y": 2.7,
                    "z": 0
                  },
                  "scale": {
                    "x": 1,
                    "y": 1,
                    "z": 1
                  }
                }
              },
              {
                "type": "Collider",
                "parameters": {
                  "collider": "fighterCollider"
                }
              }
            ]
          },
          {
            "id": 10,
            "type": "staticObject",
            "objectType": "worldObjectPrefabs",
            "spawnType": "sequoia_tree",
            "parent": null,
            "children": [],
            "components": [
              {
                "type": "transform",
                "parameters": {
                  "position": {
                    "x": 53.23995363600116,
                    "y": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 10,
                    "y": 10,
                    "z": 10
                  }
                }
              }
            ]
          },
          {
            "id": 11,
            "type": "player",
            "objectType": "playerPrefabs",
            "spawnType": "waving_guy",
            "parent": null,
            "children": [],
            "components": [
              {
                "type": "transform",
                "parameters": {
                  "position": {
                    "x": -921.1892383599477,
                    "y": 70.71740257002817,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 1,
                    "y": 1,
                    "z": 1
                  }
                }
              }
            ]
          }
        ]
      }
    },
    "shadows": {
      "sunnyDayShadows": {
        "title": "Sunny Day Shadows",
        "mapSize": 2048,
        "bias": -0.0003,
        "normalBias": 0,
        "radius": 512,
        "enabled": true
      }
    },
    "worldObjectSpawns": {
      "desertGrass": {
        "title": "Desert Grass",
        "density": 0.1,
        "maxSlope": 1,
        "bladeWidth": 2,
        "bladeHeight": 4,
        "shader": "grass",
        "tipColor": "#d9b38c",
        "baseColor": "#8b5e3c"
      },
      "desertRocks": {
        "title": "Desert Rock",
        "worldObjectPrefab": "rock",
        "density": 0.1,
        "maxSlope": 0.25
      },
      "desertSpaceships": {
        "title": "Desert Spaceship",
        "worldObjectPrefab": "",
        "density": 0.01,
        "maxSlope": 1
      },
      "desertTrees": {
        "title": "Desert Trees",
        "worldObjectPrefab": "palm_tree",
        "density": 0.001,
        "maxSlope": 0.8
      },
      "forestGrass": {
        "title": "Forest Grass",
        "density": 1,
        "maxSlope": 1,
        "bladeWidth": 2,
        "bladeHeight": 4,
        "shader": "grass",
        "tipColor": "#5a8a4f",
        "baseColor": "#2f4a29"
      },
      "forestRocks": {
        "title": "Forest Rock",
        "worldObjectPrefab": "smooth_rock",
        "density": 0.05,
        "maxSlope": 0.2
      },
      "forestTrees": {
        "title": "Forest Trees",
        "worldObjectPrefab": "ash_medium_tree",
        "density": 0.075,
        "maxSlope": 0.8
      },
      "mountainGrass": {
        "title": "Mountain Grass",
        "density": 0.75,
        "maxSlope": 1,
        "bladeWidth": 4,
        "bladeHeight": 12,
        "shader": "grass",
        "tipColor": "#d9b38c",
        "baseColor": "#4a2f1f"
      },
      "mountainRocks": {
        "title": "Mountain Rock",
        "worldObjectPrefab": "rock",
        "density": 0.3,
        "maxSlope": 0.6
      },
      "mountainTrees": {
        "title": "Mountain Trees",
        "worldObjectPrefab": "spruce_tree",
        "density": 0.001,
        "maxSlope": 0.8
      },
      "plainsGrass": {
        "title": "Plains Grass",
        "density": 1,
        "maxSlope": 1,
        "bladeWidth": 4,
        "bladeHeight": 16,
        "shader": "grass",
        "tipColor": "#a3d39c",
        "baseColor": "#5a8a4f"
      },
      "plainsRocks": {
        "title": "Plains Rock",
        "worldObjectPrefab": "smooth_rock",
        "density": 0.01,
        "maxSlope": 0.3
      },
      "plainsTrees": {
        "title": "Plains Trees",
        "worldObjectPrefab": "tree",
        "density": 0.02,
        "maxSlope": 0.8
      }
    },
    "worlds": {
      "shire": {
        "title": "Shire",
        "lighting": "sunnyDayLighting",
        "shadow": "sunnyDayShadows",
        "fog": "sunnyDayFog",
        "camera": "main",
        "worldObjects": [
          "tree",
          "rock"
        ],
        "backgroundColor": "#0288d1",
        "heightMap": "fiveStep",
        "biomes": [
          "plains",
          "desert",
          "mountain",
          "forest"
        ],
        "grassShader": "grass",
        "waterShader": "water"
      }
    },
    "enemyPrefabs": {
      "monster": {
        "title": "Monster",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/idle_monster/idle_monster.glb",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "/samples/models/walk_monster/walk_monster.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 10,
                "y": 10,
                "z": 10
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "texture": "carbonFiber",
                  "url": "/samples/models/idle_monster/idle_monster.glb",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "enemy",
        "arr": "enemies",
        "collider": "fighterCollider"
      },
      "waving_npc": {
        "title": "Waving NPC",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 10,
                "y": 10,
                "z": 10
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "texture": "carbonFiber",
                  "url": "/samples/models/waving_guy/waving_guy.glb",
                  "roughness": "1",
                  "metalness": "0"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "enemy",
        "arr": "enemies",
        "collider": "fighterCollider"
      }
    },
    "gamePrefabs": {
      "infiniworldShire": {
        "title": "Infiniworld Shire",
        "infiniWorld": "shire",
        "entity": "game",
        "palette": "main"
      }
    },
    "particlePrefabs": {
      "smoke": {
        "title": "Smoke",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "size": 1,
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "url": "/samples/models/palm_tree/palm_tree.glb",
                      "id": 0
                    }
                  ],
                  "scale": {
                    "x": 8,
                    "y": 8,
                    "z": 8
                  }
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 1,
                  "color": "#000000",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "lifeSpan": 0.66
      },
      "smoke_copy": {
        "title": "Copy of Smoke",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "size": 1,
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "url": "/samples/models/palm_tree/palm_tree.glb",
                      "id": 0
                    }
                  ],
                  "scale": {
                    "x": 8,
                    "y": 8,
                    "z": 8
                  }
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 1,
                  "color": "#000000",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "lifeSpan": 0.66
      }
    },
    "playerPrefabs": {
      "fighterJet": {
        "title": "Fighter Jet",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 5,
                  "scaleY": 5,
                  "scaleZ": 5,
                  "color": "#FFFFFF",
                  "url": "/samples/models/blue_wings/blue_wings.glb",
                  "roughness": "0.1",
                  "metalness": "0.8"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "entity": "playerAircraft",
        "projectile": "plasmaBolt"
      },
      "knight": {
        "title": "Knight",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/KnightIdle/KnightIdle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/KnightWalk/KnightWalk.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 10,
                "y": 10,
                "z": 10
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "texture": "carbonFiber",
                  "url": "/samples/models/KnightIdle/KnightIdle.glb",
                  "metalness": ".8",
                  "roughness": "0.25"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "player"
      },
      "spaceShip": {
        "title": "Space Ship",
        "hp": 500,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {
                "cockpit": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "left wing": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyLColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "right wing": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyLColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "thrusters": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "turret": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "right turret": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "right thruster": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                }
              }
            ],
            "move": [
              {
                "left wing": {
                  "shapes": [
                    {
                      "rotationX": 0.1,
                      "rotationY": 0.5,
                      "id": 1
                    }
                  ]
                },
                "right wing": {
                  "shapes": [
                    {
                      "rotationX": 0.1,
                      "rotationY": -0.5,
                      "id": 1
                    }
                  ]
                },
                "thrusters": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueLColor"
                      },
                      "id": 2
                    },
                    {
                      "color": {
                        "paletteColor": "blueLColor"
                      },
                      "id": 3
                    }
                  ]
                },
                "cockpit": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "turret": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "right turret": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                },
                "right thruster": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueMColor"
                      },
                      "id": 0
                    },
                    {
                      "color": {
                        "paletteColor": "greyMColor"
                      },
                      "id": 1
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "cockpit": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 8,
                  "x": 0,
                  "y": 10,
                  "z": 20,
                  "color": {
                    "paletteColor": "blueMColor"
                  },
                  "name": "cockpit-dome",
                  "emissive": "#00FFFF"
                },
                {
                  "type": "box",
                  "width": 10,
                  "height": 5,
                  "depth": 10,
                  "x": 0,
                  "y": 8,
                  "z": 20,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "name": "cockpit-base"
                }
              ],
              "position": {
                "x": 0,
                "y": -2,
                "z": -5.882352941176466
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "left wing": {
              "shapes": [
                {
                  "type": "box",
                  "width": 20,
                  "height": 2,
                  "depth": 15,
                  "x": 15,
                  "y": 5,
                  "z": 10,
                  "rotationY": 30,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "wing-base-left"
                },
                {
                  "type": "box",
                  "width": 30,
                  "height": 1,
                  "depth": 10,
                  "x": 25,
                  "y": 5,
                  "z": 10,
                  "rotationY": 45,
                  "color": {
                    "paletteColor": "greyLColor"
                  },
                  "name": "wing-extension-left"
                }
              ],
              "position": {
                "x": -11,
                "y": 0,
                "z": 10
              },
              "rotation": {
                "x": 0,
                "y": 0.5,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "right wing": {
              "shapes": [
                {
                  "type": "box",
                  "width": 20,
                  "height": 2,
                  "depth": 15,
                  "x": -15,
                  "y": 5,
                  "z": 10,
                  "rotationY": -30,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "wing-base-right"
                },
                {
                  "type": "box",
                  "width": 30,
                  "height": 1,
                  "depth": 10,
                  "x": -25,
                  "y": 5,
                  "z": 10,
                  "rotationY": -45,
                  "color": {
                    "paletteColor": "greyLColor"
                  },
                  "name": "wing-extension-right"
                }
              ],
              "position": {
                "x": 11,
                "y": 0,
                "z": 10
              },
              "rotation": {
                "x": 0,
                "y": -0.5,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "thrusters": {
              "shapes": [
                {
                  "type": "cone",
                  "size": 3,
                  "height": 5,
                  "x": -6,
                  "y": 3.5,
                  "z": -35,
                  "color": {
                    "paletteColor": "blueMColor"
                  },
                  "name": "thruster-left-flame",
                  "emissive": "#0000FF",
                  "rotationZ": 0,
                  "rotationY": 0,
                  "rotationX": -90
                },
                {
                  "type": "cylinder",
                  "size": 3,
                  "height": 5,
                  "x": -6,
                  "y": 3.5,
                  "z": -30,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "thruster-left",
                  "rotationX": -90
                }
              ],
              "position": {
                "x": 0,
                "y": 4,
                "z": 32
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "turret": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 5,
                  "x": 0,
                  "y": 10,
                  "z": 0,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "name": "turret-base"
                },
                {
                  "type": "cylinder",
                  "size": 2,
                  "height": 8,
                  "x": 0,
                  "y": 10,
                  "z": 5,
                  "rotationX": 90,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "turret-barrel"
                }
              ],
              "position": {
                "x": 14.5,
                "y": -3,
                "z": 18.5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "right turret": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 5,
                  "x": 0,
                  "y": 10,
                  "z": 0,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "name": "turret-base"
                },
                {
                  "type": "cylinder",
                  "size": 2,
                  "height": 8,
                  "x": 0,
                  "y": 10,
                  "z": 5,
                  "rotationX": 90,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "turret-barrel"
                }
              ],
              "position": {
                "x": -14.5,
                "y": -3,
                "z": 18.5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "right thruster": {
              "shapes": [
                {
                  "type": "cone",
                  "size": 3,
                  "height": 5,
                  "x": 6,
                  "y": 3.5,
                  "z": -35,
                  "color": {
                    "paletteColor": "blueMColor"
                  },
                  "name": "thruster-right-flame",
                  "emissive": "#0000FF",
                  "rotationX": -90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1
                },
                {
                  "type": "cylinder",
                  "size": 3,
                  "height": 5,
                  "x": 6,
                  "y": 3.5,
                  "z": -30,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "name": "thruster-right",
                  "rotationX": -90
                }
              ],
              "position": {
                "x": -0.5,
                "y": 4,
                "z": 32
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "playerAircraft"
      },
      "spaceship2": {
        "title": "Space Ship 2",
        "hp": 500,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 17.7,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 4,
                "y": 4,
                "z": 4
              },
              "shapes": [
                {
                  "type": "box",
                  "width": 3,
                  "height": 1.2,
                  "depth": 10,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "texture": "sleekMetal"
                },
                {
                  "type": "box",
                  "width": 1,
                  "height": 2,
                  "depth": 6,
                  "x": 0,
                  "y": 0.6,
                  "z": 0.1,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "sleekMetal"
                },
                {
                  "type": "box",
                  "width": 8,
                  "height": 0.3,
                  "depth": 4,
                  "x": -2.9,
                  "y": -1.5,
                  "z": 1,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 45,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "carbonFiber"
                },
                {
                  "type": "box",
                  "width": 8,
                  "height": 0.3,
                  "depth": 4,
                  "x": 2.9,
                  "y": -1.5,
                  "z": 1,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": -45,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "carbonFiber"
                },
                {
                  "type": "cylinder",
                  "size": 0.8,
                  "height": 2.5,
                  "x": -1,
                  "y": -0.5,
                  "z": -4,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "texture": "plasmaGlow"
                },
                {
                  "type": "cylinder",
                  "size": 0.8,
                  "height": 2.5,
                  "x": 1,
                  "y": -0.5,
                  "z": -4,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "texture": "plasmaGlow"
                },
                {
                  "type": "cone",
                  "size": 1.2,
                  "height": 1.8,
                  "x": -1,
                  "y": -0.5,
                  "z": -6,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "redMColor"
                  },
                  "texture": "exhaustGlow"
                },
                {
                  "type": "cone",
                  "size": 1.2,
                  "height": 1.8,
                  "x": 1,
                  "y": -0.5,
                  "z": -6,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "redMColor"
                  },
                  "texture": "exhaustGlow"
                },
                {
                  "type": "sphere",
                  "size": 1.8,
                  "x": 0,
                  "y": 0.5769470404984423,
                  "z": 4,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 0.8,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "blueMColor"
                  },
                  "texture": "tintedGlass"
                },
                {
                  "type": "box",
                  "width": 1.1,
                  "height": 0.8,
                  "depth": 2,
                  "x": 0,
                  "y": 0.5769470404984423,
                  "z": 3.5,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "sleekMetal"
                },
                {
                  "type": "cylinder",
                  "size": 3,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": 0,
                  "y": 0,
                  "z": 5,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 1.1,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1
                },
                {
                  "type": "cylinder",
                  "size": 0.2,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": 1,
                  "y": 0,
                  "z": 6.3,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0
                },
                {
                  "type": "cylinder",
                  "size": 0.2,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": -1,
                  "y": 0,
                  "z": 6.3,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0
                },
                {
                  "type": "cylinder",
                  "size": 0.2,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": -5.7,
                  "y": -4.3,
                  "z": 2.8,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "height": 6
                },
                {
                  "type": "cylinder",
                  "size": 0.2,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": 5.7,
                  "y": -4.3,
                  "z": 2.8,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "height": 6
                },
                {
                  "type": "box",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 1,
                  "y": 0.9,
                  "z": -4,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 45,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "carbonFiber"
                },
                {
                  "type": "box",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": -1,
                  "y": 0.9,
                  "z": -4,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": -45,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "texture": "carbonFiber"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "entity": "playerAircraft"
      },
      "spaceshipMesh": {
        "title": "SpaceShipMesh1",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 30,
                "y": 30,
                "z": 30
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0.2,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "url": "/samples/models/spaceship/spaceship.glb",
                  "roughness": "0.1",
                  "metalness": "0.8"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "playerAircraft"
      },
      "spaceshipMesh2": {
        "title": "SpaceShipMesh2",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 10,
                "y": 10,
                "z": 10
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "url": "/samples/models/blue_spaceship/blue_spaceship.glb"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "playerAircraft"
      },
      "viking": {
        "title": "Viking",
        "hp": 500,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "box",
                      "width": 14,
                      "height": 18,
                      "depth": 10,
                      "x": 0,
                      "y": 28.75,
                      "z": 1.48,
                      "color": "#8B4513",
                      "name": "torso",
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "z": 5.48,
                      "id": 0
                    },
                    {
                      "z": 5.48,
                      "id": 1
                    },
                    {
                      "z": 11.48,
                      "id": 2
                    },
                    {
                      "z": 9.48,
                      "id": 3
                    },
                    {
                      "z": 9.98,
                      "name": "eye-left",
                      "id": 4
                    },
                    {
                      "z": 11.48,
                      "name": "pupil-left",
                      "id": 5
                    },
                    {
                      "z": 9.98,
                      "name": "eye-right",
                      "id": 6
                    },
                    {
                      "z": 11.48,
                      "name": "pupil-right",
                      "id": 7
                    },
                    {
                      "y": 31.75,
                      "z": 5.48,
                      "name": "arm-left",
                      "rotationX": -20,
                      "id": 8
                    },
                    {
                      "y": 31.75,
                      "z": 5.48,
                      "name": "arm-right",
                      "rotationX": 20,
                      "id": 9
                    },
                    {
                      "y": 24.75,
                      "z": 15.48,
                      "name": "hand-left",
                      "id": 10
                    },
                    {
                      "y": 24.75,
                      "z": 2,
                      "name": "hand-right",
                      "rotationX": 105,
                      "id": 11
                    },
                    {
                      "z": 10,
                      "name": "leg-left",
                      "rotationX": -15,
                      "id": 12
                    },
                    {
                      "y": 12.75,
                      "name": "leg-right",
                      "rotationX": 5,
                      "id": 13
                    },
                    {
                      "y": 2.75,
                      "z": 13,
                      "name": "foot-left",
                      "id": 14
                    },
                    {
                      "y": 4.75,
                      "z": 2,
                      "name": "foot-right",
                      "id": 15
                    },
                    {
                      "z": 5.48,
                      "id": 16
                    },
                    {
                      "z": 8.5,
                      "id": 17
                    },
                    {
                      "z": 5.5,
                      "id": 18
                    },
                    {
                      "z": 5,
                      "id": 19
                    },
                    {
                      "z": -1,
                      "id": 20
                    },
                    {
                      "z": -1,
                      "rotationX": -10,
                      "id": 21
                    },
                    {
                      "y": 30,
                      "z": 5,
                      "rotationX": 20,
                      "id": 22
                    },
                    {
                      "y": 30,
                      "z": 6,
                      "rotationX": -20,
                      "id": 23
                    },
                    {
                      "x": -14,
                      "y": 25,
                      "z": 8,
                      "rotationZ": 30,
                      "rotationX": 110,
                      "id": 24
                    },
                    {
                      "x": -14,
                      "y": 25,
                      "z": 7,
                      "rotationZ": 30,
                      "rotationX": 110,
                      "id": 25
                    },
                    {
                      "y": 25,
                      "z": 15.48,
                      "rotationX": 0,
                      "id": 26
                    },
                    {
                      "y": 38,
                      "z": 15.5,
                      "rotationX": 90,
                      "id": 27
                    },
                    {
                      "y": 46,
                      "z": 15.5,
                      "rotationY": 90,
                      "id": 28
                    },
                    {
                      "z": 5.5,
                      "id": 29
                    },
                    {
                      "z": 5.5,
                      "id": 30
                    }
                  ]
                }
              },
              {},
              {
                "shapes": {
                  "shapes": [
                    {
                      "y": 27.75,
                      "z": 5.48,
                      "id": 0
                    },
                    {
                      "y": 42.75,
                      "z": 5.48,
                      "id": 1
                    },
                    {
                      "y": 42.75,
                      "z": 11.48,
                      "id": 2
                    },
                    {
                      "y": 39.25,
                      "z": 9.48,
                      "id": 3
                    },
                    {
                      "y": 44.75,
                      "z": 9.98,
                      "id": 4
                    },
                    {
                      "y": 44.75,
                      "z": 11.48,
                      "id": 5
                    },
                    {
                      "y": 44.75,
                      "z": 9.98,
                      "id": 6
                    },
                    {
                      "y": 44.75,
                      "z": 11.48,
                      "id": 7
                    },
                    {
                      "y": 28.75,
                      "z": 5.48,
                      "rotationX": 20,
                      "id": 8
                    },
                    {
                      "y": 28.75,
                      "z": 5.48,
                      "rotationX": -20,
                      "id": 9
                    },
                    {
                      "y": 20.75,
                      "z": -4.52,
                      "id": 10
                    },
                    {
                      "y": 20.75,
                      "z": 15,
                      "id": 11
                    },
                    {
                      "y": 12.75,
                      "rotationX": 5,
                      "id": 12
                    },
                    {
                      "z": 10,
                      "rotationX": -15,
                      "id": 13
                    },
                    {
                      "y": 4.75,
                      "z": 1.48,
                      "id": 14
                    },
                    {
                      "y": 2.75,
                      "z": 13,
                      "id": 15
                    },
                    {
                      "y": 18.75,
                      "z": 5.48,
                      "id": 16
                    },
                    {
                      "y": 39,
                      "z": 8.5,
                      "id": 17
                    },
                    {
                      "y": 50,
                      "z": 5.5,
                      "id": 18
                    },
                    {
                      "y": 48.1,
                      "z": 5,
                      "id": 19
                    },
                    {
                      "y": 44,
                      "z": -1,
                      "id": 20
                    },
                    {
                      "y": 27,
                      "z": -1,
                      "rotationX": -10,
                      "id": 21
                    },
                    {
                      "z": 7,
                      "rotationX": -20,
                      "id": 22
                    },
                    {
                      "z": 4,
                      "rotationX": 15,
                      "id": 23
                    },
                    {
                      "y": 21,
                      "z": 19,
                      "rotationX": 75,
                      "id": 24
                    },
                    {
                      "y": 21,
                      "z": 17.48,
                      "rotationX": 75,
                      "id": 25
                    },
                    {
                      "y": 21,
                      "z": -4.52,
                      "rotationX": 0,
                      "id": 26
                    },
                    {
                      "height": 12,
                      "depth": 14,
                      "y": 10,
                      "z": -4.5,
                      "id": 27
                    },
                    {
                      "y": 2,
                      "z": -5,
                      "rotationX": 180,
                      "id": 28
                    },
                    {
                      "y": 57,
                      "z": 5.5,
                      "id": 29
                    },
                    {
                      "y": 57,
                      "z": 5.5,
                      "id": 30
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "box",
                  "width": 14,
                  "height": 18,
                  "depth": 10,
                  "x": 0,
                  "y": 28.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "torso",
                  "scaleX": 1
                },
                {
                  "type": "sphere",
                  "size": 15,
                  "x": 0,
                  "y": 43.75,
                  "z": 1.48,
                  "color": "#e8c9a0",
                  "name": "head"
                },
                {
                  "type": "box",
                  "width": 5,
                  "height": 4,
                  "depth": 6,
                  "x": 0,
                  "y": 43.75,
                  "z": 7.48,
                  "color": "#E8C9A0",
                  "name": "nose"
                },
                {
                  "type": "box",
                  "width": 12,
                  "height": 3,
                  "depth": 6,
                  "x": 0,
                  "y": 40.25,
                  "z": 5.48,
                  "color": "#ecb69b",
                  "name": "jaw"
                },
                {
                  "type": "sphere",
                  "size": 4,
                  "x": 4.5,
                  "y": 45.75,
                  "z": 5.98,
                  "color": "#87CEFA",
                  "name": "eye-right"
                },
                {
                  "type": "sphere",
                  "size": 1.5,
                  "x": 5,
                  "y": 45.75,
                  "z": 7.48,
                  "color": "#000000",
                  "name": "pupil-right"
                },
                {
                  "type": "sphere",
                  "size": 4,
                  "x": -4.5,
                  "y": 45.75,
                  "z": 5.98,
                  "color": "#87CEFA",
                  "name": "eye-left"
                },
                {
                  "type": "sphere",
                  "size": 1.5,
                  "x": -5,
                  "y": 45.75,
                  "z": 7.48,
                  "color": "#000000",
                  "name": "pupil-left"
                },
                {
                  "type": "box",
                  "width": 6,
                  "height": 20,
                  "depth": 6,
                  "x": 12,
                  "y": 29.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "arm-right"
                },
                {
                  "type": "box",
                  "width": 6,
                  "height": 20,
                  "depth": 6,
                  "x": -12,
                  "y": 29.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "arm-left"
                },
                {
                  "type": "box",
                  "width": 8,
                  "height": 5,
                  "depth": 7,
                  "x": 12,
                  "y": 17.75,
                  "z": 2.48,
                  "color": "#E8C9A0",
                  "name": "hand-right"
                },
                {
                  "type": "box",
                  "width": 8,
                  "height": 5,
                  "depth": 7,
                  "x": -12,
                  "y": 17.75,
                  "z": 2.48,
                  "color": "#E8C9A0",
                  "name": "hand-left"
                },
                {
                  "type": "box",
                  "width": 6,
                  "height": 15,
                  "depth": 6,
                  "x": 4,
                  "y": 9.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "leg-right"
                },
                {
                  "type": "box",
                  "width": 6,
                  "height": 15,
                  "depth": 6,
                  "x": -4,
                  "y": 9.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "leg-left"
                },
                {
                  "type": "box",
                  "width": 7,
                  "height": 3,
                  "depth": 10,
                  "x": 4,
                  "y": 1.75,
                  "z": 3.48,
                  "color": "#3B3B3B",
                  "name": "foot-right"
                },
                {
                  "type": "box",
                  "width": 7,
                  "height": 3,
                  "depth": 10,
                  "x": -4,
                  "y": 1.75,
                  "z": 3.48,
                  "color": "#3B3B3B",
                  "name": "foot-left"
                },
                {
                  "type": "box",
                  "width": 15,
                  "height": 3,
                  "depth": 11,
                  "x": 0,
                  "y": 19.75,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "belt"
                },
                {
                  "type": "box",
                  "width": 18,
                  "height": 12,
                  "depth": 3,
                  "x": 0,
                  "y": 40,
                  "z": 4.5,
                  "color": "#FFD700",
                  "name": "beard"
                },
                {
                  "type": "box",
                  "width": 20,
                  "height": 8,
                  "depth": 8,
                  "x": 0,
                  "y": 51,
                  "z": 1.5,
                  "color": "#A0522D",
                  "name": "helmet-top"
                },
                {
                  "type": "box",
                  "width": 22,
                  "height": 4.7,
                  "depth": 14.5,
                  "x": 0,
                  "y": 49.1,
                  "z": 1,
                  "color": "#A9A9A9",
                  "name": "helmet-band"
                },
                {
                  "type": "box",
                  "width": 12,
                  "height": 6,
                  "depth": 2,
                  "x": 0,
                  "y": 45,
                  "z": -5,
                  "color": "#ffd700",
                  "name": "hair"
                },
                {
                  "type": "box",
                  "width": 16,
                  "height": 20,
                  "depth": 2,
                  "x": 0,
                  "y": 28,
                  "z": -6,
                  "color": "#CD853F",
                  "name": "cape"
                },
                {
                  "type": "cylinder",
                  "size": 9,
                  "height": 5,
                  "x": -12,
                  "y": 24,
                  "z": 1.5,
                  "color": "#A9A9A9",
                  "name": "bracelet-right",
                  "rotationZ": 0,
                  "rotationX": 0
                },
                {
                  "type": "cylinder",
                  "size": 9,
                  "height": 5,
                  "x": 12,
                  "y": 24,
                  "z": 1.5,
                  "color": "#A9A9A9",
                  "name": "bracelet-left",
                  "rotationZ": 0,
                  "rotationX": 0
                },
                {
                  "type": "cylinder",
                  "size": 12,
                  "height": 1,
                  "x": -12,
                  "y": 18,
                  "z": 9,
                  "color": "#cd853f",
                  "name": "shield-wood",
                  "rotationZ": 0,
                  "rotationX": 90
                },
                {
                  "type": "cylinder",
                  "size": 16,
                  "height": 2,
                  "x": -12,
                  "y": 18,
                  "z": 8,
                  "color": "#A9A9A9",
                  "name": "shield",
                  "rotationZ": 0,
                  "rotationX": 90
                },
                {
                  "type": "cylinder",
                  "size": 2,
                  "height": 35,
                  "x": 12,
                  "y": 18,
                  "z": 1.48,
                  "color": "#8B4513",
                  "name": "axe-handle",
                  "rotationZ": 0,
                  "rotationX": 90
                },
                {
                  "type": "box",
                  "width": 2,
                  "height": 14,
                  "depth": 12,
                  "x": 12,
                  "y": 18,
                  "z": 15,
                  "color": "#A9A9A9",
                  "name": "axe-head",
                  "rotationY": 0,
                  "rotationZ": 0,
                  "rotationX": 0
                },
                {
                  "type": "cone",
                  "size": 6,
                  "height": 4,
                  "x": 12,
                  "y": 18,
                  "z": 21.5,
                  "rotationX": 90,
                  "color": "#A9A9A9",
                  "name": "axe-spike"
                },
                {
                  "type": "cone",
                  "size": 4,
                  "height": 10,
                  "x": 5,
                  "y": 58,
                  "z": 1.5,
                  "rotationX": 0,
                  "color": "#858585",
                  "name": "helmet-horn-right",
                  "rotationZ": -30
                },
                {
                  "type": "cone",
                  "size": 4,
                  "height": 10,
                  "x": -5,
                  "y": 58,
                  "z": 1.5,
                  "rotationX": 0,
                  "color": "#858585",
                  "name": "helmet-horn-left",
                  "rotationZ": 30
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.25,
                "y": 0.25,
                "z": 0.25
              }
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "projectile": "plasmaBolt",
        "entity": "player"
      },
      "waving_guy": {
        "title": "Waving Guy",
        "hp": 501,
        "speed": 0.5,
        "essence": 50,
        "value": 50,
        "boss": true,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0.15,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/walk_guy/walk_guy.glb",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "throw": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0.15,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/spearthrow_guy/spearthrow_guy.glb",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "run": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0.15,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/running_guy/running_guy.glb",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "leap": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0.15,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "color": "#FFFFFF",
                      "texture": "carbonFiber",
                      "url": "/samples/models/leaping_guy/leaping_guy.glb",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 10,
                "y": 10,
                "z": 10
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0.15,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1,
                  "color": "#FFFFFF",
                  "texture": "carbonFiber",
                  "url": "/samples/models/idle_guy/idle_guy.glb",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "fireResistance": 75,
        "coldResistance": 25,
        "electricResistance": 25,
        "entity": "player",
        "projectile": "plasmaBall"
      }
    },
    "projectilePrefabs": {
      "cryoMist": {
        "damageType": "cold",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "sphere",
                      "size": 6,
                      "x": 0,
                      "y": 25,
                      "z": 0,
                      "rotationX": 90,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "scaleX": 1.5,
                      "scaleY": 1.5,
                      "scaleZ": 1.5,
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 6,
                  "x": 0,
                  "y": 25,
                  "z": 0,
                  "rotationX": 90,
                  "color": "#6771e7",
                  "scaleX": 1
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "speed": 5,
        "title": "Cryomist"
      },
      "lightning": {
        "customRenderer": "lightning",
        "damageType": "electric",
        "speed": 5,
        "title": "Lightning"
      },
      "missile": {
        "damageType": "fire",
        "render": {
          "animations": {
            "idle": [
              {},
              {
                "shapes": {
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0.7884781561950853
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "ascend": [
              {
                "shapes": {
                  "rotation": {
                    "x": -0.7884781561950848,
                    "y": 0,
                    "z": 0
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "rotation": {
                    "x": -0.788478156195085,
                    "y": 0,
                    "z": -0.7802648420680536
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "descend": [
              {
                "shapes": {
                  "rotation": {
                    "x": 0.7802648420680531,
                    "y": 0,
                    "z": 0
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "rotation": {
                    "x": 0.7802648420680529,
                    "y": 0,
                    "z": 0.7802648420680495
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "launch": [
              {
                "shapes": {
                  "rotation": {
                    "x": -1.5769563123901744,
                    "y": 0,
                    "z": 0
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "rotation": {
                    "x": -1.576956312390172,
                    "y": -0.008213314127032096,
                    "z": 0.780264842068052
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "land": [
              {
                "shapes": {
                  "rotation": {
                    "x": 1.5769563123901817,
                    "y": 0,
                    "z": 0
                  }
                }
              },
              {
                "shapes": {
                  "rotation": {
                    "x": 1.5667186747652215,
                    "y": 0.0061889906291131246,
                    "z": 0.786453832697165
                  },
                  "shapes": [
                    {
                      "type": "cylinder",
                      "size": 5,
                      "color": "#888888",
                      "x": 0,
                      "y": 0,
                      "z": -1.4,
                      "rotationX": 90,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "height": 25,
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "cylinder",
                  "size": 5,
                  "color": "#888888",
                  "height": 25,
                  "rotation": {
                    "x": 90
                  },
                  "position": {
                    "z": -1.4
                  }
                },
                {
                  "type": "cone",
                  "size": 5,
                  "color": "#ff1117",
                  "x": 0,
                  "y": 0,
                  "z": 13.6,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 5
                },
                {
                  "type": "cone",
                  "size": 2.5,
                  "color": "#ff1117",
                  "x": 0,
                  "y": 0,
                  "z": -13.8,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 2.5
                },
                {
                  "type": "cylinder",
                  "size": 6.25,
                  "color": "#888888",
                  "x": 0,
                  "y": 0,
                  "z": -11,
                  "rotationX": 90,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 5
                },
                {
                  "type": "box",
                  "size": 5,
                  "color": "#888888",
                  "x": 0,
                  "y": 3,
                  "z": -11.631250000000001,
                  "rotationX": 45,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "width": 0.25,
                  "height": 2.5,
                  "depth": 8.5
                },
                {
                  "type": "box",
                  "size": 5,
                  "color": "#888888",
                  "x": 0,
                  "y": -3,
                  "z": -11.631250000000001,
                  "rotationX": -45,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "width": 0.25,
                  "height": 2.5,
                  "depth": 8.5
                },
                {
                  "type": "box",
                  "size": 5,
                  "color": "#888888",
                  "x": -3,
                  "y": 0,
                  "z": -11.631250000000001,
                  "rotationX": 0,
                  "rotationY": 45,
                  "rotationZ": 90,
                  "width": 0.25,
                  "height": 2.5,
                  "depth": 8.5
                },
                {
                  "type": "box",
                  "size": 5,
                  "color": "#888888",
                  "x": 3,
                  "y": 0,
                  "z": -11.631250000000001,
                  "rotationX": 0,
                  "rotationY": -45,
                  "rotationZ": -90,
                  "width": 0.25,
                  "height": 2.5,
                  "depth": 8.5
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "speed": 1,
        "title": "Missile",
        "isBallistic": true,
        "particle": "smoke",
        "shadows": false,
        "hitSound": "",
        "attackSound": ""
      },
      "nanoOrb": {
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "name": "ball",
                  "type": "sphere",
                  "size": 6,
                  "color": "#ee6060"
                }
              ]
            }
          }
        },
        "speed": 25,
        "damageType": "physical",
        "title": "Nano Orb"
      },
      "neutronFragment": {
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 6,
                  "x": 0,
                  "y": 25,
                  "z": 0,
                  "rotationX": 90,
                  "color": "#ee6060",
                  "scaleX": 1
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "speed": 5,
        "damageType": "physical",
        "title": "Neutron Fragment"
      },
      "plasmaBall": {
        "title": "PlasmaBall",
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 2,
                  "color": "#ee6060"
                }
              ]
            }
          }
        },
        "entity": "projectile",
        "collider": "plasmaBolt",
        "projectile": "plasmaBall"
      },
      "plasmaBolt": {
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "cube",
                      "size": 6,
                      "x": 0,
                      "y": 24,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060",
                      "scaleX": 1
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "sphere",
                      "size": 6,
                      "x": 0,
                      "y": 24,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060"
                    },
                    {
                      "type": "sphere",
                      "size": 2,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060",
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "cube",
                      "size": 8,
                      "x": 0,
                      "y": 24,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060"
                    },
                    {
                      "type": "sphere",
                      "size": 2,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060",
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "sphere",
                      "size": 8,
                      "x": 0,
                      "y": 24,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060"
                    },
                    {
                      "type": "sphere",
                      "size": 2,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 90,
                      "color": "#ee6060",
                      "scaleX": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 2,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 90,
                  "color": "#ee6060",
                  "scaleX": 1
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "title": "Plasma Bolt",
        "entity": "projectile",
        "collider": "plasmaBolt",
        "projectile": "plasmaBolt"
      }
    },
    "worldObjectPrefabs": {
      "ash_medium_tree": {
        "title": "Ash Medium Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "height": 20,
                  "texture": "",
                  "url": "/samples/models/ash_medium_leaves/ash_medium_leaves.glb",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "x": 40,
                    "y": 40,
                    "z": 40
                  }
                },
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "height": 20,
                  "texture": "",
                  "url": "/samples/models/ash_medium_trunk/ash_medium_trunk.glb",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "x": 40,
                    "y": 40,
                    "z": 40
                  }
                }
              ]
            }
          }
        },
        "entity": "staticObject"
      },
      "rock": {
        "title": "Rock",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 16,
                  "url": "/samples/models/stone/stone.glb",
                  "color": "#ffffff",
                  "metalness": 0,
                  "roughness": 1,
                  "scale": {
                    "x": 10,
                    "y": 10,
                    "z": 10
                  },
                  "position": {
                    "z": 0,
                    "y": 5
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  }
                }
              ]
            }
          }
        },
        "entity": "staticObject"
      },
      "sequoia_tree": {
        "title": "Sequoia Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 20,
                  "scaleX": 40,
                  "texture": "",
                  "url": "/samples/models/sequoia_tree/sequoia_tree.glb",
                  "scaleY": 40,
                  "scaleZ": 40,
                  "roughness": "1",
                  "metalness": "0"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "entity": "staticObject"
      },
      "palm_tree": {
        "title": "Palm Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "height": 20,
                  "scaleX": 40,
                  "texture": "",
                  "url": "/samples/models/palm_tree/palm_tree.glb",
                  "scaleY": 40,
                  "scaleZ": 40,
                  "roughness": "1",
                  "metalness": "0"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "entity": "staticObject"
      },
      "spruce_tree": {
        "title": "Spruce Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "height": 20,
                  "texture": "",
                  "url": "/samples/models/spruce_tree/spruce_tree.glb",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "x": 40,
                    "y": 40,
                    "z": 40
                  }
                }
              ]
            }
          }
        },
        "entity": "staticObject"
      },
      "smooth_rock": {
        "title": "Smooth Rock",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 16,
                  "url": "/samples/models/stone2/stone2.glb",
                  "color": "#ffffff",
                  "metalness": 0,
                  "roughness": 1,
                  "scale": {
                    "x": 10,
                    "y": 10,
                    "z": 10
                  },
                  "position": {
                    "x": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  }
                }
              ]
            }
          }
        },
        "entity": "staticObject"
      },
      "tree": {
        "title": "Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 10,
                  "color": "#ffffff",
                  "height": 20,
                  "texture": "",
                  "url": "/samples/models/conifer_tree/conifer_tree.glb",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "x": 20,
                    "y": 30,
                    "z": 20
                  }
                }
              ]
            }
          }
        },
        "entity": "staticObject"
      }
    },
    "materials": {
      "greenL": {
        "title": "Green Light",
        "color": "#a3d39c"
      }
    },
    "palettes": {
      "main": {
        "title": "Main",
        "greenLColor": "#a3d39c",
        "greenMColor": "#5a8a4f",
        "greenDColor": "#2f4a29",
        "brownLColor": "#d9b38c",
        "brownMColor": "#8b5e3c",
        "brownDColor": "#4a2f1f",
        "blueLColor": "#b3e5fc",
        "blueMColor": "#4fc3f7",
        "blueDColor": "#0288d1",
        "redLColor": "#ffcc80",
        "redMColor": "#ff8c00",
        "redDColor": "#bf360c",
        "purpleLColor": "#e1bee7",
        "purpleMColor": "#ab47bc",
        "purpleDColor": "#6a1b9a",
        "greyLColor": "#cfd8dc",
        "greyMColor": "#78909c",
        "greyDColor": "#3e4f57"
      }
    },
    "shaders": {
      "grass": {
        "title": "Grass",
        "fragmentScript": "varying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform vec3 directionalLightColor; // DirectionalLight color\nuniform float directionalLightIntensity; // DirectionalLight intensity\nuniform vec3 directionalLightDirection; // DirectionalLight direction (world space)\nuniform vec3 ambientLightColor; // AmbientLight color\nuniform float ambientLightIntensity; // AmbientLight intensity\nuniform vec3 skyColor; // HemisphereLight sky color\nuniform vec3 groundColor; // HemisphereLight ground color\nuniform float hemisphereIntensity; // HemisphereLight intensity\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal;\n\n\nvoid main() {\n    vec4 texColor = texture2D(map, vUv);\n    vec3 color = texColor.rgb;\n\n    // Directional light (Lambertian diffuse)\n    vec3 lightDir = normalize(directionalLightDirection); // Ensure direction is normalized\n    float diff = max(dot(vNormal, lightDir), 0.0);\n    vec3 diffuse = directionalLightColor * directionalLightIntensity * diff * color;\n\n    // Ambient light\n    vec3 ambient = ambientLightColor * ambientLightIntensity * color;\n\n    // Hemisphere light\n    vec3 hemiDir = vec3(0.0, 1.0, 0.0); // Up direction for hemisphere\n    float hemiDot = dot(vNormal, hemiDir) * 0.5 + 0.5; // Remap to 0-1\n    vec3 hemi = mix(groundColor, skyColor, hemiDot) * hemisphereIntensity * color;\n\n    // Combine lighting contributions\n    vec3 litColor = diffuse + ambient + hemi;\n\n    // Apply fog\n    float fogDistance = length(vWorldPosition - cameraPosition);\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    vec3 finalColor = mix(fogColor, litColor, fogFactor);\n\n    gl_FragColor = vec4(finalColor, texColor.a);\n}",
        "vertexScript": "varying vec2 vUv;\nuniform float time;\nuniform float windSpeed;\nuniform float windStrength;\nuniform vec2 windDirection;\nattribute float instancePhase;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal; // Add for lighting\nuniform float maxDistance;\n\nvoid main() {\n    vUv = uv;\n    vec2 dir = normalize(windDirection);\n    float wave = sin(time * windSpeed + instancePhase) * windStrength;\n    wave *= uv.y;\n    vec3 displacement = vec3(\n        dir.x * wave,\n        0.0,\n        dir.y * wave\n    );\n\n    // Compute world position in world space\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position + displacement, 1.0);\n    vWorldPosition = worldPosition.xyz; // Store correct world position\n  \n    float distance = length(worldPosition.xyz - cameraPosition);\n    if (distance > 500.0) {\n        //  gl_Position = vec4(1e20, 1e20, 1e20, 1.0); // Move far outside clip space\n       // return;\n    }\n    vec3 normal = normalize(normal); // Assuming grass geometry has normals\n    vNormal = normalize((modelMatrix * instanceMatrix * vec4(normal, 0.0)).xyz);\n\n    // Compute view position for gl_Position\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}",
        "uniforms": "{ \"time\": { \"value\": 0 }, \"windSpeed\": { \"value\": 0.4 }, \"windStrength\": { \"value\": 0.5 }, \"windDirection\": { \"value\": [0.8, 0.6]} }",
        "vectors": [
          "windDirection"
        ]
      },
      "water": {
        "title": "Water",
        "fragmentScript": "uniform float time;\nuniform float waveHeight;\nuniform float liquidAlpha;\nuniform vec3 liquidColor;\nuniform vec3 foamColor;\nuniform sampler2D terrainHeightmap; // Heightmap texture\nuniform vec2 terrainSize; // Size of the terrain in world units\nuniform vec2 terrainOffset; // Offset of the terrain in world units\nuniform float waveFrequency;\nuniform float fresnelPower;\nuniform vec3 lightDirection;\nuniform float ambientIntensity;\nuniform float specularIntensity;\nuniform float foamThreshold; // How close to terrain foam appears\nuniform float foamWidth; // Width of the foam band\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight;\nvarying vec3 vWorldPosition;\nuniform vec3 fogColor;\nuniform float fogDensity;\n\n// Function to get terrain height from a heightmap texture\nfloat getTerrainHeightAt(vec2 worldPos) {\n    // Convert world position to terrain UV coordinates\n    vec2 terrainUV = (worldPos - terrainOffset) / terrainSize;\n    \n    // Ensure we're within terrain bounds (0-1)\n    if (terrainUV.x < 0.0 || terrainUV.x > 1.0 || terrainUV.y < 0.0 || terrainUV.y > 1.0) {\n        return -1000.0; // Outside terrain bounds\n    }\n    \n    // Sample heightmap texture\n    return texture2D(terrainHeightmap, terrainUV).r;\n}\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n    vec3 lightDir = normalize(lightDirection);\n    \n    // Get terrain height at this xz position\n    float terrainHeight = getTerrainHeightAt(vWorldPosition.xz);\n    \n    // Calculate distance between water surface and terrain\n    float waterTerrainDistance = vWorldPosition.y - terrainHeight;\n    \n    // Create foam based on proximity to terrain - only if we found terrain nearby\n    float terrainFoamFactor = 0.0;\n    if(terrainHeight > -999.0) { // If we found valid terrain\n        terrainFoamFactor = 1.0 - smoothstep(0.0, foamWidth, waterTerrainDistance);\n    }\n    \n    // Original wave height-based foam\n    float waveFoamFactor = smoothstep(0.8, 1.0, vNormalizedWaveHeight);\n    \n    // Combine both foam factors - use max to show foam from either source\n    float foamFactor = max(terrainFoamFactor, waveFoamFactor);\n    \n    // Fresnel effect for edge transparency\n    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);\n    \n    // Diffuse lighting\n    float diffuse = max(dot(normal, lightDir), 0.0) * 0.25;\n    \n    // Specular (Blinn-Phong)\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0) * specularIntensity;\n    \n    // Base color with subtle wave height modulation\n    vec3 baseColor = liquidColor * (0.8 + 0.2 * vNormalizedWaveHeight);\n    \n    // Apply foam - now blend between base color and foam color\n    vec3 color = mix(baseColor, foamColor, foamFactor);\n    \n    // Calculate fog\n    float fogDistance = length(vWorldPosition - cameraPosition);\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    \n    // Combine lighting components\n    vec3 lightColor = color * (ambientIntensity + diffuse) + vec3(specular);\n    vec3 finalColor = mix(fogColor, lightColor, fogFactor);\n    \n    // Apply fresnel for transparency at edges and make foam more opaque\n    float alpha = mix(0.6, 1.0, fresnel) * liquidAlpha;\n    alpha = mix(alpha, 1.0, foamFactor * 0.5); // Make foam more opaque\n    \n    gl_FragColor = vec4(finalColor, min(1.0, waterTerrainDistance));\n}",
        "vertexScript": "uniform float time;\nuniform float waveHeight;\nuniform float waveFrequency;\nuniform float waveSpeed;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight;\nvarying vec3 vWorldPosition;\n\n// 2D Random function for seeding noise\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// 2D Noise function (simplified Perlin-like noise)\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nvoid main() {\n    vUv = uv;\n\n    // Generate smooth noise for subtle variation\n    float noiseScale = 0.3; // Larger scale for smoother noise\n    float noiseSpeed = 0.05; // Slower noise evolution\n    float noiseValue = noise(vUv * noiseScale + time * noiseSpeed);\n    float noiseValue2 = noise(vUv * noiseScale * 0.5 + time * noiseSpeed * 0.7 + 10.0);\n\n    // Introduce a dominant wave direction (e.g., along x-axis, simulating wind direction)\n    float directionalWave = sin(vUv.x * waveFrequency + time * waveSpeed + noiseValue * 0.5) * waveHeight;\n\n    // Add smaller, secondary waves with slight noise variation\n    float secondaryWave = sin(vUv.x * waveFrequency * 1.5 + vUv.y * waveFrequency * 0.3 + time * waveSpeed * 0.8 + noiseValue2 * 0.3) * waveHeight * 0.4;\n    float detailWave = cos(vUv.x * waveFrequency * 2.0 + vUv.y * waveFrequency * 0.5 + time * waveSpeed * 1.2) * waveHeight * 0.2 * (0.8 + 0.2 * noiseValue);\n\n    // Combine waves with a softer mix\n    float displacementY = directionalWave + secondaryWave + detailWave;\n\n    // Store wave height for fragment shader\n    vWaveHeight = displacementY;\n\n    // Normalize wave height based on maximum possible displacement\n    float maxWaveHeight = waveHeight * (1.0 + 0.4 + 0.2); // Sum of wave amplitudes\n    vNormalizedWaveHeight = clamp(displacementY / maxWaveHeight, -1.0, 1.0);\n\n    // Update position with displacement\n    vec3 newPosition = vec3(position.x, position.y + displacementY, position.z);\n\n    // Compute normal for lighting\n    float offset = 0.01;\n    float waveX = (sin((vUv.x + offset) * waveFrequency + time * waveSpeed + noiseValue * 0.5) +\n                   sin((vUv.x + offset) * waveFrequency * 1.5 + (vUv.y + offset) * waveFrequency * 0.3 + time * waveSpeed * 0.8 + noiseValue2 * 0.3) * 0.4 +\n                   cos((vUv.x + offset) * waveFrequency * 2.0 + (vUv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.2 * (0.8 + 0.2 * noiseValue)) * waveHeight;\n    float waveZ = (sin(vUv.x * waveFrequency + time * waveSpeed + noiseValue * 0.5) +\n                   sin(vUv.x * waveFrequency * 1.5 + (vUv.y + offset) * waveFrequency * 0.3 + time * waveSpeed * 0.8 + noiseValue2 * 0.3) * 0.4 +\n                   cos(vUv.x * waveFrequency * 2.0 + (vUv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.2 * (0.8 + 0.2 * noiseValue)) * waveHeight;\n    vec3 tangent = normalize(vec3(1.0, (waveX - displacementY) / offset, 0.0));\n    vec3 bitangent = normalize(vec3(0.0, (waveZ - displacementY) / offset, 1.0));\n    vNormal = normalize(cross(tangent, bitangent));\n\n    // Pass view position for fresnel and lighting\n    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);\n    vViewPosition = (cameraPosition - worldPosition.xyz);\n    vWorldPosition = worldPosition.xyz;\n\n    // Apply projection and model-view transforms\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}",
        "uniforms": "{\"time\":{\"value\":0},\"waveHeight\":{\"value\":2},\"waveFrequency\":{\"value\":15},\"waveSpeed\":{\"value\":1},\"liquidAlpha\":{\"value\":0.75},\"liquidColor\":{\"value\":\"\"},\"foamColor\":{\"value\":\"\"},\"fresnelPower\":{\"value\":0},\"lightDirection\":{\"value\":[0.5,0.5,0.5]},\"ambientIntensity\":{\"value\":1},\"specularIntensity\":{\"value\":1}}",
        "vectors": [
          "foamColor",
          "liquidColor",
          "lightDirection"
        ],
        "liquidColor": "#0288d1",
        "foamColor": "#0288d1"
      }
    },
    "textures": {
      "end": {
        "title": "End",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlklEQVRoQ+3UIQ6AMBBEUeo5D56T4zlPPQTblNTt7zYfTTIwL7PlOvZnS/Scdy2JPnf4qSUbwPdHKyGkBFgJIS3AKgipAYYHdqIX/s6mAIFIPQQBAgF6Z1MAAYIbgOPaM+QCgkEECC68jRNAALgBON4FCAA3AMe7AAHgBuB4FyAA3AAc7wIEgBuA412AAHADcLwLmAzgBfVWYBnOEmyVAAAAAElFTkSuQmCC"
      },
      "forest": {
        "title": "Forest",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwOEX1QMH0QuRwQqWXk7NdvLTHSwY3uy3Huz5boua9aEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAs/vWAZcNxDRQAAAABJRU5ErkJggg=="
      },
      "grass": {
        "title": "Grass",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwhOYVQBIWQu0IQqWXk7NdvLTHSwY3uy3Htz5bouc9aEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAsfF2AZYnfKcAAAAABJRU5ErkJggg=="
      },
      "lava": {
        "title": "Lava",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAkUlEQVRoQ+3UQQ6AIAxEUXpnj8GdMW4Jhl0/Jd+1yei8TGP0NlqhJ54WhT53+6lRDeD7o5sQSgLchFAW4BaE0gDbA3vQC39nU4BEpBWCAIkAq7MpgADJDcBx8xlyAckgAiQXPscJIADcABzvAgSAG4DjXYAAcANwvAsQAG4AjncBAsANwPEuQAC4ATjeBRwG8AKHQEgZvHpI7AAAAABJRU5ErkJggg=="
      },
      "path": {
        "title": "Path",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA+0lEQVRoQ+2UsRWDMAxEcZ8FskAmyIAMmAmyAAukJwlFCj+MfcLikCJqSzrdP5HmxzgPhr50H5MhuVWpyRqA70aeIJgE4AlCM4DndBlu11f1pEoP9tav9fVwCc0AxM5H4eJAKSxqADQSb53lGgQ1ANbN0tKfQxABiHTL8UAAwmi50aVKCED/8dExAJAzQAPg7Xcm3UcFgFQMOYyU8SoAKJtkQ0shOFs4NgFIxEpqzgCMpcHtBbAMRecGANSxz3vkymtvYQC1hoJ9fiWavffo0qyFAWiK+cfeLgFYuiSXAJBLYsPqCoC9DGL8EW9b/OgK4IilvM0IAGSiOYA3/xycGR8hN+EAAAAASUVORK5CYII="
      },
      "scales": {
        "title": "Scales",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAQ0lEQVQYV2OM6vL/z4ADXD1wi4GRoAJ9L83/2g5qGGaAdIPEwSaAOOgApgnFCpguZMXEK4DpRjeFEeRIkJHIDkV2EwCeFirmzbH2AwAAAABJRU5ErkJggg=="
      },
      "rock": {
        "title": "Rock",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA40lEQVRoQ+3VPQ6DMAwFYHItBqQOzIw9I2PnDpUYeq2iTkgoyAnBvzzmyHn4syEN0/PXOXqW15wcxSWjJm8A/zeKhOASIBKCW4AoCK4ByA+soQNHn00ACCLlELIA/WPsvp/35dG46l4elLHgHgEbwNjsXOkmAExwu1YTQPv1qAAA5RkAAACUO6B8vdgG4IedlxYDUB40s9e7A4i2SSYAojW1Zt2KAe7cpJqG1p4tBqgtbPU81yCdrcsGcDaQVTiuXGwAXIGj1VUBwHZsY0QCWGhWaYbSc5JbRGUiASTD3vGuPcAKi06NGSIOm+IAAAAASUVORK5CYII="
      },
      "water": {
        "title": "Water",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlUlEQVRoQ+3UwQ2AIBBEUbEh27ME27MhNF4Jhtt+lnzPJqPzMlv26362RE89j5Loc4efWrIBfH+0EkJKgJUQ0gKsgpAaYHhgJ3rh72wKEIjUQxAgEKB3NgUQILgBOK49Qy4gGESA4MLbOAEEgBuA412AAHADcLwLEABuAI53AQLADcDxLkAAuAE43gUIADcAx7uAyQBeDUJgGasSxlsAAAAASUVORK5CYII="
      },
      "start": {
        "title": "Start",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwGEb1QOL0QuQwQqWXk7NdvLTHSwY3uy33VZ0v0HOdeEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAvn4mAZ8YoyRAAAAABJRU5ErkJggg=="
      }
    },
    "components": {
      "MapManager": {
        "fileName": "MapManager"
      },
      "AircraftController": {
        "script": "class AircraftController extends engine.Component {\r\n    init({\r\n        acceleration = 1000,\r\n        strafeAcceleration = 15,\r\n        verticalAcceleration = 15,\r\n        pitchSpeed = 1.5,\r\n        yawSpeed = 1,\r\n        rollSpeed = 1,\r\n        mouseSensitivity = 0.00005,\r\n        dampingFactor = 0.15,\r\n        maxSpeed = 6000,\r\n        cameraSmoothing = 0.4,\r\n        collisionRecoveryTime = 2,\r\n        // New parameters for stability\r\n        physicsUpdateRate = 60,      // Hz for physics updates\r\n        positionSmoothingFactor = 0.1, // Reduced from 0.5 for smoother transitions\r\n        velocityThreshold = 0.01     // Minimum velocity threshold to reduce jitter\r\n    }) {\r\n        this.world = this.game.gameEntity.getComponent(\"InfiniWorld\");\r\n        this.scene = this.world.scene;\r\n        this.camera = this.game.camera;\r\n        this.acceleration = acceleration;\r\n        this.strafeAcceleration = strafeAcceleration;\r\n        this.verticalAcceleration = verticalAcceleration;\r\n        this.pitchSpeed = pitchSpeed;\r\n        this.yawSpeed = yawSpeed;\r\n        this.rollSpeed = rollSpeed;\r\n        this.mouseSensitivity = mouseSensitivity;\r\n        this.dampingFactor = dampingFactor;\r\n        this.maxSpeed = maxSpeed;\r\n        this.cameraSmoothing = cameraSmoothing;\r\n        this.parent.transform.quaternion = new THREE.Quaternion();\r\n        \r\n        // New stability parameters\r\n        this.physicsUpdateRate = physicsUpdateRate;\r\n        this.physicsUpdateInterval = 1 / physicsUpdateRate;\r\n        this.physicsAccumulator = 0;\r\n        this.positionSmoothingFactor = positionSmoothingFactor;\r\n        this.velocityThreshold = velocityThreshold;\r\n        this.previousPositions = []; // Store previous positions for smoothing\r\n        this.previousPositionMaxLength = 5; // Number of positions to average\r\n\r\n        // Initialize physics properties\r\n        this.physics = this.game.gameEntity.getComponent(\"Physics\");\r\n        this.collisionRecoveryTime = collisionRecoveryTime;\r\n        this.hasCollided = false;\r\n        this.collisionImpulse = new THREE.Vector3();\r\n        \r\n        // Initialize transform properties needed for physics\r\n        this.parent.transform.physicsPosition = new THREE.Vector3().copy(this.parent.transform.position);\r\n        this.parent.grounded = false;\r\n \r\n        // Store last stable position/rotation for recovery\r\n        this.lastStablePosition = new THREE.Vector3().copy(this.parent.transform.position);\r\n        this.lastStableQuaternion = new THREE.Quaternion().copy(this.parent.transform.quaternion);\r\n        this.lastStableUpdateTime = 0;\r\n        this.stableUpdateInterval = 0.5; // Save stable state every 0.5 seconds\r\n\r\n        this.controls = new THREE_.PointerLockControls(this.camera, this.world.renderer.domElement);\r\n        this.controls.pointerSpeed = 0;\r\n        this.scene.add(this.controls.object);\r\n\r\n        // Movement properties\r\n        this.thrust = 0;\r\n        this.strafeInput = 0;\r\n        this.verticalInput = 0;\r\n        this.pitchInput = 0;\r\n        this.yawInput = 0;\r\n        this.rollInput = 0;\r\n        this.mouseXInput = 0;\r\n        this.mouseYInput = 0;\r\n        this.velocity = new THREE.Vector3();\r\n        this.targetVelocity = new THREE.Vector3(); // New target velocity for smoothing\r\n        this.collisionTimer = 0;\r\n        // Local axes\r\n        this.forward = new THREE.Vector3(0, 0, 1);\r\n        this.up = new THREE.Vector3(0, 1, 0);\r\n        this.right = new THREE.Vector3(1, 0, 0);\r\n\r\n        // World reference vectors\r\n        this.worldUp = new THREE.Vector3(0, 1, 0);\r\n        this.worldForward = new THREE.Vector3(0, 0, 1);\r\n\r\n        // Input state\r\n        this.keys = {\r\n            KeyW: false,\r\n            KeyS: false,\r\n            KeyA: false,\r\n            KeyD: false,\r\n            KeyQ: false,\r\n            KeyE: false,\r\n            ShiftLeft: false,\r\n            KeyZ: false,\r\n            Space: false\r\n        };\r\n        this.initialPosition = new THREE.Vector3();\r\n        this.initialPosition.copy(this.parent.transform.position);\r\n        // Camera settings\r\n        this.isThirdPerson = true;\r\n        this.thirdPersonDistance = 50;\r\n        this.thirdPersonHeight = 15;\r\n        this.cameraLookAhead = 5;\r\n        this.lastCameraPosition = new THREE.Vector3();\r\n        this.lastCameraLookAt = new THREE.Vector3();\r\n        this.smoothedAircraftPosition = new THREE.Vector3().copy(this.parent.transform.position);\r\n        this.smoothedAircraftQuaternion = new THREE.Quaternion().copy(this.parent.transform.quaternion);\r\n     \r\n        // Bind event handlers\r\n        this.onKeyDown = this.onKeyDown.bind(this);\r\n        this.onKeyUp = this.onKeyUp.bind(this);\r\n        this.onMouseMove = this.onMouseMove.bind(this);\r\n        this.onMouseDown = this.onMouseDown.bind(this);\r\n        this.onWheel = this.onWheel.bind(this);\r\n        document.addEventListener('keydown', this.onKeyDown);\r\n        document.addEventListener('keyup', this.onKeyUp);\r\n        document.addEventListener('mousemove', this.onMouseMove);\r\n        document.addEventListener('mousedown', this.onMouseDown);\r\n        document.addEventListener('wheel', this.onWheel);\r\n\r\n        // Initialize camera\r\n        this.updateCameraPosition();\r\n        \r\n        // Debug mode for development\r\n        this.debugMode = false;\r\n        this.debugInfo = { jitterCount: 0, maxJitter: 0 };\r\n    }\r\n\r\n    OnGrounded() {\r\n        if (this.hasCollided) return;\r\n        this.hasCollided = true;\r\n        const restitution = .5;\r\n        this.thrust *= restitution;\r\n        this.parent.transform.position.y += 5;\r\n        \r\n        let reflection = new THREE.Vector3().copy(this.world.getReflectionAt(this.game.deltaTime, this.parent.transform.position, this.velocity, restitution));\r\n        // Add energy loss on bounce (70% energy conservation)\r\n    \r\n        reflection.multiplyScalar(restitution);\r\n        reflection.y *= 2;\r\n        if(reflection.y < 5) reflection.y = 5;\r\n\r\n        reflection.y = Math.min(reflection.y, 10);\r\n        // Apply reflected velocity\r\n        this.velocity.copy(reflection);\r\n        this.parent.transform.velocity.copy(reflection);\r\n    }\r\n\r\n    onKeyDown(event) {\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = true;\r\n        }\r\n\r\n        if (event.code === 'KeyV') {\r\n            this.isThirdPerson = !this.isThirdPerson;\r\n            if (this.isThirdPerson) {\r\n                const offset = new THREE.Vector3(0, this.thirdPersonHeight, -this.thirdPersonDistance)\r\n                    .applyQuaternion(this.smoothedAircraftQuaternion);\r\n                this.lastCameraPosition.copy(this.smoothedAircraftPosition).add(offset);\r\n                this.lastCameraLookAt.copy(this.smoothedAircraftPosition);\r\n            }\r\n        }\r\n\r\n        if (event.code === 'KeyR') {\r\n            // Reset aircraft orientation and clear collision state\r\n            this.parent.transform.quaternion.set(0, 0, 0, 1);\r\n            this.smoothedAircraftQuaternion.copy(this.parent.transform.quaternion);\r\n            this.hasCollided = false;\r\n            this.collisionTimer = 0;\r\n            this.velocity.set(0, 0, 0);\r\n            this.targetVelocity.set(0, 0, 0);\r\n            this.parent.transform.velocity.set(0, 0, 0);\r\n            this.parent.transform.position.copy(this.initialPosition);\r\n            this.previousPositions = [];\r\n            \r\n            // Reset stable state\r\n            this.lastStablePosition.copy(this.initialPosition);\r\n            this.lastStableQuaternion.copy(this.parent.transform.quaternion);\r\n        }\r\n        \r\n        // Toggle debug mode with F1\r\n        if (event.code === 'F1') {\r\n            this.debugMode = !this.debugMode;\r\n            console.log(\"Debug mode:\", this.debugMode);\r\n        }\r\n    }\r\n\r\n    onKeyUp(event) {\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove(event) {\r\n        if (this.controls.isLocked && !this.hasCollided) {\r\n            // Apply more aggressive smoothing to mouse input\r\n            const smoothingFactor = 0.6; // Higher smoothing for mouse movements\r\n            \r\n            // Get new input values\r\n            const newMouseXInput = -(event.movementX || 0) * this.mouseSensitivity;\r\n            const newMouseYInput = -(event.movementY || 0) * this.mouseSensitivity;\r\n            \r\n            // Apply smoothing between old and new values\r\n            this.mouseXInput = this.mouseXInput + newMouseXInput;\r\n            this.mouseYInput = this.mouseYInput + newMouseYInput;\r\n        } else {\r\n            this.mouseXInput = 0;\r\n            this.mouseYInput = 0;\r\n        }\r\n    }\r\n    \r\n    onMouseDown(event) {\r\n        if (!this.controls.isLocked && this.game.deltaTime > 0) {\r\n            this.controls.lock();\r\n            if(!event.bubbles){\r\n                event.bubbles = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    onWheel(event) {\r\n        if (this.hasCollided) return;\r\n        \r\n        const delta = event.deltaY * 0.01;\r\n        // Apply smoother thrust changes\r\n        const thrustDelta = this.acceleration * 0.5 * delta;\r\n        this.thrust = Math.max(0, Math.min(this.thrust - thrustDelta, this.maxSpeed));\r\n    }\r\n\r\n    updateAxes() {\r\n        this.forward.set(0, 0, 1).applyQuaternion(this.parent.transform.quaternion).normalize();\r\n        this.up.set(0, 1, 0).applyQuaternion(this.parent.transform.quaternion).normalize();\r\n        this.right.set(1, 0, 0).applyQuaternion(this.parent.transform.quaternion).normalize();\r\n    }\r\n\r\n    updateCameraPosition() {\r\n        const dt = this.game.deltaTime;\r\n        const smoothingAlpha = 0.9; \r\n    \r\n    \r\n        // Calculate forward vector from smoothed quaternion\r\n        const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(this.parent.transform.quaternion);\r\n    \r\n        // Calculate look-at target\r\n        const lookTarget = this.parent.transform.position.clone().add(\r\n            forward.clone().multiplyScalar(this.cameraLookAhead)\r\n        );\r\n    \r\n        if (this.isThirdPerson) {\r\n            const offsetDistance = Math.max(1, this.parent.transform.velocity.length() * .001);\r\n            const offset = new THREE.Vector3(0, this.thirdPersonHeight, -this.thirdPersonDistance).applyQuaternion(this.parent.transform.quaternion);\r\n            offset.multiplyScalar(offsetDistance);\r\n            offset.y /= offsetDistance;\r\n            const targetPos = this.parent.transform.position.clone().add(offset);\r\n              \r\n    \r\n            // Add additional camera smoothing to reduce jitter\r\n            this.camera.position.copy(targetPos);\r\n    \r\n            // Extract roll from smoothedAircraftQuaternion\r\n            const up = new THREE.Vector3(0, 1, 0).applyQuaternion(this.parent.transform.quaternion);\r\n            const right = new THREE.Vector3().crossVectors(forward, up).normalize();\r\n            up.crossVectors(right, forward).normalize(); // Recompute up to ensure orthogonality\r\n    \r\n            // Compute quaternion to look at target while preserving roll\r\n            const lookAtMatrix = new THREE.Matrix4().lookAt(\r\n                this.camera.position,\r\n                lookTarget,\r\n                up // Use aircraft's up vector to preserve roll\r\n            );\r\n            \r\n            // Apply additional rotation smoothing\r\n            const newQuaternion = new THREE.Quaternion().setFromRotationMatrix(lookAtMatrix);\r\n            this.camera.quaternion.slerp(newQuaternion, smoothingAlpha);\r\n    \r\n        } else {\r\n            this.camera.position.copy(this.parent.transform.position);\r\n            this.camera.quaternion.copy(this.parent.transform.quaternion);\r\n        }\r\n    }\r\n\r\n    updateCollisionState(dt) {\r\n        if (this.hasCollided) {\r\n            this.collisionTimer += dt;\r\n\r\n            const fadeRate = Math.max(0, 1 - (this.collisionTimer / this.collisionRecoveryTime));\r\n        \r\n            // Add gradual stabilization as recovery progresses\r\n                // Start adding some auto-stabilization\r\n            const stabilizationForce = 0.3 * (1 - fadeRate);\r\n            \r\n            // Gradually level out\r\n\r\n            const levelingQuat = new THREE.Quaternion().setFromUnitVectors(this.up, this.worldUp);\r\n            this.parent.transform.quaternion.slerp(levelingQuat, stabilizationForce * dt * 5);\r\n        \r\n            if(this.parent.transform.position.y < this.parent.transform.groundHeight) this.parent.transform.position.y += 5;\r\n            // Check if recovery time has elapsed\r\n            if (this.collisionTimer >= this.collisionRecoveryTime) {\r\n                this.hasCollided = false;\r\n                this.collisionTimer = 0;\r\n                this.previousPositions = []; // Reset position history\r\n                console.log(\"Aircraft control restored after collision\");\r\n            }\r\n        }\r\n    }\r\n\r\n    updatePhysics(dt) {\r\n\r\n        // Apply velocity smoothing\r\n        this.targetVelocity.copy(this.velocity);\r\n        \r\n        // If velocity is very small, zero it out to prevent micro-jitters\r\n        if (this.targetVelocity.lengthSq() < this.velocityThreshold * this.velocityThreshold) {\r\n            this.targetVelocity.set(0, 0, 0);\r\n        }\r\n        \r\n        // Smooth velocity transition\r\n        this.parent.transform.velocity.copy(this.targetVelocity); // Smooth velocity transitions\r\n    \r\n        this.parent.transform.position.add(this.targetVelocity.clone().multiplyScalar(this.game.deltaTime)); \r\n    }\r\n    \r\n    // New method to save stable state\r\n    updateStableState(dt) {\r\n        if (!this.hasCollided) {\r\n            this.lastStableUpdateTime += dt;\r\n            if (this.lastStableUpdateTime >= this.stableUpdateInterval) {\r\n                this.lastStableUpdateTime = 0;\r\n                this.lastStablePosition.copy(this.parent.transform.position);\r\n                this.lastStableQuaternion.copy(this.parent.transform.quaternion);\r\n            }\r\n        }\r\n    }\r\n    \r\n    update() {\r\n        const dt = this.game.deltaTime;\r\n        \r\n        const groundHeight = this.parent.transform.groundHeight;\r\n        if(this.parent.transform.position.y <= groundHeight) this.OnGrounded();\r\n        // Update stable state tracking\r\n        this.updateStableState(dt);\r\n\r\n        // Update local axes\r\n        this.updateAxes();\r\n\r\n        if (!this.hasCollided) {\r\n            // Normal flight controls when not in collision state\r\n            \r\n            // Smooth inputs\r\n            const inputDamping = 1 - (this.dampingFactor * dt);\r\n            // Cap pitch/yaw inputs to ensure consistent rotation rate\r\n            const maxInput = 1.0; // Maximum input value for pitch/yaw\r\n            this.pitchInput = (this.pitchInput * inputDamping) + Math.max(-maxInput, Math.min(maxInput, this.mouseYInput * this.pitchSpeed));\r\n            this.yawInput = (this.yawInput * inputDamping) + Math.max(-maxInput, Math.min(maxInput, this.mouseXInput * this.yawSpeed));\r\n            this.rollInput = (this.keys.KeyD ? 1 : 0) + (this.keys.KeyA ? -1 : 0);\r\n            this.rollInput *= this.rollSpeed * dt;\r\n\r\n            // Thrust control\r\n            const thrustDamping = 1 - (this.dampingFactor * dt);\r\n            this.thrust *= thrustDamping;\r\n\r\n            if (this.keys.KeyW) {\r\n                this.thrust += this.acceleration * dt;\r\n            } else if (this.keys.KeyS) {\r\n                this.thrust -= this.acceleration * 2 * dt;\r\n            }\r\n            this.thrust = Math.max(0, Math.min(this.thrust, this.maxSpeed));\r\n\r\n            // Calculate speed\r\n            const currentSpeed = Math.min(this.thrust, this.maxSpeed);\r\n\r\n            // Apply rotations\r\n            if (this.rollInput !== 0) {\r\n                const rollQuat = new THREE.Quaternion().setFromAxisAngle(this.forward, this.rollInput);\r\n                this.parent.transform.quaternion.premultiply(rollQuat);\r\n            }\r\n\r\n            if (this.pitchInput !== 0) {\r\n                // Apply pitch without scaling to ensure consistent rate\r\n                const pitchQuat = new THREE.Quaternion().setFromAxisAngle(this.right, this.pitchInput * dt);\r\n                this.parent.transform.quaternion.premultiply(pitchQuat);\r\n            }\r\n\r\n            if (this.yawInput !== 0) {\r\n                const yawQuat = new THREE.Quaternion().setFromAxisAngle(this.worldUp, this.yawInput * dt);\r\n                this.parent.transform.quaternion.premultiply(yawQuat);\r\n            }\r\n\r\n            // Normalize quaternion\r\n            this.parent.transform.quaternion.normalize();\r\n\r\n            // Update velocity\r\n            this.velocity.copy(this.forward).multiplyScalar(currentSpeed);\r\n\r\n            // Apply vertical thrust\r\n            if (this.keys.Space) {\r\n                const verticalVelocity = this.up.clone().multiplyScalar(this.verticalAcceleration * dt);\r\n                this.velocity.add(verticalVelocity);\r\n            }\r\n                \r\n            \r\n        } else {\r\n            // Handle collision state and recovery\r\n            this.updateCollisionState(dt);\r\n        }       \r\n\r\n        // Update physics system with latest position and velocity\r\n        this.updatePhysics(dt);\r\n        // Update camera position\r\n        this.updateCameraPosition();\r\n\r\n        // Reset mouse input\r\n        this.mouseXInput *= 0.8; // Gradual decay instead of immediate reset\r\n        this.mouseYInput *= 0.8;\r\n        \r\n        // Show debug info if enabled\r\n        if (this.debugMode) {\r\n            const speed = this.parent.transform.velocity.length().toFixed(2);\r\n            const physPos = this.parent.transform.physicsPosition;\r\n            const visualPos = this.parent.transform.position;\r\n            const posDiff = visualPos.distanceTo(physPos).toFixed(4);\r\n            \r\n            console.log(`Speed: ${speed}, Pos diff: ${posDiff}, Jitters: ${this.debugInfo.jitterCount}`);\r\n        }\r\n    }\r\n\r\n    onDestroy() {\r\n        this.controls.dispose();\r\n        document.removeEventListener('keydown', this.onKeyDown);\r\n        document.removeEventListener('keyup', this.onKeyUp);\r\n        document.removeEventListener('mousemove', this.onMouseMove);\r\n        document.removeEventListener('wheel', this.onWheel);\r\n        document.removeEventListener('mousedown', this.onMouseDown);\r\n        this.scene.remove(this.parent);\r\n        if (this.parent.geometry) this.parent.geometry.dispose();\r\n        if (this.parent.material) this.parent.material.dispose();\r\n    }\r\n}",
        "fileName": "AircraftController"
      },
      "Collider": {
        "script": "class Collider extends engine.Component {\r\n    init({ debug = false, objectType, spawnType }) {\r\n        this.id = this.parent.id;\r\n        this.prefabData = this.game.getCollections()[objectType][spawnType];\r\n        this.colliderData = this.game.getCollections().colliders[this.prefabData.collider];\r\n        if(!this.colliderData){\r\n            this.colliderData = {\r\n                type: \"sphere\",\r\n                size: 1,\r\n                offset: new THREE.Vector3(),\r\n                gravity: true,\r\n                mass: 1,\r\n                restitution: 0.25\r\n            }\r\n        }\r\n        this.type = this.colliderData.type; \r\n        this.size = this.colliderData.size; \r\n        if(typeof  this.colliderData.offset == \"string\")  this.colliderData.offset = JSON.parse( this.colliderData.offset);\r\n        this.offset = this.colliderData.offset ? new THREE.Vector3(this.colliderData.offset.x, this.colliderData.offset.y, this.colliderData.offset.z) : new THREE.Vector3(0, 0, 0); // Center offset\r\n        this.gravity = this.colliderData.gravity;\r\n        this.mass = this.colliderData.mass; \r\n        this.restitution = this.colliderData.restitution;\r\n        this.debug = debug; // Enable debug mode\r\n        this.debugMesh = null; // Store debug mesh\r\n        this.lerpFactor = this.colliderData.lerpFactor || .7; // Adjust this value to control smoothing (0-1)\r\n     \r\n        // Register with physics system\r\n        this.game.gameEntity.getComponent('Physics').registerCollider(this);\r\n\r\n        // Create debug visualization if debug mode is enabled\r\n        if (this.debug) {\r\n            this.createDebugMesh();\r\n        }\r\n    }\r\n\r\n    createDebugMesh() {\r\n        let geometry, material;\r\n\r\n        if (this.type === 'sphere') {\r\n            geometry = new THREE.SphereGeometry(this.size, 16, 16); // Low-poly for performance\r\n            material = new THREE.MeshBasicMaterial({\r\n                color: 0x00ff00, // Green wireframe\r\n                wireframe: true\r\n            });\r\n        } else if (this.type === 'box') {\r\n            geometry = new THREE.BoxGeometry(this.size.x, this.size.y, this.size.z);\r\n            material = new THREE.MeshBasicMaterial({\r\n                color: 0x00ff00, // Green wireframe\r\n                wireframe: true\r\n            });\r\n        } else {\r\n            throw new Error(`Unsupported collider type: ${this.type}`);\r\n        }\r\n\r\n        this.debugMesh = new THREE.Mesh(geometry, material);\r\n        this.debugMesh.position.copy(this.parent.transform.physicsPosition).add(this.offset);\r\n        this.game.scene.add(this.debugMesh); // Add to the Three.js scene\r\n    }\r\n\r\n    getAABB(position = this.parent.transform.physicsPosition) {\r\n        const pos = position.clone().add(this.offset);\r\n        if (this.type === 'sphere') {\r\n            const radius = this.size;\r\n            return {\r\n                min: {\r\n                    x: pos.x - radius,\r\n                    y: pos.y - radius,\r\n                    z: pos.z - radius\r\n                },\r\n                max: {\r\n                    x: pos.x + radius,\r\n                    y: pos.y + radius,\r\n                    z: pos.z + radius\r\n                }\r\n            };\r\n        } else if (this.type === 'box') {\r\n            return {\r\n                min: {\r\n                    x: pos.x - this.size.x / 2,\r\n                    y: pos.y - this.size.y / 2,\r\n                    z: pos.z - this.size.z / 2\r\n                },\r\n                max: {\r\n                    x: pos.x + this.size.x / 2,\r\n                    y: pos.y + this.size.y / 2,\r\n                    z: pos.z + this.size.z / 2\r\n                }\r\n            };\r\n        }\r\n        throw new Error(`Unsupported collider type: ${this.type}`);\r\n    }\r\n\r\n    update() {\r\n \r\n        this.parent.transform.position.lerp(\r\n            this.parent.transform.physicsPosition,\r\n            this.lerpFactor\r\n        );\r\n\r\n        // Update debug mesh position if it exists\r\n        if (this.debug && this.debugMesh) {\r\n            this.debugMesh.position.copy(this.parent.transform.physicsPosition).add(this.offset);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        // Clean up debug mesh if it exists\r\n        if (this.debug && this.debugMesh) {\r\n            this.game.scene.remove(this.debugMesh);\r\n            this.debugMesh.geometry.dispose();\r\n            this.debugMesh.material.dispose();\r\n            this.debugMesh = null;\r\n        }\r\n    }\r\n}",
        "fileName": "Collider"
      },
      "Physics": {
        "script": "class Physics extends engine.Component {\r\n    async init() {\r\n        this.colliders = new Map();\r\n        this.rigidbodies = new Map();\r\n        this.staticColliderIds = new Set(); // Track which ids in rigidbodies are static\r\n        this.staticAABBs = [];  // Store AABB references, not physics objects\r\n        this.collidersToRemove = [];\r\n        this.lastUpdate = 0;\r\n        this.deltaTime = 0;\r\n        this.game.physics = this;\r\n        this.staticAABBs = [];\r\n        this.preloaded = [];\r\n        await RAPIER.init();\r\n        this.RAPIER = RAPIER; // Store reference for easier access\r\n        this.startSimulation(RAPIER);        \r\n        this.eventQueue = new RAPIER.EventQueue(true); // Enable contact events\r\n    }\r\n    \r\n    async startSimulation(r) {\r\n        // Create world with gravity\r\n        let gravity = new r.Vector3(0.0, -98.1, 0.0);\r\n        this.simulation = new r.World(gravity);\r\n        this.simulation.timestep = 1/60;\r\n        if(this.playerCallback){\r\n            this.playerCallback(this.simulation);\r\n        }\r\n        this.preloaded.forEach((c) => {\r\n            if (c.heights) {\r\n                this.createHeightmapCollider(c); // Handle heightmap colliders\r\n            } else {\r\n                this.registerCollider(c); // Handle other colliders\r\n            }\r\n        });        \r\n    }\r\n\r\n    createChunkStaticColliders(chunkId, chunkData) {\r\n        chunkData.collisionAABBs.keys().forEach((worldObjectType) => {\r\n            chunkData.collisionAABBs.get(worldObjectType).forEach((aabb) => {\r\n                this.createStaticCollider(chunkId, worldObjectType, aabb);\r\n            });            \r\n        });\r\n        // this.rigidbodies.get(chunkId).push({ type: 'heightmap', rigidBody, collider });\r\n    }\r\n\r\n    registerPlayer(callback){\r\n        this.playerCallback = callback;\r\n    }\r\n\r\n    removeStaticCollider(staticId) {\r\n        if (!staticId) {\r\n            return false;\r\n        }\r\n        \r\n        if (this.rigidbodies.has(staticId)) {\r\n            const { rigidBody, collider } = this.rigidbodies.get(staticId);\r\n            \r\n            try {\r\n                if (collider) {\r\n                    this.simulation.removeCollider(collider, true);\r\n                }\r\n                \r\n                if (rigidBody) {\r\n                    this.simulation.removeRigidBody(rigidBody);\r\n                }\r\n                \r\n                this.rigidbodies.delete(staticId);  \r\n                this.staticColliderIds.delete(staticId);\r\n                \r\n                return true;\r\n            } catch (error) {\r\n                console.error(`Error removing static collider ${staticId}:`, error);\r\n                // Still remove from our maps even if physics removal failed\r\n                this.rigidbodies.delete(staticId);\r\n                this.staticColliderIds.delete(staticId);\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    registerCollider(collider) {\r\n        const r = this.RAPIER;\r\n        if(!r){\r\n            this.preloaded.push(collider);\r\n            return;\r\n        }\r\n        let entity = collider.parent;\r\n        \r\n        if (!collider.id || !entity.transform.position) {\r\n            return;\r\n        }\r\n        \r\n        // Create rigid body\r\n        let rigidBodyDesc;\r\n        if (collider.mass <= 0) {\r\n            rigidBodyDesc = r.RigidBodyDesc.fixed();\r\n        } else {\r\n            rigidBodyDesc = r.RigidBodyDesc.dynamic()\r\n                .setLinearDamping(0.2)\r\n                .setAngularDamping(0.4)\r\n                .setCcdEnabled(true);\r\n        }\r\n        \r\n        // Set initial position\r\n        rigidBodyDesc.setTranslation(\r\n            entity.transform.position.x + collider.offset.x,\r\n            entity.transform.position.y + collider.offset.y,\r\n            entity.transform.position.z + collider.offset.z\r\n        );\r\n        \r\n        // Set initial velocity if available\r\n        if (entity.transform.velocity) {\r\n            rigidBodyDesc.setLinvel(\r\n                entity.transform.velocity.x,\r\n                entity.transform.velocity.y,\r\n                entity.transform.velocity.z\r\n            );\r\n        }\r\n        \r\n        // Create the rigid body\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        rigidBody.ccd = true;\r\n        // Create collider shape based on type\r\n        let colliderDesc;\r\n        switch (collider.type) {\r\n            case 'sphere':\r\n                colliderDesc = r.ColliderDesc.ball(collider.size);\r\n                break;\r\n            case 'box':\r\n                colliderDesc = r.ColliderDesc.cuboid(\r\n                    collider.size, collider.size, collider.size\r\n                );\r\n                break;\r\n            case 'capsule':\r\n                colliderDesc = r.ColliderDesc.capsule(\r\n                    collider.size, collider.size / 2\r\n                );\r\n                break;\r\n            default:\r\n                colliderDesc = r.ColliderDesc.ball(collider.size);\r\n                break;\r\n        }\r\n        \r\n        // Set restitution (bounciness)\r\n        colliderDesc.setRestitution(collider.restitution).setMass(collider.mass);\r\n        // Create the collider\r\n        const rapierCollider = this.simulation.createCollider(colliderDesc, rigidBody);\r\n        \r\n        // Store data for tracking\r\n        const data = {\r\n            entity: entity,\r\n            type: collider.type,\r\n            size: collider.size,\r\n            gravity: collider.gravity,\r\n            offset: collider.offset,\r\n            mass: collider.mass,\r\n            restitution: collider.restitution,\r\n            rigidBody: rigidBody,\r\n            rapierCollider: rapierCollider,\r\n            reflected: 0,\r\n            wasGrounded: false\r\n        };\r\n        \r\n        this.colliders.set(collider.id, data);\r\n        \r\n        \r\n        return rigidBody;\r\n    }\r\n\r\n    unregisterCollider(colliderId) {\r\n        if (this.colliders.has(colliderId)) {\r\n            const data = this.colliders.get(colliderId);\r\n            \r\n            // Remove the Rapier collider and rigid body\r\n            if (data.rapierCollider) {\r\n                this.simulation.removeCollider(data.rapierCollider, true);\r\n            }\r\n            \r\n            if (data.rigidBody) {\r\n                this.simulation.removeRigidBody(data.rigidBody);\r\n            }\r\n            \r\n            this.colliders.delete(colliderId);\r\n            \r\n           \r\n        }\r\n    }\r\n\r\n\r\n    sendToWorker() {\r\n        // Since we're not using a worker anymore, this method now runs the simulation step\r\n        // and updates all entity positions directly\r\n        \r\n        \r\n        // Step the physics simulation\r\n        this.simulation.step();\r\n        \r\n        // Update all entity positions based on the simulation results\r\n        for (const [colliderId, data] of this.colliders.entries()) {\r\n            const entity = data.entity;\r\n            const rigidBody = data.rigidBody;\r\n            \r\n            if (!rigidBody || !entity) continue;\r\n            \r\n            // Get position from physics\r\n            const position = rigidBody.translation();\r\n            entity.transform.physicsPosition.set(\r\n                position.x,\r\n                position.y,\r\n                position.z\r\n            );\r\n            \r\n            // Get velocity from physics\r\n            const velocity = rigidBody.linvel();\r\n            entity.transform.velocity.set(\r\n                velocity.x,\r\n                velocity.y,\r\n                velocity.z\r\n            );\r\n            \r\n            // Get rotation from physics (quaternion)\r\n            const rotation = rigidBody.rotation();\r\n            entity.transform.quaternion.set(\r\n                rotation.x,\r\n                rotation.y,\r\n                rotation.z,\r\n                rotation.w\r\n            );\r\n            \r\n            // Handle ground detection\r\n               // Update AABB if the method exists\r\n            if (entity.getAABB) {\r\n                data.aabb = entity.getAABB(entity.transform.physicsPosition);\r\n            }\r\n           \r\n            // Handle collision detection\r\n            this.detectCollisions(colliderId, data);\r\n        }\r\n        // Process colliders to remove\r\n        for (const colliderId of this.collidersToRemove) {\r\n            this.unregisterCollider(colliderId);\r\n        }\r\n        this.collidersToRemove = [];\r\n    }\r\n        \r\n    detectCollisions(data) {\r\n\r\n        \r\n        // this.eventQueue.drainContactEvents((handle1, handle2, started) => {\r\n        //     const collider1 = this.simulation.getCollider(handle1);\r\n        //     const collider2 = this.simulation.getCollider(handle2);\r\n        //     const data1 = [...this.colliders.entries()].find(([id, data]) => data.rapierCollider === collider1);\r\n        //     const data2 = [...this.colliders.entries()].find(([id, data]) => data.rapierCollider === collider2);\r\n\r\n        //     if (data1 && data2 && started && data1[1].entity.OnCollision) {\r\n        //         data1[1].entity.OnCollision(data2[1]);\r\n        //     }\r\n        // });\r\n    }\r\n    addChunkCollider(chunkData) {\r\n        const { cx, cz } = chunkData;\r\n        if (!this.simulation) {\r\n            this.preloaded.push(chunkData);\r\n            return;\r\n        }\r\n        const chunkId = `${cx},${cz}`;\r\n        if(!this.rigidbodies.has(chunkId)){\r\n            this.rigidbodies.set(chunkId, []);            \r\n        }\r\n        this.createHeightmapCollider(chunkId, chunkData);\r\n        this.createChunkStaticColliders(chunkId, chunkData);\r\n    }\r\n\r\n    removeChunkColliders(cx, cz) {\r\n        const chunkId = `${cx},${cz}`;\r\n        \r\n        if (this.rigidbodies.has(`${chunkId}`)) {\r\n            let c = 0;\r\n            this.rigidbodies.get(chunkId).forEach((body) => {                \r\n                const { rigidBody, collider } = body;\r\n                if (collider) {\r\n                    this.simulation.removeCollider(collider, true);\r\n                    c++;\r\n                }\r\n                if (rigidBody) {\r\n                    this.simulation.removeRigidBody(rigidBody);\r\n                }\r\n            });\r\n            this.rigidbodies.delete(chunkId);\r\n        }\r\n    }\r\n    createStaticCollider(chunkId, worldObjectType, aabb) {\r\n        if (!aabb || !aabb.id) {\r\n            console.warn(\"Invalid AABB provided to createStaticCollider\");\r\n            return null;\r\n        }\r\n\r\n        if (this.rigidbodies.has(aabb.id)) {\r\n            return;\r\n        }\r\n        \r\n        const r = this.RAPIER;\r\n        const halfWidth = (aabb.max.x - aabb.min.x) / 2;\r\n        const halfHeight = (aabb.max.y - aabb.min.y) / 2;\r\n        const halfDepth = (aabb.max.z - aabb.min.z) / 2;\r\n        \r\n        const centerX = (aabb.max.x + aabb.min.x) / 2;\r\n        const centerY = (aabb.max.y + aabb.min.y) / 2;\r\n        const centerZ = (aabb.max.z + aabb.min.z) / 2;\r\n        \r\n        // Create a static rigid body\r\n        const rigidBodyDesc = r.RigidBodyDesc.fixed()\r\n            .setTranslation(centerX, centerY, centerZ);\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        \r\n        // Create a cuboid collider\r\n        const colliderDesc = r.ColliderDesc.capsule(halfHeight, halfWidth)\r\n                .setCollisionGroups(0x00020004) // Belongs to group 0x0002, interacts with group 0x0004 (dynamic)\r\n                .setSolverGroups(0x00020004); // Same for solver groups\r\n        const collider = this.simulation.createCollider(colliderDesc, rigidBody);\r\n        \r\n        // Store reference to the static collider with a unique ID\r\n        this.rigidbodies.get(chunkId).push({ type: worldObjectType, rigidBody, collider });\r\n        this.staticColliderIds.add(aabb.id); // Mark this as a static collider\r\n\r\n    }\r\n    createHeightmapCollider(chunkId, chunkData) {\r\n        const r = this.RAPIER;\r\n        const { cx, cz } = chunkData;\r\n       // const { heights, nx, ny, scale } = heightmap;\r\n        // Validate inputs\r\n\r\n        // Create a static rigid body for the terrain chunk\r\n        const rigidBodyDesc = r.RigidBodyDesc.fixed()\r\n                .setSoftCcdPrediction(5)\r\n                .setTranslation(\r\n                    cx * this.game.terrain.chunkSize,\r\n                    0,\r\n                    cz * this.game.terrain.chunkSize\r\n                );\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        // Create heightfield collider\r\n       // const heightfield = new Float32Array(heights);\r\n        // const colliderDesc = r.ColliderDesc.heightfield(nx - 1, ny - 1, heightfield, scale)\r\n        //     .setSensor(false);\r\n        const colliderDesc = r.ColliderDesc.trimesh(chunkData.geometry.positions, chunkData.geometry.indices)    \r\n            .setCollisionGroups(0x00010004) // Belongs to group 0x0001, interacts with group 0x0004 (dynamic)\r\n            .setSolverGroups(0x00010004)\r\n            .setRestitution(chunkData.restitution)\r\n            .setFriction(chunkData.friction); // Same for solver groups;\r\n        const collider = this.simulation.createCollider(colliderDesc, rigidBody);    \r\n        // Store collider with a unique ID\r\n      //  this.createHeightmapMesh(cx, cz, chunkData);\r\n        this.rigidbodies.get(chunkId).push({ type: 'heightmap', rigidBody, collider });\r\n    }\r\n    createHeightmapMesh(cx, cz, chunkData) {\r\n        const { geometry } = chunkData;       \r\n\r\n        // Create geometry for the heightmap\r\n        const plane = new THREE.BufferGeometry();\r\n        plane.setAttribute('position', new THREE.Float32BufferAttribute(geometry.positions, 3));\r\n        plane.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\r\n        plane.setIndex(geometry.indices);\r\n        plane.attributes.position.needsUpdate = true; // Mark for update\r\n        plane.attributes.normal.needsUpdate = true; // Mark for update\r\n        plane.computeVertexNormals(); // Recalculate normals for lighting\r\n\r\n        // Create material\r\n        const material = new THREE.MeshStandardMaterial({\r\n            color: 0x00ff00, // Green for visibility, adjust as needed\r\n            wireframe: true   // Wireframe to visualize mesh structure\r\n        });\r\n\r\n        // Create mesh\r\n        const mesh = new THREE.Mesh(plane, material);\r\n\r\n        // Position mesh to match collider\r\n        mesh.position.set(\r\n            cx * this.game.terrain.chunkSize, // Center x\r\n            1,                                                           // y (heights are in geometry)\r\n            cz * this.game.terrain.chunkSize  // Center z\r\n        );\r\n\r\n        // // Rotate plane to lie flat (x, z plane), as PlaneGeometry is initially in x, y plane\r\n        // mesh.rotation.x = -Math.PI / 2;\r\n        // Add to scene\r\n        this.game.scene.add(mesh);\r\n\r\n        // Store mesh for debugging (optional)\r\n        const chunkId = `heightmap_${cx}_${cz}`;\r\n        this.meshes = this.meshes || new Map(); // Assuming a meshes Map to store\r\n        this.meshes.set(chunkId, mesh);\r\n\r\n    }\r\n    onDestroy() {\r\n        // Clean up Rapier resources\r\n        for (const [colliderId, data] of this.colliders.entries()) {\r\n            if (data.rapierCollider) {\r\n                this.simulation.removeCollider(data.rapierCollider, true);\r\n            }\r\n            if (data.rigidBody) {\r\n                this.simulation.removeRigidBody(data.rigidBody);\r\n            }\r\n        }\r\n        \r\n        this.colliders.clear();\r\n        this.rigidbodies.clear();\r\n        this.simulation = null;\r\n    }\r\n    \r\n}",
        "fileName": "Physics"
      },
      "PlayerAttacker": {
        "script": "class PlayerAttacker extends engine.Component {\r\n    init() {\r\n        this.stats = this.parent.getComponent(\"stats\").stats;\r\n        this.camera = this.game.camera;\r\n        // Bind mouse click event\r\n        this.cooldown = .25;\r\n        this.onMouseDown = this.handleMouseDown.bind(this);\r\n        document.addEventListener('mousedown', this.onMouseDown);\r\n        \r\n        // Throw state tracking\r\n        this.isThrowAnimationPlaying = false;\r\n        this.throwRequested = false;\r\n        this.throwTimer = 0;\r\n        this.animationLength = 2;\r\n        this.throwDelay = this.animationLength * 0.6; // Keep your original delay\r\n        this.throwSpeed = this.cooldown;\r\n    }\r\n    \r\n    update() {\r\n        // Handle cooldown timer\r\n        if (this.cooldown > 0) {\r\n            this.cooldown -= this.game.deltaTime;\r\n        }\r\n        \r\n        // Handle throw animation timing\r\n        if (this.throwRequested) {\r\n            this.throwTimer += this.game.deltaTime;\r\n            \r\n            // When we reach the throw delay, launch the projectile\r\n            if (this.throwTimer >= this.throwDelay * this.throwSpeed) {\r\n                this.throwRequested = false;\r\n                this.throwTimer = 0;\r\n                this.launchProjectile();\r\n                \r\n                // Animation is still playing but projectile is launched\r\n                this.isThrowAnimationPlaying = false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n    handleMouseDown(event) {\r\n        if (event.button !== 0) return;\r\n        if (this.cooldown > 0 || this.isThrowAnimationPlaying) return;\r\n        \r\n        this.cooldown = this.throwSpeed;\r\n        \r\n        const modelRenderer = this.parent.getComponent(\"modelRenderer\");\r\n        if (modelRenderer) {            \r\n            modelRenderer.throw(this.animationLength / this.throwSpeed, this.animationLength);\r\n            this.isThrowAnimationPlaying = true;\r\n            this.throwRequested = true;\r\n            this.throwTimer = 0;\r\n        }\r\n    }\r\n    launchProjectile() {\r\n        const projectileType = this.stats.projectile;\r\n        if (!projectileType) return;\r\n        let projectileDef = this.game.getCollections().projectilePrefabs[projectileType];\r\n       \r\n        let projStats = { ...projectileDef };\r\n        delete projStats.render;\r\n        projStats.baseDamage = this.stats.damage || 1;  \r\n        projStats.piercing = this.stats.piercing || 0;\r\n        projStats.splashRadius = this.stats.splashRadius || 0;\r\n        projStats.critChance = this.stats.critChance || 0.05;\r\n        projStats.critMultiplier = this.stats.critMultiplier || 2;\r\n        \r\n        // Calculate firing direction from camera\r\n        const direction = new THREE.Vector3();\r\n        this.camera.getWorldDirection(direction); // Camera's forward vector\r\n        direction.normalize();\r\n        \r\n        // Spawn position: slightly offset from player\r\n        let spawnPos = this.parent.transform.position.clone().add(direction.clone().multiplyScalar(5));\r\n        let projectileParams = this.game.getCollections().projectiles[projectileType];\r\n           \r\n        if (projectileParams.offset) {\r\n            const offset = JSON.parse(projectileParams.offset);\r\n            // Create offset vector\r\n            const offsetVector = new THREE.Vector3(offset.x, offset.y, offset.z);\r\n            // Apply player's rotation to the offset\r\n            offsetVector.applyQuaternion(this.parent.transform.quaternion);\r\n            // Add rotated offset to spawn position\r\n            spawnPos.add(offsetVector);\r\n        }\r\n        \r\n        // Spawn projectile entity\r\n        const projectile = this.game.spawn(\r\n            'projectile',\r\n            {\r\n                objectType: 'projectilePrefabs',\r\n                spawnType: projectileType,\r\n                direction: direction, // No specific target, uses direction\r\n                owner: this.parent,\r\n                stats: projStats\r\n            },\r\n            spawnPos\r\n        );          \r\n    }\r\n    \r\n    destroy() {\r\n        document.removeEventListener('mousedown', this.onMouseDown);\r\n    }\r\n}",
        "fileName": "PlayerAttacker"
      },
      "PlayerController": {
        "script": "class PlayerController extends engine.Component {\r\n    init({\r\n        walkSpeed = 100, // Adjusted for Rapier (meters/second)\r\n        runSpeed = 200,\r\n        jumpForce = 350, // Adjusted for Rapier (meters/second)\r\n        gravity = 981, // Standard gravity (m/s²)\r\n        mouseSensitivity = 0.002,\r\n        characterHeight = 18,\r\n        characterRadius = 3,\r\n        cameraHeight = 16,\r\n        cameraSmoothing = 0.2\r\n    }) {\r\n        let gameComponent = this.game.gameEntity.getComponent('game');\r\n        this.world = gameComponent.world;\r\n        this.physics = gameComponent.physics;\r\n        this.physics.registerPlayer(this.setupPhysics.bind(this));\r\n        this.scene = this.world.scene;\r\n        this.camera = this.game.camera;\r\n\r\n        // Movement parameters\r\n        this.walkSpeed = walkSpeed;\r\n        this.runSpeed = runSpeed;\r\n        this.jumpForce = jumpForce;\r\n        this.gravity = gravity;\r\n        this.mouseSensitivity = mouseSensitivity;\r\n        this.cameraSmoothing = cameraSmoothing;\r\n\r\n        // Character dimensions\r\n        this.characterHeight = characterHeight;\r\n        this.characterRadius = characterRadius;\r\n        this.cameraHeight = cameraHeight;\r\n\r\n\r\n        // Initialize movement state\r\n        this.velocity = new THREE.Vector3(); // For tracking vertical velocity (e.g., jumping, gravity)\r\n        this.isGrounded = false;\r\n        this.jumpRequested = false;\r\n        this.isRunning = false;\r\n\r\n        // Camera properties\r\n        this.isFirstPerson = false; // Default to first-person\r\n        this.thirdPersonDistance = 50;\r\n        this.thirdPersonHeight = 25;\r\n        this.cameraTargetPosition = new THREE.Vector3();\r\n        this.cameraLookAt = new THREE.Vector3();\r\n        this.cameraPitch = 0;\r\n        this.cameraYaw = 0;\r\n\r\n        // Local axes\r\n        this.forward = new THREE.Vector3(0, 0, 1);\r\n        this.up = new THREE.Vector3(0, 1, 0);\r\n        this.right = new THREE.Vector3(1, 0, 0);\r\n\r\n        // Movement inputs\r\n        this.moveForward = 0;\r\n        this.moveRight = 0;\r\n\r\n        // Input state\r\n        this.keys = {\r\n            KeyW: false,\r\n            KeyS: false,\r\n            KeyA: false,\r\n            KeyD: false,\r\n            ShiftLeft: false,\r\n            Space: false\r\n        };\r\n\r\n        // Pointer lock controls\r\n        this.controls = { isLocked: false };\r\n        document.addEventListener('click', () => {\r\n            if (!this.controls.isLocked) {\r\n                this.world.renderer.domElement.requestPointerLock();\r\n            }\r\n        });\r\n        document.addEventListener('pointerlockchange', () => {\r\n            this.controls.isLocked = document.pointerLockElement === this.world.renderer.domElement;\r\n        });\r\n\r\n        // Bind event handlers\r\n        this.onKeyDown = this.onKeyDown.bind(this);\r\n        this.onKeyUp = this.onKeyUp.bind(this);\r\n        this.onMouseMove = this.onMouseMove.bind(this);\r\n        document.addEventListener('keydown', this.onKeyDown);\r\n        document.addEventListener('keyup', this.onKeyUp);\r\n        document.addEventListener('mousemove', this.onMouseMove);\r\n\r\n        // Debug helpers\r\n        this.debug = {\r\n            showRaycasts: false,\r\n            raycastHelpers: []\r\n        };\r\n\r\n        // Sync initial camera position\r\n        this.updateCameraPosition();\r\n    }\r\n\r\n    setupPhysics(simulation) {\r\n        \r\n        // Initialize Rapier physics\r\n        this.rapierWorld = simulation; // Assume InfiniWorld initializes a Rapier World\r\n        this.characterController = this.rapierWorld.createCharacterController(0.01); // Offset of 0.01m\r\n        this.setupCharacterController();\r\n\r\n        // Create player rigid-body and collider\r\n        this.setupPlayerBody();\r\n    }\r\n\r\n    setupCharacterController() {\r\n        // Configure Rapier character controller\r\n        this.characterController.enableAutostep(0.3, 0.2, true); // Auto-step for stairs/obstacles\r\n        this.characterController.enableSnapToGround(0.5); // Stick to ground when going downhill\r\n        this.characterController.setMaxSlopeClimbAngle(45 * Math.PI / 180); // Max 45° climb\r\n        this.characterController.setMinSlopeSlideAngle(30 * Math.PI / 180); // Slide on steep slopes\r\n        this.characterController.setApplyImpulsesToDynamicBodies(true); // Push dynamic objects\r\n        this.characterController.setUp({ x: 0, y: 1, z: 0 }); // Up vector is +Y\r\n    }\r\n\r\n    setupPlayerBody() {\r\n        // Create a kinematic position-based rigid-body\r\n        let rigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased()\r\n            .setTranslation(0, 50, 0); // Start above ground\r\n        this.rigidBody = this.rapierWorld.createRigidBody(rigidBodyDesc);\r\n\r\n        // Create a capsule collider for the player\r\n        let colliderDesc = RAPIER.ColliderDesc.capsule(\r\n            this.characterHeight / 2 - this.characterRadius, // Half-height (excluding caps)\r\n            this.characterRadius\r\n        )\r\n            .setTranslation(0, this.characterHeight / 2, 0) // Center capsule vertically\r\n            .setCollisionGroups(0x0001) // Optional: set collision groups\r\n            .setSolverGroups(0x0001); // Optional: set solver groups\r\n        this.collider = this.rapierWorld.createCollider(colliderDesc, this.rigidBody);\r\n\r\n        // Store collision radius for camera calculations\r\n        this.parent.collisionRadius = this.characterRadius;\r\n\r\n        // Sync Three.js transform with Rapier\r\n        this.syncTransformToRapier();\r\n    }\r\n\r\n    syncTransformToRapier() {\r\n        // Update Rapier rigid-body position from Three.js transform\r\n        const pos = this.parent.transform.position;\r\n        this.rigidBody.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z });\r\n    }\r\n\r\n    syncRapierToTransform() {\r\n        // Update Three.js transform from Rapier rigid-body position\r\n        const pos = this.rigidBody.translation();\r\n        const smoothingFactor = 0.5;\r\n        this.parent.transform.position.lerp(\r\n            new THREE.Vector3(pos.x, pos.y, pos.z),\r\n            Math.min(1, this.game.deltaTime * 60 * smoothingFactor)\r\n        );\r\n    }\r\n\r\n    onKeyDown(event) {\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = true;\r\n            if (event.code === 'Space' && !event.repeat && this.isGrounded) {\r\n                this.jumpRequested = true;\r\n                this.parent.getComponent(\"modelRenderer\").jump(500 / this.jumpForce);\r\n            }\r\n        }\r\n        if (event.code === 'KeyV') {\r\n            this.isFirstPerson = !this.isFirstPerson;\r\n            if (!this.isFirstPerson) {\r\n                const offset = new THREE.Vector3(0, this.thirdPersonHeight, this.thirdPersonDistance)\r\n                    .applyQuaternion(this.parent.transform.quaternion);\r\n                this.cameraTargetPosition.copy(this.parent.transform.position).add(offset);\r\n                this.cameraLookAt.copy(this.parent.transform.position);\r\n            }\r\n        }\r\n        if (event.code === 'KeyB') {\r\n            this.debug.showRaycasts = !this.debug.showRaycasts;\r\n            if (!this.debug.showRaycasts) {\r\n                this.debug.raycastHelpers.forEach(helper => {\r\n                    if (helper && this.scene.children.includes(helper)) {\r\n                        this.scene.remove(helper);\r\n                    }\r\n                });\r\n                this.debug.raycastHelpers = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    onKeyUp(event) {\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove(event) {\r\n        if (this.controls.isLocked) {\r\n            this.cameraYaw -= event.movementX * this.mouseSensitivity;\r\n            this.cameraPitch += event.movementY * this.mouseSensitivity;\r\n            this.cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.cameraPitch));\r\n            this.parent.transform.quaternion.setFromEuler(new THREE.Euler(0, this.cameraYaw, 0));\r\n        }\r\n    }\r\n\r\n    updateAxes() {\r\n        const rotation = new THREE.Euler(0, this.cameraYaw, 0, 'YXZ');\r\n        const quaternion = new THREE.Quaternion().setFromEuler(rotation);\r\n        this.forward.set(0, 0, 1).applyQuaternion(quaternion).normalize();\r\n        this.forward.y = 0;\r\n        this.forward.normalize();\r\n        this.right.set(-1, 0, 0).applyQuaternion(quaternion).normalize();\r\n        this.right.y = 0;\r\n        this.right.normalize();\r\n        this.up.set(0, 1, 0);\r\n    }\r\n\r\n    updateCameraPosition() {\r\n        const dt = Math.min(this.game.deltaTime, 0.033);\r\n        const smoothingAlpha = this.cameraSmoothing * dt * 60;\r\n\r\n        const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.cameraPitch);\r\n        const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraYaw);\r\n        const combinedQuat = new THREE.Quaternion().multiplyQuaternions(yawQuat, pitchQuat);\r\n\r\n        if (this.isFirstPerson) {\r\n            const eyePosition = this.parent.transform.position.clone().add(new THREE.Vector3(0, this.cameraHeight, 0));\r\n            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(combinedQuat);\r\n            const forwardOffset = 0.2; // Small offset to avoid clipping\r\n            eyePosition.add(forwardDir.multiplyScalar(forwardOffset));\r\n            this.camera.position.copy(eyePosition);\r\n            const yawOffsetQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);\r\n            const invertedPitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -this.cameraPitch);\r\n            const finalQuat = new THREE.Quaternion().multiplyQuaternions(yawQuat, yawOffsetQuat).multiply(invertedPitchQuat);\r\n            this.camera.quaternion.copy(finalQuat);\r\n        } else {\r\n            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(combinedQuat);\r\n            const offsetDistance = this.thirdPersonDistance;\r\n            const offsetHeight = this.thirdPersonHeight;\r\n            const targetPosition = this.parent.transform.position.clone()\r\n                .add(new THREE.Vector3(0, offsetHeight, 0))\r\n                .sub(forwardDir.clone().multiplyScalar(offsetDistance));\r\n            this.camera.position.lerp(targetPosition, smoothingAlpha);\r\n            const lookAtPos = this.parent.transform.position.clone().add(new THREE.Vector3(0, this.cameraHeight, 0));\r\n            this.cameraLookAt.lerp(lookAtPos, smoothingAlpha);\r\n            this.camera.lookAt(this.cameraLookAt);\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (!this.controls.isLocked) return;\r\n        const dt = Math.min(this.game.deltaTime, 0.1);\r\n\r\n        // Check if grounded\r\n        this.isGrounded = this.characterController.computedGrounded();\r\n\r\n        // Process inputs\r\n        if(this.isGrounded){\r\n            // Update local axes\r\n            this.updateAxes();\r\n            this.moveForward = 0;\r\n            this.moveRight = 0;\r\n            if (this.keys.KeyW) this.moveForward += 1;\r\n            if (this.keys.KeyS) this.moveForward -= 1;\r\n            if (this.keys.KeyA) this.moveRight -= 1;\r\n            if (this.keys.KeyD) this.moveRight += 1;\r\n            this.isRunning = this.keys.ShiftLeft;\r\n        }\r\n        this.parent.getComponent(\"modelRenderer\").isRunning = this.isRunning;\r\n\r\n        // Compute desired movement\r\n        const speed = this.isRunning ? this.runSpeed : this.walkSpeed;\r\n        const moveDir = new THREE.Vector3();\r\n        if (this.moveForward !== 0) moveDir.add(this.forward.clone().multiplyScalar(this.moveForward));\r\n        if (this.moveRight !== 0) moveDir.add(this.right.clone().multiplyScalar(this.moveRight));\r\n        moveDir.normalize();\r\n\r\n        // Apply gravity and jumping\r\n        this.velocity.y -= this.gravity * dt;\r\n        if (this.jumpRequested && this.isGrounded) {\r\n            this.velocity.y = this.jumpForce;\r\n            this.jumpRequested = false;\r\n            this.isGrounded = false;\r\n        }\r\n\r\n        // Compute desired translation\r\n        const desiredTranslation = {\r\n            x: moveDir.x * speed * dt,\r\n            y: this.velocity.y * dt,\r\n            z: moveDir.z * speed * dt\r\n        };\r\n\r\n        // Use Rapier character controller to compute corrected movement\r\n        this.characterController.computeColliderMovement(this.collider, desiredTranslation);\r\n\r\n\r\n        // Apply corrected movement\r\n        const correctedMovement = this.characterController.computedMovement();\r\n        const currentPos = this.rigidBody.translation();\r\n        const newPos = {\r\n            x: currentPos.x + correctedMovement.x,\r\n            y: currentPos.y + correctedMovement.y,\r\n            z: currentPos.z + correctedMovement.z\r\n        };\r\n        this.rigidBody.setNextKinematicTranslation(newPos);\r\n\r\n        // Sync Three.js transform\r\n        this.syncRapierToTransform();\r\n\r\n        // Handle collision events (e.g., for sound effects or pushing objects)\r\n        for (let i = 0; i < this.characterController.numComputedCollisions(); i++) {\r\n            const collision = this.characterController.computedCollision(i);\r\n            // Example: Log collision or trigger effects\r\n            console.log('Collision with collider handle:', collision.handle);\r\n        }\r\n\r\n        // Reset vertical velocity if grounded\r\n        if (this.isGrounded) {\r\n            this.velocity.y = 0;\r\n        }\r\n\r\n        // Update camera\r\n        this.updateCameraPosition();\r\n\r\n        // Clean up debug visuals\r\n        if (this.debug.showRaycasts) {\r\n            this.debug.raycastHelpers.forEach(helper => {\r\n                if (helper && this.scene.children.includes(helper)) {\r\n                    this.scene.remove(helper);\r\n                }\r\n            });\r\n            this.debug.raycastHelpers = [];\r\n        }\r\n    }\r\n\r\n    onDestroy() {\r\n        document.removeEventListener('keydown', this.onKeyDown);\r\n        document.removeEventListener('keyup', this.onKeyUp);\r\n        document.removeEventListener('mousemove', this.onMouseMove);\r\n\r\n        // Clean up Rapier objects\r\n        this.rapierWorld.removeCollider(this.collider);\r\n        this.rapierWorld.removeRigidBody(this.rigidBody);\r\n        this.rapierWorld.removeCharacterController(this.characterController);\r\n\r\n        // Clean up debug helpers\r\n        this.debug.raycastHelpers.forEach(helper => {\r\n            if (helper && this.scene.children.includes(helper)) {\r\n                this.scene.remove(helper);\r\n            }\r\n        });\r\n    }\r\n}",
        "fileName": "PlayerController"
      },
      "Transform": {
        "script": "class Transform extends engine.Component {\r\n    init({x, y, z, scaleX, scaleY, scaleZ, rotationX, rotationY, rotationZ}) {\r\n\r\n        this.position = new THREE.Vector3(x, y, z);\r\n        this.velocity = new THREE.Vector3();\r\n        this.physicsVelocity = new THREE.Vector3();\r\n        this.lastPosition = new THREE.Vector3(x, y, z);\r\n        this.physicsPosition = new THREE.Vector3(x, y, z);\r\n        this.gridPosition = new THREE.Vector2(x, y);\r\n        this.drawPosition = new THREE.Vector2(x, y);\r\n        this.scale = new THREE.Vector3(scaleX || 1, scaleY || 1, scaleZ || 1);\r\n        this.quaternion = new THREE.Quaternion();\r\n        this.quaternion.setFromAxisAngle( new THREE.Vector3( rotationX, rotationY, rotationZ ), Math.PI / 2 );        \r\n        this.parent.transform = this;         \r\n\r\n    }\r\n  \r\n\r\n    postUpdate() {\r\n        \r\n        // Update grid and draw positions\r\n        this.lastPosition.x = this.position.x;\r\n        this.lastPosition.y = this.position.y;\r\n        this.lastPosition.z = this.position.z;\r\n\r\n    }\r\n    \r\n}",
        "fileName": "Transform"
      },
      "Animator": {
        "fileName": "Animator",
        "script": "class Animator extends engine.Component {\n    \n    \n    init({ objectType, spawnType}) {\n        if(!this.animations) this.animations = {};\n        this.currentAnimation = \"idle\";\n        this.currentFrame = 0;\n        this.frameDuration = .166; // 10 frames per animation frame (~0.166s at 60 FPS)\n        this.frameTimer = 0;\n\n        this.baseSpeed = this.parent.getComponent(\"stats\")?.stats.speed || 1;\n    }\n\n    update() {\n        \n        this.frameTimer += this.game.deltaTime;\n        let currentSpeedPercent = this.parent.getComponent(\"stats\")?.stats.speed / this.baseSpeed || 1;\n\n        if (this.frameTimer >= this.frameDuration / currentSpeedPercent && this.animations[this.currentAnimation]) {\n            this.frameTimer = 0;\n            const animFrames = this.animations[this.currentAnimation];\n            this.currentFrame = (this.currentFrame + 1) % animFrames.length;\n        }\n        // Sync direction with Renderer (if separate)\n        const renderer = this.parent.getComponent(\"Renderer\");\n        if (renderer && this.animations[this.currentAnimation] && this.animations[this.currentAnimation][this.currentFrame]) {\n            renderer.images = this.animations[this.currentAnimation][this.currentFrame];\n        }\n    }\n\n    setAnimation(animationType) {\n        if (this.animations[animationType] && this.currentAnimation !== animationType) {\n            this.currentAnimation = animationType;\n            this.currentFrame = 0;\n            this.frameTimer = 0;\n        }\n    }\n    \n}"
      },
      "ArrayTracker": {
        "fileName": "ArrayTracker",
        "script": "class ArrayTracker extends engine.Component {\r\n    \r\n    init( {objectType}) {\r\n        this.arr = objectType;\r\n        if(!this.game.state[this.arr]){\r\n            this.game.state[this.arr] = [];\r\n        }\r\n        this.game.state[this.arr].push(this.parent);\r\n    }\r\n\r\n    destroy(){\r\n        let index = this.game.state[this.arr].indexOf(this.parent);\r\n        this.game.state[this.arr].splice(index, 1);        \r\n    }\r\n}"
      },
      "AudioManager": {
        "title": "AudioManager",
        "fileName": "AudioManager",
        "script": "class AudioManager extends engine.Component {\n\n    init() {\n        this.isInitialized = false;\n        this.bindInitialization();\n    }\n\n    bindInitialization() {\n        const initHandler = () => {            \n            if (!this.isInitialized) {\n                this.initialize();\n            }\n        };\n        \n        document.addEventListener('click', initHandler, { once: true });\n        document.addEventListener('keydown', initHandler, { once: true });\n    }\n\n    async initialize() {\n        class SoundPool {\n            constructor(audioContext, destination, poolSize = 8) {\n                this.audioContext = audioContext;\n                this.destination = destination;\n                this.poolSize = poolSize;\n                this.sources = [];\n                this.initializePool();\n            }\n\n            initializePool() {\n                for (let i = 0; i < this.poolSize; i++) {\n                    this.sources.push(this.createSource());\n                }\n            }\n\n            createSource() {\n                const source = {\n                    active: false,\n                    id: null,\n                    envelopeGain: this.audioContext.createGain(),\n                    gainNode: this.audioContext.createGain(),\n                    filter: this.audioContext.createBiquadFilter(),\n                    distortion: this.audioContext.createWaveShaper(),\n                    compressor: this.audioContext.createDynamicsCompressor(),\n                    pannerNode: this.audioContext.createStereoPanner(),\n                    delay: this.audioContext.createDelay(5.0),\n                    delayGain: this.audioContext.createGain(),\n                    convolver: this.audioContext.createConvolver(),\n                    reverbGain: this.audioContext.createGain(),\n                    noiseFilter: this.audioContext.createBiquadFilter(),\n                    noiseGain: this.audioContext.createGain(),\n                    destination: this.destination\n                };\n\n                source.filter.type = 'lowpass';\n                source.filter.frequency.setValueAtTime(20000, this.audioContext.currentTime);\n                source.filter.Q.setValueAtTime(0.5, this.audioContext.currentTime);\n\n                source.noiseFilter.type = 'lowpass';\n                source.noiseFilter.frequency.setValueAtTime(2000, this.audioContext.currentTime);\n                source.noiseFilter.Q.setValueAtTime(1, this.audioContext.currentTime);\n                \n                source.noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.distortion.curve = null;\n                source.distortion.oversample = '4x';\n\n                source.compressor.threshold.setValueAtTime(-24, this.audioContext.currentTime);\n                source.compressor.knee.setValueAtTime(30, this.audioContext.currentTime);\n                source.compressor.ratio.setValueAtTime(12, this.audioContext.currentTime);\n                source.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);\n                source.compressor.release.setValueAtTime(0.25, this.audioContext.currentTime);\n\n                source.pannerNode.pan.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.delay.delayTime.setValueAtTime(0.3, this.audioContext.currentTime);\n                source.delayGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.reverbGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                const chain = [\n                    source.envelopeGain,\n                    source.gainNode,\n                    source.filter,\n                    source.distortion,\n                    source.compressor,\n                    source.pannerNode\n                ];\n\n                for (let i = 0; i < chain.length - 1; i++) {\n                    chain[i].connect(chain[i + 1]);\n                }\n\n                // Route delay and reverb after filter\n                source.filter.connect(source.delay);\n                source.delay.connect(source.delayGain);\n                source.delayGain.connect(source.delay);\n                source.delayGain.connect(source.pannerNode);\n\n                source.filter.connect(source.convolver);\n                source.convolver.connect(source.reverbGain);\n                source.reverbGain.connect(source.pannerNode);\n\n                source.pannerNode.connect(source.destination);\n\n                return source;\n            }\n\n            getSource() {\n                let source = this.sources.find(src => !src.active && (!src.lastUsed || this.audioContext.currentTime - src.lastUsed > 1));\n                if (!source && this.sources.length < this.poolSize * 2) {\n                    source = this.createSource();\n                    this.sources.push(source);\n                }\n                if (source) {\n                    source.active = true;\n                    source.gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);\n                    source.envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.delayGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.reverbGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                }\n                return source;\n            }\n\n            releaseSource(source) {\n                if (source) {\n                    source.active = false;\n                    source.id = null;\n                    const now = this.audioContext.currentTime;\n            \n                    // Reset all nodes\n                    source.filter.frequency.cancelScheduledValues(now);\n                    source.filter.frequency.setValueAtTime(20000, now);\n                    source.distortion.curve = null;\n                    source.pannerNode.pan.setValueAtTime(0, now);\n                    source.envelopeGain.gain.setValueAtTime(0, now);\n                    source.gainNode.gain.setValueAtTime(1, now);\n                    source.delayGain.gain.setValueAtTime(0, now);\n                    source.reverbGain.gain.setValueAtTime(0, now);\n                    source.noiseGain.gain.setValueAtTime(0, now);\n            \n                    // Disconnect and clear sources if they exist\n                    if (source.source) {\n                        try {\n                            source.source.stop(now);\n                            source.source.disconnect();\n                        } catch (e) {\n                            console.warn('Error stopping source:', e);\n                        }\n                        source.source = null;\n                    }\n                    \n                    if (source.noiseSource) {\n                        try {\n                            source.noiseSource.stop(now);\n                            source.noiseSource.disconnect();\n                        } catch (e) {\n                            console.warn('Error stopping noise source:', e);\n                        }\n                        source.noiseSource = null;\n                    }\n            \n                    source.lastUsed = now;\n                }\n            }\n\n            destroy() {\n                this.sources.forEach(source => {\n                    source.envelopeGain.disconnect();\n                    source.gainNode.disconnect();\n                    source.filter.disconnect();\n                    source.distortion.disconnect();\n                    source.compressor.disconnect();\n                    source.pannerNode.disconnect();\n                    source.delay.disconnect();\n                    source.delayGain.disconnect();\n                    source.convolver.disconnect();\n                    source.reverbGain.disconnect();\n                    source.noiseFilter.disconnect();\n                    source.noiseGain.disconnect();\n                });\n                this.sources = [];\n            }\n        }\n        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        this.masterBus = this.createAudioBus('master');\n        this.musicBus = this.createAudioBus('music');\n        this.sfxBus = this.createAudioBus('sfx');\n        this.uiBus = this.createAudioBus('ui');\n        this.musicBus.connect(this.masterBus);\n        this.sfxBus.connect(this.masterBus);\n        this.uiBus.connect(this.masterBus);\n        this.masterBus.connect(this.audioContext.destination);\n        this.soundPools = {\n            sfx: new SoundPool(this.audioContext, this.sfxBus.input, 6),\n            music: new SoundPool(this.audioContext, this.musicBus.input, 2),\n            ui: new SoundPool(this.audioContext, this.uiBus.input, 3)\n        };\n        this.buffers = {};\n        this.activeSounds = new Set();\n        if (this.audioContext.state === 'suspended') {\n            await this.audioContext.resume();\n        }\n        this.isInitialized = true;\n    }\n\n    createAudioBus(name) {\n        const bus = {\n            name,\n            input: this.audioContext.createGain(),\n            compressor: this.audioContext.createDynamicsCompressor(),\n            output: this.audioContext.createGain()\n        };\n        \n        bus.input.connect(bus.compressor);\n        bus.compressor.connect(bus.output);\n        \n        bus.connect = (destination) => {\n            bus.output.connect(destination.input || destination);\n        };\n        \n        bus.setVolume = (value) => {\n            const now = this.audioContext.currentTime;\n            bus.output.gain.cancelScheduledValues(now);\n            bus.output.gain.setTargetAtTime(\n                value <= 0 ? 0.000001 : value,\n                now,\n                0.02\n            );\n        };\n        \n        return bus;\n    }\n\n    getSynthSound(soundCollectionName, soundName) {\n        if (this.game.getCollections()[soundCollectionName]?.[soundName]) {\n            return this.game.getCollections()[soundCollectionName][soundName].audio;\n        }\n        console.warn('sound not found', soundCollectionName, soundName);\n        return null;\n    }\n\n    playSound(soundCollectionName, soundName) {\n        let data = this.getSynthSound(soundCollectionName, soundName);\n        if (data) {\n            this.playSynthSound(`${soundCollectionName}_${soundName}`, data);\n        }\n    }\n\n    playSynthSound(soundId, soundConfig, options = {}) {\n        if (!this.isInitialized) {\n            this.initialize();\n            return;\n        }        \n        if (this.audioContext.state === 'suspended') {\n            return;\n        }\n        const category = options.category || 'sfx';\n        const pool = this.soundPools[category];\n        \n        if (!pool) {\n            console.warn(`No sound pool for category ${category}`);\n            return null;\n        }\n        \n        let instanceCount = 0;\n        this.activeSounds.forEach(sound => {\n            if (sound.id === soundId) instanceCount++;\n        });\n        \n        if (instanceCount >= (options.maxInstances || 3)) {\n            console.warn(`Max instances reached for sound ${soundId}`);\n            return null;\n        }\n        \n        const sound = pool.getSource();\n        if (!sound) {\n            console.warn(`No available source for sound ${soundId}`);\n            return null;\n        }\n        \n        sound.id = soundId;\n        sound.category = category;\n        \n        // Create main oscillator\n        const oscillator = this.createSynthSource(soundConfig);\n        sound.source = oscillator;\n        oscillator.connect(sound.envelopeGain);\n        \n        // Add noise generator if configured\n        if (soundConfig.noise && soundConfig.noise.amount > 0) {\n            this.applyNoiseToSound(sound, soundConfig.noise);\n        }\n        \n        this.createEnvelopeFromConfig(soundConfig.envelope, sound.envelopeGain, soundConfig.duration);\n        \n        if (soundConfig.effects) {\n            this.applySynthEffects(sound, soundConfig.effects, soundConfig);\n        } \n        \n        this.configureSoundInstance(sound, options);\n        \n        const now = this.audioContext.currentTime;\n        oscillator.start(now);\n        \n        // Start noise generator if it exists\n        if (sound.noiseSource) {\n            sound.noiseSource.start(now);\n        }\n        \n        const duration = soundConfig.duration || 1;\n        const release = (soundConfig.envelope?.release) || 0.3;\n        let totalDuration = duration + release;\n        \n        if (soundConfig.effects?.delay?.time) {\n            const delayTail = soundConfig.effects.delay.time * 3;\n            if (totalDuration < delayTail) {\n                totalDuration = delayTail;\n            }\n        }\n        \n        oscillator.stop(now + totalDuration + 0.02);\n        if (sound.noiseSource) {\n            sound.noiseSource.stop(now + totalDuration + 0.02);\n        }\n        \n        this.activeSounds.add(sound);\n        \n        oscillator.onended = () => {\n            setTimeout(() => {\n                sound.active = false;\n                this.activeSounds.delete(sound);\n                pool.releaseSource(sound);\n            }, (soundConfig.effects?.delay?.time || 0) * 1000 * 3);\n        };\n        \n        return sound;\n    }\n\n    createSynthSource(config) {\n        // Default to oscillator unless waveform is 'noise'\n        const oscillator = config.waveform === 'noise'\n            ? this.createNoiseSource('white') \n            : this.audioContext.createOscillator();\n    \n        if (config.waveform !== 'noise') {\n            oscillator.type = config.waveform || 'sine';\n            const baseFreq = config.frequency || 440;\n            const now = this.audioContext.currentTime;\n    \n            // Initialize frequency\n            oscillator.frequency.cancelScheduledValues(now);\n            oscillator.frequency.setValueAtTime(baseFreq, now);\n    \n            // Apply pitch envelope if defined\n            if (config.pitchEnvelope) {\n                const startMultiplier = config.pitchEnvelope.start ?? 1;\n                const endMultiplier = config.pitchEnvelope.end ?? 1;\n                const envelopeTime = config.pitchEnvelope.time ?? config.duration ?? 1;\n    \n                if (startMultiplier !== 1 || endMultiplier !== 1) {\n                    const startFreq = baseFreq * startMultiplier;\n                    const endFreq = baseFreq * endMultiplier;\n    \n                    oscillator.frequency.setValueAtTime(startFreq, now);\n                    oscillator.frequency.exponentialRampToValueAtTime(\n                        Math.max(endFreq, 0.01),\n                        now + envelopeTime\n                    );\n                }\n            }\n        }\n    \n        return oscillator;\n    }\n\n    applyNoiseToSound(sound, noiseConfig) {\n        if (!noiseConfig || noiseConfig.amount <= 0) return;\n\n        const noiseType = noiseConfig.type || 'white';\n        const noiseAmount = Math.min(1, Math.max(0, noiseConfig.amount));\n        \n        // Create the noise source\n        sound.noiseSource = this.createNoiseSource(noiseType);\n        \n        // Configure noise filter if specified\n        if (noiseConfig.filter && noiseConfig.filter.type !== 'none') {\n            sound.noiseFilter.type = noiseConfig.filter.type || 'lowpass';\n            sound.noiseFilter.frequency.setValueAtTime(\n                noiseConfig.filter.frequency || 2000, \n                this.audioContext.currentTime\n            );\n        }\n        \n        // Set noise gain based on the amount\n        sound.noiseGain.gain.setValueAtTime(noiseAmount, this.audioContext.currentTime);\n        \n        // Connect noise through the filter and envelope\n        sound.noiseSource.connect(sound.noiseFilter);\n        sound.noiseFilter.connect(sound.noiseGain);\n        sound.noiseGain.connect(sound.envelopeGain);\n    }\n\n    createNoiseSource(noiseType = 'white') {\n        const bufferSize = this.audioContext.sampleRate * 2;\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\n        const output = noiseBuffer.getChannelData(0);\n        \n        // Generate different types of noise\n        switch (noiseType) {\n            case 'pink':\n                this.generatePinkNoise(output);\n                break;\n            case 'brown':\n                this.generateBrownNoise(output);\n                break;\n            case 'white':\n            default:\n                this.generateWhiteNoise(output);\n                break;\n        }\n        \n        const source = this.audioContext.createBufferSource();\n        source.buffer = noiseBuffer;\n        source.loop = true;\n        \n        return source;\n    }\n\n    generateWhiteNoise(output) {\n        for (let i = 0; i < output.length; i++) {\n            output[i] = Math.random() * 2 - 1;\n        }\n    }\n\n    generatePinkNoise(output) {\n        // Pink noise algorithm (approximation using Paul Kellet's method)\n        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;\n        \n        for (let i = 0; i < output.length; i++) {\n            const white = Math.random() * 2 - 1;\n            \n            // Filter white noise to create pink noise\n            b0 = 0.99886 * b0 + white * 0.0555179;\n            b1 = 0.99332 * b1 + white * 0.0750759;\n            b2 = 0.96900 * b2 + white * 0.1538520;\n            b3 = 0.86650 * b3 + white * 0.3104856;\n            b4 = 0.55000 * b4 + white * 0.5329522;\n            b5 = -0.7616 * b5 - white * 0.0168980;\n            \n            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;\n            b6 = white * 0.115926;\n        }\n    }\n\n    generateBrownNoise(output) {\n        // Brown noise algorithm (random walk)\n        let lastValue = 0;\n        \n        for (let i = 0; i < output.length; i++) {\n            // Small random change from previous value\n            const white = Math.random() * 2 - 1;\n            lastValue = (lastValue + (0.02 * white)) / 1.02;\n            \n            // Keep within range\n            output[i] = lastValue * 3.5; // Amplify to make it audible\n        }\n        \n        // Normalize to prevent clipping\n        const max = Math.max(...Array.from(output).map(Math.abs));\n        if (max > 0) {\n            for (let i = 0; i < output.length; i++) {\n                output[i] /= max;\n            }\n        }\n    }\n\n    createEnvelopeFromConfig(envelope, gainNode, duration = 1) {\n        if (!envelope) {\n            console.warn('No envelope provided, using default');\n            envelope = { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 };\n        }\n        \n        const now = this.audioContext.currentTime;\n        \n        const attack = Math.max(0.01, envelope.attack || 0.01);\n        const decay = Math.max(0, envelope.decay || 0.1);\n        const sustain = Math.max(0, Math.min(1, envelope.sustain || 0.7));\n        const release = Math.max(0.02, envelope.release || 0.3);\n        \n        gainNode.gain.cancelScheduledValues(now);\n        gainNode.gain.setValueAtTime(0, now);\n        gainNode.gain.linearRampToValueAtTime(1, now + attack);\n        gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);\n        gainNode.gain.setValueAtTime(sustain, now + duration);\n        gainNode.gain.setTargetAtTime(0.0001, now + duration, release / 3);\n        gainNode.gain.setValueAtTime(0, now + duration + release); // Absolute zero\n    }\n\n    applySynthEffects(sound, effectsConfig, soundConfig) {\n        const now = this.audioContext.currentTime;\n        \n        // Filter\n        if (effectsConfig.filter) {\n            sound.filter.type = effectsConfig.filter.type || 'lowpass';\n            sound.filter.frequency.setValueAtTime(effectsConfig.filter.frequency || 20000, now);\n            sound.filter.Q.setValueAtTime(effectsConfig.filter.Q || 0.5, now);\n            \n            // Apply pitch envelope to filter for noise waveforms\n            if (sound.source.buffer && soundConfig.pitchEnvelope && (soundConfig.pitchEnvelope.start !== 1 || soundConfig.pitchEnvelope.end !== 1)) {\n                const baseFreq = soundConfig.frequency || 100;\n                const startFreq = baseFreq * (soundConfig.pitchEnvelope.start + 1);\n                const endFreq = baseFreq * soundConfig.pitchEnvelope.end;\n                const duration = soundConfig.pitchEnvelope.time || soundConfig.duration || 1;\n                \n                sound.filter.frequency.cancelScheduledValues(now);\n                sound.filter.frequency.setValueAtTime(startFreq, now);\n                sound.filter.frequency.exponentialRampToValueAtTime(\n                    Math.max(endFreq, 0.01),\n                    now + duration\n                );\n                sound.filter.frequency.exponentialRampToValueAtTime(\n                    Math.max(endFreq * 0.5, 0.01),\n                    now + soundConfig.duration + (soundConfig.envelope?.release || 0.3)\n                );\n            }\n        }\n        \n        // Distortion\n        if (effectsConfig.distortion && effectsConfig.distortion > 0) {\n            sound.distortion.curve = this.makeDistortionCurve(effectsConfig.distortion);\n        } else {\n            sound.distortion.curve = null;\n        }\n        \n        // Delay\n        if (effectsConfig.delay && effectsConfig.delay.feedback > 0) {\n            sound.delay.delayTime.setValueAtTime(effectsConfig.delay.time || 0.3, now);\n            sound.delayGain.gain.setValueAtTime(Math.min(effectsConfig.delay.feedback || 0, 0.8), now);\n            sound.delayGain.gain.setTargetAtTime(0, now + soundConfig.duration + (soundConfig.envelope?.release || 0.3), 0.1);\n        } else {\n            sound.delayGain.gain.setValueAtTime(0, now);\n        }\n        \n        // Reverb\n        if (effectsConfig.reverb && effectsConfig.reverb > 0) {\n            this.generateImpulseResponse(sound.convolver);\n            sound.reverbGain.gain.setValueAtTime(Math.min(effectsConfig.reverb, 1), now);\n            sound.reverbGain.gain.setTargetAtTime(0, now + soundConfig.duration + (soundConfig.envelope?.release || 0.3), 0.2);\n        } else {\n            sound.reverbGain.gain.setValueAtTime(0, now);\n        }\n        \n        // Panning\n        if (effectsConfig.pan !== undefined) {\n            sound.pannerNode.pan.setValueAtTime(Math.max(-1, Math.min(1, effectsConfig.pan)), now);\n        }\n    }\n\n    configureSoundInstance(sound, options) {\n        const now = this.audioContext.currentTime;\n        \n        if (options.volume !== undefined) {\n            sound.gainNode.gain.cancelScheduledValues(now);\n            sound.gainNode.gain.setTargetAtTime(\n                options.volume <= 0 ? 0.000001 : Math.max(0, Math.min(options.volume, 1)),\n                now,\n                0\n            );\n        } else {\n            sound.gainNode.gain.cancelScheduledValues(now);\n            sound.gainNode.gain.setTargetAtTime(\n                0.005,\n                now,\n                0\n            );\n        }\n        if (options.position && sound.pannerNode.positionX) {\n            const pos = options.position;\n            sound.pannerNode.positionX.setValueAtTime(pos.x || 0, now);\n            sound.pannerNode.positionY.setValueAtTime(pos.y || 0, now);\n            sound.pannerNode.positionZ.setValueAtTime(pos.z || 0, now);\n        }\n        \n        if (options.pitch && sound.source && sound.source.playbackRate) {\n            sound.source.playbackRate.setValueAtTime(options.pitch, now);\n        }\n    }\n\n    generateImpulseResponse(convolver) {\n        const length = this.audioContext.sampleRate * 1.5; // Shorter impulse\n        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);\n        \n        for (let channel = 0; channel < 2; channel++) {\n            const impulseData = impulse.getChannelData(channel);\n            for (let i = 0; i < length; i++) {\n                const decay = Math.pow(1 - i / length, 2);\n                impulseData[i] = (Math.random() * 2 - 1) * decay;\n            }\n        }\n        \n        convolver.buffer = impulse;\n    }\n\n    makeDistortionCurve(amount) {\n        const k = Math.max(amount, 0) * 10;\n        const n_samples = 44100;\n        const curve = new Float32Array(n_samples);\n        const deg = Math.PI / 180;\n        for (let i = 0; i < n_samples; i++) {\n            const x = (i * 2) / n_samples - 1;\n            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n        }\n        return curve;\n    }\n\n    stopSound(sound) {\n        if (!sound) return;\n        \n        const now = this.audioContext.currentTime;\n        \n        if (sound.gainNode) {\n            sound.gainNode.gain.cancelScheduledValues(now);\n            sound.gainNode.gain.setValueAtTime(sound.gainNode.gain.value || 0, now);\n            sound.gainNode.gain.linearRampToValueAtTime(0, now + 0.05);\n        }\n        \n        if (sound.source) {\n            try {\n                sound.source.stop(now + 0.06);\n            } catch (e) {\n                console.warn('Error stopping source:', e);\n            }\n        }\n        \n        if (sound.noiseSource) {\n            try {\n                sound.noiseSource.stop(now + 0.06);\n            } catch (e) {\n                console.warn('Error stopping noise source:', e);\n            }\n        }\n        \n        sound.active = false;\n        this.activeSounds.delete(sound);\n    }\n\n    stopAllSounds() {\n        this.activeSounds.forEach(sound => {\n            this.stopSound(sound);\n        });\n        this.activeSounds.clear();\n    }\n}"
      },
      "Attacker": {
        "fileName": "Attacker",
        "script": "class Attacker extends engine.Component {\r\n    \r\n init() {        \r\n        this.stats = this.getComponent('stats').stats;    \r\n        this.level = 1;\r\n        this.target = null;\r\n        this.projectiles = [];  \r\n        this.cooldown = 0;\r\n    }\r\n\r\n    update() {\r\n        if (this.cooldown > 0) this.cooldown -= this.game.deltaTime;\r\n\r\n        // Validate current target\r\n        if (this.target) {\r\n            const distance = Math.hypot(\r\n                this.target.transform.position.x - this.parent.transform.position.x,\r\n                this.target.transform.position.y - this.parent.transform.position.y\r\n            );\r\n            if (distance > this.stats.range || this.target.getComponent('health').hp <= 0) {\r\n                this.target = null;\r\n            }\r\n        }\r\n\r\n        // Find target if none\r\n        if (!this.target) {\r\n            this.findTarget();\r\n        }\r\n\r\n        // Attack if ready and has target\r\n        if (this.cooldown <= 0 && this.target) {\r\n            this.attack();\r\n        }\r\n\r\n        if (this.cooldown <= 0 && this.stats.mineAmt > 0) {\r\n            this.gather();\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    findTarget() {\r\n        this.target = null;\r\n        let furthestEnemy = null;\r\n        let furthestDistance = -1;\r\n        const nearbyEntities = this.game.spatialGrid.getNearbyEntities(\r\n            this.parent.transform.gridPosition.x, \r\n            this.parent.transform.gridPosition.y, \r\n            this.stats.range,\r\n            \"enemy\"\r\n        );\r\n        for (let enemy of nearbyEntities) {\r\n            let enemyHP = enemy.getComponent(\"health\").hp;\r\n            let followPath = enemy.getComponent('followPath');\r\n            if (enemyHP <= 0) continue;          \r\n\r\n            let distanceToEnd = this.game.state.paths[followPath.pathIndex].length - followPath.indexInPath;\r\n            if (distanceToEnd > furthestDistance) {\r\n                furthestDistance = followPath.indexInPath;\r\n                furthestEnemy = enemy;\r\n            }  \r\n        }\r\n        \r\n        this.target = furthestEnemy;\r\n    }\r\n\r\n    gather() {\r\n        this.game.state.bloodShards += this.stats.mineAmt;\r\n        this.cooldown = this.stats.attackSpeed;\r\n    }\r\n\r\n    attack() {\r\n        if (!this.target) return; \r\n        this.launchProjectile();\r\n        this.cooldown = this.stats.attackSpeed;\r\n    }\r\n    \r\n    launchProjectile() {\r\n        this.stats = this.getComponent('stats').stats;    \r\n        let projectileType = this.stats.projectile;\r\n        let projectileDef = this.game.getCollections().projectilePrefabs[projectileType];\r\n        \r\n\r\n        let projStats = { ...projectileDef };\r\n        delete projStats.render;\r\n        projStats.baseDamage = this.stats.damage || 1; \r\n        projStats.speed = this.stats.speed || 5;     \r\n        projStats.piercing = this.stats.piercing || 0;\r\n        projStats.splashRadius = this.stats.splashRadius || 0;\r\n        projStats.critChance = this.stats.critChance || 0.05;\r\n        projStats.critMultiplier = this.stats.critMultiplier || 2;\r\n    \r\n       \tif(projectileDef.customRenderer == \"lightning\") {\r\n         \tthis.game.spawn('lightningProjectile', { objectType: \"projectilePrefabs\", spawnType: projectileType, target: this.target, owner: this.parent, stats: projStats }, this.parent.transform.position);\r\n        } else if(projectileDef.isBallistic) {\r\n         \tthis.game.spawn('ballisticProjectile', { objectType: \"projectilePrefabs\", spawnType: projectileType, target: this.target, owner: this.parent, stats: projStats }, this.parent.transform.position);\r\n        } else if( this.stats.projectileCount > 0 ) {\r\n          this.game.spawn('multiShotProjectile', { objectType: \"projectilePrefabs\", spawnType: projectileType, target: this.target, owner: this.parent, stats: projStats }, this.parent.transform.position);\r\n        } else {\r\n          this.game.spawn('projectile', { objectType: \"projectilePrefabs\", spawnType: projectileType, target: this.target, owner: this.parent, stats: projStats }, this.parent.transform.position);\r\n        }\r\n    }\r\n}"
      },
      "BallisticProjectile": {
        "fileName": "BallisticProjectile",
        "script": "class BallisticProjectile extends engine.Component {\r\n    \r\n    \r\ninit({ spawnType, owner, target, stats }) {\r\n    this.type = spawnType;\r\n    this.def = this.game.getCollections().projectilePrefabs[this.type];\r\n    this.owner = owner;\r\n    this.target = target;\r\n    this.stats = stats;\r\n    this.piercedEnemies = [];\r\n    this.ownerStats = this.owner.getComponent(\"stats\").stats;\r\n    this.distanceTraveled = 0;\r\n    this.distanceToSpawnParticle = 1;\r\n    \r\n    // Ballistic trajectory variables\r\n    this.startPosition = { ...this.parent.transform.position, z: 10 }; // Start 10 units above ground\r\n    this.targetPosition = { ...this.target.transform.position, z: 0 };\r\n    this.time = 0;\r\n    \r\n    this.totalDist = Math.sqrt(\r\n        (this.targetPosition.x - this.startPosition.x) ** 2 + \r\n        (this.targetPosition.y - this.startPosition.y) ** 2\r\n    );\r\n    this.maxHeight = this.totalDist / Math.PI;\r\n    \r\n    // Initialize position with Z component\r\n    this.parent.transform.position.z = this.startPosition.z;\r\n    this.positionZ = this.startPosition.z;\r\n    \r\n    // Animation state variables\r\n    this.lastZPosition = this.positionZ;\r\n\r\n    \r\n    this.peakThreshold = this.maxHeight * 0.1; // 10% threshold for idle at peak\r\n    this.currentAnimState = 'ascend';\r\n    if(this.stats.attackSound){\r\n        this.game.audioManager.playSound('attackSounds', this.stats.attackSound);\r\n    }\r\n}\r\n\r\nsetAnimation(anim) {\r\n\r\n    if(this.game.getCollections().configs.game.is3D) {\r\n        this.modelRenderer = this.parent.getComponent('modelRenderer');\r\n        this.modelRenderer?.setAnimation(anim);\r\n    } else {\r\n        this.animator = this.parent.getComponent('animator');\r\n        this.animator?.setAnimation(anim);\r\n    }\r\n}\r\n\r\nupdate() {\r\n    this.parent.transform.position.z = this.positionZ;\r\n    \r\n    // Save previous z position to detect direction change\r\n    this.lastZPosition = this.positionZ;\r\n\r\n    // Calculate progress (0 to 1)\r\n    this.time += this.game.deltaTime;\r\n    const dx = this.targetPosition.x - this.parent.transform.position.x;\r\n    const dy = this.targetPosition.y - this.parent.transform.position.y;\r\n    const distSq = dx * dx + dy * dy;\r\n    let dist = Math.sqrt(distSq);\r\n    const speed = this.stats.speed;\r\n    this.parent.transform.position.x += (dx / dist) * speed / (Math.PI);\r\n    this.parent.transform.position.y += (dy / dist) * speed / (Math.PI);\r\n\r\n\r\n    const currentDist = Math.sqrt(\r\n        (this.parent.transform.position.x - this.startPosition.x) ** 2 + \r\n        (this.parent.transform.position.y - this.startPosition.y) ** 2\r\n    );\r\n    const xyprogressToTarget = Math.min(1, currentDist / this.totalDist);\r\n\r\n    // Parabolic trajectory calculation (2:1 isometric adjusted)\r\n    this.parent.transform.position.z = this.maxHeight * (1 - Math.pow(2 * xyprogressToTarget - 1, 2));\r\n\r\n    this.positionZ = this.parent.transform.position.z;\r\n    \r\n    // Calculate distance from peak height to determine if we're near the top\r\n    const distanceFromPeak = Math.abs(this.positionZ - this.maxHeight);\r\n    \r\n    // Check if animation state needs to change based on z movement and proximity to peak\r\n    if( xyprogressToTarget < .075 ) {\r\n        if (this.currentAnimState !== 'launch') {\r\n            this.setAnimation('launch');\r\n            this.currentAnimState = 'launch';\r\n        }\r\n    // } else if( xyprogressToTarget > .95 ) {\r\n    //     if (this.currentAnimState !== 'land') {\r\n    //         this.animator.setAnimation('land');\r\n    //         this.currentAnimState = 'land';\r\n    //     }\r\n    } else if (distanceFromPeak <= this.peakThreshold) {\r\n        // We're near the peak of the trajectory\r\n        if (this.currentAnimState !== 'idle') {\r\n            this.setAnimation('idle');\r\n            this.currentAnimState = 'idle';\r\n        }\r\n    } else if (this.positionZ < this.lastZPosition) {\r\n        // We're descending and not near the peak\r\n        if (this.currentAnimState !== 'descend') {\r\n            this.setAnimation('descend');\r\n            this.currentAnimState = 'descend';\r\n        }\r\n    } else if (this.positionZ > this.lastZPosition) {\r\n        // We're ascending and not near the peak\r\n        if (this.currentAnimState !== 'ascend') {\r\n            this.setAnimation('ascend');\r\n            this.currentAnimState = 'ascend';\r\n        }\r\n    }\r\n    \r\n    // Check if we've hit the ground (Z <= 0)\r\n    if (this.parent.transform.position.z <= 0) {\r\n        this.parent.transform.position.z = 0; // Snap to ground\r\n\r\n        // Hit detection - same as before but at current position\r\n        const targetDistSq = (this.parent.transform.position.x - this.target.transform.position.x) ** 2 + \r\n                            (this.parent.transform.position.y - this.target.transform.position.y) ** 2;\r\n\r\n\r\n\r\n            // We missed the target but hit the ground - maybe still do splash damage\r\n        if (this.stats.splashRadius > 0) {\r\n            this.processSplashDamage();\r\n        }\r\n        this.parent.destroy();\r\n        if(this.stats.hitSound){\r\n            this.game.audioManager.playSound('hitSounds', this.stats.hitSound);\r\n        }\r\n\r\n        return;\r\n    }\r\n    \r\n    // Update distance traveled for particles\r\n    const tDx = this.parent.lastPosition.x - this.parent.transform.position.x;\r\n    const tDy = this.parent.lastPosition.y - this.parent.transform.position.y;\r\n    const tDist = Math.sqrt(tDx * tDx + tDy * tDy);\r\n    this.distanceTraveled += tDist;\r\n    \r\n    if (this.def.particle && this.distanceTraveled > this.distanceToSpawnParticle) {\r\n        let position = new THREE.Vector3(this.parent.lastPosition.x + Math.random() * 4 - 2, this.parent.lastPosition.y + Math.random() * 4 - 2, this.parent.transform.position.z + Math.random() * 4 - 2)\r\n        this.game.spawn(\"particle\", { objectType: \"particlePrefabs\", spawnType: this.def.particle }, position);\r\n\r\n        this.distanceTraveled = 0;\r\n        this.distanceToSpawnParticle += Math.random() * 2;\r\n    }\r\n}\r\n\r\n\r\nprocessSplashDamage() {\r\n    const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(\r\n        this.parent.transform.gridPosition.x, \r\n        this.parent.transform.gridPosition.y, \r\n        this.stats.splashRadius,\r\n        \"enemy\"\r\n    );\r\n    this.game.spawn(\"explosion\", { radius: this.stats.splashRadius },this.parent.transform.position);\r\n    for (const enemy of nearbyEnemies) {\r\n        if (enemy.isDead) continue;\r\n        \r\n        const dx = enemy.transform.position.x - this.parent.transform.position.x;\r\n        const dy = enemy.transform.position.y - this.parent.transform.position.y;\r\n        const distSq = dx * dx + dy * dy;\r\n        \r\n        let gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const splashRadiusSq = this.stats.splashRadius * this.stats.splashRadius * gridSize * gridSize;\r\n        \r\n        if (distSq <= splashRadiusSq) {\r\n            let enemyHealth = enemy.getComponent(\"health\");\r\n            let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n            let enemyStats = enemy.getComponent(\"stats\");\r\n            let enemyStatClone = { ...enemyStats.stats };\r\n            enemyStatClone.energyShield = enemyEnergyShield.energyShield;\r\n            \r\n            let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStatClone);\r\n            if (!damageResult.wasEvaded) {\r\n                enemyHealth.hp -= damageResult.damageDealt;\r\n                enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n                this.game.spawn(\"hitEffect\", { damageType: this.stats.damageType , lifeSpan: .3},enemy.transform.position);\r\n                if (this.ownerStats.slowAmount) {\r\n                    enemyStats.addEffect(this.game.getCollections().effects.slow, this.game.effects.slow, this.ownerStats.slowAmount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n}"
      },
      "ChainProjectile": {
        "fileName": "ChainProjectile",
        "script": "class ChainProjectile extends engine.Component {\r\n    \r\n    init( { spawnType, owner, target, stats }) {        \r\n        this.type = spawnType;\r\n        this.owner = owner;\r\n        this.target = target;\r\n        this.stats = stats;\r\n        this.piercedEnemies = [];\r\n        this.ownerStats = this.owner.getComponent(\"stats\").stats;\r\n        this.chainTargets = []; // Store all targets hit in one frame\r\n        this.hasStruck = false; // Flag to strike only once\r\n    }\r\n\r\n    update() {\r\n        if (this.hasStruck) {\r\n            this.parent.destroy(); // Destroy after one frame of striking\r\n            return;\r\n        }\r\n\r\n        if (!this.target || this.target.destroyed) {\r\n            this.parent.destroy();\r\n            return;\r\n        }\r\n\r\n        // Strike the initial target\r\n        let targetHealth = this.target.getComponent(\"health\");\r\n        let targetEnergyShield = this.target.getComponent(\"energyshield\");\r\n        let targetStats = {...this.target.getComponent(\"stats\").stats};\r\n        targetStats.energyShield = targetEnergyShield.energyShield;\r\n        let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, targetStats);                    \r\n        if( damageResult.wasEvaded ) { return; }         \r\n        targetHealth.hp -= damageResult.damageDealt;\r\n        targetEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n        this.piercedEnemies.push(this.target);\r\n        this.chainTargets.push(this.target);\r\n        this.game.spawn(\"hitEffect\", { damageType: this.stats.damageType, lifeSpan: 1},this.target.transform.position);\r\n        // Chain to nearby enemies\r\n        if (this.stats.piercing > 0 && this.piercedEnemies.length <= this.stats.piercing) {\r\n            const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(\r\n                this.target.transform.gridPosition.x, \r\n                this.target.transform.gridPosition.y, \r\n                this.ownerStats.range,\r\n                \"enemy\"\r\n            );\r\n\r\n            for (let enemy of nearbyEnemies) {\r\n                if (enemy.destroyed || this.piercedEnemies.includes(enemy)) continue;\r\n                const dx = enemy.transform.position.x - this.target.transform.position.x;\r\n                const dy = enemy.transform.position.y - this.target.transform.position.y;\r\n                const distSq = dx * dx + dy * dy;\r\n                let gridSize = this.game.getCollections().configs.game.gridSize;\r\n                if (distSq <= this.ownerStats.range * this.ownerStats.range * gridSize * gridSize) {\r\n                    let enemyHealth = enemy.getComponent(\"health\");\r\n                    let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n                    let enemyStats = {...enemy.getComponent(\"stats\").stats};\r\n                    enemyStats.energyShield = targetEnergyShield.energyShield;\r\n                    let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStats); \r\n                    if(!damageResult.wasEvaded) {\r\n                        enemyHealth.hp -= damageResult.damageDealt;\r\n                        enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n                        this.piercedEnemies.push(enemy);\r\n                        this.chainTargets.push(enemy);\r\n                        this.game.spawn(\"hitEffect\", { damageType: this.stats.damageType, lifeSpan: 1 },enemy.transform.position);\r\n                        if (this.piercedEnemies.length > this.stats.piercing) break;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply additional effects (e.g., slow, leech) to all hit targets\r\n        for (let enemy of this.chainTargets) {\r\n            if (this.ownerStats.slowAmount) {\r\n                enemy.getComponent(\"stats\").addEffect(this.game.getCollections().effects.slow, this.game.effects.slow, this.ownerStats.slowAmount);\r\n            }\r\n            if (this.ownerStats.leech > 0) {\r\n                const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;\r\n                this.game.state.bloodCoreHP = Math.min(this.game.state.stats.maxBloodCoreHP, this.game.state.bloodCoreHP + healing);\r\n            }\r\n            if (this.ownerStats.thief && this.ownerStats.thief != 0) {\r\n                const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;\r\n                this.game.state.bloodShards += stealAmt;\r\n            }\r\n        }\r\n\r\n        this.hasStruck = true; // Mark as struck, render lightning this frame\r\n    }\r\n}"
      },
      "Effect": {
        "fileName": "Effect",
        "script": "class Effect extends engine.Component {\r\n    \r\n    init( {config, applyFn, amount }) {\r\n        this.id = config.id;\r\n        this.title = config.title;\r\n        this.desc = config.desc;\r\n        this.lifeTime = config.lifeTime;\r\n        this.applyFn = applyFn;\r\n        this.amount = amount;    \r\n    }\r\n\r\n    update() {\r\n        this.lifeTime--;\r\n        if( this.lifeTime <= 0) this.parent.removeComponent(this);\r\n        return true;        \r\n    }\r\n\r\n    apply(s, add, mul) {\r\n        this.applyFn(s, add, mul, this.amount);\r\n    }\r\n}"
      },
      "Buildable": {
        "fileName": "Buildable",
        "script": "class Buildable extends engine.Component {\r\n        \r\n  init() {        \r\n        this.placed = false;\r\n    }\r\n}"
      },
      "EssenceBounty": {
        "fileName": "EssenceBounty",
        "script": "class EssenceBounty extends engine.Component {\r\n    \r\n    init(){\r\n        this.statsComp = this.parent.getComponent('stats');\r\n    }\r\n    destroy() {               \r\n        this.game.state.essence += this.statsComp.stats.essence * this.game.state.stats.essenceMultiplier;        \r\n    }\r\n}"
      },
      "FollowPath": {
        "fileName": "FollowPath",
        "script": "class FollowPath extends engine.Component {\r\n     \r\n    init({ pathIndex = 0 }) {\r\n        this.gridSize = this.game.getCollections().configs.game.gridSize;\r\n        this.pathIndex = pathIndex;\r\n        this.indexInPath = 0;\r\n        // Store grid coordinates\r\n        this.x = this.game.state.paths[this.pathIndex][this.indexInPath].x;\r\n        this.y = this.game.state.paths[this.pathIndex][this.indexInPath].y;\r\n        // Convert to pixel position\r\n        this.parent.transform.position = { \r\n            x: this.x * this.gridSize + this.gridSize / 2, \r\n            y: this.y * this.gridSize + this.gridSize / 2 \r\n        };\r\n        this.progress = 0; // Progress between grid points (0 to 1)\r\n        \r\n        // Convert pixel-based speed to grid-based speed\r\n        this.stats = this.getComponent('stats').stats;\r\n        this.gridSpeed = this.stats.speed / this.gridSize;\r\n    }\r\n\r\n    update() {\r\n        this.stats = this.getComponent('stats').stats;\r\n        this.gridSize = this.game.getCollections().configs.game.gridSize;\r\n\r\n        if (this.indexInPath < this.game.state.paths[this.pathIndex].length - 1) {\r\n            const target = this.game.state.paths[this.pathIndex][this.indexInPath + 1];\r\n            \r\n            // Use converted grid-based speed\r\n            this.progress += this.gridSpeed * this.game.deltaTime * 100;\r\n            \r\n            if (this.progress >= 1) {\r\n                this.indexInPath++;\r\n                this.progress = 0;\r\n                this.x = target.x;\r\n                this.y = target.y;\r\n            } else {\r\n                // Interpolate between current and target grid positions\r\n                this.x = this.game.state.paths[this.pathIndex][this.indexInPath].x * (1 - this.progress) + \r\n                        target.x * this.progress;\r\n                this.y = this.game.state.paths[this.pathIndex][this.indexInPath].y * (1 - this.progress) + \r\n                        target.y * this.progress;\r\n            }\r\n            \r\n            // Convert grid coordinates to pixel coordinates\r\n            this.parent.transform.position.x = this.x * this.gridSize + this.gridSize / 2;\r\n            this.parent.transform.position.y = this.y * this.gridSize + this.gridSize / 2;\r\n            this.parent.transform.position.z = this.game.gameEntity.getComponent('game').getTerrainHeight(this.parent.transform.gridPosition);\r\n        } else {\r\n            this.game.state.bloodCoreHP -= this.stats.value;\r\n            this.parent.destroy();\r\n            return false;\r\n        }\r\n    }\r\n}"
      },
      "Game": {
        "fileName": "Game",
        "script": "class Game extends engine.Component {\r\n   \r\n    constructor(game, parent, params) {\r\n        super(game, parent, params);\r\n        this.physicsAccumulator = 0;\r\n        this.lastTime = Date.now();\r\n    }\r\n   \r\n    init() {\r\n        this.physics = this.getComponent('Physics');\r\n        this.gridSize = this.game.getCollections().configs.game.gridSize;      \r\n        this.world = this.getComponent('InfiniWorld');\r\n        this.debugDiv = document.createElement('div');\r\n        this.debugDiv.style.position = \"absolute\";\r\n        this.debugDiv.style.top = '10px';\r\n        this.debugDiv.style.left = '10px';\r\n        this.debugDiv.style.zIndex = '10000';\r\n        document.body.append(this.debugDiv);\r\n    }\r\n    \r\n    update() {\r\n        if (!this.game.state.isPaused) {\r\n            this.currentTime = Date.now();\r\n            const timeSinceLastUpdate = this.currentTime - this.lastTime;\r\n            if (timeSinceLastUpdate > 1000) {\r\n                this.lastTime = this.currentTime;\r\n                return;\r\n            }\r\n            this.game.deltaTime = Math.min(1/30, timeSinceLastUpdate / 1000);\r\n            this.lastTime = this.currentTime;\r\n            \r\n            // Update FPS counter\r\n            if (!this.fps) {\r\n                this.fps = {\r\n                    frameCount: 0,\r\n                    lastFpsUpdate: this.currentTime,\r\n                    fpsValue: 0\r\n                };\r\n            }\r\n            this.fps.frameCount++;\r\n            if (this.currentTime - this.fps.lastFpsUpdate >= 1000) {\r\n                this.fps.fpsValue = Math.round((this.fps.frameCount * 1000) / (this.currentTime - this.fps.lastFpsUpdate));\r\n                this.fps.frameCount = 0;\r\n                this.fps.lastFpsUpdate = this.currentTime;\r\n                this.debugDiv.textContent = `fps:${this.fps.fpsValue}  entityCount:${this.game.state.entities.length}`;\r\n            }\r\n            \r\n            // Fixed physics update\r\n            const physicsStep = 1/60; // 60 Hz physics update\r\n            this.physicsAccumulator += this.game.deltaTime;\r\n            let entitiesToRemove = [];\r\n            for (let i = 0; i < this.game.state.entities.length; i++) {\r\n                let e = this.game.state.entities[i];\r\n                e.update();\r\n                if(!e.destroyed){\r\n                    e.draw();\r\n                    e.postUpdate();  \r\n                } else {\r\n                    entitiesToRemove.push(i);\r\n                }     \r\n            }\r\n            for(let i = entitiesToRemove.length - 1; i >= 0; i--){\r\n                this.game.state.entities.splice(entitiesToRemove[i], 1);\r\n            }\r\n            \r\n            if (this.physicsAccumulator >= physicsStep) {    \r\n                this.physics.sendToWorker(this.world);           \r\n                this.physicsAccumulator -= physicsStep;\r\n            }\r\n            \r\n            this.postUpdate();\r\n        }\r\n    }\r\n    \r\n    getTerrainHeight(position) {\r\n        return this.world ? this.world.getTerrainHeight(position) : 0;\r\n    }\r\n    \r\n    postUpdate() {\r\n        if (this.game.state.gameOver || this.game.state.victory || this.game.state.isLevelingUp) return;\r\n                   \r\n        // Game over check\r\n        if (this.game.state.bloodCoreHP <= 0 && !this.game.state.gameOver) {\r\n            this.gameOver();\r\n        }\r\n    }\r\n    \r\n    // Game-over and victory functions\r\n    gameOver() {\r\n        this.game.state.gameOver = true;\r\n        this.game.state.isPaused = true;\r\n        gameOverWave.textContent = this.game.state.round + 1;\r\n        gameOverMenu.style.display = 'block';\r\n        overlay.style.display = 'block';\r\n    }\r\n    \r\n    gameVictory() {\r\n        this.game.state.victory = true;\r\n        this.game.state.isPaused = true;\r\n        victoryMenu.style.display = 'block';\r\n        overlay.style.display = 'block';\r\n    }\r\n}"
      },
      "GameLoader": {
        "title": "Game Loader",
        "fileName": "GameLoader",
        "script": "class GameLoader extends engine.Component {\r\n    \r\n    init() {}\r\n    \r\n    async load(){\r\n        this.collections = this.game.getCollections();        \r\n        this.collections.configs.game.canvasWidth = window.outerWidth;\r\n        this.collections.configs.game.canvasHeight = window.outerHeight;    \r\n        this.game.palette = this.collections.palettes && this.collections.configs.game.palette ? this.collections.palettes[this.collections.configs.game.palette] : null;\r\n        this.isometric = this.collections.configs.game.isIsometric;\r\n        if (this.game.state.modifierSet && this.collections.modifierSets) {\r\n            this.game.state.stats = this.collections.modifierSets[this.game.state.modifierSet];\r\n            this.game.state.defaultStats = { ...this.game.state.stats };\r\n        }   \r\n        this.setupCanvas(this.collections.configs.game.canvasWidth, this.collections.configs.game.canvasHeight);\r\n        await this.loadAssets();\r\n\r\n        const scene = this.collections.scenes[\"main\"];\r\n        const sceneEntities = scene.sceneData;\r\n        sceneEntities.forEach((sceneEntity) => {\r\n            \r\n            let position = new THREE.Vector3();\r\n            let scale = new THREE.Vector3(1, 1, 1);\r\n            let rotation = new THREE.Vector3();\r\n            let params = {\r\n                \"objectType\": sceneEntity.objectType,\r\n                \"spawnType\": sceneEntity.spawnType,\r\n            };\r\n            sceneEntity.components.forEach((entityComp) => {\r\n                if(entityComp.type == \"transform\"){\r\n                    position = entityComp.parameters.position;\r\n                    scale = entityComp.parameters.scale;\r\n                    rotation = entityComp.parameters.rotation;\r\n                }\r\n                params = {...params, ...entityComp.parameters };\r\n            });\r\n            if(sceneEntity.type == \"game\"){  \r\n                this.game.gameEntity = this.game.createEntityFromCollections(sceneEntity.type, params, position);\r\n                this.game.audioManager = this.game.gameEntity.getComponent('AudioManager');  \r\n            } else {\r\n                let spawned = this.game.spawn(sceneEntity.type, params, new THREE.Vector3(position.x, position.y, position.z));                              \r\n                spawned.transform.scale.copy(scale);\r\n                // Alternative quaternion approach\r\n                let euler = new THREE.Euler(\r\n                    rotation.x,\r\n                    rotation.y,\r\n                    rotation.z\r\n                );\r\n                spawned.transform.quaternion.setFromEuler(euler);\r\n                if(sceneEntity.type.startsWith(\"player\")){\r\n                    this.player = spawned;\r\n                    this.game.player = this.player;\r\n                    this.player.placed = true;\r\n                }\r\n            }\r\n        });\r\n \r\n\r\n    }\r\n\r\n    getProject() {\r\n        return this.game.gameEntity;\r\n    }\r\n    setupCanvas(canvasWidth, canvasHeight) {\r\n        this.canvas = document.getElementById(\"gameCanvas\");\r\n        if(this.game.getCollections().configs.game.is3D){\r\n            this.finalCtx = this.canvas.getContext(\"webgl2\");\r\n        } else {\r\n            this.finalCtx = this.canvas.getContext(\"2d\");\r\n        }\r\n        this.canvasBuffer = document.createElement(\"canvas\");\r\n        this.ctx = this.canvasBuffer.getContext(\"2d\");\r\n        this.canvasBuffer.setAttribute('width', canvasWidth);\r\n        this.canvasBuffer.setAttribute('height', canvasHeight);\r\n        this.canvas.setAttribute('width', canvasWidth);\r\n        this.canvas.setAttribute('height', canvasHeight);  \r\n        \r\n        this.terrainCanvasBuffer = document.createElement('canvas');\r\n\r\n        this.game.canvas = this.canvas;\r\n        this.game.finalCtx = this.finalCtx;\r\n        this.game.canvasBuffer = this.canvasBuffer;\r\n        this.game.ctx = this.ctx;\r\n        this.game.terrainCanvasBuffer = this.terrainCanvasBuffer;\r\n    }\r\n    async loadAssets() {     \r\n        this.game.modelManager = new (this.game.libraryClasses.ModelManager)(this.game, {}, {ShapeFactory: this.game.libraryClasses.ShapeFactory, palette: this.game.palette, textures: this.game.getCollections().textures});    \r\n        for(let objectType in this.collections) {\r\n            \r\n            await this.game.modelManager.loadModels(objectType, this.collections[objectType]);\r\n        }  \r\n \r\n        console.log(\"loaded all Models\");\r\n    }\r\n}"
      },
      "HitEffectParticle": {
        "fileName": "HitEffectParticle",
        "script": "class HitEffectParticle extends engine.Component {\r\n    \r\n  init( {damageType}) {\r\n        this.damageType = damageType || \"default\";\r\n        this.particles = [];\r\n        \r\n        // Spawn particles based on damage type\r\n        const particleCount = 5;\r\n        for (let i = 0; i < particleCount; i++) {\r\n            this.particles.push({\r\n                x: 0, // Relative to parent\r\n                y: 0,\r\n                vx: (Math.random() - 0.5) * 4, // Velocity (-2 to 2)\r\n                vy: (Math.random() - 0.5) * 4,\r\n                size: Math.random() * 3 + 1, // 1-4 pixels\r\n                alpha: 1, // Fades from 1 to 0\r\n                color: this.getColor()\r\n            });\r\n        }\r\n    }\r\n\r\n    getColor() {\r\n        switch (this.damageType) {\r\n            case \"electric\": return \"rgba(0, 255, 255, \"; // Cyan for electric\r\n            case \"fire\": return \"rgba(255, 165, 0, \"; // Orange for fire\r\n            case \"ice\": return \"rgba(128, 128, 255, \"; // Blue for ice\r\n            case \"plasma\": return \"rgba(255, 0, 255, \"; // Purple for plasma\r\n            default: return \"rgba(255, 255, 255, \"; // White fallback\r\n        }\r\n    }\r\n\r\n    update() {\r\n        const lifespanComp = this.parent.getComponent(\"LifeSpan\");\r\n        if (!lifespanComp) return; // Safety check\r\n\r\n        const fadeFactor = lifespanComp.lifeSpan / 30; // Normalize to initial lifespan (30 frames)\r\n        for (let particle of this.particles) {\r\n            particle.x += particle.vx * this.game.state.timeScale;\r\n            particle.y += particle.vy * this.game.state.timeScale;\r\n            particle.alpha = fadeFactor; // Fade based on remaining lifespan\r\n            particle.size *= 0.98; // Slight shrink per frame\r\n        }\r\n    }\r\n}"
      },
      "InfiniWorld": {
        "fileName": "InfiniWorld",
        "parameters": "[\"world\", \"palette\"]",
        "updateInEditor": true,
        "script": "class InfiniWorld extends engine.Component {\r\n    init({\r\n      containerSelector = '#gameContainer',\r\n      width = window.innerWidth,\r\n      height = window.innerHeight,\r\n      isEditor,\r\n      world,\r\n      clock = new THREE.Clock()   \r\n    }) {\r\n      this.container = document.querySelector(containerSelector) || document.body;\r\n      this.gameConfig = this.game.getCollections().configs.game;      \r\n      this.world = this.game.getCollections().worlds[world];\r\n      this.rootGroup = new window.THREE.Group(); // Main container for all shapes\r\n      this.rootGroup.name = \"infiniWorldGroup\";      \r\n      this.canvas = this.game.canvas;\r\n      if(!this.canvas) {\r\n        this.canvas = this.container.querySelector(\"canvas\");\r\n      }\r\n      // Initialize core properties\r\n      this.clock = clock;\r\n      this.onWindowResizeHandler = this.onWindowResize.bind(this);\r\n      this.renderer = this.game.renderer || new THREE.WebGLRenderer({ antialias: true, canvas: this.canvas, alpha: true });\r\n      if(!isEditor){\r\n        this.renderer.setSize(width, height);\r\n      }\r\n      this.renderer.shadowMap.enabled = true;\r\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n\r\n      this.scene = this.game.scene || new window.THREE.Scene();\r\n      this.scene.add(this.rootGroup);\r\n      this.uniforms = new Map();\r\n      this.cameraData = this.game.getCollections().cameras[this.world.camera];  \r\n      // Camera setup\r\n      if(this.cameraData.fov){\r\n          this.camera = new THREE.PerspectiveCamera(\r\n              this.cameraData.fov,\r\n              width / height,\r\n              this.cameraData.near,\r\n              this.cameraData.far\r\n          );\r\n      } else if(this.cameraData.zoom){\r\n          this.camera = new THREE.OrthographicCamera(\r\n              width / - 2, \r\n              width / 2, \r\n              height / 2, \r\n              height / - 2, \r\n              this.cameraData.near,\r\n              this.cameraData.far\r\n          );\r\n          this.camera.zoom = this.cameraData.zoom;\r\n          this.camera.updateProjectionMatrix();\r\n      }\r\n    \tthis.composer = new THREE_.EffectComposer( this.renderer );\r\n      this.pixelSize = this.gameConfig.pixelSize || 1;\r\n      \r\n      this.pixelPass = new THREE_.RenderPixelatedPass( this.pixelSize, this.scene, this.camera );\r\n      if(this.pixelSize == 1) {\r\n        this.pixelPass.enabled = false;\r\n      }\r\n      this.game.postProcessors = {\r\n        pixelPass: this.pixelPass\r\n      };\r\n      this.pixelPass.normalEdgeStrength = 0;\r\n      \r\n\t\t\tthis.composer.addPass( this.pixelPass );\r\n\t\t\tconst outputPass = new THREE_.OutputPass();\r\n\t\t\tthis.composer.addPass( outputPass );\r\n      // Terrain configuration\r\n      this.heightMap = this.game.getCollections().heightMaps[this.world.heightMap];\r\n      this.chunkSize = this.heightMap.chunkSize;\r\n      this.chunkResolution = this.heightMap.chunkResolution;\r\n      this.renderDistance = this.heightMap.renderDistance;\r\n      this.heightScale = this.heightMap.heightScale;\r\n\r\n      // Lighting setup\r\n      this.lighting = this.game.getCollections().lightings[this.world.lighting];  \r\n      this.shadow = this.game.getCollections().shadows[this.world.shadow];  \r\n      this.fogData = this.game.getCollections().fogs[this.world.fog];       \r\n      \r\n      \r\n      const skyColor = parseInt(this.lighting.skyColor.replace('#', ''), 16);\r\n            // Create a large sphere for the sky\r\n      const skyGeometry = new THREE.SphereGeometry(this.cameraData.far * .9, 32, 32); // Large enough to enclose the scene\r\n     \r\n      const skyMaterial = new THREE.MeshBasicMaterial({\r\n        color: skyColor, // Use the same sky color\r\n        side: THREE.BackSide // Render the inside of the sphere\r\n      });\r\n      this.skyDome = new THREE.Mesh(skyGeometry, skyMaterial);\r\n      \r\n      this.rootGroup.add(this.skyDome);\r\n\r\n\r\n      const ambientColor = parseInt(this.lighting.ambientColor.replace('#', ''), 16);\r\n      this.ambientLight = new THREE.AmbientLight(ambientColor, this.lighting.ambientIntensity);\r\n      this.rootGroup.add(this.ambientLight);\r\n    \r\n       \r\n      const directionalColor = parseInt(this.lighting.directionalColor.replace('#', ''), 16);\r\n      this.directionalLight = new THREE.DirectionalLight(directionalColor, this.lighting.directionalIntensity);\r\n      this.directionalLight.castShadow = true;\r\n      this.directionalLight.shadow.mapSize.set(this.shadow.mapSize, this.shadow.mapSize); // Increase resolution for sharper shadows\r\n      this.directionalLight.shadow.camera.near = 0.01; // Closer near plane for precision\r\n      this.directionalLight.shadow.camera.far = this.shadow.mapSize; // Increase far plane to cover tall terrain\r\n      this.directionalLight.shadow.camera.left = -this.shadow.radius; // Expand bounds\r\n      this.directionalLight.shadow.camera.right = this.shadow.radius;\r\n      this.directionalLight.shadow.camera.top = this.shadow.radius;\r\n      this.directionalLight.shadow.camera.bottom = -this.shadow.radius;\r\n      this.directionalLight.shadow.bias = this.shadow.bias; // Add bias to reduce shadow acne\r\n      this.directionalLight.shadow.normalBias = this.shadow.normalBias; // Reduce artifacts on slopes\r\n      this.directionalLight.position.set(this.camera.position.x + this.chunkSize / 2, this.chunkSize / 2, this.camera.position.z + this.chunkSize / 2);\r\n      this.rootGroup.add(this.directionalLight);\r\n    \r\n      // Fog setup\r\n      \r\n      if(this.fogData.enabled){\r\n        const fogColor = parseInt(this.fogData.color.replace('#', ''), 16);\r\n        this.fog = new THREE.Fog(fogColor, 0, (1 - this.fogData.density) * this.renderDistance * this.chunkSize);\r\n        this.scene.fog = this.fog;\r\n      }\r\n  \r\n      this.chunks = new Map();\r\n      this.objectCache = new Map();\r\n  \r\n      this.noise = new (this.game.moduleManager.libraryClasses.SimplexNoise)(); // Fixed seed for consistency\r\n      let biomes = {};\r\n      this.world.biomes.forEach((biomeName) => {\r\n          let biomeObjData = this.game.getCollections().biomes[biomeName];\r\n          let elevationNoiseData = this.game.getCollections().noiseSettings[biomeObjData.elevationNoiseSetting];\r\n          let detailNoiseData = this.game.getCollections().noiseSettings[biomeObjData.detailNoiseSetting];\r\n\r\n          let worldObjectSpawns = [];\r\n          biomeObjData.worldObjectSpawns.forEach((worldObjectSpawn) => {\r\n            worldObjectSpawns.push(this.game.getCollections().worldObjectSpawns[worldObjectSpawn]);\r\n          })\r\n          let groundColor = new THREE.Color(biomeObjData.groundColor);\r\n          biomes[biomeName] = {\r\n            groundColor: {\r\n                r: groundColor.r,\r\n                g: groundColor.g,\r\n                b: groundColor.b\r\n            },\r\n            noiseSettings: {\r\n              elevation: elevationNoiseData,\r\n              detail: detailNoiseData\r\n            },\r\n            worldObjects: worldObjectSpawns,\r\n            range: biomeObjData.range,\r\n            groundRestitution: biomeObjData.groundRestitution\r\n          }\r\n\r\n          if(biomeName == \"mountain\"){     \r\n            let ridgeNoiseData = this.game.getCollections().noiseSettings[biomeObjData.ridgeNoiseSetting];\r\n            biomes[biomeName].noiseSettings.ridge = ridgeNoiseData;\r\n          }\r\n      });\r\n      this.biomes = biomes;\r\n      this.terrainGenerator = new (this.game.moduleManager.libraryClasses.TerrainGenerator)(); \r\n      this.terrainGenerator.init(this.biomes, this.chunkSize, this.chunkResolution, this.noise);\r\n  \r\n      this.grassPerChunk = 131072;//2^17;\r\n      // Initialize Web Worker from Blob\r\n      this.grassTasks = [];\r\n      this.grassBatchSize = 10000; // Process 10,000 instances per frame\r\n      this.currentGrassTaskIndex = 0;\r\n\r\n      this.pendingChunks = new Map();\r\n      this.chunkGeometry = new Map();\r\n      this.staticAABBsToRemove = [];\r\n      this.grassBladeWidth = 4; // Adjusted for chunk scale\r\n      this.grassBladeHeight = 10;\r\n      this.grassShader = this.game.getCollections().shaders[\"grass\"];\r\n      const workerCode = this.getWorkerCode();\r\n      const blob = new Blob([workerCode], { type: 'application/javascript' });\r\n      this.worker = new Worker(URL.createObjectURL(blob));\r\n      this.worker.onmessage = this.handleWorkerMessage.bind(this);\r\n      // Initialize terrain\r\n      this.setupInitialChunks();\r\n  \r\n     // window.addEventListener('resize', this.onWindowResizeHandler);\r\n      this.game.scene = this.scene;\r\n      this.game.camera = this.camera;\r\n      this.game.renderer = this.renderer;\r\n      this.game.terrain = this;\r\n      this.timer = 0;\r\n    }\r\n\r\n    async setupInitialChunks() {\r\n      const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n      const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n      const promises = [];\r\n  \r\n      for (let x = cameraChunkX - this.renderDistance; x <= cameraChunkX + this.renderDistance; x++) {\r\n        for (let z = cameraChunkZ - this.renderDistance; z <= cameraChunkZ + this.renderDistance; z++) {\r\n          promises.push(this.generateChunk(x, z));\r\n        }\r\n      }\r\n  \r\n      await Promise.all(promises);\r\n    }\r\n  \r\n    async generateChunk(cx, cz) {\r\n      const chunkKey = `${cx},${cz}`;\r\n      if (this.chunks.has(chunkKey)) return;\r\n  \r\n      const chunkData = {\r\n        terrainMesh: null,\r\n        objectMeshes: new Map(),\r\n        isGenerating: true\r\n      };\r\n      this.chunks.set(chunkKey, chunkData);\r\n      this.pendingChunks.set(chunkKey, chunkData);\r\n      // Send message to worker\r\n      this.worker.postMessage({\r\n        cx,\r\n        cz,\r\n        chunkSize: this.chunkSize,\r\n        chunkResolution: this.chunkResolution\r\n      });\r\n    }\r\n  \r\n  getInstancedMeshPool(type, geometry, material) {\r\n    if (!this.objectPools) this.objectPools = new Map();\r\n\r\n    const key = `${type}-${geometry.uuid}`;\r\n    if (!this.objectPools.has(key)) {\r\n      const pool = new (this.game.moduleManager.libraryClasses.InstancePool)(geometry, material, 1000);\r\n      this.rootGroup.add(pool.mesh);\r\n      this.objectPools.set(key, pool);\r\n    }\r\n    return this.objectPools.get(key);\r\n  }\r\n  \r\n  async updateChunks() {\r\n      const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n      const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n      const newChunks = new Set();\r\n      const chunksToGenerate = [];\r\n      const maxChunksPerFrame = 2;\r\n  \r\n      for (let x = cameraChunkX - this.renderDistance; x <= cameraChunkX + this.renderDistance; x++) {\r\n          for (let z = cameraChunkZ - this.renderDistance; z <= cameraChunkZ + this.renderDistance; z++) {\r\n              const chunkKey = `${x},${z}`;\r\n              newChunks.add(chunkKey);\r\n              if (!this.chunks.has(chunkKey) && !this.pendingChunks.has(chunkKey)) {\r\n                  chunksToGenerate.push({ x, z });\r\n              }\r\n          }\r\n      }\r\n  \r\n      chunksToGenerate.sort((a, b) => {\r\n          const distA = Math.hypot(a.x - cameraChunkX, a.z - cameraChunkZ);\r\n          const distB = Math.hypot(b.x - cameraChunkX, b.z - cameraChunkZ);\r\n          return distA - distB;\r\n      });\r\n  \r\n      for (let i = 0; i < Math.min(maxChunksPerFrame, chunksToGenerate.length); i++) {\r\n          const { x, z } = chunksToGenerate[i];\r\n          this.generateChunk(x, z);\r\n      }\r\n      this.staticAABBsToRemove = [];\r\n      const physics = this.game.gameEntity?.getComponent('game').physics;\r\n      // Remove old chunks\r\n      for (const [chunkKey, chunkData] of this.chunks) {\r\n          if (!newChunks.has(chunkKey) && !chunkData.isGenerating) {\r\n              let parts = chunkKey.split(',');\r\n              let cx = parts[0];\r\n              let cz = parts[1];\r\n              this.staticAABBsToRemove = [...this.staticAABBsToRemove, ...this.getStaticAABBsAt(cx, cz)];\r\n              if (chunkData.terrainMesh) {\r\n                  this.rootGroup.remove(chunkData.terrainMesh);\r\n                  chunkData.terrainMesh.geometry.dispose();\r\n                  chunkData.terrainMesh.material.dispose();\r\n              }\r\n              if (chunkData.waterMesh) {\r\n                  this.rootGroup.remove(chunkData.waterMesh);\r\n                  chunkData.waterMesh.geometry.dispose();\r\n                  chunkData.waterMesh.material.dispose();\r\n              }\r\n              if (chunkData.grassMesh) {\r\n                  this.rootGroup.remove(chunkData.grassMesh);\r\n                  chunkData.grassMesh.geometry.dispose();\r\n                  chunkData.grassMesh.material.dispose();\r\n              }\r\n              chunkData.objectMeshes.forEach((groups, type) => {\r\n                  groups.forEach(group => {\r\n                      if (group.mesh) {\r\n                          this.rootGroup.remove(group.mesh);\r\n                          group.mesh.geometry.dispose();\r\n                          if (Array.isArray(group.mesh.material)) {\r\n                              group.mesh.material.forEach(mat => mat.dispose());\r\n                          } else {\r\n                              group.mesh.material.dispose();\r\n                          }\r\n                          group.mesh.dispose();\r\n                      }\r\n                  });\r\n              });\r\n              chunkData.grassData = null;\r\n              physics.removeChunkColliders(cx, cz);\r\n              this.chunks.delete(chunkKey);\r\n              this.uniforms.delete(chunkKey);\r\n          }\r\n      }   \r\n   \r\n  }\r\n\r\n  async updateGrassTasks() {\r\n    if(this.grassTasks.length == 0) return;\r\n    if(!this.currentGrassTask){\r\n      this.currentGrassTask = this.grassTasks.pop();\r\n    }\r\n    const grassMesh = this.currentGrassTask.grassMesh;\r\n    const dummy = new THREE.Object3D();\r\n    let finishedChunk = false;\r\n    // Use pre-computed grass data\r\n    for(let i = 0; i < this.grassBatchSize; i++){\r\n      let currentIndex = this.currentGrassTaskIndex + i;\r\n      if (currentIndex >= this.grassPerChunk){\r\n          this.currentGrassTaskIndex = 0;\r\n          this.currentGrassTask = null;\r\n          finishedChunk = true;\r\n          grassMesh.needsUpdate = true;\r\n          break; // Safety check\r\n      }      \r\n      const grass = this.currentGrassTask.grassData[currentIndex];\r\n\r\n      dummy.position.set(grass.position.x, grass.position.y, grass.position.z);\r\n      dummy.rotation.set(0, grass.rotation, 0);\r\n      dummy.scale.set(grass.scale, grass.scale, grass.scale);\r\n      dummy.updateMatrix();\r\n      grassMesh.setMatrixAt(currentIndex, dummy.matrix);      \r\n    };\r\n    if(!finishedChunk){\r\n      this.currentGrassTaskIndex += this.grassBatchSize;\r\n    } \r\n    \r\n\r\n  }\r\n\r\n  getStaticAABBsToRemove() {\r\n    return this.staticAABBsToRemove;\r\n  }\r\n\r\n  handleWorkerMessage(e) {      \r\n    const { cx, cz, positions, indices, colors, normals, vegetation, grassData, restitution, friction } = e.data;\r\n    const chunkKey = `${cx},${cz}`;\r\n    const chunkData = this.pendingChunks.get(chunkKey);\r\n    if (!chunkData) return;\r\n    chunkData.cx = cx;\r\n    chunkData.cz = cz;\r\n    try {\r\n        // Copy positions and normals for manipulation\r\n        const adjustedPositions = positions.slice();\r\n        const adjustedNormals = normals.slice();\r\n        const vertexCountPerRow = this.chunkResolution + 1;\r\n\r\n        chunkData.grassData = grassData;\r\n        // IMPROVEMENT: Use integer-based positioning for chunk placement\r\n        // This helps prevent floating point errors from accumulating\r\n        const chunkWorldX = Math.round(cx * this.chunkSize);\r\n        const chunkWorldZ = Math.round(cz * this.chunkSize);\r\n\r\n        // Enhanced shared edge processing \r\n        const processSharedEdge = (thisChunk, neighborChunk, edgeSelector, neighborEdgeSelector) => {\r\n            if (!neighborChunk || !neighborChunk.terrainMesh) return;\r\n            \r\n            const thisGeom = {\r\n                positions: adjustedPositions,\r\n                normals: adjustedNormals\r\n            };\r\n            \r\n            const neighborGeom = {\r\n                positions: neighborChunk.terrainMesh.geometry.attributes.position.array,\r\n                normals: neighborChunk.terrainMesh.geometry.attributes.normal.array\r\n            };\r\n            \r\n            // Get vertices along the shared edge\r\n            const thisIndices = edgeSelector(vertexCountPerRow);\r\n            const neighborIndices = neighborEdgeSelector(vertexCountPerRow);\r\n            \r\n            // For each vertex along the edge\r\n            for (let i = 0; i < thisIndices.length; i++) {\r\n                const thisIdx = thisIndices[i];\r\n                const neighborIdx = neighborIndices[i];\r\n                \r\n                // CRITICAL FIX: Ensure absolute world positions match exactly\r\n                // Calculate world position of the neighbor vertex\r\n                const neighborWorldX = neighborChunk.terrainMesh.position.x + neighborGeom.positions[neighborIdx*3];\r\n                const neighborWorldY = neighborChunk.terrainMesh.position.y + neighborGeom.positions[neighborIdx*3+1];\r\n                const neighborWorldZ = neighborChunk.terrainMesh.position.z + neighborGeom.positions[neighborIdx*3+2];\r\n                \r\n                // Set local position based on exact world position of neighbor\r\n                // This ensures perfect alignment with zero gaps\r\n                const localX = neighborWorldX - chunkWorldX;\r\n                const localY = neighborWorldY; // Y doesn't need offset since chunks are at y=0\r\n                const localZ = neighborWorldZ - chunkWorldZ;\r\n                \r\n                // Apply exact position to eliminate gaps completely\r\n                thisGeom.positions[thisIdx*3] = localX;\r\n                thisGeom.positions[thisIdx*3+1] = localY;\r\n                thisGeom.positions[thisIdx*3+2] = localZ;\r\n                \r\n                // Average the normals for smooth lighting across chunk boundaries\r\n                const n1 = [\r\n                    thisGeom.normals[thisIdx*3], \r\n                    thisGeom.normals[thisIdx*3+1], \r\n                    thisGeom.normals[thisIdx*3+2]\r\n                ];\r\n                const n2 = [\r\n                    neighborGeom.normals[neighborIdx*3], \r\n                    neighborGeom.normals[neighborIdx*3+1], \r\n                    neighborGeom.normals[neighborIdx*3+2]\r\n                ];\r\n                \r\n                // Calculate average normal\r\n                const avgNormal = [\r\n                    (n1[0] + n2[0]) / 2,\r\n                    (n1[1] + n2[1]) / 2,\r\n                    (n1[2] + n2[2]) / 2\r\n                ];\r\n                \r\n                // Normalize the averaged normal\r\n                const mag = Math.sqrt(\r\n                    avgNormal[0] * avgNormal[0] + \r\n                    avgNormal[1] * avgNormal[1] + \r\n                    avgNormal[2] * avgNormal[2]\r\n                );\r\n                \r\n                if (mag > 0.00001) {\r\n                    avgNormal[0] /= mag;\r\n                    avgNormal[1] /= mag;\r\n                    avgNormal[2] /= mag;\r\n                    \r\n                    // Apply to current chunk\r\n                    adjustedNormals[thisIdx*3] = avgNormal[0];\r\n                    adjustedNormals[thisIdx*3+1] = avgNormal[1];\r\n                    adjustedNormals[thisIdx*3+2] = avgNormal[2];\r\n                    \r\n                    // Also update the neighbor's normal in memory\r\n                    neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3] = avgNormal[0];\r\n                    neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3+1] = avgNormal[1];\r\n                    neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3+2] = avgNormal[2];\r\n                }\r\n            }\r\n            \r\n            // Mark the neighbor's geometry for update\r\n            neighborChunk.terrainMesh.geometry.attributes.normal.needsUpdate = true;\r\n            neighborChunk.terrainMesh.geometry.attributes.position.needsUpdate = true;\r\n        };\r\n        \r\n        // Process each edge with its neighboring chunk\r\n        const neighbors = [\r\n            // [neighborKey, thisEdgeFn, neighborEdgeFn]\r\n            [`${cx - 1},${cz}`, // Left neighbor\r\n                (vpr) => Array.from({length: vpr}, (_, z) => z * vpr), // Left edge \r\n                (vpr) => Array.from({length: vpr}, (_, z) => z * vpr + (vpr - 1)) // Right edge\r\n            ],\r\n            [`${cx + 1},${cz}`, // Right neighbor\r\n                (vpr) => Array.from({length: vpr}, (_, z) => z * vpr + (vpr - 1)), // Right edge\r\n                (vpr) => Array.from({length: vpr}, (_, z) => z * vpr) // Left edge\r\n            ],\r\n            [`${cx},${cz - 1}`, // Bottom neighbor\r\n                (vpr) => Array.from({length: vpr}, (_, x) => x), // Bottom edge\r\n                (vpr) => Array.from({length: vpr}, (_, x) => (vpr - 1) * vpr + x) // Top edge\r\n            ],\r\n            [`${cx},${cz + 1}`, // Top neighbor\r\n                (vpr) => Array.from({length: vpr}, (_, x) => (vpr - 1) * vpr + x), // Top edge\r\n                (vpr) => Array.from({length: vpr}, (_, x) => x) // Bottom edge\r\n            ]\r\n        ];\r\n\r\n        // Process all neighbor edges\r\n        for (const [neighborKey, thisEdgeFn, neighborEdgeFn] of neighbors) {\r\n            processSharedEdge(\r\n                chunkData,\r\n                this.chunks.get(neighborKey),\r\n                thisEdgeFn,\r\n                neighborEdgeFn\r\n            );\r\n        }\r\n\r\n        // Fix corner vertices by finding diagonal neighbors\r\n        const cornerVertices = [\r\n            {pos: 0, // Bottom left\r\n             neighbors: [`${cx-1},${cz}`, `${cx},${cz-1}`, `${cx-1},${cz-1}`]},\r\n            {pos: vertexCountPerRow - 1, // Bottom right\r\n             neighbors: [`${cx+1},${cz}`, `${cx},${cz-1}`, `${cx+1},${cz-1}`]},\r\n            {pos: (vertexCountPerRow - 1) * vertexCountPerRow, // Top left\r\n             neighbors: [`${cx-1},${cz}`, `${cx},${cz+1}`, `${cx-1},${cz+1}`]},\r\n            {pos: vertexCountPerRow * vertexCountPerRow - 1, // Top right\r\n             neighbors: [`${cx+1},${cz}`, `${cx},${cz+1}`, `${cx+1},${cz+1}`]}\r\n        ];\r\n\r\n        // Process each corner to ensure diagonal neighbors connect properly\r\n        for (const corner of cornerVertices) {\r\n            let validNeighbors = [];\r\n            let sumPos = [0, 0, 0];\r\n            let sumNormal = [0, 0, 0];\r\n            let count = 0;\r\n            \r\n            // Add this chunk's corner\r\n            sumPos[0] += adjustedPositions[corner.pos*3];\r\n            sumPos[1] += adjustedPositions[corner.pos*3+1];\r\n            sumPos[2] += adjustedPositions[corner.pos*3+2];\r\n            sumNormal[0] += adjustedNormals[corner.pos*3];\r\n            sumNormal[1] += adjustedNormals[corner.pos*3+1];\r\n            sumNormal[2] += adjustedNormals[corner.pos*3+2];\r\n            count++;\r\n\r\n            // Find corresponding vertices in neighbors\r\n            for (const neighborKey of corner.neighbors) {\r\n                const neighbor = this.chunks.get(neighborKey);\r\n                if (!neighbor || !neighbor.terrainMesh) continue;\r\n                \r\n                // Determine which corner of the neighbor corresponds to our corner\r\n                let neighborCornerPos;\r\n                if (neighborKey === `${cx-1},${cz-1}`) { // Diagonal bottom-left\r\n                    neighborCornerPos = vertexCountPerRow * vertexCountPerRow - 1; // Top-right of neighbor\r\n                } else if (neighborKey === `${cx+1},${cz-1}`) { // Diagonal bottom-right\r\n                    neighborCornerPos = (vertexCountPerRow - 1) * vertexCountPerRow; // Top-left of neighbor\r\n                } else if (neighborKey === `${cx-1},${cz+1}`) { // Diagonal top-left\r\n                    neighborCornerPos = vertexCountPerRow - 1; // Bottom-right of neighbor\r\n                } else if (neighborKey === `${cx+1},${cz+1}`) { // Diagonal top-right\r\n                    neighborCornerPos = 0; // Bottom-left of neighbor\r\n                } else if (neighborKey === `${cx-1},${cz}`) { // Left\r\n                    neighborCornerPos = corner.pos === 0 ? vertexCountPerRow - 1 : \r\n                                     vertexCountPerRow * vertexCountPerRow - 1;\r\n                } else if (neighborKey === `${cx+1},${cz}`) { // Right\r\n                    neighborCornerPos = corner.pos === vertexCountPerRow - 1 ? 0 : \r\n                                     (vertexCountPerRow - 1) * vertexCountPerRow;\r\n                } else if (neighborKey === `${cx},${cz-1}`) { // Bottom\r\n                    neighborCornerPos = corner.pos === 0 ? \r\n                                     (vertexCountPerRow - 1) * vertexCountPerRow : \r\n                                     vertexCountPerRow * vertexCountPerRow - 1;\r\n                } else if (neighborKey === `${cx},${cz+1}`) { // Top\r\n                    neighborCornerPos = corner.pos === (vertexCountPerRow - 1) * vertexCountPerRow ? \r\n                                     0 : vertexCountPerRow - 1;\r\n                }\r\n\r\n                if (neighborCornerPos !== undefined) {\r\n                    const nGeom = neighbor.terrainMesh.geometry;\r\n                    const nPos = nGeom.attributes.position.array;\r\n                    const nNorm = nGeom.attributes.normal.array;\r\n                    \r\n                    // Calculate world position of neighbor's vertex\r\n                    const worldX = neighbor.terrainMesh.position.x + nPos[neighborCornerPos*3];\r\n                    const worldY = neighbor.terrainMesh.position.y + nPos[neighborCornerPos*3+1];\r\n                    const worldZ = neighbor.terrainMesh.position.z + nPos[neighborCornerPos*3+2];\r\n                    \r\n                    // Add to sums\r\n                    sumPos[0] += worldX - chunkWorldX; // Convert to local coords\r\n                    sumPos[1] += worldY;\r\n                    sumPos[2] += worldZ - chunkWorldZ;\r\n                    sumNormal[0] += nNorm[neighborCornerPos*3];\r\n                    sumNormal[1] += nNorm[neighborCornerPos*3+1];\r\n                    sumNormal[2] += nNorm[neighborCornerPos*3+2];\r\n                    count++;\r\n                    \r\n                    validNeighbors.push({\r\n                        chunk: neighbor,\r\n                        pos: neighborCornerPos\r\n                    });\r\n                }\r\n            }\r\n            \r\n            if (count > 1) {\r\n                // Average positions and normals\r\n                const avgPos = [sumPos[0]/count, sumPos[1]/count, sumPos[2]/count];\r\n                const avgNorm = [sumNormal[0]/count, sumNormal[1]/count, sumNormal[2]/count];\r\n                \r\n                // Normalize the normal\r\n                const mag = Math.sqrt(avgNorm[0]*avgNorm[0] + avgNorm[1]*avgNorm[1] + avgNorm[2]*avgNorm[2]);\r\n                if (mag > 0.00001) {\r\n                    avgNorm[0] /= mag;\r\n                    avgNorm[1] /= mag;\r\n                    avgNorm[2] /= mag;\r\n                }\r\n                \r\n                // Apply to this chunk\r\n                adjustedPositions[corner.pos*3] = avgPos[0];\r\n                adjustedPositions[corner.pos*3+1] = avgPos[1];\r\n                adjustedPositions[corner.pos*3+2] = avgPos[2];\r\n                adjustedNormals[corner.pos*3] = avgNorm[0];\r\n                adjustedNormals[corner.pos*3+1] = avgNorm[1];\r\n                adjustedNormals[corner.pos*3+2] = avgNorm[2];\r\n                \r\n                // Apply to all valid neighbors too\r\n                for (const n of validNeighbors) {\r\n                    const worldX = chunkWorldX + avgPos[0];\r\n                    const worldY = avgPos[1]; // Y position is absolute\r\n                    const worldZ = chunkWorldZ + avgPos[2];\r\n                    \r\n                    // Convert world position to neighbor's local space\r\n                    const neighborLocalX = worldX - n.chunk.terrainMesh.position.x;\r\n                    const neighborLocalY = worldY - n.chunk.terrainMesh.position.y;\r\n                    const neighborLocalZ = worldZ - n.chunk.terrainMesh.position.z;\r\n                    \r\n                    // Apply position and normal\r\n                    const nGeom = n.chunk.terrainMesh.geometry;\r\n                    nGeom.attributes.position.array[n.pos*3] = neighborLocalX;\r\n                    nGeom.attributes.position.array[n.pos*3+1] = neighborLocalY;\r\n                    nGeom.attributes.position.array[n.pos*3+2] = neighborLocalZ;\r\n                    nGeom.attributes.normal.array[n.pos*3] = avgNorm[0];\r\n                    nGeom.attributes.normal.array[n.pos*3+1] = avgNorm[1];\r\n                    nGeom.attributes.normal.array[n.pos*3+2] = avgNorm[2];\r\n                    \r\n                    // Mark for update\r\n                    nGeom.attributes.position.needsUpdate = true;\r\n                    nGeom.attributes.normal.needsUpdate = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Create geometry with adjusted positions and normals\r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(adjustedPositions, 3));\r\n        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(adjustedNormals, 3));\r\n        geometry.setIndex(indices);\r\n\r\n        // Improved material settings for gap-free appearance\r\n        const material = new THREE.MeshStandardMaterial({\r\n            vertexColors: true,\r\n            roughness: 0.9, \r\n            metalness: 0.1,\r\n            side: THREE.FrontSide,\r\n            flatShading: false,\r\n            dithering: true,\r\n            // NEW: Add slight overdraw to help with small gaps\r\n            polygonOffset: true,\r\n            polygonOffsetFactor: -1,  // Slight offset to prevent z-fighting\r\n            polygonOffsetUnits: -1\r\n        });\r\n\r\n        // Create mesh with precise positioning\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n        mesh.position.set(chunkWorldX, 0, chunkWorldZ); // Use exact integer positions\r\n        mesh.castShadow = true;\r\n        mesh.receiveShadow = true;\r\n        mesh.material.needsUpdate = true;\r\n        mesh.userData.isTerrain = true;\r\n        this.rootGroup.add(mesh);\r\n        chunkData.terrainMesh = mesh;\r\n        chunkData.geometry = {\r\n          positions: [...geometry.attributes.position.array],\r\n          indices: [...geometry.index.array],\r\n          normals: [...geometry.attributes.normal.array],\r\n        };\r\n        chunkData.position = new THREE.Vector3(chunkWorldX, 0, chunkWorldZ);\r\n    //    this.chunkGeometry.set(chunkKey, geometry);\r\n        // Generate water mesh\r\n        const waterMesh = this.generateWaterMesh(cx, cz, adjustedPositions);\r\n        if (waterMesh) {\r\n            // Position water mesh exactly to avoid gaps\r\n            waterMesh.position.set(chunkWorldX, 0, chunkWorldZ);\r\n            this.rootGroup.add(waterMesh);\r\n            chunkData.waterMesh = waterMesh;\r\n        }\r\n\r\n        // Add grass to chunk\r\n        const grassMesh = this.addGrassToTerrain(cx, cz, grassData);\r\n        if (grassMesh) {\r\n          grassMesh.position.set(chunkWorldX, 0, chunkWorldZ);\r\n          this.rootGroup.add(grassMesh);\r\n          chunkData.grassMesh = grassMesh;\r\n        }\r\n        // Process vegetation data\r\n        chunkData.collisionAABBs = new Map();\r\n        vegetation.forEach(({ worldObject, data }) => {\r\n            if (worldObject.endsWith('_collision')) {\r\n                const objectType = worldObject.replace('_collision', '');\r\n                chunkData.collisionAABBs.set(objectType, data);\r\n            } else {\r\n                const model = this.game.modelManager.getModel('worldObjectPrefabs', worldObject);\r\n                if (!model) {\r\n                    console.warn(`Model not found: ${worldObject}`);\r\n                    return;\r\n                }\r\n                this.processModelType(worldObject, model, data, chunkData);\r\n            }\r\n        });\r\n\r\n        // Force shadow map update to avoid shadow artifacts at boundaries\r\n        this.renderer.shadowMap.needsUpdate = true;\r\n        chunkData.restitution = restitution;\r\n        chunkData.friction = friction;\r\n        // Mark chunk as ready\r\n        chunkData.isGenerating = false;\r\n        this.game.gameEntity?.getComponent('game').physics.addChunkCollider(chunkData);\r\n        this.pendingChunks.delete(chunkKey);\r\n    } catch (error) {\r\n        console.error(`Failed to process chunk ${chunkKey}:`, error);\r\n        this.chunks.delete(chunkKey);\r\n        this.pendingChunks.delete(chunkKey);\r\n    }\r\n  }\r\n\r\n  getStaticAABBs() {\r\n    const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n    const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n    let staticAABBs = [];\r\n\r\n    // Check nearby chunks\r\n    for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n      for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n        staticAABBs = [...staticAABBs, ...this.getStaticAABBsAt(x, z)];\r\n      }\r\n    }\r\n    return staticAABBs;\r\n  }\r\n\r\n  getStaticAABBsAt(cx, cz) {\r\n      const chunkKey = `${cx},${cz}`;\r\n      const chunkData = this.chunks.get(chunkKey);\r\n      if (!chunkData || !chunkData.collisionAABBs) return [];\r\n\r\n      let rockAndTreeAABBs = [];\r\n      \r\n      // Iterate through all collision types\r\n      for (const [key, aabbs] of chunkData.collisionAABBs) {\r\n          // Check if key ends with 'tree'\r\n          if (key.endsWith('tree') || key.endsWith('rock')) {\r\n              rockAndTreeAABBs = [...rockAndTreeAABBs, ...(aabbs || [])];\r\n          }\r\n      }\r\n      \r\n      return rockAndTreeAABBs;\r\n  }\r\n    \r\n  checkStaticObjectCollisions(colliderAABB) {\r\n    const collisions = [];\r\n    const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n    const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n  \r\n    // Check nearby chunks\r\n    for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n      for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n        const chunkKey = `${x},${z}`;\r\n        const chunkData = this.chunks.get(chunkKey);\r\n        if (!chunkData) continue;\r\n  \r\n        const treeAndRockAABBs = this.getStaticAABBsAt(x, z);\r\n        if(treeAndRockAABBs){\r\n          treeAndRockAABBs.forEach(aabb => {\r\n            if (this.aabbIntersects(colliderAABB, aabb)) {\r\n              collisions.push(aabb);\r\n            }\r\n          });\r\n        }       \r\n      }\r\n    }\r\n    return collisions;\r\n  }\r\n  \r\n  aabbIntersects(aabb1, aabb2) {\r\n    return (\r\n      aabb1.min.x <= aabb2.max.x &&\r\n      aabb1.max.x >= aabb2.min.x &&\r\n      aabb1.min.y <= aabb2.max.y &&\r\n      aabb1.max.y >= aabb2.min.y &&\r\n      aabb1.min.z <= aabb2.max.z &&\r\n      aabb1.max.z >= aabb2.min.z\r\n    );\r\n  }\r\n\r\n  update() {\r\n    if (!this.game.getCollections().configs.game.is3D) return;\r\n    this.timer += this.game.deltaTime || 0;\r\n    this.skyDome.position.set(this.camera.position.x, 0, this.camera.position.z); // Center it around the camera\r\n    this.updateChunks();\r\n   // this.updateGrassTasks(); // Process grass tasks incrementally\r\n\r\n    const cameraPos = this.camera.position;\r\n  \r\n    // Update directional light position smoothly every frame\r\n    this.directionalLight.position.set(cameraPos.x + 500, 500, cameraPos.z + 500);\r\n    this.directionalLight.target.position.set(cameraPos.x, 0, cameraPos.z);\r\n    this.directionalLight.target.updateMatrixWorld();\r\n  \r\n    // Update shadow camera smoothly every frame\r\n    const shadowCamera = this.directionalLight.shadow.camera;\r\n  \r\n    // Center shadow camera on the player's position\r\n    //const terrainHeight = this.getTerrainHeight(cameraPos);\r\n    shadowCamera.position.set(cameraPos.x, 500, cameraPos.z);\r\n    shadowCamera.lookAt(cameraPos.x, 0, cameraPos.z);\r\n    shadowCamera.updateProjectionMatrix();\r\n    shadowCamera.updateMatrixWorld();\r\n  \r\n    // Only force shadow map update when terrain changes (e.g., new chunks)\r\n    // This is already handled in handleWorkerMessage with this.renderer.shadowMap.needsUpdate = true\r\n    \r\n    for (const [key, value] of this.uniforms.entries()) {\r\n        value.time = { value: this.timer };\r\n        value.cameraPosition = { value: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z } };\r\n    }\r\n    if(this.pixelPass.enabled){\r\n  \t  const rendererSize = this.renderer.getSize( new THREE.Vector2() );\r\n      const aspectRatio = rendererSize.x / rendererSize.y;\r\n  \t  this.pixelAlignFrustum( this.camera, aspectRatio, Math.floor( rendererSize.x / this.pixelSize ),\r\n\t\t\t\t\tMath.floor( rendererSize.y / this.pixelSize ) );\r\n    }\r\n    this.renderer.render(this.scene, this.camera);\r\n    if(this.pixelPass.enabled){\r\n\t\t  this.composer.render();\r\n    }\r\n  }\r\n  pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {\r\n\r\n\t\t\t// 0. Get Pixel Grid Units\r\n\t\t\tconst worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );\r\n\t\t\tconst worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );\r\n\t\t\tconst pixelWidth = worldScreenWidth / pixelsPerScreenWidth;\r\n\t\t\tconst pixelHeight = worldScreenHeight / pixelsPerScreenHeight;\r\n\r\n\t\t\t// 1. Project the current camera position along its local rotation bases\r\n\t\t\tconst camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );\r\n\t\t\tconst camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );\r\n\t\t\tconst camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );\r\n\t\t\tconst camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );\r\n\t\t\tconst camPosRight = camPos.dot( camRight );\r\n\t\t\tconst camPosUp = camPos.dot( camUp );\r\n\r\n\t\t\t// 2. Find how far along its position is along these bases in pixel units\r\n\t\t\tconst camPosRightPx = camPosRight / pixelWidth;\r\n\t\t\tconst camPosUpPx = camPosUp / pixelHeight;\r\n\r\n\t\t\t// 3. Find the fractional pixel units and convert to world units\r\n\t\t\tconst fractX = camPosRightPx - Math.round( camPosRightPx );\r\n\t\t\tconst fractY = camPosUpPx - Math.round( camPosUpPx );\r\n\r\n\t\t\t// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid\r\n\t\t\tcamera.left = - aspectRatio - ( fractX * pixelWidth );\r\n\t\t\tcamera.right = aspectRatio - ( fractX * pixelWidth );\r\n\t\t\tcamera.top = 1.0 - ( fractY * pixelHeight );\r\n\t\t\tcamera.bottom = - 1.0 - ( fractY * pixelHeight );\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t\t}\r\n\r\n  onWindowResize() {\r\n  \r\n    if(this.canvas){\r\n\r\n      const width = this.container.clientWidth || window.innerWidth;\r\n      const height = this.container.clientHeight || window.innerHeight;\r\n      this.camera.aspect = width / height;\r\n      this.camera.updateProjectionMatrix();\r\n      this.renderer.setSize(width, height);\r\n      this.canvas.style.width = `${width}px`;\r\n      this.canvas.style.height = `${height}px`;\r\n    }\r\n  }\r\n\r\n  processModelType(type, model, instances, chunkData) {\r\n      // Ensure model’s world matrices are up-to-date\r\n      model.updateMatrixWorld(true);\r\n  \r\n      // Collect mesh data with transformations relative to model root\r\n      const meshData = [];\r\n      model.traverse(node => {\r\n        if (node.isMesh) {\r\n          const parent = node.parent;\r\n          const parentWorldMatrix = parent.matrixWorld.clone();\r\n          const localMatrix = node.matrix.clone();\r\n  \r\n          // Compute transformation relative to model root\r\n          const relativeMatrix = new THREE.Matrix4();\r\n          relativeMatrix.copy(parentWorldMatrix);\r\n          relativeMatrix.multiply(localMatrix);\r\n  \r\n          meshData.push({\r\n            mesh: node,\r\n            relativeMatrix: relativeMatrix\r\n          });\r\n        }\r\n      });\r\n  \r\n      if (meshData.length === 0) {\r\n        console.warn(`No meshes found in model: ${type}`);\r\n        return;\r\n      }\r\n  \r\n      // Create instanced meshes for each mesh in the model\r\n      const instanceGroups = meshData.map(({ mesh, relativeMatrix }) => {\r\n        const instancedMesh = new THREE.InstancedMesh(\r\n          mesh.geometry,\r\n          mesh.material.clone(), // Clone material to avoid shared state\r\n          instances.length\r\n        );\r\n        instancedMesh.userData.relativeMatrix = relativeMatrix;\r\n        instancedMesh.castShadow = true;\r\n        instancedMesh.receiveShadow = true;\r\n        instancedMesh.material.transparent = false;\r\n        instancedMesh.material.alphaTest = 0.1; // Set alpha test for transparency\r\n        instancedMesh.material.needsUpdate = true; // Force material update\r\n        instancedMesh.material.side = THREE.DoubleSide; // Set side to double for better visibility\r\n        this.rootGroup.add(instancedMesh);\r\n        return { mesh: instancedMesh, instances: [] };\r\n      });\r\n  \r\n      // Set instance transformations\r\n      const matrix = new THREE.Matrix4();\r\n      const dummy = new THREE.Object3D();\r\n  \r\n      instances.forEach((instance, index) => {\r\n        // Set base transformation from worker data\r\n        dummy.position.set(\r\n          instance.position.x,\r\n          instance.position.y,\r\n          instance.position.z\r\n        );\r\n        dummy.rotation.y = instance.rotation;\r\n        dummy.scale.setScalar(instance.scale);\r\n        dummy.updateMatrix();\r\n  \r\n        // Apply base transformation combined with each mesh’s relative matrix\r\n        instanceGroups.forEach((group, meshIndex) => {\r\n          matrix.copy(dummy.matrix);\r\n          matrix.multiply(group.mesh.userData.relativeMatrix);\r\n          group.mesh.setMatrixAt(index, matrix);\r\n          group.instances.push(index);\r\n        });\r\n      });\r\n  \r\n      // Update instance matrices\r\n      instanceGroups.forEach(group => {\r\n        group.mesh.instanceMatrix.needsUpdate = true;\r\n        this.renderer.shadowMap.needsUpdate = true; // Force shadow map update\r\n      });\r\n  \r\n      // Store instance groups in chunk data\r\n      chunkData.objectMeshes.set(type, instanceGroups);\r\n  }\r\ngetInterpolatedTerrainHeight(position) {\r\n    // Determine the chunk containing the position\r\n    let chunkX = Math.floor(position.x / this.chunkSize);\r\n    let chunkZ = Math.floor(position.z / this.chunkSize);\r\n    let localX = position.x - (chunkX * this.chunkSize);\r\n    let localZ = position.z - (chunkZ * this.chunkSize);\r\n\r\n    // Adjust chunk selection for boundary positions\r\n    const halfChunk = this.chunkSize / 2;\r\n    let chunkKey;\r\n    if (localX === halfChunk) {\r\n        chunkX += 1;\r\n        localX -= this.chunkSize;\r\n    } else if (localX === -halfChunk) {\r\n        chunkX -= 1;\r\n        localX += this.chunkSize;\r\n    }\r\n    if (localZ === halfChunk) {\r\n        chunkZ += 1;\r\n        localZ -= this.chunkSize;\r\n    } else if (localZ === -halfChunk) {\r\n        chunkZ -= 1;\r\n        localZ += this.chunkSize;\r\n    }\r\n    chunkKey = `${chunkX},${chunkZ}`;\r\n\r\n    // Get chunk data\r\n    const chunkData = this.chunks.get(chunkKey);\r\n    if (!chunkData || !chunkData.terrainMesh) {\r\n        // Fallback to terrain generator if chunk is not loaded\r\n        return this.terrainGenerator.getHeight({ x: position.x, z: position.z });\r\n    }\r\n\r\n    const terrainPositions = chunkData.terrainMesh.geometry.attributes.position.array;\r\n    const vertexCountPerRow = this.chunkResolution + 1; // e.g., 33 for 32x32 tiles\r\n    const step = this.chunkSize / this.chunkResolution; // e.g., 1024 / 32 = 32 units per tile\r\n\r\n    // Map to grid coordinates (0 to chunkResolution)\r\n    const x = (localX + this.chunkSize / 2) / step; // Map from [-chunkSize/2, chunkSize/2] to [0, chunkResolution]\r\n    const z = (localZ + this.chunkSize / 2) / step;\r\n\r\n    // Clamp grid coordinates to avoid out-of-bounds access\r\n    const xIdx = Math.min(Math.max(Math.floor(x), 0), this.chunkResolution - 1);\r\n    const zIdx = Math.min(Math.max(Math.floor(z), 0), this.chunkResolution - 1);\r\n    const fx = Math.min(Math.max(x - xIdx, 0), 1); // Fractional part for interpolation\r\n    const fz = Math.min(Math.max(z - zIdx, 0), 1);\r\n\r\n    // Get heights of the four surrounding vertices\r\n    const posIdx = (zIdx * vertexCountPerRow + xIdx) * 3;\r\n    const h00 = terrainPositions[posIdx + 1]; // Height at (xIdx, zIdx)\r\n    const h10 = xIdx + 1 < vertexCountPerRow ? terrainPositions[posIdx + 3 + 1] : h00; // Height at (xIdx+1, zIdx)\r\n    const h01 = zIdx + 1 < vertexCountPerRow ? terrainPositions[(zIdx + 1) * vertexCountPerRow * 3 + xIdx * 3 + 1] : h00; // Height at (xIdx, zIdx+1)\r\n    const h11 = xIdx + 1 < vertexCountPerRow && zIdx + 1 < vertexCountPerRow ? terrainPositions[(zIdx + 1) * vertexCountPerRow * 3 + (xIdx + 1) * 3 + 1] : h00; // Height at (xIdx+1, zIdx+1)\r\n\r\n    // Perform bilinear interpolation\r\n    const height = h00 * (1 - fx) * (1 - fz) +\r\n                   h10 * fx * (1 - fz) +\r\n                   h01 * (1 - fx) * fz +\r\n                   h11 * fx * fz;\r\n\r\n    return height;\r\n}\r\n  getTerrainHeight(position, useRaycast = false) {\r\n  //    return this.getInterpolatedTerrainHeight(position);\r\n    if(!useRaycast){      \r\n      return this.terrainGenerator.getHeight(position);\r\n    }\r\n    // Create a raycaster\r\n    const raycaster = new THREE.Raycaster();\r\n    \r\n    // Set the ray origin high above the position\r\n    const rayOrigin = new THREE.Vector3(position.x, position.y + 10, position.z);\r\n    \r\n    // Set the ray direction downward\r\n    const rayDirection = new THREE.Vector3(0, -1, 0);\r\n    raycaster.set(rayOrigin, rayDirection);\r\n    \r\n    // Collect visible terrain chunks to test against\r\n    const chunks = [];\r\n    const cameraChunkX = Math.floor(position.x / this.chunkSize);\r\n    const cameraChunkZ = Math.floor(position.z / this.chunkSize);\r\n    \r\n    // Check nearby chunks (optimization: only check chunks in a certain radius)\r\n    for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n      for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n        const chunkKey = `${x},${z}`;\r\n        const chunkData = this.chunks.get(chunkKey);\r\n        if (chunkData && chunkData.terrainMesh) {\r\n          chunks.push(chunkData.terrainMesh);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Perform the raycast\r\n    const intersects = raycaster.intersectObjects(chunks, false);\r\n    \r\n    // If there's an intersection, return the y-coordinate\r\n    if (intersects.length > 0) {\r\n      return intersects[0].point.y;\r\n    }\r\n    \r\n    return 0;//this.terrainGenerator.getHeight(position);\r\n  }\r\n\r\n  getReflectionAt(position, velocity, restitution) {\r\n      return this.terrainGenerator.getReflectionAt(position, velocity, restitution);\r\n      const normal = this.getTerrainNormal(position);\r\n      const dotProduct = \r\n          velocity.x * normal.x + \r\n          velocity.y * normal.y + \r\n          velocity.z * normal.z;\r\n      \r\n      // Only reflect if moving toward the surface\r\n      if (dotProduct < 0) {\r\n          let r = (restitution || 0.3);\r\n          const slopeAmount = 1 - normal.y;\r\n          // Calculate reflection vector correctly (r affects the entire reflection, not just normal component)\r\n          // v_reflect = v - 2(v·n)n then scaled by restitution\r\n          let reflection = new THREE.Vector3(\r\n              velocity.x - 2 * dotProduct * normal.x,\r\n              velocity.y - 2 * dotProduct * normal.y,\r\n              velocity.z - 2 * dotProduct * normal.z\r\n          );\r\n\r\n\r\n          if(dotProduct > -10 || slopeAmount > .5 ){          \r\n            // r = normal.y;\r\n            r = .99;\r\n            // Scale by restitution (energy loss on bounce)\r\n          }\r\n          reflection.x *= r;\r\n          reflection.y *= r;\r\n          reflection.z *= r;\r\n          \r\n          return reflection;\r\n      } else {\r\n          // Not heading into surface, return original velocity\r\n          return { ...velocity };\r\n      }\r\n  } \r\n\r\n  getTerrainNormal(position) {\r\n      // Create a raycaster\r\n      const raycaster = new THREE.Raycaster();\r\n      \r\n      // Set the ray origin high above the position\r\n      const rayOrigin = new THREE.Vector3(position.x, this.chunkSize * 2, position.z);\r\n      \r\n      // Set the ray direction downward\r\n      const rayDirection = new THREE.Vector3(0, -1, 0);\r\n      raycaster.set(rayOrigin, rayDirection);\r\n      \r\n      // Collect visible terrain chunks to test against\r\n      const chunks = [];\r\n      const cameraChunkX = Math.floor(position.x / this.chunkSize);\r\n      const cameraChunkZ = Math.floor(position.z / this.chunkSize);\r\n      \r\n      // Check nearby chunks\r\n      for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n          for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n              const chunkKey = `${x},${z}`;\r\n              const chunkData = this.chunks.get(chunkKey);\r\n              if (chunkData && chunkData.terrainMesh) {\r\n                  chunks.push(chunkData.terrainMesh);\r\n              }\r\n          }\r\n      }\r\n      \r\n      // Perform the raycast\r\n      const intersects = raycaster.intersectObjects(chunks, false);\r\n      \r\n      // If there's an intersection, return the face normal\r\n      if (intersects.length > 0) {\r\n          return {\r\n              x: intersects[0].face.normal.x,\r\n              y: intersects[0].face.normal.y,\r\n              z: intersects[0].face.normal.z\r\n          };\r\n      }\r\n      \r\n      // Fallback to upward normal if no intersection found\r\n      return { x: 0, y: 1, z: 0 };\r\n  }\r\n\r\n  destroy() {\r\n    // window.removeEventListener('resize', this.onWindowResizeHandler); // Uncomment if needed\r\n\r\n    for (const [, chunkData] of this.chunks) {\r\n      if (chunkData.terrainMesh) {\r\n        this.scene.remove(chunkData.terrainMesh);\r\n        chunkData.terrainMesh.geometry.dispose();\r\n        if (chunkData.terrainMesh.material) {\r\n          if (Array.isArray(chunkData.terrainMesh.material)) {\r\n            chunkData.terrainMesh.material.forEach(mat => mat.dispose());\r\n          } else {\r\n            chunkData.terrainMesh.material.dispose();\r\n          }\r\n        }\r\n      }\r\n      if (chunkData.waterMesh) {\r\n        this.scene.remove(chunkData.waterMesh);\r\n        chunkData.waterMesh.geometry.dispose();\r\n        chunkData.waterMesh.material.dispose();\r\n      }\r\n      if (chunkData.grassMesh) {\r\n        this.scene.remove(chunkData.grassMesh);\r\n        chunkData.grassMesh.geometry.dispose();\r\n        chunkData.grassMesh.material.dispose();\r\n      }\r\n      chunkData.objectMeshes.forEach((groups, type) => {\r\n        groups.forEach(group => {\r\n          if (group.mesh) {\r\n            this.scene.remove(group.mesh);\r\n            group.mesh.geometry.dispose();\r\n            if (group.mesh.material) {\r\n              if (Array.isArray(group.mesh.material)) {\r\n                group.mesh.material.forEach(mat => mat.dispose());\r\n              } else {\r\n                group.mesh.material.dispose();\r\n              }\r\n            }\r\n            group.mesh.dispose();\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    if (this.objectPools) {\r\n      this.objectPools.forEach(pool => {\r\n        if (pool.mesh) {\r\n          this.scene.remove(pool.mesh);\r\n          pool.mesh.geometry.dispose();\r\n          if (pool.mesh.material) {\r\n            if (Array.isArray(pool.mesh.material)) {\r\n              pool.mesh.material.forEach(mat => mat.dispose());\r\n            } else {\r\n              pool.mesh.material.dispose();\r\n            }\r\n          }\r\n          pool.mesh.dispose();\r\n        }\r\n      });\r\n      this.objectPools.clear();\r\n    }\r\n\r\n    this.objectCache.forEach(mesh => {\r\n      this.scene.remove(mesh);\r\n      mesh.geometry.dispose();\r\n      if (mesh.material) {\r\n        if (Array.isArray(mesh.material)) {\r\n          mesh.material.forEach(mat => mat.dispose());\r\n        } else {\r\n          mesh.material.dispose();\r\n        }\r\n      }\r\n    });\r\n    this.objectCache.clear();\r\n\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n    }\r\n    this.pendingChunks.clear();\r\n    this.chunks.clear();\r\n    this.uniforms.clear();\r\n    this.scene.remove(this.rootGroup);\r\n  }\r\n\r\n\r\n  generateWaterMesh(cx, cz, terrainPositions) {\r\n    return;\r\n    const chunkKey = `${cx},${cz}`;\r\n\r\n    // Create a plane with higher resolution for visible waves\r\n    const geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, 64, 64);\r\n    geometry.rotateX(-Math.PI / 2); // Align with terrain\r\n\r\n    // Adjust UVs to be continuous across chunks\r\n    const uvAttribute = geometry.attributes.uv;\r\n    const positionAttribute = geometry.attributes.position;\r\n    for (let i = 0; i < uvAttribute.count; i++) {\r\n        const x = positionAttribute.getX(i) + (cx * this.chunkSize + this.chunkSize / 2);\r\n        const z = positionAttribute.getZ(i) + (cz * this.chunkSize + this.chunkSize / 2);\r\n        // Scale UVs based on world position\r\n        uvAttribute.setXY(i, x / this.chunkSize, z / this.chunkSize);\r\n    }\r\n    uvAttribute.needsUpdate = true;\r\n\r\n    // Parse hex color\r\n    const parseHexColor = (hex) => {\r\n        const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n        const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n        const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n        return { r, g, b };\r\n    };\r\n\r\n    // Get water shader from configuration\r\n    const waterShader = this.game.getCollections().shaders[\"water\"];\r\n    this.uniforms[chunkKey] = JSON.parse(waterShader.uniforms);\r\n\r\n    // Set colors (fix color assignment)\r\n    const liquidColorHex = \"#1E90FF\"; // DodgerBlue for water\r\n    const foamColorHex = \"#FFFFFF\"; // White for foam\r\n    const liquidColor = parseHexColor(liquidColorHex);\r\n    const foamColor = parseHexColor(foamColorHex);\r\n\r\n    // Vectorize properties\r\n    const vectorizeProps = waterShader.vectors;\r\n    vectorizeProps.forEach((prop) => {\r\n        if (this.uniforms[chunkKey][prop]) {\r\n            if (prop.toLowerCase().endsWith(\"color\")) {\r\n                const color = prop.toLowerCase().startsWith(\"foam\") ? foamColor : liquidColor;\r\n                this.uniforms[chunkKey][prop].value = new THREE.Vector3(color.r, color.g, color.b);\r\n            } else {\r\n                let arr = this.uniforms[chunkKey][prop].value;\r\n                this.uniforms[chunkKey][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Set additional uniforms\r\n    this.uniforms[chunkKey].fogColor = { value: new THREE.Color(this.fogData.color) };\r\n    this.uniforms[chunkKey].fogDensity = this.fogData.enabled ? { value: this.fogData.density } : { value: 0 };\r\n    const data = new Float32Array(this.chunkResolution * this.chunkResolution);\r\n    for (let z = 0; z < this.chunkResolution; z++) {\r\n      for (let x = 0; x < this.chunkResolution; x++) {\r\n        const index = Math.floor((z * this.chunkResolution + x)*3);\r\n        data[Math.floor(index / 3)] = terrainPositions[index+1];\r\n      }\r\n    }\r\n    const heightmapTexture = new THREE.DataTexture(\r\n      data,\r\n      this.chunkResolution,\r\n      this.chunkResolution,\r\n      THREE.RedFormat,\r\n      THREE.FloatType\r\n    );\r\n    heightmapTexture.needsUpdate = true;\r\n\r\n    this.uniforms[chunkKey].terrainHeightmap = { value: heightmapTexture };\r\n    this.uniforms[chunkKey].terrainSize = { value: new THREE.Vector2(this.chunkResolution, this.chunkResolution) };\r\n    this.uniforms[chunkKey].terrainOffset = { value: new THREE.Vector2(cx, cz) };\r\n    this.uniforms[chunkKey].foamWidth = { value: 0.5 }; // Adjust for wider/narrower foam bands\r\n    this.uniforms[chunkKey].foamColor = { value: new THREE.Vector3(1.0, 1.0, 1.0) }; \r\n    // Create the shader material\r\n    const material = new THREE.ShaderMaterial({\r\n        uniforms: this.uniforms[chunkKey],\r\n        vertexShader: waterShader.vertexScript,\r\n        fragmentShader: waterShader.fragmentScript,\r\n        side: THREE.DoubleSide, // Use DoubleSide to avoid culling issues\r\n        transparent: true\r\n    });\r\n\r\n    // Create water mesh\r\n    const waterMesh = new THREE.Mesh(geometry, material);\r\n    waterMesh.position.set(cx * this.chunkSize + this.chunkSize / 2, 0.1, cz * this.chunkSize + this.chunkSize / 2); // Center in chunk\r\n    waterMesh.name = `water_${chunkKey}`;\r\n    waterMesh.receiveShadow = true;\r\n\r\n    return waterMesh;\r\n  }\r\n  addGrassToTerrain(cx, cz, grassData) {\r\nif(!grassData) return;\r\n    const chunkKey = `${cx},${cz}`;\r\n    const grassGeometry = this.createCurvedBladeGeometry(grassData.bladeWidth, grassData.bladeHeight);\r\n    grassGeometry.translate(0, -grassData.bladeHeight * 0.6, 0);\r\n\r\n    grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(grassData.phases, 1));\r\n\r\n    const grassTexture = this.createGrassTexture(grassData);\r\n    const grassShader = this.grassShader;\r\n    this.uniforms.set(`grass_${chunkKey}`, JSON.parse(grassShader.uniforms));\r\n\r\n    const uniforms = this.uniforms.get(`grass_${chunkKey}`);\r\n    uniforms.windDirection = { value: new THREE.Vector2(uniforms.windDirection.value[0], uniforms.windDirection.value[1]).normalize() };\r\n    uniforms.map = { value: grassTexture };\r\n    uniforms.fogColor = { value: new THREE.Color(this.fogData.color) };\r\n    uniforms.fogDensity = this.fogData.enabled ? { value: this.fogData.density } : { value: 0 };\r\n    const lightDirection = new THREE.Vector3();\r\n    lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);\r\n    lightDirection.normalize();\r\n    if(!this.pixelPass.enabled){\r\n      uniforms.directionalLightColor = { value: new THREE.Color(this.lighting.directionalColor) };\r\n      uniforms.directionalLightIntensity = { value: this.lighting.directionalIntensity };\r\n      uniforms.directionalLightDirection = { value: lightDirection };\r\n      uniforms.ambientLightColor = { value: new THREE.Color(this.lighting.ambientColor) };\r\n      uniforms.ambientLightIntensity = { value: this.lighting.ambientIntensity };\r\n    }\r\n    uniforms.skyColor = { value: new THREE.Color(this.lighting.skyColor) };\r\n    uniforms.groundColor = { value: new THREE.Color(this.lighting.groundColor) };\r\n    uniforms.hemisphereIntensity = { value: this.lighting.hemisphereIntensity };\r\n    uniforms.time = { value: this.timer };\r\n    uniforms.cameraPosition = { value: new THREE.Vector3(0, 0, 0) }; // Updated dynamically\r\n    uniforms.maxDistance = { value: 500.0 };\r\n\r\n    const grassMaterial = new THREE.ShaderMaterial({\r\n      vertexShader: grassShader.vertexScript,\r\n      fragmentShader: grassShader.fragmentScript,\r\n      uniforms: uniforms,\r\n      side: THREE.DoubleSide\r\n    });\r\n\r\n    grassGeometry.computeVertexNormals();\r\n    const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassData.grassPerChunk);\r\n    grassMesh.castShadow = false;\r\n    grassMesh.receiveShadow = false;\r\n    grassMesh.name = `grass_${chunkKey}`;\r\n    const dummy = new THREE.Object3D();    \r\n    // Use pre-computed grass data\r\n    grassData.transforms.forEach((grass, index)=>{\r\n      dummy.position.set(grass.position.x, grass.position.y, grass.position.z);\r\n      dummy.rotation.set(0, grass.rotation, 0);\r\n      dummy.scale.set(grass.scale, grass.scale, grass.scale);\r\n      dummy.updateMatrix();\r\n      grassMesh.setMatrixAt(index, dummy.matrix);      \r\n    });\r\n    grassMesh.needsUpdate = true;\r\n    return grassMesh;\r\n  }\r\n  createCurvedBladeGeometry(width = 0.1, height = 1) {\r\n    const shape = new THREE.Shape();\r\n    shape.moveTo(0, -height, 0);\r\n    shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);\r\n\r\n    const shapeGeom = new THREE.ShapeGeometry(shape, 12);\r\n    const positions = shapeGeom.attributes.position.array;\r\n    const uvs = shapeGeom.attributes.uv.array;\r\n    const vertexCount = positions.length / 3;\r\n\r\n    const newUVs = new Float32Array(uvs.length);\r\n    const newNormals = new Float32Array(positions.length);\r\n\r\n    for (let i = 0; i < vertexCount; i++) {\r\n      const posIndex = i * 3;\r\n      const uvIndex = i * 2;\r\n      const x = positions[posIndex];\r\n      const y = positions[posIndex + 1];\r\n      const normalizedY = y / height;\r\n\r\n      newUVs[uvIndex] = uvs[uvIndex];\r\n      newUVs[uvIndex + 1] = normalizedY;\r\n\r\n      const t = y / height;\r\n      const curveX = width * 0.5 * (1 - t);\r\n      const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();\r\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\r\n      newNormals[posIndex] = normal.x;\r\n      newNormals[posIndex + 1] = 0;\r\n      newNormals[posIndex + 2] = normal.y;\r\n    }\r\n\r\n    shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));\r\n    shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));\r\n    return shapeGeom;\r\n  }\r\n\r\n  createGrassTexture(grassData) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 4;\r\n    canvas.height = 32;\r\n    const ctx = canvas.getContext('2d');\r\n    const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\r\n    gradient.addColorStop(0.0, grassData.baseColor);\r\n    gradient.addColorStop(0.8, grassData.baseColor);\r\n    gradient.addColorStop(1.0, grassData.tipColor);\r\n\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const texture = new THREE.CanvasTexture(canvas);\r\n    texture.wrapS = THREE.RepeatWrapping;\r\n    texture.wrapT = THREE.ClampToEdgeWrapping;\r\n    texture.magFilter = THREE.NearestFilter;\r\n    texture.minFilter = THREE.NearestFilter;\r\n    return texture;\r\n  }\r\n  getWorkerCode() {\r\n    return `\r\n      ${this.game.getCollections().libraries[\"SimplexNoise\"].script}\r\n\r\n      ${this.game.getCollections().libraries[\"TerrainGenerator\"].script}\r\n\r\n      const noise = new SimplexNoise();\r\n      const terrainGenerator = new TerrainGenerator();\r\n      terrainGenerator.init(${JSON.stringify(this.biomes)}, ${this.chunkSize}, ${this.chunkResolution}, noise);\r\n\r\n      self.onmessage = function(e) {\r\n        const { cx, cz, chunkSize, chunkResolution } = e.data;\r\n        const result = terrainGenerator.generateChunk(cx, cz, chunkSize, chunkResolution);     \r\n        self.postMessage(result);\r\n      };\r\n    `;\r\n  }\r\n}"
      },
      "Leveler": {
        "fileName": "Leveler",
        "script": "class Leveler extends engine.Component {\r\n    \r\n init( {level = 1}) {\r\n        this.level = level;\r\n    }\r\n}"
      },
      "PlanckProjectile": {
        "fileName": "PlanckProjectile",
        "script": "class PlanckProjectile extends engine.Component {\r\n    \r\n    \r\ninit({ spawnType, owner, target, targetPosition, stats }) {\r\n  this.type = spawnType;\r\n  this.def = this.game.getCollections().projectilePrefabs[this.type];\r\n  this.owner = owner;\r\n  this.target = target;\r\n  this.targetPosition = targetPosition;\r\n  this.stats = stats;\r\n  this.piercedEnemies = [];\r\n  this.ownerStats = this.owner.getComponent(\"stats\").stats;\r\n  this.distanceTraveled = 0;\r\n  this.distanceToSpawnParticle = 24;\r\n\r\n  // Add lifespan for projectile\r\n  this.maxLifespan = this.stats.lifespan || 5; // Default to 5 seconds\r\n  this.currentLifespan = 0;\r\n  \r\n  // Get the planck body from the component\r\n  this.planckBody = this.parent.getComponent('planckBody');\r\n  \r\n  // Calculate direction and set velocity\r\n  const currentPosition = {\r\n    x: this.parent.transform.position.x,\r\n    y: this.parent.transform.position.y\r\n  };\r\n  \r\n  const targetPos = this.targetPosition ? this.targetPosition : this.target.transform.position;\r\n  const dx = targetPos.x - currentPosition.x;\r\n  const dy = targetPos.y - currentPosition.y;\r\n  const dist = Math.sqrt(dx * dx + dy * dy);\r\n  \r\n  // Normalize direction and multiply by speed\r\n  this.speed = this.stats.speed;\r\n  const velocityX = (dx / dist) * this.speed;\r\n  const velocityY = (dy / dist) * this.speed;\r\n  \r\n  // Set the linear velocity on the planck body\r\n  this.planckBody.setVelocity({ x: velocityX, y: velocityY });\r\n  \r\n  // Store a reference to this projectile in the body's user data\r\n  this.planckBody.body.setUserData(this);\r\n  \r\n  // Setup contact listener if not already done\r\n  if (!this.game.contactListenerSetup) {\r\n    this.setupContactListener();\r\n    this.game.contactListenerSetup = true;\r\n  }\r\n}\r\n\r\nsetupContactListener() {\r\n  const world = this.game.planckWorld;\r\n  \r\n  world.on('begin-contact', (contact) => {\r\n    const fixtureA = contact.getFixtureA();\r\n    const fixtureB = contact.getFixtureB();\r\n    \r\n    const bodyA = fixtureA.getBody();\r\n    const bodyB = fixtureB.getBody();\r\n    \r\n    const entityA = bodyA.getUserData();\r\n    const entityB = bodyB.getUserData();\r\n    \r\n    // Check if one is a projectile and one is an enemy\r\n    if (entityA && entityB) {\r\n      let projectile = null;\r\n      let enemy = null;\r\n      \r\n      if (entityA.parent && entityA.parent.type === \"projectile\" && !entityB.parent) {\r\n        projectile = entityA;\r\n        enemy = entityB;\r\n\r\n      } else if (entityB.parent && entityB.parent.type === \"projectile\" && !entityA.parent) {\r\n        projectile = entityB;\r\n        enemy = entityA;        \r\n      }\r\n      \r\n      if (projectile && enemy) {\r\n        // Handle collision in the next frame to avoid modifying physics during step\r\n        this.game.queuePostPhysicsCallback(() => {\r\n          projectile.handleEnemyCollision(enemy);\r\n        });\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nhandleEnemyCollision(enemy) {\r\n  // Skip if already hit this enemy or enemy is dead\r\n  if (enemy.isDead || this.piercedEnemies.includes(enemy)) {\r\n    return;\r\n  }\r\n  \r\n  // Apply damage\r\n  let enemyHealth = enemy.getComponent(\"health\");\r\n  let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n  let enemyStats = enemy.getComponent(\"stats\");\r\n  let enemyStatClone = { ...enemyStats.stats };\r\n  enemyStatClone.energyShield = enemyEnergyShield.energyShield;\r\n\r\n  // Apply damage\r\n  let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStatClone);\r\n  if (!damageResult.wasEvaded) {\r\n    enemyHealth.hp -= damageResult.damageDealt;\r\n    enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n    this.game.spawn(\"hitEffect\", {\r\n      damageType: this.stats.damageType,\r\n      lifeSpan: 0.3\r\n    },enemy.transform.position);\r\n    if (this.ownerStats.slowAmount) {\r\n      enemyStats.addEffect(\r\n        this.game.getCollections().effects.slow,\r\n        this.game.effects.slow,\r\n        this.ownerStats.slowAmount\r\n      );\r\n    }\r\n  }\r\n\r\n  // Special effects logic (summon, leech, thief)\r\n  if (\r\n    this.ownerStats.summonChance > 0 &&\r\n    enemyHealth.hp <= 0 &&\r\n    Math.random() < this.ownerStats.summonChance - 1\r\n  ) {\r\n    this.game.spawn( \"summonedTower\", {\r\n      objectType: \"towerPrefabs\",\r\n      spawnType: this.ownerStats.summonType,\r\n      owner: this.owner\r\n    },enemy.transform.position);\r\n  }\r\n  if (this.ownerStats.leech > 0) {\r\n    const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;\r\n    this.game.state.bloodCoreHP = Math.min(\r\n      this.game.state.stats.maxBloodCoreHP,\r\n      this.game.state.bloodCoreHP + healing\r\n    );\r\n  }\r\n  if (this.ownerStats.thief && this.ownerStats.thief != 0) {\r\n    const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;\r\n    this.game.state.bloodShards += stealAmt;\r\n  }\r\n\r\n  // Splash damage if applicable\r\n  if (this.stats.splashRadius > 0) {\r\n    this.applySplashDamage(enemy);\r\n    this.game.spawn(\"explosion\", {\r\n      radius: this.stats.splashRadius\r\n    },this.parent.transform.position);\r\n  }\r\n\r\n  // Piercing logic\r\n  if (this.stats.piercing > 0 && this.piercedEnemies.length < this.stats.piercing) {\r\n    this.piercedEnemies.push(enemy);\r\n    const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(\r\n      this.parent.transform.gridPosition.x,\r\n      this.parent.transform.gridPosition.y,\r\n      this.ownerStats.range,\r\n      \"enemy\"\r\n    );\r\n    const newTarget = this.findNewTarget(nearbyEnemies);\r\n    if (newTarget) {\r\n      this.target = newTarget;\r\n      this.targetPosition = null; // Switch to target-based tracking\r\n      \r\n      // Recalculate velocity toward the new target\r\n      const currentPosition = {\r\n        x: this.parent.transform.position.x,\r\n        y: this.parent.transform.position.y\r\n      };\r\n      \r\n      const dx = newTarget.position.x - currentPosition.x;\r\n      const dy = newTarget.position.y - currentPosition.y;\r\n      const dist = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (dist > 0) {\r\n        const velocityX = (dx / dist) * this.speed;\r\n        const velocityY = (dy / dist) * this.speed;\r\n        this.planckBody.setVelocity({ x: velocityX, y: velocityY });\r\n      }\r\n    } else {\r\n      // No new target, keep going but don't destroy\r\n      return;\r\n    }\r\n  } else {\r\n    // No piercing or reached piercing limit, destroy projectile\r\n    //this.parent.destroy();\r\n  }\r\n}\r\n\r\napplySplashDamage(centerEnemy) {\r\n  // Get nearby enemies within splash radius\r\n  const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(\r\n    this.parent.transform.gridPosition.x,\r\n    this.parent.transform.gridPosition.y,\r\n    this.stats.splashRadius,\r\n    \"enemy\"\r\n  );\r\n  \r\n  const gridSize = this.game.getCollections().configs.game.gridSize;\r\n  const splashRadiusSq = this.stats.splashRadius * this.stats.splashRadius * gridSize * gridSize;\r\n  \r\n  for (const enemy of nearbyEnemies) {\r\n    // Skip the center enemy (already damaged) and dead enemies\r\n    if (enemy === centerEnemy || enemy.isDead || this.piercedEnemies.includes(enemy)) continue;\r\n    \r\n    let enemyHealth = enemy.getComponent(\"health\");\r\n    let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n    let enemyStats = enemy.getComponent(\"stats\");\r\n    let enemyStatClone = { ...enemyStats.stats };\r\n    enemyStatClone.energyShield = enemyEnergyShield.energyShield;\r\n\r\n    const dx = enemy.transform.position.x - this.parent.transform.position.x;\r\n    const dy = enemy.transform.position.y - this.parent.transform.position.y;\r\n    const distSq = dx * dx + dy * dy;\r\n\r\n    if (distSq <= splashRadiusSq) {\r\n      let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStatClone);\r\n      if (!damageResult.wasEvaded) {\r\n        enemyHealth.hp -= damageResult.damageDealt;\r\n        enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n        this.game.spawn( \"hitEffect\", {\r\n          damageType: this.stats.damageType,\r\n          lifeSpan: 0.3\r\n        },enemy.transform.position);\r\n        if (this.ownerStats.slowAmount) {\r\n          enemyStats.addEffect(\r\n            this.game.getCollections().effects.slow,\r\n            this.game.effects.slow,\r\n            this.ownerStats.slowAmount\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nupdate() {\r\n  if(this.target) this.targetCurrentPosition = {...this.target.transform.position };\r\n  \r\n  // Update lifespan and destroy if expired\r\n  this.currentLifespan += this.game.deltaTime;\r\n  if (this.currentLifespan >= this.maxLifespan) {\r\n    this.parent.destroy();\r\n    return;\r\n  }\r\n\r\n  // Remove if target is gone (only if no targetPosition)\r\n  if (!this.targetPosition && (!this.target || this.target.destroyed)) {\r\n    if(this.targetCurrentPosition) {\r\n      this.targetPosition = this.targetCurrentPosition;\r\n      \r\n      // Recalculate velocity toward the last known position\r\n      const currentPosition = {\r\n        x: this.parent.transform.position.x,\r\n        y: this.parent.transform.position.y\r\n      };\r\n      \r\n      const dx = this.targetPosition.x - currentPosition.x;\r\n      const dy = this.targetPosition.y - currentPosition.y;\r\n      const dist = Math.sqrt(dx * dx + dy * dy);\r\n      \r\n      if (dist > 0) {        \r\n        const velocityX = (dx / dist) * this.speed;\r\n        const velocityY = (dy / dist) * this.speed;\r\n        this.planckBody.setVelocity({ x: velocityX, y: velocityY });\r\n      }\r\n    } else {\r\n      this.parent.destroy(); \r\n      return;\r\n    }\r\n  }\r\n    \r\n\r\n\r\n  // Particle spawning logic\r\n  const currentPos = this.planckBody.body.getPosition();\r\n  const currentVel = this.planckBody.body.getLinearVelocity();\r\n  const speed = Math.sqrt(currentVel.x * currentVel.x + currentVel.y * currentVel.y);\r\n  \r\n  // Only spawn particles if the projectile is moving\r\n  if (speed > 0 && this.def.particle) {\r\n    this.distanceTraveled += speed * this.game.deltaTime;\r\n    \r\n    if (this.distanceTraveled > this.distanceToSpawnParticle) {\r\n      this.game.spawn(\"particle\", { \r\n        objectType: \"particlePrefabs\", \r\n        spawnType: this.def.particle\r\n      },currentPos);\r\n      this.distanceTraveled = 0;\r\n      this.distanceToSpawnParticle = 24 + Math.random() * 3;\r\n    }\r\n  }\r\n}\r\n\r\n// Helper method to find a new target for piercing\r\nfindNewTarget(nearbyEnemies) {\r\n  const gridSize = this.game.getCollections().configs.game.gridSize;\r\n  const rangeSq = this.ownerStats.range * this.ownerStats.range * gridSize * gridSize;\r\n  for (let enemy of nearbyEnemies) {\r\n    if (!enemy.destroyed && !this.piercedEnemies.includes(enemy)) {\r\n      const dx = enemy.transform.position.x - this.parent.transform.position.x;\r\n      const dy = enemy.transform.position.y - this.parent.transform.position.y;\r\n      const distSq = dx * dx + dy * dy;\r\n      if (distSq < rangeSq) {\r\n        return enemy;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n}"
      },
      "MultishotProjectile": {
        "fileName": "MultishotProjectile",
        "script": "class MultishotProjectile extends engine.Component {\r\n    \r\n    \r\n    \r\ninit({ spawnType, stats, target, owner }) {\r\n  this.type = spawnType;\r\n  this.stats = stats;\r\n  this.target = target;\r\n  const ownerStats = owner.getComponent('stats').stats;\r\n  const spreadCount = ownerStats.projectileCount || 3; // Total projectiles (e.g., 3: center + 2 sides)\r\n    const spreadAngleDegrees = ownerStats.projectileAngle || 45; // Default to 45 degrees\r\n  const spreadAngle = spreadAngleDegrees * (Math.PI / 180); // Convert degrees to radians\r\n\r\n \r\n  // Calculate the base direction to the target\r\n  const dx = target.position.x - this.parent.transform.position.x;\r\n  const dy = target.position.y - this.parent.transform.position.y;\r\n  const baseAngle = Math.atan2(dy, dx); // Angle from parent to target in radians\r\n  const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n  // Total spread angle (e.g., for 3 projectiles: -spreadAngle, 0, +spreadAngle)\r\n  const totalSpread = spreadAngle * (spreadCount - 1); // Max angle covered by all projectiles\r\n\r\n  // Spawn projectiles in a symmetrical fan\r\n  for (let i = 0; i < spreadCount; i++) {\r\n    // Calculate the angle offset from the center\r\n    const offsetIndex = i - Math.floor(spreadCount / 2); // Center at 0 (e.g., -1, 0, 1 for 3)\r\n    const currentAngle = baseAngle + (offsetIndex * spreadAngle);\r\n\r\n    // Calculate the new target position based on the angle\r\n    const deltaX = Math.cos(currentAngle) * distance;\r\n    const deltaY = Math.sin(currentAngle) * distance;\r\n\r\n    this.game.spawn(\r\n      \"projectile\",\r\n      {\r\n        spawnType: ownerStats.projectile,\r\n        objectType: \"projectilePrefabs\",\r\n        owner: owner,\r\n        stats: stats,\r\n        target: target,\r\n        targetPosition: {\r\n          x: this.parent.transform.position.x + deltaX, // Start from parent, extend to new position\r\n          y: this.parent.transform.position.y + deltaY\r\n        }\r\n      },\r\n      this.parent.transform.position\r\n    );\r\n  }\r\n\r\n  this.parent.destroy();\r\n}\r\n}"
      },
      "PlanckWorld": {
        "fileName": "PlanckWorld",
        "script": "class PlanckWorld extends engine.Component {\r\n            \r\n    //planckWorld component\r\n    init({gravity = 10, gravityX = 0, gravityY = 0}) {\r\n        this.velocityIterations = 6;\r\n        this.positionIterations = 2;\r\n        this.physicsUpdateTimer = 0;\r\n        this.timeStep = 1 / 60; // Fixed timestep of 60fps\r\n        \r\n        const { World } = planck;\r\n        this.game.planckWorld = new World();\r\n    }\r\n\r\n    postUpdate() {\r\n        this.game.planckWorld.step(this.timeStep, this.velocityIterations, this.positionIterations);\r\n    }\r\n}"
      },
      "PlanckBody": {
        "fileName": "PlanckBody",
        "script": "class PlanckBody extends engine.Component {\r\n\r\n    \r\ninit({box2DBodySize = 1, density = 1, friction= 0, layer = 0x0001, collidesWith = 0x0001}) {\r\n  \r\n   const { Box } = planck;\r\n  this.body = this.game.planckWorld.createBody({\r\n    type: \"dynamic\",\r\n    position: {x: this.parent.transform.position.x, y: this.parent.transform.position.y}\r\n  });\r\n  this.body.createFixture({\r\n      shape: new Box(1.0, 1.0),\r\n      density: density,\r\n      friction: friction,\r\n  });\r\n  this.speedScale = 10;\r\n}\r\n\r\nupdate() {\r\n  if (!this.body) return;\r\n  const bodyPos = this.body.getTransform().p;\r\n\r\n  // Update game object position\r\n  this.parent.transform.position.x = bodyPos.x;\r\n  this.parent.transform.position.y = bodyPos.y;\r\n\r\n}\r\n\r\nsetVelocity(vel) {\r\n\tthis.body.setLinearVelocity({ x: vel.x*this.speedScale, y: vel.y * this.speedScale });\r\n}\r\ngetVelocity() {\r\n  let vel = this.body.getLinearVelocity();\r\n  return { x: vel.x / this.speedScale, y: vel.y / this.speedScale };\r\n}\r\npostUpdate() {\r\n  //this.body.applyForce({ x: 10, y: 0}, { x: this.parent.transform.position.x, y: this.parent.transform.position.y});\r\n}\r\n}"
      },
      "LifeSpan": {
        "fileName": "LifeSpan",
        "script": "class LifeSpan extends engine.Component {\r\n\r\n    \r\n    init( {lifeSpan}) {\r\n        this.lifeSpan = lifeSpan || this.getComponent('stats').stats.lifeSpan;\r\n    }\r\n    update() {        \r\n        if( this.lifeSpan > 0 ) {\r\n            this.lifeSpan -= this.game.deltaTime;\r\n        } else {\r\n            this.parent.destroy();\r\n        }\r\n    }\r\n}"
      },
      "PopulationBurden": {
        "fileName": "PopulationBurden",
        "script": "class PopulationBurden extends engine.Component {\r\n        \r\n    init(){\r\n        this.stats = this.parent.getComponent('stats').stats;        \r\n    }\r\n    update() {\r\n        if(this.stats){ \r\n            if( this.stats.population ) {\r\n                this.game.state.stats.population += this.stats.population;\r\n            } \r\n            if( this.stats.supply ) {\r\n                this.game.state.stats.maxPopulation += this.stats.supply;\r\n            }\r\n        }\r\n    }\r\n}"
      },
      "Projectile": {
        "fileName": "Projectile",
        "script": "class Projectile extends engine.Component {\r\n   \r\n  init({ spawnType, owner, direction }) {\r\n      this.projectilePrefabData = this.game.getCollections().projectilePrefabs[spawnType];\r\n      this.projectileData = this.game.getCollections().projectiles[this.projectilePrefabData.projectile];\r\n      this.owner = owner;\r\n      this.piercedEnemies = [];\r\n      if(this.owner){\r\n        this.ownerStats = this.owner.getComponent(\"stats\").stats;\r\n      }\r\n      this.distanceTraveled = 0;\r\n      this.distanceToSpawnParticle = 24;\r\n      this.direction = direction || new THREE.Vector3();\r\n      \r\n      // Add lifespan for projectile\r\n      this.maxLifespan = this.projectileData.lifespan || 30;  \r\n      this.currentLifespan = 0;\r\n      \r\n      if(this.projectileData.attackSound){\r\n          this.game.audioManager.playSound('sounds', this.projectileData.attackSound);\r\n      }      \r\n      // Add physics properties\r\n      this.parent.transform.velocity = new THREE.Vector3(\r\n          this.direction.x * this.projectileData.speed,\r\n          this.direction.y * this.projectileData.speed,\r\n          this.direction.z * this.projectileData.speed\r\n      );    \r\n      if(this.owner){\r\n        this.parent.transform.velocity = this.parent.transform.velocity.add(this.owner.transform.velocity.clone());\r\n      }\r\n\r\n  }\r\n  \r\n  update() {\r\n      // Update lifespan and destroy if expired\r\n      this.currentLifespan += this.game.deltaTime;\r\n      if (this.currentLifespan >= this.maxLifespan) {\r\n          this.parent.destroy();\r\n          return;\r\n      }\r\n      // Don't directly modify position - let the physics system handle it\r\n      // Instead, only update non-physical properties\r\n      \r\n      // Particle spawning logic\r\n      if (this.parent.lastPosition) {\r\n          const tDx = this.parent.transform.lastPosition.x - this.parent.transform.position.x;\r\n          const tDy = this.parent.transform.lastPosition.y - this.parent.transform.position.y;\r\n          const tDz = this.parent.transform.lastPosition.z - this.parent.transform.position.z;\r\n          const tDistSq = tDx * tDx + tDy * tDy + tDz * tDz;\r\n          const tDist = Math.sqrt(tDistSq);\r\n          this.distanceTraveled += tDist;\r\n          \r\n          if (this.projectileData.particle && this.distanceTraveled > this.distanceToSpawnParticle) {\r\n              this.game.spawn(\"particle\", { \r\n                  objectType: \"particlePrefabs\", \r\n                  spawnType: this.projectileData.particlePrefab\r\n              }, this.parent.transform.position);\r\n              this.distanceTraveled = 0;\r\n              this.distanceToSpawnParticle += Math.random() * 3;\r\n          }\r\n      }\r\n      \r\n      // Store current position for next frame\r\n      this.parent.transform.lastPosition = {\r\n          x: this.parent.transform.position.x,\r\n          y: this.parent.transform.position.y,\r\n          z: this.parent.transform.position.z\r\n      };\r\n      \r\n      if(this.parent.grounded){\r\n        //this.OnStaticCollision();\r\n        //this.parent.destroy();\r\n      }\r\n      // Add impact check logic here if needed\r\n      // Check for enemy collisions, etc.\r\n  }\r\n  \r\n  OnCollision(collidedWith){\r\n    if(this.projectileData.hitSound){\r\n      this.game.audioManager.playSound('sounds', this.projectileData.hitSound);\r\n    }\r\n   // this.parent.destroy();\r\n  }\r\n  OnStaticCollision(){\r\n    if(this.projectileData.hitSound && this.parent.transform.physicsVelocity.length() > 50){\r\n      this.game.audioManager.playSound('sounds', this.projectileData.hitSound);\r\n    }\r\n  }\r\n  destroy() {\r\n      // Clean up physics registration\r\n      if (this.physics) {\r\n          this.physics.unregisterEntity(this.parent.id);\r\n      }\r\n      \r\n      // Optional: Spawn impact effect\r\n      if (this.projectileData.impactParticle) {\r\n          this.game.spawn(\"particle\", {\r\n              objectType: \"particlePrefabs\", \r\n              spawnType: this.projectileData.impactParticlePrefab\r\n          }, this.parent.transform.position);\r\n      }\r\n  }\r\n}"
      },
      "SpacialGridEntity": {
        "fileName": "SpacialGridEntity",
        "script": "class SpacialGridEntity extends engine.Component {\r\n    \r\n   update() {\r\n        this.game.spatialGrid.insert(this.parent);\r\n    }\r\n    destroy() {\r\n        this.game.spatialGrid.remove(this.parent);\r\n    }\r\n}"
      },
      "Stats": {
        "fileName": "Stats",
        "script": "class Stats extends engine.Component {\r\n    \r\n    \r\n  init( {objectType, spawnType} ) {        \r\n        \r\n        let stats = this.game.getCollections()[objectType][spawnType];\r\n        this.type = spawnType;\r\n        this.stats = {...stats};\r\n        this.defaultStats = {...this.stats};\r\n        this.activeEffects = {};\r\n    }\r\n    update() {\r\n        this.stats = {...this.defaultStats};\r\n        //this.applyEffects();\r\n        //this.applyUpgrades();\r\n    }\r\n    addStat(statName, statValue) {\r\n        this.stats[statName] = statValue;\r\n        this.defaultStats[statName] = statValue;\r\n    }\r\n    addEffect(effectConfig, effectFn, effectAmt) {        \r\n        this.activeEffects[effectConfig.id] = this.parent.addComponent(\"effect\", { config: effectConfig, applyFn: effectFn, amount: effectAmt });\r\n    }  \r\n}"
      },
      "UpgradeManager": {
        "fileName": "UpgradeManager",
        "script": "class UpgradeManager extends engine.Component {\r\n        \r\n\r\n    init() {\r\n        this.game.state.activeUpgrades = {};\r\n    }\r\n    \r\n    update() {\r\n       this.applyActiveUpgrades();\r\n        // Level Up check\r\n        if (this.game.state.essence >= this.game.state.essenceToNextLevel && !this.game.state.isLevelingUp) {\r\n            this.showUpgradeMenu();\r\n        }\r\n    }\r\n\r\n    applyActiveUpgrades() {\r\n        engine.getFunction(\"calculateStats\")(this.game.state.stats, this.game.state.activeUpgrades['global']);    \r\n    }\r\n\r\n    \r\n    // Upgrade system\r\n    showUpgradeMenu() {\r\n        if (this.game.state.isLevelingUp) return; // Prevent re-triggering\r\n        \r\n        this.game.state.isLevelingUp = true;\r\n        this.game.state.isPaused = true;\r\n        \r\n        this.game.uiManager.upgradeMenu.style.display = 'block';\r\n        this.game.uiManager.overlay.style.display = 'block';\r\n        this.game.uiManager.upgradeOptionsDiv.innerHTML = '';\r\n        \r\n        // Filter upgrades based on conditions\r\n        const availableUpgrades = this.game.upgrades.filter(upgrade => upgrade.canApply(this.game.state));\r\n        \r\n        // Choose 3 random upgrades\r\n        const options = [];\r\n        while (options.length < 3 && availableUpgrades.length > 0) {\r\n            const index = Math.floor(Math.random() * availableUpgrades.length);\r\n            options.push(availableUpgrades[index]);\r\n            availableUpgrades.splice(index, 1);\r\n        }\r\n        \r\n        // Create upgrade options\r\n        options.forEach(upgrade => {\r\n            const div = document.createElement('div');\r\n            div.className = 'upgrade-option';\r\n            div.innerHTML = `\r\n                <div class=\"upgrade-icon\">${upgrade.icon}</div>\r\n                <div class=\"upgrade-desc\">\r\n                    <div class=\"upgrade-title\">${upgrade.title}</div>\r\n                    ${upgrade.desc}\r\n                </div>\r\n            `;\r\n            div.onclick = () => this.selectUpgrade(upgrade);\r\n            this.game.uiManager.upgradeOptionsDiv.appendChild(div);\r\n        });\r\n    }\r\n\r\n    selectUpgrade(upgrade) {       \r\n        // Add to active upgrades list if not already\r\n        if (!this.game.state.activeUpgrades[upgrade.appliesTo]) {\r\n            this.game.state.activeUpgrades[upgrade.appliesTo] = [upgrade];\r\n        } else {\r\n            this.game.state.activeUpgrades[upgrade.appliesTo].push(upgrade);\r\n        }\r\n\r\n        this.applyActiveUpgrades();\r\n        if(upgrade.onAcquire) {\r\n            upgrade.onAcquire(this.game.state);\r\n        }\r\n        \r\n        upgradeMenu.style.display = 'none';\r\n        overlay.style.display = 'none';\r\n        \r\n        this.game.state.essence -= this.game.state.essenceToNextLevel;\r\n        this.game.state.level++;\r\n        this.game.state.essenceToNextLevel = Math.floor(this.game.state.essenceToNextLevel * 1.4);        \r\n        \r\n        this.game.state.isLevelingUp = false;\r\n        this.game.state.isPaused = false;\r\n    }\r\n}"
      },
      "WaveManager": {
        "fileName": "WaveManager",
        "title": "AudioManager",
        "script": "class WaveManager extends engine.Component {\r\n    \r\n    init() {   \r\n        \r\n        this.resetWaveState();\r\n    }\r\n\r\n    resetWaveState() {\r\n        this.game.state.waveSets = this.game.getCollections().levels[this.game.state.level].wavesets;\r\n        this.game.state.currentWaveIds = [];\r\n        this.game.state.currentWaveEnemies = [];\r\n        this.game.state.enemiesSpawned = [];\r\n        this.game.state.spawnTimers = []; // Array for individual spawn timers\r\n        this.game.state.spawnRate = 1;    // Base spawn rate (can be modified per waveset if needed)\r\n        this.game.state.waveTimer = 0;\r\n        this.game.state.startDelayTimer = 0;\r\n        this.game.state.round = 0;\r\n    }\r\n\r\n    update() {\r\n        // Skip wave updates if game is over or in certain states\r\n        if (this.game.state.gameOver || this.game.state.victory || this.game.state.isLevelingUp) return;\r\n\r\n        this.game.state.startDelayTimer += this.game.deltaTime;\r\n\r\n        // Process all wavesets in parallel\r\n        for (let i = 0; i < this.game.state.currentWaveIds.length; i++) {\r\n            let waveSet = this.game.getCollections().wavesets[this.game.state.waveSets[i]];\r\n            \r\n            // Skip if still in start delay\r\n            if (waveSet.startDelay && this.game.state.startDelayTimer < waveSet.startDelay) continue;\r\n            \r\n            if(this.game.deltaTime){\r\n            // Update individual spawn timer for this waveset\r\n                this.game.state.spawnTimers[i] += this.game.deltaTime;\r\n            }\r\n            // If this waveset still has enemies to spawn\r\n            if (this.game.state.enemiesSpawned[i] < this.game.state.currentWaveEnemies[i].length) {\r\n                if (this.game.state.spawnTimers[i] >= this.game.state.spawnRate) {\r\n                    // Create enemy from the appropriate waveset using the enemy type and start point index\r\n                    const enemyType = this.game.state.currentWaveEnemies[i][this.game.state.enemiesSpawned[i]];\r\n                    const startPointIndex = i;\r\n                    \r\n                    \r\n                    this.game.spawn('enemy', { objectType: \"enemyPrefabs\", spawnType: enemyType, pathIndex: startPointIndex, friction: 1000, density: 1000}, new THREE.Vector3());\r\n                    this.game.state.enemiesSpawned[i]++;\r\n                    this.game.state.spawnTimers[i] = 0; // Reset this waveset's timer\r\n                    \r\n                    // Calculate total progress across all wavesets\r\n                    const totalEnemies = this.game.state.currentWaveEnemies.reduce((sum, wave) => sum + wave.length, 0);\r\n                    const totalSpawned = this.game.state.enemiesSpawned.reduce((sum, count) => sum + count, 0);\r\n                    \r\n                    // Update wave progress bar\r\n                    document.getElementById('waveProgress').style.width = (totalSpawned / totalEnemies * 100) + '%';\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Check if all wavesets have completed spawning\r\n        const allWavesetsComplete = this.game.state.enemiesSpawned.every((spawned, index) => \r\n            spawned >= this.game.state.currentWaveEnemies[index].length\r\n        );\r\n        \r\n        // Move to next wave if all enemies defeated and all wavesets have completed spawning\r\n        if (this.game.state.enemies.length === 0 && allWavesetsComplete) {\r\n            this.game.state.waveTimer++;\r\n            \r\n            if (this.game.state.waveTimer >= this.game.state.waveDelay) {\r\n                this.startNextWave();\r\n            }\r\n        }\r\n    }\r\n\r\n    startNextWave() {\r\n        document.getElementById('waveDisplay').textContent = this.game.state.round + 1;\r\n        \r\n        this.game.state.currentWaveIds = [];\r\n        this.game.state.currentWaveEnemies = [];\r\n        this.game.state.enemiesSpawned = [];\r\n        this.game.state.spawnTimers = [];\r\n        \r\n        let totalWaves = 0;\r\n        for (let i = 0; i < this.game.state.waveSets.length; i++) {\r\n            const waveSetId = this.game.state.waveSets[i];\r\n            const waveSet = this.game.getCollections().wavesets[waveSetId];\r\n            \r\n            // Check if this waveset has enough waves for the current round\r\n            if (this.game.state.round < waveSet.waves.length) {\r\n                const currentWaveId = waveSet.waves[this.game.state.round];\r\n                \r\n                // Add this wave to the current active waves\r\n                this.game.state.currentWaveIds.push(currentWaveId);\r\n                this.game.state.currentWaveEnemies.push(this.game.getCollections().waves[currentWaveId].enemies);\r\n                this.game.state.enemiesSpawned.push(0);\r\n                this.game.state.spawnTimers.push(0); // Initialize spawn timer for this waveset\r\n            }\r\n            \r\n            totalWaves = Math.max(totalWaves, waveSet.waves.length);\r\n        }\r\n        \r\n        // If all wavesets are exhausted, end the game\r\n        if (this.game.state.currentWaveIds.length === 0) {\r\n            this.game.state.victory = true;\r\n            this.game.state.isPaused = true;\r\n            document.getElementById('victoryMenu').style.display = 'block';\r\n            document.getElementById('overlay').style.display = 'block';\r\n            return;\r\n        }\r\n        \r\n        this.game.state.maxWaves = totalWaves;\r\n        this.game.state.spawnRate = 5;\r\n        this.game.state.waveTimer = 0;\r\n        this.game.state.startDelayTimer = 0;\r\n        \r\n        // Reset wave progress bar\r\n        document.getElementById('waveProgress').style.width = '0%';\r\n        this.game.state.round++;\r\n    }\r\n}"
      }
    },
    "entities": {
      "ballisticProjectile": {
        "title": "Ballistic Projectile",
        "components": [
          "Stats",
          "ArrayTracker",
          "BallisticProjectile",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "Renderer"
        ]
      },
      "enemy": {
        "title": "Enemy",
        "components": [
          "Stats",
          "ArrayTracker",
          "Collider"
        ],
        "renderers": [
          "ModelRenderer",
          "Health",
          "EnergyShield"
        ]
      },
      "explosion": {
        "title": "Explosion",
        "components": [],
        "renderers": [
          "Explosion"
        ]
      },
      "game": {
        "title": "Game",
        "components": [
          "AudioManager",
          "InfiniWorld",
          "Physics",
          "Game"
        ],
        "renderers": [
          "UiManager"
        ]
      },
      "GameLoader": {
        "title": "Game Loader",
        "components": [
          "GameLoader"
        ],
        "renderers": []
      },
      "hitEffect": {
        "title": "Hit Effect",
        "components": [
          "HitEffectParticle",
          "LifeSpan"
        ],
        "renderers": [
          "HitEffectRenderer"
        ]
      },
      "lightningProjectile": {
        "title": "Lightning Projectile",
        "components": [
          "Stats",
          "ArrayTracker",
          "ChainProjectile"
        ],
        "renderers": [
          "LightningRenderer"
        ]
      },
      "particle": {
        "title": "Particle",
        "components": [
          "Stats",
          "LifeSpan",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "Renderer"
        ]
      },
      "multiShotProjectile": {
        "title": "Multi-Shot Projectile",
        "components": [
          "Stats",
          "MultishotProjectile"
        ],
        "renderers": []
      },
      "player": {
        "title": "Player",
        "components": [
          "Stats",
          "PlayerController",
          "Animator",
          "PlayerAttacker"
        ],
        "renderers": [
          "ModelRenderer",
          "Health"
        ]
      },
      "playerAircraft": {
        "title": "Player Aircraft",
        "components": [
          "Stats",
          "PlayerAttacker",
          "AircraftController"
        ],
        "renderers": [
          "ModelRenderer",
          "Health"
        ]
      },
      "previewTower": {
        "title": "Preview Tower",
        "components": [
          "Stats",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "RangeIndicator",
          "Renderer"
        ]
      },
      "projectile": {
        "title": "Projectile",
        "components": [
          "Stats",
          "ArrayTracker",
          "Projectile",
          "Animator",
          "Collider"
        ],
        "renderers": [
          "ModelRenderer",
          "Renderer"
        ]
      },
      "staticObject": {
        "title": "Static Object",
        "components": [
          "ArrayTracker",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "Renderer"
        ]
      },
      "summonedTower": {
        "title": "Summoned Tower",
        "components": [
          "Stats",
          "ArrayTracker",
          "Attacker",
          "LifeSpan",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "RangeIndicator",
          "Renderer"
        ]
      },
      "tower": {
        "title": "Tower",
        "components": [
          "Stats",
          "ArrayTracker",
          "Leveler",
          "Buildable",
          "PopulationBurden",
          "Attacker",
          "Animator"
        ],
        "renderers": [
          "ModelRenderer",
          "RangeIndicator",
          "Renderer"
        ]
      }
    },
    "functions": {
      "calculateDamage": {
        "fileName": "calculateDamage",
        "script": "function calculateDamage(attack, target) {\r\n    // Set default values if not provided\r\n    \r\n    attack.speed = attack.speed || 5;     \r\n    attack.piercing = attack.piercing || 0,\r\n    attack.splashRadius = attack.splashRadius || 0;\r\n    attack.critChance = attack.critChance || .05;\r\n    attack.critMultiplier = attack.critMultiplier || 2;\r\n    attack.penetration = {\r\n      \"fire\": attack.firePenetration || 0,\r\n      \"electric\": attack.electricPenetration || 0,\r\n      \"cold\": attack.coldPenetration || 0,\r\n      \"physical\": attack.physicalPenetration || 0,\r\n      \"toxic\": attack.toxicPenetration || 0,\r\n    }\r\n    target.resistances = {\r\n      \"fire\": target.fireResistance || 0,\r\n      \"electric\": target.electricResistance || 0,\r\n      \"cold\": target.coldResistance || 0,\r\n      \"physical\": target.physicalResistance || 0,\r\n      \"toxic\": target.toxicResistance || 0,\r\n    }\r\n    \r\n    // Initialize result object\r\n    const result = {\r\n      damageBlocked: 0,\r\n      damageAbsorbed: 0,\r\n      damageDealt: 0,\r\n      energyShieldRemaining: target.energyShield || 0,\r\n      wasEvaded: false,\r\n      wasCritical: Math.random() <= attack.critChance,\r\n      hitDetails: {}\r\n    };\r\n    \r\n    // Check for evasion\r\n    if (target.evasion && target.evasion > 0) {\r\n      const evasionRoll = Math.random() * 100;\r\n      if (evasionRoll < target.evasion) {\r\n        result.wasEvaded = true;\r\n        result.hitDetails.evasion = \"Attack evaded\";\r\n        return result;\r\n      }\r\n    }\r\n    \r\n    // Calculate initial damage\r\n    let damage = attack.baseDamage;\r\n    \r\n    // Apply critical hit\r\n    if (result.wasCritical) {\r\n      damage *= attack.critMultiplier;\r\n      result.hitDetails.critical = `Critical hit (${attack.critMultiplier}x damage)`;\r\n    }\r\n    \r\n    // Apply resistances based on damage type\r\n  \r\n    if(attack.damageType != \"physical\") {\r\n      const resistance = target.resistances[attack.damageType] || 0;\r\n      const penetration = attack.penetration[attack.damageType] || 0;\r\n      const finalResist = resistance - penetration;\r\n      let resistanceMultiplier = 1 - (finalResist / 100);\r\n      damage *= resistanceMultiplier;\r\n  \r\n      \r\n      if (finalResist !== 0) {\r\n        if (finalResist > 0) {\r\n          result.hitDetails.resistance = `${attack.damageType} resisted (${finalResist}%)`;\r\n        } else {\r\n          result.hitDetails.resistance = `${attack.damageType} vulnerability (${-finalResist}%)`;\r\n        }\r\n      }  \r\n    }\r\n    \r\n    // Apply armor (only affects physical damage)\r\n    if (attack.damageType === \"physical\" && target.armor > 0) {\r\n      let effectiveArmor = target.armor;\r\n      if (attack.penetration.physical > 0 ) {\r\n        // Piercing ignores 75% of armor\r\n        effectiveArmor = target.armor * (1 - attack.penetration.physical);\r\n      }\r\n      // Armor formula: damage reduction percentage = armor / (armor + 100)\r\n      const armorReduction = effectiveArmor / (effectiveArmor + 100);\r\n      const blockedDamage = damage * armorReduction;\r\n      \r\n      damage -= blockedDamage;\r\n      result.damageBlocked = blockedDamage;\r\n      result.hitDetails.armor = `Armor blocked ${blockedDamage.toFixed(1)} damage`;\r\n    }\r\n    \r\n    // Round damage to 1 decimal place for cleaner numbers\r\n    damage = Math.round(damage * 10) / 10;\r\n    \r\n    // Apply shield absorption\r\n    if (target.energyShield > 0) {\r\n      if (damage <= target.energyShield) {\r\n        // Shield absorbs all damage\r\n        result.damageAbsorbed = damage;\r\n        result.energyShieldRemaining = target.energyShield - damage;\r\n        result.hitDetails.energyShield = `Shield absorbed all damage, ${result.energyShieldRemaining.toFixed(1)} shield remaining`;\r\n        damage = 0;\r\n      } else {\r\n        // Shield is depleted, remaining damage goes through\r\n        result.damageAbsorbed = target.energyShield;\r\n        result.damageDealt = damage - target.energyShield;\r\n        result.energyShieldRemaining = 0;\r\n        result.hitDetails.energyShield = `Shield depleted, ${result.damageDealt.toFixed(1)} damage dealt to health`;\r\n        damage -= target.energyShield;\r\n      }\r\n    } else {\r\n      // No shield, all damage goes to health\r\n      result.damageDealt = damage;\r\n    }\r\n    \r\n    // Make sure we don't return negative damage\r\n    result.damageDealt = Math.max(0, result.damageDealt);\r\n    \r\n    return result;\r\n  }\r\n"
      },
      "calculateStats": {
        "fileName": "calculateStats",
        "script": "function calculateStats(stats, calcArray) {\r\n\r\n    if( calcArray && calcArray.length > 0 ) {\r\n        let additiveStats = {};\r\n        let multiplicitiveStats = {};\r\n        for(let key in stats) {\r\n            additiveStats[key] = [];\r\n            multiplicitiveStats[key] = [];\r\n        }\r\n        for(let effect of calcArray) {\r\n            effect.apply(stats, additiveStats, multiplicitiveStats);\r\n        }\r\n        let addedEffects = {};\r\n        for(let key in additiveStats){\r\n            for(let val of additiveStats[key]){ \r\n                if(addedEffects[key]){\r\n                    addedEffects[key] += val - 1;\r\n                } else {\r\n                    addedEffects[key] = val - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let key in addedEffects) {\r\n            if( stats[key] ) {\r\n                stats[key] *= ( 1 + addedEffects[key] );\r\n            }\r\n        }\r\n\r\n        let multipliedUpgrades = {};        \r\n        for(let key in multiplicitiveStats){\r\n            for(let val of multiplicitiveStats[key]){ \r\n                if(stats[key]){\r\n                    stats[key] *= val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
      }
    },
    "interfaces": {
      "main": {
        "title": "Main Interface",
        "modals": [],
        "fileName": "main",
        "css": ":root {\r\n\t/* Solid hex colors */\r\n\t--primary-dark: #0f2418;\r\n\t/* Deep forest green */\r\n\t--primary-bg: #1a3526;\r\n\t/* Dark moss green */\r\n\t--secondary-bg: #224031;\r\n\t/* Muted pine green */\r\n\t--accent-color: #4a7c59;\r\n\t/* Fresh green (main accent) - matches grass */\r\n\t--bright-accent: #5a9e6f;\r\n\t/* Lighter, vibrant green */\r\n\t--highlight-color: #6abe54;\r\n\t/* Soft green highlight - matches necroOrb */\r\n\t--shadow-color: #3a443c;\r\n\t/* Darker green for shadows */\r\n\t--text-color: #f7f7f0;\r\n\t/* Off-white for readability - matches our palette */\r\n\t--gold-color: #e3d163;\r\n\t/* Warm gold - matches goldMine inner */\r\n\t--essence-color: #7047a3;\r\n\t/* Purple for essence - matches necromancer color */\r\n\t--health-color: #4a7c59;\r\n\t/* Forest green - matches grass */\r\n\t/* Opacity variables for use with solid colors */\r\n\t--semi-transparent: 0.6;\r\n\t--high-transparent: 0.8;\r\n\t--very-high-transparent: 0.95;\r\n\t--low-transparent: 0.3;\r\n\t--overlay-transparent: 0.75;\r\n\t--hover-transparent: 0.9;\r\n\t--full-transparent: 0.98;\r\n\t--near-full-transparent: 0.99;\r\n}\r\n\r\n* {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbox-sizing: border-box;\r\n}\r\n\r\nbody {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbackground-color: var(--primary-dark);\r\n\tbackground-image: radial-gradient(circle at center, var(--primary-bg) 0%, var(--primary-dark) 100%);\r\n\tcolor: var(--text-color);\r\n\tfont-family: 'Crimson Pro', serif;\r\n\toverflow: hidden;\r\n\tline-height: 1.6;\r\n}\r\n\r\n#gameContainer {\r\n    position: relative;\r\n    width: 100vw;\r\n    height: 100vh;\r\n}\r\n\r\ncanvas { \r\n    background-color: var(--secondary-bg);\r\n    transition: transform 0.3s ease;\r\n    width: 100vw;\r\n    height: 100vh;\r\n    position: absolute;\r\n    left: 0;\r\n    top: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    margin: 0;\r\n    z-index: 0;\r\n}\r\n\r\n/* ========== Tower Menu Container ========== */\r\n#towerMenu {\r\n\tdisplay: none;\r\n    position: absolute;\r\n    bottom: 30px;\r\n    border-radius: 14px;\r\n    padding: .5em;\r\n    max-width: 90%;\r\n    width: 820px;\r\n    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);\r\n    border: 1px solid var(--accent-color);\r\n\tbackground-color: var(--primary-dark);\r\n    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));\r\n    gap: 5px;\r\n    z-index: 100;\r\n\tleft: 0;\r\n\tright: 0;\r\n\tmargin: 0 auto;\r\n\toverflow-x: auto;\r\n\toverflow-y: hidden;\r\n\tpadding: 10px;\r\n\tscrollbar-width: thin;\r\n\tscrollbar-color: var(--accent-color) transparent;\r\n}\r\n\r\n/* ========== Tower Options ========== */\r\n.tower-option {\r\n\tbackground-color: var(--secondary-bg);\r\n\tborder-radius: 8px;\r\n\tborder: 1px solid var(--accent-color);\r\n\tcolor: var(--text-color);\r\n\tcursor: pointer;\r\n\tpadding: .1em .5em;\r\n}\r\n.tower-option:hover {\r\n\tbackground-color: var(--primary-bg);\r\n\ttransition: background-color 0.3s ease;\r\n}\t\r\n\r\n#statsContainer {\r\n\tdisplay: none;\r\n\twidth: 800px;\r\n\tmax-width: 90%;\r\n\tpadding: 12px;\r\n\tbackground: var(--primary-dark);\r\n\tborder-radius: 10px;\r\n\tborder: 1px solid var(--accent-color);\r\n\tborder-opacity: var(--low-transparent);\r\n\t/* Note: This won't work directly; see below */\r\n\tbackdrop-filter: blur(5px);\r\n\tposition: absolute;\r\n\tz-index: 1;\r\n\tmargin: 1em auto;\r\n\tleft: 0;\r\n\tright: 0;\r\n}\r\n\r\n#stats {\r\n\tdisplay: flex;\r\n\tjustify-content: space-around;\r\n\tgap: 20px;\r\n\tflex-wrap: wrap;\r\n}\r\n\r\n.stat {\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tgap: 8px;\r\n\tfont-size: 1.1rem;\r\n}\r\n\r\n.stat-icon {\r\n\twidth: 24px;\r\n\theight: 24px;\r\n\tborder-radius: 50%;\r\n\tbox-shadow: 0 0 8px #000;\r\n\tdisplay: flex;\r\n\tjustify-content: center;\r\n\talign-items: center;\r\n}\r\n\r\n#upgradeMenu {\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n\tbackground: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));\r\n\topacity: var(--very-high-transparent);\r\n\tcolor: var(--text-color);\r\n\tpadding: 25px;\r\n\tborder-radius: 12px;\r\n\tborder: 2px solid var(--accent-color);\r\n\tdisplay: none;\r\n\tz-index: 10;\r\n\twidth: 450px;\r\n\tbox-shadow: 0 0 40px var(--shadow-color);\r\n\tbackdrop-filter: blur(10px);\r\n}\r\n\r\n#upgradeMenu h2 {\r\n\ttext-align: center;\r\n\tcolor: var(--highlight-color);\r\n\tmargin-top: 0;\r\n\tborder-bottom: 1px solid var(--accent-color);\r\n\tpadding-bottom: 15px;\r\n\tfont-family: 'Cinzel', serif;\r\n\tletter-spacing: 1px;\r\n\tfont-weight: 700;\r\n}\r\n\r\n.upgrade-option {\r\n\tmargin: 18px 0;\r\n\tpadding: 18px;\r\n\tbackground: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));\r\n\topacity: var(--high-transparent);\r\n\tcursor: pointer;\r\n\tborder-radius: 8px;\r\n\ttransition: all 0.3s;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tborder: 1px solid var(--accent-color);\r\n\tborder-opacity: var(--low-transparent);\r\n\t/* Note: This won't work directly; see below */\r\n\tbox-shadow: 0 4px 8px #000;\r\n}\r\n\r\n.upgrade-option:hover {\r\n\tbackground: linear-gradient(to right, var(--accent-color), var(--bright-accent));\r\n\topacity: var(--hover-transparent);\r\n\ttransform: translateX(8px);\r\n\tbox-shadow: 0 6px 12px #000;\r\n}\r\n\r\n.upgrade-icon {\r\n\twidth: 48px;\r\n\theight: 48px;\r\n\tmargin-right: 18px;\r\n\tbackground: linear-gradient(135deg, var(--accent-color), var(--secondary-bg));\r\n\tborder-radius: 8px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\r\n\tfont-size: 22px;\r\n\tbox-shadow: 0 3px 6px #000;\r\n}\r\n\r\n.upgrade-desc {\r\n\tflex-grow: 1;\r\n}\r\n\r\n.upgrade-title {\r\n\tfont-weight: bold;\r\n\tmargin-bottom: 6px;\r\n\tcolor: var(--highlight-color);\r\n\tfont-size: 1.2rem;\r\n\tfont-family: 'Cinzel', serif;\r\n}\r\n\r\n#overlay {\r\n\tposition: absolute;\r\n\ttop: 0;\r\n\tleft: 0;\r\n\twidth: 100%;\r\n\theight: 100%;\r\n\tbackground: #000;\r\n\topacity: var(--overlay-transparent);\r\n\tdisplay: none;\r\n\tz-index: 5;\r\n\tbackdrop-filter: blur(3px);\r\n}\r\n\r\n#waveInfo {\r\n\tposition: absolute;\r\n\ttop: 15px;\r\n\tleft: 50%;\r\n\ttransform: translateX(-50%);\r\n\tbackground: linear-gradient(to right, var(--secondary-bg), var(--primary-bg));\r\n\topacity: var(--high-transparent);\r\n\tpadding: 8px 20px;\r\n\tborder-radius: 20px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tgap: 15px;\r\n\tbox-shadow: 0 4px 12px #000;\r\n\tborder: 1px solid var(--accent-color);\r\n\tborder-opacity: var(--low-transparent);\r\n\t/* Note: This won't work directly; see below */\r\n\tbackdrop-filter: blur(5px);\r\n}\r\n\r\n#waveDisplay {\r\n\tfont-weight: bold;\r\n\tcolor: var(--highlight-color);\r\n}\r\n\r\n.progress-bar {\r\n\twidth: 220px;\r\n\theight: 12px;\r\n\tbackground: var(--primary-dark);\r\n\tborder-radius: 6px;\r\n\toverflow: hidden;\r\n\tbox-shadow: inset 0 1px 3px #000;\r\n\tborder: 1px solid var(--accent-color);\r\n\tborder-opacity: var(--low-transparent);\r\n\t/* Note: This won't work directly; see below */\r\n}\r\n\r\n.progress-fill {\r\n\theight: 100%;\r\n\tbackground: linear-gradient(to right, var(--accent-color), var(--highlight-color));\r\n\twidth: 0%;\r\n\tbox-shadow: 0 0 8px var(--shadow-color);\r\n\ttransition: width 0.3s ease;\r\n}\r\n\r\n#startGameBtn {\r\n\tpadding: 12px 35px;\r\n\tbackground: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));\r\n\tcolor: white;\r\n\tborder: none;\r\n\tborder-radius: 30px;\r\n\tcursor: pointer;\r\n\tfont-family: 'Cinzel', serif;\r\n\tfont-weight: 500;\r\n\tfont-size: 1.2rem;\r\n\ttransition: all 0.3s;\r\n\tbox-shadow: 0 6px 12px #000;\r\n\ttext-shadow: 0 1px 2px #000;\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n\tz-index: 20;\r\n}\r\n\r\n#startGameBtn:hover {\r\n\tbackground: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));\r\n\ttransform: translate(-50%, -50%) scale(1.05);\r\n\tbox-shadow: 0 8px 16px #000;\r\n}\r\n\r\n#startGameBtn:active {\r\n\ttransform: translate(-50%, -50%) scale(1);\r\n\tbox-shadow: 0 4px 8px #000;\r\n}\r\n\r\n#tooltip {\r\n\tposition: absolute;\r\n\tbackground: linear-gradient(to bottom, var(--primary-dark), var(--primary-dark));\r\n\topacity: var(--very-high-transparent);\r\n\tcolor: var(--text-color);\r\n\tpadding: 12px 15px;\r\n\tborder-radius: 8px;\r\n\tdisplay: none;\r\n\tz-index: 100;\r\n\tborder: 1px solid var(--accent-color);\r\n\tpointer-events: none;\r\n\tmax-width: 280px;\r\n\tbox-shadow: 0 0 20px var(--shadow-color);\r\n\tfont-size: 0.95rem;\r\n\tbackdrop-filter: blur(5px);\r\n}\r\n\r\n#gameOverMenu,\r\n#victoryMenu {\r\n\tposition: absolute;\r\n\ttop: 50%;\r\n\tleft: 50%;\r\n\ttransform: translate(-50%, -50%);\r\n\tbackground: linear-gradient(to bottom, var(--secondary-bg), var(--primary-dark));\r\n\topacity: var(--full-transparent);\r\n\tcolor: white;\r\n\tpadding: 40px;\r\n\ttext-align: center;\r\n\tborder-radius: 15px;\r\n\tborder: 3px solid var(--accent-color);\r\n\tz-index: 20;\r\n\tdisplay: none;\r\n\tbox-shadow: 0 0 60px var(--shadow-color);\r\n\tbackdrop-filter: blur(10px);\r\n\tmin-width: 350px;\r\n}\r\n\r\n#gameOverMenu h2,\r\n#victoryMenu h2 {\r\n\tcolor: var(--highlight-color);\r\n\tfont-size: 32px;\r\n\tmargin-bottom: 20px;\r\n\tfont-family: 'Cinzel', serif;\r\n\ttext-shadow: 0 2px 4px #000;\r\n}\r\n\r\n#gameOverMenu p,\r\n#victoryMenu p {\r\n\tfont-size: 18px;\r\n\tmargin-bottom: 25px;\r\n\tline-height: 1.6;\r\n}\r\n\r\n.menu-button {\r\n\tmargin-top: 25px;\r\n\tpadding: 12px 25px;\r\n\tbackground: linear-gradient(to bottom, var(--bright-accent), var(--accent-color));\r\n\tborder: none;\r\n\tcolor: white;\r\n\tcursor: pointer;\r\n\tborder-radius: 8px;\r\n\ttransition: all 0.3s;\r\n\tfont-family: 'Cinzel', serif;\r\n\tfont-size: 16px;\r\n\tletter-spacing: 1px;\r\n\tbox-shadow: 0 4px 8px #000;\r\n\ttext-shadow: 0 1px 2px #000;\r\n}\r\n\r\n.menu-button:hover {\r\n\tbackground: linear-gradient(to bottom, var(--highlight-color), var(--bright-accent));\r\n\ttransform: scale(1.05) translateY(-3px);\r\n\tbox-shadow: 0 6px 15px #000;\r\n}\r\n\r\n.menu-button:active {\r\n\ttransform: scale(1) translateY(0);\r\n\tbox-shadow: 0 3px 6px #000;\r\n}\r\n\r\n/* Stat icons with custom styling */\r\n#shardsDisplay {\r\n\tcolor: var(--gold-color);\r\n\tfont-weight: 600;\r\n}\r\n\r\n#essenceDisplay,\r\n#essenceNeededDisplay {\r\n\tcolor: var(--essence-color);\r\n\tfont-weight: 600;\r\n}\r\n\r\n#populationDisplay,\r\n#maxPopulationDisplay {\r\n\tcolor: var(--essence-color);\r\n\tfont-weight: 600;\r\n}\r\n\r\n#hpDisplay {\r\n\tcolor: var(--health-color);\r\n\tfont-weight: 600;\r\n}\r\n\r\n#waveDisplay {\r\n\tdisplay: inline-block;\r\n}\r\n\r\n\r\n/* Mobile-first adjustments (applies below 768px) */\r\n@media screen and (max-width: 768px) {\r\n    /* Base layout adjustments */\r\n    #gameContainer {\r\n        overflow: hidden;\r\n    }\r\n    #towerMenu {\r\n        position: fixed;\r\n\t\tbottom: 0;\r\n        left: 0;\r\n        right: 0;\r\n        width: 95vw;\r\n\t\tmax-height: 20vh;\r\n\t\toverflow-y:auto;\r\n        max-width: unset;\r\n        margin: 0 auto;\r\n        grid-template-columns: repeat(2, 1fr);\r\n    }\r\n\r\n    .tower-option {\r\n        min-width: unset;\r\n        font-size: 0.95rem;\r\n    }\r\n\r\n    /* Add a close button for mobile */\r\n    #menuCloseButton {\r\n        display: block;\r\n        position: absolute;\r\n        top: 8px;\r\n        right: 8px;\r\n        background: var(--accent-color);\r\n        border: none;\r\n        color: var(--text-color);\r\n        width: 32px;\r\n        height: 32px;\r\n        border-radius: 50%;\r\n        cursor: pointer;\r\n        z-index: 100;\r\n    }\r\n\r\n    /* Adjust stats container position */\r\n    #statsContainer {\r\n        top: 10px;\r\n        width: 95%;\r\n        padding: 8px;\r\n    }\r\n    #stats {\r\n        gap: 8px;\r\n    }\r\n\r\n    .stat {\r\n        font-size: 0.9rem;\r\n        gap: 4px;\r\n    }\r\n\r\n    /* Upgrade menu adjustments */\r\n    #upgradeMenu {\r\n        width: 90%;\r\n        padding: 15px;\r\n    }\r\n\r\n    .upgrade-option {\r\n        margin: 12px 0;\r\n        padding: 12px;\r\n        flex-direction: column;\r\n        align-items: flex-start;\r\n    }\r\n\r\n    .upgrade-icon {\r\n        width: 36px;\r\n        height: 36px;\r\n        margin-right: 12px;\r\n        font-size: 18px;\r\n    }\r\n\r\n    .upgrade-title {\r\n        font-size: 1rem;\r\n    }\r\n\r\n    /* Wave info adjustments */\r\n    #waveInfo {\r\n        top: 80px;\r\n        width: 90%;\r\n        padding: 6px 15px;\r\n    }\r\n\r\n    .progress-bar {\r\n        width: 150px;\r\n    }\r\n\r\n    /* Game over/victory menus */\r\n    #gameOverMenu, #victoryMenu {\r\n        width: 90%;\r\n        padding: 20px;\r\n    }\r\n\r\n    #gameOverMenu h2, #victoryMenu h2 {\r\n        font-size: 1.5rem;\r\n    }\r\n\r\n    /* Tooltip adjustments */\r\n    #tooltip {\r\n        max-width: 200px;\r\n        font-size: 0.85rem;\r\n        padding: 8px 10px;\r\n    }\r\n\r\n    /* Button sizes */\r\n    #startGameBtn {\r\n        padding: 10px 25px;\r\n        font-size: 1rem;\r\n    }\r\n\r\n    .menu-button {\r\n        padding: 10px 20px;\r\n        font-size: 0.9rem;\r\n    }\r\n}\r\n\r\n/* Additional adjustments for very small screens */\r\n@media screen and (max-width: 480px) {\r\n\r\n\r\n    #stats {\r\n        justify-content: center;\r\n    }\r\n\r\n    .stat {\r\n        font-size: 0.8rem;\r\n    }\r\n\r\n    .progress-bar {\r\n        width: 120px;\r\n        height: 10px;\r\n    }\r\n\r\n    #waveDisplay {\r\n        font-size: 0.9rem;\r\n    }\r\n\r\n    .upgrade-option {\r\n        padding: 10px;\r\n        margin: 8px 0;\r\n    }\r\n\r\n    .upgrade-title {\r\n        font-size: 0.9rem;\r\n    }\r\n}\r\n\r\n/* Orientation-specific adjustments */\r\n@media screen and (max-height: 500px) and (orientation: landscape) {\r\n\r\n    #statsContainer {\r\n        top: 5px;\r\n        padding: 5px;\r\n    }\r\n\r\n  \r\n}\r\n@media screen and (max-width: 480px) {\r\n\r\n\r\n    #menuCloseButton {\r\n        top: 4px;\r\n        right: 4px;\r\n        width: 28px;\r\n        height: 28px;\r\n    }\r\n}",
        "html": "<div id=\"gameContainer\">\r\n    <div id=\"waveInfo\">\r\n        <span>Wave: <span id=\"waveDisplay\">1</span></span>             \r\n        <div class=\"progress-bar\">\r\n            <div class=\"progress-fill\" id=\"waveProgress\"></div>\r\n        </div>\r\n    </div>\r\n    <div id=\"statsContainer\">\r\n        <div id=\"stats\">\r\n            <div class=\"stat\">\r\n                <div class=\"stat-icon\" style=\"background-color: var(--gold-color);\"></div>\r\n                <span>Gold: <span id=\"shardsDisplay\">50</span></span>                 \r\n            </div>\r\n            <div class=\"stat\">\r\n                <div class=\"stat-icon\" style=\"background-color: var(--essence-color);\"></div>\r\n                <span>Essence: <span id=\"essenceDisplay\">0</span>/<span id=\"essenceNeededDisplay\">100</span></span>                 \r\n            </div>\r\n            <div class=\"stat\">\r\n                <div class=\"stat-icon\" style=\"background-color: var(--essence-color);\"></div>\r\n                <span>Population: <span id=\"populationDisplay\">0</span>/<span id=\"maxPopulationDisplay\">5</span></span>                 \r\n            </div>\r\n            <div class=\"stat\">\r\n                <div class=\"stat-icon\" style=\"background-color: var(--health-color);\"></div>\r\n                <span>Core: <span id=\"hpDisplay\">100</span></span>                 \r\n            </div>\r\n        </div>\r\n    </div>\r\n    <canvas id=\"gameCanvas\" width=\"1536\" height=\"768\"></canvas>\r\n    <div id=\"towerMenu\">\r\n        <div class=\"tower-option\" data-type=\"sentry\">Photon Sentry (25)</div>\r\n        <div class=\"tower-option\" data-type=\"fusionCore\">Fusion Core (50)</div>\r\n        <div class=\"tower-option\" data-type=\"barracks\">Barracks (100)</div>\r\n        <div class=\"tower-option\" data-type=\"fabricator\">Fabricator (200)</div>\r\n        <div class=\"tower-option\" data-type=\"teslaCoil\">Tesla Coil (70)</div>\r\n        <div class=\"tower-option\" data-type=\"missileLauncher\">Missile Launcher (90)</div>\r\n        <div class=\"tower-option\" data-type=\"chrono\">Chrono Defibrilator (100)</div>\r\n        <div class=\"tower-option\" data-type=\"guardTower\">Guard Tower (70)</div>\r\n    </div>\r\n    <button id=\"startGameBtn\">Start Game</button>    \r\n</div>\r\n<div id=\"overlay\"></div>\r\n<div id=\"upgradeMenu\">\r\n    <h2>Level Up! Choose an Upgrade:</h2>\r\n    <div id=\"upgradeOptions\"></div>\r\n</div>\r\n<div id=\"tooltip\" style=\"display: none;\"></div>\r\n<div id=\"gameOverMenu\">\r\n    <h2>Home Destroyed!</h2>\r\n    <p>You survived <span id=\"gameOverWave\">0</span> waves</p>\r\n    <button class=\"menu-button\">Try Again</button>     \r\n</div>\r\n<div id=\"victoryMenu\">\r\n    <h2>Victory!</h2>\r\n    <p>You've successfully defended your Home through all waves!</p>\r\n    <button class=\"menu-button\">Play Again</button>     \r\n</div>"
      },
      "aiPromptPanel": {
        "title": "AI Prompt Panel",
        "modals": [
          "aiPromptPanel"
        ],
        "fileName": "aiPromptPanel"
      },
      "audioEditor": {
        "title": "Audio Editor",
        "fileName": "audioEditor",
        "css": "#audio-editor-container {\r\n    padding: 20px;\r\n    margin: 0 auto;\r\n    border-radius: 8px;\r\n    flex-direction: column;\r\n}\r\n\r\n#audio-editor-container .main-flex-container {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: 20px;\r\n}\r\n\r\n#audio-editor-container #status-container {\r\n    width: 100%;\r\n    padding: 10px;\r\n    text-align: center;\r\n}\r\n\r\n#audio-editor-container #status-message {\r\n    color: #333;\r\n    font-weight: bold;\r\n}\r\n\r\n#audio-editor-container .parameters-container {\r\n    flex: 1;\r\n    min-width: 300px;\r\n    padding: 15px;\r\n    margin: 10px 0;\r\n    border-radius: 8px;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\r\n}\r\n\r\n#audio-editor-container .control-buttons {\r\n    margin-bottom: 10px;\r\n    display: flex;\r\n    gap: 10px;\r\n    flex-wrap: wrap;\r\n}\r\n\r\n#audio-editor-container .parameter-group {\r\n    display: grid;\r\n    gap: 10px;\r\n    margin-top: 15px;\r\n}\r\n\r\n#audio-editor-container .parameter-group label {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 10px;\r\n    font-size: 0.9em;\r\n}\r\n\r\n#audio-editor-container .value-display {\r\n    min-width: 60px;\r\n    text-align: right;\r\n    font-family: monospace;\r\n}\r\n\r\n#audio-editor-container input[type=\"range\"] {\r\n    flex-grow: 1;\r\n}\r\n\r\n\r\n@media (max-width: 600px) {\r\n    #audio-editor-container .parameters-container {\r\n        min-width: 100%;\r\n    }\r\n    \r\n    #audio-editor-container .control-buttons {\r\n        flex-direction: column;\r\n    }\r\n    \r\n    #audio-editor-container .parameter-group label {\r\n        flex-direction: column;\r\n        align-items: flex-start;\r\n    }\r\n}",
        "html": "<div id=\"audio-editor-container\">       \r\n     <div id=\"status-container\">\r\n        <span id=\"status-message\">Ready</span>\r\n    </div>\r\n\r\n    <div class=\"main-flex-container\">\r\n        <!-- Status Message Area -->\r\n\r\n        <!-- Basic Parameters -->\r\n        <div class=\"parameters-container\">\r\n            <!-- Playback Controls -->\r\n            <div class=\"control-buttons\">\r\n                <button id=\"playBtn\" class=\"primary-button\">Play</button>\r\n                <button id=\"exportBtn\">Save</button>\r\n                <button id=\"randomSoundBtn\">🎲 Randomize Sound</button>\r\n            </div>\r\n            <h3>Basic Parameters</h3>\r\n            <div class=\"parameter-group\">\r\n                <label>\r\n                    Waveform:\r\n                    <select id=\"waveform\">\r\n                        <option value=\"sine\">Sine</option>\r\n                        <option value=\"square\">Square</option>\r\n                        <option value=\"sawtooth\">Sawtooth</option>\r\n                        <option value=\"triangle\">Triangle</option>\r\n                        <option value=\"noise\">Noise</option>\r\n                    </select>\r\n                </label>\r\n                <label>\r\n                    Frequency:\r\n                    <input type=\"range\" id=\"frequency\" min=\"20\" max=\"2000\" value=\"440\" step=\"1\">\r\n                    <span class=\"value-display\">440 Hz</span>\r\n                </label>\r\n                <label>\r\n                    Duration:\r\n                    <input type=\"range\" id=\"duration\" min=\"0.1\" max=\"5\" value=\"1\" step=\"0.1\">\r\n                    <span class=\"value-display\">1.00 s</span>\r\n                </label>\r\n                <label>\r\n                    Volume:\r\n                    <input type=\"range\" id=\"volume\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n                    <span class=\"value-display\">70%</span>\r\n                </label>\r\n            </div>\r\n        </div>\r\n        <div class=\"parameters-container\">\r\n            <h3>Noise Generator</h3>\r\n            <div class=\"parameter-group\">\r\n                <label >\r\n                    Noise Type:\r\n                    <select id=\"noiseType\">\r\n                        <option value=\"white\">White</option>\r\n                        <option value=\"pink\">Pink</option>\r\n                        <option value=\"brown\">Brown</option>\r\n                    </select>\r\n                </label>\r\n                <label>\r\n                    Noise Amount:\r\n                    <input type=\"range\" id=\"noiseAmount\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n                    <span class=\"value-display\">0%</span>\r\n                </label>\r\n                <label >\r\n                    Noise Filter:\r\n                    <select id=\"noiseFilterType\">\r\n                        <option value=\"none\">None</option>\r\n                        <option value=\"lowpass\">Low Pass</option>\r\n                        <option value=\"highpass\">High Pass</option>\r\n                        <option value=\"bandpass\">Band Pass</option>\r\n                    </select>\r\n                </label>\r\n                <label>\r\n                    Noise Filter Freq:\r\n                    <input type=\"range\" id=\"noiseFilterFreq\" min=\"20\" max=\"20000\" value=\"2000\" step=\"1\">\r\n                    <span class=\"value-display\">2000 Hz</span>\r\n                </label>\r\n            </div>\r\n            <!-- ADSR Envelope -->\r\n            <div class=\"parameters-container\">\r\n                <h3>Envelope (ADSR)</h3>\r\n                <div class=\"parameter-group\">\r\n                    <label>\r\n                        Attack:\r\n                        <input type=\"range\" id=\"attack\" min=\"0.001\" max=\"2\" value=\"0.01\" step=\"0.001\">\r\n                        <span class=\"value-display\">0.010 s</span>\r\n                    </label>\r\n                    <label>\r\n                        Decay:\r\n                        <input type=\"range\" id=\"decay\" min=\"0\" max=\"2\" value=\"0.1\" step=\"0.001\">\r\n                        <span class=\"value-display\">0.10 s</span>\r\n                    </label>\r\n                    <label>\r\n                        Sustain:\r\n                        <input type=\"range\" id=\"sustain\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n                        <span class=\"value-display\">70%</span>\r\n                    </label>\r\n                    <label>\r\n                        Release:\r\n                        <input type=\"range\" id=\"release\" min=\"0.001\" max=\"5\" value=\"0.3\" step=\"0.001\">\r\n                        <span class=\"value-display\">0.30 s</span>\r\n                    </label>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <!-- Pitch Envelope -->\r\n        <div class=\"parameters-container\">\r\n            <h3>Pitch Envelope</h3>\r\n            <div class=\"parameter-group\">\r\n                <label>\r\n                    Start:\r\n                    <input type=\"range\" id=\"pitchEnvStart\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n                    <span class=\"value-display\">1.00x</span>\r\n                </label>\r\n                <label>\r\n                    End:\r\n                    <input type=\"range\" id=\"pitchEnvEnd\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n                    <span class=\"value-display\">1.00x</span>\r\n                </label>\r\n            </div>\r\n        </div>\r\n\r\n        <!-- Effects -->\r\n        <div class=\"parameters-container\">\r\n            <h3>Effects</h3>\r\n            <div class=\"parameter-group\">\r\n                <label>\r\n                    Filter Type:\r\n                    <select id=\"filterType\">\r\n                        <option value=\"lowpass\">Low Pass</option>\r\n                        <option value=\"highpass\">High Pass</option>\r\n                        <option value=\"bandpass\">Band Pass</option>\r\n                        <option value=\"notch\">Notch</option>\r\n                    </select>\r\n                </label>\r\n                <label>\r\n                    Filter Frequency:\r\n                    <input type=\"range\" id=\"filterFreq\" min=\"20\" max=\"20000\" value=\"1000\" step=\"1\">\r\n                    <span class=\"value-display\">1000 Hz</span>\r\n                </label>\r\n                <label>\r\n                    Filter Q:\r\n                    <input type=\"range\" id=\"filterQ\" min=\"0.1\" max=\"20\" value=\"1\" step=\"0.1\">\r\n                    <span class=\"value-display\">Q: 1.0</span>\r\n                </label>\r\n                <label>\r\n                    Distortion:\r\n                    <input type=\"range\" id=\"distortion\" min=\"0\" max=\"100\" value=\"0\" step=\"1\">\r\n                    <span class=\"value-display\">0%</span>\r\n                </label>\r\n                <label>\r\n                    Delay Time:\r\n                    <input type=\"range\" id=\"delayTime\" min=\"0\" max=\"2\" value=\"0.3\" step=\"0.01\">\r\n                    <span class=\"value-display\">0.30 s</span>\r\n                </label>\r\n                <label>\r\n                    Delay Feedback:\r\n                    <input type=\"range\" id=\"delayFeedback\" min=\"0\" max=\"0.9\" value=\"0\" step=\"0.01\">\r\n                    <span class=\"value-display\">0%</span>\r\n                </label>\r\n                <label>\r\n                    Reverb:\r\n                    <input type=\"range\" id=\"reverbAmount\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n                    <span class=\"value-display\">0%</span>\r\n                </label>\r\n                <label>\r\n                    Bitcrusher:\r\n                    <input type=\"range\" id=\"bitcrusher\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n                    <span class=\"value-display\">0%</span>\r\n                </label>\r\n                <label>\r\n                    Panning:\r\n                    <input type=\"range\" id=\"panning\" min=\"-1\" max=\"1\" value=\"0\" step=\"0.01\">\r\n                    <span class=\"value-display\">Center</span>\r\n                </label>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n"
      },
      "scriptEditor": {
        "title": "Script Editor",
        "fileName": "scriptEditor",
        "css": "\r\n#script-editor-container .grid-background {\r\n    width: calc(100% - 450px);\r\n}\r\n/* Override global scrollbar suppression for CodeMirror */\r\n#script-editor-container .CodeMirror {\r\n    overflow-y: auto !important; /* Enable vertical scrolling */\r\n    -ms-overflow-style: auto !important; /* IE and Edge */\r\n    scrollbar-width: auto !important; /* Firefox */\r\n}\r\n\r\n/* Container and layout */\r\n#script-editor-container {\r\n    position: relative;\r\n    height: auto; /* Allow dynamic resizing */\r\n}\r\n\r\n#script-editor-container .grid-background {\r\n    width: calc(100% - 360px); /* Adjust for sidebar width */\r\n    flex: 1;\r\n    position: relative;\r\n    overflow: hidden; /* Contain children */\r\n}\r\n\r\n#script-editor-container .grid-background > div {\r\n    position: relative;\r\n    height: 100%;\r\n}\r\n#script-editor-sidebar {\r\n    width: 360px;\r\n    padding: 10px;\r\n}",
        "html": "            <div id=\"script-editor-container\" class=\"main-content-container\">\r\n                <div id=\"script-editor-sidebar\" class=\"content-sidebar\">                    \r\n                    <h3>Script Editor</h3>\r\n                    <button id=\"save-script-btn\">Save Script</button>\r\n                </div>\r\n                <div class=\"grid-background\">\r\n                    <div>\r\n                        <textarea id=\"script-editor\" class=\"script-editor\" placeholder=\"Enter your script here...\"></textarea>                    \r\n                        <div class=\"handle\"></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n"
      },
      "graphicsEditor": {
        "title": "Graphics Editor",
        "modals": [
          "rotateShapes",
          "moveAllShapes",
          "generateIsometric"
        ],
        "fileName": "graphicsEditor",
        "css": "\r\n#graphics-editor-container #grid-display {\r\n    position: absolute;\r\n    top: 10px;\r\n    left: 10px;\r\n    padding: 5px 10px;\r\n    border-radius: 0;\r\n    font-family: 'Courier New', monospace;\r\n}\r\n#graphics-editor-container .btn {\r\n    padding: 0;\r\n}\r\n\r\n#graphics-editor-container .btn-add {\r\n  background-color: rgba(16, 185, 129, 0.3);\r\n  border: 1px solid #10b981;\r\n  color: #f4e1d2;\r\n}\r\n#graphics-editor-container .btn-add:hover {\r\n  background-color: rgba(16, 185, 129, 0.5);\r\n  box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);\r\n}\r\n#graphics-editor-container #graphics-rightbar {\r\n    width: 360px;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#graphics-editor-container #canvas-container {\r\n    flex: 1;\r\n    position: relative;\r\n}\r\n\r\n#graphics-editor-container #graphics-editor-canvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    cursor: grab;\r\n    outline: none;\r\n}\r\n\r\n#graphics-editor-container .toolbar {\r\n    display: flex;\r\n    flex-direction: column;\r\n    padding: 10px 5px;\r\n    gap: 5px;  \r\n    align-items: normal;\r\n}\r\n#graphics-editor-container .toolbar > div {\r\n    display: flex;\r\n    gap: 7px;\r\n    justify-content: space-between;\r\n}\r\n#graphics-editor-container .toolbar > div > div {\r\n    display: flex;\r\n    gap: 5px;\r\n}\r\n\r\n#graphics-editor-container #shape-list {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n    padding: 15px;\r\n}\r\n\r\n#graphics-editor-container .shape-item {\r\n    padding: 12px;\r\n    margin-bottom: 8px;\r\n    border-radius: 0;\r\n    cursor: pointer;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n#graphics-editor-container #inspector {\r\n    padding: 15px;\r\n}\r\n\r\n#graphics-editor-container .scene-info {\r\n    padding: 10px 15px;\r\n    position: absolute;\r\n    bottom: 15px;\r\n    left: 15px;\r\n    border-radius: 0;\r\n    font-size: 13px;\r\n}\r\n#graphics-editor-container #move-modal button, #rotate-modal button, #isometric-modal button {\r\n    width: 48%;\r\n}\r\n\r\n\r\n#graphics-editor-container .ref-container {\r\n    display: flex;\r\n    gap: 10px;\r\n}\r\n\r\n#graphics-editor-container .ref-select {\r\n    flex: 1;\r\n    min-width: 150px;\r\n}\r\n\r\n#graphics-editor-container .ref-values {\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: 5px;\r\n    margin-bottom: 5px;\r\n}\r\n\r\n#graphics-editor-container .ref-value-item {\r\n    border-radius: 4px;\r\n    padding: 3px 6px;\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 5px;\r\n}\r\n\r\n#graphics-editor-container .remove-ref-btn {\r\n    padding: 0 3px;\r\n    font-size: 14px;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal .modal-content {\r\n    width: 400px;\r\n    padding: 20px;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal .form-row {\r\n    display: flex;\r\n    align-items: center;\r\n    margin-bottom: 15px;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal label {\r\n    width: 100px;\r\n    display: inline-block;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal input[type=\"range\"] {\r\n    flex-grow: 1;\r\n    margin: 0 10px;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal .button-row {\r\n    display: flex;\r\n    justify-content: flex-end;\r\n    margin-top: 20px;\r\n}\r\n\r\n#graphics-editor-container #rotate-group-modal button {\r\n    margin-left: 10px;\r\n    padding: 6px 12px;\r\n    cursor: pointer;\r\n}\r\n\r\n/* Base styling for shape list */\r\n#graphics-editor-container #shape-list {\r\n    padding: 10px;\r\n    user-select: none; /* Prevent text selection during drag */\r\n  }\r\n  \r\n  /* Common styles for items */\r\n  #graphics-editor-container  .shape-item, .group-item {\r\n    padding: 8px;\r\n    margin: 5px 0;\r\n    border-radius: 4px;\r\n    cursor: grab;\r\n    border: 1px solid transparent;\r\n    transition: border-color 0.2s;\r\n  }\r\n  \r\n  /* Shapes styling */\r\n  #graphics-editor-container  .shape-item {\r\n    border-left: 1px solid #555;\r\n  }\r\n  \r\n  #graphics-editor-container  .shape-item:active {\r\n    cursor: grabbing;\r\n  }\r\n  \r\n  /* Group styling */\r\n  #graphics-editor-container  .group-item {\r\n    border-left: 4px solid #007bff; /* Visual distinction for groups */\r\n    font-weight: 500;\r\n  }\r\n  \r\n  /* Selected states - use border instead of background */\r\n  #graphics-editor-container  .shape-item.selected, \r\n  #graphics-editor-container  .group-item.selected {\r\n    border-color: #4080ff;\r\n  }\r\n  \r\n  /* Drag-over states */\r\n  #graphics-editor-container .group-item.drag-over,\r\n  #graphics-editor-container  #shape-list.drag-over {\r\n    border-color: #40a040;\r\n    box-shadow: 0 0 3px rgba(0, 100, 0, 0.5);\r\n  }\r\n  \r\n  /* Animation for when dragging */\r\n  #graphics-editor-container .shape-item.dragging {\r\n    opacity: 0.7;\r\n  }\r\n  \r\n  /* Group shapes container */\r\n  #graphics-editor-container .group-shapes {\r\n    margin-left: 15px;\r\n    padding: 5px;\r\n    border-left: 2px dashed #666;\r\n  }\r\n  \r\n  /* Ungrouped shapes section */\r\n  #graphics-editor-container #shape-list .ungrouped-shapes {\r\n    margin-top: 10px;\r\n    padding: 10px;\r\n    border: 1px dashed #666;\r\n  }\r\n\r\n  #graphics-editor-container .transform-buttons {\r\n    display: flex;\r\n    gap: 10px;\r\n    margin-bottom: 10px;\r\n}\r\n\r\n#graphics-editor-container .transform-buttons button {\r\n    flex: 1;\r\n    padding: 8px;\r\n    background: #444;\r\n    border: 1px solid #666;\r\n    color: white;\r\n    cursor: pointer;\r\n}\r\n\r\n#graphics-editor-container .transform-buttons button.active {\r\n    background: #0066cc;\r\n    border-color: #0088ff;\r\n}",
        "html": "<div id=\"graphics-editor-container\" class=\"main-content-container\">\r\n   <div id=\"graphics-sidebar\" class=\"content-sidebar\">\r\n      <div id=\"toolbar\" class=\"toolbar\">\r\n         <div>    \r\n            <div>\r\n               <button id=\"add-animation\" class=\"btn btn-add\" title=\"Add Animation\">+A</button>                        \r\n               <button id=\"delete-animation\" class=\"btn btn-danger\" title=\"Delete Animation\">-A</button>                        \r\n            </div>                   \r\n            <div>\r\n               <button id=\"add-frame\" class=\"btn btn-add\" title=\"Add Frame\">+F</button>                        \r\n               <button id=\"delete-frame\" class=\"btn btn-danger\" title=\"Delete Frame\">-F</button>                        \r\n            </div>\r\n            <div>\r\n               <button id=\"create-group\" class=\"btn btn-add\" title=\"Create Group\">+G</button>\r\n               <button id=\"delete-group\" class=\"btn btn-danger\" title=\"Delete Group\">-G</button>\r\n            </div>\r\n            <div>                    \r\n               <button id=\"add-shape\" class=\"btn btn-add\" title=\"Add Shape\">+S</button>                        \r\n               <button id=\"delete-shape\" class=\"btn btn-danger\" title=\"Delete Shape\">-S</button>           \r\n            </div>\r\n         </div>  \r\n         <div>\r\n            <div>\r\n               <button id=\"preview-animation\" class=\"btn btn-primary\" title=\"Preview Animation\">▶</button> \r\n               <button id=\"generate-isometric\" class=\"btn btn-primary\" title=\"Generate Isometric Sprites\">Iso</button>                    \r\n            </div>\r\n         </div>\r\n      </div>\r\n      <div id=\"frame-list\"></div>\r\n      <div id=\"group-list\"></div>\r\n      <div id=\"shape-list\"></div>\r\n   </div>\r\n   <div id=\"canvas-container\" class=\"grid-background\">\r\n      <canvas id=\"graphics-editor-canvas\"></canvas>\r\n      <div class=\"scene-info\">\r\n         <div>Shapes: <span id=\"shape-count\">0</span></div>\r\n         <div>Selected: <span id=\"selected-shape\">None</span></div>\r\n         <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>\r\n      </div>\r\n   </div>\r\n   <div id=\"graphics-rightbar\">\r\n      <div id=\"inspector\"></div>\r\n      <div id=\"json-editor\" style=\"display: none\">                        \r\n        <textarea id=\"json-content\" placeholder=\"Edit JSON here...\"></textarea>                    \r\n\t\t\t</div>\r\n   </div>\r\n</div>\r\n"
      },
      "TextureEditor": {
        "title": "Texture Editor",
        "fileName": "TextureEditor",
        "css": "#texture-editor-wrapper {\n    display: flex;\n    gap: 20px;\n    padding: 10px;\n    border-radius: 5px;\n}\n\n.texture-editor-tools {\n    width: 200px;\n    flex-shrink: 0;\n}\n\n.texture-editor-canvas-container {\n    flex-grow: 1;\n    position: relative;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    border-radius: 5px;\n}\n\n#texture-canvas {\n    background-color: transparent;\n    box-shadow: 0 0 10px rgba(0,0,0,0.1);\n    image-rendering: pixelated;\n    border: 1px solid #000;\n}\n\n#noTextureMessage {\n    position: absolute;\n    color: #666;\n}\n\n.tool-section {\n    margin-bottom: 15px;\n    padding-bottom: 15px;\n}\n\n.tool-section h3 {\n    margin-top: 0;\n    margin-bottom: 10px;\n    font-size: 14px;\n}\n\n.tool-btn {\n    margin-right: 5px;\n    margin-bottom: 5px;\n    padding: 5px 10px;\n    cursor: pointer;\n}\n\n.tool-btn.active {\n    background-color: #007bff;\n    color: white;\n}\n\n.color-palette {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 5px;\n    margin-bottom: 10px;\n}\n\n.color-btn {\n    width: 25px;\n    height: 25px;\n    border: 1px solid #ccc;\n    border-radius: 3px;\n    cursor: pointer;\n}\n\n.color-btn.active {\n    border: 2px solid #000;\n}\n\n.custom-color {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n}\n\n#custom-color-picker {\n    width: 30px;\n    height: 30px;\n    padding: 0;\n    border: none;\n    cursor: pointer;\n}",
        "html": "<div id=\"texture-editor-container\" class=\"texture-editor-wrapper\"> \n    <div class=\"texture-editor-tools\">\n        <div class=\"tool-section\">\n            <h3>Tools</h3>\n            <button id=\"brush-tool\" class=\"tool-btn active\">Brush</button>\n            <button id=\"eraser-tool\" class=\"tool-btn\">Eraser</button>\n            <button id=\"fill-tool\" class=\"tool-btn\">Fill</button>\n            <button id=\"eyedropper-tool\" class=\"tool-btn\">Eyedropper</button>\n        </div>\n        \n        <div class=\"tool-section\">\n            <h3>Brush Size</h3>\n            <input type=\"range\" id=\"brush-size\" min=\"1\" max=\"10\" value=\"1\">\n            <span id=\"brush-size-display\">1px</span>\n        </div>\n        \n        <div class=\"tool-section\">\n            <h3>Colors</h3>\n            <div id=\"color-palette\" class=\"color-palette\"></div>\n            <div class=\"custom-color\">\n                <input type=\"color\" id=\"custom-color-picker\" value=\"#000000\">\n                <label for=\"custom-color-picker\">Custom Color</label>\n            </div>\n            <div class=\"transparency-controls\">\n                <label for=\"transparency-slider\">Opacity: </label>\n                <input type=\"range\" id=\"transparency-slider\" min=\"0\" max=\"255\">\n                <span id=\"transparency-display\">100%</span>\n            </div>\n        </div>\n        \n        <div class=\"tool-section\">\n            <h3>Actions</h3>\n            <button id=\"new-btn\">New</button>\n            <button id=\"undo-btn\" disabled>Undo</button>\n            <button id=\"redo-btn\" disabled>Redo</button>\n            <button id=\"clear-btn\">Clear</button>\n            <button class=\"export-btn\">Save</button>\n        </div>\n        \n        <div class=\"tool-section\">\n            <h3>Import</h3>\n            <input type=\"file\" accept=\"image/*\">\n        </div>\n    </div>\n    \n    <div class=\"texture-editor-canvas-container\">\n        <canvas id=\"texture-canvas\"></canvas>\n        <div id=\"noTextureMessage\">No texture loaded</div>\n    </div>\n</div>\n"
      },
      "terrainEditor": {
        "title": "Terrain Editor",
        "modals": [
          "addTerrainType",
          "generateIsoSprites"
        ],
        "fileName": "terrainEditor",
        "css": "#level-editor-container :root {\r\n\t--primary: #6366f1;\r\n\t--primary-dark: #4f46e5;\r\n\t--secondary: #10b981;\r\n\t--dark: #1e293b;\r\n\t--darker: #0f172a;\r\n\t--light: #e2e8f0;\r\n\t--accent: #8b5cf6;\r\n\t--danger: #ef4444;\r\n\t--text: #f8fafc;\r\n\t--text-muted: #94a3b8;\r\n\t--border-radius: 8px;\r\n\t--shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\r\n  }\r\n\r\n  #level-editor-container * {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tbox-sizing: border-box;\r\n\tfont-family: 'Inter', system-ui, -apple-system, sans-serif;\r\n  }\r\n\r\n  #level-editor-container {\r\n\tbackground-color: var(--darker);\r\n\tcolor: var(--text);\r\n  }\r\n\r\n  #level-editor-container button {\r\n\tcursor: pointer;\r\n\tborder: none;\r\n\tborder-radius: var(--border-radius);\r\n\tpadding: 8px 12px;\r\n\tfont-weight: 500;\r\n\ttransition: all 0.2s ease;\r\n  }\r\n\r\n  #level-editor-container button:hover {\r\n\topacity: 0.9;\r\n\ttransform: translateY(-1px);\r\n  }\r\n\r\n  #level-editor-container button:active {\r\n\ttransform: translateY(0);\r\n  }\r\n\r\n  #level-editor-container input {\r\n\tbackground-color: var(--dark);\r\n\tborder: 1px solid #334155;\r\n\tcolor: var(--text);\r\n\tborder-radius: var(--border-radius);\r\n\tpadding: 8px 12px;\r\n\toutline: none;\r\n  }\r\n\r\n  #level-editor-container input:focus {\r\n\tborder-color: var(--primary);\r\n\tbox-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);\r\n  }\r\n\r\n  #level-editor-container input[type=\"number\"] {\r\n\twidth: 80px;\r\n  }\r\n\r\n  #level-editor-container input[type=\"color\"] {\r\n\twidth: 40px;\r\n\theight: 40px;\r\n\tpadding: 2px;\r\n\tcursor: pointer;\r\n  }\r\n\r\n  #level-editor-container {\r\n\tdisplay: flex;\r\n\tgap: 24px;\r\n\theight: 90vh;\r\n\toverflow: hidden;\r\n\tbackground-color: var(--darker);\r\n\tcolor: var(--text);\r\n\tposition: relative;\r\n  }\r\n\r\n  #level-editor-container .content-sidebar {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\twidth: 320px;\r\n\tbackground-color: var(--dark);\r\n\tborder-radius: var(--border-radius);\r\n\tbox-shadow: var(--shadow);\r\n\toverflow: hidden;\r\n  }\r\n\r\n  #level-editor-container .toolbar {\r\n\tdisplay: flex;\r\n\tpadding: 16px;\r\n\tbackground-color: rgba(255, 255, 255, 0.03);\r\n\tborder-bottom: 1px solid rgba(255, 255, 255, 0.1);\r\n  }\r\n\r\n  #level-editor-container .toolbar button {\r\n\tbackground-color: transparent;\r\n\tcolor: var(--text-muted);\r\n\tfont-weight: 600;\r\n\tpadding: 8px 16px;\r\n\tborder-radius: var(--border-radius);\r\n  }\r\n\r\n  #level-editor-container .toolbar button.active {\r\n\tbackground-color: var(--primary);\r\n\tcolor: white;\r\n  }\r\n\r\n  #level-editor-container .tools {\r\n\tpadding: 20px;\r\n\tflex-grow: 1;\r\n\toverflow-y: auto;\r\n  }\r\n\r\n  #level-editor-container .form-row {\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: space-between;\r\n\tmargin-bottom: 16px;\r\n  }\r\n\r\n  #level-editor-container .form-row label {\r\n\tcolor: var(--text-muted);\r\n\tfont-size: 14px;\r\n\tflex: 1;\r\n  }\r\n\r\n  #level-editor-container h3 {\r\n\tcolor: var(--light);\r\n\tfont-size: 18px;\r\n\tmargin-bottom: 24px;\r\n\tfont-weight: 600;\r\n\tborder-bottom: 1px solid rgba(255, 255, 255, 0.1);\r\n\tpadding-bottom: 12px;\r\n  }\r\n\r\n  #level-editor-container h4 {\r\n\tcolor: var(--text-muted);\r\n\tfont-size: 16px;\r\n\tmargin: 24px 0 16px;\r\n\tfont-weight: 600;\r\n  }\r\n\r\n  #level-editor-container .grid-container {\r\n\tflex-grow: 1;\r\n\tposition: relative;\r\n\tbackground-color: var(--dark);\r\n\tborder-radius: var(--border-radius);\r\n\toverflow: hidden;\r\n\tbox-shadow: var(--shadow);\r\n  }\r\n\r\n  #level-editor-container .grid-background {\r\n\tbackground-image: \r\n\t  linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),\r\n\t  linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);\r\n\tbackground-size: 20px 20px;\r\n  }\r\n\r\n  #level-editor-container #grid {\r\n\tdisplay: block;\r\n\timage-rendering: pixelated;\r\n  }\r\n\r\n  #level-editor-container .translation-controls {\r\n\tposition: absolute;\r\n\tright: 20px;\r\n\tbottom: 20px;\r\n\tdisplay: grid;\r\n\tgrid-template-columns: repeat(3, 40px);\r\n\tgrid-template-rows: repeat(3, 40px);\r\n\tgap: 4px;\r\n\tz-index: 10;\r\n  }\r\n\r\n  #level-editor-container .translation-controls button {\r\n\twidth: 40px;\r\n\theight: 40px;\r\n\tbackground-color: rgba(15, 23, 42, 0.8);\r\n\tcolor: var(--light);\r\n\tborder: 1px solid rgba(255, 255, 255, 0.1);\r\n\tfont-size: 18px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\r\n  }\r\n\r\n  #level-editor-container #translate-up {\r\n\tgrid-column: 2;\r\n\tgrid-row: 1;\r\n  }\r\n\r\n  #level-editor-container #translate-left {\r\n\tgrid-column: 1;\r\n\tgrid-row: 2;\r\n  }\r\n\r\n  #level-editor-container #translate-right {\r\n\tgrid-column: 3;\r\n\tgrid-row: 2;\r\n  }\r\n\r\n  #level-editor-container #translate-down {\r\n\tgrid-column: 2;\r\n\tgrid-row: 3;\r\n  }\r\n\r\n  /* Terrain item styling */\r\n  #level-editor-container .terrain-types-container {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tgap: 12px;\r\n\tmargin-top: 16px;\r\n  }\r\n\r\n  #level-editor-container .terrain-item {\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tgap: 12px;\r\n\tpadding: 12px;\r\n\tborder-radius: var(--border-radius);\r\n\tbackground-color: rgba(255, 255, 255, 0.03);\r\n\tborder: 1px solid rgba(255, 255, 255, 0.1);\r\n\tcursor: move;\r\n\tuser-select: none;\r\n\ttransition: all 0.2s ease;\r\n  }\r\n\r\n  #level-editor-container .terrain-item:hover {\r\n\tbackground-color: rgba(255, 255, 255, 0.05);\r\n\ttransform: translateY(-2px);\r\n  }\r\n\r\n  #level-editor-container .color-option {\r\n\twidth: 36px;\r\n\theight: 36px;\r\n\tborder-radius: var(--border-radius);\r\n\tcursor: pointer;\r\n\tborder: 2px solid transparent;\r\n\tflex-shrink: 0;\r\n  }\r\n\r\n  #level-editor-container .color-option.active {\r\n\tborder-color: var(--primary);\r\n\tbox-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n  }\r\n\r\n  #level-editor-container  .terrain-label {\r\n\tflex-grow: 1;\r\n\tfont-weight: 500;\r\n  }\r\n\r\n  #level-editor-container .terrain-buttons {\r\n\tdisplay: flex;\r\n\tgap: 8px;\r\n  }\r\n\r\n  #level-editor-container .terrain-buttons button {\r\n\twidth: 30px;\r\n\theight: 30px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\r\n\tpadding: 0;\r\n\tbackground-color: transparent;\r\n\tcolor: var(--text-muted);\r\n\tborder: 1px solid rgba(255, 255, 255, 0.1);\r\n  }\r\n\r\n  #level-editor-container  .terrain-buttons button:hover {\r\n\tbackground-color: rgba(255, 255, 255, 0.05);\r\n\tcolor: var(--text);\r\n  }\r\n\r\n  #level-editor-container .status-bar {\r\n\tposition: absolute;\r\n\tbottom: 0;\r\n\tleft: 0;\r\n\tright: 0;\r\n\theight: 28px;\r\n\tbackground-color: rgba(15, 23, 42, 0.9);\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tpadding: 0 16px;\r\n\tfont-size: 13px;\r\n\tcolor: var(--text-muted);\r\n\tborder-top: 1px solid rgba(255, 255, 255, 0.1);\r\n  }\r\n\r\n  /* Add a terrainsPanel container */\r\n  #level-editor-container  #terrainsPanel {\r\n\tmargin-top: 24px;\r\n\tborder-top: 1px solid rgba(255, 255, 255, 0.1);\r\n\tpadding-top: 16px;\r\n  }\r\n\r\n\r\n\r\n  /* Environment Panel Styles */\r\n  #level-editor-container #environmentPanel {\r\n\toverflow-y: auto;\r\n\tmax-height: calc(100vh - 200px);\r\n  }\r\n  \r\n  #level-editor-container .environment-objects-container {\r\n\tdisplay: flex;\r\n\tflex-direction: column;\r\n\tgap: 10px;\r\n  }\r\n  \r\n  #level-editor-container .environment-objects-container h3 {\r\n\tmargin-top: 0;\r\n\tmargin-bottom: 12px;\r\n\tcolor: #e5e7eb;\r\n\tfont-size: 16px;\r\n\tborder-bottom: 1px solid #374151;\r\n\tpadding-bottom: 8px;\r\n  }\r\n  \r\n  #level-editor-container .environment-type {\r\n\tbackground-color: #1f2937;\r\n\tborder-radius: 6px;\r\n\toverflow: hidden;\r\n\tmargin-bottom: 8px;\r\n\tbox-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\r\n\ttransition: box-shadow 0.2s ease;\r\n  }\r\n  \r\n  #level-editor-container .environment-type:hover {\r\n\tbox-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);\r\n  }\r\n  \r\n  #level-editor-container .environment-type-header {\r\n\tpadding: 10px 12px;\r\n\tfont-weight: 500;\r\n\tcursor: pointer;\r\n\tdisplay: flex;\r\n\tjustify-content: space-between;\r\n\talign-items: center;\r\n\tbackground-color: #2d3748;\r\n\tcolor: #e5e7eb;\r\n\tposition: relative;\r\n\ttext-transform: capitalize;\r\n  }\r\n  \r\n  #level-editor-container .environment-type-header::after {\r\n\tcontent: '▼';\r\n\tfont-size: 10px;\r\n\ttransition: transform 0.2s ease;\r\n  }\r\n  \r\n  #level-editor-container .environment-type-header.open::after {\r\n\ttransform: rotate(180deg);\r\n  }\r\n  \r\n  #level-editor-container .environment-items {\r\n\tpadding: 10px;\r\n\tdisplay: flex;\r\n\tflex-wrap: wrap;\r\n\tgap: 3px;\r\n\tbackground-color: #1f2937;\r\n  }\r\n  \r\n  #level-editor-container .environment-item {\r\n\twidth: 128px;\r\n\theight: 128px;\r\n\tborder: 2px solid #4b5563;\r\n\tborder-radius: 4px;\r\n\tcursor: pointer;\r\n\tpadding: 2px;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tjustify-content: center;\r\n\tbackground-color: #374151;\r\n\ttransition: all 0.2s ease;\r\n\tposition: relative;\r\n  }\r\n  \r\n  #level-editor-container .environment-item:hover {\r\n\tborder-color: #9ca3af;\r\n\ttransform: translateY(-2px);\r\n  }\r\n  \r\n  #level-editor-container .environment-item.active {\r\n\tborder-color: #3b82f6;\r\n\tbox-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);\r\n  }\r\n  \r\n  #level-editor-container .environment-item canvas {\r\n\tmax-width: 100%;\r\n\tmax-height: 100%;\r\n\tobject-fit: contain;\r\n  }\r\n  \r\n  /* Tooltip for environment items */\r\n  #level-editor-container .environment-item::before {\r\n\tcontent: attr(data-name);\r\n\tposition: absolute;\r\n\tbottom: calc(100% + 5px);\r\n\tleft: 50%;\r\n\ttransform: translateX(-50%);\r\n\tbackground-color: #111827;\r\n\tcolor: white;\r\n\ttext-align: center;\r\n\tborder-radius: 4px;\r\n\tpadding: 4px 8px;\r\n\tfont-size: 12px;\r\n\twhite-space: nowrap;\r\n\tvisibility: hidden;\r\n\topacity: 0;\r\n\ttransition: all 0.2s ease;\r\n\tz-index: 10;\r\n\tpointer-events: none;\r\n\tbox-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n  }\r\n  \r\n  #level-editor-container .environment-item:hover::before {\r\n\tvisibility: visible;\r\n\topacity: 1;\r\n  }\r\n  \r\n  /* Indicator for placement mode */\r\n  #level-editor-container .placement-mode-indicator {\r\n\tposition: absolute;\r\n\ttop: 10px;\r\n\tleft: 50%;\r\n\ttransform: translateX(-50%);\r\n\tbackground-color: rgba(17, 24, 39, 0.8);\r\n\tcolor: white;\r\n\tpadding: 5px 10px;\r\n\tborder-radius: 4px;\r\n\tfont-size: 14px;\r\n\tpointer-events: none;\r\n\ttransition: opacity 0.3s ease;\r\n\tbox-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\r\n\tz-index: 100;\r\n  }\r\n  \r\n  /* Improved toolbar buttons */\r\n  #level-editor-container .toolbar .btn {\r\n\tpadding: 8px 16px;\r\n\tborder: none;\r\n\tbackground-color: #374151;\r\n\tcolor: #e5e7eb;\r\n\tcursor: pointer;\r\n\tborder-radius: 4px;\r\n\tfont-weight: 500;\r\n\ttransition: all 0.2s ease;\r\n  }\r\n  \r\n  #level-editor-container .toolbar .btn:hover {\r\n\tbackground-color: #4b5563;\r\n  }\r\n  \r\n  #level-editor-container .toolbar .btn.active {\r\n\tbackground-color: #3b82f6;\r\n\tcolor: white;\r\n  }\r\n  \r\n  /* Better spacing for the tools panels */\r\n  #level-editor-container .tools > div {\r\n\tmargin-bottom: 20px;\r\n  }\r\n  \r\n  /* Environment object count badge */\r\n  #level-editor-container .environment-type-header .object-count-container {\r\n\tflex: 1;\r\n\tmargin-left: 8px;\r\n  }\r\n  #level-editor-container .environment-type-header .object-count {\r\n\tbackground-color: #4b5563;\r\n\tcolor: white;\r\n\tpadding: 2px 6px;\r\n\tborder-radius: 10px;\r\n\tfont-size: 12px;\r\n  }\r\n  \r\n  /* Empty state for environment types */\r\n  #level-editor-container .environment-items.empty {\r\n\tpadding: 20px;\r\n\ttext-align: center;\r\n\tcolor: #9ca3af;\r\n\tfont-style: italic;\r\n  }\r\n  \r\n  /* Styles for delete mode */\r\n  #level-editor-container .delete-mode-active .grid-container {\r\n\tcursor: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"red\" stroke-width=\"2\"><path d=\"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2\"/><path d=\"M10 11v6M14 11v6\"/></svg>'), auto;\r\n  }\r\n  \r\n  /* Object control panel */\r\n  #level-editor-container .object-controls {\r\n\tdisplay: flex;\r\n\tjustify-content: space-between;\r\n\tpadding: 10px;\r\n\tbackground-color: #1f2937;\r\n\tborder-radius: 6px;\r\n\tmargin-bottom: 10px;\r\n\tgap: 8px;\r\n  }\r\n  \r\n  #level-editor-container .object-controls button {\r\n\tbackground-color: #374151;\r\n\tcolor: #e5e7eb;\r\n\tborder: none;\r\n\tpadding: 6px 12px;\r\n\tborder-radius: 4px;\r\n\tcursor: pointer;\r\n\tdisplay: flex;\r\n\talign-items: center;\r\n\tgap: 5px;\r\n\ttransition: background-color 0.2s;\r\n  }\r\n  \r\n  #level-editor-container .object-controls button:hover {\r\n\tbackground-color: #4b5563;\r\n  }\r\n  \r\n  #level-editor-container .object-controls button.delete-mode {\r\n\tbackground-color: #ef4444;\r\n\tcolor: white;\r\n  }\r\n  \r\n  #level-editor-container .object-controls button.delete-mode:hover {\r\n\tbackground-color: #dc2626;\r\n  }\r\n  \r\n  \r\n #object-preview-canvas {\r\n\ttransition: transform 0.05s ease-out;\r\n\twill-change: transform;\r\n\timage-rendering: pixelated;\r\n\tposition: absolute;\r\n\tpointer-events: none; \r\n\tz-index: 9999;\r\n\topacity: 0.7; \r\n}\r\n  /* Responsive adjustments */\r\n  @media (max-width: 768px) {\r\n\t#level-editor-container .environment-items {\r\n\t  justify-content: center;\r\n\t}\r\n\t\r\n\t#level-editor-container .environment-item {\r\n\t  width: 56px;\r\n\t  height: 56px;\r\n\t}\r\n  }",
        "html": "<div id=\"level-editor-container\" class=\"main-content-container\">\r\n   <div class=\"content-sidebar\">\r\n     <div class=\"toolbar\">\r\n       <button id=\"terrainsBtn\" class=\"btn active\">Tiles</button>\r\n       <button id=\"environmentBtn\" class=\"btn\">Env</button>\r\n     </div>\r\n     <div class=\"tools\">\r\n       <div>\r\n         <h3>Map Settings</h3>\r\n         <div class=\"form-row\">\r\n           <label for=\"terrainMapSize\">Map Size:</label>\r\n           <input type=\"number\" id=\"terrainMapSize\" value=\"48\" step=\"1\" min=\"1\">\r\n         </div>\r\n         <div class=\"form-row\">\r\n            <label for=\"extensionTerrainType\">Surrounding Terrain Type:</label>\r\n            <select id=\"extensionTerrainType\" class=\"extensionTerrainType\"></select>\r\n          </div>\r\n       </div>\r\n       <div id=\"environmentPanel\" style=\"display:none\">\r\n\r\n       </div>\r\n       <div id=\"terrainsPanel\">\r\n         <div class=\"terrain-types-container\">\r\n           <div class=\"terrain-item\">\r\n             <div class=\"color-option active\" style=\"background-color: #10b981;\"></div>\r\n             <div class=\"terrain-label\">Grass</div>\r\n             <div class=\"terrain-buttons\">\r\n               <button title=\"Edit\">✏️</button>\r\n               <button title=\"Delete\">🗑️</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"terrain-item\">\r\n             <div class=\"color-option\" style=\"background-color: #3b82f6;\"></div>\r\n             <div class=\"terrain-label\">Water</div>\r\n             <div class=\"terrain-buttons\">\r\n               <button title=\"Edit\">✏️</button>\r\n               <button title=\"Delete\">🗑️</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"terrain-item\">\r\n             <div class=\"color-option\" style=\"background-color: #a3a3a3;\"></div>\r\n             <div class=\"terrain-label\">Stone</div>\r\n             <div class=\"terrain-buttons\">\r\n               <button title=\"Edit\">✏️</button>\r\n               <button title=\"Delete\">🗑️</button>\r\n             </div>\r\n           </div>\r\n         </div>\r\n       </div>\r\n     </div>\r\n   </div>\r\n   \r\n   <div class=\"grid-container grid-background\">\r\n     <canvas id=\"grid\"></canvas>\r\n     \r\n     <div class=\"translation-controls\">\r\n       <button id=\"translate-up\"><span>↑</span></button>\r\n       <button id=\"translate-left\"><span>←</span></button>\r\n       <button id=\"translate-right\"><span>→</span></button>\r\n       <button id=\"translate-down\"><span>↓</span></button>\r\n     </div>\r\n     \r\n     <div class=\"status-bar\">\r\n       Cursor: x: 0, y: 0 | Zoom: 100% | Selected: Grass\r\n     </div>\r\n   </div>\r\n </div>"
      },
      "sceneEditor": {
        "title": "Scene Editor",
        "modals": [],
        "fileName": "sceneEditor",
        "css": "\r\n#scene-editor-container .btn {\r\n    padding: 0;\r\n}\r\n#scene-editor-container .sidebar {\r\n    width: 250px;\r\n    display: flex;\r\n    padding: 0 1em 0 0;\r\n    flex-direction: column;\r\n    background-color: none;\r\n    border: none;\r\n    box-shadow: none;\r\n}\r\n\r\n#scene-editor-container .hierarchy {\r\n    flex: 1;\r\n    overflow-y: auto;\r\n}\r\n\r\n#scene-editor-container .hierarchy-item {\r\n    padding: 4px 8px;\r\n    margin: 2px 0;\r\n    cursor: pointer;\r\n    border-radius: 3px;\r\n    display: flex;\r\n    align-items: center;\r\n}\r\n\r\n#scene-editor-container .hierarchy-item.selected {\r\n    background-color: #0b4984;\r\n}\r\n\r\n#scene-editor-container .hierarchy-item:hover:not(.selected) {\r\n    background-color: #333333;\r\n}\r\n\r\n#scene-editor-container .hierarchy-item span {\r\n    margin-left: 5px;\r\n}\r\n\r\n#scene-editor-container .entity-icon {\r\n    width: 16px;\r\n    height: 16px;\r\n    display: inline-block;\r\n    margin-right: 5px;\r\n    border-radius: 2px;\r\n}\r\n\r\n#scene-editor-container .main-content {\r\n    flex: 1;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n#scene-editor-container .toolbar {\r\n    padding: 8px;\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 8px;\r\n}\r\n\r\n#scene-editor-container .scene-view {\r\n    flex: 1;\r\n    position: relative;\r\n}\r\n\r\n#scene-editor-container .inspector {\r\n    width: 300px;\r\n    overflow-y: auto;\r\n    padding: 0 0 0 1em;\r\n}\r\n\r\n#scene-editor-container .property {\r\n    padding: 8px;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n#scene-editor-container .property label {\r\n    flex: 1;\r\n}\r\n\r\n#scene-editor-container .property input, #scene-editor-container .property select {\r\n    width: 120px;\r\n    padding: 4px;\r\n    border-radius: 3px;\r\n}\r\n\r\n#scene-editor-container .property-group {\r\n    margin-bottom: 8px;\r\n}\r\n\r\n#scene-editor-container .component-header {\r\n    padding: 8px;\r\n    font-weight: bold;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n#scene-editor-container .btn {\r\n    padding: 4px 8px;\r\n    border-radius: 3px;\r\n    cursor: pointer;\r\n}\r\n\r\n\r\n#scene-editor-container .add-entity-btn,#scene-editor-container .add-component-btn {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 4px;\r\n}\r\n\r\n#scene-editor-container .no-selection {\r\n    padding: 16px;\r\n    text-align: center;\r\n}\r\n\r\n#scene-editor-container .vector3-input {\r\n    display: flex;\r\n    width: 200px;\r\n    gap: 2px;\r\n}\r\n\r\n#scene-editor-container .vector3-input input {\r\n    width: 64px;\r\n    text-align: center;\r\n}\r\n\r\n#scene-editor-container .dropdown-content {\r\n    display: none;\r\n    position: absolute;\r\n    min-width: 160px;\r\n    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);\r\n    z-index: 1;\r\n    border-radius: 3px;\r\n}\r\n\r\n#scene-editor-container .dropdown-content a {\r\n    padding: 8px 12px;\r\n    text-decoration: none;\r\n    display: block;\r\n    cursor: pointer;\r\n}\r\n\r\n#scene-editor-container .show {\r\n    display: block;\r\n}\r\n\r\n#scene-editor-container .color-input {\r\n    width: 120px;\r\n    position: relative;\r\n}\r\n\r\n#scene-editor-container .color-preview {\r\n    width: 16px;\r\n    height: 16px;\r\n    display: inline-block;\r\n    border-radius: 2px;\r\n    position: absolute;\r\n    right: 8px;\r\n    top: 50%;\r\n    transform: translateY(-50%);\r\n}\r\n\r\n\r\n#scene-editor-container .gizmo-toolbar {\r\n    position: absolute;\r\n    top: 10px;\r\n    right: 10px;\r\n    background: rgba(40, 40, 40, 0.8);\r\n    padding: 8px;\r\n    border-radius: 4px;\r\n    display: flex;\r\n    gap: 5px;\r\n}\r\n\r\n#scene-editor-container .gizmo-btn {\r\n    padding: 6px 12px;\r\n    background: #444;\r\n    border: none;\r\n    border-radius: 3px;\r\n    color: white;\r\n    cursor: pointer;\r\n}\r\n\r\n#scene-editor-container .gizmo-btn:hover {\r\n    background: #555;\r\n}\r\n\r\n#scene-editor-container .gizmo-btn.active {\r\n    background: #0066cc;\r\n}",
        "html": "<div id=\"scene-editor-container\" class=\"editor\">\r\n   <div id=\"scene-sidebar\" class=\"sidebar\">\r\n      <h2 class=\"sidebar-header\">Hierarchy</h2>\r\n      <div id=\"scene-hierarchy\" class=\"hierarchy\">\r\n        <!-- Entities will be populated here -->\r\n      </div>\r\n      <div class=\"toolbar\">\r\n        <div>\r\n          <button class=\"btn danger remove-prefab-btn\" id=\"scene-removePrefabBtn\">Remove Selected Prefab</button>\r\n        </div>\r\n        <div>\r\n          <select id=\"scene-addPrefabSelect\"></select>\r\n        </div>\r\n        <div>\r\n          <button class=\"btn add-prefab-btn\" id=\"scene-addPrefabBtn\">+ Add Prefab</button>\r\n        </div>\r\n      </div>\r\n   </div>\r\n      \r\n   <div class=\"main-content\">\r\n      <div class=\"gizmo-toolbar\">\r\n        <button id=\"scene-translate-tool\" class=\"gizmo-btn active\" title=\"Translate (G)\">\r\n            <span>Move</span>\r\n        </button>\r\n        <button id=\"scene-rotate-tool\" class=\"gizmo-btn\" title=\"Rotate (R)\">\r\n            <span>Rotate</span>\r\n        </button>\r\n        <button id=\"scene-scale-tool\" class=\"gizmo-btn\" title=\"Scale (S)\">\r\n            <span>Scale</span>\r\n        </button>\r\n      </div>\r\n      <div id=\"scene-view\" class=\"scene-view\">      \r\n         <div id=\"scene-canvas-container\" class=\"grid-background\">\r\n            <canvas id=\"scene-editor-canvas\"></canvas>\r\n         </div>\r\n      </div>\r\n   </div>\r\n \r\n   <div id=\"scene-inspector\" class=\"inspector\">\r\n      <h2 class=\"sidebar-header\">Inspector</h2>\r\n      <div class=\"no-selection\" id=\"scene-noSelection\">\r\n        No entity selected\r\n      </div>\r\n      <div id=\"scene-entityInspector\" style=\"display: none;\">        \r\n        <!-- Components will be added here dynamically -->\r\n        <div id=\"scene-components\">\r\n          <!-- Example component (will be created dynamically) -->\r\n        </div>\r\n        \r\n        <div class=\"toolbar\">\r\n          <button class=\"btn add-component-btn\" id=\"addComponentBtn\">+ Add Component</button>\r\n        </div>\r\n      </div>\r\n   </div>\r\n   \r\n"
      }
    },
    "libraries": {
      "threejs": {
        "title": "THREE",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "className": "THREE",
        "requireName": "THREE",
        "fileName": "threejs",
        "isModule": true,
        "importName": "three"
      },
      "Rapier": {
        "fileName": "Rapier",
        "href": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
        "requireName": "RAPIER",
        "importName": "RAPIER",
        "isModule": true
      },
      "three.SkeletonUtils": {
        "title": "THREE.SkeletonUtils",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/utils/SkeletonUtils.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "SkeletonUtils",
        "importName": "SkeletonUtils",
        "fileName": "three.SkeletonUtils"
      },
      "three.PointerLockControls": {
        "title": "THREE.PointerLockControls",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/PointerLockControls.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "PointerLockControls",
        "importName": "PointerLockControls",
        "fileName": "three.PointerLockControls"
      },
      "three.BufferGeometryUtils": {
        "title": "THREE.BufferGeometryUtils",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/utils/BufferGeometryUtils.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "BufferGeometryUtils",
        "importName": "BufferGeometryUtils",
        "fileName": "three.BufferGeometryUtils"
      },
      "ShapeFactory": {
        "fileName": "ShapeFactory",
        "script": "class ShapeFactory {\n    constructor(palette, textures, libraryClasses) {\n        this.gltfCache = new Map();\n        this.gltfLoader = new THREE_.GLTFLoader();\n        this.palette = palette;\n        this.textures = textures;\n        this.skeleUtils = THREE_.SkeletonUtils;        \n    }\n    async createMergedGroupFromJSON(model, frameData, groupName) {\n        let mergedGroup = this.getMergedGroup(model, frameData, groupName);\n        if( mergedGroup){\n            return await this.createGroupFromJSON(groupName, mergedGroup);\n        } else {\n            return null;\n        }\n    }\n    async createGroupFromJSON(groupName, groupData) {\n        const group = new THREE.Group();\n        group.name = groupName;\n        group.userData = { isGroup: true };\n        // Use Promise.all with map instead of forEach to properly await all shapes\n        await Promise.all(groupData.shapes.map(async (shape, index) => {\n            if (shape.type === 'gltf') {\n                await this.handleGLTFShape(shape, index, group);\n            } else {\n                await this.handlePrimitiveShape(shape, index, group);\n            }\n        }));\n        if(groupData.position){            \n            group.position.x = groupData.position.x || 0;\n            group.position.y = groupData.position.y || 0;\n            group.position.z = groupData.position.z || 0;\n        }\n\n        if(groupData.rotation){\n            group.rotation.x = groupData.rotation.x || 0;\n            group.rotation.y = groupData.rotation.y || 0;\n            group.rotation.z = groupData.rotation.z || 0;\n        }\n\n        if(groupData.scale){\n            group.scale.x = groupData.scale.x || 1;\n            group.scale.y = groupData.scale.y || 1;\n            group.scale.z = groupData.scale.z || 1;\n        } \n        return group;\n    }\n\n    async handleGLTFShape(shape, index, group) {\n        const applyTransformations = (model, gltf) => {\n            // Extract animations\n            const animations = gltf.animations;\n            model.position.set(\n                (shape.position ? shape.position.x : shape.x) || 0, \n                (shape.position ? shape.position.y : shape.y) || 0, \n                (shape.position ? shape.position.z : shape.z) || 0\n            );\n            model.scale.set(\n                (shape.scale ? shape.scale.x : shape.scaleX) || 1,\n                (shape.scale ? shape.scale.y : shape.scaleY) || 1,\n                (shape.scale ? shape.scale.z : shape.scaleZ) || 1\n            );\n            model.rotation.set(\n                ((shape.rotation ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,\n                ((shape.rotation ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,\n                ((shape.rotation ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180\n            );\n    \n            model.traverse(child => {\n                if (child.isMesh) {\n                    // Override material with skinning enabled\n                    let map = child.material.map;\n                    child.material = new THREE.MeshStandardMaterial({\n                        color: 0xffffff,\n                        metalness: shape.metalness || 0.5,\n                        roughness: shape.roughness || 0.5,\n                        map: map\n                    });\n                    child.material.needsUpdate = true;\n                    child.castShadow = true;\n                    child.receiveShadow = true;\n                    child.userData = {\n                        isShape: true,\n                        index: index,\n                        isGLTFChild: true\n                    };\n                }\n            });\n    \n            model.userData = {\n                isShape: true,\n                index: index,\n                isGLTFRoot: true,\n                castShadow: true,\n                animations: animations\n            };\n    \n            group.add(model);\n    \n            if (animations && animations.length > 0) {\n \n    \n                const mixer = new THREE.AnimationMixer(model);\n                const action = mixer.clipAction(animations[0]);\n                action.play();\n    \n                model.userData.mixer = mixer;\n                let skinnedMesh;\n                gltf.scene.traverse((child) => {\n                    if (child.isSkinnedMesh) {\n                        skinnedMesh = child;\n                    }\n                });\n    \n                if (!skinnedMesh) {\n                    return;\n                }    \n                const skeleton = skinnedMesh.skeleton;\n                model.userData.skeleton = skeleton;                \n            }         \n\n        };\n    \n        if (shape.url) {\n            const cached = this.gltfCache.get(shape.url);\n            if (cached) {\n                \n                const clonedScene = this.skeleUtils.clone(cached.scene);\n                applyTransformations(clonedScene, cached);\n            } else if (shape.url && location.hostname !== \"\") {\n                await new Promise((resolve, reject) => {\n                    this.gltfLoader.load(\n                        shape.url,\n                        (gltf) => {\n                            const clonedScene = this.skeleUtils.clone(gltf.scene);\n                            this.gltfCache.set(shape.url, gltf);\n                            applyTransformations(clonedScene, gltf);\n                            resolve();\n                        },\n                        undefined,\n                        (error) => {\n                            console.error(`Failed to load GLTF model at ${shape.url}:`, error);\n                            reject(error);\n                        }\n                    );\n                });\n            }\n        } else {\n            return null;\n        }\n    }\n\n    async handlePrimitiveShape(shape, index, group) {\n        let geometry, material;\n\n        let colorToUse = shape.color;\n        if(shape.color.paletteColor){\n            colorToUse = \"#ffffff\";\n            if(this.palette && this.palette[shape.color.paletteColor]){\n                colorToUse = this.palette[shape.color.paletteColor];\n            }\n        }\n        if(shape.texture){\n            // If a texture is specified, use it instead of the color\n            // If a texture is specified, use it instead of the color\n            const textureLoader = new THREE.TextureLoader();\n                \n            const textureData = this.textures[shape.texture];\n            \n            if( textureData ) {\n                const texture = await new Promise((resolve, reject) => {\n                    textureLoader.load(\n                        textureData.image,\n                        (loadedTexture) => {\n                            loadedTexture.wrapS = THREE.RepeatWrapping; // Use ClampToEdge instead of RepeatWrapping\n                            loadedTexture.wrapT = THREE.RepeatWrapping; // Use RepeatWrapping for vertical repeat\n                            loadedTexture.magFilter = THREE.NearestFilter;\n                            loadedTexture.minFilter = THREE.NearestFilter;\n                            loadedTexture.generateMipmaps = false;\n                            loadedTexture.anisotropy = 1;\n                            loadedTexture.needsUpdate = true;\n\n                            const meshWidth = shape.width || 1; // Mesh width in world units\n                            const meshHeight = shape.height || 1; // Mesh height in world units\n            \n                            const textureWidth = loadedTexture.image.width;\n                            const textureHeight = loadedTexture.image.height;\n                            const pixelsPerUnit = 2;\n                            const repeatX = Math.ceil((meshWidth * pixelsPerUnit) / textureWidth);\n                            const repeatY = Math.ceil((meshHeight * pixelsPerUnit) / textureHeight);\n                            loadedTexture.repeat.set(repeatX, repeatY);\n \n                            resolve(loadedTexture);\n                        },\n                        undefined,\n                        (error) => reject(error)\n                    );\n                });\n                material = new THREE.MeshStandardMaterial({ map: texture, color: colorToUse });\n            } else {                \n                material = new THREE.MeshStandardMaterial({ color: colorToUse });\n            }\n        } else {            \n            // Create material with specified color\n            material = new THREE.MeshStandardMaterial({ color: colorToUse });\n        }\n\n        switch (shape.type) {\n            case 'sphere':\n                geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);\n                break;\n            case 'cube':\n                geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);\n                break;\n            case 'box':\n                geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);\n                break;\n            case 'cylinder':\n                geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);\n                break;\n            case 'cone':\n                geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);\n                break;\n            case 'torus':\n                geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);\n                break;\n            case 'tetrahedron':\n                geometry = new THREE.TetrahedronGeometry(shape.size / 2);\n                break;\n            default:\n                return;\n        }\n\n        const mesh = new THREE.Mesh(geometry, material);\n        mesh.userData = { isShape: true, castShadow: true, index: index };\n        \n        // Position and rotation\n        mesh.position.set(\n            (shape.position && shape.position.x ? shape.position.x : shape.x) || 0, \n            (shape.position && shape.position.y ? shape.position.y : shape.y) || 0, \n            (shape.position && shape.position.z ? shape.position.z : shape.z) || 0\n        );\n        mesh.rotation.set(\n            ((shape.rotation && shape.rotation.x ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,\n            ((shape.rotation && shape.rotation.y ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,\n            ((shape.rotation && shape.rotation.z ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180\n        );\n        mesh.scale.set(\n            (shape.scale && shape.scale.x ? shape.scale.x : shape.scaleX) || 1,\n            (shape.scale && shape.scale.y ? shape.scale.y : shape.scaleY) || 1,\n            (shape.scale && shape.scale.z ? shape.scale.z : shape.scaleZ) || 1\n        );\n        group.add(mesh);\n    }\n\n    disposeObject(object) {\n        object.traverse(child => {\n            if (child.geometry) child.geometry.dispose();\n            if (child.material) {\n                if (Array.isArray(child.material)) {\n                    child.material.forEach(m => m.dispose());\n                } else {\n                    child.material.dispose();\n                }\n            }\n        });\n    }\n\n    getMergedGroup(model, frameData, groupName) {\n        const modelGroup = model[groupName];\n        if (!modelGroup) {\n            delete frameData?.[groupName];\n            return null;\n        }\n    \n        frameData = frameData || {};\n        let frameGroup = this.initializeFrameGroup(frameData, modelGroup, groupName);\n        \n        this.cleanupMatchingTransforms(modelGroup, frameGroup);\n        const mergedShapes = this.mergeShapes(modelGroup, frameGroup);\n        \n        this.cleanupEmptyShapes(frameGroup);\n        \n        const mergedGroup = {\n            ...modelGroup,\n            ...frameGroup,\n            shapes: mergedShapes\n        };\n    \n        if (modelGroup.shapes.length === 0) {\n            frameGroup.shapes = [];\n        }\n    \n        const returnVal = JSON.parse(JSON.stringify(mergedGroup));\n        this.cleanupFrameData(frameData, frameGroup, groupName);\n        \n        return returnVal;\n    }\n    \n    initializeFrameGroup(frameData, modelGroup, groupName) {\n        if (!frameData[groupName]) {\n            frameData[groupName] = JSON.parse(JSON.stringify(modelGroup));\n            const frameGroup = frameData[groupName];\n            frameGroup.shapes.forEach((shape, index) => {\n                shape.id = index;\n            });\n            return frameGroup;\n        }\n        return frameData[groupName];\n    }\n    \n    cleanupMatchingTransforms(modelGroup, frameGroup) {\n        const properties = ['position', 'rotation', 'scale'];\n        properties.forEach(prop => {\n            if (JSON.stringify(modelGroup[prop]) === JSON.stringify(frameGroup[prop])) {\n                delete frameGroup[prop];\n            }\n        });\n    }\n    \n    mergeShapes(modelGroup, frameGroup) {\n        return modelGroup.shapes.map((modelShape, i) => {\n            if (!frameGroup.shapes) {\n                return JSON.parse(JSON.stringify(modelShape));\n            }\n    \n            let frameShape = frameGroup.shapes.find(shape => shape.id === i) || { id: i };\n            if (!frameGroup.shapes.includes(frameShape)) {\n                frameGroup.shapes.push(frameShape);\n            }\n    \n            const mergedShape = this.mergeShapeProperties(modelShape, frameShape);\n            this.cleanupMatchingShapeTransforms(modelShape, frameShape);\n            \n            return JSON.parse(JSON.stringify(mergedShape));\n        });\n    }\n    \n    mergeShapeProperties(modelShape, frameShape) {\n        const mergedShape = {};\n        \n        for (const key in modelShape) {\n            if (key === 'id') continue;\n            \n            if (frameShape && frameShape[key] !== undefined && modelShape[key] === frameShape[key]) {\n                delete frameShape[key];\n                mergedShape[key] = modelShape[key];\n            } else if (!frameShape || frameShape[key] === undefined) {\n                mergedShape[key] = modelShape[key];\n            } else {\n                mergedShape[key] = frameShape[key];\n            }\n        }\n    \n        return { ...mergedShape, ...frameShape };\n    }\n    \n    cleanupMatchingShapeTransforms(modelShape, frameShape) {\n        const transforms = [\n            { prop: 'scale', defaultVal: 1, axes: ['X', 'Y', 'Z'] },\n            { prop: 'rotation', defaultVal: 0, axes: ['X', 'Y', 'Z'] }\n        ];\n    \n        transforms.forEach(({ prop, defaultVal, axes }) => {\n            axes.forEach(axis => {\n                const propName = `${prop}${axis}`;\n                if (frameShape[propName] === modelShape[propName] || \n                   (frameShape[propName] === defaultVal && modelShape[propName] === undefined)) {\n                    delete frameShape[propName];\n                }\n            });\n        });\n    }\n    \n    cleanupEmptyShapes(frameGroup) {\n        if (frameGroup.shapes) {\n            frameGroup.shapes = frameGroup.shapes.filter(shape => \n                Object.keys(shape).length > 0\n            );\n            \n            if (frameGroup.shapes.length === 0) {\n                delete frameGroup.shapes;\n            }\n        }\n    }\n    \n    cleanupFrameData(frameData, frameGroup, groupName) {\n        if (Object.keys(frameGroup).length === 0) {\n            delete frameData[groupName];\n        }\n    }\n\n}"
      },
      "SimplexNoise": {
        "title": "SimplexNoise",
        "fileName": "SimplexNoise",
        "script": "class SimplexNoise {\r\n    constructor(seed = 0) {\r\n        // Permutation table for randomization\r\n        this.perm = new Uint8Array(256);\r\n        this.seed = seed;\r\n        this.initPermutation();\r\n    }\r\n\r\n    // Initialize permutation table with a seed\r\n    initPermutation() {\r\n        for (let i = 0; i < 256; i++) {\r\n            this.perm[i] = i;\r\n        }\r\n        // Shuffle using a simple seeded random\r\n        let rand = this.seededRandom();\r\n        for (let i = 255; i > 0; i--) {\r\n            const j = Math.floor(rand() * (i + 1));\r\n            [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];\r\n        }\r\n    }\r\n\r\n    // Simple seeded random number generator\r\n    seededRandom() {\r\n        let x = Math.sin(this.seed++) * 10000;\r\n        return () => {\r\n            x = Math.sin(x + this.seed++) * 10000;\r\n            return x - Math.floor(x);\r\n        };\r\n    }\r\n\r\n    // 2D Simplex noise function\r\n    noise2D(x, y) {\r\n        // Skew input coordinates to simplex grid\r\n        const s = (x + y) * 0.366025403784; // F = (sqrt(3) - 1) / 2\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n\r\n        // Unskew back to get simplex cell origin\r\n        const t = (i + j) * 0.211324865405; // G = (3 - sqrt(3)) / 6\r\n        const X0 = i - t;\r\n        const Y0 = j - t;\r\n        const x0 = x - X0;\r\n        const y0 = y - Y0;\r\n\r\n        // Determine which simplex we're in\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n\r\n        // Offsets for second and third corners\r\n        const x1 = x0 - i1 + 0.211324865405;\r\n        const y1 = y0 - j1 + 0.211324865405;\r\n        const x2 = x0 - 1 + 0.42264973081;\r\n        const y2 = y0 - 1 + 0.42264973081;\r\n\r\n        // Gradient indices\r\n        const gi0 = this.perm[(i + this.perm[j & 255]) & 255] % 4;\r\n        const gi1 = this.perm[(i + i1 + this.perm[(j + j1) & 255]) & 255] % 4;\r\n        const gi2 = this.perm[(i + 1 + this.perm[(j + 1) & 255]) & 255] % 4;\r\n\r\n        // Calculate contributions from each corner\r\n        const n0 = this.contribution(x0, y0, gi0);\r\n        const n1 = this.contribution(x1, y1, gi1);\r\n        const n2 = this.contribution(x2, y2, gi2);\r\n\r\n        // Sum contributions and normalize to [-1, 1]\r\n        return (n0 + n1 + n2) * 70; // Scale to approximate [-1, 1]\r\n    }\r\n\r\n    // Calculate contribution from a corner\r\n    contribution(x, y, gi) {\r\n        // Distance falloff\r\n        const t = 0.5 - x * x - y * y;\r\n        if (t < 0) return 0;\r\n\r\n        // Gradient vectors (simplified 2D)\r\n        const gradients = [\r\n            [1, 1], [-1, 1], [1, -1], [-1, -1]\r\n        ];\r\n        const grad = gradients[gi];\r\n        const t2 = t * t;\r\n        return t2 * t2 * (grad[0] * x + grad[1] * y);\r\n    }\r\n}"
      },
      "TerrainGenerator": {
        "title": "TerrainGenerator",
        "fileName": "TerrainGenerator",
        "script": "class TerrainGenerator {\r\n    init(biomes, chunkSize, chunkResolution, noise) {\r\n        this.noise = noise;\r\n        this.biomes = biomes;\r\n        this.chunkSize = chunkSize;\r\n        this.chunkResolution = chunkResolution;\r\n    }\r\n\r\n    fractalNoise(x, y, settings) {\r\n        let value = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        for (let i = 0; i < settings.octaves; i++) {\r\n            value += this.noise.noise2D(x * frequency * settings.scale, y * frequency * settings.scale) * amplitude;\r\n            amplitude *= settings.persistence;\r\n            frequency *= settings.lacunarity;\r\n        }\r\n        return value * settings.heightScale;\r\n    }\r\n\r\n    getBiomeWeights(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const biomeNoise = this.noise.noise2D(wx * 0.00001, wz * 0.00001);\r\n        const biomeValue = (biomeNoise + 1) / 2;\r\n        const weights = {};\r\n\r\n        Object.keys(this.biomes).forEach((biomeName) => {\r\n            const biome = this.biomes[biomeName];\r\n            const [min, max] = biome.range.elevation || biome.range; // Adjust for range format\r\n            let weight = 0;\r\n            if (biomeValue >= min && biomeValue <= max) {\r\n                weight = 1 - Math.abs(biomeValue - (min + max) / 2) / ((max - min) / 2);\r\n                weight = Math.max(0, weight);\r\n            }\r\n            weights[biomeName] = weight;\r\n        });\r\n\r\n        const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);\r\n        if (totalWeight > 0) {\r\n            for (const biome in weights) {\r\n                weights[biome] /= totalWeight;\r\n            }\r\n        } else {\r\n            weights.plains = 1;\r\n        }\r\n        return weights;\r\n    }\r\n\r\n    getBiomeAt(x, z) {\r\n        const position = { x, z };\r\n        const weights = this.getBiomeWeights(position);\r\n        let maxWeight = 0;\r\n        let selectedBiome = \"plains\";\r\n        for (const biomeName in weights) {\r\n            if (weights[biomeName] > maxWeight) {\r\n                maxWeight = weights[biomeName];\r\n                selectedBiome = biomeName;\r\n            }\r\n        }\r\n        return selectedBiome;\r\n    }\r\n\r\n    getHeight(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const weights = this.getBiomeWeights(position);\r\n        let totalHeight = 0;\r\n        for (const biomeName in weights) {\r\n            const weight = weights[biomeName];\r\n            if (weight === 0) continue;\r\n            const biome = this.biomes[biomeName];\r\n            let height = 0;\r\n            height += this.fractalNoise(wx, wz, biome.noiseSettings.elevation);\r\n            height += this.fractalNoise(wx * 2, wz * 2, biome.noiseSettings.detail);\r\n            if (biome.noiseSettings.ridge) {\r\n                const ridgeNoise = Math.abs(this.noise.noise2D(wx * biome.noiseSettings.ridge.scale, wz * biome.noiseSettings.ridge.scale));\r\n                height += Math.pow(ridgeNoise, biome.noiseSettings.ridge.power) * biome.noiseSettings.ridge.heightScale;\r\n            }\r\n            totalHeight += height * weight;\r\n        }\r\n        return totalHeight;\r\n    }\r\n\r\n    getNormalAt(position) {\r\n        const heightAtPoint = this.getHeight(position);\r\n        const sampleDistance = 1;\r\n\r\n        const heightAtPointPlusX = this.getHeight({ x: position.x + sampleDistance, z: position.z });\r\n        const heightAtPointPlusZ = this.getHeight({ x: position.x, z: position.z + sampleDistance });\r\n\r\n        const tangentX = { x: sampleDistance, y: heightAtPointPlusX - heightAtPoint, z: 0 };\r\n        const tangentZ = { x: 0, y: heightAtPointPlusZ - heightAtPoint, z: sampleDistance };\r\n\r\n        const normal = {\r\n            x: -tangentX.y * tangentZ.z + tangentX.z * tangentZ.y,\r\n            y: tangentX.x * tangentZ.z - tangentX.z * tangentZ.x,\r\n            z: -tangentX.x * tangentZ.y + tangentX.y * tangentZ.x\r\n        };\r\n\r\n        const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\r\n        normal.x /= normalLength || 1;\r\n        normal.y /= normalLength || 1;\r\n        normal.z /= normalLength || 1;\r\n\r\n        return normal;\r\n    }\r\n\r\n    getReflectionAt(position, velocity, restitution) {\r\n\r\n        const normal = this.getNormalAt(position);\r\n        const dotProduct = \r\n            velocity.x * normal.x + \r\n            velocity.y * normal.y + \r\n            velocity.z * normal.z;\r\n        \r\n        // Only reflect if moving toward the surface\r\n        if (dotProduct < 0) {\r\n            let r = (restitution || 0.3);\r\n            const slopeAmount = 1 - normal.y;\r\n            // Calculate reflection vector correctly (r affects the entire reflection, not just normal component)\r\n            // v_reflect = v - 2(v·n)n then scaled by restitution\r\n            let reflection = new THREE.Vector3(\r\n                velocity.x - 2 * dotProduct * normal.x,\r\n                velocity.y - 2 * dotProduct * normal.y,\r\n                velocity.z - 2 * dotProduct * normal.z\r\n            );\r\n\r\n\r\n            if(dotProduct > -10 || slopeAmount > .5 ){          \r\n                // r = normal.y;\r\n                r = .99;\r\n                // Scale by restitution (energy loss on bounce)\r\n            }\r\n            reflection.x *= r;\r\n            reflection.y *= r;\r\n            reflection.z *= r;\r\n            \r\n            return reflection;\r\n        } else {\r\n            // Not heading into surface, return original velocity\r\n            return { ...velocity };\r\n        }\r\n    }\r\n\r\n    getSlope(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const delta = 1.0;\r\n\r\n        const dx = this.getHeight({ x: wx + delta, z: wz }) - this.getHeight({ x: wx - delta, z: wz });\r\n        const dz = this.getHeight({ x: wx, z: wz + delta }) - this.getHeight({ x: wx, z: wz - delta });\r\n        return Math.sqrt(dx * dx + dz * dz) / (2 * delta);\r\n    }\r\n\r\n    getRandomFromPosition(position, seed = 0) {\r\n        const a = 12345.6789 * (position.x + 1);\r\n        const b = 9876.54321 * (position.z + 1);\r\n        const c = 567.89 * seed;\r\n        const val = Math.sin(a + b + c) * 43758.5453;\r\n        return val - Math.floor(val);\r\n    }\r\n    // Convert hex color (e.g., \"#FF0000\") to RGB object { r, g, b } with values in [0, 1]\r\n    hexToRGB(hex) {\r\n        const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n        const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n        const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n        return { r, g, b };\r\n    }\r\n\r\n    // Convert RGB object { r, g, b } (values in [0, 1]) to hex color string (e.g., \"#FF0000\")\r\n    rgbToHex(rgb) {\r\n        const r = Math.round(rgb.r * 255).toString(16).padStart(2, '0');\r\n        const g = Math.round(rgb.g * 255).toString(16).padStart(2, '0');\r\n        const b = Math.round(rgb.b * 255).toString(16).padStart(2, '0');\r\n        return `#${r}${g}${b}`;\r\n    }\r\n    generateChunk(cx, cz, chunkSize, chunkResolution) {\r\n        // Pre-calculate frequently used values\r\n        const size = chunkSize / chunkResolution;\r\n        const nx = chunkResolution + 1;\r\n        const ny = chunkResolution + 1;\r\n        const vertexCount = nx * ny;\r\n        \r\n        // Pre-allocate arrays for better performance\r\n        const positions = new Float32Array(vertexCount * 3);\r\n        const colors = new Float32Array(vertexCount * 3);\r\n        const normals = new Float32Array(vertexCount * 3);\r\n        const biomeMap = new Array(vertexCount);\r\n        \r\n        // Use a more efficient data structure for vertex heights\r\n        const vertexHeights = new Map();\r\n\r\n        // Generate positions and heights\r\n        for (let z = 0, idx = 0, posIdx = 0; z < ny; z++) {\r\n            for (let x = 0; x < nx; x++, idx++, posIdx += 3) {\r\n                const vx = x * size - chunkSize / 2;\r\n                const vz = z * size - chunkSize / 2;\r\n                const wx = cx * chunkSize + vx;\r\n                const wz = cz * chunkSize + vz;\r\n\r\n                // Use a more efficient boundary key calculation\r\n                let height;\r\n                if ((x === 0 || x === chunkResolution || z === 0 || z === chunkResolution)) {\r\n                    const boundaryKey = `${Math.floor(wx * 1000)},${Math.floor(wz * 1000)}`;\r\n                    if (vertexHeights.has(boundaryKey)) {\r\n                        height = vertexHeights.get(boundaryKey);\r\n                    } else {\r\n                        height = this.getHeight({x: wx, z: wz});\r\n                        vertexHeights.set(boundaryKey, height);\r\n                    }\r\n                } else {\r\n                    height = this.getHeight({x: wx, z: wz});\r\n                }\r\n                \r\n                positions[posIdx] = vx;\r\n                positions[posIdx + 1] = height;\r\n                positions[posIdx + 2] = vz;\r\n                \r\n                const position = {x: wx, y: height, z: wz};\r\n                biomeMap[idx] = {\r\n                    weights: this.getBiomeWeights(position),\r\n                    position: position,\r\n                    slope: this.getSlope(position)\r\n                };\r\n            }\r\n        }\r\n\r\n        // Generate indices more efficiently\r\n        const indexCount = chunkResolution * chunkResolution * 6;\r\n        const indices = new Uint32Array(indexCount);\r\n        \r\n        // Initialize accumulator arrays for normals\r\n        const normalAccum = new Float32Array(vertexCount * 3);\r\n        const contributions = new Uint16Array(vertexCount);\r\n\r\n        // Generate indices and calculate normals\r\n        for (let z = 0, idx = 0; z < chunkResolution; z++) {\r\n            for (let x = 0; x < chunkResolution; x++, idx += 6) {\r\n                const a = x + (z * nx);\r\n                const b = a + 1;\r\n                const c = a + nx;\r\n                const d = c + 1;\r\n\r\n                // Store indices in a more compact way\r\n                indices[idx] = a;\r\n                indices[idx + 1] = c;\r\n                indices[idx + 2] = b;\r\n                indices[idx + 3] = c;\r\n                indices[idx + 4] = d;\r\n                indices[idx + 5] = b;\r\n                \r\n                // Calculate triangle normals more efficiently\r\n                this._calculateTriangleNormals(\r\n                    positions, a, c, b, d,\r\n                    normalAccum, contributions\r\n                );\r\n            }\r\n        }\r\n\r\n        // Normalize accumulated normals\r\n        this._normalizeNormals(normalAccum, contributions, normals);\r\n        // Calculate vertex colors and vegetation\r\n        const { vegetation, grassData, restitution, friction } = this._processVegetationAndColors(\r\n            biomeMap, colors, positions, nx, ny, chunkSize, chunkResolution\r\n        );\r\n\r\n        return {\r\n            cx,\r\n            cz,\r\n            positions: Array.from(positions),\r\n            indices: Array.from(indices),\r\n            colors: Array.from(colors),\r\n            normals: Array.from(normals),\r\n            restitution,\r\n            friction,\r\n            vegetation,\r\n            grassData\r\n        };\r\n    }\r\n\r\n    // Extracted method for triangle normal calculation\r\n    _calculateTriangleNormals(positions, a, c, b, d, normalAccum, contributions) {\r\n        // Calculate vertex positions for the first triangle\r\n        const a3 = a * 3;\r\n        const b3 = b * 3;\r\n        const c3 = c * 3;\r\n        const d3 = d * 3;\r\n        \r\n        // First triangle normal\r\n        const normal1 = this._computeNormal(\r\n            positions[a3], positions[a3 + 1], positions[a3 + 2],\r\n            positions[c3], positions[c3 + 1], positions[c3 + 2],\r\n            positions[b3], positions[b3 + 1], positions[b3 + 2]\r\n        );\r\n        \r\n        // Second triangle normal\r\n        const normal2 = this._computeNormal(\r\n            positions[c3], positions[c3 + 1], positions[c3 + 2],\r\n            positions[d3], positions[d3 + 1], positions[d3 + 2],\r\n            positions[b3], positions[b3 + 1], positions[b3 + 2]\r\n        );\r\n        \r\n        // Accumulate normals for first triangle\r\n        this._accumulateNormal(normal1, normalAccum, a, contributions);\r\n        this._accumulateNormal(normal1, normalAccum, c, contributions);\r\n        this._accumulateNormal(normal1, normalAccum, b, contributions);\r\n        \r\n        // Accumulate normals for second triangle\r\n        this._accumulateNormal(normal2, normalAccum, c, contributions);\r\n        this._accumulateNormal(normal2, normalAccum, d, contributions);\r\n        this._accumulateNormal(normal2, normalAccum, b, contributions);\r\n    }\r\n\r\n    // Compute normal from three vertices\r\n    _computeNormal(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\r\n        // Calculate edges\r\n        const e1x = x2 - x1;\r\n        const e1y = y2 - y1;\r\n        const e1z = z2 - z1;\r\n        \r\n        const e2x = x3 - x1;\r\n        const e2y = y3 - y1;\r\n        const e2z = z3 - z1;\r\n        \r\n        // Cross product\r\n        let nx = e1y * e2z - e1z * e2y;\r\n        let ny = e1z * e2x - e1x * e2z;\r\n        let nz = e1x * e2y - e1y * e2x;\r\n        \r\n        // Normalize\r\n        const mag = Math.sqrt(nx * nx + ny * ny + nz * nz);\r\n        if (mag < 0.00001) {\r\n            return [0, 1, 0];\r\n        }\r\n        \r\n        nx /= mag;\r\n        ny /= mag;\r\n        nz /= mag;\r\n        \r\n        // Ensure normal points upward\r\n        if (ny < 0) {\r\n            nx = -nx;\r\n            ny = -ny;\r\n            nz = -nz;\r\n        }\r\n        \r\n        return [nx, ny, nz];\r\n    }\r\n\r\n    // Accumulate normal at vertex\r\n    _accumulateNormal(normal, normalAccum, vertexIndex, contributions) {\r\n        const idx = vertexIndex * 3;\r\n        normalAccum[idx] += normal[0];\r\n        normalAccum[idx + 1] += normal[1];\r\n        normalAccum[idx + 2] += normal[2];\r\n        contributions[vertexIndex]++;\r\n    }\r\n\r\n    // Normalize accumulated normals\r\n    _normalizeNormals(normalAccum, contributions, normals) {\r\n        for (let i = 0, idx = 0; i < contributions.length; i++, idx += 3) {\r\n            if (contributions[i] > 0) {\r\n                const nx = normalAccum[idx];\r\n                const ny = normalAccum[idx + 1];\r\n                const nz = normalAccum[idx + 2];\r\n                \r\n                const mag = Math.sqrt(nx * nx + ny * ny + nz * nz);\r\n                if (mag > 0.00001) {\r\n                    normals[idx] = nx / mag;\r\n                    normals[idx + 1] = ny / mag;\r\n                    normals[idx + 2] = nz / mag;\r\n                } else {\r\n                    normals[idx] = 0;\r\n                    normals[idx + 1] = 1;\r\n                    normals[idx + 2] = 0;\r\n                }\r\n            } else {\r\n                normals[idx] = 0;\r\n                normals[idx + 1] = 1;\r\n                normals[idx + 2] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extracted method for vegetation and color processing\r\n    _processVegetationAndColors(biomeMap, colors, positions, nx, ny, chunkSize, chunkResolution) {\r\n        const vegetation = new Map();\r\n        let blendedGrass = null;\r\n        let totalGrassWeight = 0;\r\n        let restitution = 0;\r\n        let friction = 0;\r\n        for (let i = 0; i < biomeMap.length; i++) {\r\n            const { weights, position, slope } = biomeMap[i];\r\n            const objectTypes = new Map();\r\n            \r\n            // Calculate blended ground color\r\n            let r = 0, g = 0, b = 0;\r\n            for (const biomeName in weights) {\r\n                const biome = this.biomes[biomeName];\r\n                const weight = weights[biomeName];\r\n                \r\n                // Add weighted color contributions\r\n                r += biome.groundColor.r * weight;\r\n                g += biome.groundColor.g * weight;\r\n                b += biome.groundColor.b * weight;\r\n                if (weight === 0) continue;\r\n                restitution += biome.groundRestitution * weight;\r\n                friction += biome.groundFriction * weight;\r\n                // Process biome objects\r\n                this._processWorldObjects(biome, weight, objectTypes, position, slope, vegetation);\r\n                \r\n                // Process grass\r\n                blendedGrass = this._processGrass(biome, weight, blendedGrass);\r\n                totalGrassWeight += weight;\r\n            }\r\n            \r\n            // Store the blended color\r\n            const colorIdx = i * 3;\r\n            colors[colorIdx] = r;\r\n            colors[colorIdx + 1] = g;\r\n            colors[colorIdx + 2] = b;\r\n        }\r\n        \r\n        // Generate grass instances if needed\r\n        const grassData = totalGrassWeight > 0 ? \r\n            this._finalizeGrass(blendedGrass, totalGrassWeight, chunkSize, chunkResolution, positions, nx) : \r\n            null;\r\n        return { vegetation: this._finalizeVegetation(vegetation), grassData, restitution: restitution / totalGrassWeight, friction: friction / totalGrassWeight };\r\n    }\r\n\r\n    // Process world objects from a biome\r\n    _processWorldObjects(biome, weight, objectTypes, position, slope, vegetation) {\r\n        biome.worldObjects.forEach((objDef, type) => {\r\n            if (!objDef.worldObjectPrefab || objDef.title?.toLowerCase().endsWith('grass')) {\r\n                // Skip grass objects, they're handled separately\r\n                return;\r\n            }\r\n            \r\n            if (!objectTypes.has(objDef.worldObjectPrefab)) {\r\n                objectTypes.set(objDef.worldObjectPrefab, []);\r\n            }\r\n            \r\n            objectTypes.get(objDef.worldObjectPrefab).push({\r\n                density: objDef.density,\r\n                maxSlope: objDef.maxSlope,\r\n                weight\r\n            });\r\n        });\r\n        \r\n        // Generate world object instances\r\n        let index = 0;\r\n        objectTypes.forEach((defs, worldObjectPrefab) => {\r\n            if (!worldObjectPrefab) return;\r\n            \r\n            // Calculate blended properties\r\n            const { density, maxSlope } = this._blendObjectProperties(defs);\r\n            \r\n            // Generate instances based on density and slope\r\n            index++;\r\n            this._generateWorldObjectInstances(\r\n                worldObjectPrefab, \r\n                density, \r\n                maxSlope, \r\n                position, \r\n                slope, \r\n                index,\r\n                vegetation\r\n            );\r\n        });\r\n    }\r\n\r\n    // Blend properties for world objects\r\n    _blendObjectProperties(defs) {\r\n        let blendedDensity = 0;\r\n        let blendedMaxSlope = 0;\r\n        let totalWeight = 0;\r\n        \r\n        defs.forEach(def => {\r\n            blendedDensity += def.density * def.weight;\r\n            blendedMaxSlope += def.maxSlope * def.weight;\r\n            totalWeight += def.weight;\r\n        });\r\n        \r\n        if (totalWeight === 0) {\r\n            return { density: 0, maxSlope: 0 };\r\n        }\r\n        \r\n        return {\r\n            density: blendedDensity / totalWeight,\r\n            maxSlope: blendedMaxSlope / totalWeight\r\n        };\r\n    }\r\n\r\n    // Generate world object instances\r\n    _generateWorldObjectInstances(worldObjectPrefab, density, maxSlope, position, slope, index, vegetation) {\r\n        const instances = vegetation.get(worldObjectPrefab) || [];\r\n        const collisionData = vegetation.get(worldObjectPrefab + '_collision') || [];\r\n        \r\n        // Random check based on density\r\n        const randomSeed = { \r\n            x: position.x * index * 10000, \r\n            y: 0, \r\n            z: position.z * index * 10000 \r\n        };\r\n        \r\n        if (this.getRandomFromPosition(randomSeed, 1) < density && slope <= maxSlope) {\r\n            const instance = {\r\n                position: { x: position.x, y: position.y - 5, z: position.z },\r\n                rotation: this.getRandomFromPosition(position, 2) * Math.PI * 2,\r\n                scale: 0.8 + this.getRandomFromPosition(position, 3) * 0.4\r\n            };\r\n            instances.push(instance);\r\n            \r\n            // Generate collision data\r\n            const aabb = this._generateCollisionAABB(worldObjectPrefab, position, instance.scale);\r\n            if (aabb) {\r\n                collisionData.push(aabb);\r\n            }\r\n        }\r\n        \r\n        vegetation.set(worldObjectPrefab, instances);\r\n        if (collisionData.length > 0) {\r\n            vegetation.set(`${worldObjectPrefab}_collision`, collisionData);\r\n        }\r\n    }\r\n\r\n    // Generate collision AABB for an object\r\n    _generateCollisionAABB(worldObjectPrefab, position, scale) {\r\n        if (worldObjectPrefab.endsWith('tree')) {\r\n            const trunkRadius = 7.0 * scale;\r\n            const trunkHeight = 40.0 * scale;\r\n            return {\r\n                id: `${worldObjectPrefab}_${Math.floor(position.x)}_${Math.floor(position.z)}`,\r\n                min: { \r\n                    x: position.x - trunkRadius, \r\n                    y: position.y - trunkHeight, \r\n                    z: position.z - trunkRadius \r\n                },\r\n                max: { \r\n                    x: position.x + trunkRadius, \r\n                    y: position.y + trunkHeight, \r\n                    z: position.z + trunkRadius \r\n                }\r\n            };\r\n        } else if (worldObjectPrefab.endsWith('rock')) {\r\n            const rockRadius = 5.0 * scale;\r\n            const rockHeight = 10.0 * scale;\r\n            return {\r\n                id: `${worldObjectPrefab}_${Math.floor(position.x)}_${Math.floor(position.z)}`,\r\n                min: { \r\n                    x: position.x - rockRadius, \r\n                    y: position.y, \r\n                    z: position.z - rockRadius \r\n                },\r\n                max: { \r\n                    x: position.x + rockRadius, \r\n                    y: position.y + rockHeight, \r\n                    z: position.z + rockRadius \r\n                }\r\n            };\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    // Process grass from a biome\r\n    _processGrass(biome, weight, blendedGrass) {\r\n        if (!blendedGrass) {\r\n            blendedGrass = {\r\n                bladeWidth: 0,\r\n                bladeHeight: 0,\r\n                baseColor: { r: 0, g: 0, b: 0 },\r\n                tipColor: { r: 0, g: 0, b: 0 },\r\n                density: 0,\r\n                maxSlope: 0,\r\n                weight: 0,\r\n                transforms: []\r\n            };\r\n        }\r\n        \r\n        biome.worldObjects.forEach((objDef) => {\r\n            if (!objDef.worldObjectPrefab && objDef.title?.toLowerCase().endsWith('grass')) {\r\n                // Convert hex colors to RGB for blending\r\n                const baseColorRGB = this.hexToRGB(objDef.baseColor);\r\n                const tipColorRGB = this.hexToRGB(objDef.tipColor);\r\n                \r\n                // Accumulate weighted grass properties\r\n                blendedGrass.bladeWidth += objDef.bladeWidth * weight;\r\n                blendedGrass.bladeHeight += objDef.bladeHeight * weight;\r\n                blendedGrass.baseColor.r += baseColorRGB.r * weight;\r\n                blendedGrass.baseColor.g += baseColorRGB.g * weight;\r\n                blendedGrass.baseColor.b += baseColorRGB.b * weight;\r\n                blendedGrass.tipColor.r += tipColorRGB.r * weight;\r\n                blendedGrass.tipColor.g += tipColorRGB.g * weight;\r\n                blendedGrass.tipColor.b += tipColorRGB.b * weight;\r\n                blendedGrass.density += objDef.density * weight;\r\n                blendedGrass.maxSlope += objDef.maxSlope * weight;\r\n            }\r\n        });\r\n        \r\n        return blendedGrass;\r\n    }\r\n\r\n    // Finalize grass properties and generate instances\r\n    _finalizeGrass(blendedGrass, totalGrassWeight, chunkSize, chunkResolution, positions, vertexCountPerRow) {\r\n        if (!blendedGrass || totalGrassWeight === 0) return null;\r\n        \r\n        // Normalize grass properties\r\n        blendedGrass.bladeWidth /= totalGrassWeight;\r\n        blendedGrass.bladeHeight /= totalGrassWeight;\r\n        blendedGrass.baseColor.r /= totalGrassWeight;\r\n        blendedGrass.baseColor.g /= totalGrassWeight;\r\n        blendedGrass.baseColor.b /= totalGrassWeight;\r\n        blendedGrass.tipColor.r /= totalGrassWeight;\r\n        blendedGrass.tipColor.g /= totalGrassWeight;\r\n        blendedGrass.tipColor.b /= totalGrassWeight;\r\n        blendedGrass.density /= totalGrassWeight;\r\n        blendedGrass.maxSlope /= totalGrassWeight;\r\n        \r\n        // Convert back to hex if needed\r\n        blendedGrass.baseColor = this.rgbToHex(blendedGrass.baseColor);\r\n        blendedGrass.tipColor = this.rgbToHex(blendedGrass.tipColor);\r\n        \r\n        // Generate grass instances\r\n        const grassPerChunk = Math.floor(blendedGrass.density * chunkSize * chunkResolution);\r\n        blendedGrass.grassPerChunk = grassPerChunk;\r\n        const step = chunkSize / chunkResolution;\r\n        \r\n        // Pre-allocate arrays\r\n        blendedGrass.phases = new Float32Array(grassPerChunk);\r\n        blendedGrass.transforms = new Array(grassPerChunk);\r\n        \r\n        for (let i = 0; i < grassPerChunk; i++) {\r\n            const x = Math.random() * chunkResolution;\r\n            const z = Math.random() * chunkResolution;\r\n            const xIdx = Math.floor(x);\r\n            const zIdx = Math.floor(z);\r\n            const fx = x - xIdx;\r\n            const fz = z - zIdx;\r\n            \r\n            const height = this.interpolateHeight(positions, xIdx, zIdx, fx, fz, vertexCountPerRow);\r\n            const worldX = (x * step - chunkSize / 2);\r\n            const worldZ = (z * step - chunkSize / 2);\r\n            \r\n            blendedGrass.transforms[i] = {\r\n                position: { x: worldX, y: height, z: worldZ },\r\n                rotation: Math.random() * Math.PI * 2,\r\n                scale: 0.7 + Math.random() * 0.5\r\n            };\r\n            \r\n            blendedGrass.phases[i] = Math.random() * Math.PI * 2;\r\n        }\r\n        \r\n        return blendedGrass.transforms.length > 0 ? blendedGrass : null;\r\n    }\r\n\r\n    // Finalize vegetation data\r\n    _finalizeVegetation(vegetation) {\r\n        return Array.from(vegetation.entries()).map(([worldObject, data]) => ({ \r\n            worldObject, \r\n            data \r\n        }));\r\n    }\r\n\r\n    // Interpolate height at a position\r\n    interpolateHeight(positions, x, z, fx, fz, vertexCountPerRow) {\r\n        const idx1 = (z * vertexCountPerRow + x) * 3;\r\n        const idx2 = idx1 + 3;\r\n        const idx3 = ((z + 1) * vertexCountPerRow + x) * 3;\r\n        const idx4 = idx3 + 3;\r\n        \r\n        const h1 = positions[idx1 + 1];\r\n        const h2 = positions[idx2 + 1];\r\n        const h3 = positions[idx3 + 1];\r\n        const h4 = positions[idx4 + 1];\r\n        \r\n        // Bilinear interpolation\r\n        const top = h1 * (1 - fx) + h2 * fx;\r\n        const bottom = h3 * (1 - fx) + h4 * fx;\r\n        \r\n        return top * (1 - fz) + bottom * fz;\r\n    }\r\n}"
      },
      "ImageManager": {
        "fileName": "ImageManager",
        "script": "\r\nclass ImageManager {\r\n    constructor(app, {imageSize, palette, textures}, {ShapeFactory}) {\r\n        this.app = app;\r\n        this.images = {};\r\n        this.imageSize = imageSize || 128;\r\n        // Create a single reusable renderer\r\n        this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });\r\n        this.renderer.setSize(this.imageSize, this.imageSize);\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        \r\n        this.renderTarget = new THREE.WebGLRenderTarget(this.imageSize, this.imageSize);\r\n        this.renderTarget.texture.flipY = true;\r\n        \r\n        // Create reusable scene\r\n        this.scene = new THREE.Scene();\r\n        \r\n        // Create reusable cameras for different views\r\n        const cameraDistance = 64;\r\n        const frustumSize = cameraDistance + 16;\r\n        const aspect = 1;\r\n\r\n        this.shapeFactory = new ShapeFactory(palette, textures);\r\n        // Create 8 cameras for isometric views at 45-degree intervals\r\n        this.cameras = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            this.cameras.push(new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000));\r\n        }\r\n        \r\n        // Position cameras in a circle around the y-axis at isometric angle\r\n        // Standard isometric angle is about 35.264 degrees (arctan(1/sqrt(2)))\r\n        const isoAngle = Math.atan(1 / Math.sqrt(2));\r\n        const horizDistance = cameraDistance * Math.cos(isoAngle);\r\n        const vertDistance = cameraDistance * Math.sin(isoAngle);\r\n        \r\n        for (let i = 0; i < 8; i++) {\r\n            const angle = (i * Math.PI / 4); // 45-degree increments\r\n            const x = horizDistance * Math.sin(angle);\r\n            const z = horizDistance * Math.cos(angle);\r\n            \r\n            this.cameras[i].position.set(x, vertDistance, z);\r\n            this.cameras[i].lookAt(0, 0, 0);\r\n        }\r\n        \r\n        // Create reusable lights\r\n        this.ambientLight = new THREE.AmbientLight(0xffaaff, .25);\r\n        \r\n        // Create a light group that will rotate with each camera view\r\n        this.lightGroup = new THREE.Group();\r\n        \r\n        // Main directional light\r\n        this.directionalLight = new THREE.DirectionalLight(0xffffaa, .7);\r\n        this.directionalLight.position.set(75, 96, 75);\r\n        this.directionalLight.castShadow = true;\r\n        this.directionalLight.shadow.mapSize.width = 1024;\r\n        this.directionalLight.shadow.mapSize.height = 1024;\r\n        this.directionalLight.shadow.camera.near = 0.5;\r\n        this.directionalLight.shadow.camera.far = 500;\r\n        this.directionalLight.shadow.bias = -0.0005;\r\n        this.directionalLight.shadow.normalBias = 0.02;\r\n        this.directionalLight.shadow.radius = 1;\r\n        this.lightGroup.add(this.directionalLight);\r\n        \r\n        // Fill light\r\n        this.fillLight = new THREE.DirectionalLight(0xffaaff, .5);\r\n        this.fillLight.position.set(-20, 30, -20);\r\n        this.lightGroup.add(this.fillLight);\r\n        \r\n        // Create ground plane\r\n        const groundGeometry = new THREE.PlaneGeometry(200, 200);\r\n        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });\r\n        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n        this.ground.rotation.x = -Math.PI / 2;\r\n        this.ground.position.y = 0;\r\n        this.ground.receiveShadow = true;\r\n    }\r\n\r\n    clear() {\r\n        images = {};\r\n    }\r\n\r\n    dispose() {\r\n        // Proper cleanup when the manager is no longer needed\r\n        if (this.renderer) {\r\n            this.renderer.dispose();\r\n            this.renderer = null;\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n            this.renderTarget = null;\r\n        }\r\n        if (this.ground && this.ground.geometry) {\r\n            this.ground.geometry.dispose();\r\n            this.ground.material.dispose();\r\n        }\r\n        // Dispose of other reusable resources\r\n        this.cameras = [];\r\n        this.scene = null;\r\n        this.lightGroup = null;\r\n        this.ambientLight = null;\r\n    }\r\n\r\n    async loadImages(prefix, config, checkCache = true, cacheResult = true) {\r\n\r\n        if (!prefix || !config || typeof config !== 'object') {\r\n            throw new Error('Invalid prefix or config provided to loadImages');\r\n        }\r\n        if( checkCache ) {\r\n            const cachedImages = await this.checkCache(prefix);\r\n            if (cachedImages) {\r\n                this.images = { ...this.images, ...cachedImages };\r\n                return;\r\n            }\r\n        }\r\n    \r\n        for (const [type, cfg] of Object.entries(config)) {\r\n            if (cfg.render && cfg.render.animations) {\r\n                this.images[`${prefix}_${type}`] = await this.createAnimatedPlaceholder(cfg);\r\n            } else if (cfg.tileMap && cfg.tileMap.terrainTypes) {\r\n                this.images[`${prefix}_${type}`] = await this.createTerrainImages(cfg);\r\n            }\r\n        }\r\n        if(cacheResult) {\r\n            await this.cacheImages(prefix);\r\n        }\r\n    }\r\n    \r\n    async checkCache(prefix) {\r\n        try {\r\n            const response = await fetch(`/cache/${prefix}.json`);\r\n            if (response.ok) {\r\n                const cacheData = await response.json();\r\n                // Convert base64 cached images back to canvases\r\n                return await this.convertBase64ToCanvases(cacheData.images);\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    async convertBase64ToCanvases(cachedImages) {\r\n        const convertedImages = {};\r\n        \r\n        for (const [key, value] of Object.entries(cachedImages)) {\r\n            if (Array.isArray(value)) {\r\n                // Handle terrain tiles\r\n                convertedImages[key] = await Promise.all(value.map(async (terrain) => {\r\n                    const sprites = await Promise.all(terrain.sprites.map(async (base64) => {\r\n                        const canvas = document.createElement('canvas');\r\n                        canvas.width = canvas.height = 24; // Match tileWidth from createTerrainImages\r\n                        const ctx = canvas.getContext('2d');\r\n                        const img = new Image();\r\n                        \r\n                        await new Promise((resolve, reject) => {\r\n                            img.onload = () => {\r\n                                ctx.drawImage(img, 0, 0);\r\n                                resolve();\r\n                            };\r\n                            img.onerror = reject;\r\n                            img.src = base64;\r\n                        });\r\n                        \r\n                        return canvas;\r\n                    }));\r\n                    \r\n                    return {\r\n                        type: terrain.type,\r\n                        sprites\r\n                    };\r\n                }));\r\n            } else if (typeof value === 'object') {\r\n                // Handle animations\r\n                const animations = {};\r\n                for (const [animType, frames] of Object.entries(value)) {\r\n                    animations[animType] = await Promise.all(frames.map(async (frameSet) => {\r\n                        return Promise.all(frameSet.map(async (base64) => {\r\n                            const canvas = document.createElement('canvas');\r\n                            canvas.width = canvas.height = this.imageSize;\r\n                            const ctx = canvas.getContext('2d');\r\n                            const img = new Image();\r\n                            \r\n                            await new Promise((resolve, reject) => {\r\n                                img.onload = () => {\r\n                                    ctx.drawImage(img, 0, 0);\r\n                                    resolve();\r\n                                };\r\n                                img.onerror = reject;\r\n                                img.src = base64;\r\n                            });\r\n                            \r\n                            return canvas;\r\n                        }));\r\n                    }));\r\n                }\r\n                convertedImages[key] = animations;\r\n            }\r\n        }\r\n        \r\n        return convertedImages;\r\n    }\r\n    async cacheImages(prefix) {\r\n        const base64Images = {};\r\n        \r\n        for (const [key, value] of Object.entries(this.images)) {\r\n            if (key.startsWith(prefix)) {\r\n                if (Array.isArray(value) && value[0]?.type && value[0]?.sprites) {\r\n                    // Handle terrain tiles\r\n                    base64Images[key] = value.map(terrain => ({\r\n                        type: terrain.type,\r\n                        sprites: terrain.sprites.map(canvas => canvas.toDataURL('image/png'))\r\n                    }));\r\n                } else if (typeof value === 'object' && value !== null) {\r\n                    // Handle animations\r\n                    const animationData = {};\r\n                    for (const [animType, frames] of Object.entries(value)) {\r\n                        animationData[animType] = frames.map(frameSet => \r\n                            frameSet.map(canvas => canvas.toDataURL('image/png'))\r\n                        );\r\n                    }\r\n                    base64Images[key] = animationData;\r\n                }\r\n            }\r\n        }\r\n\r\n        try {\r\n            await fetch('/api/cache', {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    prefix,\r\n                    images: base64Images\r\n                })\r\n            });\r\n        } catch (error) {\r\n            console.error('Error caching images:', error);\r\n        }\r\n    }\r\n    // In the ImageManager class\r\n    async createTerrainImages(config) {\r\n        let terrainTiles = [];\r\n        const tileWidth = 24;\r\n\r\n        // Create a map of terrain type to its image data first\r\n        const terrainMap = {};\r\n        \r\n        await Promise.all(config.tileMap.terrainTypes.map(async (terrainType, terrainIndex) => {\r\n            const pixelData = terrainType.image;\r\n            if (pixelData && pixelData.length > 0) {\r\n                let sprites = new Array(8);\r\n                \r\n                await Promise.all(pixelData.map(async (imagePixelData, spriteIdx) => {\r\n                    const img = new Image();\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = tileWidth;\r\n                    const ctx = canvas.getContext('2d');\r\n\r\n                    if (!imagePixelData.startsWith('data:image/')) {\r\n                        imagePixelData = 'data:image/png;base64,' + imagePixelData;\r\n                    }\r\n                    img.src = imagePixelData;\r\n\r\n                    await new Promise((resolve, reject) => {\r\n                        img.onload = () => {\r\n                            ctx.drawImage(img, 0, 0);\r\n                            sprites[spriteIdx] = canvas;\r\n                            resolve();\r\n                        };\r\n                        img.onerror = () => {\r\n                            console.error(`Failed to load image for ${terrainType.type} at index ${spriteIdx}`);\r\n                            sprites[spriteIdx] = canvas; // Store empty canvas on error\r\n                            resolve(); // Don't reject, just move on\r\n                        };\r\n                    });\r\n                }));\r\n\r\n                // Store by index and type for more reliable lookup\r\n                terrainTiles[terrainIndex] = { \r\n                    type: terrainType.type,\r\n                    sprites: sprites \r\n                };\r\n            } else {\r\n                // Create a solid color placeholder for types without images\r\n                const sprites = new Array(8).fill().map(() => {\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = tileWidth;\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.fillStyle = terrainType.color || '#cccccc';\r\n                    ctx.fillRect(0, 0, tileWidth, tileWidth);\r\n                    return canvas;\r\n                });\r\n                \r\n                terrainTiles[terrainIndex] = {\r\n                    type: terrainType.type,\r\n                    sprites: sprites\r\n                };\r\n            }\r\n        }));\r\n\r\n        // Make sure there are no gaps in the array\r\n        return terrainTiles.filter(Boolean);\r\n    }\r\n    async createAnimatedPlaceholder(config) {\r\n        const animations = {};\r\n        \r\n        if(config.shadows === false) {\r\n            this.ground.receiveShadow = false;\r\n        } else {\r\n            this.ground.receiveShadow = true;\r\n        }\r\n        for (const [animType, frames] of Object.entries(config.render.animations)) {\r\n            animations[animType] = [];\r\n            let i = 0;\r\n            for (const frame of frames) {\r\n                const frameImages = await this.captureObjectImagesFromJSON(config.render.model, frame);\r\n                const canvases = frameImages.map(img => {\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = this.imageSize;\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n                    return canvas;\r\n                });                \r\n                animations[animType].push(canvases); // Array of 8 canvases per frame\r\n            }\r\n        }\r\n        return animations; // { \"idle\": [[canvas0, canvas1, canvas2, canvas3, ...], ...], \"walk\": [...] }\r\n    }\r\n\r\n    getImages(prefix, type) {\r\n        return this.images[`${prefix}_${type}`]; // Returns animation object\r\n    }\r\n    async captureObjectImagesFromJSON(model, frameData) {\r\n        const size = this.imageSize;\r\n        // Clear the scene\r\n        while (this.scene.children.length > 0) {\r\n            const object = this.scene.children[0];\r\n            this.scene.remove(object);\r\n        }\r\n        \r\n        // Add reusable elements to scene\r\n        this.scene.add(this.ground);\r\n        this.scene.add(this.ambientLight);\r\n        this.scene.add(this.lightGroup);\r\n        \r\n        // Create objects from the JSON data\r\n        const objectGroup = await this.createObjectsFromJSON(model, frameData, this.scene);\r\n\r\n        \r\n        const images = [];\r\n        \r\n        // For each camera view, rotate the light group to match camera orientation\r\n        for (let i = 0; i < this.cameras.length; i++) {\r\n            const camera = this.cameras[i];\r\n            \r\n            // Reset light group rotation\r\n            this.lightGroup.rotation.set(0, 0, 0);\r\n            \r\n            // Rotate light group to match camera position\r\n            // Calculate angle based on camera index (8 positions at 45-degree intervals)\r\n            // Rotate 45 degrees CLOCKWISE (subtract π/4 instead of adding)\r\n            const angle = (i * Math.PI / 4); \r\n            this.lightGroup.rotation.y = angle;\r\n            \r\n            // Before rendering with each camera, update shadow camera frustum\r\n            const d = 100;\r\n            this.directionalLight.shadow.camera.left = -d;\r\n            this.directionalLight.shadow.camera.right = d;\r\n            this.directionalLight.shadow.camera.top = d;\r\n            this.directionalLight.shadow.camera.bottom = -d;\r\n            // After rotating lightGroup in the camera loop\r\n            this.directionalLight.shadow.camera.updateProjectionMatrix();\r\n            this.directionalLight.shadow.camera.updateMatrixWorld();\r\n            this.directionalLight.target.position.set(0, 0, 0);\r\n            this.directionalLight.target.updateMatrixWorld();\r\n            // Render and capture the image\r\n            this.renderer.setRenderTarget(this.renderTarget);\r\n            this.renderer.render(this.scene, camera);\r\n            const buffer = new Uint8Array(size * size * 4);\r\n            this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, size, size, buffer);\r\n            \r\n            // Flip the buffer (y-axis)\r\n            const flippedBuffer = new Uint8Array(size * size * 4);\r\n            for (let y = 0; y < size; y++) {\r\n                const srcRowStart = y * size * 4;\r\n                const destRowStart = (size - 1 - y) * size * 4;\r\n                flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);\r\n            }\r\n            \r\n            const imageData = new ImageData(new Uint8ClampedArray(flippedBuffer), size, size);\r\n            const imageBitmap = await createImageBitmap(imageData);\r\n            images.push(imageBitmap);\r\n        }\r\n        if( this.renderer) this.renderer.setRenderTarget(null);\r\n        \r\n        // Cleanup object geometries and materials\r\n        this.shapeFactory.disposeObject(objectGroup);\r\n        \r\n        // Remove object group from scene\r\n        if( this.scene ) this.scene.remove(objectGroup);\r\n        \r\n        return images;\r\n    }\r\n\r\n    /**\r\n     * Creates 3D objects from shape data.\r\n     * @param {Object} frameData - The JSON object containing frame definitions.\r\n     * @returns {THREE.Group} - A group containing all 3D objects.\r\n     */\r\n  \r\n    async createObjectsFromJSON(model, frameData, scene) {\r\n        const rootGroup = new THREE.Group();\r\n        \r\n        for(const groupName in model) {\r\n            const group = await this.shapeFactory.createMergedGroupFromJSON(model, frameData, groupName);\r\n            if(group){\r\n                group.traverse((child) => {\r\n                    if (child.isMesh) {\r\n                        child.castShadow = true; // or set this selectively for objects that should cast shadows\r\n                        child.receiveShadow = true; // for objects that should receive shadows\r\n                    }\r\n                });\r\n                rootGroup.add(group);\r\n            }\r\n        }\r\n\r\n        scene.add(rootGroup);\r\n    \r\n        return rootGroup;\r\n    }\r\n   \r\n}\r\n"
      },
      "SpatialGrid": {
        "fileName": "SpatialGrid",
        "script": " \r\n    class SpatialGrid {\r\n        constructor(worldSize, cellSize) {\r\n            this.cellSize = cellSize;\r\n            this.cols = worldSize;\r\n            this.rows = worldSize;\r\n            this.grid = new Array(this.cols * this.rows).fill().map(() => []);\r\n            \r\n            // Track which cell each entity is in\r\n            this.entityCells = new Map(); // Map of entity -> cell index\r\n        }\r\n        \r\n        getIndex(x, y) {\r\n            return y * this.cols + x;\r\n        }\r\n\r\n        insert(entity) {\r\n            const newIndex = this.getIndex(entity.transform.gridPosition.x, entity.transform.gridPosition.y);\r\n            const oldIndex = this.entityCells.get(entity);\r\n            \r\n            // If entity moved to a new cell\r\n            if (oldIndex !== newIndex) {\r\n                // Remove from old cell if it exists\r\n                if (oldIndex !== undefined) {\r\n                    const oldCell = this.grid[oldIndex];\r\n                    const entityIndex = oldCell.indexOf(entity);\r\n                    if (entityIndex !== -1) {\r\n                        oldCell.splice(entityIndex, 1);\r\n                    }\r\n                }\r\n                \r\n                // Add to new cell\r\n                if (newIndex >= 0 && newIndex < this.grid.length) {\r\n                    this.grid[newIndex].push(entity);\r\n                    this.entityCells.set(entity, newIndex);\r\n                }\r\n            }\r\n        }\r\n        \r\n        remove(entity) {\r\n            const index = this.entityCells.get(entity);\r\n            if (index !== undefined) {\r\n                const cell = this.grid[index];\r\n                const entityIndex = cell.indexOf(entity);\r\n                if (entityIndex !== -1) {\r\n                    cell.splice(entityIndex, 1);\r\n                }\r\n                this.entityCells.delete(entity);\r\n            }\r\n        }\r\n        getNearbyEntities(x, y, radius, type=\"\") {\r\n            const nearby = [];\r\n            // Get cells that could contain entities within radius\r\n            const startX = Math.max(0, Math.floor((x - radius)));\r\n            const endX = Math.min(this.cols - 1, Math.floor((x + radius)));\r\n            const startY = Math.max(0, Math.floor((y - radius)));\r\n            const endY = Math.min(this.rows - 1, Math.floor((y + radius)));\r\n       \r\n            // Collect potential candidates from relevant cells\r\n            for (let row = startY; row <= endY; row++) {\r\n                for (let col = startX; col <= endX; col++) {\r\n                    const index = row * this.cols + col;\r\n                    if (index >= 0 && index < this.grid.length) {\r\n                        for (let entity of this.grid[index]) {\r\n                            const dx = (entity.transform.gridPosition.x) - (x + .5);\r\n                            const dy = (entity.transform.gridPosition.y) - (y + .5);\r\n                            const distSquared = dx * dx + dy * dy;\r\n                            \r\n                            if (distSquared <= radius * radius) {\r\n                                if(type) {\r\n                                    if( entity.type == type ) {\r\n                                        nearby.push(entity);\r\n                                    }\r\n                                } else {\r\n                                    nearby.push(entity);\r\n                                }\r\n                            }                            \r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return nearby;\r\n        }\r\n        clear() {\r\n            this.grid = this.grid.map(() => []);\r\n            this.entityCells.clear();\r\n        }\r\n        \r\n        // Optional: Only clear but maintain all entity positions\r\n        // Useful for when reusing the same grid across updates\r\n        resetKeepingEntities() {\r\n            const allEntities = [];\r\n            this.entityCells.forEach((_, entity) => {\r\n                allEntities.push(entity);\r\n            });\r\n            \r\n            this.clear();\r\n            \r\n            allEntities.forEach(entity => {\r\n                this.insert(entity);\r\n            });\r\n        }\r\n    }\r\n"
      },
      "CoordinateTranslator": {
        "fileName": "CoordinateTranslator",
        "script": "class CoordinateTranslator {\r\n    constructor(config, mapSize, isometric = false) {\r\n        this.isometric = isometric;\r\n        this.tileWidth = config.gridSize;\r\n        this.tileHeight = config.gridSize * 0.5;\r\n        this.canvasWidth = config.canvasWidth;\r\n        this.canvasHeight = config.canvasHeight;\r\n        this.mapSize = mapSize;\r\n    }\r\n\r\n    // Pixel (top-down) to Grid\r\n    pixelToGrid(pixelX, pixelY) {\r\n        return {\r\n            x: pixelX / this.tileWidth,\r\n            y: pixelY / this.tileWidth\r\n        };\r\n    }\r\n\r\n    // Grid to Isometric (with vertical centering)\r\n    gridToIso(gridX, gridY) {\r\n        // If not isometric, return grid coordinates as-is\r\n        if (!this.isometric) {\r\n            return { x: gridX * this.tileWidth, y: gridY * this.tileWidth };\r\n        }\r\n\r\n        const isoX = (gridX - gridY) * (this.tileWidth / 2) + this.canvasWidth / 2;\r\n       \r\n        // Calculate the height the grid would occupy\r\n        const totalGridHeight = this.mapSize * this.tileHeight;\r\n       \r\n        // Center vertically by adding an offset\r\n        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;\r\n       \r\n        const isoY = (gridX + gridY) * (this.tileHeight / 2) + verticalOffset;\r\n       \r\n        return { x: isoX, y: isoY };\r\n    }\r\n\r\n    // Pixel (top-down) to Isometric\r\n    pixelToIso(pixelX, pixelY) {\r\n        if(!this.isometric){\r\n            return {\r\n                x: pixelX + ( this.canvasWidth - this.mapSize * this.tileWidth) / 2,\r\n                y: pixelY + ( this.canvasHeight - this.mapSize * this.tileWidth) / 2\r\n            }\r\n        }\r\n        const grid = this.pixelToGrid(pixelX, pixelY);\r\n        return this.gridToIso(grid.x, grid.y);\r\n    }\r\n\r\n    isoToGrid(isoX, isoY) {\r\n        // If not isometric, convert directly to grid\r\n        if (!this.isometric) {\r\n            return {\r\n                x: isoX / this.tileWidth,\r\n                y: isoY / this.tileWidth\r\n            };\r\n        }\r\n\r\n        const adjustedX = isoX - this.canvasWidth / 2;\r\n       \r\n        // Calculate the same vertical offset as in gridToIso\r\n        const totalGridHeight = this.mapSize * this.tileHeight;\r\n        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;\r\n       \r\n        // Subtract the offset before conversion\r\n        const adjustedY = isoY - verticalOffset;\r\n       \r\n        const gridX = (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2;\r\n        const gridY = (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2;\r\n       \r\n        return { x: gridX, y: gridY };\r\n    }\r\n\r\n    isoToPixel(isoX, isoY) {\r\n        const grid = this.isoToGrid(isoX, isoY);\r\n        return {\r\n            x: grid.x * this.tileWidth,\r\n            y: grid.y * this.tileWidth\r\n        };\r\n    }\r\n\r\n    // Snap grid coordinates to nearest integer\r\n    snapToGrid(gridX, gridY) {\r\n        return { x: Math.floor(gridX), y: Math.floor(gridY) };\r\n    }\r\n}"
      },
      "CanvasUtility": {
        "fileName": "CanvasUtility",
        "script": "class CanvasUtility {\r\n    constructor() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\r\n\t\tthis.ctx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency\r\n        \r\n\t\tthis.tempCanvas = document.createElement('canvas');\r\n        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });\r\n\t\tthis.tempCtx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency\r\n    }\r\n\r\n    setSize(width, height) {\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n    paintTexture(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\trotateTexture(imageData, angle) {\r\n        // Set the canvas size to accommodate the rotated image\r\n        // Note: If the rotation results in a change in width/height, adjust these values accordingly\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original imageData to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Apply the rotation\r\n        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n        this.ctx.rotate(angle);\r\n        this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);\r\n\r\n        // Create a temporary canvas to hold the current state\r\n        this.tempCanvas.width = this.canvas.width;\r\n        this.tempCanvas.height = this.canvas.height;\r\n        this.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Clear the main canvas and draw the rotated image\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.drawImage(this.tempCanvas, 0, 0);\r\n\r\n        // Capture the rotated image data\r\n        let rotatedData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n \r\n\r\n        return rotatedData;\r\n    }\r\n\tflipTextureVertical(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original image data to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Use an off-screen canvas to perform the flip\r\n        this.tempCanvas.width = imageData.width;\r\n        this.tempCanvas.height = imageData.height;\r\n  \r\n        // Apply the flip on the off-screen canvas\r\n        this.tempCtx.translate(0, this.tempCanvas.height);\r\n\t\tthis.tempCtx.scale(1, -1);\r\n\t\tthis.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Extract the flipped image data\r\n        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);\r\n    }\r\n\r\n    flipTextureHorizontal(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original image data to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Use an off-screen canvas to perform the flip\r\n        this.tempCanvas.width = imageData.width;\r\n        this.tempCanvas.height = imageData.height;\r\n        // Apply the flip on the off-screen canvas\r\n\t\tthis.tempCtx.translate(this.tempCanvas.width, 0);\r\n\t\tthis.tempCtx.scale(-1, 1);\r\n\t\tthis.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Extract the flipped image data\r\n        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);\r\n    }\r\n\tdrawImage(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n\trotateImage(image, angle) {\r\n\t\tthis.setSize(image.width, image.height);\r\n\t\t// Set up the rotation\r\n\t\tthis.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n\t\tthis.ctx.rotate(angle);\r\n\t\tthis.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);\r\n\t\tthis.ctx.fillStyle = 'rgba(0, 0, 0, 0)'; // Fully transparent\r\n\t\tthis.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\t\r\n\t\t// Draw the image\r\n\t\tthis.ctx.drawImage(image, 0, 0);\r\n\t\treturn this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n\t}\r\n\r\n    flipImageVertical(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.translate(0, this.canvas.height);\r\n        this.ctx.scale(1, -1);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    flipCanvasVertical() {\r\n        this.ctx.translate(0, this.canvas.height);\r\n        this.ctx.scale(1, -1);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    flipImageHorizontal(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.translate(this.canvas.width, 0);\r\n        this.ctx.scale(-1, 1);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n}"
      },
      "TerrainImageProcessor": {
        "fileName": "TerrainImageProcessor",
        "script": "class TerrainImageProcessor {\r\n  //Utility function to convert terrain tile spritesheets to and from base64 encoding\r\n    constructor(app, options = {}) {\r\n        this.app = app;\r\n        // Configurable tile dimensions with defaults\r\n        this.tileWidth = options.tileWidth || 24;\r\n        this.tileHeight = options.tileHeight || 24;\r\n        this.tilesX = options.tilesX || 4;\r\n        this.tilesY = options.tilesY || 1;\r\n\r\n        // Bind methods to ensure correct context\r\n        this.convertCanvasToBase64Tiles = this.convertCanvasToBase64Tiles.bind(this);\r\n        this.displayStoredBase64Tiles = this.displayStoredBase64Tiles.bind(this);\r\n\r\n        // Element references\r\n        this.output = null;\r\n        this.displayImage = null;\r\n    }\r\n\r\n    // Initialize the processor with DOM elements\r\n    initialize(outputElement, displayImageElement) {\r\n        this.output = outputElement;\r\n        this.displayImage = displayImageElement;\r\n\r\n        // Optional: Add custom event listener\r\n        document.body.addEventListener('editTerrainImage', this.displayStoredBase64Tiles);\r\n    }\r\n\r\n    processImage(imageUrl) {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n            // Create a temporary canvas to process the image\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = this.tileWidth * this.tilesX;\r\n            canvas.height = this.tileHeight * this.tilesY;\r\n\r\n            const ctx = canvas.getContext('2d');\r\n            \r\n            // Set transparent background\r\n            ctx.globalCompositeOperation = 'source-over';\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n            \r\n            // Draw the uploaded image, scaling to fit the canvas\r\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\r\n\r\n            // Convert to base64 tiles with vertical flips\r\n            const base64Tiles = this.convertCanvasToBase64Tiles(canvas);\r\n            \r\n            // Save base64 tiles to output\r\n            this.output.value = JSON.stringify(base64Tiles);\r\n\r\n            // Display the original uploaded image\r\n            this.displayImage.src = imageUrl;\r\n        };\r\n        img.src = imageUrl;\r\n    }\r\n\r\n\r\n\r\n    // Convert canvas to array of base64 tiles with vertical flips\r\n    convertCanvasToBase64Tiles(canvas, format = 'png', quality = 1.0) {\r\n        const base64Tiles = [];\r\n\r\n        // First, process the first row of tiles normally\r\n        for (let x = 0; x < this.tilesX; x++) {\r\n            const tileCanvas = document.createElement('canvas');\r\n            tileCanvas.width = this.tileWidth;\r\n            tileCanvas.height = this.tileHeight;\r\n            const tileCtx = tileCanvas.getContext('2d');\r\n\r\n            // Calculate the source position on the main canvas\r\n            const srcX = x * this.tileWidth;\r\n            const srcY = 0;\r\n\r\n            // Get the image data for this tile\r\n            const imageData = canvas.getContext('2d').getImageData(\r\n                srcX, srcY, this.tileWidth, this.tileHeight\r\n            );\r\n\r\n            // Put the image data on the tile canvas\r\n            tileCtx.putImageData(imageData, 0, 0);\r\n\r\n            // Convert the tile canvas to a data URL\r\n            const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n\r\n            // Extract the Base64 string (remove the prefix)\r\n            const base64String = dataUrl.split(',')[1];\r\n\r\n            // Add to the array\r\n            base64Tiles.push(base64String);\r\n        }\r\n\r\n        // Now create vertically flipped versions of the first row\r\n        for (let x = 0; x < this.tilesX; x++) {\r\n            const tileCanvas = document.createElement('canvas');\r\n            tileCanvas.width = this.tileWidth;\r\n            tileCanvas.height = this.tileHeight;\r\n            const tileCtx = tileCanvas.getContext('2d');\r\n\r\n            // Calculate the source position on the main canvas\r\n            const srcX = x * this.tileWidth;\r\n            const srcY = 0;\r\n\r\n            // Get the image data for this tile\r\n            const imageData = canvas.getContext('2d').getImageData(\r\n                srcX, srcY, this.tileWidth, this.tileHeight\r\n            );\r\n\r\n            // Create a new ImageData for the flipped tile\r\n            const flippedImageData = new ImageData(this.tileWidth, this.tileHeight);\r\n            for (let y = 0; y < this.tileHeight; y++) {\r\n                for (let x = 0; x < this.tileWidth; x++) {\r\n                    const srcIndex = (y * this.tileWidth + x) * 4;\r\n                    const destIndex = ((this.tileHeight - 1 - y) * this.tileWidth + x) * 4;\r\n                    \r\n                    flippedImageData.data[destIndex] = imageData.data[srcIndex];     // R\r\n                    flippedImageData.data[destIndex + 1] = imageData.data[srcIndex + 1]; // G\r\n                    flippedImageData.data[destIndex + 2] = imageData.data[srcIndex + 2]; // B\r\n                    flippedImageData.data[destIndex + 3] = imageData.data[srcIndex + 3]; // A\r\n                }\r\n            }\r\n\r\n            // Put the flipped image data on the tile canvas\r\n            tileCtx.putImageData(flippedImageData, 0, 0);\r\n\r\n            // Convert the tile canvas to a data URL\r\n            const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n\r\n            // Extract the Base64 string (remove the prefix)\r\n            const base64String = dataUrl.split(',')[1];\r\n\r\n            // Add to the array\r\n            base64Tiles.push(base64String);\r\n        }\r\n\r\n        return base64Tiles;\r\n    }\r\n\r\n    // Display stored base64 tiles\r\n    displayStoredBase64Tiles() {\r\n        // Check if there are stored base64 tiles\r\n        if (!this.output.value) return;\r\n\r\n        try {\r\n            // Parse the stored base64 tiles\r\n            const base64Tiles = JSON.parse(this.output.value);\r\n\r\n            // Validate the number of tiles\r\n            if (!Array.isArray(base64Tiles) || base64Tiles.length !== 8) {\r\n                console.error('Invalid base64 tiles array');\r\n                return;\r\n            }\r\n\r\n            const img = new Image();\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = this.tileWidth * this.tilesX;\r\n            canvas.height = this.tileHeight * this.tilesY;\r\n            const ctx = canvas.getContext('2d');\r\n\r\n            let loadedImages = 0;\r\n            const tileImages = new Array(8).fill(null);\r\n\r\n            base64Tiles.forEach((base64String, index) => {\r\n                const tileImg = new Image();\r\n                tileImg.onload = () => {\r\n                    tileImages[index] = tileImg;\r\n                    loadedImages++;\r\n\r\n                    // Once all images are loaded, draw them\r\n                    if (loadedImages === base64Tiles.length) {\r\n                        // Draw first row of tiles\r\n                        for (let x = 0; x < this.tilesX; x++) {\r\n                            ctx.drawImage(tileImages[x], x * this.tileWidth, 0);\r\n                        }\r\n\r\n                        // Set the final image\r\n                        this.displayImage.src = canvas.toDataURL('image/png');\r\n                    }\r\n                };\r\n\r\n                // Ensure the base64 string has the correct data URL prefix\r\n                if (!base64String.startsWith('data:image/')) {\r\n                    base64String = 'data:image/png;base64,' + base64String;\r\n                }\r\n                tileImg.src = base64String;\r\n            });\r\n        } catch (error) {\r\n            console.error('Error parsing stored base64 tiles:', error);\r\n        }\r\n    }\r\n\r\n    // Method to clean up event listeners if needed\r\n    destroy() {\r\n        document.body.removeEventListener('editTerrainImage', this.displayStoredBase64Tiles);\r\n    }\r\n}"
      },
      "TileMap": {
        "fileName": "TileMap",
        "script": "\r\n  \r\n  \r\nclass TileMap {\r\n\r\n  constructor(app, config, { CanvasUtility }) {\r\n   \tthis.app = app;\r\n    this.config = config;\r\n    this.engineClasses = {\r\n \t\t\t\"CanvasUtility\": CanvasUtility\r\n    } \r\n  }\r\n\tinit(canvas, tileSize, layerSpriteSheets, isometric) {\r\n\t\tthis.isometric = isometric;\r\n\t\tthis.canvas = canvas;\r\n\t\tthis.tileSize = tileSize;\r\n\t\tthis.numColumns = 0;\r\n\t\tthis.layerSpriteSheets = layerSpriteSheets;\r\n\t\tthis.tileMap = [];\r\n\t\tthis.layerTextures = [];\r\n\t\tthis.canvasUtility = new (this.engineClasses.CanvasUtility)();\r\n\t\tthis.TileAnalysis = class {\r\n\t\t\tconstructor() {\r\n\t\t\t  this.heightIndex = 0;\r\n\t\t\t  this.neighborLowerCount = 0;\r\n\t\t\t  this.cornerLowerCount = 0;\r\n\t\t\t  this.topLess = false;\r\n\t\t\t  this.leftLess = false;\r\n\t\t\t  this.rightLess = false;\r\n\t\t\t  this.botLess = false;\r\n\t\t\t  this.cornerTopLeftLess = false;\r\n\t\t\t  this.cornerTopRightLess = false;\r\n\t\t\t  this.cornerBottomLeftLess = false;\r\n\t\t\t  this.cornerBottomRightLess = false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.TileTransforms = {\r\n\t\t\tNone: 0,\r\n\t\t\tClockWise90: 1,\r\n\t\t\tCounterClockWise90: 2,\r\n\t\t\tRotate180: 3,\r\n\t\t\tFlipHorizontal: 4,\r\n\t\t\tFlipVertical: 5,\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileAtom = {\r\n\t\t\tFull: 0,\r\n\t\t\tOneCorner: 1,\r\n\t\t\tTwoCorner: 2,\r\n\t\t\tThreeCorner: 3,\r\n\t\t\tFullVariation: 4,\r\n\t\t\tOneCornerBot: 5,\r\n\t\t\tTwoCornerBot: 6,\r\n\t\t\tThreeCornerBot: 7\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileMolecule = {\r\n\t\t\tFull: 0,\r\n\t\t\tCorner: 1,\r\n\t\t\tEdge: 2,\r\n\t\t\tTunnel: 3,\r\n\t\t\tTwoSides: 4,\r\n\t\t\tPenninsula: 5,\r\n\t\t\tIsland: 6,\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileCliffMolecules = {\r\n\t\t\tFull: 0,\r\n\t\t\tCornerTL: 1,\r\n\t\t\tCornerTR: 2,\r\n\t\t\tCornerBL: 3,\r\n\t\t\tCornerBR: 4,\r\n\t\t\tEdgeT: 5,\r\n\t\t\tEdgeL: 6,\r\n\t\t\tEdgeR: 7,\r\n\t\t\tEdgeB: 8,\r\n\t\t\tTunnelH: 9,\r\n\t\t\tTunnelV: 10,\r\n\t\t\tTwoSidesTL: 11,\r\n\t\t\tTwoSidesTR: 12,\r\n\t\t\tTwoSidesBL: 13,\r\n\t\t\tTwoSidesBR: 14,    \r\n\t\t\tPenninsulaT: 15,\r\n\t\t\tPenninsulaL: 16,\r\n\t\t\tPenninsulaR: 17,\r\n\t\t\tPenninsulaB: 18,\r\n\t\t\tIsland: 19,\r\n\t\t};\r\n\t}\r\n\r\n    draw(map){\r\n\t\tthis.tileMap = map;\r\n\t\tthis.numColumns = this.tileMap.length;\r\n\t\t// Load all textures\r\n\r\n\t\tif(this.layerTextures.length == 0) {\r\n\t\r\n\t\t\tthis.layerSpriteSheets.forEach((layerSprites, index) => {      \r\n\t\t\t\tconst moleculeData = this.buildBaseMolecules(layerSprites.sprites);\r\n\t\t\t\tthis.layerTextures[index] = moleculeData;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet analyzedMap = this.analyzeMap(this.tileMap);\r\n\t\tthis.drawMap(analyzedMap);\r\n        if(this.isometric){\r\n            this.drawIsometric();\r\n        }\r\n\r\n    }\r\n\r\n    drawIsometric() {\r\n        let ctx = this.canvas.getContext('2d');\r\n        // Save the original state\r\n        ctx.save();\r\n        \r\n        // Create an off-screen canvas to hold original drawing\r\n        const offscreen = document.createElement('canvas');\r\n        offscreen.width = this.canvas.width;\r\n        offscreen.height = this.canvas.height;\r\n        const offCtx = offscreen.getContext('2d');\r\n        offCtx.drawImage(this.canvas, 0, 0);\r\n        \r\n        // Clear the main canvas\r\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Move to center for rotation\r\n        ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n        \r\n        // Apply isometric transformation\r\n        const scale = .56;    // Adjust overall size\r\n        const isoAngle = Math.atan(1 / 2); // ≈ 26.565° (classic isometric angle)\r\n        const cosA = Math.cos(isoAngle);   // ≈ 0.8944\r\n        const sinA = Math.sin(isoAngle);   // ≈ 0.4472\r\n        \r\n        ctx.transform(\r\n            cosA * scale,    // scaleX\r\n            sinA * scale,    // skewY\r\n            -cosA * scale,   // skewX\r\n            sinA * scale,    // scaleY\r\n            0,               // translateX\r\n            0                // translateY\r\n        );\r\n        \r\n        // Draw the transformed image centered\r\n        ctx.drawImage(offscreen, -this.canvas.width / 2, -this.canvas.height / 2);\r\n        \r\n        // Restore original state\r\n        ctx.restore();\r\n    }\r\n\r\n    drawTexture(texture, x, y) {\r\n\t\tctx.drawImage(texture, x, y, this.tileSize / 2, this.tileSize / 2); // Assuming each atom is 256x256\r\n    }\r\n\r\n    // Function to generate a molecule texture for various molecule ty\r\n\tbuildBaseMolecules(sprites) {\r\n\t\t// Define texture objects\r\n\t\tconst fullTexture = document.createElement(\"canvas\");\r\n\r\n\t\tconst oneCornerTexture = document.createElement(\"canvas\");\r\n\t\tconst twoCornerTexture = document.createElement(\"canvas\");\r\n\t\tconst threeCornerTexture = document.createElement(\"canvas\");\r\n\r\n\t\tconst oneCornerBotTexture = document.createElement(\"canvas\");\r\n\t\tconst twoCornerBotTexture = document.createElement(\"canvas\");\r\n\t\tconst threeCornerBotTexture = document.createElement(\"canvas\");\r\n\r\n\t\tfullTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\toneCornerTexture.setAttribute('willReadFrequently', true); \r\n\t\ttwoCornerTexture.setAttribute('willReadFrequently', true); \r\n\t\tthreeCornerTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\toneCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\t\ttwoCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\t\tthreeCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\t// Set the texture sizes\r\n\t\tconst spriteResolution = this.tileSize / 2;\r\n\t\tconst finalTileBaseResolution = spriteResolution * 2;\r\n\r\n\t\tfullTexture.width = spriteResolution;\r\n\t\tfullTexture.height = spriteResolution;\r\n\r\n\t\toneCornerTexture.width = spriteResolution;\r\n\t\toneCornerTexture.height = spriteResolution;\r\n\r\n\t\ttwoCornerTexture.width = spriteResolution;\r\n\t\ttwoCornerTexture.height = spriteResolution;\r\n\r\n\t\tthreeCornerTexture.width = spriteResolution;\r\n\t\tthreeCornerTexture.height = spriteResolution;\t\r\n\r\n\t\toneCornerBotTexture.width = spriteResolution;\r\n\t\toneCornerBotTexture.height = spriteResolution;\t\r\n\r\n\t\ttwoCornerBotTexture.width = spriteResolution;\r\n\t\ttwoCornerBotTexture.height = spriteResolution;\t\r\n\r\n\t\tthreeCornerBotTexture.width = spriteResolution;\r\n\t\tthreeCornerBotTexture.height = spriteResolution;\t\r\n\t\t\r\n\t\t// Get sprite textures\r\n\t\tconst fullSprite = sprites[this.TileAtom.Full];\r\n\r\n\t\tconst oneCornerSprite = sprites[this.TileAtom.OneCorner];\r\n\t\tconst twoCornerSprite = sprites[this.TileAtom.TwoCorner];\r\n\t\tconst threeCornerSprite = sprites[this.TileAtom.ThreeCorner];\r\n\r\n\t\tconst oneCornerBotSprite = sprites[this.TileAtom.OneCornerBot];\r\n\t\tconst twoCornerBotSprite = sprites[this.TileAtom.TwoCornerBot];\r\n\t\tconst threeCornerBotSprite = sprites[this.TileAtom.ThreeCornerBot];\r\n\r\n\t\t// Create CanvasRenderingContext2D objects for each texture\r\n\t\tconst fullCtx = fullTexture.getContext(\"2d\");\r\n\r\n\t\tconst oneCornerCtx = oneCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst twoCornerCtx = twoCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst threeCornerCtx = threeCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\r\n\t\tconst oneCornerBotCtx = oneCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst twoCornerBotCtx = twoCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst threeCornerBotCtx = threeCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\t\r\n\t\t// Copy pixels from sprites to texture canvases\r\n\t\tfullCtx.drawImage(fullSprite,0,0);\r\n\r\n\t\toneCornerCtx.drawImage(oneCornerSprite,0,0);\r\n\t\ttwoCornerCtx.drawImage(twoCornerSprite,0,0);\r\n\t\tthreeCornerCtx.drawImage(threeCornerSprite,0,0);\r\n\r\n\t\toneCornerBotCtx.drawImage(oneCornerBotSprite,0,0);\r\n\t\ttwoCornerBotCtx.drawImage(twoCornerBotSprite,0,0);\r\n\t\tthreeCornerBotCtx.drawImage(threeCornerBotSprite,0,0);\r\n\r\n\t\t// Get pixel data from the canvases\r\n\t\tconst fullImageData = fullCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerTopRightImageData = oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerTopLeftImageData = this.flipTextureHorizontal(oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));\t\r\n\r\n\t\tconst oneCornerBotRightImageData = oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerBotLeftImageData = this.flipTextureHorizontal(oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));\t\r\n\t\t\r\n\t\tconst twoCornerTopImageData = twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst twoCornerLeftImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), -Math.PI / 2);\r\n\t\tconst twoCornerRightImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), Math.PI / 2);\r\n\t\tconst twoCornerBottomImageData = twoCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\t\r\n\t\tconst threeCornerTopRightImageData = threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst threeCornerTopLeftImageData = this.flipTextureHorizontal(threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));\t\t\r\n\t\tconst threeCornerBottomRightImageData = threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst threeCornerBottomLeftImageData = this.flipTextureHorizontal(threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t// Define molecule objects\r\n\t\tconst moleculeCanvas = document.createElement(\"canvas\");\r\n\r\n\t\tmoleculeCanvas.width = finalTileBaseResolution;\r\n\t\tmoleculeCanvas.height = finalTileBaseResolution;\r\n\t\t\r\n\t\tconst moleculeCtx = moleculeCanvas.getContext('2d', { willReadFrequently: true });\r\n\r\n\t\tconst cornerCanvas = document.createElement(\"canvas\");\r\n\r\n\t\tcornerCanvas.width = finalTileBaseResolution / 2;\r\n\t\tcornerCanvas.height = finalTileBaseResolution / 2;\r\n\t\t\r\n\t\tconst cornerCtx = cornerCanvas.getContext('2d', { willReadFrequently: true });\r\n\r\n\t\tvar imageDataList = [\r\n\t\t\t//FULL\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, fullImageData, fullImageData, fullImageData),\r\n\r\n\t\t\t//CORNERS\r\n\t\t\toneCornerTopLeftImageData, \r\n\t\t\toneCornerTopRightImageData,\r\n\t\t\toneCornerBotLeftImageData,\r\n\t\t\toneCornerBotRightImageData,\r\n\t\t\t//EDGES\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, fullImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, twoCornerLeftImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, fullImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, fullImageData, twoCornerBottomImageData, twoCornerBottomImageData),\r\n\r\n\t\t\t//TUNNELS\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, twoCornerBottomImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, twoCornerLeftImageData, twoCornerRightImageData),\r\n\r\n\t\t\t//TWO SIDES\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, twoCornerLeftImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, fullImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),\r\n\r\n\t\t\t//PENNINSULAS\t\t\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, twoCornerLeftImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),\r\n\r\n\t\t\t//ISLAND\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),\r\n\t\t];\r\n\r\n\t\treturn imageDataList;\r\n\t}\r\n\r\n\tcreateMolecule(context, TLImageData, TRImageData, BLImageData, BRImageData) {\r\n\t\tlet size = context.canvas.width;\r\n\t\tlet spriteResolution = size / 2;\r\n\t\tcontext.fillStyle = 'black';\r\n\t\tcontext.fillRect(0, 0, size, size);\r\n\t\tcontext.putImageData(TLImageData, 0, 0);\r\n\t\tcontext.putImageData(TRImageData, spriteResolution, 0);\r\n\t\tcontext.putImageData(BLImageData, 0, spriteResolution);\r\n\t\tcontext.putImageData(BRImageData, spriteResolution, spriteResolution);\r\n\t\treturn context.getImageData(0, 0, size, size);\r\n\t}\r\n\r\n\textractSpritesFromSheet(spriteSheet, columns, rows) {\r\n\t\tlet sprites = [];\r\n\t\tlet spriteWidth = spriteSheet.width / columns;\r\n\t\tlet spriteHeight = spriteSheet.height / rows;\r\n\t\r\n\t\tfor (let y = 0; y < rows; y++) {\r\n\t\t\tfor (let x = 0; x < columns; x++) {\r\n\t\t\t\tlet canvas = document.createElement('canvas');\r\n\t\t\t\tcanvas.width = spriteWidth;\r\n\t\t\t\tcanvas.height = spriteHeight;\r\n\t\t\t\tlet context = canvas.getContext('2d');\r\n\t\t\t\tcontext.drawImage(spriteSheet, x * spriteWidth, y * spriteHeight, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);\r\n\t\t\t\tsprites.push(canvas);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\treturn sprites;\r\n\t}\r\n\t\r\n\tgetSpriteRotations(imageDataList) {\r\n\t\tlet rotationDict = {};\r\n\r\n\t\tlet requiredTransforms = {};\r\n\r\n\t\trequiredTransforms[this.TileMolecule.Full] = [];\r\n\t\trequiredTransforms[this.TileMolecule.Corner] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Edge] = [this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Tunnel] = [this.TileTransforms.CounterClockWise90];\r\n\t\trequiredTransforms[this.TileMolecule.TwoSides] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Penninsula] = [this.TileTransforms.FlipVertical, this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90];\r\n\t\trequiredTransforms[this.TileMolecule.Island] = [];\r\n\r\n\t\tObject.keys(imageDataList).forEach(moleculeType => {\r\n\t\t\tlet rotations = {};\r\n\t\t\tlet colors = imageDataList[moleculeType];\r\n\t\t\trotations[this.TileTransforms.None] = colors;\r\n\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.ClockWise90)) {\r\n\t\t\t\trotations[this.TileTransforms.ClockWise90] = this.rotateTexture(colors, Math.PI / 2);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.CounterClockWise90)) {\r\n\t\t\t\trotations[this.TileTransforms.CounterClockWise90] = this.rotateTexture(colors, -Math.PI / 2);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.Rotate180)) {\r\n\t\t\t\trotations[this.TileTransforms.Rotate180] = this.rotateTexture(colors, Math.PI);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipHorizontal)) {\r\n\t\t\t\trotations[this.TileTransforms.FlipHorizontal] = this.flipTextureHorizontal(colors);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipVertical)) {\r\n\t\t\t\trotations[this.TileTransforms.FlipVertical] = this.flipTextureVertical(colors);\r\n\t\t\t}\r\n\r\n\t\t\trotationDict[moleculeType] = rotations;\r\n\t\t});\r\n\r\n\t\treturn rotationDict;\r\n\t}\r\n\r\n\trotateTexture(imageData, angle) {\r\n\t\treturn this.canvasUtility.rotateTexture(imageData, angle);\r\n\t}\r\n\r\n\tflipTextureVertical(imageData) {\r\n\t\treturn this.canvasUtility.flipTextureVertical(imageData);\r\n\t}\r\n\r\n\tflipTextureHorizontal(imageData) {\r\n\t\treturn this.canvasUtility.flipTextureHorizontal(imageData);\r\n\t}\r\n\r\n\tanalyzeTile(x, y) {\r\n\t\tlet tileAnalysis = new this.TileAnalysis();\r\n\t\tlet row = y;\r\n\t\tlet col = x;\r\n\r\n\t\tif (row < 0 || row >= this.numColumns || col < 0 || col >= this.numColumns) {\r\n\t\t\treturn tileAnalysis; // Out of bounds\r\n\t\t}\r\n\r\n\t\ttileAnalysis.heightIndex = this.tileMap[row][col];\r\n\r\n\t\t// Helper function to check if a location is within bounds\r\n\t\tfunction isWithinBounds(r, c, n) {\r\n\t\t\treturn r >= 0 && r < n && c >= 0 && c < n;\r\n\t\t}\r\n\r\n\t\t// Helper function to check and update tile analysis\r\n\t\tvar checkAndUpdate = ((r, c, n, direction, propertyLess) => {\r\n\t\t\tif (isWithinBounds(r, c, n) ) {\r\n\t\t\t\ttileAnalysis[direction] = this.tileMap[r][c];\r\n\t\t\t\tif( this.tileMap[r][c] < tileAnalysis.heightIndex) {\r\n\t\t\t\t\ttileAnalysis[propertyLess] = true;\r\n\t\t\t\t\tif(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0 ) {\r\n\t\t\t\t\t\ttileAnalysis.neighborLowerCount++;\r\n\t\t\t\t\t} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {\r\n\t\t\t\t\t\ttileAnalysis.cornerLowerCount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tcheckAndUpdate(row - 1, col, this.numColumns, 'topHeight', 'topLess');\r\n\t\tcheckAndUpdate(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');\r\n\t\tcheckAndUpdate(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');\r\n\t\tcheckAndUpdate(row + 1, col, this.numColumns, 'botHeight', 'botLess');\r\n\t\tcheckAndUpdate(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');\r\n\t\tcheckAndUpdate(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');\r\n\t\tcheckAndUpdate(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');\r\n\t\tcheckAndUpdate(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');\r\n\r\n\t\treturn tileAnalysis;\r\n\t}\r\n\r\n\t// Function to generate a random integer between min and max (inclusive)\r\n\tgetRandomInt(min, max) {\r\n\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\r\n\t}\r\n\r\n\t// Function to generate a random 10x10 map\r\n\tgenerateRandomMap(rows, columns) {\r\n\t\tlet map = [];\r\n\t\tfor (let i = 0; i < rows; i++) {\r\n\t\t\tlet row = [];\r\n\t\t\tfor (let j = 0; j < columns; j++) {\r\n\t\t\t\trow.push(getRandomInt(0, layers.length - 1)); // Random height between 0 and 10\r\n\t\t\t}\r\n\t\t\tmap.push(row);\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\tanalyzeMap() {\r\n\t\tlet analyzedTiles = [];\r\n\r\n\t\tfor (let i = 0; i < this.numColumns; i++) {\r\n\t\t\tfor (let j = 0; j < this.numColumns; j++) {\r\n\t\t\t\tanalyzedTiles.push(this.analyzeTile(j, i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn analyzedTiles;\r\n\t}\r\n\r\n\tgetTransformedTexture(transformationDict, tileAnalysis, molecule){\r\n\t\tswitch(tileAnalysis.neighborLowerCount){\t\t\t\t\r\n\t\t\tcase 1:\r\n\t\t\t\tif(tileAnalysis.leftLess){                    \r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t} else if(tileAnalysis.rightLess){\r\n                    return transformationDict[molecule][this.TileTransforms.ClockWise90];\r\n\t\t\t\t} else if(tileAnalysis.botLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.Rotate180];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(tileAnalysis.topLess && tileAnalysis.leftLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipHorizontal];\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.leftLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.Rotate180];\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.rightLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipVertical];\r\n\t\t\t\t} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tif(!tileAnalysis.topLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipVertical];\r\n\t\t\t\t} else if(!tileAnalysis.leftLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.ClockWise90];\r\n\t\t\t\t} else if(!tileAnalysis.rightLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\t\t\r\n        return transformationDict[molecule][this.TileTransforms.None];\r\n\t}\r\n\r\n\tgetMoleculeByTileAnalysis(tileAnalysis){\r\n\t\tvar molecule = this.TileCliffMolecules.Full;\t\t\t\t\t\t\t\t\r\n\t\tswitch(tileAnalysis.neighborLowerCount){\r\n\t\t\tcase 0: \r\n\t\t\t\tmolecule = this.TileCliffMolecules.Full;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tif(tileAnalysis.topLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeT;\r\n\t\t\t\t} else if(tileAnalysis.leftLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeL;\r\n\t\t\t\t} else if(tileAnalysis.rightLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeR;\r\n\t\t\t\t} else if(tileAnalysis.botLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeB;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(tileAnalysis.topLess && tileAnalysis.botLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TunnelH;\r\n\t\t\t\t} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TunnelV;\r\n\t\t\t\t} else if(tileAnalysis.topLess && tileAnalysis.leftLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesTL;\r\n\t\t\t\t} else if(tileAnalysis.topLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesTR;\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.leftLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesBL;\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesBR;\r\n\t\t\t\t} \r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tif( !tileAnalysis.topLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaB;\r\n\t\t\t\t} else if( !tileAnalysis.leftLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaR;\r\n\t\t\t\t} else if( !tileAnalysis.rightLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaL;\r\n\t\t\t\t} else if( !tileAnalysis.botLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaT;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\tcase 4:\r\n\t\t\t\tmolecule = this.TileCliffMolecules.Island;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn molecule;\r\n\t}\r\n\r\n\tcolorImageData(imageData, tileAnalysis) {\r\n\t\t\r\n\t\tconst data = new Uint8ClampedArray(imageData.data);\r\n\t\tvar directions = ['topHeight', 'leftHeight', 'rightHeight', 'botHeight', 'topLeftHeight', 'topRightHeight', 'botLeftHeight', 'botRightHeight'];\r\n\t\tlet heightCounts = {};\r\n\t\tdirections.forEach((direction) => {\r\n\t\t\tlet height = tileAnalysis[direction];\r\n\t\t\tif (height !== tileAnalysis.heightIndex) {\r\n\t\t\t\tif (!heightCounts[height]) {\r\n\t\t\t\t\theightCounts[height] = 0;\r\n\t\t\t\t}\r\n\t\t\t\theightCounts[height]++;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\tlet lowerNeighborHeight = Math.max(0, tileAnalysis.heightIndex - 1);\r\n\t\tlet maxCount = 0;\r\n\t\tObject.keys(heightCounts).forEach((height) => {\r\n\t\t\tif (heightCounts[height] > maxCount && height < tileAnalysis.heightIndex) {\r\n\t\t\t\tlowerNeighborHeight = parseInt(height);\r\n\t\t\t\tmaxCount = heightCounts[height];\r\n\t\t\t}\r\n\t\t});\r\n\t\tconst numPixels = this.tileSize * this.tileSize;\r\n\t\tif(lowerNeighborHeight < 0){\r\n\t\t\tconst blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)\r\n\t\t\tblackData.fill(0); // Fill with black (0, 0, 0, 255)\r\n\t\t\treturn new ImageData(blackData, this.tileSize, this.tileSize);\r\n\t\t}\r\n\t\tlet baseColors = this.layerTextures[tileAnalysis.heightIndex][this.TileMolecule.Full].data;\r\n\t\tlet neighborColors = this.layerTextures[lowerNeighborHeight][this.TileMolecule.Full].data;\r\n\r\n\t\t// Iterate over each pixel\r\n\t\tfor (let i = 0; i < numPixels; i++) {\r\n\t\t\tconst dataIndex = i * 4;\r\n\t\t\tlet pColor = { r: data[dataIndex], g: data[dataIndex + 1], b: data[dataIndex + 2], a: data[dataIndex + 3] };\r\n\t\t\tlet bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };\r\n\t\t\tlet tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };\r\n\t\r\n\t\t\tif (this.layerTextures.length > tileAnalysis.heightIndex) {\r\n\t\t\t\tif (baseColors.length > i) {\r\n\t\t\t\t\tbColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (lowerNeighborHeight >= 0) {\r\n\t\t\t\tif (neighborColors.length > i) {\r\n\t\t\t\t\ttColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet fColor = pColor;\r\n\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 0 })) fColor = pColor;\r\n\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) fColor = bColor;\r\n\r\n\t\t\tdata.set([fColor.r, fColor.g, fColor.b, fColor.a], dataIndex);\r\n\t\t}\r\n\t\treturn new ImageData(data, this.tileSize, this.tileSize);\r\n\t}\r\n\r\n\tisEqualColor(color1, color2) {\r\n\t\treturn color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && color1.a === color2.a;\r\n\t}\r\n\r\n\taddCornerGraphics(imageData, tileAnalysis) {\r\n\t\tlet cornerSize = this.tileSize / 2;\r\n\t\tlet cornerTexture;\r\n\t\tlet heightIndex = tileAnalysis.heightIndex;\r\n\t\r\n\t\tif (tileAnalysis.cornerLowerCount > 0) {\r\n\t\t\tif (tileAnalysis.cornerTopLeftLess && (!tileAnalysis.topLess && !tileAnalysis.leftLess)) {\t\t\t\t\r\n\t\t\t\tcornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerTL];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, 0, 0, cornerTexture, tileAnalysis);\t\t\t\r\n\t\t\t}\r\n\t\t\t// Assuming tileAnalysis, textureDict, and other variables are already defined\r\n\t\t\tif (tileAnalysis.cornerTopRightLess && (!tileAnalysis.topLess && !tileAnalysis.rightLess)) {\t\t\t\t\r\n\t\t\t\tcornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerTR];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, cornerSize, 0, cornerTexture, tileAnalysis);\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif (tileAnalysis.cornerBottomLeftLess && (!tileAnalysis.botLess && !tileAnalysis.leftLess)) {\t\t\t\t\r\n\t\t\t\tcornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerBL];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, 0, cornerSize, cornerTexture, tileAnalysis);\t\t\t\r\n\t\t\t}\r\n\r\n\t\t\tif (tileAnalysis.cornerBottomRightLess && (!tileAnalysis.botLess && !tileAnalysis.rightLess)) {\t\t\t\r\n\t\t\t\tcornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerBR];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, cornerSize, cornerSize, cornerTexture, tileAnalysis);\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn imageData;\r\n\t}\r\n\t\r\n\tcolorCornerTextureRoutine(outputImageData, x, y, cornerImageData, tileAnalysis) {\r\n\t\tlet cornerSize = this.tileSize / 2;\t\r\n\t\tlet baseHeightIndex = tileAnalysis.heightIndex;\r\n\t\tlet baseColors = this.layerTextures[baseHeightIndex][this.TileMolecule.Full];\r\n\t\tconst data = new Uint8ClampedArray(outputImageData.data);\r\n\t\tfor (let j = 0; j < cornerSize; j++) {\r\n\t\t\tfor (let i = 0; i < cornerSize; i++) {\r\n\t\t\t\t// Calculate the correct position in the output image data\r\n\t\t\t\tlet outputIndex = ((y + j) * this.tileSize + (x + i)) * 4;\r\n\t\r\n\t\t\t\tlet baseColor = this.getColorFromImageData(baseColors, outputIndex);\r\n\t\t\r\n\t\t\t\tlet sourceOriginX = i;\r\n\t\t\t\tlet sourceOriginY = j * cornerSize;\r\n\t\t\t\tlet sourcePixel = (sourceOriginY + sourceOriginX) * 4;\r\n\t\t\t\tlet pColor = this.getColorFromImageData(cornerImageData, sourcePixel);\r\n\t\t\t\tlet fColor = pColor;\r\n\t\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) {\r\n\t\t\t\t\tfColor = baseColor;\t\t\t\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdata[outputIndex] = fColor.r;\r\n\t\t\t\tdata[outputIndex + 1] = fColor.g;\r\n\t\t\t\tdata[outputIndex + 2] = fColor.b;\r\n\t\t\t\tdata[outputIndex + 3] = fColor.a;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new ImageData(data, this.tileSize, this.tileSize);\r\n\t}\r\n\t\r\n\tgetColorFromImageData(imageData, index) {\r\n\t\treturn {\r\n\t\t\tr: imageData.data[index],\r\n\t\t\tg: imageData.data[index + 1],\r\n\t\t\tb: imageData.data[index + 2],\r\n\t\t\ta: imageData.data[index + 3]\r\n\t\t};\r\n\t}\t\r\n\t\r\n\taddVariationImage(imageData, tileAnalysis) {\r\n\t\tconst img = this.layerSpriteSheets[tileAnalysis.heightIndex];\r\n\t\r\n\t\tif (img && Math.random() < .25) {\r\n\t\t\tthis.canvasUtility.setSize(imageData.width, imageData.height);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// Paint the existing imageData onto the canvas\r\n\t\t\tthis.canvasUtility.paintTexture(imageData);\r\n\t\r\n\t\t\t// Assuming img is a loaded Image object and you want to draw it at (0,0)\r\n\t\t\t// Draw the img over the imageData\r\n\t\t\tthis.canvasUtility.ctx.drawImage(img, (imageData.width / 2) - img.width / 2,  (imageData.width / 2) - img.width / 2);\r\n\t\r\n\t\t\t// Get the updated imageData from the canvas\r\n\t\t\treturn this.canvasUtility.ctx.getImageData(0, 0, imageData.width, imageData.height);\r\n\t\t} else {\r\n\t\t\t// If img is not available, return the original imageData\r\n\t\t\treturn imageData;\r\n\t\t}\r\n\t}\r\n\t\r\n\tdrawMap(analyzedMap) {\r\n\t\tconst ctx = this.canvas.getContext('2d');\r\n\t\tconst layerCanvases = {};\r\n\t\r\n\t\tfor (let layerIndex = 0; layerIndex < this.layerTextures.length; layerIndex++) {\r\n\t\t\tconst offscreenCanvas = document.createElement('canvas');\r\n\t\t\toffscreenCanvas.width = this.canvas.width;\r\n\t\t\toffscreenCanvas.height = this.canvas.height;\r\n\t\t\tlayerCanvases[layerIndex] = offscreenCanvas;\r\n\t\t\tconst offscreenCtx = offscreenCanvas.getContext('2d');\r\n\t\r\n\t\t\tanalyzedMap.forEach((tileAnalysis, index) => {\r\n\t\t\t\tconst x = (index % this.numColumns) * this.tileSize;\r\n\t\t\t\tconst y = Math.floor(index / this.numColumns) * this.tileSize;\r\n\t\r\n\t\t\t\tlet imageData;\r\n\t\t\t\tlet _tileAnalysis = {...tileAnalysis };\r\n\t\t\t\tif (_tileAnalysis.heightIndex > layerIndex) {\r\n\t\t\t\t\t// Use base image data for higher layers\r\n\t\t\t\t\t_tileAnalysis.heightIndex = layerIndex;\r\n\t\t\t\t\tif(_tileAnalysis.topLess && _tileAnalysis.topHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.topLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.neighborLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.leftLess && _tileAnalysis.leftHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.leftLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.neighborLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.rightLess && _tileAnalysis.rightHeight >= _tileAnalysis.heightIndex){\r\n\t\t\t\t\t\t_tileAnalysis.rightLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.neighborLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.botLess && _tileAnalysis.botHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.botLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.neighborLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.cornerTopLeftLess && _tileAnalysis.topLeftHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.cornerTopLeftLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.cornerLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.cornerTopRightLess && _tileAnalysis.topRightHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.cornerTopRightLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.cornerLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.cornerBottomLeftLess && _tileAnalysis.botLeftHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.cornerBottomLeftLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.cornerLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(_tileAnalysis.cornerBottomRightLess && _tileAnalysis.botRightHeight >= _tileAnalysis.heightIndex) {\r\n\t\t\t\t\t\t_tileAnalysis.cornerBottomRightLess = false;\r\n\t\t\t\t\t\t_tileAnalysis.cornerLowerCount--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} \r\n\t\t\t\tif (_tileAnalysis.heightIndex < layerIndex) {\r\n\t\t\t\t\t// Use base image data for higher layers\r\n\t\t\t\t\tlet numPixels = this.tileSize * this.tileSize;\r\n\t\t\t\t\tconst transparentData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (let i = 0; i < numPixels * 4; i += 4) {\r\n\t\t\t\t\t\ttransparentData[i] = 0;     // Red (not important for transparency)\r\n\t\t\t\t\t\ttransparentData[i + 1] = 0; // Green (not important for transparency)\r\n\t\t\t\t\t\ttransparentData[i + 2] = 0; // Blue (not important for transparency)\r\n\t\t\t\t\t\ttransparentData[i + 3] = 0; // Alpha (0 for full transparency)\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\timageData = new ImageData(transparentData, this.tileSize, this.tileSize);\r\n\t\t\t\t\t\r\n\t\t\t\t } else {\r\n\t\t\t\t\timageData = new ImageData(new Uint8ClampedArray(4), 1, 1);\r\n\t\t\t\t\tif( _tileAnalysis.heightIndex >= 0 ) {\r\n\t\t\t\t\t\tlet molecule = this.getMoleculeByTileAnalysis(_tileAnalysis);\t\t\t\t\t\t\r\n\t\t\t\t\t\timageData = this.layerTextures[_tileAnalysis.heightIndex][molecule];//this.getTransformedTexture(this.layerTextures[_tileAnalysis.heightIndex], _tileAnalysis, molecule);\t\t\t\r\n\t\t\t\t\t\timageData = this.colorImageData(imageData, _tileAnalysis);\r\n\t\t\t\t\t\t//imageData = this.addVariationImage(imageData, _tileAnalysis);\r\n\t\t\t\t\t\timageData = this.addCornerGraphics(imageData, _tileAnalysis);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tlet numPixels = this.tileSize * this.tileSize;\r\n\t\t\t\t\t\tconst blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)\r\n\t\t\t\t\t\tblackData.fill(0); // Fill with black (0, 0, 0, 255)\r\n\t\t\t\t\t\timageData = new ImageData(blackData, this.tileSize, this.tileSize);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffscreenCtx.putImageData(imageData, x, y);\r\n\t\t\t});\r\n\t\t}\r\n\t\r\n\t\t// Drawing each layer canvas onto the main canvas\r\n\t\tObject.keys(layerCanvases).forEach(layerIndex => {\r\n\t\t\t//if( layerIndex == 0 || layerIndex == 1 || layerIndex == 2) {\r\n\t\t\tctx.drawImage(layerCanvases[layerIndex], 0, 0);\r\n\t\t//}\r\n\t\t});\r\n\t}\r\n  }"
      },
      "Entity": {
        "fileName": "Entity",
        "script": "class Entity {\r\n    constructor(game, type) {\r\n        this.game = game;\r\n        this.moduleManager = game.moduleManager;        \r\n        this.components = [];\r\n        this.renderers = [];\r\n        this.destroyed = false;        \r\n        this.id = ++game.entityId;\r\n        this.type = type;\r\n        this.collisionRadius = 5;   \r\n        this.entityHeight = 10;        \r\n    }\r\n    getAABB(position = this.transform.position) {\r\n        return {\r\n            min: {\r\n                x: position.x - this.collisionRadius,\r\n                y: position.y,\r\n                z: position.z - this.collisionRadius\r\n            },\r\n            max: {\r\n                x: position.x + this.collisionRadius,\r\n                y: position.y + this.entityHeight,\r\n                z: position.z + this.collisionRadius\r\n            }\r\n        };\r\n    }\r\n\r\n    getComponent(name) {\r\n        return this.components[name.toLowerCase()] || this.components[`${name.toLowerCase()}`];\r\n    }\r\n    addRenderer(RendererClassName, params) {\r\n        const RendererClass = this.moduleManager.getCompiledScript(RendererClassName, 'renderers');\r\n        const renderer = new RendererClass(this.game, this, params);\r\n        this.renderers[RendererClass.name.toLowerCase()] = renderer;\r\n        this.components[RendererClass.name.toLowerCase()] = renderer;\r\n        return renderer;\r\n    }\r\n    addComponent(ComponentClassName, params) {        \r\n        const ComponentClass = this.moduleManager.getCompiledScript(ComponentClassName, 'components');\r\n        const component = new ComponentClass(this.game, this, params);\r\n        this.components[ComponentClass.name.toLowerCase()] = component;\r\n        return component;\r\n    }\r\n    removeComponent(component) {\r\n        let index = this.components.indexOf(component);\r\n        if( index >= 0 ) {\r\n            this.components.splice(index, 1);\r\n        }\r\n    }\r\n    update() {    \r\n        for(let c in this.components) {\r\n            this.components[c].update(); \r\n            if(this.destroyed) break;\r\n        }                \r\n    }\r\n    postUpdate() {\r\n        for(let c in this.components) {\r\n            this.components[c].postUpdate();   \r\n            if(this.destroyed) break;\r\n        }     \r\n    }\r\n    draw() {\r\n        for(let r in this.renderers) {\r\n            this.renderers[r].draw();  \r\n        }\r\n\r\n    }\r\n    OnCollision(collidedWith){\r\n        for(let c in this.components) {\r\n            this.components[c].OnCollision(collidedWith);                           \r\n        }                \r\n    }\r\n    OnStaticCollision(){\r\n        for(let c in this.components) {\r\n            this.components[c].OnStaticCollision();                           \r\n        }                \r\n    }\r\n    OnGrounded(){\r\n        for(let c in this.components) {\r\n            this.components[c].OnGrounded();                           \r\n        }                \r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        for(let c in this.components) {\r\n            this.components[c].destroy();   \r\n        }   \r\n        for(let r in this.renderers) {\r\n            this.renderers[r].destroy();   \r\n        }   \r\n    }\r\n}"
      },
      "Component": {
        "fileName": "Component",
        "script": "class Component {\r\n    constructor(game, parent, params) { \r\n        this.game = game;\r\n        this.parent = parent;\r\n        this.init(params);\r\n    }\r\n    init(params) {}\r\n    getComponent(type) {\r\n        return this.parent.getComponent(type);\r\n    }\r\n    update() {}\r\n    postUpdate() {}\r\n    destroy() {}\r\n    \r\n    OnCollision(collidedWith){}\r\n    OnStaticCollision(){}\r\n    OnGrounded(){}\r\n}"
      },
      "GameState": {
        "fileName": "GameState",
        "script": "class GameState {\r\n    constructor(gameConfig = {}) {\r\n        let state = gameConfig.configs.state;\r\n     \r\n        // Clear all existing properties\r\n        for (let prop in this) {\r\n            if (Object.prototype.hasOwnProperty.call(this, prop)) {\r\n                delete this[prop];\r\n            }\r\n        }\r\n\r\n        // Set only the properties from params\r\n        for (let key in state) {\r\n            if (Object.prototype.hasOwnProperty.call(state, key)) {\r\n                this[key] = state[key];\r\n            }\r\n        }\r\n        this.entities = [];\r\n        // If stats is present, create defaultStats as a copy\r\n  \r\n    }\r\n\r\n    addEntity(entity) {\r\n        this.entities.push(entity);\r\n    }\r\n    removeEntity(entity) {\r\n    \r\n        let index = this.entities.indexOf(entity);\r\n        if( index >= 0 ) {\r\n            this.entities.splice(index, 1);\r\n        }\r\n    }\r\n}"
      },
      "ModelManager": {
        "title": "ModelManager",
        "fileName": "ModelManager",
        "script": "class ModelManager {\n    constructor(app, config, { ShapeFactory, palette, textures }) {\n        this.app = app;\n        this.config = config;\n        this.models = {};\n        this.shapeFactory = new ShapeFactory(palette, textures, null);\n        this.textureAtlases = new Map();\n        this.uvMappings = new Map();\n        this.mergedGeometries = new Map();\n    }\n\n    clear() {\n        this.models = {};\n        this.uvMappings.clear();\n        this.mergedGeometries.clear();\n        this.textureAtlases.clear();\n\n    }\n\n    dispose() {\n        for (const [key, model] of Object.entries(this.models)) {\n            this.disposeModel(model);\n        }\n        this.models = {};\n        this.uvMappings.clear();\n        this.mergedGeometries.clear();\n        this.textureAtlases.clear();\n\n    }\n\n    disposeModel(model) {\n        if (!model) return;\n        if (model.animations) {\n            for (const [animType, frames] of Object.entries(model.animations)) {\n                for (const frame of frames) {\n                    if (frame.group) {\n                        this.shapeFactory.disposeObject(frame.group);\n                        frame.group = null;\n                    }\n                }\n            }\n        }\n    }\n\n    async loadModels(prefix, config) {\n        if (!prefix || !config || typeof config !== 'object') {\n            throw new Error('Invalid prefix or config provided to loadModels');\n        }\n\n        const textures = [];\n        const textureInfo = [];\n\n        // First pass: Load temporary models to collect textures\n        const tempModels = [];\n        for (const [type, cfg] of Object.entries(config)) {\n            if (cfg.render && cfg.render.model) {\n                const modelGroupName = Object.keys(cfg.render.model)[0];\n                const modelGroup = cfg.render.model[modelGroupName];\n                const isGLTF = modelGroup.shapes.length > 0 && modelGroup.shapes[0].type === \"gltf\";\n                if (isGLTF) {\n                    const modelKey = `${prefix}_${type}`;\n                    const model = await this.createModel(prefix, type, cfg.render.model, false);\n                    tempModels.push({ modelKey, model, spawnType: type });\n                }\n            }\n        }\n\n        // Collect textures\n        tempModels.forEach(({ modelKey, model, spawnType }) => {\n            let meshIndex = 0;\n            model.traverse(child => {\n                if (child.isMesh && child.material.map) {\n                    textures.push(child.material.map);                    \n                    textureInfo.push({ modelKey, spawnType, meshIndex });\n                    meshIndex++;\n                }\n            });\n        });\n\n        // Generate texture atlas if textures exist\n        if (textures.length > 0) {\n            await this.generateTextureAtlas(prefix, textures, textureInfo);\n        }\n\n        // Second pass: Create final models with atlas and remapped UVs\n        for (const [type, cfg] of Object.entries(config)) {\n            if (cfg.render && cfg.render.model) {\n                const modelGroupName = Object.keys(cfg.render.model)[0];\n                const modelGroup = cfg.render.model[modelGroupName];\n                const isGLTF = modelGroup.shapes.length > 0 && modelGroup.shapes[0].type === \"gltf\";\n                if (isGLTF) {\n                    const modelKey = `${prefix}_${type}`;\n                    this.models[modelKey] = await this.createModel(prefix, type, cfg.render.model, true);\n                    const animations = cfg.render.animations;\n                    await Promise.all(Object.keys(animations).map(async (animationName) => {\n                        const anim = animations[animationName][0];\n                        const animMainGroup = anim[Object.keys(anim)[0]];\n                        let mergedModel = JSON.parse(JSON.stringify(cfg.render.model));\n                        if (animMainGroup) {\n                            mergedModel[modelGroupName].shapes[0].url = animMainGroup.shapes[0].url;\n                        }\n                        const modelKey = `${prefix}_${type}_${animationName}`;\n                        this.models[modelKey] = await this.createModel(prefix, type, mergedModel, true);\n                    }));\n                } else {\n                    this.models[`${prefix}_${type}`] = await this.createModel(prefix, type, cfg.render.model, false);\n                }\n            }\n        }  \n        // if (textures.length > 0) {\n        //     this.debugTextureAtlas(config, prefix);\n        // }\n        // Dispose temporary models\n        tempModels.forEach(({ model }) => this.shapeFactory.disposeObject(model));\n    }\n    debugTextureAtlas(config, prefix) {\n        if (!this.textureAtlases[prefix] || this.uvMappings.size === 0) {\n            console.warn('No texture atlas or UV mappings available to debug.');\n            return;\n        }\n\n        // Create a new canvas\n        const canvas = document.createElement('canvas');\n        canvas.width = this.textureAtlases[prefix].image.width;\n        canvas.height = this.textureAtlases[prefix].image.height;\n        const ctx = canvas.getContext('2d');\n\n        // Draw the texture atlas\n        ctx.drawImage(this.textureAtlases[prefix].image, 0, 0);\n\n        // Draw UV mapping regions (atlas regions per spawnType)\n        ctx.lineWidth = 2;\n        const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];\n        let index = 0;\n        this.uvMappings.forEach((uv, spawnType) => {\n            const [uMin, vMin, uMax, vMax] = uv;\n            const x = uMin * canvas.width;\n            const y = vMin * canvas.height;\n            const width = (uMax - uMin) * canvas.width;\n            const height = (vMax - vMin) * canvas.height;\n\n            // Draw rectangle for atlas region\n            ctx.strokeStyle = colors[index % colors.length];\n            ctx.strokeRect(x, y, width, height);\n\n            // Draw label\n            ctx.fillStyle = colors[index % colors.length];\n            ctx.font = '16px Arial';\n            ctx.fillText(spawnType, x + 5, y + 20);\n\n            index++;\n        });\n        index = 0;\n        for (const [type] of Object.entries(config)) {\n\n            const model = this.getModel(prefix, type);\n            if (!model) continue;\n\n            model.traverse((child) => {\n                \n                if (child.isMesh && child.geometry && child.geometry.attributes.uv && child.material.map) {\n                    const geometry = child.geometry;\n                    const uvAttribute = geometry.attributes.uv;\n                    const indexAttribute = geometry.index;\n                    const textureWidth = canvas.width;\n                    const textureHeight = canvas.height;\n                    // Draw UVs as a wireframe (using remapped UVs from createModel)\n                    ctx.fillStyle = colors[(index) % colors.length];\n                    ctx.strokeStyle = colors[(index) % colors.length];\n                    ctx.beginPath();\n                    if (indexAttribute) {\n                        // Draw lines for each triangle\n                        for (let i = 0; i < indexAttribute.count; i += 3) {\n                            const a = indexAttribute.getX(i);\n                            const b = indexAttribute.getX(i + 1);\n                            const c = indexAttribute.getX(i + 2);\n\n                            const uvA = [uvAttribute.getX(a), uvAttribute.getY(a)];\n                            const uvB = [uvAttribute.getX(b), uvAttribute.getY(b)];\n                            const uvC = [uvAttribute.getX(c), uvAttribute.getY(c)];\n\n                            // Scale UVs to canvas coordinates\n                            const xA = uvA[0] * textureWidth;\n                            const yA = uvA[1] * textureHeight;\n                            const xB = uvB[0] * textureWidth;\n                            const yB = uvB[1] * textureHeight;\n                            const xC = uvC[0] * textureWidth;\n                            const yC = uvC[1] * textureHeight;\n\n                            // Draw triangle edges\n                           ctx.moveTo(xA, yA);\n                           ctx.lineTo(xB, yB);\n                           ctx.lineTo(xC, yC);\n                           ctx.lineTo(xA, yA);\n                        }\n                    } \n                    ctx.stroke();\n            index++;\n                }\n            });\n            \n        }\n        // Style the canvas for visibility\n        canvas.style.border = '1px solid black';\n        canvas.style.margin = '10px';\n        canvas.title = `Texture Atlas with UV Mappings and Geometry UVs (Prefix: ${prefix})`;\n\n        // Append to document body\n        document.body.appendChild(canvas);\n    }\n    async generateTextureAtlas(objectType, textures, textureInfo) {\n        const textureSizes = textures.map((texture) => {\n            const img = texture.image;\n            return { width: img.width, height: img.height };\n        });\n\n        const gridSize = Math.ceil(Math.sqrt(textures.length));\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const gridPositions = [];\n\n        textureSizes.forEach((size, i) => {\n            const row = Math.floor(i / gridSize);\n            const col = i % gridSize;\n            const x = col * Math.max(...textureSizes.map(s => s.width));\n            const y = row * Math.max(...textureSizes.map(s => s.height));\n            gridPositions.push({ x, y });\n            maxWidth = Math.max(maxWidth, x + size.width);\n            maxHeight = Math.max(maxHeight, y + size.height);\n        });\n\n        let atlasWidth = Math.pow(2, Math.ceil(Math.log2(maxWidth)));\n        let atlasHeight = Math.pow(2, Math.ceil(Math.log2(maxHeight)));\n\n        const maxTextureSize = 4096;\n        let scale = 1;\n        if (atlasWidth > maxTextureSize || atlasHeight > maxTextureSize) {\n            console.warn('Atlas size exceeds GPU limit. Scaling down textures.');\n            scale = Math.min(maxTextureSize / atlasWidth, maxTextureSize / atlasHeight);\n            maxWidth = Math.floor(maxWidth * scale);\n            maxHeight = Math.floor(maxHeight * scale);\n            atlasWidth = Math.pow(2, Math.ceil(Math.log2(maxWidth)));\n            atlasHeight = Math.pow(2, Math.ceil(Math.log2(maxHeight)));\n            textureSizes.forEach(size => {\n                size.width = Math.floor(size.width * scale);\n                size.height = Math.floor(size.height * scale);\n            });\n            gridPositions.forEach(pos => {\n                pos.x = Math.floor(pos.x * scale);\n                pos.y = Math.floor(pos.y * scale);\n            });\n        }\n\n        const canvas = document.createElement('canvas');\n        canvas.width = atlasWidth;\n        canvas.height = atlasHeight;\n        const ctx = canvas.getContext('2d');\n\n        this.uvMappings.clear();\n        textures.forEach((texture, i) => {\n            const img = texture.image;\n            const size = textureSizes[i];\n            const pos = gridPositions[i];\n            ctx.drawImage(img, pos.x, pos.y, size.width, size.height);\n            this.uvMappings.set(`${textureInfo[i].spawnType}_${textureInfo[i].meshIndex}`, [\n                pos.x / atlasWidth,\n                pos.y / atlasHeight,\n                (pos.x + size.width) / atlasWidth,\n                (pos.y + size.height) / atlasHeight\n            ]);\n        });\n        this.textureAtlases[objectType] = new THREE.CanvasTexture(canvas);\n        this.textureAtlases[objectType].flipY = false;\n        this.textureAtlases[objectType].colorSpace = THREE.SRGBColorSpace;\n        this.textureAtlases[objectType].needsUpdate = true;\n    }\n\n    async createModel(objectType, spawnType, modelData, useAtlas = true) {\n        const modelGroup = await this.createObjectsFromJSON(modelData, {}, objectType, spawnType);\n        if (modelGroup) {\n            let meshIndex = 0;\n            modelGroup.traverse((child) => {\n                if (child.isMesh) {\n                    child.castShadow = true;\n                    child.receiveShadow = true;\n                    const geometry = child.geometry;\n                    if (useAtlas && this.textureAtlases[objectType] && this.uvMappings.has(spawnType) && !geometry.userData.uvsRemapped) {\n                        geometry.userData.uvsRemapped = true;\n                        // Apply texture atlas material\n                        child.material = new THREE.MeshStandardMaterial({\n                            map: this.textureAtlases[objectType],\n                            metalness: child.material.metalness || 0.5,\n                            roughness: child.material.roughness || 0.5\n                        });\n                        child.material.needsUpdate = true;\n                        // Remap UVs\n                        const uvMapping = this.uvMappings.get(`${spawnType}_${meshIndex}`);\n                        meshIndex++;\n                        const [uMin, vMin, uMax, vMax] = uvMapping;\n                        const uvAttribute = geometry.attributes.uv;\n                        if (uvAttribute) {                   \n                            for (let i = 0; i < uvAttribute.count; i++) {\n                                   \n                                let u = uvAttribute.getX(i);\n                                let v = uvAttribute.getY(i);\n                                // Map UVs to atlas region\n                                const uNew = uMin + u * (uMax - uMin);\n                                // Flip v to match GLTF (bottom-left) if atlas is top-left\n                                const vNew = vMin + v * (vMax - vMin); // Flip vertically                                 \n                                uvAttribute.setXY(i,uNew, vNew);\n                            }\n                            uvAttribute.needsUpdate = true;\n                        }\n                    }\n                }\n            });\n        }\n        return modelGroup;\n    }\n\n    getModel(prefix, type) {\n        return this.models[`${prefix}_${type}`];\n    }\n\n    getAnimation(prefix, type, anim) {\n        return this.models[`${prefix}_${type}_${anim}`];\n    }\n\n    async createObjectsFromJSON(model, frameData, objectType, spawnType) {\n        const rootGroup = new THREE.Group();\n        for (const groupName in model) {\n            const group = await this.shapeFactory.createMergedGroupFromJSON(model, frameData, groupName, objectType, spawnType);\n            if (group) {\n                rootGroup.add(group);\n            }\n        }\n        return rootGroup;\n    }\n}"
      },
      "three.OrbitControls": {
        "title": "THREE.OrbitControls",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
        "isModule": true,
        "fileName": "three.OrbitControls",
        "windowContext": "THREE_",
        "requireName": "OrbitControls",
        "importName": "OrbitControls"
      },
      "GLTFLoader": {
        "title": "GLTF Loader",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/loaders/GLTFLoader.js",
        "className": "GLTFLoader",
        "fileName": "GLTFLoader",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "GLTFLoader",
        "importName": "GLTFLoader"
      },
      "InstancePool": {
        "script": "class InstancePool {\r\n    constructor(geometry, material, initialSize) {\r\n        this.mesh = new THREE.InstancedMesh(geometry, material, initialSize);\r\n        this.mesh.count = 0;\r\n        this.freeIndices = [];\r\n        this.maxIndex = 0;\r\n    }\r\n\r\n    addInstance(matrix) {\r\n        let index;\r\n        if (this.freeIndices.length > 0) {\r\n            index = this.freeIndices.pop();\r\n        } else {\r\n            index = this.maxIndex++;\r\n            if (index >= this.mesh.instanceMatrix.count) {\r\n                this.expandPool(Math.max(this.mesh.count * 2, 100));\r\n            }\r\n        }\r\n\r\n        this.mesh.setMatrixAt(index, matrix);\r\n        this.mesh.count = Math.max(this.mesh.count, index + 1);\r\n        this.mesh.instanceMatrix.needsUpdate = true;\r\n        return index;\r\n    }\r\n\r\n    removeInstance(index) {\r\n        this.freeIndices.push(index);\r\n        // Set identity matrix to hide instance\r\n        this.mesh.setMatrixAt(index, new THREE.Matrix4());\r\n        this.mesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    expandPool(additionalSize) {\r\n        const newCount = this.mesh.instanceMatrix.count + additionalSize;\r\n        const newMesh = new THREE.InstancedMesh(\r\n            this.mesh.geometry,\r\n            this.mesh.material,\r\n            newCount\r\n        );\r\n        \r\n        newMesh.instanceMatrix.copy(this.mesh.instanceMatrix);\r\n        newMesh.count = this.mesh.count;\r\n        this.mesh.dispose();\r\n        this.mesh = newMesh;\r\n    }\r\n}",
        "fileName": "InstancePool"
      },
      "three.EffectComposer": {
        "title": "THREE.EffectComposer",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "EffectComposer",
        "importName": "EffectComposer",
        "fileName": "three.EffectComposer"
      },
      "three.RenderPixelatedPass": {
        "title": "THREE.RenderPixelatedPass",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "RenderPixelatedPass",
        "importName": "RenderPixelatedPass",
        "fileName": "three.RenderPixelatedPass"
      },
      "three.OutputPass": {
        "title": "THREE.OutputPass",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "OutputPass",
        "importName": "OutputPass",
        "fileName": "three.OutputPass"
      }
    },
    "modals": {
      "aiPromptPanel": {
        "title": "AI Prompt Panel",
        "fileName": "aiPromptPanel",
        "html": "<h2>AI Object Generator</h2>\r\n                <div class=\"form-group\">\r\n                    <label for=\"ai-prompt-textarea\">Prompt:</label>\r\n                    <textarea id=\"ai-prompt-textarea\" rows=\"6\" placeholder=\"Enter your AI generation prompt\"></textarea>\r\n                    <textarea id=\"ai-pre-prompt-textarea\" rows=\"6\" placeholder=\"context\"></textarea>\r\n                </div>\r\n                <div class=\"actions\">\r\n                    <button id=\"send-ai-prompt-btn\" class=\"primary\">Send to AI</button>\r\n                    <button id=\"close-ai-prompt-modal\">Cancel</button>\r\n                </div>\r\n                <div class=\"preview-section\">\r\n                    <h3>AI Response Preview</h3>\r\n                    <textarea id=\"ai-response-preview\" rows=\"6\"></textarea>\r\n                    <div class=\"preview-actions\">\r\n                        <button id=\"apply-ai-response-btn\" class=\"primary\" style=\"display:none;\">Apply Response</button>\r\n                    </div>\r\n                </div>"
      },
      "addTerrainType": {
        "title": "Add Terrain Type",
        "fileName": "addTerrainType",
        "html": "\r\n<h4 id=\"formTitle\">Add Terrain Type</h4>\r\n<input type=\"hidden\" id=\"editingType\" value=\"\">\r\n<div class=\"form-group\">\r\n    <label for=\"terrainType\">Type:</label>\r\n    <input type=\"text\" id=\"terrainType\" placeholder=\"grass, water, etc.\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainColor\">Color:</label>\r\n    <input type=\"text\" id=\"terrainColorText\">\r\n    <input type=\"color\" id=\"terrainColor\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainImage\">Sprite Sheet:</label>\r\n    <input type=\"textarea\" id=\"terrainImage\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainTexture\">Texture:</label>\r\n    <select id=\"terrainTexture\"></select>\r\n</div>\r\n<div class=\"form-group\">\r\n    <img id=\"terrain-image-display\" alt=\"Terrain Image\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainBuildable\">Buildable:</label>\r\n    <input type=\"checkbox\" id=\"terrainBuildable\">\r\n</div>\r\n<div class=\"form-actions\">\r\n    <button id=\"saveTerrainBtn\" class=\"primary\">Save</button>\r\n    <button id=\"cancelTerrainBtn\">Cancel</button>\r\n</div>\r\n<input type=\"hidden\" id=\"editingId\">\r\n"
      },
      "generateIsometric": {
        "title": "Generate Isometric Sprites",
        "fileName": "generateIsometric",
        "html": " <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>                 <div class=\"form-row\">                     <label for=\"iso-frustum\">Frustum Size:</label>                     <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-distance\">Distance:</label>                     <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-size\">Sprite Size:</label>                     <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">                 </div>                 <div style=\"display: flex; gap: 10px; margin-top: 20px;\">                     <button id=\"iso-cancel\">Cancel</button>                     <button id=\"iso-generate\">Generate</button>                 </div>           "
      },
      "generateIsoSprites": {
        "title": "Generate Spritesheet",
        "fileName": "generateIsoSprites",
        "html": "\r\n                <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-frustum\">Frustum Size:</label>\r\n                    <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-distance\">Distance:</label>\r\n                    <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-size\">Sprite Size:</label>\r\n                    <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"iso-cancel\">Cancel</button>\r\n                    <button id=\"iso-generate\">Generate</button>\r\n                </div>\r\n"
      },
      "moveAllShapes": {
        "title": "Move All Shapes",
        "fileName": "moveAllShapes",
        "html": "\r\n<h3>Move All Shapes</h3>\r\n<div class=\"form-row\">\r\n    <label for=\"move-x\">X Offset:</label>\r\n    <input type=\"number\" id=\"move-x\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-y\">Y Offset:</label>\r\n    <input type=\"number\" id=\"move-y\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-z\">Z Offset:</label>\r\n    <input type=\"number\" id=\"move-z\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n    <button id=\"move-cancel\">Cancel</button>\r\n    <button id=\"move-apply\">Apply</button>\r\n</div>\r\n"
      },
      "rotateShapes": {
        "title": "Rotate Shapes",
        "fileName": "rotateShapes",
        "html": "\r\n                <h3>Rotate All Shapes</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-angle\">Angle (degrees):</label>\r\n                    <input type=\"number\" id=\"rotate-angle\" value=\"0\" step=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-axis\">Axis:</label>\r\n                    <select id=\"rotate-axis\">\r\n                        <option value=\"x\">X</option>\r\n                        <option value=\"y\" selected>Y</option>\r\n                        <option value=\"z\">Z</option>\r\n                    </select>\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"rotate-cancel\">Cancel</button>\r\n                    <button id=\"rotate-apply\">Apply</button>\r\n                </div>\r\n"
      }
    },
    "renderers": {
      "EnergyShield": {
        "fileName": "EnergyShield",
        "script": "class EnergyShield extends engine.Component {\r\n\r\n    init(){\r\n        // Get stats component for reference\r\n        let statsComp = this.parent.getComponent('stats');\r\n        \r\n        // Shield configuration with defaults\r\n        this.maxEnergyShield = statsComp.stats.energyShield || 0;\r\n        this.energyShield = this.maxEnergyShield || 0;\r\n        this.rechargeRate = statsComp.stats.rechargeRate || 10; // Shield points per second\r\n        this.rechargeDelay = statsComp.stats.rechargeDelay || 2000; // Milliseconds before recharge starts\r\n        this.lastDamageTime = 0; // Timestamp of last damage taken\r\n        \r\n        // Add relevant stats to the stats component\r\n        statsComp.addStat('maxEnergyShield', this.maxEnergyShield);\r\n        statsComp.addStat('shieldRechargeRate', this.rechargeRate);\r\n        statsComp.addStat('shieldRechargeDelay', this.rechargeDelay);\r\n        \r\n        // Visual settings\r\n        this.shieldColor = 'rgba(77, 166, 255, 0.6)'; // Light blue default\r\n        this.shieldEmptyColor = 'rgba(77, 166, 255, 0.2)';\r\n        this.barWidth = 30;\r\n        this.barHeight = 5;\r\n        this.barOffset = 8; // Distance above health bar\r\n    }\r\n    \r\n    /**\r\n     * Handle incoming damage\r\n     * @param {number} damage - Amount of incoming damage\r\n     * @returns {Object} - Damage breakdown\r\n     */\r\n    absorbDamage(damage) {\r\n        const result = {\r\n            absorbedByShield: 0,\r\n            remainingDamage: 0\r\n        };\r\n        \r\n        // Reset recharge timer when taking damage\r\n        this.lastDamageTime = this.game.currentTime;\r\n        \r\n        if (this.energyShield > 0) {\r\n            if (damage <= this.energyShield) {\r\n                // Shield absorbs all damage\r\n                result.absorbedByShield = damage;\r\n                this.energyShield -= damage;\r\n            } else {\r\n                // Shield is depleted, remaining damage goes through\r\n                result.absorbedByShield = this.energyShield;\r\n                result.remainingDamage = damage - this.energyShield;\r\n                this.energyShield = 0;\r\n            }\r\n        } else {\r\n            // No shield available\r\n            result.remainingDamage = damage;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Update shield state (recharging)\r\n     */\r\n    update() {\r\n        let statsComp = this.parent.getComponent('stats');\r\n        this.maxEnergyShield = statsComp.stats.energyShield || 0;\r\n        // Check if enough time has passed since last damage\r\n        const timeSinceLastDamage = this.game.currentTime - this.lastDamageTime;\r\n        \r\n        if (timeSinceLastDamage >= this.rechargeDelay && this.energyShield < this.maxEnergyShield) {\r\n            // Calculate recharge amount based on time elapsed and rate\r\n            const deltaTime = this.game.deltaTime || 16; // Fallback to 60fps if deltaTime not available\r\n            const rechargeAmount = (this.rechargeRate * deltaTime) / 1000; // Convert to per-frame amount\r\n            \r\n            // Apply recharge\r\n            this.energyShield = Math.min(this.maxEnergyShield, this.energyShield + rechargeAmount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Draw shield bar\r\n     */\r\n    draw() {\r\n        if (this.maxEnergyShield <= 0) return; // Don't draw if no shield capacity\r\n        \r\n        const shieldPercentage = this.energyShield / this.maxEnergyShield;        \r\n        \r\n        // Shield bar will be slightly above that\r\n        const barY = this.parent.drawPosition.y - this.game.getCollections().configs.game.imageSize * .3 - this.barOffset;\r\n        \r\n        // Draw shield background/empty bar\r\n        this.game.ctx.fillStyle = this.shieldEmptyColor;\r\n        this.game.ctx.fillRect(this.parent.drawPosition.x - this.barWidth/2, barY, this.barWidth, this.barHeight);\r\n        \r\n        // Draw current shield level\r\n        if (shieldPercentage > 0) {\r\n            this.game.ctx.fillStyle = this.shieldColor;\r\n            this.game.ctx.fillRect(\r\n                this.parent.drawPosition.x - this.barWidth/2, \r\n                barY, \r\n                this.barWidth * shieldPercentage, \r\n                this.barHeight\r\n            );\r\n        }\r\n        \r\n        // Draw recharge indicator if currently recharging\r\n        const timeSinceLastDamage = this.game.currentTime - this.lastDamageTime;\r\n        if (timeSinceLastDamage < this.rechargeDelay && this.energyShield < this.maxEnergyShield) {\r\n            const rechargePercentage = timeSinceLastDamage / this.rechargeDelay;\r\n            \r\n            // Draw a small indicator below the shield bar\r\n            this.game.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';\r\n            this.game.ctx.fillRect(\r\n                this.parent.drawPosition.x - this.barWidth/2, \r\n                barY + this.barHeight + 1, \r\n                this.barWidth * rechargePercentage, \r\n                2\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get current shield value\r\n     * @returns {number} Current shield amount\r\n     */\r\n    getShieldValue() {\r\n        return this.energyShield;\r\n    }\r\n    \r\n    /**\r\n     * Reset shield to full\r\n     */\r\n    resetShield() {\r\n        this.energyShield = this.maxEnergyShield;\r\n    }\r\n    \r\n    /**\r\n     * Temporarily boost shield capacity\r\n     * @param {number} amount - Amount to boost by\r\n     * @param {number} duration - Duration in milliseconds\r\n     */\r\n    boostShield(amount, duration) {\r\n        const originalMax = this.maxEnergyShield;\r\n        this.maxEnergyShield += amount;\r\n        this.energyShield += amount;\r\n        \r\n        // Reset after duration\r\n        setTimeout(() => {\r\n            this.maxEnergyShield = originalMax;\r\n            this.energyShield = Math.min(this.energyShield, this.maxEnergyShield);\r\n        }, duration);\r\n    }\r\n}"
      },
      "Explosion": {
        "fileName": "Explosion",
        "script": "class Explosion extends engine.Component {\r\n\r\n   init( {radius}) {\r\n        this.maxRadius = radius * this.game.getCollections().configs.game.gridSize / 2;\r\n        this.currentRadius = 0;\r\n        this.alpha = 1;\r\n    }\r\n\r\n    update() {\r\n        this.currentRadius += this.maxRadius * 0.1;\r\n        this.alpha -= 0.05;\r\n        if( this.alpha < 0 ) {\r\n            this.parent.destroy();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        const pixelX = this.parent.transform.position.x;\r\n        const pixelY = this.parent.transform.position.y;\r\n\r\n        // Convert pixel to isometric\r\n        const isoPos = this.game.translator.pixelToIso(pixelX, pixelY);\r\n        const isoRadiusX = this.currentRadius;         // X-axis range remains roughly the same in isometric space\r\n        const isoRadiusY = this.currentRadius * 0.5;   // Y-axis range is halved due to isometric compression\r\n\r\n        this.game.ctx.beginPath();\r\n        this.game.ctx.ellipse(\r\n                isoPos.x,           // Center x in isometric coords\r\n                isoPos.y,           // Center y in isometric coords\r\n                isoRadiusX,          // X radius (wider due to isometric projection)\r\n                isoRadiusY,          // Y radius (shorter due to flattening)\r\n                0,                  // Rotation (none needed for isometric)\r\n                0,                  // Start angle\r\n                2 * Math.PI         // End angle (full circle)\r\n            );\r\n        this.game.ctx.fillStyle = `rgba(255, 200, 0, ${this.alpha * 0.5})`;\r\n        this.game.ctx.fill();\r\n\r\n        this.game.ctx.beginPath();\r\n        this.game.ctx.ellipse(\r\n                isoPos.x,           // Center x in isometric coords\r\n                isoPos.y,           // Center y in isometric coords\r\n                isoRadiusX * .7,          // X radius (wider due to isometric projection)\r\n                isoRadiusY * .7,          // Y radius (shorter due to flattening)\r\n                0,                  // Rotation (none needed for isometric)\r\n                0,                  // Start angle\r\n                2 * Math.PI         // End angle (full circle)\r\n            );\r\n        this.game.ctx.fillStyle = `rgba(255, 100, 0, ${this.alpha})`;\r\n        this.game.ctx.fill();\r\n    \r\n    }\r\n}"
      },
      "Health": {
        "fileName": "Health",
        "script": "class Health extends engine.Component {\r\n       \r\n  init(){\r\n        let statsComp = this.parent.getComponent('stats');\r\n        this.hp = statsComp.stats.hp;\r\n        \r\n        statsComp.addStat('maxHp', this.hp);\r\n    }\r\n\r\n    update() {        \r\n        if (this.hp <= 0){            \r\n            this.parent.destroy();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        let imageSize = this.game.getCollections().configs.game.imageSize;\r\n        let statsComp = this.parent.getComponent('stats');\r\n        const healthPercentage = this.hp / statsComp.stats.maxHp;\r\n        const barWidth = 30;\r\n        this.game.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n\r\n        // const isoPos = this.game.translator.pixelToIso(this.parent.transform.position.x, this.parent.transform.position.y)\r\n\r\n        // this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - imageSize * .3, barWidth, 5);\r\n        // if( healthPercentage >= 0 ) {\r\n        //     this.game.ctx.fillStyle = healthPercentage > 0.5 ? 'rgba(0, 255, 0, 0.5)' : healthPercentage > 0.25 ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';\r\n        //     this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - imageSize * .3, barWidth * healthPercentage, 5);\r\n        // }\r\n    }\r\n}"
      },
      "HitEffectRenderer": {
        "fileName": "HitEffectRenderer",
        "script": "class HitEffectRenderer extends engine.Component {\r\n    \r\n    \r\n    init( ) {\r\n        this.ctx = this.game.ctx;\r\n    }\r\n\r\n    draw() {\r\n        const particleComp = this.parent.getComponent(\"HitEffectParticle\");\r\n        if (!particleComp || !particleComp.particles.length) return;\r\n\r\n        const basePos = this.game.translator.pixelToIso(this.parent.transform.position.x, this.parent.transform.position.y);\r\n\r\n        for (let particle of particleComp.particles) {\r\n            this.ctx.fillStyle = `${particle.color}${particle.alpha})`;\r\n            this.ctx.beginPath();\r\n            const drawX = basePos.x + particle.x;\r\n            const drawY = basePos.y + particle.y;\r\n            this.ctx.arc(drawX, drawY, particle.size, 0, Math.PI * 2);\r\n            this.ctx.fill();\r\n        }\r\n    }\r\n}"
      },
      "LightningRenderer": {
        "fileName": "LightningRenderer",
        "script": "class LightningRenderer extends engine.Component {\r\n    \r\n    \r\n    init( {owner}) {\r\n        this.ctx = this.game.ctx;\r\n        const ownerStats = owner.getComponent(\"stats\").stats;\r\n        this.startOffsetY = ownerStats.projectileStartOffsetY || this.game.getCollections().configs.game.gridSize / 2;\r\n    }\r\n\r\n    draw() {\r\n        const projectile = this.parent.getComponent(\"ChainProjectile\");\r\n        if (!projectile || !projectile.chainTargets.length) return;\r\n\r\n        this.ctx.strokeStyle = \"rgba(0, 255, 255, 0.8)\"; // Cyan lightning\r\n        this.ctx.lineWidth = 2;\r\n        let stats = this.parent.getComponent('stats').stats;\r\n        // Start from Tesla Coil (parent position)\r\n        let startPos = this.game.translator.pixelToIso(this.parent.transform.position.x, this.parent.transform.position.y);\r\n        startPos.y -= this.startOffsetY;//dont shoot off the ground\r\n        for (let i = 0; i < projectile.chainTargets.length; i++) {\r\n            const target = projectile.chainTargets[i];\r\n            if (!target || target.destroyed) continue;\r\n\r\n            const endPos = this.game.translator.pixelToIso(target.position.x, target.position.y);\r\n            this.drawLightning(startPos, endPos);\r\n\r\n            // Next arc starts from this target\r\n            startPos = endPos;\r\n        }\r\n    }\r\n\r\n    drawLightning(startPos, endPos) {\r\n        this.ctx.beginPath();            \r\n        this.ctx.moveTo(startPos.x, startPos.y);\r\n\r\n        const segments = 8; // Number of zigzag points\r\n        const dx = (endPos.x - startPos.x) / segments;\r\n        const dy = (endPos.y - startPos.y) / segments;\r\n\r\n        let currentX = startPos.x;\r\n        let currentY = startPos.y;\r\n\r\n        for (let i = 1; i < segments; i++) {\r\n            currentX += dx;\r\n            currentY += dy;\r\n\r\n            // Add random offset for jagged effect\r\n            const offsetX = (Math.random() - 0.5) * 10; // Max 10px jitter\r\n            const offsetY = (Math.random() - 0.5) * 10;\r\n\r\n            this.ctx.lineTo(currentX + offsetX, currentY + offsetY);\r\n        }\r\n\r\n        this.ctx.lineTo(endPos.x, endPos.y);\r\n        this.ctx.stroke();\r\n    }\r\n}"
      },
      "ModelRenderer": {
        "title": "Model Renderer",
        "fileName": "ModelRenderer",
        "parameters": "[\"objectType\",\"spawnType\"]",
        "script": "class ModelRenderer extends engine.Component {\r\n    init({ objectType, spawnType, frameDuration }) {\r\n        if (!this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.objectType = objectType;\r\n        this.spawnType = spawnType;\r\n        this.animationState = 'idle';\r\n        this.currentFrameIndex = 0;\r\n        this.frameTime = 0;\r\n        this.frameDuration = frameDuration || 0.17;\r\n        this.lastDirection = -1;\r\n        this.currentAnimationTime = 0;\r\n        \r\n        this.fadeTime = 0.3;\r\n        this.minAnimationTime = 0;//this.fadeTime * 2;\r\n        // Load animation and model data\r\n        this.animationData = this.game.getCollections()[objectType]?.[spawnType]?.render?.animations;\r\n        this.modelData = this.game.getCollections()[objectType]?.[spawnType]?.render?.model;\r\n        this.isGLTF = this.modelData[Object.keys(this.modelData)[0]].shapes[0].type === \"gltf\";\r\n        this.clock = new THREE.Clock();\r\n        this.clock.start();\r\n\r\n        // Get the model\r\n        this.model = this.game.modelManager.getModel(objectType, spawnType);\r\n        this.skeletonUtils = THREE_.SkeletonUtils;\r\n        this.throwTimer = -1;\r\n        this.leapTimer = -1;\r\n        this.leapTime = 1;\r\n        this.throwTime = 2;\r\n        // Clone the model once\r\n        this.modelGroup = !this.isGLTF ? this.skeletonUtils.clone(this.model) : this.model;\r\n        this.game.scene.add(this.modelGroup);\r\n        this.modelGroup.position.set(0, -10000, 0);\r\n        this.isRunning = false;\r\n        // Initialize AnimationMixer and actions if GLTF\r\n        if (this.isGLTF) {\r\n            this.setupAnimationMixer();\r\n        }\r\n\r\n        // Set initial animation\r\n        this.setAnimation('idle');\r\n    }\r\n\r\n    setupAnimationMixer() {\r\n        // Find the mixer and animations from userData\r\n        let mixer, animations;\r\n        this.modelGroup.traverse(object => {\r\n            if (object.userData.mixer) {\r\n                mixer = object.userData.mixer;\r\n                animations = object.userData.animations;\r\n            }\r\n        });\r\n\r\n        this.mixer = mixer;\r\n        this.animationActions = {};\r\n\r\n        // Create AnimationActions for each animation\r\n        const animationNames = Object.keys(this.animationData);\r\n        animationNames.forEach(name => {\r\n            const animModel = this.game.modelManager.getAnimation(this.objectType, this.spawnType, name);\r\n            let animModelAnimations;\r\n            animModel.traverse(object => {\r\n                if (object.userData.mixer) {\r\n                    animModelAnimations = object.userData.animations;\r\n                }\r\n            });\r\n            if (animModelAnimations?.length > 0) {\r\n                const clip = animModelAnimations[0];\r\n                if (clip) {\r\n                    const action = this.mixer.clipAction(clip);\r\n                    action.setLoop(THREE.LoopRepeat);\r\n                    action.enabled = true;\r\n                    this.animationActions[name] = action;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Store the current action\r\n        this.currentAction = null;\r\n    }\r\n\r\n    setAnimation(animationName, speed = 1) {\r\n        if (!this.animationData[animationName]) {\r\n            console.warn(`Animation '${animationName}' not found, defaulting to 'idle'`);\r\n            animationName = 'idle';\r\n            if (!this.animationData[animationName]) {\r\n                const availableAnims = Object.keys(this.animationData);\r\n                animationName = availableAnims.length > 0 ? availableAnims[0] : null;\r\n                if (!animationName) {\r\n                    console.error('No animations available for this model');\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.animationState !== animationName && \r\n            (this.currentAnimationTime >= this.minAnimationTime)) {\r\n            this.animationState = animationName;\r\n            this.currentAnimationTime = 0;\r\n            if (this.isGLTF && this.mixer) {\r\n                const newAction = this.animationActions[animationName];\r\n                if (!newAction) {\r\n                    console.error(`No AnimationAction for ${animationName}`, this.animationActions);\r\n                    return;\r\n                }\r\n                if(newAction != this.currentAction){\r\n                    this.crossfadeTo(newAction, speed);\r\n                    this.currentAction.setEffectiveTimeScale(speed);\r\n                } else {\r\n                    this.currentAction.stop();\r\n                    this.currentAction.time = 0;\r\n                    this.currentAction.enabled = true;\r\n                    this.currentAction.setEffectiveTimeScale(speed);\r\n                    this.currentAction.play();\r\n                }\r\n\r\n\r\n            } else {\r\n                this.currentFrameIndex = 0;\r\n                this.frameTime = 0;\r\n                this.updateModelFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    crossfadeTo(newAction, speed) {\r\n        if(!newAction) return;\r\n        const previousAction = this.currentAction;\r\n        this.currentAction = newAction;\r\n        if (previousAction && previousAction !== newAction) {\r\n            previousAction.setEffectiveWeight(1);\r\n\r\n            newAction.setEffectiveWeight(1);\r\n\r\n            previousAction.play();\r\n            newAction.play();\r\n\r\n            previousAction.crossFadeTo(newAction, this.fadeTime / speed, true);\r\n\r\n            setTimeout(() => {\r\n                if (previousAction && this.currentAction !== previousAction) {\r\n                    previousAction.stop();\r\n                }\r\n            }, this.fadeTime * 1000 / speed);\r\n        } else {\r\n            newAction.enabled = true;\r\n            newAction.time = 0;\r\n            newAction.setEffectiveTimeScale(speed); // Apply animation speed\r\n            newAction.setEffectiveWeight(1);\r\n            newAction.play();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        if (!this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.currentAnimationTime += this.game.deltaTime;\r\n        // Update AnimationMixer for GLTF models\r\n        if (this.isGLTF && this.mixer) {\r\n            this.mixer.update(this.game.deltaTime);\r\n        }\r\n\r\n        this.updateDirection();\r\n        if (this.throwTimer >= 0) {\r\n            this.throwTimer += this.game.deltaTime;\r\n            if (this.throwTimer > this.throwTime) {\r\n                this.throwTimer = -1;\r\n            } else if (this.animationState !== 'throw') {\r\n                this.setAnimation('throw', this.throwSpeed);\r\n            }\r\n        }\r\n\r\n        if (this.leapTimer >= 0) {\r\n            this.leapTimer += this.game.deltaTime;\r\n            if (this.leapTimer > this.leapTime) {\r\n                this.leapTimer = -1;\r\n            } else if (this.animationState !== 'leap') {\r\n                this.setAnimation('leap', this.leapSpeed);\r\n            }\r\n        }\r\n        if (this.throwTimer < 0 && this.leapTimer < 0) {\r\n            this.setMovementAnimation();\r\n        }\r\n\r\n        // Update skeleton for skinned meshes\r\n        this.modelGroup.traverse(object => {\r\n            if (object.isSkinnedMesh && object.skeleton) {\r\n                object.skeleton.update();\r\n            }\r\n        });\r\n\r\n        // Update frame-based animations for non-GLTF models\r\n        if (!this.isGLTF) {\r\n            this.frameTime += this.game.deltaTime;\r\n            const effectiveFrameDuration = this.frameDuration; // Scale frame duration\r\n            if (this.frameTime >= effectiveFrameDuration) {\r\n                this.frameTime -= effectiveFrameDuration;\r\n                this.advanceFrame();\r\n            }\r\n        }\r\n        this.modelGroup.scale.set(\r\n            this.parent.transform.scale.x,\r\n            this.parent.transform.scale.y,\r\n            this.parent.transform.scale.z\r\n        );\r\n        // Update position of model to match entity position\r\n        if (this.parent && this.parent.transform.position) {\r\n            this.modelGroup.position.set(\r\n                this.parent.transform.position.x,\r\n                this.parent.transform.position.y,\r\n                this.parent.transform.position.z\r\n            );\r\n\r\n            // Handle rotation based on movement direction\r\n            this.updateDirection();\r\n        }\r\n    }\r\n\r\n    jump(speed = 1) {\r\n        if(this.leapTimer > 0) {\r\n            return;\r\n        }\r\n        this.leapSpeed = speed;\r\n        this.setAnimation('leap', speed);\r\n        this.leapTimer = 0;\r\n        this.leapTime = (this.animationActions['leap'].getClip().duration / speed);; // Scale leap time inversely with speed\r\n    }\r\n    throw(speed = 1) {\r\n        if(this.throwTimer > 0){\r\n            return;\r\n        }\r\n        this.throwSpeed = speed;\r\n        this.setAnimation('throw', speed);\r\n        this.throwTimer = 0;\r\n        this.throwTime = (this.animationActions['throw'].getClip().duration / speed);\r\n    \r\n    }\r\n    updateDirection() {\r\n        if (this.parent && this.parent.transform.lastPosition) {\r\n            this.modelGroup.quaternion.copy(this.parent.transform.quaternion);\r\n        }\r\n    }\r\n\r\n    setMovementAnimation() {\r\n        const dx = this.parent.transform.position.x - this.parent.transform.lastPosition.x;\r\n        const dy = this.parent.transform.position.z - this.parent.transform.lastPosition.z;\r\n        // Only update direction if there's significant movement\r\n        if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {\r\n            // Set walking animation when moving\r\n            this.throwTimer = -1;            \r\n            let moveAnim = this.isRunning ? \"run\" : \"walk\";\r\n            if (this.animationData[moveAnim]) {\r\n                this.setAnimation(moveAnim);\r\n                return;\r\n            }\r\n        } else {\r\n            // Entity is stationary, use idle animation\r\n            this.setAnimation('idle');\r\n        }\r\n    }\r\n\r\n    advanceFrame() {\r\n        const frames = this.animationData[this.animationState];\r\n        if (!frames || frames.length === 0) return;\r\n\r\n        this.currentFrameIndex = (this.currentFrameIndex + 1) % frames.length;\r\n        this.updateModelFrame();\r\n    }\r\n\r\n    updateModelFrame() {\r\n        // Get current animation and frame\r\n        const frames = this.animationData[this.animationState];\r\n        if (!frames?.length) return;\r\n\r\n        const frameData = frames[this.currentFrameIndex] || {};\r\n\r\n        // Traverse the modelGroup to apply transformations\r\n        this.modelGroup.traverse((obj) => {\r\n            // Handle group-level transformations (apply to group objects)\r\n            if (!obj.isMesh && obj.name && this.modelData[obj.name]) {\r\n                const groupName = obj.name;\r\n                const groupData = frameData[groupName];\r\n                const modelGroupData = this.modelData[groupName];\r\n                this.updateObjectTransforms(obj, groupData, modelGroupData);\r\n            }\r\n\r\n            // Handle shape-level transformations (apply to meshes)\r\n            if (obj.isMesh && obj.userData?.index >= 0 && obj.parent?.name) {\r\n                const groupName = obj.parent.name;\r\n                const index = obj.userData.index;\r\n                const groupData = frameData[groupName];\r\n                const modelGroupData = this.modelData[groupName];\r\n                let shape;\r\n                if (groupData?.shapes) {\r\n                    shape = groupData.shapes.find(s => s.id === index);\r\n                }\r\n                const modelShape = modelGroupData?.shapes?.[index];\r\n\r\n                if (shape || modelShape) {\r\n                    this.updateShapeTransforms(obj, shape, modelShape);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    updateObjectTransforms(obj, groupData, modelGroupData) {\r\n        if (!modelGroupData) return;\r\n\r\n        // Position\r\n        const pos = groupData?.position || modelGroupData.position || { x: 0, y: 0, z: 0 };\r\n        obj.position.set(\r\n            pos.x ?? modelGroupData.position?.x ?? 0,\r\n            pos.y ?? modelGroupData.position?.y ?? 0,\r\n            pos.z ?? modelGroupData.position?.z ?? 0\r\n        );\r\n\r\n        // Rotation\r\n        const rot = groupData?.rotation || modelGroupData.rotation || { x: 0, y: 0, z: 0 };\r\n        obj.rotation.set(\r\n            rot.x ?? modelGroupData.rotation?.x ?? 0,\r\n            rot.y ?? modelGroupData.rotation?.y ?? 0,\r\n            rot.z ?? modelGroupData.rotation?.z ?? 0\r\n        );\r\n\r\n        // Scale\r\n        const scale = groupData?.scale || modelGroupData.scale || { x: 1, y: 1, z: 1 };\r\n        obj.scale.set(\r\n            scale.x ?? modelGroupData.scale?.x ?? 1,\r\n            scale.y ?? modelGroupData.scale?.y ?? 1,\r\n            scale.z ?? modelGroupData.scale?.z ?? 1\r\n        );\r\n    }\r\n\r\n    updateShapeTransforms(obj, shape, modelShape) {\r\n        if (!modelShape) return;\r\n\r\n        // Position (local to group)\r\n        obj.position.set(\r\n            shape?.x ?? modelShape.x ?? 0,\r\n            shape?.y ?? modelShape.y ?? 0,\r\n            shape?.z ?? modelShape.z ?? 0\r\n        );\r\n\r\n        // Rotation (local to group, convert degrees to radians)\r\n        obj.rotation.set(\r\n            ((shape?.rotationX ?? modelShape.rotationX) || 0) * Math.PI / 180,\r\n            ((shape?.rotationY ?? modelShape.rotationY) || 0) * Math.PI / 180,\r\n            ((shape?.rotationZ ?? modelShape.rotationZ) || 0) * Math.PI / 180\r\n        );\r\n\r\n        // Scale (local to group)\r\n        obj.scale.set(\r\n            shape?.scaleX ?? modelShape.scaleX ?? 1,\r\n            shape?.scaleY ?? modelShape.scaleY ?? 1,\r\n            shape?.scaleZ ?? modelShape.scaleZ ?? 1\r\n        );\r\n    }\r\n\r\n    destroy() {\r\n        if (this.modelGroup) {\r\n            // Stop and clean up all animation actions\r\n            if (this.mixer) {\r\n                Object.values(this.animationActions).forEach(action => {\r\n                    action.stop();\r\n                });\r\n                this.mixer.uncacheRoot(this.modelGroup);\r\n                this.mixer = null;\r\n            }\r\n\r\n            // Remove model from scene\r\n            if (this.game.scene) {\r\n                this.game.scene.remove(this.modelGroup);\r\n            }\r\n\r\n            // Dispose of geometries and materials\r\n            this.modelGroup.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Clear children\r\n            while (this.modelGroup.children.length > 0) {\r\n                this.modelGroup.remove(this.modelGroup.children[0]);\r\n            }\r\n\r\n            this.modelGroup = null;\r\n        }\r\n    }\r\n}"
      },
      "RangeIndicator": {
        "fileName": "RangeIndicator",
        "script": "class RangeIndicator extends engine.Component {\r\n    \r\n    init() {\r\n        this.ctx = this.game.ctx;\r\n        this.translator = this.game.translator; // Access translator for tileWidth\r\n    }\r\n\r\n    draw() {\r\n        let statsComp = this.getComponent('stats');\r\n        if (!statsComp || !statsComp.stats || !statsComp.stats.range) {\r\n            return;\r\n        }\r\n        this.drawRangeIndicator(statsComp.stats.range);\r\n    }\r\n\r\n    drawRangeIndicator(range) {    \r\n        const drawRage = range;        \r\n        const pixelX = this.parent.transform.position.x;\r\n        const pixelY = this.parent.transform.position.y;\r\n        let gridPos = this.translator.pixelToGrid(pixelX, pixelY);\r\n        gridPos = this.translator.snapToGrid(gridPos.x, gridPos.y);\r\n        const isoPos = this.translator.pixelToIso(pixelX, pixelY);\r\n    \r\n        let isoRangeX = drawRage * this.game.getCollections().configs.game.gridSize;  // Matches gridToIso X scaling\r\n        let isoRangeY = drawRage * this.game.getCollections().configs.game.gridSize * (this.game.state.isometric ? 0.5 : 1); // Matches gridToIso Y scaling\r\n    \r\n        if( this.game.state.isometric ) {\r\n            isoRangeX *= .56;\r\n            isoRangeY *= .56;\r\n        }\r\n\r\n        if (gridPos.x === this.game.state.mousePosition.gridX && gridPos.y === this.game.state.mousePosition.gridY) {\r\n            this.ctx.save();\r\n            this.ctx.beginPath();\r\n            this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\r\n            this.ctx.lineWidth = 2;\r\n    \r\n            this.ctx.ellipse(\r\n                isoPos.x,\r\n                isoPos.y,\r\n                isoRangeX,\r\n                isoRangeY,\r\n                0,\r\n                0,\r\n                2 * Math.PI\r\n            );\r\n    \r\n            this.ctx.stroke();\r\n            this.ctx.closePath();\r\n            this.ctx.restore();\r\n        }    \r\n      \r\n    }\r\n}"
      },
      "Renderer": {
        "fileName": "Renderer",
        "script": "class Renderer extends engine.Component {\r\n\r\n    \r\n  init( { objectType, spawnType, setDirection = -2}) {\r\n        if(this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.images = this.game.imageManager.getImages(objectType, spawnType);  \r\n        this.setDirection = setDirection;\r\n        this.currentDirection = 0; // Default direction (will be 0-7 now)\r\n        // Rotated direction zones 45 degrees counter-clockwise\r\n        // Each zone covers a 45-degree arc (π/4 radians)\r\n        this.directionZones = [\r\n            { min: Math.PI/8, max: 3*Math.PI/8 },     // 0: Down-Right (Southeast)\r\n            { min: 3*Math.PI/8, max: 5*Math.PI/8 },   // 1: Down\r\n            { min: 5*Math.PI/8, max: 7*Math.PI/8 },   // 2: Down-Left (Southwest)\r\n            { min: 7*Math.PI/8, max: -7*Math.PI/8 },  // 3: Left (West)\r\n            { min: -7*Math.PI/8, max: -5*Math.PI/8 }, // 4: Up-Left (Northwest)\r\n            { min: -5*Math.PI/8, max: -3*Math.PI/8 }, // 5: Up\r\n            { min: -3*Math.PI/8, max: -Math.PI/8 },   // 6: Up-Right (Northeast)\r\n            { min: -Math.PI/8, max: Math.PI/8 }       // 7: Right (East)\r\n        ];\r\n        this.isometric = this.game.getCollections().configs.game.isIsometric;\r\n    }\r\n\r\n    draw() {\r\n        if(this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        if( this.setDirection < 0 ) {\r\n            const dx = this.parent.transform.position.x - this.parent.lastPosition.x; // Change in x\r\n            const dy = this.parent.transform.position.y - this.parent.lastPosition.y; // Change in y\r\n            \r\n            // Only update direction if there's movement\r\n            if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {\r\n                // Calculate angle of movement in radians\r\n                const angle = Math.atan2(dy, dx);\r\n                \r\n                // Determine which of the 8 directional zones the angle falls into\r\n                for (let i = 0; i < this.directionZones.length; i++) {\r\n                    const zone = this.directionZones[i];\r\n                    \r\n                    // Special handling for the West zone which wraps around from PI to -PI\r\n                    if (i === 3) {\r\n                        if (angle >= zone.min || angle <= zone.max) {\r\n                            this.currentDirection = i;\r\n                            break;\r\n                        }\r\n                    } \r\n                    // Normal zone check\r\n                    else if (angle >= zone.min && angle < zone.max) {\r\n                        this.currentDirection = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this.currentDirection = this.setDirection;\r\n        }\r\n        let direction = this.currentDirection + (this.isometric ? 0 : -1);\r\n        if(direction == -1 ) direction = this.images.length - 1;//wrap around\r\n        // Draw the image for the current direction\r\n        if (this.images && this.images.length > direction) {\r\n            const image = this.images[direction];\r\n            if (image) {\r\n                const imgWidth = image.width;\r\n                const imgHeight = image.height;\r\n                \r\n                const drawX = this.parent.transform.drawPosition.x - imgWidth / 2;\r\n                let drawY = this.parent.transform.drawPosition.y - imgHeight / 2;\r\n                if( this.parent.transform.position.z ) {\r\n                   drawY -= this.parent.transform.position.z;                   \r\n                }\r\n                this.game.ctx.drawImage(image, drawX, drawY);\r\n            }\r\n        }\r\n    }\r\n}"
      },
      "UiManager": {
        "fileName": "UiManager",
        "script": "class UiManager extends engine.Component {\r\n    \r\n    init({ canvas, canvasBuffer, terrainCanvasBuffer }) {\r\n        this.canvas = canvas || this.game.canvas;\r\n        this.canvasBuffer = canvasBuffer || this.game.canvasBuffer;\r\n        if(this.game.getCollections().configs.game.is3D) {\r\n            this.finalCtx = this.canvas.getContext(\"webgl2\");\r\n            this.ctx = this.canvasBuffer.getContext(\"webgl2\");\r\n        } else {\r\n            this.finalCtx = this.canvas.getContext(\"2d\");\r\n            this.ctx = this.canvasBuffer.getContext(\"2d\");\r\n        }\r\n        this.terrainCanvasBuffer = terrainCanvasBuffer || this.game.terrainCanvasBuffer;\r\n        this.projectConfig = this.game.getCollections().configs.game;\r\n        this.gridSize = this.projectConfig.gridSize;\r\n        this.isometric = this.projectConfig.isIsometric || false;\r\n        this.overlay = document.getElementById('overlay');\r\n        this.tooltip = document.getElementById('tooltip');\r\n        this.gameOverMenu = document.getElementById('gameOverMenu');\r\n        this.victoryMenu = document.getElementById('victoryMenu');\r\n\r\n        this.hpDisplay = document.getElementById('hpDisplay');\r\n        this.gameOverWave = document.getElementById('gameOverWave');\r\n    \r\n        this.setupEventListeners();\r\n        this.game.uiManager = this;\r\n       \r\n    }\r\n    clearCanvas() {\r\n        this.ctx.clearRect(0, 0, this.canvasBuffer.width, this.canvasBuffer.height);\r\n        this.finalCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);    \r\n    }\r\n    renderCanvas() {      \r\n        this.finalCtx.drawImage(this.canvasBuffer, 0, 0);\r\n    }\r\n\r\n    setMousePosition(clientX, clientY) {\r\n        if(!this.game.getCollections().configs.game.is3D) {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n                \r\n            // Account for canvas scaling and offset\r\n            const scaleX = this.canvas.width / rect.width;   // Ratio of canvas pixel width to CSS width\r\n            const scaleY = this.canvas.height / rect.height; // Ratio of canvas pixel height to CSS height\r\n            \r\n            const mapGridWidth = this.game.state.tileMap.length;\r\n            // Calculate mouse position relative to canvas with scaling\r\n            const mouseX = (clientX - rect.left) * scaleX + (this.isometric ? 0 : -( this.canvas.width - mapGridWidth * this.game.getCollections().configs.game.gridSize) / 2);\r\n            const mouseY = (clientY - rect.top) * scaleY + (this.isometric ? 0 : -( this.canvas.height - mapGridWidth * this.game.getCollections().configs.game.gridSize) / 2);\r\n\r\n            // Convert to isometric and grid coordinates\r\n            const gridPos = this.game.translator.isoToGrid(mouseX, mouseY);\r\n            const snappedGrid = this.game.translator.snapToGrid(gridPos.x, gridPos.y);\r\n            const pixelIsoPos = this.game.translator.pixelToIso(mouseX, mouseY);\r\n\r\n            // Update state with corrected coordinates\r\n            this.game.state.mousePosition = { \r\n                x: mouseX, \r\n                y: mouseY, \r\n                isoX: pixelIsoPos.x, \r\n                isoY: pixelIsoPos.y, \r\n                gridX: snappedGrid.x, \r\n                gridY: snappedGrid.y \r\n            };\r\n        } else {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            \r\n            // Calculate normalized device coordinates (-1 to +1)\r\n            const mouseX = ((clientX - rect.left) / rect.width) * 2 - 1;\r\n            const mouseY = -((clientY - rect.top) / rect.height) * 2 + 1;\r\n            \r\n            // Setup the raycaster\r\n            const raycaster = new THREE.Raycaster();\r\n            const mouse = new THREE.Vector2(mouseX, mouseY);\r\n            \r\n            // Update the picking ray with the camera and mouse position\r\n            raycaster.setFromCamera(mouse, this.game.camera);\r\n            \r\n            // Create a plane at y=0 to represent our terrain\r\n            const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);\r\n            \r\n            // Calculate the point where the ray intersects the ground plane\r\n            const intersectPoint = new THREE.Vector3();\r\n            raycaster.ray.intersectPlane(groundPlane, intersectPoint);\r\n            \r\n            if (intersectPoint) {\r\n                // Convert to grid coordinates\r\n                const gridX = Math.floor(intersectPoint.x / this.game.getCollections().configs.game.gridSize);\r\n                const gridY = Math.floor(intersectPoint.z / this.game.getCollections().configs.game.gridSize);\r\n                \r\n                // Update state with world and grid coordinates\r\n                this.game.state.mousePosition = {\r\n                    x: intersectPoint.x,                    \r\n                    y: intersectPoint.z,\r\n                    gridX: gridX,\r\n                    gridY: gridY,\r\n                    worldX: intersectPoint.x,\r\n                    worldY: intersectPoint.z\r\n                };\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    setupEventListeners() {\r\n        document.getElementById('startGameBtn').removeAttribute('style');\r\n        document.getElementById('startGameBtn').addEventListener('click', (e) => {    \r\n            this.game.state.isPaused = false;\r\n            e.target.setAttribute('style','display:none;');\r\n        });\r\n        document.querySelector(\"#gameOverMenu .menu-button\").addEventListener(\"click\", (e) => {\r\n            this.game.reset();\r\n        });\r\n        \r\n        document.querySelector(\"#victoryMenu .menu-button\").addEventListener(\"click\", (e) => {\r\n            this.game.reset();\r\n        });\r\n        this.canvas.addEventListener('mousemove', (e) => {\r\n            this.setMousePosition(e.clientX, e.clientY);\r\n        });\r\n\r\n        this.canvas.addEventListener('mouseout', () => {\r\n            this.hideTooltip();\r\n        });\r\n                \r\n        // Cancel tower placement with right click\r\n        this.canvas.addEventListener('contextmenu', (e) => {\r\n            e.preventDefault();\r\n            if (this.game.state.selectedTowerType) {\r\n                this.game.state.selectedTowerType = null;\r\n                this.canvas.style.cursor = 'default';\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    reset() {\r\n        this.gameOverMenu.style.display = 'none';\r\n        this.victoryMenu.style.display = 'none';\r\n        this.overlay.style.display = 'none';\r\n    }\r\n\r\n\r\n    draw() {\r\n  \r\n    }\r\n\r\n\r\n    showTooltip(x, y, text) {\r\n        const tooltip = document.getElementById('tooltip');\r\n        tooltip.style.display = 'block';\r\n        tooltip.style.left = (x + 10) + 'px';\r\n        tooltip.style.top = (y + 10) + 'px';\r\n        tooltip.textContent = text;\r\n    }\r\n\r\n    hideTooltip() {\r\n        const tooltip = document.getElementById('tooltip');\r\n        tooltip.style.display = 'none';\r\n    }\r\n}"
      }
    },
    "configs": {
      "ai": {
        "title": "AI",
        "aiEndPoint": "http://localhost:11434/api/generate",
        "aiModel": "deepseek-r1:32b",
        "defaultPrompt": "I am developing a game.  Generate a new object based on the following context. Please provide ONLY a valid JSON object with keys MATCHING EXACTLY to the context above. It absolutely MUST have an appropriate 'id' field. Ensure all existing key types are maintained. Do not wrap the json object with any other text.",
        "fileName": "ai"
      },
      "codeMirror": {
        "title": "Code Mirror",
        "theme": "codeMirrorTheme",
        "fileName": "codeMirror"
      },
      "editor": {
        "title": "Editor Config",
        "editorCategories": "",
        "theme": "claude2",
        "editorModules": [
          "graphicsModule",
          "scriptModule",
          "aiPromptModule",
          "audioModule",
          "exportScriptModule",
          "textureEditor",
          "sceneModule"
        ],
        "path": "/",
        "fileName": "editor"
      },
      "game": {
        "gridSize": 48,
        "imageSize": 128,
        "title": "Infiniworld",
        "isIsometric": false,
        "libraries": [
          "threejs",
          "Rapier",
          "three.SkeletonUtils",
          "three.PointerLockControls",
          "three.BufferGeometryUtils",
          "ShapeFactory",
          "SimplexNoise",
          "TerrainGenerator",
          "ImageManager",
          "SpatialGrid",
          "CoordinateTranslator",
          "CanvasUtility",
          "TerrainImageProcessor",
          "TileMap",
          "Entity",
          "Component",
          "GameState",
          "ModelManager",
          "three.OrbitControls",
          "GLTFLoader",
          "InstancePool",
          "three.EffectComposer",
          "three.RenderPixelatedPass",
          "three.OutputPass"
        ],
        "fileName": "game",
        "interface": "main",
        "loaderComponent": "GameLoader",
        "loaderEntity": "GameLoader",
        "canvasWidth": 1600,
        "canvasHeight": 1000,
        "is3D": true,
        "palette": "main",
        "pixelSize": 1
      },
      "state": {
        "level": "level1",
        "enemies": [],
        "towers": [],
        "projectiles": [],
        "summons": [],
        "others": [],
        "enemiesSpawned": [],
        "isPaused": true,
        "isLevelingUp": false,
        "timeScale": 1,
        "gameOver": false,
        "victory": false,
        "round": 0,
        "fileName": "state",
        "population": 0
      }
    },
    "editorModules": {
      "graphicsModule": {
        "title": "Graphics Editor",
        "container": "graphics-editor-container",
        "libraries": [
          "threejs",
          "three.OrbitControls",
          "three.SkeletonUtils",
          "GLTFLoader",
          "ShapeFactory",
          "GE_AnimationManager",
          "GE_EventManager",
          "GE_GizmoManager",
          "GE_GroupManager",
          "GE_ShapeManager",
          "GE_RotationUtils",
          "GE_SceneRenderer",
          "GE_UIManager",
          "GraphicsEditor"
        ],
        "propertyName": "render",
        "interface": "graphicsEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "renderGraphicsObject",
        "saveHook": "saveGraphicsObject"
      },
      "sceneModule": {
        "title": "Scene Editor",
        "container": "scene-editor-container",
        "libraries": [
          "threejs",
          "three.OrbitControls",
          "three.SkeletonUtils",
          "GLTFLoader",
          "ShapeFactory",
          "SimplexNoise",
          "TerrainGenerator",
          "ModelManager",
          "SE_GizmoManager",
          "SceneEditor"
        ],
        "propertyName": "sceneData",
        "interface": "sceneEditor",
        "inputElement": "textarea",
        "inputDataType": "array",
        "loadHook": "renderSceneObject",
        "saveHook": "saveSceneObject"
      },
      "aiPromptModule": {
        "title": "AI Prompt Modal",
        "library": "aiPromptPanel",
        "interface": "aiPromptPanel"
      },
      "audioModule": {
        "title": "Audio Editor",
        "container": "audio-editor-container",
        "propertyName": "audio",
        "interface": "audioEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "editAudio",
        "saveHook": "saveAudio",
        "libraries": [
          "Component",
          "audioEditor"
        ]
      },
      "exportScriptModule": {
        "title": "Export Scripts Module",
        "library": "ZipExporter"
      },
      "terrainModule": {
        "title": "Terrain Editor",
        "container": "level-editor-container",
        "libraries": [
          "threejs",
          "ShapeFactory",
          "CoordinateTranslator",
          "ImageManager",
          "CanvasUtility",
          "TerrainImageProcessor",
          "TileMap",
          "GE_GroupManager",
          "terrainMapEditor"
        ],
        "propertyName": "tileMap",
        "interface": "terrainEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "editTileMap",
        "saveHook": "saveTileMap"
      },
      "textureEditor": {
        "title": "Texture Editor",
        "container": "texture-editor-container",
        "library": "TextureEditor",
        "propertyName": "image",
        "interface": "TextureEditor",
        "inputElement": "textarea",
        "inputDataType": "string",
        "loadHook": "editTexture",
        "saveHook": "saveTexture"
      },
      "scriptModule": {
        "title": "Script Editor",
        "container": "script-editor-container",
        "interface": "scriptEditor",
        "inputElement": "textarea",
        "inputDataType": "string",
        "libraries": [
          "Component",
          "Entity",
          "scriptEditor"
        ],
        "propertyNames": "[\"script\", \"html\", \"css\"]",
        "loadHook": "editScript",
        "saveHook": "saveScript"
      }
    },
    "inputDataTypes": {
      "array": {
        "title": "Array"
      },
      "boolean": {
        "title": "Boolean"
      },
      "color": {
        "title": "Color"
      },
      "enum": {
        "title": "Enum"
      },
      "json": {
        "title": "JSON"
      },
      "number": {
        "title": "Number"
      },
      "string": {
        "title": "String"
      },
      "vector2": {
        "title": "Vector2"
      },
      "vector3": {
        "title": "Vector3"
      }
    },
    "inputElementTypes": {
      "text": {
        "title": "text",
        "tag": "input"
      },
      "textarea": {
        "title": "Text Area",
        "tag": "textarea"
      }
    },
    "themes": {
      "claude2": {
        "title": "Claude 2",
        "fileName": "claude2",
        "css": "/* Professional Theme - Clean UI */ @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');  :root {   --bg-primary: #16192e;   --bg-secondary: #1d2035;   --bg-tertiary: #252a43;   --accent-primary: #4d7cff;   --accent-muted: rgba(77, 124, 255, 0.15);   --text-primary: #e9edf5;   --text-secondary: #a9b1c3;   --border-color: rgba(108, 123, 163, 0.25);   --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.2);   --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25); }  body {   font-family: 'Inter', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6; }  /* Sidebar styling */ .sidebar {   background-color: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: none;   letter-spacing: 0.2px;   color: var(--text-secondary);   font-weight: 400;   transition: all 0.2s ease;   padding: 10px 14px;   margin-bottom: 2px; }  .object-item:hover {   background-color: var(--bg-tertiary);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary); }  .object-item.selected {   background-color: var(--accent-muted);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   font-weight: 500; }  /* Editor area */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #three-js-container {   border: 1px solid var(--border-color);   border-radius: 4px;   background: var(--bg-primary); }  .preview-canvas-container {   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-color);   border-radius: 2px; }  /* Camera controls */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px; }  .camera-controls button {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   color: var(--text-primary);   border-radius: 3px;   padding: 8px 12px;   transition: all 0.2s ease; }  .camera-controls button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .camera-controls .color-picker {   border: 1px solid var(--border-color);   border-radius: 3px; }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-color);   border-radius: 3px;   height: 5px; }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   border-radius: 50%;   cursor: pointer; }  /* Form elements */ label {   font-weight: 500;   color: var(--text-primary);   margin-bottom: 6px;   display: block;   font-size: 0.875rem; }  input, textarea, select {   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   border-radius: 3px;   width: calc(100% - 24px);  padding: 8px 12px;   transition: all 0.2s ease;   font-family: 'IBM Plex Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 2px var(--accent-muted); }  /* Button styles */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease; }  button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  button.primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  button.primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6;   box-shadow: var(--shadow-sm); }  button.danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  button.danger:hover {   background-color: rgba(235, 68, 68, 0.25);   box-shadow: var(--shadow-sm); }  button.active {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  /* Modal styling */ .modal {   background-color: rgba(22, 25, 46, 0.8); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-md);   border-radius: 4px; }  .property-list {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   border-radius: 4px; }  /* Tab navigation */ .tab-navigation {   border-bottom: 1px solid var(--border-color);   display: flex;   padding: 0 4px; }  .tab {   padding: 10px 16px;   color: var(--text-secondary);   transition: all 0.2s ease; }  .tab:hover {   background-color: var(--bg-tertiary);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 500;   border-bottom: 2px solid var(--accent-primary); }  /* Info and warning boxes */ .instructions {   background-color: var(--bg-tertiary);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .success-message {   color: #34c79a;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(235, 68, 68, 0.1);   border-left: 3px solid #eb4444;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  /* Main containers */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  #graphics-rightbar {   background: var(--bg-secondary);   border-left: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(108, 123, 163, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(108, 123, 163, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar */ .toolbar {   background: var(--bg-secondary);   border-bottom: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations */ .btn {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease;   font-size: 0.875rem; }  .btn:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  .btn-primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6; }  .btn-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  .btn-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  .btn-secondary {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color); }  .btn-secondary:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-special {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  .btn-special:hover {   background-color: rgba(52, 199, 154, 0.25); }  /* Shape list */ #shape-list {   border-bottom: 1px solid var(--border-color);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 3px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.2s ease;   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .shape-item.active {   background-color: rgba(52, 199, 154, 0.1);   border-color: #34c79a;   color: #34c79a;   font-weight: 500; }  /* Inspector panel */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-color);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--text-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   padding: 8px 12px;   border-radius: 3px; }  /* Scene info */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px 16px;   margin-bottom: 16px; }  .button-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444;   padding: 8px 14px;   border-radius: 3px;   font-weight: 500;   transition: all 0.2s ease; }  .button-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  /* Typography */ h2, h3 {   color: var(--text-primary);   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-color);   font-weight: 600; }  /* Scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(108, 123, 163, 0.5);   border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {   background: rgba(108, 123, 163, 0.7); }"
      },
      "codeMirrorTheme": {
        "title": "Code - Ez On Eyes",
        "fileName": "codeMirrorTheme",
        "css": ".CodeMirror {    background: #1e1e1e;    color: #d4d4d4;    font-size: 14px; } .CodeMirror-gutters {    background: #252525;  border-right: 1px solid #444; } .CodeMirror-linenumber {    color: #888; }.CodeMirror-cursor {    border-left: 1px solid #d4d4d4; } .CodeMirror-selected {    background: #3a3a3a; }.CodeMirror-focused .CodeMirror-selected {    background: #404040; /* Slightly lighter when focused */}.CodeMirror-activeline-background {    background: #2a2a2a; /* Subtle active line highlight */}.CodeMirror-matchingbracket {    color: #b5cea8; /* Muted green for matching brackets */}.CodeMirror-nonmatchingbracket {    color: #d16969; /* Soft red for non-matching */}/* Override default theme's syntax highlighting */.cm-s-default .cm-header { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-quote { color: #b5cea8; } /* Muted green (overrides #090) */.cm-negative { color: #d16969; } /* Soft red */.cm-positive { color: #6a9955; } /* Muted green */.cm-header, .cm-strong { font-weight: 700; }.cm-em { font-style: italic; }.cm-s-default .cm-link { color: #d7ba7d; text-decoration: underline; } /* Muted yellow (overrides #00c blue) */.cm-strikethrough { text-decoration: line-through; }.cm-s-default .cm-keyword { color: #ce9178; } /* Soft orange (overrides #708 purple) */.cm-s-default .cm-atom { color: #d4d4d4; } /* Light gray (overrides #219 blue) */.cm-s-default .cm-number { color: #b5cea8; } /* Muted green (overrides #164) */.cm-s-default .cm-def { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-variable-2 { color: #d4d4d4; } /* Light gray (overrides #05a blue) */.cm-s-default .cm-variable-3, .cm-s-default .cm-type { color: #dcdcaa; } /* Soft yellow (overrides #085 blue) */.cm-s-default .cm-comment { color: #6a9955; } /* Muted green (overrides #a50) */.cm-s-default .cm-string { color: #ce9178; } /* Soft orange (overrides #a11) */.cm-s-default .cm-string-2 { color: #d7ba7d; } /* Muted yellow (overrides #f50) */.cm-s-default .cm-meta { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-qualifier { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-builtin { color: #dcdcaa; } /* Soft yellow (overrides #30a) */.cm-s-default .cm-bracket { color: #d4d4d4; } /* Light gray (overrides #997) */.cm-s-default .cm-tag { color: #dcdcaa; } /* Soft yellow (overrides #170) */.cm-s-default .cm-attribute { color: #d4d4d4; } /* Light gray (overrides #00c blue) */.cm-s-default .cm-hr { color: #888; } /* Muted gray (overrides #999) */.cm-s-default .cm-link { color: #d7ba7d; } /* Muted yellow (overrides #00c blue) */.cm-s-default .cm-error { color: #d16969; } /* Soft red (overrides red) */.cm-invalidchar { color: #d16969; } /* Soft red *//* Search highlight */.cm-searching {    background-color: rgba(255, 255, 0, 0.2); /* Subtle yellow */}"
      },
      "cyberpunk": {
        "title": "Cyber Punk",
        "fileName": "cyberpunk",
        "css": "/* Default Cyberpunk Theme */ @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&display=swap');  body {     font-family: 'Orbitron', 'Rajdhani', sans-serif;     background-color: #0a0a16;     color: #00f0ff; }  .sidebar {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px #00f0ff, inset 0 0 20px rgba(0, 240, 255, 0.2); }  .object-item {     background-color: rgba(0, 0, 35, 0.6);     border-left: 2px solid #fe01fe;     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(254, 1, 254, 0.2);     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(254, 1, 254, 0.3);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 8px rgba(254, 1, 254, 0.5); }  .editor {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #fe01fe;     box-shadow: 0 0 15px rgba(254, 1, 254, 0.3); }  #three-js-container {     border: 1px solid rgba(0, 240, 255, 0.5); }  .preview-canvas-container {     border: 1px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.3); }  .preview {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(0, 240, 255, 0.5); }  .camera-controls {     background: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff; }  .camera-controls button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff; }  .camera-controls .color-picker {     border: 1px solid #00f0ff; }  .camera-controls .size-slider {     background: #101028;     border: 1px solid #00f0ff; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #fe01fe; }  input, textarea, select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff;     text-transform: uppercase;     letter-spacing: 1px; }  button:after {     background: linear-gradient(to right, transparent, rgba(0, 240, 255, 0.2), transparent); }  button:hover {     background-color: rgba(0, 240, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5), 0 0 20px rgba(0, 240, 255, 0.2);     transform: translateY(-2px); }  button:hover:after {     transform: translateX(100%) rotate(30deg); }  button.primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  button.primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5), 0 0 20px rgba(254, 1, 254, 0.2); }  button.danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  button.danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5), 0 0 20px rgba(255, 0, 76, 0.2); }  button.active {     border: 1px solid #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);     color: #00ff9d; }  .modal {     background-color: rgba(0, 0, 20, 0.85);     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(15, 15, 35, 0.9);     border: 1px solid #00f0ff;     box-shadow: 0 0 30px rgba(0, 240, 255, 0.3), 0 0 60px rgba(0, 240, 255, 0.1); }  .property-list {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6); }  .tab-navigation {     border-bottom: 1px solid #00f0ff; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(0, 240, 255, 0.1); }  .tab.active {     border-bottom: 3px solid #fe01fe;     box-shadow: 0 5px 10px -5px rgba(254, 1, 254, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(0, 0, 35, 0.6);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.2); }  #grid-display {     background-color: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px rgba(0, 240, 255, 0.3); }  .success-message {     color: #00ff9d;     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(255, 0, 76, 0.1);     border-left: 4px solid #ff004c;     box-shadow: 0 0 10px rgba(255, 0, 76, 0.2); }  .main-content-container {     background-color: #080815;     color: #00f0ff; }  .content-sidebar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-right: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-left: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  .grid-background {     background: #05051a;     background-image: radial-gradient(rgba(0, 240, 255, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-bottom: 1px solid #00f0ff; }  .btn {     border: 1px solid #00f0ff;     background-color: rgba(0, 240, 255, 0.1);     color: #00f0ff;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(0, 240, 255, 0.2);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  .btn-primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  .btn-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .btn-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  .btn-secondary {     background-color: rgba(0, 240, 255, 0.15);     border: 1px solid #00f0ff; }  .btn-secondary:hover {     background-color: rgba(0, 240, 255, 0.25);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5); }  .btn-special {     background-color: rgba(0, 255, 157, 0.2);     border: 1px solid #00ff9d;     color: #00ff9d; }  .btn-special:hover {     background-color: rgba(0, 255, 157, 0.3);     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(0, 240, 255, 0.2); }  .shape-item {     background-color: rgba(0, 0, 35, 0.6);     border: 1px solid #00f0ff; }  .shape-item:hover {     background-color: rgba(0, 240, 255, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(0, 255, 157, 0.1);     border-color: #00ff9d;     color: #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.3); }  #inspector {     background: rgba(20, 20, 50, 0.8);     border-top: 1px solid #00f0ff; }  .form-row label {     color: #fe01fe; }  .form-row input, .form-row select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  .scene-info {     background: rgba(0, 0, 20, 0.8);     color: #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);     border: 1px solid #00f0ff; }  .button-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .button-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  h2, h3 {     color: #fe01fe;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #00f0ff;     text-shadow: 0 0 5px rgba(254, 1, 254, 0.7); }  h2:hover, h3:hover {     text-shadow: -2px 0 #00f0ff, 2px 0 #ff004c; }  .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(0, 240, 255, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(0, 240, 255, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(0, 0, 35, 0.8);     border: 1px solid #00f0ff;     color: #00ff9d;     font-family: 'Courier New', monospace;     padding: 15px;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.2), inset 0 0 30px rgba(0, 0, 35, 0.5); }  .ref-value-item {     background-color: #405060; }  .remove-ref-btn {     background: none;     border: none;     color: #ff6b6b;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(0, 0, 35, 0.6); }  ::-webkit-scrollbar-thumb {     background: #00f0ff;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #fe01fe; }  button:active::before {     content: '';     position: absolute;     top: 0;     left: 0;     width: 100%;     height: 100%;     background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.4), transparent);     animation: loading 1s infinite; }"
      },
      "medieval": {
        "title": "Medieval",
        "fileName": "medieval",
        "css": "/* Medieval Theme */ @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English&display=swap');  body {     font-family: 'Cinzel', 'IM Fell English', serif;     background-color: #2b1e12; /* Dark brown, earthy tone */     color: #d4b98a; /* Parchment-like beige */ }  .sidebar {     background-color: rgba(50, 40, 30, 0.8); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), inset 0 0 20px rgba(50, 40, 30, 0.3); }  .object-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .editor {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #b8860b;     box-shadow: 0 0 15px rgba(184, 134, 11, 0.3); }  #three-js-container {     border: 1px solid rgba(138, 92, 46, 0.5); /* Bronze edge */ }  .preview-canvas-container {     border: 1px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.3); }  .preview {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(138, 92, 46, 0.5); }  .camera-controls {     background: rgba(40, 30, 20, 0.7); /* Dark stone */     border: 1px solid #8a5c2e; }  .camera-controls button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a; }  .camera-controls .color-picker {     border: 1px solid #8a5c2e; }  .camera-controls .size-slider {     background: #3c2f1e; /* Darker wood */     border: 1px solid #8a5c2e; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #b8860b; /* Gold text */ }  input, textarea, select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  button:hover {     background-color: rgba(138, 92, 46, 0.3);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), 0 0 20px rgba(138, 92, 46, 0.2);     transform: translateY(-2px); }  button.primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  button.primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5), 0 0 20px rgba(184, 134, 11, 0.2); }  button.danger {     background-color: rgba(139, 0, 0, 0.2); /* Crimson */     border: 1px solid #8b0000;     color: #ff4040; }  button.danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5), 0 0 20px rgba(139, 0, 0, 0.2); }  button.active {     border: 1px solid #228b22; /* Forest green */     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5);     color: #228b22; }  .modal {     background-color: rgba(40, 30, 20, 0.85); /* Stone texture */     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(50, 40, 30, 0.9);     border: 1px solid #8a5c2e;     box-shadow: 0 0 30px rgba(138, 92, 46, 0.3), 0 0 60px rgba(138, 92, 46, 0.1); }  .property-list {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6); }  .tab-navigation {     border-bottom: 1px solid #8a5c2e; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(138, 92, 46, 0.1); }  .tab.active {     border-bottom: 3px solid #b8860b;     box-shadow: 0 5px 10px -5px rgba(184, 134, 11, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(60, 50, 40, 0.6);     border-left: 4px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.2); }  #grid-display {     background-color: rgba(40, 30, 20, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 10px rgba(138, 92, 46, 0.3); }  .success-message {     color: #228b22; /* Forest green */     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(139, 0, 0, 0.1);     border-left: 4px solid #8b0000;     box-shadow: 0 0 10px rgba(139, 0, 0, 0.2); }  .main-content-container {     background-color: #251a10; /* Darker brown */     color: #d4b98a; }  .content-sidebar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-right: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-left: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  .grid-background {     background: #1e150d;     background-image: radial-gradient(rgba(138, 92, 46, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-bottom: 1px solid #8a5c2e; }  .btn {     border: 1px solid #8a5c2e;     background-color: rgba(138, 92, 46, 0.1);     color: #d4b98a;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(138, 92, 46, 0.2);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  .btn-primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  .btn-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .btn-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  .btn-secondary {     background-color: rgba(138, 92, 46, 0.15);     border: 1px solid #8a5c2e; }  .btn-secondary:hover {     background-color: rgba(138, 92, 46, 0.25);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .btn-special {     background-color: rgba(34, 139, 34, 0.2); /* Forest green */     border: 1px solid #228b22;     color: #228b22; }  .btn-special:hover {     background-color: rgba(34, 139, 34, 0.3);     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(138, 92, 46, 0.2); }  .shape-item {     background-color: rgba(60, 50, 40, 0.6);     border: 1px solid #8a5c2e; }  .shape-item:hover {     background-color: rgba(138, 92, 46, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(34, 139, 34, 0.1);     border-color: #228b22;     color: #228b22;     box-shadow: 0 0 10px rgba(34, 139, 34, 0.3); }  #inspector {     background: rgba(60, 50, 40, 0.8);     border-top: 1px solid #8a5c2e; }  .form-row label {     color: #b8860b; }  .form-row input, .form-row select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  .scene-info {     background: rgba(40, 30, 20, 0.8);     color: #d4b98a;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3);     border: 1px solid #8a5c2e; }  .button-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .button-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  h2, h3 {     color: #b8860b;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #8a5c2e;     text-shadow: 0 0 5px rgba(184, 134, 11, 0.7); }   .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(138, 92, 46, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(138, 92, 46, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(60, 50, 40, 0.8);     border: 1px solid #8a5c2e;     color: #228b22; /* Green ink */     font-family: 'IM Fell English', serif;     padding: 15px;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.2), inset 0 0 30px rgba(60, 50, 40, 0.5); }  .ref-value-item {     background-color: #4a3a2a; /* Darker wood */ }  .remove-ref-btn {     background: none;     border: none;     color: #ff4040;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(60, 50, 40, 0.6); }  ::-webkit-scrollbar-thumb {     background: #8a5c2e;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #b8860b; }  /* Category Styling for Medieval Theme */ .type-selector {     background-color: rgba(50, 40, 30, 0.7); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: inset 0 0 10px rgba(138, 92, 46, 0.3); }  .category-header {     background-color: rgba(60, 50, 40, 0.8); /* Aged wood */     border: 1px solid #8a5c2e;     color: #d4b98a; /* Parchment beige */     text-transform: uppercase;     letter-spacing: 1px;     font-weight: bold; }  .category-header:hover {     background-color: rgba(138, 92, 46, 0.2); /* Bronze hover */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .category-types {     background-color: rgba(40, 30, 20, 0.6); /* Dark stone */ }  .object-type-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  .object-type-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-type-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .object-list {     background-color: rgba(50, 40, 30, 0.5); /* Slightly lighter wood */ }"
      },
      "Neon Dune": {
        "title": "Neon Dune",
        "fileName": "Neon Dune",
        "css": "body { background-color: #1a0f05; color: #ffffff; font-family: 'Arial', sans-serif; }\r\n\r\nh1, h2, h3 { color: #00ffbf; }\r\n\r\n.button-primary { background-color: #00ffbf; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; }\r\n.button-primary:hover { transform: scale(1.05); box-shadow: 0 0 15px #00ffbf; }\r\n\r\n.link { color: #00ffbf; text-decoration: none; }\r\n.link:hover { text-decoration: underline; }\r\n\r\n.card { background-color: #2d1e13; border-radius: 10px; padding: 20px; margin: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n\r\ninput, textarea { background-color: #2d1e13; color: #ffffff; border: 1px solid #00ffbf; padding: 8px; border-radius: 5px; }\r\n\r\nheader { background-color: #00ffbf; padding: 20px; text-align: center; box-shadow: 0 4px 6px rgba(0,255,191,0.3); }\r\n\r\nfooter { background-color: #2d1e13; color: #ffffff; padding: 20px; text-align: center; border-top: 1px solid #00ffbf; }\r\n"
      },
      "professional2": {
        "title": "Professional Warm",
        "fileName": "professional2",
        "css": "/* Professional Cyberpunk Variation - Warm Edition */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #2b1e1e; /* Deep reddish-brown */     color: #f4e1d2; /* Soft cream for text */     line-height: 1.6; }  .sidebar {     background-color: rgba(54, 36, 36, 0.95); /* Muted dark red */     border: 1px solid #7a4e4e; /* Subtle reddish-gray */     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.2); }  .object-item {     background-color: rgba(54, 36, 36, 0.8);     border-left: 2px solid #d97706; /* Warm amber */     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(217, 119, 6, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(217, 119, 6, 0.25);     border-left: 3px solid #d97706;     box-shadow: 0 0 6px rgba(217, 119, 6, 0.4); }  .editor {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #three-js-container {     border: 1px solid rgba(122, 78, 78, 0.6); }  .preview-canvas-container {     border: 1px solid #d97706;     box-shadow: 0 4px 12px rgba(217, 119, 6, 0.1); }  .preview {     background-color: rgba(54, 36, 36, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(122, 78, 78, 0.5); }  .camera-controls {     background: rgba(46, 28, 28, 0.9); /* Darker reddish tint */     border: 1px solid #7a4e4e; }  .camera-controls button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .camera-controls .color-picker {     border: 1px solid #7a4e4e; }  .camera-controls .size-slider {     background: #3a2424;     border: 1px solid #7a4e4e; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #d97706; /* Amber for labels */ }  input, textarea, select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #d97706;     box-shadow: 0 0 8px rgba(217, 119, 6, 0.3); }  button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  button.primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  button.danger {     background-color: rgba(220, 38, 38, 0.3); /* Softer red */     border: 1px solid #dc2626;     color: #f4e1d2; }  button.danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  button.active {     border: 1px solid #10b981; /* Emerald green for active state */     box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);     color: #10b981; }  .modal {     background-color: rgba(46, 28, 28, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 8px 24px rgba(122, 78, 78, 0.2); }  .property-list {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8); }  .tab-navigation {     border-bottom: 1px solid #7a4e4e; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(122, 78, 78, 0.2); }  .tab.active {     border-bottom: 2px solid #d97706;     box-shadow: 0 4px 8px -4px rgba(217, 119, 6, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(54, 36, 36, 0.8);     border-left: 3px solid #d97706;     box-shadow: 0 2px 6px rgba(217, 119, 6, 0.1); }  #grid-display {     background-color: rgba(46, 28, 28, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .success-message {     color: #10b981; /* Emerald green for success */     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(220, 38, 38, 0.15);     border-left: 3px solid #dc2626;     box-shadow: 0 2px 6px rgba(220, 38, 38, 0.1); }  .main-content-container {     background-color: #332121; /* Slightly lighter reddish-brown */     color: #f4e1d2; }  .content-sidebar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-right: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-left: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .grid-background {     background: #2b1e1e;     background-image: radial-gradient(rgba(122, 78, 78, 0.15) 1px, transparent 1px);     background-size:30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-bottom: 1px solid #7a4e4e; }  .btn {     border: 1px solid #7a4e4e;     background-color: rgba(122, 78, 78, 0.3);     color: #f4e1d2;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  .btn-primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  .btn-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .btn-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  .btn-secondary {     background-color: rgba(122, 78, 78, 0.25);     border: 1px solid #7a4e4e; }  .btn-secondary:hover {     background-color: rgba(122, 78, 78, 0.4);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .btn-special {     background-color: rgba(16, 185, 129, 0.3);     border: 1px solid #10b981;     color: #f4e1d2; }  .btn-special:hover {     background-color: rgba(16, 185, 129, 0.5);     box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(122, 78, 78, 0.3); }  .shape-item {     background-color: rgba(54, 36, 36, 0.8);     border: 1px solid #7a4e4e;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(122, 78, 78, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(16, 185, 129, 0.15);     border-color: #10b981;     color: #10b981;     box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); }  #inspector {     background: rgba(54, 36, 36, 0.95);     border-top: 1px solid #7a4e4e; }  .form-row label {     color: #d97706; }  .form-row input, .form-row select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1); }  .scene-info {     background: rgba(46, 28, 28, 0.9prisma);     color: #f4e1d2;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15);     border: 1px solid #7a4e4e; }  .button-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .button-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  h2, h3 {     color: #d97706;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #7a4e4e;     text-shadow: 0 0 4px rgba(217, 119, 6, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(54, 36, 36, 0.8); }  ::-webkit-scrollbar-thumb {     background: #7a4e4e;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #d97706; }"
      },
      "professional": {
        "title": "Professional",
        "fileName": "professional",
        "css": "/* Professional Theme */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #1a1a2e;     color: #e6e6fa;     line-height: 1.6; }  .sidebar {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.2); }  .object-item {     background-color: rgba(34, 34, 54, 0.8);     border-left: 2px solid #8a4af0;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(138, 74, 240, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(138, 74, 240, 0.25);     border-left: 3px solid #8a4af0;     box-shadow: 0 0 6px rgba(138, 74, 240, 0.4); }  .editor {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #three-js-container {     border: 1px solid rgba(75, 94, 135, 0.6); }  .preview-canvas-container {     border: 1px solid #8a4af0;     box-shadow: 0 4px 12px rgba(138, 74, 240, 0.1); }  .preview {     background-color: rgba(34, 34, 54, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(75, 94, 135, 0.5); }  .camera-controls {     background: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87; }  .camera-controls button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .camera-controls .color-picker {     border: 1px solid #4b5e87; }  .camera-controls .size-slider {     background: #2a2a42;     border: 1px solid #4b5e87; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #8a4af0; }  input, textarea, select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #8a4af0;     box-shadow: 0 0 8px rgba(138, 74, 240, 0.3); }  button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  button.primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  button.danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  button.danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  button.active {     border: 1px solid #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.4);     color: #00cc99; }  .modal {     background-color: rgba(26, 26, 46, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 8px 24px rgba(75, 94, 135, 0.2); }  .property-list {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8); }  .tab-navigation {     border-bottom: 1px solid #4b5e87; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(75, 94, 135, 0.2); }  .tab.active {     border-bottom: 2px solid #8a4af0;     box-shadow: 0 4px 8px -4px rgba(138, 74, 240, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(34, 34, 54, 0.8);     border-left: 3px solid #8a4af0;     box-shadow: 0 2px 6px rgba(138, 74, 240, 0.1); }  #grid-display {     background-color: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .success-message {     color: #00cc99;     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(240, 74, 74, 0.15);     border-left: 3px solid #f04a4a;     box-shadow: 0 2px 6px rgba(240, 74, 74, 0.1); }  .main-content-container {     background-color: #1f1f38;     color: #e6e6fa; }  .content-sidebar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-right: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-left: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .grid-background {     background: #1a1a2e;     background-image: radial-gradient(rgba(75, 94, 135, 0.15) 1px, transparent 1px);     background-size: 30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-bottom: 1px solid #4b5e87; }  .btn {     border: 1px solid #4b5e87;     background-color: rgba(75, 94, 135, 0.3);     color: #e6e6fa;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  .btn-primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  .btn-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .btn-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  .btn-secondary {     background-color: rgba(75, 94, 135, 0.25);     border: 1px solid #4b5e87; }  .btn-secondary:hover {     background-color: rgba(75, 94, 135, 0.4);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .btn-special {     background-color: rgba(0, 204, 153, 0.3);     border: 1px solid #00cc99;     color: #e6e6fa; }  .btn-special:hover {     background-color: rgba(0, 204, 153, 0.5);     box-shadow: 0 2px 8px rgba(0, 204, 153, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(75, 94, 135, 0.3); }  .shape-item {     background-color: rgba(34, 34, 54, 0.8);     border: 1px solid #4b5e87;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(75, 94, 135, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(0, 204, 153, 0.15);     border-color: #00cc99;     color: #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.3); }  #inspector {     background: rgba(34, 34, 54, 0.95);     border-top: 1px solid #4b5e87; }  .form-row label {     color: #8a4af0; }  .form-row input, .form-row select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1); }  .scene-info {     background: rgba(26, 26, 46, 0.9);     color: #e6e6fa;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15);     border: 1px solid #4b5e87; }  .button-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .button-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  h2, h3 {     color: #8a4af0;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #4b5e87;     text-shadow: 0 0 4px rgba(138, 74, 240, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(34, 34, 54, 0.8); }  ::-webkit-scrollbar-thumb {     background: #4b5e87;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #8a4af0; }"
      },
      "professional3": {
        "title": "Claude",
        "fileName": "professional3",
        "css": "/* Eclipse Theme - A premium dark UI experience */ @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap');  :root {   --bg-primary: #0f111a;   --bg-secondary: #141725;   --bg-tertiary: #1a1d2d;   --accent-primary: #7c4dff;   --accent-secondary: #00bcd4;   --accent-tertiary: #ff4081;   --text-primary: #eceff1;   --text-secondary: #b0bec5;   --border-light: rgba(99, 114, 166, 0.25);   --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);   --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);   --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);   --gradient-bg: linear-gradient(135deg, rgba(20, 23, 37, 0.95), rgba(15, 17, 26, 0.95));   --gradient-accent: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); }  body {   font-family: 'Space Grotesk', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6;   transition: background-color 0.3s ease;   background-image:      radial-gradient(circle at 15% 15%, rgba(124, 77, 255, 0.08) 0%, transparent 25%),     radial-gradient(circle at 85% 85%, rgba(0, 188, 212, 0.08) 0%, transparent 25%); }  /* Modern sidebar with glassmorphism effect */ .sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--text-secondary);   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   margin-bottom: 4px;   border-radius: 0 4px 4px 0; }  .object-item:hover {   background-color: rgba(124, 77, 255, 0.1);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   transform: translateX(2px); }  .object-item.selected {   background: linear-gradient(90deg, rgba(124, 77, 255, 0.15), rgba(124, 77, 255, 0.05));   border-left: 3px solid var(--accent-primary);   color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   font-weight: 600; }  /* Editor area with polished look */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  #three-js-container {   border: 1px solid var(--border-light);   border-radius: 6px;   box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);   background: rgba(15, 17, 26, 0.5); }  .preview-canvas-container {   border: 1px solid var(--accent-primary);   box-shadow: 0 0 16px rgba(124, 77, 255, 0.15);   border-radius: 6px;   overflow: hidden; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-light);   border-radius: 4px; }  /* Enhanced camera controls with dynamic hover effects */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px;   box-shadow: var(--shadow-sm); }  .camera-controls button {   background-color: rgba(99, 114, 166, 0.15);   border: 1px solid var(--border-light);   color: var(--text-primary);   border-radius: 4px;   padding: 8px 12px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .camera-controls button:hover {   background-color: rgba(124, 77, 255, 0.15);   border-color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   transform: translateY(-2px) scale(1.02); }  .camera-controls button:active {   transform: translateY(1px); }  .camera-controls .color-picker {   border: 1px solid var(--border-light);   border-radius: 4px;   overflow: hidden;   box-shadow: var(--shadow-sm); }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-light);   border-radius: 4px;   height: 6px;   box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.2); }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.4);   border-radius: 50%;   cursor: pointer;   transition: all 0.2s ease; }  .camera-controls .size-slider::-webkit-slider-thumb:hover {   transform: scale(1.2); }  /* Form elements with attractive focus states */ label {   font-weight: 500;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--accent-primary);   margin-bottom: 6px;   display: block;   font-size: 0.85rem; }  input, textarea, select {   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   border-radius: 4px;   padding: 10px 12px;   box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);   transition: all 0.3s ease;   font-family: 'JetBrains Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 3px rgba(124, 77, 255, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.1);   background-color: rgba(20, 23, 37, 0.8); }  /* Modern button styles with micro-interactions */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden; }  button:hover {   background-color: rgba(99, 114, 166, 0.2);   border-color: var(--border-light);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);   transform: translateY(-2px); }  button:active {   transform: translateY(1px); }  button::after {   content: '';   position: absolute;   top: 50%;   left: 50%;   width: 100%;   height: 100%;   background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 50%);   transform: scale(0);   opacity: 0;   transition: transform 0.5s, opacity 0.3s;   pointer-events: none; }  button:active::after {   transform: scale(2);   opacity: 1;   transition: 0s; }  button.primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  button.primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.3); }  button.primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  button.primary:hover::before {   opacity: 0.1; }  button.danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  button.danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  button.active {   border: 1px solid var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.3);   color: var(--accent-secondary);   background-color: rgba(0, 188, 212, 0.15); }  /* Modal with glassmorphism effect */ .modal {   background-color: rgba(15, 17, 26, 0.7);   backdrop-filter: blur(8px);   -webkit-backdrop-filter: blur(8px); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-lg);   border-radius: 8px;   overflow: hidden;   animation: modalAppear 0.3s ease; }  @keyframes modalAppear {   from {     opacity: 0;     transform: scale(0.95) translateY(-10px);   }   to {     opacity: 1;     transform: scale(1) translateY(0);   } }  .property-list {   border: 1px solid var(--border-light);   background-color: var(--bg-tertiary);   border-radius: 6px;   overflow: hidden; }  /* Tab navigation with smooth transitions */ .tab-navigation {   border-bottom: 1px solid var(--border-light);   display: flex;   gap: 4px;   padding: 0 6px; }  .tab {   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   color: var(--text-secondary);   position: relative;   transition: all 0.3s ease;   border-radius: 4px 4px 0 0; }  .tab:hover {   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 600;   background-color: rgba(124, 77, 255, 0.05); }  .tab.active::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   right: 0;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Stylized instructions and warnings */ .instructions {   background-color: rgba(124, 77, 255, 0.05);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .instructions::before {   content: 'i';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: var(--accent-primary);   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   font-style: italic;   color: white;   font-size: 14px; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  .success-message {   color: #4caf50;   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px;   background-color: rgba(76, 175, 80, 0.1);   border-radius: 4px;   display: inline-block; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(244, 67, 54, 0.1);   border-left: 3px solid #f44336;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .warning::before {   content: '!';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: #f44336;   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   color: white;   font-size: 14px; }  /* Content containers with subtle gradients */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  #graphics-rightbar {   background: var(--gradient-bg);   border-left: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(99, 114, 166, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(99, 114, 166, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar with subtle glassmorphism */ .toolbar {   background: var(--gradient-bg);   border-bottom: 1px solid var(--border-light);   box-shadow: var(--shadow-sm);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations with consistent styling */ .btn {   border: 1px solid var(--border-light);   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 8px 14px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden;   font-size: 0.85rem; }  .btn:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);   transform: translateY(-2px); }  .btn:active {   transform: translateY(1px); }  .btn-primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  .btn-primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.2); }  .btn-primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  .btn-primary:hover::before {   opacity: 0.1; }  .btn-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  .btn-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  .btn-secondary {   background-color: rgba(99, 114, 166, 0.1);   border: 1px solid var(--border-light); }  .btn-secondary:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }  .btn-special {   background-color: rgba(0, 188, 212, 0.15);   border: 1px solid var(--accent-secondary);   color: var(--accent-secondary); }  .btn-special:hover {   background-color: rgba(0, 188, 212, 0.25);   box-shadow: 0 4px 16px rgba(0, 188, 212, 0.2); }  /* Shape list with improved visual hierarchy */ #shape-list {   border-bottom: 1px solid var(--border-light);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 4px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: rgba(99, 114, 166, 0.15);   transform: translateX(3px);   border-color: var(--border-light); }  .shape-item.active {   background-color: rgba(0, 188, 212, 0.1);   border-color: var(--accent-secondary);   color: var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.15);   font-weight: 500; }  /* Inspector panel with clean design */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-light);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--accent-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   padding: 10px 12px;   border-radius: 4px; }  /* Scene info with modern styling */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px 16px;   margin-bottom: 16px;   box-shadow: var(--shadow-sm); }  .button-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336;   padding: 10px 16px;   border-radius: 4px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .button-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2);   transform: translateY(-2px); }  /* Typography improvements */ h2, h3 {   color: var(--accent-primary);   text-transform: uppercase;   letter-spacing: 1px;   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-light);   font-weight: 600;   text-shadow: 0 0 20px rgba(124, 77, 255, 0.3);   position: relative; }  h2::after, h3::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   width: 50px;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Sleek scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(124, 77, 255, 0.3);   border-radius: 3px;   border: 1px solid var(--bg-tertiary); }  ::-webkit-scrollbar-thumb:hover {   background: var(--accent-primary); }  /* Animations and transitions */ @keyframes pulse {   0% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0.4); }   70% { box-shadow: 0 0 0 10px rgba(124, 77, 255, 0); }   100% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0); } }  .pulse-animation {   animation: pulse 2s infinite; }  /* Tooltips */ [data-tooltip] {   position: relative; }  [data-tooltip]::after {   content: attr(data-tooltip);   position: absolute;   bottom: 125%;   left: 50%;   transform: translateX(-50%);   padding: 6px 10px;   background: var(--bg-tertiary);   color: var(--text-primary);   border-radius: 4px;   font-size: 0.75rem;   white-space: nowrap;   opacity: 0;   visibility: hidden;   transition: all 0.3s ease;   z-index: 100;   box-shadow: var(--shadow-md);   border: 1px solid var(--border-light); }  [data-tooltip]:hover::after {   opacity: 1;   visibility: visible; }"
      },
      "scifi2": {
        "title": "SciFi2.0",
        "fileName": "scifi2",
        "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap'); :root {     --primary-bg: #0a0a1a;     --secondary-bg: #121228;     --accent-color: #00ffff;     --text-color: #e0e7ff;     --border-color: #2a2a4a;     --highlight-color: #ff00ff;     --hover-color: rgba(0, 255, 255, 0.2); }  body {     background-color: var(--primary-bg);     color: var(--text-color);     font-family: 'Orbitron', 'Arial', sans-serif;     line-height: 1.6; }  .container {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 20px rgba(0, 255, 255, 0.1); }  /* Sidebar Styling */ .sidebar {     background-color: #0f0f2a;     border-right: 1px solid var(--border-color); }  .object-item, .object-type-item {     background-color: var(--secondary-bg);     border: 1px solid var(--border-color);     color: var(--text-color);     transition: all 0.3s ease; }  .object-item:hover, .object-type-item:hover {     background-color: var(--hover-color);     border-color: var(--accent-color); }  .object-item.selected, .object-type-item.selected {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Button Styling */ button {     background-color: var(--secondary-bg);     color: var(--accent-color);     border: 2px solid var(--accent-color);     transition: all 0.3s ease;     position: relative;     overflow: hidden; }  button:before {     content: '';     position: absolute;     top: 0;     left: -100%;     width: 100%;     height: 100%;     background: linear-gradient(120deg, transparent, var(--highlight-color), transparent);     transition: all 0.5s ease; }  button:hover:before {     left: 100%; }  button:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  .primary {     background-color: var(--accent-color);     color: var(--primary-bg); }  .danger {     border-color: #ff4444;     color: #ff4444; }  /* Input Styling */ input, textarea, select {     background-color: var(--secondary-bg);     color: var(--text-color);     border: 1px solid var(--border-color);     transition: border-color 0.3s ease; }  input:focus, textarea:focus, select:focus {     border-color: var(--accent-color);     outline: none;     box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }  /* Modal Styling */ .modal {     background-color: rgba(10, 10, 26, 0.9); }  .modal-content {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 30px rgba(0, 255, 255, 0.1); }  /* Graphics Editor Enhancements */ #canvas-container {     background:          linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0,         linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0;     background-size: 20px 20px;     background-color: var(--primary-bg); }  .scene-info {     background-color: rgba(18, 18, 40, 0.8);     border: 1px solid var(--border-color);     color: var(--accent-color); }  /* Toolbar Styling */ .toolbar .btn {     background-color: var(--secondary-bg);     border-color: var(--border-color);     color: var(--accent-color); }  .toolbar .btn:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Tab and Category Styling */ .tab, .category-header {     color: var(--text-color);     transition: color 0.3s ease; }  .tab:hover, .category-header:hover {     color: var(--accent-color); }  .tab.active {     border-bottom-color: var(--accent-color); }  /* Scrollbar (for browsers that support) */ ::-webkit-scrollbar {     width: 10px; }  ::-webkit-scrollbar-track {     background: var(--secondary-bg); }  ::-webkit-scrollbar-thumb {     background: var(--accent-color);     border-radius: 5px; }  ::-webkit-scrollbar-thumb:hover {     background: var(--highlight-color); }  /* Subtle Sci-Fi Animations */ @keyframes pulse-border {     0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }     50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); } }  @keyframes grid-pulse {     0%, 100% { opacity: 0.1; }     50% { opacity: 0.3; } }  /* Additional Futuristic Effects */ body::before {     content: '';     position: fixed;     top: 0;     left: 0;     width: 100%;     height: 100%;     pointer-events: none;     background:          repeating-linear-gradient(             0deg,             rgba(0, 0, 0, 0.15),             rgba(0, 0, 0, 0.15) 1px,             transparent 1px,             transparent 2px         );     opacity: 0.3;     z-index: 9999; }"
      },
      "videogame": {
        "title": "Video Game",
        "fileName": "videogame",
        "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');  body {     font-family: 'Orbitron', 'Share Tech Mono', sans-serif;     background-color: #0a0a0a; /* Deep black */     color: #00d4ff; /* Neon blue */     overflow: hidden; }  .sidebar {     background: linear-gradient(135deg, rgba(10, 10, 10, 0.9), rgba(155, 0, 255, 0.1)); /* Black to purple fade */     border: 1px solid #ff007a; /* Hot pink */     box-shadow: 0 0 15px rgba(0, 212, 255, 0.5), inset 0 0 10px rgba(155, 0, 255, 0.3); }  .inventory-item {     background-color: rgba(12, 12, 12, 0.7);     border-left: 3px solid #9b00ff; /* Electric purple */     text-transform: uppercase;     letter-spacing: 2px;     transition: all 0.2s ease; }  .inventory-item:hover {     background-color: rgba(0, 212, 255, 0.2);     transform: scale(1.03);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.7); }  .inventory-item.active {     background-color: rgba(255, 0, 122, 0.3); /* Pink glow */     border-left: 5px solid #ff007a;     box-shadow: 0 0 15px rgba(255, 0, 122, 0.8); }  .hud {     background: rgba(10, 10, 10, 0.8);     border: 1px solid #00d4ff;     box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }  #game-canvas {     border: 1px dashed #c0c0c0; /* Silver dashed */     background: radial-gradient(circle, rgba(155, 0, 255, 0.1), transparent); }  .hologram-display {     border: 2px solid #9b00ff;     box-shadow: 0 0 25px rgba(155, 0, 255, 0.6);     animation: pulseGlow 2s infinite alternate; }  @keyframes pulseGlow {     0% { box-shadow: 0 0 25px rgba(155, 0, 255, 0.6); }     100% { box-shadow: 0 0 35px rgba(155, 0, 255, 0.9); } }  .control-panel {     background: rgba(0, 0, 0, 0.85);     border: 1px solid #c0c0c0; }  .control-panel button {     background-color: rgba(0, 212, 255, 0.2);     border: 1px solid #00d4ff;     color: #fff;     text-transform: uppercase;     transition: all 0.3s ease; }  .control-panel button:hover {     background-color: rgba(0, 212, 255, 0.4);     box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);     transform: translateY(-3px); }  label {     color: #ff007a; /* Hot pink */     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1.5px; }  input, textarea, select {     border: 1px solid #9b00ff;     background-color: rgba(10, 10, 10, 0.7);     color: #00d4ff;     box-shadow: 0 0 8px rgba(155, 0, 255, 0.4); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #ff007a;     box-shadow: 0 0 12px rgba(255, 0, 122, 0.7); }  button {     background-color: rgba(155, 0, 255, 0.2);     border: 1px solid #9b00ff;     color: #fff;     text-transform: uppercase;     letter-spacing: 1px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(155, 0, 255, 0.4);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.7);     transform: translateY(-2px) scale(1.05); }  button.primary {     background-color: rgba(0, 212, 255, 0.3);     border: 1px solid #00d4ff;     color: #fff; }  button.primary:hover {     background-color: rgba(0, 212, 255, 0.5);     box-shadow: 0 0 20px rgba(0, 212, 255, 0.9); }  button.alert {     background-color: rgba(255, 0, 122, 0.2);     border: 1px solid #ff007a;     color: #fff; }  button.alert:hover {     background-color: rgba(255, 0, 122, 0.4);     box-shadow: 0 0 15px rgba(255, 0, 122, 0.7); }  .modal {     background: rgba(0, 0, 0, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background: linear-gradient(45deg, rgba(10, 10, 10, 0.9), rgba(0, 212, 255, 0.1));     border: 1px solid #00d4ff;     box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }  .notification {     background-color: rgba(155, 0, 255, 0.3);     border-left: 4px solid #9b00ff;     color: #fff;     animation: slideIn 0.5s ease-out; }  @keyframes slideIn {     0% { transform: translateX(100%); opacity: 0; }     100% { transform: translateX(0); opacity: 1; } }  .main-content {     background: #0a0a0a;     animation: glitch 4s infinite; }   .grid-overlay {     background: repeating-linear-gradient(45deg, rgba(155, 0, 255, 0.05), rgba(155, 0, 255, 0.05) 10px, transparent 10px, transparent 20px); }  .btn {     border: 1px solid #c0c0c0;     background-color: rgba(0, 212, 255, 0.15);     color: #fff; }  .btn:hover {     background-color: rgba(0, 212, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.6); }  .btn-primary {     background-color: rgba(9b, 0, 255, 0.25);     border: 1px solid #9b00ff; }  .btn-primary:hover {     background-color: rgba(155, 0, 255, 0.45);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.8); }  ::-webkit-scrollbar {     width: 6px; }  ::-webkit-scrollbar-track {     background: #0a0a0a; }  ::-webkit-scrollbar-thumb {     background: #00d4ff;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #ff007a; }"
      },
      "videoGame2": {
        "title": "Video Game 2",
        "fileName": "videoGame2",
        "css": "/* retro-theme.css - Pixel Art Retro Video Game Theme */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base Styles */\r\nbody {\r\n    background-color: #1a1a1a; /* Dark retro background */\r\n    font-family: 'Press Start 2P', cursive; /* Pixelated font */\r\n    image-rendering: pixelated; /* Ensures crisp pixel art rendering */\r\n    color: #fff; /* Default text color */\r\n}\r\n\r\n/* Container */\r\n.container {\r\n    background: #2b2b2b; /* Retro gray */\r\n    border: 4px solid #000; /* Thick black border */\r\n    padding: .5em;\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    background: #3c3c3c; /* Mid-gray retro */\r\n    border: 4px solid #000;\r\n}\r\n\r\n.sidebar img {\r\n    image-rendering: pixelated;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n/* Object List */\r\n.object-item {\r\n    background: #5a5a5a; /* Darker gray */\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px; /* Smaller for pixel readability */\r\n}\r\n\r\n.object-item:hover, .object-item.selected {\r\n    background: #ffcc00; /* Bright retro yellow */\r\n    color: #000;\r\n}\r\n.object-type-item.selected {\r\n    color: #ffcc00;\r\n}\r\n\r\n/* Buttons */\r\nbutton {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    text-transform: uppercase; /* Retro game style */\r\n    transition: background 0.1s ease;\r\n}\r\n\r\nbutton:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\nbutton.primary {\r\n    background: #33cc33; /* Green for primary actions */\r\n}\r\n\r\nbutton.primary:hover {\r\n    background: #ffcc00; /* Yellow on hover */\r\n}\r\n\r\n/* Main Content */\r\n.main-content {\r\n    background: #2b2b2b;\r\n}\r\n\r\n/* Editor */\r\n.editor {\r\n    background: #3c3c3c;\r\n    border: 4px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Canvas and Grid Containers */\r\n#canvas-container, .grid-container {\r\n    background: #000; /* Black canvas background */\r\n    border: 4px solid #fff;\r\n}\r\n\r\n#canvas, #grid {\r\n    image-rendering: pixelated;\r\n    background: repeating-linear-gradient(\r\n        45deg,\r\n        #333 0px,\r\n        #333 10px,\r\n        #000 10px,\r\n        #000 20px\r\n    ); /* Retro checkerboard grid */\r\n}\r\n\r\n.scene-info {\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border: 2px solid #fff;\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 8px;\r\n}\r\n\r\n/* Toolbar */\r\n.toolbar {\r\n    background: #5a5a5a;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.btn {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    transition: background 0.1s ease;\r\n}\r\n\r\n.btn:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\n.btn.btn-danger {\r\n    background: #ff0000; /* Bright red */\r\n}\r\n\r\n.btn.btn-danger:hover {\r\n    background: #cc0000; /* Darker red */\r\n}\r\n\r\n.btn.btn-secondary {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.btn.btn-secondary:hover {\r\n    background: #9999ff; /* Lighter blue */\r\n}\r\n\r\n.btn.btn-special {\r\n    background: #ff00ff; /* Retro magenta */\r\n}\r\n\r\n.btn.btn-special:hover {\r\n    background: #cc00cc; /* Darker magenta */\r\n}\r\n\r\n/* Modals */\r\n.modal {\r\n    background: rgba(0, 0, 0, 0.8);\r\n}\r\n\r\n.modal-content {\r\n    background: #3c3c3c;\r\n    border: 4px solid #fff;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Form Elements */\r\n.form-group label {\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 10px;\r\n}\r\n\r\ninput, textarea, select {\r\n    background: #000;\r\n    border: 2px solid #fff;\r\n    color: #ffcc00; /* Retro yellow */\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n}\r\n\r\ninput[type=\"color\"] {\r\n    padding: 0; /* Fix color picker padding */\r\n    height: 20px; /* Consistent height */\r\n}\r\n\r\n/* Tabs */\r\n.tab-navigation {\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.tab {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.tab.active {\r\n    background: #ffcc00; /* Yellow for active tab */\r\n    color: #000;\r\n}\r\n\r\n/* Inspector and JSON Editor */\r\n#inspector, #json-editor {\r\n    background: #3c3c3c;\r\n    border: 2px solid #000;\r\n}\r\n\r\n#json-content {\r\n    background: #000;\r\n    color: #00ff00; /* Green for code-like text */\r\n}\r\n\r\n/* Translation Controls */\r\n.translation-controls button {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.translation-controls button:hover {\r\n    background: #9999ff;\r\n}\r\n\r\n/* Shape List */\r\n.shape-item {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.shape-item:hover {\r\n    background: #ffcc00;\r\n    color: #000;\r\n}\r\n\r\n.type-selector .object-item {\r\n  font-size: .6em;\r\n}\r\n\r\n/* codemirror-retro.css - Retro Pixel Art Theme for CodeMirror */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base CodeMirror Styles */\r\n.CodeMirror {\r\n    height: 100% !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important; /* Small size for pixel readability */\r\n    background: #000 !important; /* Black background like a CRT screen */\r\n    color: #00ff00 !important; /* Neon green default text */\r\n    border: 4px solid #fff !important; /* Thick white border */\r\n    image-rendering: pixelated; /* Crisp rendering */\r\n}\r\n.CodeMirror-gutters {\r\n background-color: #000;\r\n}\r\n\r\n/* Retro Theme Definition */\r\n.cm-s-retro .CodeMirror-gutters {\r\n    background: #1a1a1a !important; /* Dark gray gutter */\r\n    border-right: 2px solid #fff !important; /* White separator */\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-linenumber {\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n    padding: 0 5px !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-cursor {\r\n    border-left: 2px solid #ff3333 !important; /* Red blinking cursor */\r\n    animation: blink 1s step-end infinite; /* Retro blink effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-selected {\r\n    background: #ff3333 !important; /* Red selection highlight */\r\n    opacity: 0.5; /* Slightly transparent for retro effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-focused .CodeMirror-selected {\r\n    background: #ff3333 !important;\r\n}\r\n\r\n/* Syntax Highlighting */\r\n.cm-s-retro .cm-comment {\r\n    color: #6666ff !important; /* Blue for comments */\r\n    font-style: italic; /* Slight retro flair */\r\n}\r\n\r\n.cm-s-retro .cm-string {\r\n    color: #ffcc00 !important; /* Yellow for strings */\r\n}\r\n\r\n.cm-s-retro .cm-number {\r\n    color: #33cc33 !important; /* Green for numbers */\r\n}\r\n\r\n.cm-s-retro .cm-keyword {\r\n    color: #ff00ff !important; /* Magenta for keywords */\r\n    font-weight: bold; /* Bold for emphasis */\r\n}\r\n\r\n.cm-s-retro .cm-operator {\r\n    color: #fff !important; /* White for operators */\r\n}\r\n\r\n.cm-s-retro .cm-variable {\r\n    color: #00ff00 !important; /* Green for variables */\r\n}\r\n\r\n.cm-s-retro .cm-variable-2 {\r\n    color: #33cc33 !important; /* Lighter green for secondary variables */\r\n}\r\n\r\n.cm-s-retro .cm-def {\r\n    color: #ff00ff !important; /* Magenta for definitions */\r\n}\r\n\r\n.cm-s-retro .cm-property {\r\n    color: #ffcc00 !important; /* Yellow for properties */\r\n}\r\n\r\n.cm-s-retro .cm-function {\r\n    color: #ff00ff !important; /* Magenta for functions */\r\n}\r\n\r\n.cm-s-retro .cm-builtin {\r\n    color: #33cc33 !important; /* Green for built-ins */\r\n}\r\n\r\n.cm-s-retro .cm-tag {\r\n    color: #ff3333 !important; /* Red for tags (if HTML mode is used) */\r\n}\r\n\r\n.cm-s-retro .cm-attribute {\r\n    color: #ffcc00 !important; /* Yellow for attributes */\r\n}\r\n\r\n/* Matching Brackets */\r\n.cm-s-retro .CodeMirror-matchingbracket {\r\n    color: #33cc33 !important; /* Green for matching brackets */\r\n    border-bottom: 2px solid #33cc33 !important;\r\n    background: none !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-nonmatchingbracket {\r\n    color: #ff3333 !important; /* Red for non-matching brackets */\r\n    border-bottom: 2px solid #ff3333 !important;\r\n}\r\n\r\n/* Autocomplete Hints */\r\n.CodeMirror-hints {\r\n    background: #2b2b2b !important; /* Dark retro gray */\r\n    border: 2px solid #fff !important; /* White border */\r\n    color: #fff !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important;\r\n    box-shadow: 4px 4px 0 #000; /* Retro shadow effect */\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint {\r\n    color: #ffcc00 !important; /* Yellow for hint items */\r\n    padding: 5px !important;\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint-active {\r\n    background: #ff3333 !important; /* Red for selected hint */\r\n    color: #000 !important;\r\n}\r\n\r\n/* Scrollbars (minimal retro style) */\r\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar {\r\n    background: #3c3c3c !important;\r\n}\r\n\r\n.CodeMirror-scrollbar-filler {\r\n    background: #000 !important;\r\n}\r\n\r\n/* Animations */\r\n@keyframes blink {\r\n    50% { opacity: 0; }\r\n}"
      }
    }
  },
  "objectTypeDefinitions": [
    {
      "id": "configs",
      "name": "Configs",
      "singular": "Config",
      "category": "Settings",
      "isCore": true
    },
    {
      "id": "entities",
      "name": "Entities",
      "singular": "Entity",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "components",
      "name": "Components",
      "singular": "Component",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "renderers",
      "name": "Renderers",
      "singular": "Renderer",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "functions",
      "name": "Functions",
      "singular": "Function",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "playerPrefabs",
      "name": "Player Prefabs",
      "singular": "playerPrefab",
      "category": "Prefabs"
    },
    {
      "id": "projectilePrefabs",
      "name": "Projectiles Prefabs",
      "singular": "projectilePrefab",
      "category": "Prefabs"
    },
    {
      "id": "worldObjectPrefabs",
      "name": "World Object Prefabs",
      "singular": "worldObjectPrefab",
      "category": "Prefabs"
    },
    {
      "id": "particlePrefabs",
      "name": "Particle Prefabs",
      "singular": "particlePrefab",
      "category": "Prefabs"
    },
    {
      "id": "themes",
      "name": "Themes",
      "singular": "Theme",
      "category": "Settings",
      "isCore": true
    },
    {
      "id": "sounds",
      "name": "Sounds",
      "singular": "Sound",
      "category": "Audio",
      "isCore": true
    },
    {
      "id": "libraries",
      "name": "Libraries",
      "singular": "Library",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "interfaces",
      "name": "Interfaces",
      "singular": "Interface",
      "category": "Settings"
    },
    {
      "id": "modals",
      "name": "Modals",
      "singular": "Modal",
      "category": "Scripts"
    },
    {
      "id": "palettes",
      "name": "Palettes",
      "singular": "Palette",
      "category": "Resources"
    },
    {
      "id": "shadows",
      "name": "Shadows",
      "singular": "Shadow",
      "category": "Environment"
    },
    {
      "id": "lightings",
      "name": "Lightings",
      "singular": "lighting",
      "category": "Environment"
    },
    {
      "id": "fogs",
      "name": "Fogs",
      "singular": "Fog",
      "category": "Environment"
    },
    {
      "id": "cameras",
      "name": "Cameras",
      "singular": "Camera",
      "category": "Environment"
    },
    {
      "id": "worlds",
      "name": "Worlds",
      "singular": "World",
      "category": "Environment"
    },
    {
      "id": "textures",
      "name": "Textures",
      "singular": "Texture",
      "category": "Resources"
    },
    {
      "id": "materials",
      "name": "Materials",
      "singular": "Material",
      "category": "Resources"
    },
    {
      "id": "shaders",
      "name": "Shaders",
      "singular": "Shader",
      "category": "Resources"
    },
    {
      "id": "editorModules",
      "name": "editorModules",
      "singular": "editorModule",
      "category": "Settings"
    },
    {
      "id": "attackSounds",
      "name": "AttackSounds",
      "singular": "attackSound",
      "category": "Audio"
    },
    {
      "id": "hitSounds",
      "name": "HitSounds",
      "singular": "hitSound",
      "category": "Audio"
    },
    {
      "id": "heightMaps",
      "name": "HeightMaps",
      "singular": "heightMap",
      "category": "Environment"
    },
    {
      "id": "inputDataTypes",
      "name": "InputDataTypes",
      "singular": "inputDataType",
      "category": "Settings"
    },
    {
      "id": "inputElementTypes",
      "name": "InputElementTypes",
      "singular": "inputElementType",
      "category": "Settings"
    },
    {
      "id": "levels",
      "name": "Levels",
      "singular": "level",
      "category": "Environment"
    },
    {
      "id": "scenes",
      "name": "Scenes",
      "singular": "Scene",
      "category": "Environment"
    },
    {
      "id": "noiseSettings",
      "name": "Noise Settings",
      "singular": "noiseSetting",
      "category": "Environment"
    },
    {
      "id": "biomes",
      "name": "Biomes",
      "singular": "biome",
      "category": "Environment"
    },
    {
      "id": "worldObjectSpawns",
      "name": "World Object Spawns",
      "singular": "worldObjectSpawn",
      "category": "Environment"
    },
    {
      "id": "enemyPrefabs",
      "name": "Enemy Prefabs",
      "singular": "enemyPrefab",
      "category": "Prefabs"
    },
    {
      "id": "colliders",
      "name": "Colliders",
      "singular": "collider",
      "category": "Component Instance Data"
    },
    {
      "id": "projectiles",
      "name": "Projectiles",
      "singular": "projectile",
      "category": "Component Instance Data"
    },
    {
      "id": "infiniWorlds",
      "name": "InfiniWorlds",
      "singular": "InfiniWorld",
      "category": "Component Instance Data"
    },
    {
      "id": "gamePrefabs",
      "name": "Game Prefabs",
      "singular": "gamePrefab",
      "category": "Prefabs"
    }
  ]
}