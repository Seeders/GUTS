{
  "objectTypes": {
    "components": {
      "Animator": {
        "script": "class Animator extends engine.Component {\r\n    \r\n    constructor(game, parent, params) {\r\n        super(game, parent, params);\r\n        \r\n    }\r\n    \r\n    \r\n    init({ objectType, spawnType}) {\r\n\r\n        this.animations = this.game.imageManager.getImages(objectType, spawnType); // { \"idle\": [...], \"walk\": [...] }\r\n        this.currentAnimation = \"idle\";\r\n        if(this.animations.walk) this.currentAnimation = \"walk\";\r\n        this.currentFrame = 0;\r\n        this.frameDuration = .166; // 10 frames per animation frame (~0.166s at 60 FPS)\r\n        this.frameTimer = 0;\r\n\r\n        this.baseSpeed = this.parent.getComponent(\"stats\")?.stats.speed || 1;\r\n    }\r\n\r\n    update() {\r\n        \r\n        this.frameTimer += this.game.deltaTime;\r\n        let currentSpeedPercent = this.parent.getComponent(\"stats\")?.stats.speed / this.baseSpeed || 1;\r\n\r\n        if (this.frameTimer >= this.frameDuration / currentSpeedPercent) {\r\n            this.frameTimer = 0;\r\n            const animFrames = this.animations[this.currentAnimation];\r\n            this.currentFrame = (this.currentFrame + 1) % animFrames.length;\r\n        }\r\n        // Sync direction with Renderer (if separate)\r\n        const renderer = this.parent.getComponent(\"Renderer\");\r\n        if (renderer) {\r\n            renderer.images = this.animations[this.currentAnimation][this.currentFrame];\r\n        }\r\n    }\r\n\r\n    setAnimation(animationType) {\r\n        if (this.animations[animationType] && this.currentAnimation !== animationType) {\r\n            this.currentAnimation = animationType;\r\n            this.currentFrame = 0;\r\n            this.frameTimer = 0;\r\n        }\r\n    }\r\n    \r\n}",
        "filePath": "/global/components/js/Animator.js",
        "fileName": "Animator"
      },
      "ArrayTracker": {
        "script": "class ArrayTracker extends engine.Component {\r\n\r\n    init( {objectType}) {\r\n        this.arr = objectType;\r\n        if(!this.game.state[this.arr]){\r\n            this.game.state[this.arr] = [];\r\n        }\r\n        this.game.state[this.arr].push(this.parent);\r\n    }\r\n\r\n    destroy(){\r\n        let index = this.game.state[this.arr].indexOf(this.parent);\r\n        this.game.state[this.arr].splice(index, 1);        \r\n    }\r\n}",
        "filePath": "/global/components/js/ArrayTracker.js",
        "fileName": "ArrayTracker"
      },
      "Effect": {
        "script": "class Effect extends engine.Component {\r\n    \r\n    constructor(game, parent, params) {\r\n        super(game, parent, params);\r\n    }\r\n    \r\n    \r\n    init( {config, applyFn, amount }) {\r\n        this.id = config.id;\r\n        this.title = config.title;\r\n        this.desc = config.desc;\r\n        this.lifeTime = config.lifeTime;\r\n        this.applyFn = applyFn;\r\n        this.amount = amount;    \r\n    }\r\n\r\n    update() {\r\n        this.lifeTime--;\r\n        if( this.lifeTime <= 0) this.parent.removeComponent(this);\r\n        return true;        \r\n    }\r\n\r\n    apply(s, add, mul) {\r\n        this.applyFn(s, add, mul, this.amount);\r\n    }\r\n}",
        "filePath": "/global/components/js/Effect.js",
        "fileName": "Effect"
      },
      "Physics": {
        "script": "class Physics extends engine.Component {\r\n    async init() {\r\n        this.colliders = new Map();\r\n        this.rigidbodies = new Map();\r\n        this.staticColliderIds = new Set(); // Track which ids in rigidbodies are static\r\n        this.staticAABBs = [];  // Store AABB references, not physics objects\r\n        this.collidersToRemove = [];\r\n        this.lastUpdate = 0;\r\n        this.deltaTime = 0;\r\n        this.game.physics = this;\r\n        this.staticAABBs = [];\r\n        this.preloaded = [];\r\n        await RAPIER.init();\r\n        this.RAPIER = RAPIER; // Store reference for easier access\r\n        this.startSimulation(RAPIER);        \r\n        this.eventQueue = new RAPIER.EventQueue(true); // Enable contact events\r\n    }\r\n    \r\n    async startSimulation(r) {\r\n        // Create world with gravity\r\n        let gravity = new r.Vector3(0.0, -98.1, 0.0);\r\n        this.simulation = new r.World(gravity);\r\n        this.simulation.timestep = 1/60;\r\n        if(this.playerCallback){\r\n            this.playerCallback(this.simulation);\r\n        }\r\n        this.preloaded.forEach((c) => {\r\n            if (c.heights) {\r\n                this.createHeightmapCollider(c); // Handle heightmap colliders\r\n            } else {\r\n                this.registerCollider(c); // Handle other colliders\r\n            }\r\n        });        \r\n    }\r\n\r\n    createChunkStaticColliders(chunkId, chunkData) {\r\n        chunkData.collisionAABBs.keys().forEach((worldObjectType) => {\r\n            chunkData.collisionAABBs.get(worldObjectType).forEach((aabb) => {\r\n                this.createStaticCollider(chunkId, worldObjectType, aabb);\r\n            });            \r\n        });\r\n        // this.rigidbodies.get(chunkId).push({ type: 'heightmap', rigidBody, collider });\r\n    }\r\n\r\n    registerPlayer(callback){\r\n        if(this.simulation) {\r\n            callback(this.simulation);\r\n        } else {\r\n            this.playerCallback = callback;\r\n        }\r\n    }\r\n\r\n    removeStaticCollider(staticId) {\r\n        if (!staticId) {\r\n            return false;\r\n        }\r\n        \r\n        if (this.rigidbodies.has(staticId)) {\r\n            const { rigidBody, collider } = this.rigidbodies.get(staticId);\r\n            \r\n            try {\r\n                if (collider) {\r\n                    this.simulation.removeCollider(collider, true);\r\n                }\r\n                \r\n                if (rigidBody) {\r\n                    this.simulation.removeRigidBody(rigidBody);\r\n                }\r\n                \r\n                this.rigidbodies.delete(staticId);  \r\n                this.staticColliderIds.delete(staticId);\r\n                \r\n                return true;\r\n            } catch (error) {\r\n                console.error(`Error removing static collider ${staticId}:`, error);\r\n                // Still remove from our maps even if physics removal failed\r\n                this.rigidbodies.delete(staticId);\r\n                this.staticColliderIds.delete(staticId);\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    registerCollider(collider) {\r\n        const r = this.RAPIER;\r\n        if(!r){\r\n            this.preloaded.push(collider);\r\n            return;\r\n        }\r\n        let entity = collider.parent;\r\n        \r\n        if (!collider.id || !entity.transform.position) {\r\n            return;\r\n        }\r\n        \r\n        // Create rigid body\r\n        let rigidBodyDesc;\r\n        if (collider.mass <= 0) {\r\n            rigidBodyDesc = r.RigidBodyDesc.fixed();\r\n        } else {\r\n            rigidBodyDesc = r.RigidBodyDesc.dynamic()\r\n                .setLinearDamping(0.2)\r\n                .setAngularDamping(0.4)\r\n                .setCcdEnabled(true);\r\n        }\r\n        \r\n        // Set initial position\r\n        rigidBodyDesc.setTranslation(\r\n            entity.transform.position.x + collider.offset.x,\r\n            entity.transform.position.y + collider.offset.y,\r\n            entity.transform.position.z + collider.offset.z\r\n        );\r\n        \r\n        // Set initial velocity if available\r\n        if (entity.transform.velocity) {\r\n            rigidBodyDesc.setLinvel(\r\n                entity.transform.velocity.x,\r\n                entity.transform.velocity.y,\r\n                entity.transform.velocity.z\r\n            );\r\n        }\r\n        \r\n        // Create the rigid body\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        rigidBody.ccd = true;\r\n        // Create collider shape based on type\r\n        let colliderDesc;\r\n        switch (collider.type) {\r\n            case 'sphere':\r\n                colliderDesc = r.ColliderDesc.ball(collider.size);\r\n                break;\r\n            case 'box':\r\n                colliderDesc = r.ColliderDesc.cuboid(\r\n                    collider.size, collider.size, collider.size\r\n                );\r\n                break;\r\n            case 'capsule':\r\n                colliderDesc = r.ColliderDesc.capsule(\r\n                    collider.size, collider.size / 2\r\n                );\r\n                break;\r\n            default:\r\n                colliderDesc = r.ColliderDesc.ball(collider.size);\r\n                break;\r\n        }\r\n        \r\n        // Set restitution (bounciness)\r\n        colliderDesc.setRestitution(collider.restitution).setMass(collider.mass);\r\n        // Create the collider\r\n        const rapierCollider = this.simulation.createCollider(colliderDesc, rigidBody);\r\n        \r\n        // Store data for tracking\r\n        const data = {\r\n            entity: entity,\r\n            type: collider.type,\r\n            size: collider.size,\r\n            gravity: collider.gravity,\r\n            offset: collider.offset,\r\n            mass: collider.mass,\r\n            restitution: collider.restitution,\r\n            rigidBody: rigidBody,\r\n            rapierCollider: rapierCollider,\r\n            reflected: 0,\r\n            wasGrounded: false\r\n        };\r\n        \r\n        this.colliders.set(collider.id, data);\r\n        \r\n        \r\n        return rigidBody;\r\n    }\r\n\r\n    unregisterCollider(colliderId) {\r\n        if (this.colliders.has(colliderId)) {\r\n            const data = this.colliders.get(colliderId);\r\n            \r\n            // Remove the Rapier collider and rigid body\r\n            if (data.rapierCollider) {\r\n                this.simulation.removeCollider(data.rapierCollider, true);\r\n            }\r\n            \r\n            if (data.rigidBody) {\r\n                this.simulation.removeRigidBody(data.rigidBody);\r\n            }\r\n            \r\n            this.colliders.delete(colliderId);\r\n            \r\n           \r\n        }\r\n    }\r\n\r\n\r\n    sendToWorker() {\r\n        // Since we're not using a worker anymore, this method now runs the simulation step\r\n        // and updates all entity positions directly\r\n        \r\n        \r\n        // Step the physics simulation\r\n        this.simulation.step();\r\n        \r\n        // Update all entity positions based on the simulation results\r\n        for (const [colliderId, data] of this.colliders.entries()) {\r\n            const entity = data.entity;\r\n            const rigidBody = data.rigidBody;\r\n            \r\n            if (!rigidBody || !entity) continue;\r\n            \r\n            // Get position from physics\r\n            const position = rigidBody.translation();\r\n            entity.transform.physicsPosition.set(\r\n                position.x,\r\n                position.y,\r\n                position.z\r\n            );\r\n            \r\n            // Get velocity from physics\r\n            const velocity = rigidBody.linvel();\r\n            entity.transform.velocity.set(\r\n                velocity.x,\r\n                velocity.y,\r\n                velocity.z\r\n            );\r\n            \r\n            // Get rotation from physics (quaternion)\r\n            const rotation = rigidBody.rotation();\r\n            entity.transform.quaternion.set(\r\n                rotation.x,\r\n                rotation.y,\r\n                rotation.z,\r\n                rotation.w\r\n            );\r\n            \r\n            // Handle ground detection\r\n               // Update AABB if the method exists\r\n            if (entity.getAABB) {\r\n                data.aabb = entity.getAABB(entity.transform.physicsPosition);\r\n            }\r\n           \r\n            // Handle collision detection\r\n            this.detectCollisions(colliderId, data);\r\n        }\r\n        // Process colliders to remove\r\n        for (const colliderId of this.collidersToRemove) {\r\n            this.unregisterCollider(colliderId);\r\n        }\r\n        this.collidersToRemove = [];\r\n    }\r\n        \r\n    detectCollisions(data) {\r\n\r\n        \r\n        // this.eventQueue.drainContactEvents((handle1, handle2, started) => {\r\n        //     const collider1 = this.simulation.getCollider(handle1);\r\n        //     const collider2 = this.simulation.getCollider(handle2);\r\n        //     const data1 = [...this.colliders.entries()].find(([id, data]) => data.rapierCollider === collider1);\r\n        //     const data2 = [...this.colliders.entries()].find(([id, data]) => data.rapierCollider === collider2);\r\n\r\n        //     if (data1 && data2 && started && data1[1].entity.OnCollision) {\r\n        //         data1[1].entity.OnCollision(data2[1]);\r\n        //     }\r\n        // });\r\n    }\r\n    addChunkCollider(chunkData) {\r\n        const { cx, cz } = chunkData;\r\n        if (!this.simulation) {\r\n            this.preloaded.push(chunkData);\r\n            return;\r\n        }\r\n        const chunkId = `${cx},${cz}`;\r\n        if(!this.rigidbodies.has(chunkId)){\r\n            this.rigidbodies.set(chunkId, []);            \r\n        }\r\n        this.createHeightmapCollider(chunkId, chunkData);\r\n        this.createChunkStaticColliders(chunkId, chunkData);\r\n    }\r\n\r\n    removeChunkColliders(cx, cz) {\r\n        const chunkId = `${cx},${cz}`;\r\n        \r\n        if (this.rigidbodies.has(`${chunkId}`)) {\r\n            let c = 0;\r\n            this.rigidbodies.get(chunkId).forEach((body) => {                \r\n                const { rigidBody, collider } = body;\r\n                if (collider) {\r\n                    this.simulation.removeCollider(collider, true);\r\n                    c++;\r\n                }\r\n                if (rigidBody) {\r\n                    this.simulation.removeRigidBody(rigidBody);\r\n                }\r\n            });\r\n            this.rigidbodies.delete(chunkId);\r\n        }\r\n    }\r\n    createStaticCollider(chunkId, worldObjectType, aabb) {\r\n        if (!aabb || !aabb.id) {\r\n            console.warn(\"Invalid AABB provided to createStaticCollider\");\r\n            return null;\r\n        }\r\n\r\n        if (this.rigidbodies.has(aabb.id)) {\r\n            return;\r\n        }\r\n        \r\n        const r = this.RAPIER;\r\n        const halfWidth = (aabb.max.x - aabb.min.x) / 2;\r\n        const halfHeight = (aabb.max.y - aabb.min.y) / 2;\r\n        const halfDepth = (aabb.max.z - aabb.min.z) / 2;\r\n        \r\n        const centerX = (aabb.max.x + aabb.min.x) / 2;\r\n        const centerY = (aabb.max.y + aabb.min.y) / 2;\r\n        const centerZ = (aabb.max.z + aabb.min.z) / 2;\r\n        \r\n        // Create a static rigid body\r\n        const rigidBodyDesc = r.RigidBodyDesc.fixed()\r\n            .setTranslation(centerX, centerY, centerZ);\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        \r\n        // Create a cuboid collider\r\n        const colliderDesc = r.ColliderDesc.capsule(halfHeight, halfWidth)\r\n                .setCollisionGroups(0x00020004) // Belongs to group 0x0002, interacts with group 0x0004 (dynamic)\r\n                .setSolverGroups(0x00020004); // Same for solver groups\r\n        const collider = this.simulation.createCollider(colliderDesc, rigidBody);\r\n        \r\n        // Store reference to the static collider with a unique ID\r\n        this.rigidbodies.get(chunkId).push({ type: worldObjectType, rigidBody, collider });\r\n        this.staticColliderIds.add(aabb.id); // Mark this as a static collider\r\n\r\n    }\r\n    createHeightmapCollider(chunkId, chunkData) {\r\n        const r = this.RAPIER;\r\n        const { cx, cz } = chunkData;\r\n       // const { heights, nx, ny, scale } = heightmap;\r\n        // Validate inputs\r\n\r\n        // Create a static rigid body for the terrain chunk\r\n        const rigidBodyDesc = r.RigidBodyDesc.fixed()\r\n                .setSoftCcdPrediction(5)\r\n                .setTranslation(\r\n                    cx * this.game.terrain.chunkSize,\r\n                    0,\r\n                    cz * this.game.terrain.chunkSize\r\n                );\r\n        const rigidBody = this.simulation.createRigidBody(rigidBodyDesc);\r\n        // Create heightfield collider\r\n       // const heightfield = new Float32Array(heights);\r\n        // const colliderDesc = r.ColliderDesc.heightfield(nx - 1, ny - 1, heightfield, scale)\r\n        //     .setSensor(false);\r\n        const colliderDesc = r.ColliderDesc.trimesh(chunkData.geometry.positions, chunkData.geometry.indices)    \r\n            .setCollisionGroups(0x00010004) // Belongs to group 0x0001, interacts with group 0x0004 (dynamic)\r\n            .setSolverGroups(0x00010004)\r\n            .setRestitution(chunkData.restitution)\r\n            .setFriction(chunkData.friction); // Same for solver groups;\r\n        const collider = this.simulation.createCollider(colliderDesc, rigidBody);    \r\n        // Store collider with a unique ID\r\n      //  this.createHeightmapMesh(cx, cz, chunkData);\r\n        this.rigidbodies.get(chunkId).push({ type: 'heightmap', rigidBody, collider });\r\n    }\r\n    createHeightmapMesh(cx, cz, chunkData) {\r\n        const { geometry } = chunkData;       \r\n\r\n        // Create geometry for the heightmap\r\n        const plane = new THREE.BufferGeometry();\r\n        plane.setAttribute('position', new THREE.Float32BufferAttribute(geometry.positions, 3));\r\n        plane.setAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\r\n        plane.setIndex(geometry.indices);\r\n        plane.attributes.position.needsUpdate = true; // Mark for update\r\n        plane.attributes.normal.needsUpdate = true; // Mark for update\r\n        plane.computeVertexNormals(); // Recalculate normals for lighting\r\n\r\n        // Create material\r\n        const material = new THREE.MeshStandardMaterial({\r\n            color: 0x00ff00, // Green for visibility, adjust as needed\r\n            wireframe: true   // Wireframe to visualize mesh structure\r\n        });\r\n\r\n        // Create mesh\r\n        const mesh = new THREE.Mesh(plane, material);\r\n\r\n        // Position mesh to match collider\r\n        mesh.position.set(\r\n            cx * this.game.terrain.chunkSize, // Center x\r\n            1,                                                           // y (heights are in geometry)\r\n            cz * this.game.terrain.chunkSize  // Center z\r\n        );\r\n\r\n        // // Rotate plane to lie flat (x, z plane), as PlaneGeometry is initially in x, y plane\r\n        // mesh.rotation.x = -Math.PI / 2;\r\n        // Add to scene\r\n        this.game.scene.add(mesh);\r\n\r\n        // Store mesh for debugging (optional)\r\n        const chunkId = `heightmap_${cx}_${cz}`;\r\n        this.meshes = this.meshes || new Map(); // Assuming a meshes Map to store\r\n        this.meshes.set(chunkId, mesh);\r\n\r\n    }\r\n    onDestroy() {\r\n        // Clean up Rapier resources\r\n        for (const [colliderId, data] of this.colliders.entries()) {\r\n            if (data.rapierCollider) {\r\n                this.simulation.removeCollider(data.rapierCollider, true);\r\n            }\r\n            if (data.rigidBody) {\r\n                this.simulation.removeRigidBody(data.rigidBody);\r\n            }\r\n        }\r\n        \r\n        this.colliders.clear();\r\n        this.rigidbodies.clear();\r\n        this.simulation = null;\r\n    }\r\n    \r\n}",
        "filePath": "/global/components/js/Physics.js",
        "fileName": "Physics"
      },
      "Projectile": {
        "script": "class Projectile extends engine.Component {  \r\n      \r\n  init({ spawnType, owner, target, targetPosition, stats }) {\r\n    this.type = spawnType;\r\n    this.def = this.game.getCollections().projectiles[this.type];\r\n    this.owner = owner;\r\n    this.target = target;\r\n    this.targetPosition = targetPosition;\r\n    this.stats = stats;\r\n    this.piercedEnemies = [];\r\n    this.ownerStats = this.owner.getComponent(\"stats\").stats;\r\n    this.distanceTraveled = 0;\r\n    this.distanceToSpawnParticle = 24;\r\n\r\n    // Add lifespan for projectile (e.g., 5 seconds)\r\n    this.maxLifespan = this.stats.lifespan || 5; // Default to 5 seconds, adjust as needed\r\n    this.currentLifespan = 0;  \r\n    if(this.stats.attackSound){\r\n      this.game.audioManager.playSound('attackSounds', this.stats.attackSound);\r\n    }\r\n  }\r\n\r\n  update() {\r\n    let hitSoundPlayed = false;\r\n    if(this.target) this.targetCurrentPosition = {...this.target.transform.position };\r\n    // Update lifespan and destroy if expired\r\n    this.currentLifespan += this.game.deltaTime; // Assuming deltaTime is in seconds\r\n    if (this.currentLifespan >= this.maxLifespan) {\r\n      this.parent.destroy();\r\n      return;\r\n    }\r\n\r\n    // Remove if target is gone (only if no targetPosition)\r\n    if (!this.targetPosition && (!this.target || this.target.destroyed)) {\r\n      if(this.targetCurrentPosition) {\r\n        this.targetPosition = this.targetCurrentPosition;\r\n      } else {\r\n        this.parent.destroy(); \r\n        return;\r\n      }\r\n    }\r\n\r\n    // Determine movement target\r\n    const targetPos = this.targetPosition ? this.targetPosition : this.target.transform.position;\r\n    const dx = targetPos.x - this.parent.transform.position.x;\r\n    const dz = targetPos.z - this.parent.transform.position.z;\r\n    const distSq = dx * dx + dz * dz;\r\n    const dist = Math.sqrt(distSq);\r\n    const speed = this.stats.speed;\r\n\r\n    // Hit detection\r\n    const hitRadiusSq = 15 * 15; // Same as your original hit detection radius\r\n    let hitDetected = false;\r\n\r\n    if (this.targetPosition) {\r\n      // Check nearby enemies for hit detection when using targetPosition\r\n      const nearbyEnemies = this.game.spatialGrid.getNearbyEntities(\r\n        this.parent.transform.gridPosition.x,\r\n        this.parent.transform.gridPosition.y,\r\n        this.stats.splashRadius || 15, // Use splashRadius or default to 15,\r\n        \"enemy\"\r\n      );\r\n\r\n      for (const enemy of nearbyEnemies) {\r\n        if (enemy.isDead || this.piercedEnemies.includes(enemy)) continue;\r\n\r\n        const dxEnemy = enemy.transform.position.x - this.parent.transform.position.x;\r\n        const dzEnemy = enemy.transform.position.z - this.parent.transform.position.z;\r\n        const enemyDistSq = dxEnemy * dxEnemy + dzEnemy * dzEnemy;\r\n\r\n        if (enemyDistSq <= hitRadiusSq) {\r\n          // Hit detected\r\n          if(this.stats.hitSound && !hitDetected && !hitSoundPlayed){\r\n            this.game.audioManager.playSound('hitSounds', this.stats.hitSound);\r\n            hitSoundPlayed = true;\r\n          }\r\n          hitDetected = true;\r\n          let enemyHealth = enemy.getComponent(\"health\");\r\n          let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n          let enemyStats = enemy.getComponent(\"stats\");\r\n          let enemyStatClone = { ...enemyStats.stats };\r\n          enemyStatClone.energyShield = enemyEnergyShield.energyShield;\r\n\r\n          // Apply damage\r\n          let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStatClone);\r\n          if (!damageResult.wasEvaded) {\r\n            enemyHealth.hp -= damageResult.damageDealt;\r\n            enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n            this.game.spawn(\"hitEffect\", {\r\n              damageType: this.stats.damageType,\r\n              lifeSpan: 0.3,\r\n              position: enemy.transform.position\r\n            });\r\n            if (this.ownerStats.slowAmount) {\r\n              enemyStats.addEffect(\r\n                this.game.getCollections().effects.slow,\r\n                this.game.effects.slow,\r\n                this.ownerStats.slowAmount\r\n              );\r\n            }\r\n          }\r\n\r\n          // Piercing logic\r\n          if (this.stats.piercing > 0 && this.piercedEnemies.length < this.stats.piercing) {\r\n            this.piercedEnemies.push(enemy);\r\n            let newTarget = this.findNewTarget(nearbyEnemies);\r\n            if (newTarget) {\r\n              this.target = newTarget;\r\n              this.targetPosition = null; // Switch to target-based tracking\r\n              return;\r\n            }\r\n          }\r\n\r\n          // Splash damage if applicable\r\n          if (this.stats.splashRadius > 0) {\r\n            this.applySplashDamage(nearbyEnemies);\r\n            this.game.spawn(\"explosion\", {\r\n              radius: this.stats.splashRadius,\r\n              position: this.parent.transform.position\r\n            });\r\n          }\r\n\r\n          // Destroy projectile if no piercing or piercing limit reached\r\n          if (this.stats.piercing <= 0 || this.piercedEnemies.length >= this.stats.piercing) {\r\n            this.parent.destroy();\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    } else if (distSq < hitRadiusSq) {\r\n      // Original target-based hit detection\r\n      let targetHealth = this.target.getComponent(\"health\");\r\n      let targetEnergyShield = this.target.getComponent(\"energyshield\");\r\n      let targetStats = this.target.getComponent(\"stats\");\r\n      let targetStatClone = { ...targetStats.stats };\r\n      targetStatClone.energyShield = targetEnergyShield.energyShield;\r\n\r\n      // Apply damage and effects (unchanged from your original code)\r\n      let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, targetStatClone);\r\n      if (!damageResult.wasEvaded) {\r\n        if(this.stats.hitSound && !hitSoundPlayed){\r\n          this.game.audioManager.playSound('hitSounds', this.stats.hitSound);\r\n          hitSoundPlayed = true;\r\n        }\r\n        targetHealth.hp -= damageResult.damageDealt;\r\n        targetEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n        this.game.spawn(\"hitEffect\", {\r\n          damageType: this.stats.damageType,\r\n          lifeSpan: 0.3,\r\n          position: this.target.transform.position\r\n        });\r\n        if (this.ownerStats.slowAmount) {\r\n          targetStats.addEffect(\r\n            this.game.getCollections().effects.slow,\r\n            this.game.effects.slow,\r\n            this.ownerStats.slowAmount\r\n          );\r\n        }\r\n      }\r\n\r\n      // Summon skeleton, leech, thief logic (unchanged)\r\n      if (\r\n        this.ownerStats.summonChance > 0 &&\r\n        targetHealth.hp <= 0 &&\r\n        Math.random() < this.ownerStats.summonChance - 1\r\n      ) {\r\n        this.game.spawn(\"summonedTower\", {\r\n          objectType: \"towers\",\r\n          spawnType: this.ownerStats.summonType,\r\n          owner: this.owner,\r\n          position: this.target.transform.position\r\n        });\r\n      }\r\n      if (this.ownerStats.leech > 0) {\r\n        const healing = this.stats.damage * this.ownerStats.leech * this.game.state.stats.healingMultiplier;\r\n        this.game.state.bloodCoreHP = Math.min(\r\n          this.game.state.stats.maxBloodCoreHP,\r\n          this.game.state.bloodCoreHP + healing\r\n        );\r\n      }\r\n      if (this.ownerStats.thief && this.ownerStats.thief != 0) {\r\n        const stealAmt = this.stats.damage * this.ownerStats.thief * this.game.state.stats.bloodShardMultiplier;\r\n        this.game.state.bloodShards += stealAmt;\r\n      }\r\n\r\n      // Piercing logic\r\n      if (this.stats.piercing > 0 && this.piercedEnemies.length < this.stats.piercing) {\r\n        this.piercedEnemies.push(this.target);\r\n        const newTarget = this.findNewTarget(\r\n          this.game.spatialGrid.getNearbyEntities(\r\n            this.parent.transform.gridPosition.x,\r\n            this.parent.transform.gridPosition.y,\r\n            this.ownerStats.range\r\n          )\r\n        );\r\n        if (newTarget) {\r\n          this.target = newTarget;\r\n          return;\r\n        }\r\n      }\r\n\r\n      this.parent.destroy();\r\n      return;\r\n    }\r\n\r\n    // Move projectile\r\n    this.parent.transform.position.x += (dx / dist) * speed;\r\n    this.parent.transform.position.z += (dz / dist) * speed;\r\n\r\n    // Continue moving past targetPosition by updating it if reached\r\n    if (this.targetPosition && distSq < speed * speed) {\r\n      // If close to targetPosition, extend it in the same direction\r\n      const directionX = dx / dist;\r\n      const directionZ = dz / dist;\r\n      this.targetPosition.x += directionX * speed * 10; // Extend further (adjust multiplier)\r\n      this.targetPosition.z += directionZ * speed * 10;\r\n    }\r\n\r\n    // Particle spawning logic (unchanged)\r\n    const tDx = this.parent.transform.lastPosition.x - this.parent.transform.position.x;\r\n    const tDz = this.parent.transform.lastPosition.z - this.parent.transform.position.z;\r\n    const tDistSq = tDx * tDx + tDz * tDz;\r\n    const tDist = Math.sqrt(tDistSq);\r\n\r\n    this.distanceTraveled += tDist;\r\n    if (this.def.particle && this.distanceTraveled > this.distanceToSpawnParticle) {\r\n      this.game.spawn(\"particle\", { objectType: \"particles\", spawnType: this.def.particle, position: this.parent.transform.position});\r\n      this.distanceTraveled = 0;\r\n      this.distanceToSpawnParticle += Math.random() * 3;\r\n    }\r\n  }\r\n\r\n  // Helper method to find a new target for piercing\r\n  findNewTarget(nearbyEnemies) {\r\n    const gridSize = this.game.getCollections().configs.game.gridSize;\r\n    const rangeSq = this.ownerStats.range * this.ownerStats.range * gridSize * gridSize;\r\n    for (let enemy of nearbyEnemies) {\r\n      if (!enemy.destroyed && !this.piercedEnemies.includes(enemy)) {\r\n        const dx = enemy.transform.position.x - this.parent.transform.position.x;\r\n        const dz = enemy.transform.position.z - this.parent.transform.position.z;\r\n        const distSq = dx * dx + dz * dz;\r\n        if (distSq < rangeSq) {\r\n          return enemy;\r\n        }\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // Helper method to apply splash damage\r\n  applySplashDamage(nearbyEnemies) {\r\n    const gridSize = this.game.getCollections().configs.game.gridSize;\r\n    const splashRadiusSq = this.stats.splashRadius * this.stats.splashRadius * gridSize * gridSize;\r\n    for (const enemy of nearbyEnemies) {\r\n      if (enemy.isDead || this.piercedEnemies.includes(enemy)) continue;\r\n      let enemyHealth = enemy.getComponent(\"health\");\r\n      let enemyEnergyShield = enemy.getComponent(\"energyshield\");\r\n      let enemyStats = enemy.getComponent(\"stats\");\r\n      let enemyStatClone = { ...enemyStats.stats };\r\n      enemyStatClone.energyShield = enemyEnergyShield.energyShield;\r\n\r\n      const dx = enemy.transform.position.x - this.parent.transform.position.x;\r\n      const dz = enemy.transform.position.z - this.parent.transform.position.z;\r\n      const distSq = dx * dx + dz * dz;\r\n\r\n      if (distSq <= splashRadiusSq) {\r\n        let damageResult = engine.getFunction(\"calculateDamage\")(this.stats, enemyStatClone);\r\n        if (!damageResult.wasEvaded) {\r\n          enemyHealth.hp -= damageResult.damageDealt;\r\n          enemyEnergyShield.absorbDamage(damageResult.damageAbsorbed);\r\n          this.game.spawn(\"hitEffect\", {\r\n            damageType: this.stats.damageType,\r\n            lifeSpan: 0.3,\r\n            position: enemy.transform.position\r\n          });\r\n          if (this.ownerStats.slowAmount) {\r\n            enemyStats.addEffect(\r\n              this.game.getCollections().effects.slow,\r\n              this.game.effects.slow,\r\n              this.ownerStats.slowAmount\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}",
        "filePath": "/global/components/js/Projectile.js",
        "fileName": "Projectile"
      },
      "ThreeJsWorld": {
        "script": "class ThreeJsWorld extends engine.Component {\n    init({\n    containerSelector = '#gameContainer',\n    width = window.innerWidth,\n    height = window.innerHeight,\n    useControls = true,\n    canvas,\n    scene,\n    camera,\n    renderer,\n    isEditor}) {\n        this.gameConfig = this.game.getCollections().configs.game;\n  \n        this.canvas = canvas;\n        this.level = this.game.getCollections().levels[this.game.state.level];\n        this.world = this.game.getCollections().worlds[this.level.world];\n        this.lightingSettings = this.game.getCollections().lightings[this.world.lighting];\n        this.shadowSettings = this.game.getCollections().shadows[this.world.shadow];\n        this.fogSettings = this.game.getCollections().fogs[this.world.fog]; \n        this.heightMapSettings = this.game.getCollections().heightMaps[this.world.heightMap];      \n        this.cameraSettings = this.game.getCollections().cameras[this.world.camera];\n\n        this.heightStep = this.heightMapSettings.heightStep;\n        this.showStats = false;\n        this.clock = new THREE.Clock();\n        this.onWindowResizeHandler = this.onWindowResize.bind(this);\n        this.game.heightMapConfig = this.heightMapSettings;\n        this.terrainSize = 768;\n        this.extensionSize = this.world.extensionSize;\n        this.extendedSize = this.terrainSize + 2 * this.world.extensionSize;\n        this.heightMapResolution = this.extendedSize / this.heightMapSettings.resolutionDivisor;\n        this.container = document.querySelector(containerSelector) || document.body;\n        this.renderer = renderer;\n        if(!this.renderer){\n            this.renderer = new THREE.WebGLRenderer({ antialias: true, canvas: this.canvas, alpha: true });\n        \n            this.renderer.setSize(width, height);        \n            this.renderer.shadowMap.enabled = this.shadowSettings.enabled;\n            this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n        }\n        this.uniforms = {};\n        this.scene = scene || new THREE.Scene();\n        this.scene.background = new THREE.Color(this.world.backgroundColor);\n\n        if (this.fogSettings.enabled) {\n            this.scene.fog = new THREE.FogExp2(this.fogSettings.color, this.fogSettings.density);\n        }\n        this.camera = camera;\n        if(!this.camera){\n            if(this.cameraSettings.fov){\n                this.camera = new THREE.PerspectiveCamera(\n                    this.cameraSettings.fov,\n                    width / height,\n                    this.cameraSettings.near,\n                    this.cameraSettings.far\n                );\n            } else if(this.cameraSettings.zoom){\n                this.camera = new THREE.OrthographicCamera(\n                    width / - 2, \n                    width / 2, \n                    height / 2, \n                    height / - 2, \n                    this.cameraSettings.near,\n                    this.cameraSettings.far\n                );\n                this.camera.zoom = this.cameraSettings.zoom;\n                this.camera.updateProjectionMatrix();\n            }\n        }\n        let cameraPos = JSON.parse(this.cameraSettings.position);\n\n        this.camera.position.set(\n            cameraPos.x,\n            cameraPos.y,\n            cameraPos.z\n        );\n        let lookAt = JSON.parse(this.cameraSettings.lookAt);\n        this.camera.lookAt(\n            lookAt.x,\n            lookAt.y,\n            lookAt.z\n        );\n\n        if (useControls && !isEditor) {\n            this.controls = new THREE_.OrbitControls(this.camera, this.renderer.domElement);\n            this.controls.target.set(\n                lookAt.x,\n                lookAt.y,\n                lookAt.z\n            );\n            this.controls.maxPolarAngle = Math.PI / 2.05;\n            this.controls.minPolarAngle = 0.1;\n            this.controls.enableDamping = true;\n            this.controls.dampingFactor = 0.05;\n            this.controls.update();\n        }\n\n        this.ambientLight = new THREE.AmbientLight(\n            this.lightingSettings.ambientColor,\n            this.lightingSettings.ambientIntensity\n        );\n        this.scene.add(this.ambientLight);\n\n        this.directionalLight = new THREE.DirectionalLight(\n            this.lightingSettings.directionalColor,\n            this.lightingSettings.directionalIntensity\n        );\n        this.directionalLight.position.set(this.extendedSize, this.extendedSize, this.extendedSize);\n        this.directionalLight.castShadow = this.shadowSettings.enabled;\n\n        if (this.shadowSettings.enabled) {\n            this.directionalLight.shadow.mapSize.width = this.shadowSettings.mapSize;\n            this.directionalLight.shadow.mapSize.height = this.shadowSettings.mapSize;\n            this.directionalLight.shadow.camera.near = 0.5;\n            this.directionalLight.shadow.camera.far = 20000;\n            this.directionalLight.shadow.bias = this.shadowSettings.bias;\n            this.directionalLight.shadow.normalBias = this.shadowSettings.normalBias;\n            this.directionalLight.shadow.radius = this.shadowSettings.radius;\n\n            const d = this.extendedSize * 0.75;\n            this.directionalLight.shadow.camera.left = -d;\n            this.directionalLight.shadow.camera.right = d;\n            this.directionalLight.shadow.camera.top = d;\n            this.directionalLight.shadow.camera.bottom = -d;\n\n            this.directionalLight.target.position.set(-this.extendedSize, -this.extendedSize, -this.extendedSize);\n            this.directionalLight.target.updateMatrixWorld();\n            this.directionalLight.shadow.camera.updateProjectionMatrix();\n        }\n\n        this.scene.add(this.directionalLight);\n        this.scene.add(this.directionalLight.target);\n\n        this.hemisphereLight = new THREE.HemisphereLight(\n            this.lightingSettings.skyColor,\n            this.lightingSettings.groundColor,\n            this.lightingSettings.hemisphereIntensity\n        );\n        this.scene.add(this.hemisphereLight);\n\n        this.composer = new THREE_.EffectComposer( this.renderer );\n        this.pixelSize = this.gameConfig.pixelSize || 1;\n        this.pixelPass = new THREE_.RenderPixelatedPass( this.pixelSize, this.scene, this.camera );\n        if(this.pixelSize == 1) {\n            this.pixelPass.enabled = false;\n        }\n        this.game.postProcessors = {\n            pixelPass: this.pixelPass\n        };\n        this.pixelPass.normalEdgeStrength = 0;\n    \n        this.composer.addPass( this.pixelPass );\n        const outputPass = new THREE_.OutputPass();\n        this.composer.addPass( outputPass );\n\n        this.tileMap = this.game.getCollections().levels[this.game.state.level].tileMap;\n        this.setupGround();\n        this.generateLiquidSurfaceMesh(0);\n        this.generateLiquidSurfaceMesh(1);\n        if (this.showStats) {\n            this.stats = new Stats();\n            this.container.appendChild(this.stats.dom);\n        }\n\n        window.addEventListener('resize', this.onWindowResizeHandler);\n\n        this.game.scene = this.scene;\n        this.game.camera = this.camera;\n        this.game.renderer = this.renderer;\n        this.game.ground = this.ground;\n        this.drawn = false;\n        this.timer = 0;        \n    }\n\n    setupGround() {\n        this.groundCanvas = document.createElement('canvas');\n        this.groundCanvas.width = this.extendedSize;\n        this.groundCanvas.height = this.extendedSize;\n        this.groundCtx = this.groundCanvas.getContext('2d');\n\n        let bgColor = this.tileMap.terrainTypes[this.tileMap.extensionTerrainType].color;\n        let colorToUse = bgColor.paletteColor ? this.game.palette[bgColor.paletteColor] : bgColor;\n        this.groundCtx.fillStyle = colorToUse;\n        this.groundCtx.fillRect(0, 0, this.extendedSize, this.extendedSize);\n\n        this.groundTexture = new THREE.CanvasTexture(this.groundCanvas);\n        this.groundTexture.wrapS = THREE.ClampToEdgeWrapping;\n        this.groundTexture.wrapT = THREE.ClampToEdgeWrapping;\n        this.groundTexture.minFilter = THREE.NearestFilter;\n        this.groundTexture.magFilter = THREE.NearestFilter;\n        \n        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);\n        this.terrainTypes = this.tileMap.terrainTypes || [];\n\n        const segments = this.heightMapResolution || 1;\n        const groundGeometry = new THREE.PlaneGeometry(\n            this.extendedSize,\n            this.extendedSize,\n            segments,\n            segments\n        );\n\n        this.groundVertices = groundGeometry.attributes.position;\n        this.groundMaterial = this.getGroundMaterial();\n\n        this.ground = new THREE.Mesh(groundGeometry, this.groundMaterial);\n        this.ground.rotation.x = -Math.PI / 2;\n        this.ground.position.set(this.terrainSize / 2, 0, this.terrainSize / 2);\n        this.ground.receiveShadow = true;\n        this.ground.castShadow = true;\n        this.scene.add(this.ground);\n    }\n    findClosestTerrainType(r, g, b, terrainTypeColors) {\n        let minDistance = Infinity;\n        let bestTypeIndex = null;\n        let toleranceSquared = 36;\n        for (const [colorKey, typeIndex] of Object.entries(terrainTypeColors)) {\n            const [cr, cg, cb] = colorKey.split(',').map(Number);\n            const distance = ((r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2);\n            if (distance < minDistance && distance < toleranceSquared) { // Adjust tolerance as needed\n                minDistance = distance;\n                bestTypeIndex = typeIndex;\n            }\n        }\n        return bestTypeIndex;\n    }\n    updateHeightMap() {\n        if (!this.heightMapSettings.enabled || !this.game.terrainTileMapper.canvas) return;\n\n        try {\n            const terrainCanvas = this.game.terrainTileMapper.canvas;\n            const terrainCtx = terrainCanvas.getContext('2d', { alpha: false, willReadFrequently: true });\n            terrainCanvas.width = this.game.getCollections().configs.game.gridSize * this.level.tileMap.terrainMap[0].length;\n            terrainCanvas.height = this.game.getCollections().configs.game.gridSize * this.level.tileMap.terrainMap.length;\n\n            terrainCtx.imageSmoothingEnabled = false;\n            const terrainData = this.game.terrainTileMapper.terrainData;//terrainCtx.getImageData(0, 0, terrainCanvas.width, terrainCanvas.height).data;\n            const terrainTypeColors = this.createTerrainTypeColorMap();\n\n            this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);\n\n            const extensionTerrainType = this.tileMap.extensionTerrainType;\n            const extensionHeight = extensionTerrainType * this.heightStep;\n\n            for (let z = 0; z < this.extendedSize; z++) {\n                for (let x = 0; x < this.extendedSize; x++) {\n                    this.heightMapData[z * this.extendedSize + x] = extensionHeight;\n                }\n            }\n\n            for (let z = 0; z < this.terrainSize; z++) {\n                for (let x = 0; x < this.terrainSize; x++) {\n                    const pixelIndex = (z * terrainCanvas.width + x) * 4;\n                    const r = terrainData[pixelIndex];\n                    const g = terrainData[pixelIndex + 1];\n                    const b = terrainData[pixelIndex + 2];\n            \n                    const typeIndex = this.findClosestTerrainType(r,g,b,terrainTypeColors) ?? extensionHeight;\n                    let height = typeIndex !== undefined ? typeIndex * this.heightStep : extensionHeight;\n\n                    // Check neighboring pixels for lower terrain types\n                    let neighborCheckDist = this.heightMapSettings.resolutionDivisor - 1;\n                    const neighbors = [\n                        { x: x-neighborCheckDist, z: z },   // left\n                        { x: x+neighborCheckDist, z: z },   // right\n                        { x: x, z: z-neighborCheckDist },   // top\n                        { x: x, z: z+neighborCheckDist + 1 },   // bottom\n                        { x: x-neighborCheckDist, z: z-neighborCheckDist }, // top-left\n                        { x: x+neighborCheckDist, z: z-neighborCheckDist }, // top-right\n                        { x: x-neighborCheckDist, z: z+neighborCheckDist }, // bottom-left\n                        { x: x+neighborCheckDist, z: z+neighborCheckDist }  // bottom-right\n                    ];\n                    let lowestNeighborType = Infinity;\n                    for (const neighbor of neighbors) {\n                        if (neighbor.x >= 0 && neighbor.x < this.terrainSize && \n                            neighbor.z >= 0 && neighbor.z < this.terrainSize) {\n                            \n                            const neighborIndex = (neighbor.z * terrainCanvas.width + neighbor.x) * 4;\n                            const nr = terrainData[neighborIndex];\n                            const ng = terrainData[neighborIndex + 1];\n                            const nb = terrainData[neighborIndex + 2];\n                            const neighborKey = `${nr},${ng},${nb}`;\n                            \n                            const neighborTypeIndex = terrainTypeColors[neighborKey];\n                            if (neighborTypeIndex !== undefined && neighborTypeIndex < typeIndex && neighborTypeIndex < lowestNeighborType) {\n                                // If neighbor is lower terrain, use its height\n                                lowestNeighborType = neighborTypeIndex;\n                            }\n                        }\n                    }\n                    if (lowestNeighborType < typeIndex) {\n                        height = lowestNeighborType * this.heightStep;\n                    }\n                    const extX = x + this.extensionSize;\n                    const extZ = z + this.extensionSize;\n                    this.heightMapData[extZ * this.extendedSize + extX] = height;\n                }\n            }\n\n            this.applyHeightMapToGeometry();\n\n        } catch (e) {\n            console.warn('Failed to update height map:', e);\n        }\n    }\n\n    createTerrainTypeColorMap() {\n        const colorMap = {};\n        const terrainTypes = this.terrainTypes;\n\n        for (let i = 0; i < terrainTypes.length; i++) {\n            const terrainType = terrainTypes[i];\n            let color = terrainType.color || {};\n\n            if (color.paletteColor && this.game.palette) {\n                const hexColor = this.game.palette[color.paletteColor];\n                if (hexColor) {\n                    const r = parseInt(hexColor.slice(1, 3), 16);\n                    const g = parseInt(hexColor.slice(3, 5), 16);\n                    const b = parseInt(hexColor.slice(5, 7), 16);\n                    colorMap[`${r},${g},${b}`] = i;\n                }\n            } else {\n                const hexColor = color;\n                if (hexColor) {\n                    const r = parseInt(hexColor.slice(1, 3), 16);\n                    const g = parseInt(hexColor.slice(3, 5), 16);\n                    const b = parseInt(hexColor.slice(5, 7), 16);\n                    colorMap[`${r},${g},${b}`] = i;\n                }\n            }\n        }\n\n        return colorMap;\n    }\n\n    applyHeightMapToGeometry() {\n        if (!this.ground || !this.groundVertices) return;\n\n        const positions = this.groundVertices.array;\n        const geometry = this.ground.geometry;\n        const segments = this.heightMapResolution;\n        const verticesPerRow = segments + 1;\n\n        for (let z = 0; z < verticesPerRow; z++) {\n            for (let x = 0; x < verticesPerRow; x++) {\n                const vertexIndex = (z * verticesPerRow + x);\n                const idx = vertexIndex * 3;\n\n                const nx = x / segments;\n                const nz = z / segments;\n\n                const terrainX = Math.floor(nx * (this.extendedSize - 1));\n                const terrainZ = Math.floor(nz * (this.extendedSize - 1));\n\n                const heightIndex = terrainZ * this.extendedSize + terrainX;\n                const height = this.heightMapData[heightIndex] || 0;\n\n                // const finalHeight = this.heightMapSettings.smoothing ?\n                //     this.smoothHeight(terrainX, terrainZ) : height;\n\n                positions[idx + 2] = height;\n            }\n        }\n\n        this.groundVertices.needsUpdate = true;\n        geometry.computeVertexNormals();\n    }\n\n    getGroundMaterial() {\n        return new THREE.MeshStandardMaterial({\n            map: this.groundTexture,\n            side: THREE.DoubleSide,\n            metalness: 0.0,\n            roughness: 0.8\n        });\n    }\n\n    onWindowResize() {\n        if(!this.isEditor){\n            const width = this.container.clientWidth || window.innerWidth;\n            const height = this.container.clientHeight || window.innerHeight;\n\n            this.camera.aspect = width / height;\n            this.camera.updateProjectionMatrix();\n            this.renderer.setSize(width, height);\n            this.canvas.style.width = `${width}px`;\n            this.canvas.style.height = `${height}px`;\n        }\n                // Ensure canvas display size matches resolution\n        \n    }\n\n    update() {\n        if (!this.game.getCollections().configs.game.is3D) {\n            return;\n        }   \n        if (this.controls) {\n            this.controls.update();\n        }\n        if (!isNaN(this.game.deltaTime)) {\n            this.timer += this.game.deltaTime;\n        }\n        if (this.stats) {\n            this.stats.update();\n        }\n        if (!this.drawn && this.groundTexture && this.game.mapRenderer && this.game.mapRenderer.isMapCached) {\n            this.groundCtx.drawImage(this.game.terrainTileMapper.canvas, this.extensionSize, this.extensionSize);\n            this.groundTexture.needsUpdate = true;\n\n            if (this.heightMapSettings.enabled) {\n                console.log('here');\n                this.updateHeightMap();\n            }\n\n            this.addGrassToTerrain();\n            this.drawn = true;\n        }\n        for(const key in this.uniforms) {\n            this.uniforms[key].time = { value: this.timer };            \n        }\n        \n        if(this.pixelPass.enabled && this.pixelSize > 1){\n            const rendererSize = this.renderer.getSize( new THREE.Vector2() );\n            const aspectRatio = rendererSize.x / rendererSize.y;\n            this.pixelAlignFrustum( this.camera, aspectRatio, Math.floor( rendererSize.x / this.pixelSize ),\n                        Math.floor( rendererSize.y / this.pixelSize ) );\n        }\n        if(!this.isEditor){\n            this.renderer.render(this.scene, this.camera);\n        \n            if(this.pixelPass.enabled){\n                this.composer.render();\n            }\n        }\n    }\n    pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {\n\n        // 0. Get Pixel Grid Units\n        const worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );\n        const worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );\n        const pixelWidth = worldScreenWidth / pixelsPerScreenWidth;\n        const pixelHeight = worldScreenHeight / pixelsPerScreenHeight;\n\n        // 1. Project the current camera position along its local rotation bases\n        const camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );\n        const camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );\n        const camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );\n        const camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );\n        const camPosRight = camPos.dot( camRight );\n        const camPosUp = camPos.dot( camUp );\n\n        // 2. Find how far along its position is along these bases in pixel units\n        const camPosRightPx = camPosRight / pixelWidth;\n        const camPosUpPx = camPosUp / pixelHeight;\n\n        // 3. Find the fractional pixel units and convert to world units\n        const fractX = camPosRightPx - Math.round( camPosRightPx );\n        const fractY = camPosUpPx - Math.round( camPosUpPx );\n\n        // 4. Add fractional world units to the left/right top/bottom to align with the pixel grid\n        camera.left = - aspectRatio - ( fractX * pixelWidth );\n        camera.right = aspectRatio - ( fractX * pixelWidth );\n        camera.top = 1.0 - ( fractY * pixelHeight );\n        camera.bottom = - 1.0 - ( fractY * pixelHeight );\n        camera.updateProjectionMatrix();\n\n    }\n\n    addGrassToTerrain() {\n        const bladeWidth = 12;\n        const bladeHeight = 18;\n        const grassGeometry = this.createCurvedBladeGeometry(bladeWidth, bladeHeight);\n        grassGeometry.translate(0, bladeHeight / 2, 0);\n        const grassCount = 500000;\n\n        const gridSize = this.game.getCollections().configs.game.gridSize;\n        const phases = new Float32Array(grassCount);\n        for (let i = 0; i < grassCount; i++) {\n            phases[i] = Math.random() * Math.PI * 2;\n        }\n        grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(phases, 1));\n\n        const grassTexture = this.createGrassTexture();\n        const grassShader = this.game.getCollections().shaders[this.level.grassShader];\n        this.uniforms['grass'] = JSON.parse(grassShader.uniforms);\n        \n        this.uniforms['grass'].windDirection = { value: new THREE.Vector2(this.uniforms['grass'].windDirection.value[0], this.uniforms['grass'].windDirection.value[1]).normalize()};\n        this.uniforms['grass'].map = { value: grassTexture };\n        this.uniforms['grass'].fogColor = { value: new THREE.Color(this.fogSettings.color) };\n        this.uniforms['grass'].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;\n        const lightDirection = new THREE.Vector3();\n        lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);\n        lightDirection.normalize();\n        if(!this.pixelPass.enabled){\n            this.uniforms['grass'].directionalLightColor = { value: new THREE.Color(this.lightingSettings.directionalColor) };\n            this.uniforms['grass'].directionalLightIntensity = { value: this.lightingSettings.directionalIntensity };\n            this.uniforms['grass'].directionalLightDirection = { value: lightDirection };\n            this.uniforms['grass'].ambientLightColor = { value: new THREE.Color(this.lightingSettings.ambientColor) };\n            this.uniforms['grass'].ambientLightIntensity = { value: this.lightingSettings.ambientIntensity };\n        }\n        this.uniforms['grass'].skyColor =  { value: new THREE.Color(this.lightingSettings.skyColor) }; // HemisphereLight sky color\n        this.uniforms['grass'].groundColor = { value: new THREE.Color(this.lightingSettings.groundColor) }; // HemisphereLight ground color\n        this.uniforms['grass'].hemisphereIntensity = { value: this.lightingSettings.hemisphereIntensity };\n\n        const uniforms = this.uniforms['grass'];\n        this.grassMaterial = new THREE.ShaderMaterial({\n            vertexShader: grassShader.vertexScript,\n            fragmentShader: grassShader.fragmentScript,\n            uniforms: uniforms,\n            transparent: true\n        });\n\n        this.grassShader = this.grassMaterial;\n        \n        grassGeometry.computeVertexNormals(); \n        const grass = new THREE.InstancedMesh(grassGeometry, this.grassMaterial, grassCount);\n        grass.castShadow = true;\n        grass.receiveShadow = false;\n\n        const dummy = new THREE.Object3D();\n        const grassArea = this.extendedSize;  \n        const ctx = this.groundCanvas.getContext('2d');\n        const terrainData = ctx.getImageData(0, 0, this.groundCanvas.width, this.groundCanvas.height).data;\n\n        // Create a density map for grass placement\n        // Create a density map for grass placement\n        const densityMap = new Float32Array(this.extendedSize * this.extendedSize);\n        for (let z = 0; z < this.extendedSize; z++) {\n            for (let x = 0; x < this.extendedSize; x++) {\n                // Check current pixel for green dominance\n                const pixelIndex = (z * this.groundCanvas.width + x) * 4;\n                const isGreenDominant = (pixel) => {\n                    const r = terrainData[pixel];\n                    const g = terrainData[pixel + 1];\n                    const b = terrainData[pixel + 2];\n                    return g > r && g > b;\n                };\n\n                // Only set density if current pixel and all neighbors are green\n                if (isGreenDominant(pixelIndex)) {\n                    // Check 8 neighboring pixels\n                    let checkDist = Math.ceil(gridSize / 10);\n                    const neighbors = [\n                        [-checkDist, -checkDist], [0, -checkDist], [checkDist, -checkDist],\n                        [-checkDist,  0],                           [checkDist,  0],\n                        [-checkDist,  checkDist], [0,  checkDist], [checkDist,  checkDist]\n                    ];\n\n                    let allNeighborsGreen = true;\n                    for (const [dx, dz] of neighbors) {\n                        const nx = x + dx;\n                        const nz = z + dz;\n                        \n                        // Skip if neighbor is outside bounds\n                        if (nx < 0 || nx >= this.extendedSize || nz < 0 || nz >= this.extendedSize) {\n                            allNeighborsGreen = false;\n                            break;\n                        }\n\n                        const neighborIndex = (nz * this.groundCanvas.width + nx) * 4;\n                        if (!isGreenDominant(neighborIndex)) {\n                            allNeighborsGreen = false;\n                            break;\n                        }\n                    }\n\n                    densityMap[z * this.extendedSize + x] = allNeighborsGreen ? 1 : 0;\n                } else {\n                    densityMap[z * this.extendedSize + x] = 0;\n                }\n            }\n        }\n\n        // Place grass based on density\n        let placed = 0;\n        for (let i = 0; i < grassCount * 2 && placed < grassCount; i++) {\n            const x = Math.floor(Math.random() * grassArea);\n            const z = Math.floor(Math.random() * grassArea);\n            if (densityMap[z * this.extendedSize + x] > 0) {\n                const rotationY = Math.random() * Math.PI * 2;\n                const scale = 0.7 + Math.random() * 0.5;\n                let height = this.heightMapSettings.enabled\n                    ? this.heightMapData[Math.min(z, this.extendedSize - 1) * this.extendedSize + Math.min(x, this.extendedSize - 1)] || 0\n                    : 0;\n                dummy.position.set(x - grassArea / 2 + this.terrainSize / 2, height - bladeHeight, z - grassArea / 2 + this.terrainSize / 2);\n                dummy.rotation.set(0, rotationY, 0);\n                dummy.scale.set(scale, scale, scale);\n                dummy.updateMatrix();\n                grass.setMatrixAt(placed++, dummy.matrix);\n            }\n        }\n\n        grass.instanceMatrix.needsUpdate = true;\n        this.scene.add(grass);\n        this.grass = grass;\n    }\n\n    onDestroy() {\n        window.removeEventListener('resize', this.onWindowResizeHandler);\n        this.renderer.dispose();\n        if (this.stats?.dom?.parentElement) {\n            this.stats.dom.parentElement.removeChild(this.stats.dom);\n        }\n        if (this.renderer.domElement?.parentElement) {\n            this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);\n        }\n        if (this.grass) {\n            this.grass.geometry.dispose();\n            this.grass.material.dispose();\n        }\n        this.ground.geometry?.dispose();\n        this.groundMaterial?.dispose();\n        this.groundTexture?.dispose();\n        this.groundCanvas = null;\n        this.game.scene = null;\n        this.game.camera = null;\n        this.game.renderer = null;\n    }\n\n    createCurvedBladeGeometry(width = 0.1, height = 1) {\n        const shape = new THREE.Shape();\n        shape.moveTo(0, 0);\n        shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);\n    \n        const shapeGeom = new THREE.ShapeGeometry(shape, 12);\n        const positions = shapeGeom.attributes.position.array;\n        const uvs = shapeGeom.attributes.uv.array;\n        const vertexCount = positions.length / 3;\n    \n        const newUVs = new Float32Array(uvs.length);\n        const newNormals = new Float32Array(positions.length);\n    \n        for (let i = 0; i < vertexCount; i++) {\n            const posIndex = i * 3;\n            const uvIndex = i * 2;\n            const x = positions[posIndex];\n            const y = positions[posIndex + 1];\n            const normalizedY = y / height;\n    \n            newUVs[uvIndex] = uvs[uvIndex];\n            newUVs[uvIndex + 1] = normalizedY;\n    \n            // Compute normal: approximate outward direction along curve\n            const t = y / height; // Parameter along curve\n            const curveX = width * 0.5 * (1 - t); // Quadratic curve approximation\n            const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();\n            const normal = new THREE.Vector2(-tangent.y, tangent.x); // Perpendicular to tangent\n            newNormals[posIndex] = normal.x;\n            newNormals[posIndex + 1] = 0;\n            newNormals[posIndex + 2] = normal.y;\n        }\n    \n        shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));\n        shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));\n        return shapeGeom;\n    }\n    createGrassTexture() {\n        const canvas = document.createElement('canvas');\n        canvas.width = 4;\n        canvas.height = 32;\n        const ctx = canvas.getContext('2d');\n\n        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\n        gradient.addColorStop(0.0, this.game.palette[\"greenMColor\"]);\n        gradient.addColorStop(0.8, this.game.palette[\"greenMColor\"]);\n        gradient.addColorStop(1.0, this.game.palette[\"redLColor\"]);\n\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        const texture = new THREE.CanvasTexture(canvas);\n        texture.wrapS = THREE.RepeatWrapping;\n        texture.wrapT = THREE.ClampToEdgeWrapping;\n        texture.magFilter = THREE.NearestFilter;\n        texture.minFilter = THREE.NearestFilter;\n        return texture;\n    }\n\n    generateLiquidSurfaceMesh(terrainType) {\n        const terrainMap = this.tileMap.terrainMap;\n        const gridSize = this.game.getCollections().configs.game.gridSize;\n        const rows = terrainMap.length;\n        const cols = terrainMap[0].length;\n        \n        // Arrays to store vertices, indices, and UVs for the BufferGeometry\n        const vertices = [];\n        const indices = [];\n        const uvs = [];\n        \n        // Amount to extend the perimeter (e.g., 10% of gridSize)\n        const extensionAmount = gridSize * 0.25; // Adjust as needed        \n  \n        // Helper function to check if a tile is a water tile\n        const isWaterTile = (x, z) => {\n            if (x < 0 || x >= cols || z < 0 || z >= rows) return false;\n            return terrainMap[z][x] === terrainType;\n        };\n        \n        // Step 1: Generate a grid of vertices, but only for positions needed by water tiles\n        const usedPositions = new Set();\n        for (let z = 0; z < rows; z++) {\n            for (let x = 0; x < cols; x++) {\n                if (terrainMap[z][x] === terrainType) {\n                    usedPositions.add(`${x},${z}`);     // Bottom-left\n                    usedPositions.add(`${x + 1},${z}`); // Bottom-right\n                    usedPositions.add(`${x + 1},${z + 1}`); // Bottom-right in your view (+z is south)\n                    usedPositions.add(`${x},${z + 1}`); // Top-left\n                }\n            }\n        }\n        \n        // Step 2: Create vertices for all used positions and store their original positions\n        const positionToVertexIndex = new Map();\n        const originalPositions = []; // Store original (x, z) for each vertex\n        let vertexIndex = 0;\n        for (const pos of usedPositions) {\n            const [x, z] = pos.split(',').map(Number);\n            positionToVertexIndex.set(pos, vertexIndex++);\n            vertices.push(x * gridSize, 0.1, z * gridSize);\n            originalPositions.push([x, z]); // Store original grid position\n            uvs.push(x, z); // UVs based on grid position\n        }\n        \n        // Step 3: Generate indices for water tiles, connecting them into a single mesh\n        for (let z = 0; z < rows; z++) {\n            for (let x = 0; x < cols; x++) {\n                if (terrainMap[z][x] === terrainType) {\n                    const bl = positionToVertexIndex.get(`${x},${z}`);\n                    const br = positionToVertexIndex.get(`${x + 1},${z}`);\n                    const tr = positionToVertexIndex.get(`${x + 1},${z + 1}`); // Bottom-right in your view\n                    const tl = positionToVertexIndex.get(`${x},${z + 1}`);\n        \n                    indices.push(bl, br, tl);\n                    indices.push(br, tr, tl);\n                }\n            }\n        }\n        \n        // Step 4: Identify perimeter vertices and their extension directions\n        const perimeterExtensions = new Map(); // Map vertexIndex to { extendLeft, extendRight, extendUp, extendDown }\n        for (let z = 0; z < rows; z++) {\n            for (let x = 0; x < cols; x++) {\n                if (terrainMap[z][x] === terrainType) {\n                    const isLeftEdge = !isWaterTile(x - 1, z);\n                    const isRightEdge = !isWaterTile(x + 1, z);\n                    const isBottomEdge = !isWaterTile(x, z - 1); // North\n                    const isTopEdge = !isWaterTile(x, z + 1);    // South\n        \n                    // Bottom-left vertex (x, z)\n                    if (isLeftEdge || isBottomEdge) {\n                        const vIdx = positionToVertexIndex.get(`${x},${z}`);\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\n                        const ext = perimeterExtensions.get(vIdx);\n                        if (isLeftEdge) ext.extendLeft = true;\n                        if (isBottomEdge) ext.extendUp = true; // North\n                    }\n        \n                    // Bottom-right vertex (x + 1, z)\n                    if (isRightEdge || isBottomEdge) {\n                        const vIdx = positionToVertexIndex.get(`${x + 1},${z}`);\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\n                        const ext = perimeterExtensions.get(vIdx);\n                        if (isRightEdge) ext.extendRight = true;\n                        if (isBottomEdge) ext.extendUp = true; // North\n                    }\n        \n                    // Top-right vertex (x + 1, z + 1) - Bottom-right in your view\n                    if (isRightEdge || isTopEdge) {\n                        const vIdx = positionToVertexIndex.get(`${x + 1},${z + 1}`);\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\n                        const ext = perimeterExtensions.get(vIdx);\n                        if (isRightEdge) ext.extendRight = true;\n                        if (isTopEdge) ext.extendDown = true; // South\n                    }\n        \n                    // Top-left vertex (x, z + 1)\n                    if (isLeftEdge || isTopEdge) {\n                        const vIdx = positionToVertexIndex.get(`${x},${z + 1}`);\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\n                        const ext = perimeterExtensions.get(vIdx);\n                        if (isLeftEdge) ext.extendLeft = true;\n                        if (isTopEdge) ext.extendDown = true; // South\n                    }\n                }\n            }\n        }\n        \n        // Step 5: Apply perimeter extensions\n        perimeterExtensions.forEach((ext, vertexIndex) => {\n            const idx = vertexIndex * 3;\n            const [origX, origZ] = originalPositions[vertexIndex];\n        \n            // Log the bottom-right corner for debugging\n            if (ext.extendRight && ext.extendDown) {\n                console.log(`Bottom-right corner at (${origX}, ${origZ}): Before extension - x: ${vertices[idx]}, z: ${vertices[idx + 2]}`);\n            }\n        \n            if (ext.extendLeft) vertices[idx] -= extensionAmount; // Extend left\n            if (ext.extendRight) vertices[idx] += extensionAmount; // Extend right\n            if (ext.extendUp) vertices[idx + 2] -= extensionAmount; // Extend north (decrease z)\n            if (ext.extendDown) vertices[idx + 2] += extensionAmount; // Extend south (increase z)\n        \n            if (ext.extendRight && ext.extendDown) {\n                console.log(`Bottom-right corner at (${origX}, ${origZ}): After extension - x: ${vertices[idx]}, z: ${vertices[idx + 2]}`);\n            }\n        });\n        \n        // Step 6: Create the BufferGeometry\n        const geometry = new THREE.BufferGeometry();\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n        geometry.setIndex(indices);\n        geometry.computeVertexNormals(); // For lighting\n        // Parse the hex color to RGB\n        const parseHexColor = (hex) => {\n            const r = parseInt(hex.slice(1, 3), 16) / 255;\n            const g = parseInt(hex.slice(3, 5), 16) / 255;\n            const b = parseInt(hex.slice(5, 7), 16) / 255;\n            return { r, g, b };\n        };\n        const waterShader = this.game.getCollections().shaders[this.level.waterShader];\n        // Use the hex color in a ShaderMaterial\n        this.uniforms[terrainType] = JSON.parse(waterShader.uniforms);\n        let vectorizeProps = JSON.parse(waterShader.vectors);\n        vectorizeProps.forEach((prop => {\n            if (this.uniforms[terrainType][prop]) {\n                if( prop.toLowerCase().endsWith(\"color\")){\n                    const colorToUse = this.tileMap.terrainTypes[terrainType].color;\n                    const { r, g, b } = parseHexColor(colorToUse);\n                    this.uniforms[terrainType][prop].value = new THREE.Vector3(r, g, b);\n                } else {\n                    let arr = this.uniforms[terrainType][prop].value;\n                    this.uniforms[terrainType][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);\n                }\n            }\n        }));\n        this.uniforms[terrainType].fogColor = { value: new THREE.Color(this.fogSettings.color) };\n        this.uniforms[terrainType].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;\n        // Reference the uniforms\n        const uniforms = this.uniforms[terrainType];\n        \n        // Create the shader material\n        const material = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            vertexShader: waterShader.vertexScript,\n            fragmentShader: waterShader.fragmentScript,\n            side: THREE.DoubleSide,\n            transparent: true\n        });\n\n        // Replace the MeshBasicMaterial with this ShaderMaterial in the mesh creation\n        const waterMesh = new THREE.Mesh(geometry, material);        \n        waterMesh.position.y = (terrainType + 2) * this.heightMapSettings.heightStep;\n        this.scene.add(waterMesh); // Assuming `this.scene` is your THREE.js scene\n    }\n}",
        "filePath": "/global/components/js/ThreeJsWorld.js",
        "fileName": "ThreeJsWorld"
      },
      "AudioManager": {
        "script": "class AudioManager extends engine.Component {\n    constructor(game, parent, params) {\n        super(game, parent, params);\n    }\n\n    init() {\n        this.isInitialized = false;\n        this.bindInitialization();\n    }\n\n    bindInitialization() {\n        const initHandler = () => {\n            if (!this.isInitialized) {\n                this.initialize();\n            }\n        };\n        \n        document.addEventListener('click', initHandler, { once: true });\n        document.addEventListener('keydown', initHandler, { once: true });\n    }\n\n    async initialize() {\n        class SoundPool {\n            constructor(audioContext, destination, poolSize = 8) {\n                this.audioContext = audioContext;\n                this.destination = destination;\n                this.poolSize = poolSize;\n                this.sources = [];\n                this.initializePool();\n            }\n\n            initializePool() {\n                for (let i = 0; i < this.poolSize; i++) {\n                    this.sources.push(this.createSource());\n                }\n            }\n\n            createSource() {\n                const source = {\n                    active: false,\n                    id: null,\n                    envelopeGain: this.audioContext.createGain(),\n                    gainNode: this.audioContext.createGain(),\n                    filter: this.audioContext.createBiquadFilter(),\n                    distortion: this.audioContext.createWaveShaper(),\n                    compressor: this.audioContext.createDynamicsCompressor(),\n                    pannerNode: this.audioContext.createStereoPanner(),\n                    delay: this.audioContext.createDelay(5.0),\n                    delayGain: this.audioContext.createGain(),\n                    convolver: this.audioContext.createConvolver(),\n                    reverbGain: this.audioContext.createGain(),\n                    noiseFilter: this.audioContext.createBiquadFilter(),\n                    noiseGain: this.audioContext.createGain(),\n                    destination: this.destination\n                };\n\n                source.filter.type = 'lowpass';\n                source.filter.frequency.setValueAtTime(20000, this.audioContext.currentTime);\n                source.filter.Q.setValueAtTime(0.5, this.audioContext.currentTime);\n\n                source.noiseFilter.type = 'lowpass';\n                source.noiseFilter.frequency.setValueAtTime(2000, this.audioContext.currentTime);\n                source.noiseFilter.Q.setValueAtTime(1, this.audioContext.currentTime);\n                \n                source.noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.distortion.curve = null;\n                source.distortion.oversample = '4x';\n\n                source.compressor.threshold.setValueAtTime(-24, this.audioContext.currentTime);\n                source.compressor.knee.setValueAtTime(30, this.audioContext.currentTime);\n                source.compressor.ratio.setValueAtTime(12, this.audioContext.currentTime);\n                source.compressor.attack.setValueAtTime(0.003, this.audioContext.currentTime);\n                source.compressor.release.setValueAtTime(0.25, this.audioContext.currentTime);\n\n                source.pannerNode.pan.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.delay.delayTime.setValueAtTime(0.3, this.audioContext.currentTime);\n                source.delayGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                source.reverbGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n\n                const chain = [\n                    source.envelopeGain,\n                    source.gainNode,\n                    source.filter,\n                    source.distortion,\n                    source.compressor,\n                    source.pannerNode\n                ];\n\n                for (let i = 0; i < chain.length - 1; i++) {\n                    chain[i].connect(chain[i + 1]);\n                }\n\n                // Route delay and reverb after filter\n                source.filter.connect(source.delay);\n                source.delay.connect(source.delayGain);\n                source.delayGain.connect(source.delay);\n                source.delayGain.connect(source.pannerNode);\n\n                source.filter.connect(source.convolver);\n                source.convolver.connect(source.reverbGain);\n                source.reverbGain.connect(source.pannerNode);\n\n                source.pannerNode.connect(source.destination);\n\n                return source;\n            }\n\n            getSource() {\n                let source = this.sources.find(src => !src.active && (!src.lastUsed || this.audioContext.currentTime - src.lastUsed > 1));\n                if (!source && this.sources.length < this.poolSize * 2) {\n                    source = this.createSource();\n                    this.sources.push(source);\n                }\n                if (source) {\n                    source.active = true;\n                    source.gainNode.gain.setValueAtTime(1, this.audioContext.currentTime);\n                    source.envelopeGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.delayGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.reverbGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                    source.noiseGain.gain.setValueAtTime(0, this.audioContext.currentTime);\n                }\n                return source;\n            }\n\n            releaseSource(source) {\n                if (source) {\n                    source.active = false;\n                    source.id = null;\n                    const now = this.audioContext.currentTime;\n            \n                    // Reset all nodes\n                    source.filter.frequency.cancelScheduledValues(now);\n                    source.filter.frequency.setValueAtTime(20000, now);\n                    source.distortion.curve = null;\n                    source.pannerNode.pan.setValueAtTime(0, now);\n                    source.envelopeGain.gain.setValueAtTime(0, now);\n                    source.gainNode.gain.setValueAtTime(1, now);\n                    source.delayGain.gain.setValueAtTime(0, now);\n                    source.reverbGain.gain.setValueAtTime(0, now);\n                    source.noiseGain.gain.setValueAtTime(0, now);\n            \n                    // Disconnect and clear sources if they exist\n                    if (source.source) {\n                        try {\n                            source.source.stop(now);\n                            source.source.disconnect();\n                        } catch (e) {\n                            console.warn('Error stopping source:', e);\n                        }\n                        source.source = null;\n                    }\n                    \n                    if (source.noiseSource) {\n                        try {\n                            source.noiseSource.stop(now);\n                            source.noiseSource.disconnect();\n                        } catch (e) {\n                            console.warn('Error stopping noise source:', e);\n                        }\n                        source.noiseSource = null;\n                    }\n            \n                    source.lastUsed = now;\n                }\n            }\n\n            destroy() {\n                this.sources.forEach(source => {\n                    source.envelopeGain.disconnect();\n                    source.gainNode.disconnect();\n                    source.filter.disconnect();\n                    source.distortion.disconnect();\n                    source.compressor.disconnect();\n                    source.pannerNode.disconnect();\n                    source.delay.disconnect();\n                    source.delayGain.disconnect();\n                    source.convolver.disconnect();\n                    source.reverbGain.disconnect();\n                    source.noiseFilter.disconnect();\n                    source.noiseGain.disconnect();\n                });\n                this.sources = [];\n            }\n        }\n        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\n        this.masterBus = this.createAudioBus('master');\n        this.musicBus = this.createAudioBus('music');\n        this.sfxBus = this.createAudioBus('sfx');\n        this.uiBus = this.createAudioBus('ui');\n        this.musicBus.connect(this.masterBus);\n        this.sfxBus.connect(this.masterBus);\n        this.uiBus.connect(this.masterBus);\n        this.masterBus.connect(this.audioContext.destination);\n        this.soundPools = {\n            sfx: new SoundPool(this.audioContext, this.sfxBus.input, 6),\n            music: new SoundPool(this.audioContext, this.musicBus.input, 2),\n            ui: new SoundPool(this.audioContext, this.uiBus.input, 3)\n        };\n        this.buffers = {};\n        this.activeSounds = new Set();\n        if (this.audioContext.state === 'suspended') {\n            await this.audioContext.resume();\n        }\n        this.isInitialized = true;\n    }\n\n    createAudioBus(name) {\n        const bus = {\n            name,\n            input: this.audioContext.createGain(),\n            compressor: this.audioContext.createDynamicsCompressor(),\n            output: this.audioContext.createGain()\n        };\n        \n        bus.input.connect(bus.compressor);\n        bus.compressor.connect(bus.output);\n        \n        bus.connect = (destination) => {\n            bus.output.connect(destination.input || destination);\n        };\n        \n        bus.setVolume = (value) => {\n            const now = this.audioContext.currentTime;\n            bus.output.gain.cancelScheduledValues(now);\n            bus.output.gain.setTargetAtTime(\n                value <= 0 ? 0.000001 : value,\n                now,\n                0.02\n            );\n        };\n        \n        return bus;\n    }\n\n    getSynthSound(soundCollectionName, soundName) {\n        if (this.game.getCollections()[soundCollectionName]?.[soundName]) {\n            return this.game.getCollections()[soundCollectionName][soundName].audio;\n        }\n        console.warn('sound not found', soundCollectionName, soundName);\n        return null;\n    }\n\n    playSound(soundCollectionName, soundName) {\n        let data = this.getSynthSound(soundCollectionName, soundName);\n        if (data) {\n            this.playSynthSound(`${soundCollectionName}_${soundName}`, data);\n        }\n    }\n\n    playSynthSound(soundId, soundConfig, options = {}) {\n        if (!this.isInitialized) {\n            this.initialize();\n            return this.playSynthSound(soundId, soundConfig, options);\n        }\n        \n        const category = options.category || 'sfx';\n        const pool = this.soundPools[category];\n        \n        if (!pool) {\n            console.warn(`No sound pool for category ${category}`);\n            return null;\n        }\n        \n        let instanceCount = 0;\n        this.activeSounds.forEach(sound => {\n            if (sound.id === soundId) instanceCount++;\n        });\n        \n        if (instanceCount >= (options.maxInstances || 3)) {\n            console.warn(`Max instances reached for sound ${soundId}`);\n            return null;\n        }\n        \n        const sound = pool.getSource();\n        if (!sound) {\n            console.warn(`No available source for sound ${soundId}`);\n            return null;\n        }\n        \n        sound.id = soundId;\n        sound.category = category;\n        \n        // Create main oscillator\n        const oscillator = this.createSynthSource(soundConfig);\n        sound.source = oscillator;\n        oscillator.connect(sound.envelopeGain);\n        \n        // Add noise generator if configured\n        if (soundConfig.noise && soundConfig.noise.amount > 0) {\n            this.applyNoiseToSound(sound, soundConfig.noise);\n        }\n        \n        this.createEnvelopeFromConfig(soundConfig.envelope, sound.envelopeGain, soundConfig.duration);\n        \n        if (soundConfig.effects) {\n            this.applySynthEffects(sound, soundConfig.effects, soundConfig);\n        } \n        \n        this.configureSoundInstance(sound, options);\n        \n        const now = this.audioContext.currentTime;\n        oscillator.start(now);\n        \n        // Start noise generator if it exists\n        if (sound.noiseSource) {\n            sound.noiseSource.start(now);\n        }\n        \n        const duration = soundConfig.duration || 1;\n        const release = (soundConfig.envelope?.release) || 0.3;\n        let totalDuration = duration + release;\n        \n        if (soundConfig.effects?.delay?.time) {\n            const delayTail = soundConfig.effects.delay.time * 3;\n            if (totalDuration < delayTail) {\n                totalDuration = delayTail;\n            }\n        }\n        \n        oscillator.stop(now + totalDuration + 0.02);\n        if (sound.noiseSource) {\n            sound.noiseSource.stop(now + totalDuration + 0.02);\n        }\n        \n        this.activeSounds.add(sound);\n        \n        oscillator.onended = () => {\n            setTimeout(() => {\n                sound.active = false;\n                this.activeSounds.delete(sound);\n                pool.releaseSource(sound);\n            }, (soundConfig.effects?.delay?.time || 0) * 1000 * 3);\n        };\n        \n        return sound;\n    }\n\n    createSynthSource(config) {\n        // Default to oscillator unless waveform is 'noise'\n        const oscillator = config.waveform === 'noise'\n            ? this.createNoiseSource('white') \n            : this.audioContext.createOscillator();\n    \n        if (config.waveform !== 'noise') {\n            oscillator.type = config.waveform || 'sine';\n            const baseFreq = config.frequency || 440;\n            const now = this.audioContext.currentTime;\n    \n            // Initialize frequency\n            oscillator.frequency.cancelScheduledValues(now);\n            oscillator.frequency.setValueAtTime(baseFreq, now);\n    \n            // Apply pitch envelope if defined\n            if (config.pitchEnvelope) {\n                const startMultiplier = config.pitchEnvelope.start ?? 1;\n                const endMultiplier = config.pitchEnvelope.end ?? 1;\n                const envelopeTime = config.pitchEnvelope.time ?? config.duration ?? 1;\n    \n                if (startMultiplier !== 1 || endMultiplier !== 1) {\n                    const startFreq = baseFreq * startMultiplier;\n                    const endFreq = baseFreq * endMultiplier;\n    \n                    oscillator.frequency.setValueAtTime(startFreq, now);\n                    oscillator.frequency.exponentialRampToValueAtTime(\n                        Math.max(endFreq, 0.01),\n                        now + envelopeTime\n                    );\n                }\n            }\n        }\n    \n        return oscillator;\n    }\n\n    applyNoiseToSound(sound, noiseConfig) {\n        if (!noiseConfig || noiseConfig.amount <= 0) return;\n\n        const noiseType = noiseConfig.type || 'white';\n        const noiseAmount = Math.min(1, Math.max(0, noiseConfig.amount));\n        \n        // Create the noise source\n        sound.noiseSource = this.createNoiseSource(noiseType);\n        \n        // Configure noise filter if specified\n        if (noiseConfig.filter && noiseConfig.filter.type !== 'none') {\n            sound.noiseFilter.type = noiseConfig.filter.type || 'lowpass';\n            sound.noiseFilter.frequency.setValueAtTime(\n                noiseConfig.filter.frequency || 2000, \n                this.audioContext.currentTime\n            );\n        }\n        \n        // Set noise gain based on the amount\n        sound.noiseGain.gain.setValueAtTime(noiseAmount, this.audioContext.currentTime);\n        \n        // Connect noise through the filter and envelope\n        sound.noiseSource.connect(sound.noiseFilter);\n        sound.noiseFilter.connect(sound.noiseGain);\n        sound.noiseGain.connect(sound.envelopeGain);\n    }\n\n    createNoiseSource(noiseType = 'white') {\n        const bufferSize = this.audioContext.sampleRate * 2;\n        const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);\n        const output = noiseBuffer.getChannelData(0);\n        \n        // Generate different types of noise\n        switch (noiseType) {\n            case 'pink':\n                this.generatePinkNoise(output);\n                break;\n            case 'brown':\n                this.generateBrownNoise(output);\n                break;\n            case 'white':\n            default:\n                this.generateWhiteNoise(output);\n                break;\n        }\n        \n        const source = this.audioContext.createBufferSource();\n        source.buffer = noiseBuffer;\n        source.loop = true;\n        \n        return source;\n    }\n\n    generateWhiteNoise(output) {\n        for (let i = 0; i < output.length; i++) {\n            output[i] = Math.random() * 2 - 1;\n        }\n    }\n\n    generatePinkNoise(output) {\n        // Pink noise algorithm (approximation using Paul Kellet's method)\n        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;\n        \n        for (let i = 0; i < output.length; i++) {\n            const white = Math.random() * 2 - 1;\n            \n            // Filter white noise to create pink noise\n            b0 = 0.99886 * b0 + white * 0.0555179;\n            b1 = 0.99332 * b1 + white * 0.0750759;\n            b2 = 0.96900 * b2 + white * 0.1538520;\n            b3 = 0.86650 * b3 + white * 0.3104856;\n            b4 = 0.55000 * b4 + white * 0.5329522;\n            b5 = -0.7616 * b5 - white * 0.0168980;\n            \n            output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;\n            b6 = white * 0.115926;\n        }\n    }\n\n    generateBrownNoise(output) {\n        // Brown noise algorithm (random walk)\n        let lastValue = 0;\n        \n        for (let i = 0; i < output.length; i++) {\n            // Small random change from previous value\n            const white = Math.random() * 2 - 1;\n            lastValue = (lastValue + (0.02 * white)) / 1.02;\n            \n            // Keep within range\n            output[i] = lastValue * 3.5; // Amplify to make it audible\n        }\n        \n        // Normalize to prevent clipping\n        const max = Math.max(...Array.from(output).map(Math.abs));\n        if (max > 0) {\n            for (let i = 0; i < output.length; i++) {\n                output[i] /= max;\n            }\n        }\n    }\n\n    createEnvelopeFromConfig(envelope, gainNode, duration = 1) {\n        if (!envelope) {\n            console.warn('No envelope provided, using default');\n            envelope = { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.3 };\n        }\n        \n        const now = this.audioContext.currentTime;\n        \n        const attack = Math.max(0.01, envelope.attack || 0.01);\n        const decay = Math.max(0, envelope.decay || 0.1);\n        const sustain = Math.max(0, Math.min(1, envelope.sustain || 0.7));\n        const release = Math.max(0.02, envelope.release || 0.3);\n        \n        gainNode.gain.cancelScheduledValues(now);\n        gainNode.gain.setValueAtTime(0, now);\n        gainNode.gain.linearRampToValueAtTime(1, now + attack);\n        gainNode.gain.linearRampToValueAtTime(sustain, now + attack + decay);\n        gainNode.gain.setValueAtTime(sustain, now + duration);\n        gainNode.gain.setTargetAtTime(0.0001, now + duration, release / 3);\n        gainNode.gain.setValueAtTime(0, now + duration + release); // Absolute zero\n    }\n\n    applySynthEffects(sound, effectsConfig, soundConfig) {\n        const now = this.audioContext.currentTime;\n        \n        // Filter\n        if (effectsConfig.filter) {\n            sound.filter.type = effectsConfig.filter.type || 'lowpass';\n            sound.filter.frequency.setValueAtTime(effectsConfig.filter.frequency || 20000, now);\n            sound.filter.Q.setValueAtTime(effectsConfig.filter.Q || 0.5, now);\n            \n            // Apply pitch envelope to filter for noise waveforms\n            if (sound.source.buffer && soundConfig.pitchEnvelope && (soundConfig.pitchEnvelope.start !== 1 || soundConfig.pitchEnvelope.end !== 1)) {\n                const baseFreq = soundConfig.frequency || 100;\n                const startFreq = baseFreq * (soundConfig.pitchEnvelope.start + 1);\n                const endFreq = baseFreq * soundConfig.pitchEnvelope.end;\n                const duration = soundConfig.pitchEnvelope.time || soundConfig.duration || 1;\n                \n                sound.filter.frequency.cancelScheduledValues(now);\n                sound.filter.frequency.setValueAtTime(startFreq, now);\n                sound.filter.frequency.exponentialRampToValueAtTime(\n                    Math.max(endFreq, 0.01),\n                    now + duration\n                );\n                sound.filter.frequency.exponentialRampToValueAtTime(\n                    Math.max(endFreq * 0.5, 0.01),\n                    now + soundConfig.duration + (soundConfig.envelope?.release || 0.3)\n                );\n            }\n        }\n        \n        // Distortion\n        if (effectsConfig.distortion && effectsConfig.distortion > 0) {\n            sound.distortion.curve = this.makeDistortionCurve(effectsConfig.distortion);\n        } else {\n            sound.distortion.curve = null;\n        }\n        \n        // Delay\n        if (effectsConfig.delay && effectsConfig.delay.feedback > 0) {\n            sound.delay.delayTime.setValueAtTime(effectsConfig.delay.time || 0.3, now);\n            sound.delayGain.gain.setValueAtTime(Math.min(effectsConfig.delay.feedback || 0, 0.8), now);\n            sound.delayGain.gain.setTargetAtTime(0, now + soundConfig.duration + (soundConfig.envelope?.release || 0.3), 0.1);\n        } else {\n            sound.delayGain.gain.setValueAtTime(0, now);\n        }\n        \n        // Reverb\n        if (effectsConfig.reverb && effectsConfig.reverb > 0) {\n            this.generateImpulseResponse(sound.convolver);\n            sound.reverbGain.gain.setValueAtTime(Math.min(effectsConfig.reverb, 1), now);\n            sound.reverbGain.gain.setTargetAtTime(0, now + soundConfig.duration + (soundConfig.envelope?.release || 0.3), 0.2);\n        } else {\n            sound.reverbGain.gain.setValueAtTime(0, now);\n        }\n        \n        // Panning\n        if (effectsConfig.pan !== undefined) {\n            sound.pannerNode.pan.setValueAtTime(Math.max(-1, Math.min(1, effectsConfig.pan)), now);\n        }\n    }\n\n    configureSoundInstance(sound, options) {\n        const now = this.audioContext.currentTime;\n        \n        if (options.volume !== undefined) {\n            sound.gainNode.gain.cancelScheduledValues(now);\n            sound.gainNode.gain.setTargetAtTime(\n                options.volume <= 0 ? 0.000001 : Math.max(0, Math.min(options.volume, 1)),\n                now,\n                0.02\n            );\n        }\n        \n        if (options.position && sound.pannerNode.positionX) {\n            const pos = options.position;\n            sound.pannerNode.positionX.setValueAtTime(pos.x || 0, now);\n            sound.pannerNode.positionY.setValueAtTime(pos.y || 0, now);\n            sound.pannerNode.positionZ.setValueAtTime(pos.z || 0, now);\n        }\n        \n        if (options.pitch && sound.source && sound.source.playbackRate) {\n            sound.source.playbackRate.setValueAtTime(options.pitch, now);\n        }\n    }\n\n    generateImpulseResponse(convolver) {\n        const length = this.audioContext.sampleRate * 1.5; // Shorter impulse\n        const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);\n        \n        for (let channel = 0; channel < 2; channel++) {\n            const impulseData = impulse.getChannelData(channel);\n            for (let i = 0; i < length; i++) {\n                const decay = Math.pow(1 - i / length, 2);\n                impulseData[i] = (Math.random() * 2 - 1) * decay;\n            }\n        }\n        \n        convolver.buffer = impulse;\n    }\n\n    makeDistortionCurve(amount) {\n        const k = Math.max(amount, 0) * 10;\n        const n_samples = 44100;\n        const curve = new Float32Array(n_samples);\n        const deg = Math.PI / 180;\n        for (let i = 0; i < n_samples; i++) {\n            const x = (i * 2) / n_samples - 1;\n            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n        }\n        return curve;\n    }\n\n    stopSound(sound) {\n        if (!sound) return;\n        \n        const now = this.audioContext.currentTime;\n        \n        if (sound.gainNode) {\n            sound.gainNode.gain.cancelScheduledValues(now);\n            sound.gainNode.gain.setValueAtTime(sound.gainNode.gain.value || 0, now);\n            sound.gainNode.gain.linearRampToValueAtTime(0, now + 0.05);\n        }\n        \n        if (sound.source) {\n            try {\n                sound.source.stop(now + 0.06);\n            } catch (e) {\n                console.warn('Error stopping source:', e);\n            }\n        }\n        \n        if (sound.noiseSource) {\n            try {\n                sound.noiseSource.stop(now + 0.06);\n            } catch (e) {\n                console.warn('Error stopping noise source:', e);\n            }\n        }\n        \n        sound.active = false;\n        this.activeSounds.delete(sound);\n    }\n\n    stopAllSounds() {\n        this.activeSounds.forEach(sound => {\n            this.stopSound(sound);\n        });\n        this.activeSounds.clear();\n    }\n}",
        "filePath": "/global/components/js/AudioManager.js",
        "fileName": "AudioManager"
      },
      "MapManager": {
        "script": "class MapManager extends engine.Component {\r\n        \r\n    init({level}) {\r\n        this.nodeClass = class Node {\r\n            constructor(x, y, tileType, parent = null) {\r\n                this.x = x;\r\n                this.y = y;\r\n                this.tileType = tileType;\r\n                this.parent = parent;\r\n                \r\n                this.g = 0; // Cost from start to current node\r\n                this.h = 0; // Heuristic (estimated cost from current to goal)\r\n                this.f = 0; // Total cost (g + h)\r\n            }\r\n\r\n            equals(other) {\r\n                return this.x === other.x && this.y === other.y;\r\n            }\r\n\r\n            // Unique key for node based on coordinates\r\n            key() {\r\n                return `${this.x},${this.y}`;\r\n            }\r\n        };\r\n        this.tileMap = this.game.getCollections().levels[level].tileMap;\r\n\r\n        const {tileMap, paths} = this.generateMap();\r\n        this.game.state.tileMap = tileMap;\r\n        this.game.state.paths = paths;\r\n    }\r\n\r\n    getTerrainHeight(gridPosition) {\r\n        if(this.game.state.tileMap.length > gridPosition.y && gridPosition.y > 0 && this.game.state.tileMap[Math.floor(gridPosition.y)] && this.game.state.tileMap[Math.floor(gridPosition.y)].length > gridPosition.x && gridPosition.x > 0){\r\n            const tile = this.game.state.tileMap[Math.floor(gridPosition.y)][Math.floor(gridPosition.x)];\r\n            if (!tile) {\r\n                return 0;\r\n            }              \r\n            let heightStep = 1;\r\n            if(this.game.heightMapConfig){\r\n                heightStep = this.game.heightMapConfig.heightStep\r\n            }\r\n            const terrainHeight = tile.typeId * heightStep;\r\n            return terrainHeight;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    generateMap() {\r\n        // Extract values from the data object\r\n        const { size, terrainTypes, terrainMap } = this.tileMap;\r\n        let paths = [];\r\n        let starts = [];\r\n        let endPoint = {x: 0, y: 0};\r\n\r\n        // Find START and END tile types by their IDs\r\n        const startTypeId = terrainTypes.findIndex(t => t.type === \"start\");\r\n        const endTypeId = terrainTypes.findIndex(t => t.type === \"end\");\r\n        // Create the tile map using the provided terrainMap\r\n        const tileMap = terrainMap.map((row, y) => \r\n            row.map((terrainId, x) => {\r\n                // Find the terrain object to get color information\r\n                const terrain = terrainTypes[terrainId]; \r\n                // Check for start/end points using IDs\r\n                if(terrainId === startTypeId) {\r\n                    starts.push({x: x, y: y});\r\n                } else if(terrainId === endTypeId) {\r\n                    endPoint = {x: x, y: y};\r\n                }\r\n                \r\n                return { \r\n                    type: terrain ? terrain.type : 'unknown',\r\n                    typeId: terrainId,\r\n                    color: terrain ? terrain.color : '#8bc34a', // Default to grass color if not found\r\n                    buildable: terrain ? terrain.buildable : false\r\n                };\r\n            })\r\n        );        \r\n        \r\n        starts.forEach((startPoint) => {\r\n            paths.push(this.findPath(startPoint, endPoint, terrainMap));\r\n        });\r\n\r\n        return { tileMap, paths };\r\n    }\r\n\r\n    findPath(startPoint, endPoint, tileMap) {\r\n        return this.aStar(startPoint, endPoint, tileMap);\r\n    }\r\n    \r\n    /**\r\n     * A* pathfinding algorithm\r\n     * @param {Object} start - Starting position {x, y}\r\n     * @param {Object} end - Ending position {x, y}\r\n     * @param {Array} tileMap - 2D array representing the map\r\n     * @returns {Array} - Array of positions forming the path, or empty array if no path found\r\n     */\r\n    aStar(start, end, tileMap) {\r\n       \r\n        const rows = tileMap.length;\r\n        const cols = tileMap[0].length;\r\n        \r\n        // Validate inputs\r\n        if (start.x < 0 || start.x >= cols || start.y < 0 || start.y >= rows) {\r\n            throw new Error('Start position is outside the map bounds');\r\n        }\r\n        if (end.x < 0 || end.x >= cols || end.y < 0 || end.y >= rows) {\r\n            throw new Error('End position is outside the map bounds');\r\n        }\r\n        \r\n        // Create start and end nodes\r\n        const startNode = new this.nodeClass(start.x, start.y, tileMap[start.y][start.x]);\r\n        const endNode = new this.nodeClass(end.x, end.y, tileMap[end.y][end.x]);\r\n        \r\n        // Initialize open and closed lists\r\n        const openList = [];\r\n        const closedList = new Set();\r\n        const openSet = new Set(); // For faster lookups\r\n        \r\n        // Add start node to open list\r\n        openList.push(startNode);\r\n        openSet.add(startNode.key());\r\n        \r\n        // Define movement directions (4-directional: up, right, down, left)\r\n        const directions = [\r\n            {x: 0, y: -1}, // Up\r\n            {x: 1, y: 0},  // Right\r\n            {x: 0, y: 1},  // Down\r\n            {x: -1, y: 0}  // Left\r\n            \r\n            // {x: 1, y: 1}, // Up\r\n            // {x: 1, y: -1},  // Right\r\n            // {x: -1, y: 1},  // Down\r\n            // {x: -1, y: -1}  // Left\r\n        ];\r\n        \r\n        // Main loop\r\n        while (openList.length > 0) {\r\n            // Sort by f value and take the lowest\r\n            openList.sort((a, b) => a.f - b.f);\r\n            const currentNode = openList.shift();\r\n            openSet.delete(currentNode.key());\r\n            \r\n            // Add current node to closed list\r\n            closedList.add(currentNode.key());\r\n            \r\n            // Check if we've reached the end\r\n            if (currentNode.equals(endNode)) {\r\n                // Reconstruct the path\r\n                return this.reconstructPath(currentNode);\r\n            }\r\n            \r\n            // Generate neighbors\r\n            for (const dir of directions) {\r\n                const neighborX = currentNode.x + dir.x;\r\n                const neighborY = currentNode.y + dir.y;\r\n                \r\n                // Check if neighbor is inside the map\r\n                if (neighborX < 0 || neighborX >= cols || neighborY < 0 || neighborY >= rows) {\r\n                    continue;\r\n                }\r\n                \r\n                const tileType = tileMap[neighborY][neighborX];\r\n                const neighbor = new this.nodeClass(neighborX, neighborY, tileType, currentNode);\r\n                const neighborKey = neighbor.key();\r\n                \r\n                // Skip if neighbor is in closed list\r\n                if (closedList.has(neighborKey)) {\r\n                    continue;\r\n                }\r\n                \r\n                // Calculate g score for this neighbor\r\n                // Path tiles will have a much lower cost than other tile types\r\n                let movementCost = this.calculateMovementCost(tileType);\r\n                const tentativeG = currentNode.g + movementCost;\r\n                \r\n                // Check if this is a better path to neighbor\r\n                if (!openSet.has(neighborKey) || tentativeG < neighbor.g) {\r\n                    // Update neighbor values\r\n                    neighbor.g = tentativeG;\r\n                    neighbor.h = this.calculateHeuristic(neighbor, endNode);\r\n                    neighbor.f = neighbor.g + neighbor.h;\r\n                    \r\n                    // Add neighbor to open list if not there already\r\n                    if (!openSet.has(neighborKey)) {\r\n                        openList.push(neighbor);\r\n                        openSet.add(neighborKey);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // No path found\r\n        return [];\r\n    }\r\n    \r\n    /**\r\n     * Calculate movement cost based on tile type\r\n     * Path tiles are heavily favored\r\n     * @param {number} tileTypeId - ID of the tile type\r\n     * @returns {number} - Movement cost\r\n     */\r\n    calculateMovementCost(tileTypeId) {\r\n        // Find path and end type IDs\r\n        const { terrainTypes } = this.tileMap;\r\n        const pathTypeId = terrainTypes.findIndex(t => t.type === \"path\");\r\n        const endTypeId = terrainTypes.findIndex(t => t.type === \"end\");\r\n        \r\n        // Heavily favor \"path\" and \"end\" type tiles\r\n        if (tileTypeId === pathTypeId || tileTypeId === endTypeId) {\r\n            return 1;\r\n        } else {\r\n            // Make non-path tiles much less desirable\r\n            return 100000;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate heuristic (Manhattan distance)\r\n     * @param {Node} nodeA \r\n     * @param {Node} nodeB \r\n     * @returns {number} - Heuristic value\r\n     */\r\n    calculateHeuristic(nodeA, nodeB) {\r\n        return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);\r\n    }\r\n    \r\n    /**\r\n     * Reconstruct the path from the end node to the start\r\n     * @param {Node} endNode - The end node\r\n     * @returns {Array} - Array of positions {x, y} from start to end\r\n     */\r\n    reconstructPath(endNode) {\r\n        const path = [];\r\n        let currentNode = endNode;\r\n        \r\n        while (currentNode !== null) {\r\n            path.unshift({\r\n                x: currentNode.x,\r\n                y: currentNode.y,\r\n                tileType: currentNode.tileType\r\n            });\r\n            currentNode = currentNode.parent;\r\n        }\r\n        \r\n        return path;\r\n    }\r\n}",
        "filePath": "/global/components/js/MapManager.js",
        "fileName": "MapManager"
      },
      "Collider": {
        "script": "class Collider extends engine.Component {\r\n    init({ debug = false, objectType, spawnType }) {\r\n        this.id = this.parent.id;\r\n        this.prefabData = this.game.getCollections()[objectType][spawnType];\r\n        this.colliderData = this.game.getCollections().colliders[this.prefabData.collider];\r\n        if(!this.colliderData){\r\n            this.colliderData = {\r\n                type: \"sphere\",\r\n                size: 1,\r\n                offset: new THREE.Vector3(),\r\n                gravity: true,\r\n                mass: 1,\r\n                restitution: 0.25\r\n            }\r\n        }\r\n        this.type = this.colliderData.type; \r\n        this.size = this.colliderData.size; \r\n        if(typeof  this.colliderData.offset == \"string\")  this.colliderData.offset = JSON.parse( this.colliderData.offset);\r\n        this.offset = this.colliderData.offset ? new THREE.Vector3(this.colliderData.offset.x, this.colliderData.offset.y, this.colliderData.offset.z) : new THREE.Vector3(0, 0, 0); // Center offset\r\n        this.gravity = this.colliderData.gravity;\r\n        this.mass = this.colliderData.mass; \r\n        this.restitution = this.colliderData.restitution;\r\n        this.debug = debug; // Enable debug mode\r\n        this.debugMesh = null; // Store debug mesh\r\n        this.lerpFactor = this.colliderData.lerpFactor || .7; // Adjust this value to control smoothing (0-1)\r\n     \r\n        // Register with physics system\r\n        this.game.gameEntity.getComponent('Physics').registerCollider(this);\r\n\r\n        // Create debug visualization if debug mode is enabled\r\n        if (this.debug) {\r\n            this.createDebugMesh();\r\n        }\r\n    }\r\n\r\n    createDebugMesh() {\r\n        let geometry, material;\r\n\r\n        if (this.type === 'sphere') {\r\n            geometry = new THREE.SphereGeometry(this.size, 16, 16); // Low-poly for performance\r\n            material = new THREE.MeshBasicMaterial({\r\n                color: 0x00ff00, // Green wireframe\r\n                wireframe: true\r\n            });\r\n        } else if (this.type === 'box') {\r\n            geometry = new THREE.BoxGeometry(this.size.x, this.size.y, this.size.z);\r\n            material = new THREE.MeshBasicMaterial({\r\n                color: 0x00ff00, // Green wireframe\r\n                wireframe: true\r\n            });\r\n        } else {\r\n            throw new Error(`Unsupported collider type: ${this.type}`);\r\n        }\r\n\r\n        this.debugMesh = new THREE.Mesh(geometry, material);\r\n        this.debugMesh.position.copy(this.parent.transform.physicsPosition).add(this.offset);\r\n        this.game.scene.add(this.debugMesh); // Add to the Three.js scene\r\n    }\r\n\r\n    getAABB(position = this.parent.transform.physicsPosition) {\r\n        const pos = position.clone().add(this.offset);\r\n        if (this.type === 'sphere') {\r\n            const radius = this.size;\r\n            return {\r\n                min: {\r\n                    x: pos.x - radius,\r\n                    y: pos.y - radius,\r\n                    z: pos.z - radius\r\n                },\r\n                max: {\r\n                    x: pos.x + radius,\r\n                    y: pos.y + radius,\r\n                    z: pos.z + radius\r\n                }\r\n            };\r\n        } else if (this.type === 'box') {\r\n            return {\r\n                min: {\r\n                    x: pos.x - this.size.x / 2,\r\n                    y: pos.y - this.size.y / 2,\r\n                    z: pos.z - this.size.z / 2\r\n                },\r\n                max: {\r\n                    x: pos.x + this.size.x / 2,\r\n                    y: pos.y + this.size.y / 2,\r\n                    z: pos.z + this.size.z / 2\r\n                }\r\n            };\r\n        }\r\n        throw new Error(`Unsupported collider type: ${this.type}`);\r\n    }\r\n\r\n    update() {\r\n \r\n        this.parent.transform.position.lerp(\r\n            this.parent.transform.physicsPosition,\r\n            this.lerpFactor\r\n        );\r\n\r\n        // Update debug mesh position if it exists\r\n        if (this.debug && this.debugMesh) {\r\n            this.debugMesh.position.copy(this.parent.transform.physicsPosition).add(this.offset);\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        // Clean up debug mesh if it exists\r\n        if (this.debug && this.debugMesh) {\r\n            this.game.scene.remove(this.debugMesh);\r\n            this.debugMesh.geometry.dispose();\r\n            this.debugMesh.material.dispose();\r\n            this.debugMesh = null;\r\n        }\r\n    }\r\n}",
        "filePath": "/global/components/js/Collider.js",
        "fileName": "Collider"
      },
      "Stats": {
        "script": "class Stats extends engine.Component {\r\n    \r\n    constructor(game, parent, params) {\r\n        super(game, parent, params);\r\n    }\r\n    \r\n    \r\n  init( {objectType, spawnType} ) {        \r\n        \r\n        let stats = this.game.getCollections()[objectType][spawnType];\r\n        this.type = spawnType;\r\n        this.stats = {...stats};\r\n        this.defaultStats = {...this.stats};\r\n        this.activeEffects = {};\r\n    }\r\n    update() {\r\n        this.stats = {...this.defaultStats};\r\n        this.applyEffects();\r\n        this.applyUpgrades();\r\n    }\r\n    addStat(statName, statValue) {\r\n        this.stats[statName] = statValue;\r\n        this.defaultStats[statName] = statValue;\r\n    }\r\n    addEffect(effectConfig, effectFn, effectAmt) {        \r\n        this.activeEffects[effectConfig.id] = this.parent.addComponent(\"effect\", { config: effectConfig, applyFn: effectFn, amount: effectAmt });\r\n    }\r\n    applyEffects() {\r\n        let effectArr = [];\r\n        for(let effectId in this.activeEffects) {\r\n            if(this.activeEffects[effectId] && this.activeEffects[effectId].lifeTime > 0){\r\n                effectArr.push(this.activeEffects[effectId]);\r\n            } else {\r\n                this.activeEffects[effectId] = undefined;\r\n            }\r\n        }        \r\n        \r\n        engine.getFunction(\"calculateStats\")(this.stats, effectArr);\r\n    }\r\n    \r\n    applyUpgrades() {\r\n        if(this.game.state.activeUpgrades && this.game.state.activeUpgrades[this.type]){\r\n            engine.getFunction(\"calculateStats\")(this.stats, this.game.state.activeUpgrades[this.type]);        \r\n        }\r\n    }\r\n}",
        "filePath": "/global/components/js/Stats.js",
        "fileName": "Stats"
      },
      "PlayerController": {
        "script": "class PlayerController extends engine.Component {\r\n    init({\r\n        walkSpeed = 40, // Adjusted for Rapier (meters/second)\r\n        runSpeed = 100,\r\n        jumpForce = 250, // Adjusted for Rapier (meters/second)\r\n        gravity = 981, // Standard gravity (m/s)\r\n        mouseSensitivity = 0.002,\r\n        characterHeight = 18,\r\n        characterRadius = 3,\r\n        cameraHeight = 16,\r\n        cameraSmoothing = 0.2,\r\n        isRemote = false\r\n    }) {\r\n        let gameComponent = this.game.gameEntity.getComponent('game');\r\n        \r\n        this.modelRenderer = this.parent.getComponent('ModelRenderer');\r\n        this.modelRenderer.setFrustumCulled(false);\r\n        this.world = gameComponent.world;\r\n        this.physics = gameComponent.physics;\r\n        this.scene = this.world.scene;\r\n        this.camera = this.game.camera;\r\n\r\n        // Movement parameters\r\n        this.walkSpeed = walkSpeed;\r\n        this.runSpeed = runSpeed;\r\n        this.jumpForce = jumpForce;\r\n        this.gravity = gravity;\r\n        this.mouseSensitivity = mouseSensitivity;\r\n        this.cameraSmoothing = cameraSmoothing;\r\n\r\n        // Character dimensions\r\n        this.characterHeight = characterHeight;\r\n        this.characterRadius = characterRadius;\r\n        this.cameraHeight = cameraHeight;\r\n\r\n\r\n        // Initialize movement state\r\n        this.velocity = new THREE.Vector3(); // For tracking vertical velocity (e.g., jumping, gravity)\r\n        this.isGrounded = false;\r\n        this.jumpRequested = false;\r\n        this.isRunning = false;\r\n\r\n        // Camera properties\r\n        this.isFirstPerson = false; // Default to first-person\r\n        this.thirdPersonDistance = 50;\r\n        this.thirdPersonHeight = 25;\r\n        this.cameraTargetPosition = new THREE.Vector3();\r\n        this.cameraLookAt = new THREE.Vector3();\r\n        this.cameraPitch = 0;\r\n        this.cameraYaw = 0;\r\n\r\n        // Local axes\r\n        this.forward = new THREE.Vector3(0, 0, 1);\r\n        this.up = new THREE.Vector3(0, 1, 0);\r\n        this.right = new THREE.Vector3(1, 0, 0);\r\n\r\n        // Movement inputs\r\n        this.moveForward = 0;\r\n        this.moveRight = 0;\r\n\r\n        //this is just a ghost instance of a remote player\r\n        this.isRemote = isRemote;\r\n        // Input state\r\n        this.keys = {\r\n            KeyW: false,\r\n            KeyS: false,\r\n            KeyA: false,\r\n            KeyD: false,\r\n            ShiftLeft: false,\r\n            Space: false\r\n        };\r\n        this.lastKeys = {...this.keys};\r\n        // Pointer lock controls\r\n        this.controls = { isLocked: false };\r\n\r\n\r\n        if(!this.isRemote) { \r\n            document.addEventListener('click', () => {            \r\n                if (!this.controls.isLocked) {\r\n                    this.world.renderer.domElement.requestPointerLock();\r\n                }\r\n            });\r\n            document.addEventListener('pointerlockchange', () => {\r\n                this.controls.isLocked = document.pointerLockElement === this.world.renderer.domElement;\r\n            });\r\n        // Bind event handlers\r\n            this.onKeyDown = this.onKeyDown.bind(this);\r\n            this.onKeyUp = this.onKeyUp.bind(this);\r\n            this.onMouseMove = this.onMouseMove.bind(this);\r\n            document.addEventListener('keydown', this.onKeyDown);\r\n            document.addEventListener('keyup', this.onKeyUp);\r\n            document.addEventListener('mousemove', this.onMouseMove);\r\n        }\r\n        // Debug helpers\r\n        this.debug = {\r\n            showRaycasts: false,\r\n            raycastHelpers: []\r\n        };\r\n    }\r\n    getNetworkData(){     \r\n        let data = {\r\n            keys: this.keys,\r\n            direction: {\r\n                forward: {\r\n                    x: this.forward.x,\r\n                    y: this.forward.y,\r\n                    z: this.forward.z\r\n                },\r\n                right:{\r\n                    x: this.right.x,\r\n                    y: this.right.y,\r\n                    z: this.right.z\r\n                },\r\n                up: {\r\n                    x: this.up.x,\r\n                    y: this.up.y,\r\n                    z: this.up.z\r\n                }\r\n            }\r\n        } \r\n        \r\n        if(JSON.stringify(this.lastKeys) != JSON.stringify(this.keys)){\r\n            console.log('get', data);\r\n        }   \r\n        this.lastKeys = {...this.keys};\r\n        return data;       \r\n    }\r\n    \r\n    setNetworkData(data){\r\n\r\n        if(this.game.isServer){\r\n    \r\n            if(data.keys){\r\n                if(JSON.stringify(data.keys) != JSON.stringify(this.keys)){\r\n                    console.log('set', data);\r\n                }\r\n                this.keys = data.keys;\r\n                this.forward.set(data.direction.forward.x, data.direction.forward.y, data.direction.forward.z);\r\n                this.right.set(data.direction.right.x, data.direction.right.y, data.direction.right.z);\r\n                this.up.set(data.direction.up.x, data.direction.up.y, data.direction.up.z);\r\n            }\r\n        }\r\n    }\r\n\r\n    setupPhysics(simulation) {\r\n        \r\n        // Initialize Rapier physics\r\n        this.rapierWorld = simulation; // Assume InfiniWorld initializes a Rapier World\r\n        this.characterController = this.rapierWorld.createCharacterController(0.01); // Offset of 0.01m\r\n        this.setupCharacterController();\r\n\r\n        // Create player rigid-body and collider\r\n        this.setupPlayerBody();\r\n    }\r\n\r\n    setupCharacterController() {\r\n        // Configure Rapier character controller\r\n        this.characterController.enableAutostep(0.3, 0.2, true); // Auto-step for stairs/obstacles\r\n        this.characterController.enableSnapToGround(0.5); // Stick to ground when going downhill\r\n        this.characterController.setMaxSlopeClimbAngle(45 * Math.PI / 180); // Max 45 climb\r\n        this.characterController.setMinSlopeSlideAngle(30 * Math.PI / 180); // Slide on steep slopes\r\n        this.characterController.setApplyImpulsesToDynamicBodies(true); // Push dynamic objects\r\n        this.characterController.setUp({ x: 0, y: 1, z: 0 }); // Up vector is +Y\r\n    }\r\n\r\n    setupPlayerBody() {\r\n        const pos = this.parent.transform.position;\r\n        let rigidBodyDesc = RAPIER.RigidBodyDesc.kinematicPositionBased().setTranslation(pos.x, pos.y, pos.z);\r\n        this.rigidBody = this.rapierWorld.createRigidBody(rigidBodyDesc);\r\n\r\n        // Create a capsule collider for the player\r\n        let colliderDesc = RAPIER.ColliderDesc.capsule(\r\n            this.characterHeight / 2 - this.characterRadius, // Half-height (excluding caps)\r\n            this.characterRadius\r\n        )\r\n            .setTranslation(0, this.characterHeight / 2, 0) // Center capsule vertically\r\n            .setCollisionGroups(0x0001) // Optional: set collision groups\r\n            .setSolverGroups(0x0001); // Optional: set solver groups\r\n        this.collider = this.rapierWorld.createCollider(colliderDesc, this.rigidBody);\r\n\r\n        // Store collision radius for camera calculations\r\n        this.parent.collisionRadius = this.characterRadius;\r\n    }\r\n\r\n\r\n    onKeyDown(event) {\r\n            if(this.isRemote) {\r\n            return;\r\n        }\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = true;\r\n            if (event.code === 'Space' && !event.repeat && this.isGrounded) {\r\n                this.jumpRequested = true;\r\n                this.parent.getComponent(\"modelRenderer\").jump(500 / this.jumpForce);\r\n            }\r\n        }\r\n        if (event.code === 'KeyV') {\r\n            this.isFirstPerson = !this.isFirstPerson;\r\n            if (!this.isFirstPerson) {\r\n                const offset = new THREE.Vector3(0, this.thirdPersonHeight, this.thirdPersonDistance)\r\n                    .applyQuaternion(this.parent.transform.quaternion);\r\n                this.cameraTargetPosition.copy(this.parent.transform.position).add(offset);\r\n                this.cameraLookAt.copy(this.parent.transform.position);\r\n            }\r\n        }\r\n        if (event.code === 'KeyB') {\r\n            this.debug.showRaycasts = !this.debug.showRaycasts;\r\n            if (!this.debug.showRaycasts) {\r\n                this.debug.raycastHelpers.forEach(helper => {\r\n                    if (helper && this.scene.children.includes(helper)) {\r\n                        this.scene.remove(helper);\r\n                    }\r\n                });\r\n                this.debug.raycastHelpers = [];\r\n            }\r\n        }\r\n    }\r\n\r\n    onKeyUp(event) {\r\n            if(this.isRemote) {\r\n            return;\r\n        }\r\n        if (event.code in this.keys) {\r\n            this.keys[event.code] = false;\r\n        }\r\n    }\r\n\r\n    onMouseMove(event) {\r\n            if(this.isRemote) {\r\n            return;\r\n        }\r\n        if (this.controls.isLocked) {\r\n            this.cameraYaw -= event.movementX * this.mouseSensitivity;\r\n            this.cameraPitch += event.movementY * this.mouseSensitivity;\r\n            this.cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, this.cameraPitch));\r\n            this.parent.transform.quaternion.setFromEuler(new THREE.Euler(0, this.cameraYaw, 0));\r\n        }\r\n    }\r\n\r\n    updateAxes() {\r\n        const rotation = new THREE.Euler(0, this.cameraYaw, 0, 'YXZ');\r\n        const quaternion = new THREE.Quaternion().setFromEuler(rotation);\r\n        this.forward.set(0, 0, 1).applyQuaternion(quaternion).normalize();\r\n        this.forward.y = 0;\r\n        this.forward.normalize();\r\n        this.right.set(-1, 0, 0).applyQuaternion(quaternion).normalize();\r\n        this.right.y = 0;\r\n        this.right.normalize();\r\n        this.up.set(0, 1, 0);\r\n    }\r\n\r\n    updateCameraPosition() {\r\n        if(this.isRemote) {\r\n            return;\r\n        }\r\n        const dt = Math.min(this.game.deltaTime, 0.033);\r\n        const smoothingAlpha = this.cameraSmoothing * dt * 60;\r\n\r\n        const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.cameraPitch);\r\n        const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraYaw);\r\n        const combinedQuat = new THREE.Quaternion().multiplyQuaternions(yawQuat, pitchQuat);\r\n\r\n        if (this.isFirstPerson) {\r\n            const eyePosition = this.parent.transform.position.clone().add(new THREE.Vector3(0, this.cameraHeight + 5, 0));\r\n            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(combinedQuat);\r\n            const forwardOffset = -17; // Small offset to avoid clipping\r\n            eyePosition.add(forwardDir.multiplyScalar(forwardOffset));\r\n            this.camera.position.copy(eyePosition);\r\n            const yawOffsetQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);\r\n            const invertedPitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -this.cameraPitch);\r\n            const finalQuat = new THREE.Quaternion().multiplyQuaternions(yawQuat, yawOffsetQuat).multiply(invertedPitchQuat);\r\n            this.camera.quaternion.copy(finalQuat);\r\n            this.camera.near = 0.01;\r\n        } else {\r\n            const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(combinedQuat);\r\n            const offsetDistance = this.thirdPersonDistance;\r\n            const offsetHeight = this.thirdPersonHeight;\r\n            const targetPosition = this.parent.transform.position.clone()\r\n                .add(new THREE.Vector3(0, offsetHeight, 0))\r\n                .sub(forwardDir.clone().multiplyScalar(offsetDistance));\r\n            this.camera.position.lerp(targetPosition, smoothingAlpha);\r\n            const lookAtPos = this.parent.transform.position.clone().add(new THREE.Vector3(0, this.cameraHeight, 0));\r\n            this.cameraLookAt.lerp(lookAtPos, smoothingAlpha);\r\n            this.camera.lookAt(this.cameraLookAt);\r\n            this.camera.near = 0.01;\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if ((!this.controls.isLocked || this.isRemote) && !this.game.isServer) return;\r\n        const dt = Math.min(this.game.deltaTime, 0.1);\r\n\r\n        if(!this.isRemote){            \r\n            // Update camera\r\n            this.updateCameraPosition();  \r\n            this.updateAxes();     \r\n        }\r\n\r\n        if(this.modelRenderer){\r\n            this.isRunning = this.keys.ShiftLeft;\r\n            let moveForward = 0;\r\n            let moveRight = 0;\r\n            if (this.keys.KeyW) moveForward += 1;\r\n            if (this.keys.KeyS) moveForward -= 1;\r\n            if (this.keys.KeyA) moveRight -= 1;\r\n            if (this.keys.KeyD) moveRight += 1;\r\n\r\n            if(moveForward != 0 || moveRight != 0) {\r\n                if(this.isRunning){\r\n                    this.modelRenderer.setAnimation('run');\r\n                } else {\r\n                    this.modelRenderer.setAnimation('walk');\r\n                }\r\n            } else {\r\n                this.modelRenderer.setAnimation('idle');\r\n            }\r\n        }\r\n\r\n        if(!this.game.isServer && !this.game.isSinglePlayer) return;\r\n        // Check if grounded\r\n\r\n        this.isGrounded = this.characterController.computedGrounded();\r\n        // Process inputs\r\n        if(this.isGrounded){\r\n            // Update local axes\r\n            this.moveForward = 0;\r\n            this.moveRight = 0;\r\n            if (this.keys.KeyW) this.moveForward += 1;\r\n            if (this.keys.KeyS) this.moveForward -= 1;\r\n            if (this.keys.KeyA) this.moveRight -= 1;\r\n            if (this.keys.KeyD) this.moveRight += 1;\r\n\r\n        }\r\n\r\n        // Compute desired movement\r\n        const speed = this.isRunning ? this.runSpeed : this.walkSpeed;\r\n        const moveDir = new THREE.Vector3();\r\n        if (this.moveForward !== 0) moveDir.add(this.forward.clone().multiplyScalar(this.moveForward));\r\n        if (this.moveRight !== 0) moveDir.add(this.right.clone().multiplyScalar(this.moveRight));\r\n        moveDir.normalize();\r\n\r\n        // Apply gravity and jumping\r\n        this.velocity.y -= this.gravity * dt;\r\n        if (this.jumpRequested && this.isGrounded) {\r\n            this.velocity.y = this.jumpForce;\r\n            this.jumpRequested = false;\r\n            this.isGrounded = false;\r\n        }\r\n\r\n        // Compute desired translation\r\n        const desiredTranslation = {\r\n            x: moveDir.x * speed * dt,\r\n            y: this.velocity.y * dt,\r\n            z: moveDir.z * speed * dt\r\n        };\r\n\r\n        // Use Rapier character controller to compute corrected movement\r\n        this.characterController.computeColliderMovement(this.collider, desiredTranslation);\r\n\r\n\r\n        // Apply corrected movement\r\n        const correctedMovement = this.characterController.computedMovement();\r\n        const currentPos = this.rigidBody.translation();\r\n        const newPos = {\r\n            x: currentPos.x + correctedMovement.x,\r\n            y: currentPos.y + correctedMovement.y,\r\n            z: currentPos.z + correctedMovement.z\r\n        };\r\n        this.rigidBody.setNextKinematicTranslation(newPos);\r\n\r\n        const pos = this.rigidBody.translation();\r\n        const smoothingFactor = 0.9;\r\n        this.parent.transform.position.lerp(\r\n            new THREE.Vector3(pos.x, pos.y, pos.z),\r\n            Math.min(1, this.game.deltaTime * 60 * smoothingFactor)\r\n        );\r\n\r\n        // // Handle collision events (e.g., for sound effects or pushing objects)\r\n        // for (let i = 0; i < this.characterController.numComputedCollisions(); i++) {\r\n        //     const collision = this.characterController.computedCollision(i);\r\n        //     // Example: Log collision or trigger effects\r\n        // }\r\n\r\n        // Reset vertical velocity if grounded\r\n        if (this.isGrounded) {\r\n            this.velocity.y = 0;\r\n        }\r\n\r\n        // Clean up debug visuals\r\n        if (this.debug.showRaycasts) {\r\n            this.debug.raycastHelpers.forEach(helper => {\r\n                if (helper && this.scene.children.includes(helper)) {\r\n                    this.scene.remove(helper);\r\n                }\r\n            });\r\n            this.debug.raycastHelpers = [];\r\n        }\r\n    }\r\n\r\n    onDestroy() {\r\n        document.removeEventListener('keydown', this.onKeyDown);\r\n        document.removeEventListener('keyup', this.onKeyUp);\r\n        document.removeEventListener('mousemove', this.onMouseMove);\r\n\r\n        // Clean up Rapier objects\r\n        this.rapierWorld.removeCollider(this.collider);\r\n        this.rapierWorld.removeRigidBody(this.rigidBody);\r\n        this.rapierWorld.removeCharacterController(this.characterController);\r\n\r\n        // Clean up debug helpers\r\n        this.debug.raycastHelpers.forEach(helper => {\r\n            if (helper && this.scene.children.includes(helper)) {\r\n                this.scene.remove(helper);\r\n            }\r\n        });\r\n    }\r\n}",
        "filePath": "/global/components/js/PlayerController.js",
        "fileName": "PlayerController"
      },
      "MultiplayerManager": {
        "fileName": "MultiplayerManager",
        "script": "class MultiplayerManager extends engine.Component {\r\n  init({scene, physics, serverUrl}) {\r\n    this.scene = scene;            // Three.js scene\r\n    this.physics = physics;            // Rapier world\r\n    this.localPlayer = null;       // Local player object\r\n    this.remotePlayers = {};       // Other players\r\n    this.networkObjects = {};      // Networked physics objects\r\n    this.isServer = false;\r\n    // Create network manager\r\n    this.serverUrl = serverUrl;\r\n    // Interpolation settings\r\n    this.interpolationDelay = 100; // ms    \r\n    this.connected = false;\r\n    this.game.multiplayerManager = this;\r\n  }\r\n  \r\n  // Initialize networking\r\n  async initializeMultiplayer() {\r\n    try {\r\n      this.network = new GUTS.NetworkManager(this);\r\n      const networkId = await this.network.connect(this.serverUrl);\r\n      console.log(`Multiplayer initialized with player ID: ${networkId}`);\r\n      this.connected = true;\r\n      return networkId;\r\n    } catch (err) {\r\n      console.error('Failed to initialize multiplayer:', err);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  setHost(isHost){\r\n    this.isServer = isHost;\r\n    this.game.isServer = this.isServer;\r\n  }\r\n  \r\n  // Update called from your game loop\r\n  update() {\r\n    if(!this.connected){\r\n      return;\r\n    }\r\n    // Update local player position on network\r\n    this.updatePlayers();  \r\n    if (!this.game.isServer) {    \r\n      if(this.localPlayer){  \r\n        this.network.sendPlayerInput({ components: this.localPlayer.getNetworkComponentData() });          \r\n      }\r\n      // Interpolate remote players\r\n    } else {\r\n      let data = {\r\n        players: []\r\n      };\r\n      Object.keys(this.remotePlayers).forEach((networkId) => {\r\n        let entity = this.remotePlayers[networkId];\r\n        let componentData = entity.getNetworkComponentData();\r\n        data.players.push({\r\n          networkId: networkId,\r\n          components: {\r\n            ...componentData\r\n          }\r\n        });\r\n      });\r\n      this.network.sendGameState(data);\r\n    }   \r\n  }\r\n    // Update remote player\r\n  updatePlayer(playerData) {\r\n    let player = this.remotePlayers[playerData.networkId];\r\n    let isRemote = true;\r\n    if (!player && this.localPlayer && this.localPlayer.networkId == playerData.networkId) {\r\n      player = this.localPlayer;\r\n      isRemote = false;\r\n    };\r\n\r\n    if(!player) return;\r\n    player.setNetworkComponentData(playerData, isRemote);\r\n  }\r\n  \r\n  // Update remote players with interpolation\r\n  updatePlayers() {\r\n    if(this.localPlayer){\r\n      if (this.localPlayer.transform.networkPosition) {\r\n        // Position interpolation\r\n        this.localPlayer.transform.position.lerp(this.localPlayer.transform.networkPosition, 0.2);\r\n      }\r\n      if(this.localPlayer.transform.networkQuaternion){\r\n        // Rotation interpolation\r\n        this.localPlayer.transform.quaternion.slerp(this.localPlayer.transform.networkQuaternion, 0.2);\r\n      }\r\n    }\r\n    Object.keys(this.remotePlayers).forEach(networkId => {\r\n      const player = this.remotePlayers[networkId];\r\n      \r\n      if (player.transform.networkPosition) {\r\n        // Position interpolation\r\n        player.transform.position.lerp(player.transform.networkPosition, 0.2);\r\n      }\r\n      if(player.transform.networkQuaternion){\r\n        // Rotation interpolation\r\n        player.transform.quaternion.slerp(player.transform.networkQuaternion, 0.2);\r\n      }\r\n    });\r\n  }\r\n  \r\n  // Create local player\r\n  createLocalPlayer(networkId, entity) {\r\n    this.localPlayer = entity;\r\n    this.localPlayer.networkId = networkId;\r\n    entity.transform.networkPosition = entity.transform.position;\r\n    entity.transform.networkQuaternion = entity.transform.quaternion;\r\n    entity.transform.networkVelocity = entity.transform.velocity;\r\n    return this.localPlayer;\r\n  }\r\n  \r\n  // Create remote player representation\r\n  createRemotePlayer(data) {\r\n    let objEntity = this.game.spawn(\"playerAircraft\", { objectType: \"playerPrefabs\", spawnType: \"spaceshipMesh\", networkId: data.networkId, isRemote: true , position:  new THREE.Vector3(data.position)});\r\n    objEntity.networkId = data.networkId;\r\n    this.setNetworkTransform(objEntity);\r\n    this.remotePlayers[data.networkId] = objEntity;\r\n    if(this.game.isServer){            \r\n      objEntity.getComponent(\"AircraftController\").setupPhysics(this.physics.simulation);\r\n    }\r\n    return objEntity;\r\n  }\r\n\r\n  createNetworkObjectEntity(networkId, data) {\r\n    let objEntity = this.game.spawn(data.type, { networkId: networkId , position: data.position});\r\n    objEntity.networkId = this.network;\r\n    this.setNetworkTransform(objEntity);    \r\n    this.networkObjects[networkId] = objEntity;  \r\n    return object;\r\n  }\r\n    \r\n  setNetworkTransform(entity) {\r\n    entity.transform.networkPosition = entity.transform.position.clone();\r\n    entity.transform.networkQuaternion = entity.transform.quaternion.clone();\r\n    entity.transform.networkVelocity = entity.transform.velocity.clone();\r\n    return entity;\r\n  }\r\n\r\n  // Remove remote player\r\n  removeRemotePlayer(playerId) {\r\n    const player = this.remotePlayers[playerId];\r\n    if (!player) return;\r\n    \r\n    player.destroy();\r\n    // Remove from cache\r\n    delete this.remotePlayers[playerId];\r\n  }\r\n  \r\n  requestServerData(params, callback){\r\n    if(this.network){\r\n      console.log('has network');\r\n      this.network.requestServerData(params, callback);\r\n    }\r\n  }\r\n  \r\n  handleServerDataRequest(requestKey, responseObj, params){\r\n    if(params.function == \"getTerrainChunk\"){\r\n      this.getTerrainChunk(requestKey, responseObj, params.params);\r\n    } else {\r\n      this.network.serverDataResponse(responseObj);\r\n    }\r\n  }\r\n\r\n  getTerrainChunk(requestKey, responseObj, params){\r\n    this.game.terrain.requestTerrainChunk(requestKey, params, (chunkData) => {\r\n      responseObj.chunkData = chunkData;\r\n      this.network.serverDataResponse(responseObj);\r\n    });\r\n  }\r\n\r\n  // Update object from server data\r\n  updateObjectFromServer(objectData) {\r\n    const object = this.networkObjects[objectData.id];\r\n    if (!object) return;\r\n    \r\n    // Update mesh and body\r\n    if (objectData.position && object.transform) {\r\n      object.transform.position.set(\r\n        objectData.position.x,\r\n        objectData.position.y,\r\n        objectData.position.z\r\n      );\r\n    }\r\n    \r\n    if (objectData.quaternion && object.mesh) {\r\n      object.transform.quaternion.set(\r\n        objectData.quaternion.x,\r\n        objectData.quaternion.y,\r\n        objectData.quaternion.z,\r\n        objectData.quaternion.w\r\n      );\r\n    }\r\n    \r\n    // Update physics body if needed\r\n    if (object.body && !object.isLocal) {\r\n      if (objectData.position) {\r\n        object.body.setTranslation({\r\n          x: objectData.position.x,\r\n          y: objectData.position.y,\r\n          z: objectData.position.z\r\n        }, true);\r\n      }\r\n      \r\n      if (objectData.quaternion) {\r\n        object.body.setRotation({\r\n          x: objectData.quaternion.x,\r\n          y: objectData.quaternion.y,\r\n          z: objectData.quaternion.z,\r\n          w: objectData.quaternion.w\r\n        }, true);\r\n      }\r\n      \r\n      if (objectData.velocity) {\r\n        object.body.setLinvel({\r\n          x: objectData.velocity.x,\r\n          y: objectData.velocity.y,\r\n          z: objectData.velocity.z\r\n        }, true);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Update object ID (when a temporary client ID is replaced with server ID)\r\n  updateObjectId(oldId, newId) {\r\n    const object = this.networkObjects[oldId];\r\n    if (!object) return;\r\n    \r\n    // Update the ID\r\n    object.id = newId;\r\n    \r\n    // Move to new ID in the cache\r\n    this.networkObjects[newId] = object;\r\n    delete this.networkObjects[oldId];\r\n  }\r\n  \r\n  // Get local player position for reconciliation\r\n  getLocalPlayerPosition() {\r\n    if (!this.localPlayer || !this.localPlayer.transform) {\r\n      return { x: 0, y: 0, z: 0 };\r\n    }\r\n    \r\n    const pos = this.localPlayer.transform.position;\r\n    return { x: pos.x, y: pos.y, z: pos.z };\r\n  }\r\n  \r\n  // Reconcile local player with server position\r\n  reconcileLocalPlayer(position, velocity) {\r\n    if (!this.localPlayer) return;\r\n    \r\n    // Update position\r\n    if (position && this.localPlayer.transform) {\r\n      this.localPlayer.transform.position.set(position.x, position.y, position.z);\r\n    }\r\n    \r\n    // Update velocity\r\n    if (velocity && this.localPlayer.body) {\r\n      this.localPlayer.body.setLinvel({\r\n        x: velocity.x,\r\n        y: velocity.y,\r\n        z: velocity.z\r\n      }, true);\r\n    }\r\n  }\r\n  \r\n  // Apply pending input for reconciliation\r\n  applyInput(input) {\r\n    // Implement based on your input system\r\n    // For example, if input contains movement:\r\n    if (input.movement && this.localPlayer && this.localPlayer.body) {\r\n      const force = new THREE.Vector3(\r\n        input.movement.x,\r\n        input.movement.y,\r\n        input.movement.z\r\n      ).multiplyScalar(input.deltaTime * 1000); // Convert to appropriate force\r\n      \r\n      this.localPlayer.body.applyImpulse(force, true);\r\n    }\r\n  }\r\n  \r\n  // Handle disconnection from server\r\n  handleDisconnect() {\r\n    // Clear remote players\r\n    Object.keys(this.remotePlayers).forEach(playerId => {\r\n      this.removeRemotePlayer(playerId);\r\n    });\r\n    \r\n    // Optionally clear network objects or mark them as non-synced\r\n  }\r\n  \r\n  // Create an object that will be synced on the network\r\n  createNetworkedObject(objectData) {\r\n    // Create local representation\r\n    const object = this.createNetworkObject({\r\n      ...objectData,\r\n      id: `temp_${Date.now()}`\r\n    });\r\n    \r\n    if (!object) return null;\r\n    \r\n    // Send to server\r\n    const networkId = this.network.createObject(objectData);\r\n    \r\n    // Update local ID\r\n    object.id = networkId;\r\n    this.networkObjects[networkId] = object;\r\n    \r\n    return object;\r\n  }\r\n  \r\n  // Cleanup and disconnect\r\n  dispose() {\r\n    // Disconnect from server\r\n    this.network.disconnect();\r\n    \r\n    // Clear remote players\r\n    Object.keys(this.remotePlayers).forEach(playerId => {\r\n      this.removeRemotePlayer(playerId);\r\n    });\r\n    \r\n    // Clear network objects\r\n    Object.keys(this.networkObjects).forEach(objId => {\r\n      const obj = this.networkObjects[objId];\r\n      if (obj.mesh) this.scene.remove(obj.mesh);\r\n      if (obj.mesh.geometry) obj.mesh.geometry.dispose();\r\n      if (obj.mesh.material) {\r\n        if (Array.isArray(obj.mesh.material)) {\r\n          obj.mesh.material.forEach(material => material.dispose());\r\n        } else {\r\n          obj.mesh.material.dispose();\r\n        }\r\n      }\r\n    });\r\n    \r\n    this.networkObjects = {};\r\n  }\r\n}",
        "filePath": "/global/components/js/MultiplayerManager.js"
      },
      "InfiniWorld": {
        "fileName": "InfiniWorld",
        "parameters": "[\"world\", \"palette\"]",
        "updateInEditor": true,
        "script": "class InfiniWorld extends engine.Component {\r\n    init({\r\n      containerSelector = '#gameContainer',\r\n      width = window.innerWidth,\r\n      height = window.innerHeight,\r\n      isEditor,\r\n      world,\r\n      clock = new THREE.Clock()   \r\n    }) {\r\n      this.container = document.querySelector(containerSelector) || document.body;\r\n      this.gameConfig = this.game.getCollections().configs.game;      \r\n      this.world = this.game.getCollections().worlds[world];\r\n      this.rootGroup = new window.THREE.Group(); // Main container for all shapes\r\n      this.rootGroup.name = \"infiniWorldGroup\";      \r\n      this.canvas = this.game.canvas;\r\n      if(!this.canvas) {\r\n        this.canvas = this.container.querySelector(\"canvas\");\r\n      }\r\n      // Initialize core properties\r\n      this.clock = clock;\r\n      this.onWindowResizeHandler = this.onWindowResize.bind(this);\r\n      \r\n      if(!this.game.isServer){\r\n        this.renderer = this.game.renderer || new THREE.WebGLRenderer({ antialias: true, canvas: this.canvas, alpha: true });\r\n        if(!isEditor){\r\n          this.renderer.setSize(width, height);\r\n        }\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n      }\r\n      this.scene = this.game.scene || new window.THREE.Scene();\r\n      this.scene.add(this.rootGroup);\r\n      this.uniforms = new Map();\r\n      this.cameraData = this.game.getCollections().cameras[this.world.camera];  \r\n      // Camera setup\r\n        if(this.cameraData.fov){\r\n            this.camera = new THREE.PerspectiveCamera(\r\n                this.cameraData.fov,\r\n                width / height,\r\n                this.cameraData.near,\r\n                this.cameraData.far\r\n            );\r\n        } else if(this.cameraData.zoom){\r\n            this.camera = new THREE.OrthographicCamera(\r\n                width / - 2, \r\n                width / 2, \r\n                height / 2, \r\n                height / - 2, \r\n                this.cameraData.near,\r\n                this.cameraData.far\r\n            );\r\n            this.camera.zoom = this.cameraData.zoom;\r\n            this.camera.updateProjectionMatrix();\r\n        }\r\n      \r\n      if(!this.game.isServer){\r\n        this.composer = new THREE_.EffectComposer( this.renderer );\r\n        this.pixelSize = this.gameConfig.pixelSize || 1;\r\n        \r\n        this.pixelPass = new THREE_.RenderPixelatedPass( this.pixelSize, this.scene, this.camera );\r\n        if(this.pixelSize == 1) {\r\n          this.pixelPass.enabled = false;\r\n        }\r\n        this.game.postProcessors = {\r\n          pixelPass: this.pixelPass\r\n        };\r\n        this.pixelPass.normalEdgeStrength = 0;\r\n        \r\n        this.composer.addPass( this.pixelPass );\r\n        const outputPass = new THREE_.OutputPass();\r\n        this.composer.addPass( outputPass );\r\n      }\r\n      // Terrain configuration\r\n      this.heightMap = this.game.getCollections().heightMaps[this.world.heightMap];\r\n      this.chunkSize = this.heightMap.chunkSize;\r\n      this.chunkResolution = this.heightMap.chunkResolution;\r\n      this.renderDistance = this.heightMap.renderDistance;\r\n      this.heightScale = this.heightMap.heightScale;\r\n\r\n      // Lighting setup\r\n      this.lighting = this.game.getCollections().lightings[this.world.lighting];  \r\n      this.shadow = this.game.getCollections().shadows[this.world.shadow];  \r\n      this.fogData = this.game.getCollections().fogs[this.world.fog];       \r\n      \r\n      \r\n      const skyColor = parseInt(this.lighting.skyColor.replace('#', ''), 16);\r\n            // Create a large sphere for the sky\r\n      const skyGeometry = new THREE.SphereGeometry(this.cameraData.far * .9, 32, 32); // Large enough to enclose the scene\r\n     \r\n      const skyMaterial = new THREE.MeshBasicMaterial({\r\n        color: skyColor, // Use the same sky color\r\n        side: THREE.BackSide // Render the inside of the sphere\r\n      });\r\n      this.skyDome = new THREE.Mesh(skyGeometry, skyMaterial);\r\n      \r\n      this.rootGroup.add(this.skyDome);\r\n\r\n\r\n      const ambientColor = parseInt(this.lighting.ambientColor.replace('#', ''), 16);\r\n      this.ambientLight = new THREE.AmbientLight(ambientColor, this.lighting.ambientIntensity);\r\n      this.rootGroup.add(this.ambientLight);\r\n    \r\n       \r\n      const directionalColor = parseInt(this.lighting.directionalColor.replace('#', ''), 16);\r\n      this.directionalLight = new THREE.DirectionalLight(directionalColor, this.lighting.directionalIntensity);\r\n      this.directionalLight.castShadow = true;\r\n      this.directionalLight.shadow.mapSize.set(this.shadow.mapSize, this.shadow.mapSize); // Increase resolution for sharper shadows\r\n      this.directionalLight.shadow.camera.near = 0.01; // Closer near plane for precision\r\n      this.directionalLight.shadow.camera.far = this.shadow.mapSize; // Increase far plane to cover tall terrain\r\n      this.directionalLight.shadow.camera.left = -this.shadow.radius; // Expand bounds\r\n      this.directionalLight.shadow.camera.right = this.shadow.radius;\r\n      this.directionalLight.shadow.camera.top = this.shadow.radius;\r\n      this.directionalLight.shadow.camera.bottom = -this.shadow.radius;\r\n      this.directionalLight.shadow.bias = this.shadow.bias; // Add bias to reduce shadow acne\r\n      this.directionalLight.shadow.normalBias = this.shadow.normalBias; // Reduce artifacts on slopes\r\n      this.directionalLight.position.set(this.camera.position.x + this.chunkSize / 2, this.chunkSize / 2, this.camera.position.z + this.chunkSize / 2);\r\n      this.rootGroup.add(this.directionalLight);\r\n    \r\n      // Fog setup\r\n      \r\n      if(this.fogData.enabled){\r\n        const fogColor = parseInt(this.fogData.color.replace('#', ''), 16);\r\n        this.fog = new THREE.Fog(fogColor, 0, (1 - this.fogData.density) * this.renderDistance * this.chunkSize);\r\n        this.scene.fog = this.fog;\r\n      }\r\n  \r\n      this.chunks = new Map();\r\n  \r\n      this.noise = new (this.game.moduleManager.libraryClasses.SimplexNoise)(); // Fixed seed for consistency\r\n      let biomes = {};\r\n      this.world.biomes.forEach((biomeName) => {\r\n          let biomeObjData = this.game.getCollections().biomes[biomeName];\r\n          let elevationNoiseData = this.game.getCollections().noiseSettings[biomeObjData.elevationNoiseSetting];\r\n          let detailNoiseData = this.game.getCollections().noiseSettings[biomeObjData.detailNoiseSetting];\r\n\r\n          let worldObjectSpawns = [];\r\n          biomeObjData.worldObjectSpawns.forEach((worldObjectSpawn) => {\r\n            worldObjectSpawns.push(this.game.getCollections().worldObjectSpawns[worldObjectSpawn]);\r\n          })\r\n          let groundColor = new THREE.Color(biomeObjData.groundColor);\r\n          biomes[biomeName] = {\r\n            groundColor: {\r\n                r: groundColor.r,\r\n                g: groundColor.g,\r\n                b: groundColor.b\r\n            },\r\n            noiseSettings: {\r\n              elevation: elevationNoiseData,\r\n              detail: detailNoiseData\r\n            },\r\n            worldObjects: worldObjectSpawns,\r\n            range: biomeObjData.range,\r\n            groundRestitution: biomeObjData.groundRestitution\r\n          }\r\n\r\n          if(biomeName == \"mountain\"){     \r\n            let ridgeNoiseData = this.game.getCollections().noiseSettings[biomeObjData.ridgeNoiseSetting];\r\n            biomes[biomeName].noiseSettings.ridge = ridgeNoiseData;\r\n          }\r\n      });\r\n      this.biomes = biomes;\r\n      this.terrainGenerator = new (this.game.moduleManager.libraryClasses.TerrainGenerator)(); \r\n      this.terrainGenerator.init(this.biomes, this.chunkSize, this.chunkResolution, this.noise);\r\n  \r\n      this.grassPerChunk = 131072;//2^17;\r\n      // Initialize Web Worker from Blob\r\n      this.grassTasks = [];\r\n      this.grassBatchSize = 10000; // Process 10,000 instances per frame\r\n      this.currentGrassTaskIndex = 0;\r\n      this.chunkRequests = new Map();\r\n      this.pendingChunks = new Map();\r\n      this.chunkGeometry = new Map();\r\n      this.staticAABBsToRemove = [];\r\n      this.grassBladeWidth = 4; // Adjusted for chunk scale\r\n      this.grassBladeHeight = 10;\r\n      this.grassShader = this.game.getCollections().shaders[\"grass\"];\r\n      const workerCode = this.getWorkerCode();\r\n      const blob = new Blob([workerCode], { type: 'application/javascript' });\r\n      this.worker = new Worker(URL.createObjectURL(blob));\r\n      this.worker.onmessage = this.handleWorkerMessage.bind(this);\r\n      // Initialize terrain\r\n      if(!this.game.multiplayerManager){\r\n       // this.setupInitialChunks();\r\n      }\r\n     // window.addEventListener('resize', this.onWindowResizeHandler);\r\n      this.game.scene = this.scene;\r\n      this.game.camera = this.camera;\r\n      this.game.renderer = this.renderer;\r\n      this.game.terrain = this;\r\n      this.timer = 0;\r\n    }\r\n\r\n    async setupInitialChunks() {\r\n      const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n      const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n      const promises = [];\r\n      for (let x = cameraChunkX - this.renderDistance; x <= cameraChunkX + this.renderDistance; x++) {\r\n        for (let z = cameraChunkZ - this.renderDistance; z <= cameraChunkZ + this.renderDistance; z++) {\r\n          \r\n          promises.push(this.generateChunk(x, z));\r\n        }\r\n      }\r\n  \r\n      await Promise.all(promises);\r\n    }\r\n  \r\n    requestTerrainChunk(requestKey, params, callback){\r\n\r\n      if(this.chunkRequests.has(requestKey)) {\r\n        return;\r\n      }\r\n      if(typeof params.cx != \"undefined\" && typeof params.cz != \"undefined\"){\r\n        this.chunkRequests.set(requestKey, callback);\r\n        this.generateChunk(params.cx, params.cz, requestKey);\r\n      }\r\n    \r\n    }\r\n\r\n    async generateChunk(cx, cz, requestKey) {\r\n      const chunkKey = `${cx},${cz}`;\r\n      if (this.chunks.has(chunkKey)){\r\n        if(requestKey){\r\n          let chunkData = this.chunks.get(chunkKey);\r\n          let requestResponse = {\r\n            cx: chunkData.cx,\r\n            cz: chunkData.cz,\r\n            position: chunkData.position,\r\n            geometry: chunkData.geometry,\r\n            restitution: chunkData.restitution,\r\n            friction: chunkData.friction\r\n          };\r\n          this.sendChunkResponse(requestKey, requestResponse);\r\n        }\r\n        return;\r\n      }\r\n      const chunkData = {\r\n        cx: cx, \r\n        cz: cz,\r\n        terrainMesh: null,\r\n        objectMeshes: new Map(),\r\n        isGenerating: true\r\n      };\r\n      this.chunks.set(chunkKey, chunkData);\r\n      this.pendingChunks.set(chunkKey, chunkData);\r\n      // Send message to worker\r\n\r\n      if(!this.game.isServer){\r\n        if(this.game.multiplayerManager){\r\n          console.log('requested');\r\n          this.game.multiplayerManager.requestServerData({\r\n            function: 'getTerrainChunk',\r\n            params: {\r\n              cx, \r\n              cz\r\n            }\r\n          }, (response) => {\r\n            let rx = response.chunkData.cx;\r\n            let rz = response.chunkData.cz;\r\n            let cData = this.chunks.get(`${rx},${rz}`);\r\n            cData.restitution = response.chunkData.restitution;\r\n            cData.friction = response.chunkData.friction;\r\n            console.log('response', cData);\r\n            this.createTerrainMesh(cData, rx, rz, response.chunkData.geometry.positions, response.chunkData.geometry.color, response.chunkData.geometry.normals, response.chunkData.geometry.indices);\r\n          });\r\n        }\r\n      } else {\r\n        this.worker.postMessage({\r\n          cx,\r\n          cz,\r\n          chunkSize: this.chunkSize,\r\n          chunkResolution: this.chunkResolution, \r\n          requestKey\r\n        });\r\n      }\r\n    }\r\n  \r\n  async updateChunks() {\r\n      const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n      const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n      const newChunks = new Set();\r\n      const chunksToGenerate = [];\r\n      const maxChunksPerFrame = 2;\r\n  \r\n      for (let x = cameraChunkX - this.renderDistance; x <= cameraChunkX + this.renderDistance; x++) {\r\n          for (let z = cameraChunkZ - this.renderDistance; z <= cameraChunkZ + this.renderDistance; z++) {\r\n              const chunkKey = `${x},${z}`;\r\n              newChunks.add(chunkKey);\r\n              if (!this.chunks.has(chunkKey) && !this.pendingChunks.has(chunkKey)) {\r\n                  chunksToGenerate.push({ x, z });\r\n              }\r\n          }\r\n      }\r\n  \r\n      chunksToGenerate.sort((a, b) => {\r\n          const distA = Math.hypot(a.x - cameraChunkX, a.z - cameraChunkZ);\r\n          const distB = Math.hypot(b.x - cameraChunkX, b.z - cameraChunkZ);\r\n          return distA - distB;\r\n      });\r\n  \r\n      for (let i = 0; i < Math.min(maxChunksPerFrame, chunksToGenerate.length); i++) {\r\n          const { x, z } = chunksToGenerate[i];\r\n          this.generateChunk(x, z);\r\n      }\r\n      this.staticAABBsToRemove = [];\r\n      const physics = this.game.gameEntity?.getComponent('game').physics;\r\n      // Remove old chunks\r\n      for (const [chunkKey, chunkData] of this.chunks) {\r\n          if (!newChunks.has(chunkKey) && !chunkData.isGenerating) {\r\n              let parts = chunkKey.split(',');\r\n              let cx = parts[0];\r\n              let cz = parts[1];\r\n              this.staticAABBsToRemove = [...this.staticAABBsToRemove, ...this.getStaticAABBsAt(cx, cz)];\r\n              if (chunkData.terrainMesh) {\r\n                  this.rootGroup.remove(chunkData.terrainMesh);\r\n                  chunkData.terrainMesh.geometry.dispose();\r\n                  chunkData.terrainMesh.material.dispose();\r\n              }\r\n              if (chunkData.waterMesh) {\r\n                  this.rootGroup.remove(chunkData.waterMesh);\r\n                  chunkData.waterMesh.geometry.dispose();\r\n                  chunkData.waterMesh.material.dispose();\r\n              }\r\n              if (chunkData.grassMesh) {\r\n                  this.rootGroup.remove(chunkData.grassMesh);\r\n                  chunkData.grassMesh.geometry.dispose();\r\n                  chunkData.grassMesh.material.dispose();\r\n              }\r\n              chunkData.objectMeshes.forEach((groups, type) => {\r\n                  groups.forEach(group => {\r\n                      if (group.mesh) {\r\n                          this.rootGroup.remove(group.mesh);\r\n                          group.mesh.geometry.dispose();\r\n                          if (Array.isArray(group.mesh.material)) {\r\n                              group.mesh.material.forEach(mat => mat.dispose());\r\n                          } else {\r\n                              group.mesh.material.dispose();\r\n                          }\r\n                          group.mesh.dispose();\r\n                      }\r\n                  });\r\n              });\r\n              chunkData.grassData = null;\r\n              physics.removeChunkColliders(cx, cz);\r\n              this.chunks.delete(chunkKey);\r\n              this.uniforms.delete(chunkKey);\r\n          }\r\n      }   \r\n   \r\n  }\r\n\r\n  getStaticAABBsToRemove() {\r\n    return this.staticAABBsToRemove;\r\n  }\r\n\r\n  handleWorkerMessage(e) {      \r\n    const { cx, cz, positions, indices, colors, normals, vegetation, grassData, restitution, friction, requestKey } = e.data;\r\n    const chunkKey = `${cx},${cz}`;\r\n    const chunkData = this.pendingChunks.get(chunkKey);\r\n    if (!chunkData) return;\r\n\r\n    chunkData.restitution = restitution;\r\n    chunkData.friction = friction;\r\n    // Copy positions and normals for manipulation\r\n    const adjustedPositions = positions.slice();\r\n    const adjustedNormals = normals.slice();\r\n    const vertexCountPerRow = this.chunkResolution + 1;\r\n\r\n    chunkData.grassData = grassData;\r\n    chunkData.collisionAABBs = new Map();\r\n    vegetation.forEach(async ({ worldObject, data }) => {\r\n        if (worldObject.endsWith('_collision')) {\r\n            const objectType = worldObject.replace('_collision', '');\r\n            chunkData.collisionAABBs.set(objectType, data);\r\n        } else if(!this.game.isServer){\r\n            const model = await this.game.modelManager.getModel('worldObjectPrefabs', worldObject);\r\n            if (!model) {\r\n                console.warn(`Model not found: ${worldObject}`);\r\n                return;\r\n            }\r\n            this.processModelType(worldObject, model, data, chunkData);\r\n        }\r\n    });\r\n    // IMPROVEMENT: Use integer-based positioning for chunk placement\r\n    // This helps prevent floating point errors from accumulating\r\n    const chunkWorldX = Math.round(cx * this.chunkSize);\r\n    const chunkWorldZ = Math.round(cz * this.chunkSize);\r\n\r\n    // Enhanced shared edge processing \r\n    const processSharedEdge = (thisChunk, neighborChunk, edgeSelector, neighborEdgeSelector) => {\r\n        if (!neighborChunk || !neighborChunk.terrainMesh) return;\r\n        \r\n        const thisGeom = {\r\n            positions: adjustedPositions,\r\n            normals: adjustedNormals\r\n        };\r\n        \r\n        const neighborGeom = {\r\n            positions: neighborChunk.terrainMesh.geometry.attributes.position.array,\r\n            normals: neighborChunk.terrainMesh.geometry.attributes.normal.array\r\n        };\r\n        \r\n        // Get vertices along the shared edge\r\n        const thisIndices = edgeSelector(vertexCountPerRow);\r\n        const neighborIndices = neighborEdgeSelector(vertexCountPerRow);\r\n        \r\n        // For each vertex along the edge\r\n        for (let i = 0; i < thisIndices.length; i++) {\r\n            const thisIdx = thisIndices[i];\r\n            const neighborIdx = neighborIndices[i];\r\n            \r\n            // CRITICAL FIX: Ensure absolute world positions match exactly\r\n            // Calculate world position of the neighbor vertex\r\n            const neighborWorldX = neighborChunk.terrainMesh.position.x + neighborGeom.positions[neighborIdx*3];\r\n            const neighborWorldY = neighborChunk.terrainMesh.position.y + neighborGeom.positions[neighborIdx*3+1];\r\n            const neighborWorldZ = neighborChunk.terrainMesh.position.z + neighborGeom.positions[neighborIdx*3+2];\r\n            \r\n            // Set local position based on exact world position of neighbor\r\n            // This ensures perfect alignment with zero gaps\r\n            const localX = neighborWorldX - chunkWorldX;\r\n            const localY = neighborWorldY; // Y doesn't need offset since chunks are at y=0\r\n            const localZ = neighborWorldZ - chunkWorldZ;\r\n            \r\n            // Apply exact position to eliminate gaps completely\r\n            thisGeom.positions[thisIdx*3] = localX;\r\n            thisGeom.positions[thisIdx*3+1] = localY;\r\n            thisGeom.positions[thisIdx*3+2] = localZ;\r\n            \r\n            // Average the normals for smooth lighting across chunk boundaries\r\n            const n1 = [\r\n                thisGeom.normals[thisIdx*3], \r\n                thisGeom.normals[thisIdx*3+1], \r\n                thisGeom.normals[thisIdx*3+2]\r\n            ];\r\n            const n2 = [\r\n                neighborGeom.normals[neighborIdx*3], \r\n                neighborGeom.normals[neighborIdx*3+1], \r\n                neighborGeom.normals[neighborIdx*3+2]\r\n            ];\r\n            \r\n            // Calculate average normal\r\n            const avgNormal = [\r\n                (n1[0] + n2[0]) / 2,\r\n                (n1[1] + n2[1]) / 2,\r\n                (n1[2] + n2[2]) / 2\r\n            ];\r\n            \r\n            // Normalize the averaged normal\r\n            const mag = Math.sqrt(\r\n                avgNormal[0] * avgNormal[0] + \r\n                avgNormal[1] * avgNormal[1] + \r\n                avgNormal[2] * avgNormal[2]\r\n            );\r\n            \r\n            if (mag > 0.00001) {\r\n                avgNormal[0] /= mag;\r\n                avgNormal[1] /= mag;\r\n                avgNormal[2] /= mag;\r\n                \r\n                // Apply to current chunk\r\n                adjustedNormals[thisIdx*3] = avgNormal[0];\r\n                adjustedNormals[thisIdx*3+1] = avgNormal[1];\r\n                adjustedNormals[thisIdx*3+2] = avgNormal[2];\r\n                \r\n                // Also update the neighbor's normal in memory\r\n                neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3] = avgNormal[0];\r\n                neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3+1] = avgNormal[1];\r\n                neighborChunk.terrainMesh.geometry.attributes.normal.array[neighborIdx*3+2] = avgNormal[2];\r\n            }\r\n        }\r\n        \r\n        // Mark the neighbor's geometry for update\r\n        neighborChunk.terrainMesh.geometry.attributes.normal.needsUpdate = true;\r\n        neighborChunk.terrainMesh.geometry.attributes.position.needsUpdate = true;\r\n    };\r\n    \r\n    // Process each edge with its neighboring chunk\r\n    const neighbors = [\r\n        // [neighborKey, thisEdgeFn, neighborEdgeFn]\r\n        [`${cx - 1},${cz}`, // Left neighbor\r\n            (vpr) => Array.from({length: vpr}, (_, z) => z * vpr), // Left edge \r\n            (vpr) => Array.from({length: vpr}, (_, z) => z * vpr + (vpr - 1)) // Right edge\r\n        ],\r\n        [`${cx + 1},${cz}`, // Right neighbor\r\n            (vpr) => Array.from({length: vpr}, (_, z) => z * vpr + (vpr - 1)), // Right edge\r\n            (vpr) => Array.from({length: vpr}, (_, z) => z * vpr) // Left edge\r\n        ],\r\n        [`${cx},${cz - 1}`, // Bottom neighbor\r\n            (vpr) => Array.from({length: vpr}, (_, x) => x), // Bottom edge\r\n            (vpr) => Array.from({length: vpr}, (_, x) => (vpr - 1) * vpr + x) // Top edge\r\n        ],\r\n        [`${cx},${cz + 1}`, // Top neighbor\r\n            (vpr) => Array.from({length: vpr}, (_, x) => (vpr - 1) * vpr + x), // Top edge\r\n            (vpr) => Array.from({length: vpr}, (_, x) => x) // Bottom edge\r\n        ]\r\n    ];\r\n\r\n    // Process all neighbor edges\r\n    for (const [neighborKey, thisEdgeFn, neighborEdgeFn] of neighbors) {\r\n        processSharedEdge(\r\n            chunkData,\r\n            this.chunks.get(neighborKey),\r\n            thisEdgeFn,\r\n            neighborEdgeFn\r\n        );\r\n    }\r\n\r\n    // Fix corner vertices by finding diagonal neighbors\r\n    const cornerVertices = [\r\n        {pos: 0, // Bottom left\r\n          neighbors: [`${cx-1},${cz}`, `${cx},${cz-1}`, `${cx-1},${cz-1}`]},\r\n        {pos: vertexCountPerRow - 1, // Bottom right\r\n          neighbors: [`${cx+1},${cz}`, `${cx},${cz-1}`, `${cx+1},${cz-1}`]},\r\n        {pos: (vertexCountPerRow - 1) * vertexCountPerRow, // Top left\r\n          neighbors: [`${cx-1},${cz}`, `${cx},${cz+1}`, `${cx-1},${cz+1}`]},\r\n        {pos: vertexCountPerRow * vertexCountPerRow - 1, // Top right\r\n          neighbors: [`${cx+1},${cz}`, `${cx},${cz+1}`, `${cx+1},${cz+1}`]}\r\n    ];\r\n\r\n    // Process each corner to ensure diagonal neighbors connect properly\r\n    for (const corner of cornerVertices) {\r\n        let validNeighbors = [];\r\n        let sumPos = [0, 0, 0];\r\n        let sumNormal = [0, 0, 0];\r\n        let count = 0;\r\n        \r\n        // Add this chunk's corner\r\n        sumPos[0] += adjustedPositions[corner.pos*3];\r\n        sumPos[1] += adjustedPositions[corner.pos*3+1];\r\n        sumPos[2] += adjustedPositions[corner.pos*3+2];\r\n        sumNormal[0] += adjustedNormals[corner.pos*3];\r\n        sumNormal[1] += adjustedNormals[corner.pos*3+1];\r\n        sumNormal[2] += adjustedNormals[corner.pos*3+2];\r\n        count++;\r\n\r\n        // Find corresponding vertices in neighbors\r\n        for (const neighborKey of corner.neighbors) {\r\n            const neighbor = this.chunks.get(neighborKey);\r\n            if (!neighbor || !neighbor.terrainMesh) continue;\r\n            \r\n            // Determine which corner of the neighbor corresponds to our corner\r\n            let neighborCornerPos;\r\n            if (neighborKey === `${cx-1},${cz-1}`) { // Diagonal bottom-left\r\n                neighborCornerPos = vertexCountPerRow * vertexCountPerRow - 1; // Top-right of neighbor\r\n            } else if (neighborKey === `${cx+1},${cz-1}`) { // Diagonal bottom-right\r\n                neighborCornerPos = (vertexCountPerRow - 1) * vertexCountPerRow; // Top-left of neighbor\r\n            } else if (neighborKey === `${cx-1},${cz+1}`) { // Diagonal top-left\r\n                neighborCornerPos = vertexCountPerRow - 1; // Bottom-right of neighbor\r\n            } else if (neighborKey === `${cx+1},${cz+1}`) { // Diagonal top-right\r\n                neighborCornerPos = 0; // Bottom-left of neighbor\r\n            } else if (neighborKey === `${cx-1},${cz}`) { // Left\r\n                neighborCornerPos = corner.pos === 0 ? vertexCountPerRow - 1 : \r\n                                  vertexCountPerRow * vertexCountPerRow - 1;\r\n            } else if (neighborKey === `${cx+1},${cz}`) { // Right\r\n                neighborCornerPos = corner.pos === vertexCountPerRow - 1 ? 0 : \r\n                                  (vertexCountPerRow - 1) * vertexCountPerRow;\r\n            } else if (neighborKey === `${cx},${cz-1}`) { // Bottom\r\n                neighborCornerPos = corner.pos === 0 ? \r\n                                  (vertexCountPerRow - 1) * vertexCountPerRow : \r\n                                  vertexCountPerRow * vertexCountPerRow - 1;\r\n            } else if (neighborKey === `${cx},${cz+1}`) { // Top\r\n                neighborCornerPos = corner.pos === (vertexCountPerRow - 1) * vertexCountPerRow ? \r\n                                  0 : vertexCountPerRow - 1;\r\n            }\r\n\r\n            if (neighborCornerPos !== undefined) {\r\n                const nGeom = neighbor.terrainMesh.geometry;\r\n                const nPos = nGeom.attributes.position.array;\r\n                const nNorm = nGeom.attributes.normal.array;\r\n                \r\n                // Calculate world position of neighbor's vertex\r\n                const worldX = neighbor.terrainMesh.position.x + nPos[neighborCornerPos*3];\r\n                const worldY = neighbor.terrainMesh.position.y + nPos[neighborCornerPos*3+1];\r\n                const worldZ = neighbor.terrainMesh.position.z + nPos[neighborCornerPos*3+2];\r\n                \r\n                // Add to sums\r\n                sumPos[0] += worldX - chunkWorldX; // Convert to local coords\r\n                sumPos[1] += worldY;\r\n                sumPos[2] += worldZ - chunkWorldZ;\r\n                sumNormal[0] += nNorm[neighborCornerPos*3];\r\n                sumNormal[1] += nNorm[neighborCornerPos*3+1];\r\n                sumNormal[2] += nNorm[neighborCornerPos*3+2];\r\n                count++;\r\n                \r\n                validNeighbors.push({\r\n                    chunk: neighbor,\r\n                    pos: neighborCornerPos\r\n                });\r\n            }\r\n        }\r\n        \r\n        if (count > 1) {\r\n            // Average positions and normals\r\n            const avgPos = [sumPos[0]/count, sumPos[1]/count, sumPos[2]/count];\r\n            const avgNorm = [sumNormal[0]/count, sumNormal[1]/count, sumNormal[2]/count];\r\n            \r\n            // Normalize the normal\r\n            const mag = Math.sqrt(avgNorm[0]*avgNorm[0] + avgNorm[1]*avgNorm[1] + avgNorm[2]*avgNorm[2]);\r\n            if (mag > 0.00001) {\r\n                avgNorm[0] /= mag;\r\n                avgNorm[1] /= mag;\r\n                avgNorm[2] /= mag;\r\n            }\r\n            \r\n            // Apply to this chunk\r\n            adjustedPositions[corner.pos*3] = avgPos[0];\r\n            adjustedPositions[corner.pos*3+1] = avgPos[1];\r\n            adjustedPositions[corner.pos*3+2] = avgPos[2];\r\n            adjustedNormals[corner.pos*3] = avgNorm[0];\r\n            adjustedNormals[corner.pos*3+1] = avgNorm[1];\r\n            adjustedNormals[corner.pos*3+2] = avgNorm[2];\r\n            \r\n            // Apply to all valid neighbors too\r\n            for (const n of validNeighbors) {\r\n                const worldX = chunkWorldX + avgPos[0];\r\n                const worldY = avgPos[1]; // Y position is absolute\r\n                const worldZ = chunkWorldZ + avgPos[2];\r\n                \r\n                // Convert world position to neighbor's local space\r\n                const neighborLocalX = worldX - n.chunk.terrainMesh.position.x;\r\n                const neighborLocalY = worldY - n.chunk.terrainMesh.position.y;\r\n                const neighborLocalZ = worldZ - n.chunk.terrainMesh.position.z;\r\n                \r\n                // Apply position and normal\r\n                const nGeom = n.chunk.terrainMesh.geometry;\r\n                nGeom.attributes.position.array[n.pos*3] = neighborLocalX;\r\n                nGeom.attributes.position.array[n.pos*3+1] = neighborLocalY;\r\n                nGeom.attributes.position.array[n.pos*3+2] = neighborLocalZ;\r\n                nGeom.attributes.normal.array[n.pos*3] = avgNorm[0];\r\n                nGeom.attributes.normal.array[n.pos*3+1] = avgNorm[1];\r\n                nGeom.attributes.normal.array[n.pos*3+2] = avgNorm[2];\r\n                \r\n                // Mark for update\r\n                nGeom.attributes.position.needsUpdate = true;\r\n                nGeom.attributes.normal.needsUpdate = true;\r\n            }\r\n        }\r\n    }\r\n    this.createTerrainMesh(chunkData, cx, cz, adjustedPositions, colors, adjustedNormals, indices);\r\n\r\n    \r\n    if(requestKey){\r\n      let requestResponse = {\r\n        cx: cx,\r\n        cz: cz,\r\n        position: chunkData.position,\r\n        geometry: chunkData.geometry,\r\n        restitution: restitution,\r\n        friction: friction\r\n      };\r\n      this.sendChunkResponse(requestKey, requestResponse);\r\n    }\r\n\r\n    this.game.gameEntity?.getComponent('game').physics.addChunkCollider(chunkData);\r\n  }\r\n\r\n  sendChunkResponse(requestKey, chunkData){\r\n      const requestCallback = this.chunkRequests.get(requestKey);\r\n      if(requestCallback){        \r\n        requestCallback(chunkData);\r\n        this.chunkRequests.delete(requestKey);\r\n      }\r\n  }\r\n\r\n  createTerrainMesh(chunkData, cx, cz, adjustedPositions, colors, adjustedNormals, indices){\r\n    const chunkWorldX = Math.round(cx * this.chunkSize);\r\n    const chunkWorldZ = Math.round(cz * this.chunkSize);\r\n    // Create geometry with adjusted positions and normals\r\n    const geometry = new THREE.BufferGeometry();\r\n    geometry.setAttribute('position', new THREE.Float32BufferAttribute(adjustedPositions, 3));\r\n    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\r\n    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(adjustedNormals, 3));\r\n    geometry.setIndex(indices);\r\n\r\n    // Improved material settings for gap-free appearance\r\n    const material = new THREE.MeshStandardMaterial({\r\n        vertexColors: true,\r\n        roughness: 0.9, \r\n        metalness: 0.1,\r\n        side: THREE.FrontSide,\r\n        flatShading: false,\r\n        dithering: true,\r\n        // NEW: Add slight overdraw to help with small gaps\r\n        polygonOffset: true,\r\n        polygonOffsetFactor: -1,  // Slight offset to prevent z-fighting\r\n        polygonOffsetUnits: -1\r\n    });\r\n\r\n    // Create mesh with precise positioning\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    mesh.position.set(chunkWorldX, 0, chunkWorldZ); // Use exact integer positions\r\n    mesh.castShadow = true;\r\n    mesh.receiveShadow = true;\r\n    mesh.material.needsUpdate = true;\r\n    mesh.userData.isTerrain = true;\r\n    mesh.matrixAutoUpdate = false;\r\n    mesh.updateMatrix();\r\n    this.rootGroup.add(mesh);\r\n    chunkData.terrainMesh = mesh;\r\n    chunkData.geometry = {\r\n      positions: [...geometry.attributes.position.array],\r\n      indices: [...geometry.index.array],\r\n      normals: [...geometry.attributes.normal.array],\r\n      color: [...geometry.attributes.color.array]\r\n    };\r\n    chunkData.position = new THREE.Vector3(chunkWorldX, 0, chunkWorldZ);\r\n//    this.chunkGeometry.set(chunkKey, geometry);\r\n    // Generate water mesh\r\n    if(!this.game.isServer){\r\n      const waterMesh = this.generateWaterMesh(cx, cz, adjustedPositions);\r\n      if (waterMesh) {\r\n          // Position water mesh exactly to avoid gaps\r\n          waterMesh.position.set(chunkWorldX, 0, chunkWorldZ);\r\n          this.rootGroup.add(waterMesh);\r\n          chunkData.waterMesh = waterMesh;\r\n      }\r\n      // Add grass to chunk\r\n      const grassMesh = this.addGrassToTerrain(cx, cz, chunkData.grassData);\r\n      if (grassMesh) {\r\n        grassMesh.position.set(chunkWorldX, 0, chunkWorldZ);\r\n        grassMesh.updateMatrix();\r\n        this.rootGroup.add(grassMesh);\r\n        chunkData.grassMesh = grassMesh;\r\n      }\r\n    }\r\n    // Process vegetation data\r\n   \r\n    if(!this.game.isServer){\r\n    // Force shadow map update to avoid shadow artifacts at boundaries\r\n      this.renderer.shadowMap.needsUpdate = true;\r\n    }\r\n    chunkData.isGenerating = false;\r\n\r\n    this.pendingChunks.delete(`${cx},${cz}`);\r\n\r\n  }\r\n\r\n  getStaticAABBs() {\r\n    const cameraChunkX = Math.floor(this.camera.position.x / this.chunkSize);\r\n    const cameraChunkZ = Math.floor(this.camera.position.z / this.chunkSize);\r\n    let staticAABBs = [];\r\n\r\n    // Check nearby chunks\r\n    for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n      for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n        staticAABBs = [...staticAABBs, ...this.getStaticAABBsAt(x, z)];\r\n      }\r\n    }\r\n    return staticAABBs;\r\n  }\r\n\r\n  getStaticAABBsAt(cx, cz) {\r\n      const chunkKey = `${cx},${cz}`;\r\n      const chunkData = this.chunks.get(chunkKey);\r\n      if (!chunkData || !chunkData.collisionAABBs) return [];\r\n\r\n      let rockAndTreeAABBs = [];\r\n      \r\n      // Iterate through all collision types\r\n      for (const [key, aabbs] of chunkData.collisionAABBs) {\r\n          // Check if key ends with 'tree'\r\n          if (key.endsWith('tree') || key.endsWith('rock')) {\r\n              rockAndTreeAABBs = [...rockAndTreeAABBs, ...(aabbs || [])];\r\n          }\r\n      }\r\n      \r\n      return rockAndTreeAABBs;\r\n  }\r\n\r\n  update() {\r\n    if (!this.game.getCollections().configs.game.is3D) return;\r\n    if(this.game.isServer) return;\r\n    this.timer += this.game.deltaTime || 0;\r\n    this.skyDome.position.set(this.camera.position.x, 0, this.camera.position.z); // Center it around the camera\r\n    this.updateChunks();\r\n    const cameraPos = this.camera.position;  \r\n    // Update directional light position smoothly every frame\r\n    this.directionalLight.position.set(cameraPos.x + 500, 500, cameraPos.z + 500);\r\n    this.directionalLight.target.position.set(cameraPos.x, 0, cameraPos.z);\r\n    this.directionalLight.target.updateMatrixWorld();\r\n  \r\n    // Update shadow camera smoothly every frame\r\n    const shadowCamera = this.directionalLight.shadow.camera;\r\n  \r\n    // Center shadow camera on the player's position\r\n    //const terrainHeight = this.getTerrainHeight(cameraPos);\r\n    shadowCamera.position.set(cameraPos.x, 500, cameraPos.z);\r\n    shadowCamera.lookAt(cameraPos.x, 0, cameraPos.z);\r\n    shadowCamera.updateProjectionMatrix();\r\n    shadowCamera.updateMatrixWorld();\r\n  \r\n    // Only force shadow map update when terrain changes (e.g., new chunks)\r\n    // This is already handled in handleWorkerMessage with this.renderer.shadowMap.needsUpdate = true\r\n    \r\n    for (const [key, value] of this.uniforms.entries()) {\r\n        value.time = { value: this.timer };\r\n        value.cameraPosition = { value: { x: this.camera.position.x, y: this.camera.position.y, z: this.camera.position.z } };\r\n    }\r\n    if(!this.game.isServer){\r\n      if(this.pixelPass && this.pixelPass.enabled){\r\n        const rendererSize = this.renderer.getSize( new THREE.Vector2() );\r\n        const aspectRatio = rendererSize.x / rendererSize.y;\r\n        this.pixelAlignFrustum( this.camera, aspectRatio, Math.floor( rendererSize.x / this.pixelSize ),\r\n            Math.floor( rendererSize.y / this.pixelSize ) );\r\n      }\r\n      this.render();\r\n    }\r\n  }\r\n  render() {    \r\n    this.renderer.render(this.scene, this.camera);\r\n    if(this.pixelPass.enabled){\r\n\t\t  this.composer.render();\r\n    }\r\n  }\r\n  pixelAlignFrustum( camera, aspectRatio, pixelsPerScreenWidth, pixelsPerScreenHeight ) {\r\n\r\n\t\t\t// 0. Get Pixel Grid Units\r\n\t\t\tconst worldScreenWidth = ( ( camera.right - camera.left ) / camera.zoom );\r\n\t\t\tconst worldScreenHeight = ( ( camera.top - camera.bottom ) / camera.zoom );\r\n\t\t\tconst pixelWidth = worldScreenWidth / pixelsPerScreenWidth;\r\n\t\t\tconst pixelHeight = worldScreenHeight / pixelsPerScreenHeight;\r\n\r\n\t\t\t// 1. Project the current camera position along its local rotation bases\r\n\t\t\tconst camPos = new THREE.Vector3(); camera.getWorldPosition( camPos );\r\n\t\t\tconst camRot = new THREE.Quaternion(); camera.getWorldQuaternion( camRot );\r\n\t\t\tconst camRight = new THREE.Vector3( 1.0, 0.0, 0.0 ).applyQuaternion( camRot );\r\n\t\t\tconst camUp = new THREE.Vector3( 0.0, 1.0, 0.0 ).applyQuaternion( camRot );\r\n\t\t\tconst camPosRight = camPos.dot( camRight );\r\n\t\t\tconst camPosUp = camPos.dot( camUp );\r\n\r\n\t\t\t// 2. Find how far along its position is along these bases in pixel units\r\n\t\t\tconst camPosRightPx = camPosRight / pixelWidth;\r\n\t\t\tconst camPosUpPx = camPosUp / pixelHeight;\r\n\r\n\t\t\t// 3. Find the fractional pixel units and convert to world units\r\n\t\t\tconst fractX = camPosRightPx - Math.round( camPosRightPx );\r\n\t\t\tconst fractY = camPosUpPx - Math.round( camPosUpPx );\r\n\r\n\t\t\t// 4. Add fractional world units to the left/right top/bottom to align with the pixel grid\r\n\t\t\tcamera.left = - aspectRatio - ( fractX * pixelWidth );\r\n\t\t\tcamera.right = aspectRatio - ( fractX * pixelWidth );\r\n\t\t\tcamera.top = 1.0 - ( fractY * pixelHeight );\r\n\t\t\tcamera.bottom = - 1.0 - ( fractY * pixelHeight );\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t}\r\n\r\n  onWindowResize() {\r\n  \r\n    if(this.canvas && !this.game.isServer){\r\n\r\n      const width = this.container.clientWidth || window.innerWidth;\r\n      const height = this.container.clientHeight || window.innerHeight;\r\n      this.camera.aspect = width / height;\r\n      this.camera.updateProjectionMatrix();\r\n      this.renderer.setSize(width, height);\r\n      this.canvas.style.width = `${width}px`;\r\n      this.canvas.style.height = `${height}px`;\r\n    }\r\n  }\r\n\r\n  processModelType(type, model, instances, chunkData) {\r\n      // Ensure models world matrices are up-to-date\r\n      model.updateMatrixWorld(true);\r\n  \r\n      // Collect mesh data with transformations relative to model root\r\n      const meshData = [];\r\n      model.traverse(node => {\r\n        if (node.isMesh) {\r\n          const parent = node.parent;\r\n          const parentWorldMatrix = parent.matrixWorld.clone();\r\n          const localMatrix = node.matrix.clone();\r\n  \r\n          // Compute transformation relative to model root\r\n          const relativeMatrix = new THREE.Matrix4();\r\n          relativeMatrix.copy(parentWorldMatrix);\r\n          relativeMatrix.multiply(localMatrix);\r\n  \r\n          meshData.push({\r\n            mesh: node,\r\n            relativeMatrix: relativeMatrix\r\n          });\r\n        }\r\n      });\r\n  \r\n      if (meshData.length === 0) {\r\n        console.warn(`No meshes found in model: ${type}`);\r\n        return;\r\n      }\r\n  \r\n      // Create instanced meshes for each mesh in the model\r\n      const instanceGroups = meshData.map(({ mesh, relativeMatrix }) => {\r\n        const instancedMesh = new THREE.InstancedMesh(\r\n          mesh.geometry,\r\n          mesh.material.clone(), // Clone material to avoid shared state\r\n          instances.length\r\n        );\r\n        instancedMesh.matrixAutoUpdate = false;\r\n        instancedMesh.userData.relativeMatrix = relativeMatrix;\r\n        instancedMesh.castShadow = true;\r\n        instancedMesh.receiveShadow = true;\r\n        instancedMesh.material.alphaTest = 0.1;\r\n        instancedMesh.material.transparent = false;\r\n        instancedMesh.material.needsUpdate = true; // Force material update\r\n        instancedMesh.material.side = THREE.DoubleSide; // Set side to double for better visibility\r\n        this.rootGroup.add(instancedMesh);\r\n        return { mesh: instancedMesh, instances: [] };\r\n      });\r\n  \r\n      // Set instance transformations\r\n      const matrix = new THREE.Matrix4();\r\n      const dummy = new THREE.Object3D();\r\n  \r\n      instances.forEach((instance, index) => {\r\n        // Set base transformation from worker data\r\n        dummy.position.set(\r\n          instance.position.x,\r\n          instance.position.y,\r\n          instance.position.z\r\n        );\r\n        dummy.rotation.y = instance.rotation;\r\n        dummy.scale.setScalar(instance.scale);\r\n        dummy.updateMatrix();\r\n        dummy.matrixAutoUpdate = false;\r\n  \r\n        // Apply base transformation combined with each meshs relative matrix\r\n        instanceGroups.forEach((group, meshIndex) => {\r\n          matrix.copy(dummy.matrix);\r\n          matrix.multiply(group.mesh.userData.relativeMatrix);\r\n          group.mesh.setMatrixAt(index, matrix);\r\n          group.mesh.matrixAutoUpdate = false;\r\n          group.instances.push(index);\r\n        });\r\n      });\r\n  \r\n      // Update instance matrices\r\n      instanceGroups.forEach(group => {\r\n        group.mesh.instanceMatrix.needsUpdate = true;\r\n        this.renderer.shadowMap.needsUpdate = true; // Force shadow map update\r\n      });\r\n  \r\n      // Store instance groups in chunk data\r\n      chunkData.objectMeshes.set(type, instanceGroups);\r\n  }\r\n\r\n  getTerrainHeight(position, useRaycast = false) {\r\n    if(!useRaycast){      \r\n      return this.terrainGenerator.getHeight(position);\r\n    }\r\n    // Create a raycaster\r\n    const raycaster = new THREE.Raycaster();\r\n    \r\n    // Set the ray origin high above the position\r\n    const rayOrigin = new THREE.Vector3(position.x, position.y + 10, position.z);\r\n    \r\n    // Set the ray direction downward\r\n    const rayDirection = new THREE.Vector3(0, -1, 0);\r\n    raycaster.set(rayOrigin, rayDirection);\r\n    \r\n    // Collect visible terrain chunks to test against\r\n    const chunks = [];\r\n    const cameraChunkX = Math.floor(position.x / this.chunkSize);\r\n    const cameraChunkZ = Math.floor(position.z / this.chunkSize);\r\n    \r\n    // Check nearby chunks (optimization: only check chunks in a certain radius)\r\n    for (let x = cameraChunkX - 1; x <= cameraChunkX + 1; x++) {\r\n      for (let z = cameraChunkZ - 1; z <= cameraChunkZ + 1; z++) {\r\n        const chunkKey = `${x},${z}`;\r\n        const chunkData = this.chunks.get(chunkKey);\r\n        if (chunkData && chunkData.terrainMesh) {\r\n          chunks.push(chunkData.terrainMesh);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Perform the raycast\r\n    const intersects = raycaster.intersectObjects(chunks, false);\r\n    \r\n    // If there's an intersection, return the y-coordinate\r\n    if (intersects.length > 0) {\r\n      return intersects[0].point.y;\r\n    }\r\n    \r\n    return 0;\r\n  }\r\n\r\n  destroy() {\r\n    // window.removeEventListener('resize', this.onWindowResizeHandler); // Uncomment if needed\r\n\r\n    for (const [, chunkData] of this.chunks) {\r\n      if (chunkData.terrainMesh) {\r\n        this.scene.remove(chunkData.terrainMesh);\r\n        chunkData.terrainMesh.geometry.dispose();\r\n        if (chunkData.terrainMesh.material) {\r\n          if (Array.isArray(chunkData.terrainMesh.material)) {\r\n            chunkData.terrainMesh.material.forEach(mat => mat.dispose());\r\n          } else {\r\n            chunkData.terrainMesh.material.dispose();\r\n          }\r\n        }\r\n      }\r\n      if (chunkData.waterMesh) {\r\n        this.scene.remove(chunkData.waterMesh);\r\n        chunkData.waterMesh.geometry.dispose();\r\n        chunkData.waterMesh.material.dispose();\r\n      }\r\n      if (chunkData.grassMesh) {\r\n        this.scene.remove(chunkData.grassMesh);\r\n        chunkData.grassMesh.geometry.dispose();\r\n        chunkData.grassMesh.material.dispose();\r\n      }\r\n      chunkData.objectMeshes.forEach((groups, type) => {\r\n        groups.forEach(group => {\r\n          if (group.mesh) {\r\n            this.scene.remove(group.mesh);\r\n            group.mesh.geometry.dispose();\r\n            if (group.mesh.material) {\r\n              if (Array.isArray(group.mesh.material)) {\r\n                group.mesh.material.forEach(mat => mat.dispose());\r\n              } else {\r\n                group.mesh.material.dispose();\r\n              }\r\n            }\r\n            group.mesh.dispose();\r\n          }\r\n        });\r\n      });\r\n    }\r\n    if (this.worker) {\r\n      this.worker.terminate();\r\n      this.worker = null;\r\n    }\r\n    this.pendingChunks.clear();\r\n    this.chunks.clear();\r\n    this.uniforms.clear();\r\n    this.scene.remove(this.rootGroup);\r\n  }\r\n\r\n\r\n  generateWaterMesh(cx, cz, terrainPositions) {\r\n    return;\r\n    const chunkKey = `${cx},${cz}`;\r\n\r\n    // Create a plane with higher resolution for visible waves\r\n    const geometry = new THREE.PlaneGeometry(this.chunkSize, this.chunkSize, 64, 64);\r\n    geometry.rotateX(-Math.PI / 2); // Align with terrain\r\n\r\n    // Adjust UVs to be continuous across chunks\r\n    const uvAttribute = geometry.attributes.uv;\r\n    const positionAttribute = geometry.attributes.position;\r\n    for (let i = 0; i < uvAttribute.count; i++) {\r\n        const x = positionAttribute.getX(i) + (cx * this.chunkSize + this.chunkSize / 2);\r\n        const z = positionAttribute.getZ(i) + (cz * this.chunkSize + this.chunkSize / 2);\r\n        // Scale UVs based on world position\r\n        uvAttribute.setXY(i, x / this.chunkSize, z / this.chunkSize);\r\n    }\r\n    uvAttribute.needsUpdate = true;\r\n\r\n    // Parse hex color\r\n    const parseHexColor = (hex) => {\r\n        const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n        const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n        const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n        return { r, g, b };\r\n    };\r\n\r\n    // Get water shader from configuration\r\n    const waterShader = this.game.getCollections().shaders[\"water\"];\r\n    this.uniforms[chunkKey] = JSON.parse(waterShader.uniforms);\r\n\r\n    // Set colors (fix color assignment)\r\n    const liquidColorHex = \"#1E90FF\"; // DodgerBlue for water\r\n    const foamColorHex = \"#FFFFFF\"; // White for foam\r\n    const liquidColor = parseHexColor(liquidColorHex);\r\n    const foamColor = parseHexColor(foamColorHex);\r\n\r\n    // Vectorize properties\r\n    const vectorizeProps = waterShader.vectors;\r\n    vectorizeProps.forEach((prop) => {\r\n        if (this.uniforms[chunkKey][prop]) {\r\n            if (prop.toLowerCase().endsWith(\"color\")) {\r\n                const color = prop.toLowerCase().startsWith(\"foam\") ? foamColor : liquidColor;\r\n                this.uniforms[chunkKey][prop].value = new THREE.Vector3(color.r, color.g, color.b);\r\n            } else {\r\n                let arr = this.uniforms[chunkKey][prop].value;\r\n                this.uniforms[chunkKey][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);\r\n            }\r\n        }\r\n    });\r\n\r\n    // Set additional uniforms\r\n    this.uniforms[chunkKey].fogColor = { value: new THREE.Color(this.fogData.color) };\r\n    this.uniforms[chunkKey].fogDensity = this.fogData.enabled ? { value: this.fogData.density } : { value: 0 };\r\n    const data = new Float32Array(this.chunkResolution * this.chunkResolution);\r\n    for (let z = 0; z < this.chunkResolution; z++) {\r\n      for (let x = 0; x < this.chunkResolution; x++) {\r\n        const index = Math.floor((z * this.chunkResolution + x)*3);\r\n        data[Math.floor(index / 3)] = terrainPositions[index+1];\r\n      }\r\n    }\r\n    const heightmapTexture = new THREE.DataTexture(\r\n      data,\r\n      this.chunkResolution,\r\n      this.chunkResolution,\r\n      THREE.RedFormat,\r\n      THREE.FloatType\r\n    );\r\n    heightmapTexture.needsUpdate = true;\r\n\r\n    this.uniforms[chunkKey].terrainHeightmap = { value: heightmapTexture };\r\n    this.uniforms[chunkKey].terrainSize = { value: new THREE.Vector2(this.chunkResolution, this.chunkResolution) };\r\n    this.uniforms[chunkKey].terrainOffset = { value: new THREE.Vector2(cx, cz) };\r\n    this.uniforms[chunkKey].foamWidth = { value: 0.5 }; // Adjust for wider/narrower foam bands\r\n    this.uniforms[chunkKey].foamColor = { value: new THREE.Vector3(1.0, 1.0, 1.0) }; \r\n    // Create the shader material\r\n    const material = new THREE.ShaderMaterial({\r\n        uniforms: this.uniforms[chunkKey],\r\n        vertexShader: waterShader.vertexScript,\r\n        fragmentShader: waterShader.fragmentScript,\r\n        side: THREE.DoubleSide, // Use DoubleSide to avoid culling issues\r\n        transparent: true\r\n    });\r\n\r\n    // Create water mesh\r\n    const waterMesh = new THREE.Mesh(geometry, material);\r\n    waterMesh.position.set(cx * this.chunkSize + this.chunkSize / 2, 0.1, cz * this.chunkSize + this.chunkSize / 2); // Center in chunk\r\n    waterMesh.name = `water_${chunkKey}`;\r\n    waterMesh.receiveShadow = true;\r\n\r\n    return waterMesh;\r\n  }\r\n  addGrassToTerrain(cx, cz, grassData) {\r\nif(!grassData) return;\r\n    const chunkKey = `${cx},${cz}`;\r\n    const grassGeometry = this.createCurvedBladeGeometry(grassData.bladeWidth, grassData.bladeHeight);\r\n    grassGeometry.translate(0, -grassData.bladeHeight * 0.6, 0);\r\n\r\n    grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(grassData.phases, 1));\r\n\r\n    const grassTexture = this.createGrassTexture(grassData);\r\n    const grassShader = this.grassShader;\r\n    this.uniforms.set(`grass_${chunkKey}`, JSON.parse(grassShader.uniforms));\r\n\r\n    const uniforms = this.uniforms.get(`grass_${chunkKey}`);\r\n    uniforms.windDirection = { value: new THREE.Vector2(uniforms.windDirection.value[0], uniforms.windDirection.value[1]).normalize() };\r\n    uniforms.map = { value: grassTexture };\r\n    uniforms.fogColor = { value: new THREE.Color(this.fogData.color) };\r\n    uniforms.fogDensity = this.fogData.enabled ? { value: this.fogData.density } : { value: 0 };\r\n    const lightDirection = new THREE.Vector3();\r\n    lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);\r\n    lightDirection.normalize();\r\n    if(!this.pixelPass.enabled){\r\n      uniforms.directionalLightColor = { value: new THREE.Color(this.lighting.directionalColor) };\r\n      uniforms.directionalLightIntensity = { value: this.lighting.directionalIntensity };\r\n      uniforms.directionalLightDirection = { value: lightDirection };\r\n      uniforms.ambientLightColor = { value: new THREE.Color(this.lighting.ambientColor) };\r\n      uniforms.ambientLightIntensity = { value: this.lighting.ambientIntensity };\r\n    }\r\n    uniforms.skyColor = { value: new THREE.Color(this.lighting.skyColor) };\r\n    uniforms.groundColor = { value: new THREE.Color(this.lighting.groundColor) };\r\n    uniforms.hemisphereIntensity = { value: this.lighting.hemisphereIntensity };\r\n    uniforms.time = { value: this.timer };\r\n    uniforms.cameraPosition = { value: new THREE.Vector3(0, 0, 0) }; // Updated dynamically\r\n    uniforms.maxDistance = { value: 500.0 };\r\n\r\n    const grassMaterial = new THREE.ShaderMaterial({\r\n      vertexShader: grassShader.vertexScript,\r\n      fragmentShader: grassShader.fragmentScript,\r\n      uniforms: uniforms,\r\n      side: THREE.DoubleSide\r\n    });\r\n\r\n    grassGeometry.computeVertexNormals();\r\n    const grassMesh = new THREE.InstancedMesh(grassGeometry, grassMaterial, grassData.grassPerChunk);\r\n    grassMesh.castShadow = false;\r\n    grassMesh.receiveShadow = false;\r\n    grassMesh.name = `grass_${chunkKey}`;\r\n    const dummy = new THREE.Object3D();    \r\n    // Use pre-computed grass data\r\n    grassData.transforms.forEach((grass, index)=>{\r\n      dummy.position.set(grass.position.x, grass.position.y, grass.position.z);\r\n      dummy.rotation.set(0, grass.rotation, 0);\r\n      dummy.scale.set(grass.scale, grass.scale, grass.scale);\r\n      dummy.updateMatrix();\r\n      grassMesh.setMatrixAt(index, dummy.matrix);      \r\n    });\r\n    grassMesh.needsUpdate = true;\r\n    grassMesh.matrixAutoUpdate = false;\r\n    return grassMesh;\r\n  }\r\n  createCurvedBladeGeometry(width = 0.1, height = 1) {\r\n    const shape = new THREE.Shape();\r\n    shape.moveTo(0, -height, 0);\r\n    shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);\r\n\r\n    const shapeGeom = new THREE.ShapeGeometry(shape, 12);\r\n    const positions = shapeGeom.attributes.position.array;\r\n    const uvs = shapeGeom.attributes.uv.array;\r\n    const vertexCount = positions.length / 3;\r\n\r\n    const newUVs = new Float32Array(uvs.length);\r\n    const newNormals = new Float32Array(positions.length);\r\n\r\n    for (let i = 0; i < vertexCount; i++) {\r\n      const posIndex = i * 3;\r\n      const uvIndex = i * 2;\r\n      const x = positions[posIndex];\r\n      const y = positions[posIndex + 1];\r\n      const normalizedY = y / height;\r\n\r\n      newUVs[uvIndex] = uvs[uvIndex];\r\n      newUVs[uvIndex + 1] = normalizedY;\r\n\r\n      const t = y / height;\r\n      const curveX = width * 0.5 * (1 - t);\r\n      const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();\r\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\r\n      newNormals[posIndex] = normal.x;\r\n      newNormals[posIndex + 1] = 0;\r\n      newNormals[posIndex + 2] = normal.y;\r\n    }\r\n\r\n    shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));\r\n    shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));\r\n    return shapeGeom;\r\n  }\r\n\r\n  createGrassTexture(grassData) {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = 4;\r\n    canvas.height = 32;\r\n    const ctx = canvas.getContext('2d');\r\n    const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\r\n    gradient.addColorStop(0.0, grassData.baseColor);\r\n    gradient.addColorStop(0.8, grassData.baseColor);\r\n    gradient.addColorStop(1.0, grassData.tipColor);\r\n\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    const texture = new THREE.CanvasTexture(canvas);\r\n    texture.wrapS = THREE.RepeatWrapping;\r\n    texture.wrapT = THREE.ClampToEdgeWrapping;\r\n    texture.magFilter = THREE.NearestFilter;\r\n    texture.minFilter = THREE.NearestFilter;\r\n    return texture;\r\n  }\r\n  getWorkerCode() {\r\n    return `\r\n      ${this.game.getCollections().libraries[\"SimplexNoise\"].script}\r\n\r\n      ${this.game.getCollections().libraries[\"TerrainGenerator\"].script}\r\n\r\n      const noise = new SimplexNoise();\r\n      const terrainGenerator = new TerrainGenerator();\r\n      terrainGenerator.init(${JSON.stringify(this.biomes)}, ${this.chunkSize}, ${this.chunkResolution}, noise);\r\n\r\n      self.onmessage = function(e) {\r\n        const { cx, cz, chunkSize, chunkResolution, requestKey } = e.data;\r\n        const result = terrainGenerator.generateChunk(cx, cz, chunkSize, chunkResolution);     \r\n        result.requestKey = requestKey;\r\n        self.postMessage(result);\r\n      };\r\n    `;\r\n  }\r\n}",
        "filePath": "/global/components/js/InfiniWorld.js"
      },
      "Transform": {
        "fileName": "Transform",
        "script": "class Transform extends engine.Component {\n    init({position, scale, rotation}) {\n        let x, y, z = 0;\n        if(position){\n            x = position.x;\n            y = position.y;\n            z = position.z;\n        }   \n        this.position = new THREE.Vector3(x, y, z);\n        this.velocity = new THREE.Vector3();\n        this.physicsVelocity = new THREE.Vector3();\n        this.lastPosition = new THREE.Vector3(x, y, z);\n        this.physicsPosition = new THREE.Vector3(x, y, z);\n        this.gridPosition = new THREE.Vector2(x, y);\n        this.drawPosition = new THREE.Vector2(x, y);\n        this.scale = scale ? new THREE.Vector3(scale.x, scale.y, scale.z) : new THREE.Vector3(1,1,1);\n        this.quaternion = new THREE.Quaternion();  \n        if(rotation){\n            let euler = new THREE.Euler(rotation.x, rotation.y, rotation.z);\n            this.quaternion.setFromEuler(euler);\n        }\n        this.parent.transform = this;      \n        this.networkPosition = this.position.clone();\n        this.networkQuaternion = this.quaternion.clone();   \n        this.networkVelocity = this.velocity.clone();   \n        this.setGridPosition(); \n\n    }\n  \n    getNetworkData(){ \n        return {\n            position: {\n                x: this.position.x || 0, \n                y: this.position.y || 0,\n                z: this.position.z || 0\n            },\n            quaternion: {\n                x:  this.quaternion.x || 0,\n                y:  this.quaternion.y || 0,\n                z:  this.quaternion.z || 0,\n                w:  this.quaternion.w || 0\n            },\n            velocity: {\n                x: this.velocity.x || 0,\n                y: this.velocity.y || 0,\n                z: this.velocity.z || 0\n            }\n        }\n        \n    }\n\n    setNetworkData(data, isRemote){\n        if (data.position) {\n            this.networkPosition.set(\n                data.position.x,\n                data.position.y,\n                data.position.z\n            );\n        }\n        \n        if (data.quaternion) {               \n            this.networkQuaternion.set(\n                data.quaternion.x,\n                data.quaternion.y,\n                data.quaternion.z,\n                data.quaternion.w\n            );            \n        }\n        \n        if (data.velocity) {\n            this.networkVelocity.set(\n                data.velocity.x,\n                data.velocity.y,\n                data.velocity.z\n            );\n        }\n    }\n\n    update() {        \n        this.setGridPosition(); \n    }\n    postUpdate() {\n        \n        // Update grid and draw positions\n        this.lastPosition.x = this.position.x;\n        this.lastPosition.y = this.position.y;\n        this.lastPosition.z = this.position.z;\n\n    }\n    \n    setGridPosition() {\n        if(this.game.translator){\n            let gridPosition = this.game.translator.pixelToGrid( this.position.x, this.position.z ); \n            this.gridPosition = this.game.translator.snapToGrid(gridPosition.x, gridPosition.y);   \n            return;\n        }\n        this.gridPosition = { x: 0, y: 0 };\n    }\n}",
        "filePath": "/global/components/js/Transform.js"
      }
    },
    "editorModules": {
      "audioModule": {
        "title": "Audio Editor",
        "container": "audio-editor-container",
        "propertyName": "audio",
        "interface": "audioEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "editAudio",
        "saveHook": "saveAudio",
        "libraries": [
          "Component",
          "AudioEditor"
        ]
      },
      "exportScriptModule": {
        "title": "Export Scripts Module",
        "library": "ZipExporter"
      },
      "sceneModule": {
        "title": "Scene Editor",
        "container": "scene-editor-container",
        "libraries": [
          "threejs",
          "three_OrbitControls",
          "three_SkeletonUtils",
          "three_EffectComposer",
          "three_OutputPass",
          "three_RenderPixelatedPass",
          "GLTFLoader",
          "ShapeFactory",
          "GameState",
          "TileMap",
          "SimplexNoise",
          "TerrainGenerator",
          "ModelManager",
          "SE_GizmoManager",
          "SceneEditor"
        ],
        "propertyName": "sceneData",
        "interface": "sceneEditor",
        "inputElement": "textarea",
        "inputDataType": "array",
        "loadHook": "renderSceneObject",
        "saveHook": "saveSceneObject"
      },
      "terrainModule": {
        "title": "Terrain Editor",
        "container": "level-editor-container",
        "libraries": [
          "threejs",
          "ShapeFactory",
          "CoordinateTranslator",
          "ImageManager",
          "CanvasUtility",
          "TerrainImageProcessor",
          "TileMap",
          "GE_GroupManager",
          "TerrainMapEditor"
        ],
        "propertyName": "tileMap",
        "interface": "terrainEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "editTileMap",
        "saveHook": "saveTileMap"
      },
      "scriptModule": {
        "title": "Script Editor",
        "container": "script-editor-container",
        "interface": "scriptEditor",
        "inputElement": "textarea",
        "inputDataType": "string",
        "libraries": [
          "ScriptEditor"
        ],
        "propertyNames": "[\"script\", \"html\", \"css\"]",
        "loadHook": "editScript",
        "saveHook": "saveScript"
      },
      "textureEditor": {
        "title": "Texture Editor",
        "container": "texture-editor-container",
        "library": "TextureEditor",
        "propertyName": "image",
        "interface": "TextureEditor",
        "inputElement": "textarea",
        "inputDataType": "string",
        "loadHook": "editTexture",
        "saveHook": "saveTexture"
      },
      "aiPromptModule": {
        "title": "AI Prompt Modal",
        "library": "AIPromptPanel",
        "interface": "aiPromptPanel"
      },
      "compilerModule": {
        "title": "Game Compiler",
        "library": "CompilerModule",
        "propertyName": "compiler",
        "libraries": [
          "jszip.min.js",
          "Compiler",
          "CompilerModule"
        ],
        "interface": "compilerInterface"
      },
      "graphicsModule": {
        "title": "Graphics Editor",
        "container": "graphics-editor-container",
        "libraries": [
          "threejs",
          "three_OrbitControls",
          "GLTFLoader",
          "ShapeFactory",
          "ModelManager",
          "GE_AnimationManager",
          "GE_EventManager",
          "GE_GizmoManager",
          "GE_GroupManager",
          "GE_ShapeManager",
          "GE_RotationUtils",
          "GE_SceneRenderer",
          "GE_UIManager",
          "GE_EquipmentEditor",
          "GraphicsEditor"
        ],
        "propertyName": "render",
        "interface": "graphicsEditor",
        "inputElement": "textarea",
        "inputDataType": "json",
        "loadHook": "renderGraphicsObject",
        "saveHook": "saveGraphicsObject"
      }
    },
    "interfaces": {
      "aiPromptPanel": {
        "title": "AI Prompt Panel",
        "modals": [
          "aiPromptPanel"
        ],
        "fileName": "aiPromptPanel"
      },
      "compilerInterface": {
        "title": "Compiler Interface",
        "fileName": "compilerInterface",
        "filePath": "/global/interfaces/css/compilerInterface.css",
        "modals": [
          "compilerModal"
        ],
        "css": ".compiler-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.7);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 10000;\n}\n\n.compiler-modal .modal-content {\n    background: #2d2d30;\n    border-radius: 8px;\n    width: 600px;\n    max-width: 90%;\n    max-height: 90vh;\n    overflow-y: auto;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n}\n\n.compiler-modal .modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid #3e3e42;\n}\n\n.compiler-modal .modal-header h2 {\n    margin: 0;\n    color: #fff;\n}\n\n.compiler-modal .close-btn {\n    background: none;\n    border: none;\n    color: #999;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 0;\n    width: 30px;\n    height: 30px;\n    line-height: 30px;\n    text-align: center;\n}\n\n.compiler-modal .close-btn:hover {\n    color: #fff;\n}\n\n.compiler-modal .modal-body {\n    padding: 20px;\n}\n\n.compiler-modal .form-group {\n    margin-bottom: 15px;\n}\n\n.compiler-modal .form-group label {\n    display: block;\n    margin-bottom: 5px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"text\"] {\n    width: 100%;\n    padding: 10px;\n    background: #3c3c3c;\n    border: 1px solid #555;\n    border-radius: 4px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"checkbox\"] {\n    margin-right: 8px;\n}\n\n.compiler-modal .compilation-output {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 10px;\n    margin-top: 15px;\n}\n\n.compiler-modal .compilation-output h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .compilation-output pre {\n    margin: 0;\n    color: #d4d4d4;\n    font-family: 'Courier New', monospace;\n    font-size: 12px;\n    white-space: pre-wrap;\n    max-height: 200px;\n    overflow-y: auto;\n}\n\n.compiler-modal .downloads-section {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 15px;\n    margin-bottom: 15px;\n}\n\n.compiler-modal .downloads-section h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link {\n    display: inline-block;\n    padding: 8px 12px;\n    background: #007acc;\n    color: white;\n    text-decoration: none;\n    border-radius: 4px;\n    margin-right: 10px;\n    margin-bottom: 10px;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .modal-footer {\n    padding: 20px;\n    border-top: 1px solid #3e3e42;\n    display: flex;\n    justify-content: flex-end;\n    gap: 10px;\n}\n\n.compiler-modal .btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n.compiler-modal .btn-primary {\n    background: #007acc;\n    color: white;\n}\n\n.compiler-modal .btn-primary:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .btn-secondary {\n    background: #3e3e42;\n    color: #d4d4d4;\n}\n\n.compiler-modal .btn-secondary:hover {\n    background: #505053;\n}\n\n.toolbar-btn {\n    padding: 8px 16px;\n    background: #007acc;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.toolbar-btn:hover {\n    background: #005a9e;\n}\n"
      },
      "graphicsEditor": {
        "title": "Graphics Editor",
        "modals": [
          "rotateShapes",
          "moveAllShapes",
          "generateIsometric"
        ],
        "fileName": "graphicsEditor",
        "css": "/* =============================================================================\r\n   GRAPHICS EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#graphics-editor-canvas {\r\n    cursor: grab;\r\n    outline: none;\r\n}\r\n\r\n#graphics-editor-canvas:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n/* Equipment list specific styles */\r\n.graphics-editor__equipment-list {\r\n    max-height: 200px;\r\n}\r\n\r\n.graphics-editor__no-equipment {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n    font-size: 13px;\r\n}\r\n\r\n/* Equipment item styling */\r\n.graphics-editor__equipment-item {\r\n    padding: var(--editor-spacing-md);\r\n    border-bottom: 1px solid var(--editor-border-color);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n.graphics-editor__equipment-item:hover {\r\n    background-color: var(--editor-primary);\r\n}\r\n\r\n.graphics-editor__equipment-item--selected {\r\n    background-color: var(--editor-primary);\r\n    color: white;\r\n}\r\n\r\n.graphics-editor__equipment-item:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.graphics-editor__equipment-info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex: 1;\r\n}\r\n\r\n.graphics-editor__item-name {\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n}\r\n\r\n.graphics-editor__slot-name {\r\n    color: var(--editor-text-muted);\r\n    font-size: 12px;\r\n}\r\n\r\n.graphics-editor__bone-info {\r\n    font-size: 11px;\r\n    color: var(--editor-text-muted);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n/* Shape list specific styles */\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n    user-select: none;\r\n    cursor: grab;\r\n}\r\n\r\n.graphics-editor__shape-item:active,\r\n.graphics-editor__group-item:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n.graphics-editor__group-item {\r\n    border-left: 4px solid var(--editor-primary);\r\n    font-weight: 500;\r\n}\r\n\r\n.graphics-editor__shape-item {\r\n    border-left: 2px solid var(--editor-bg-lighter);\r\n}\r\n\r\n.graphics-editor__group-shapes {\r\n    margin-left: var(--editor-spacing-lg);\r\n    padding: var(--editor-spacing-sm);\r\n    border-left: 2px dashed var(--editor-border-color);\r\n}\r\n\r\n/* Drag states */\r\n.graphics-editor__shape-item.dragging,\r\n.graphics-editor__group-item.dragging {\r\n    opacity: 0.5;\r\n}\r\n\r\n.graphics-editor__group-item.drag-over {\r\n    border-color: var(--editor-success);\r\n    box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);\r\n}\r\n\r\n/* Mode-specific visibility */\r\n#graphics-editor-container.equipment-mode #graphics-toolbar,\r\n#graphics-editor-container.equipment-mode #graphics-lists,\r\n#graphics-editor-container.equipment-mode #inspector {\r\n    display: none !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #equipment-toolbar,\r\n#graphics-editor-container.equipment-mode #equipment-controls,\r\n#graphics-editor-container.equipment-mode #equipment-inspector,\r\n#graphics-editor-container.equipment-mode #equipment-info,\r\n#graphics-editor-container.equipment-mode #selected-equipment-info {\r\n    display: block !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #shape-count,\r\n#graphics-editor-container.equipment-mode #selected-shape {\r\n    display: none !important;\r\n}\r\n\r\n/* Transform buttons */\r\n.graphics-editor__transform-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.graphics-editor__transform-buttons button {\r\n    flex: 1;\r\n}\r\n",
        "filePath": "/global/interfaces/html/graphicsEditor.html",
        "html": "<div id=\"graphics-editor-container\" class=\"editor-module\">\r\n   <div id=\"graphics-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n\r\n      <!-- Standard Graphics Editor Toolbar -->\r\n      <div id=\"toolbar\" class=\"editor-module__toolbar\">\r\n         <div id=\"graphics-toolbar\" class=\"editor-module__toolbar-group editor-module__flex-col editor-module__gap-sm\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-animation\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Animation\">+A</button>\r\n               <button id=\"delete-animation\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Animation\">-A</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-frame\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Frame\">+F</button>\r\n               <button id=\"delete-frame\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Frame\">-F</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"create-group\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Create Group\">+G</button>\r\n               <button id=\"delete-group\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Group\">-G</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-shape\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Shape\">+S</button>\r\n               <button id=\"delete-shape\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Shape\">-S</button>\r\n            </div>\r\n         </div>\r\n         <div id=\"graphics-toolbar-right\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"preview-animation\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Preview Animation\"></button>\r\n               <button id=\"generate-isometric\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Generate Isometric Sprites\">Iso</button>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Toolbar -->\r\n         <div id=\"equipment-toolbar\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-add-btn\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Equipment\">+E</button>\r\n               <button id=\"equipment-remove-btn\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Remove Equipment\">-E</button>\r\n               <button id=\"equipment-reset-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Reset Position\"></button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-mode-toggle\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Toggle Equipment Mode\"></button>\r\n               <button id=\"equipment-save-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Save Equipment\"></button>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- Standard Graphics Editor Lists -->\r\n      <div id=\"graphics-lists\" class=\"editor-module__scroll-y\">\r\n         <div id=\"frame-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"group-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"shape-list\" class=\"editor-module__list\"></div>\r\n      </div>\r\n\r\n      <!-- Equipment Controls -->\r\n      <div id=\"equipment-controls\">\r\n\r\n         <!-- Add Equipment Section -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Add Equipment</h4>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Item:</label>\r\n               <select id=\"equipment-item-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Item...</option>\r\n               </select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Slot:</label>\r\n               <select id=\"equipment-slot-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Slot...</option>\r\n                  <option value=\"mainHand\">Main Hand</option>\r\n                  <option value=\"offHand\">Off Hand</option>\r\n                  <option value=\"head\">Head</option>\r\n                  <option value=\"chest\">Chest</option>\r\n                  <option value=\"back\">Back</option>\r\n                  <option value=\"legs\">Legs</option>\r\n                  <option value=\"feet\">Feet</option>\r\n               </select>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment List -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment List</h4>\r\n            <div id=\"equipment-list\" class=\"graphics-editor__equipment-list editor-module__scroll-y\">\r\n               <div class=\"graphics-editor__no-equipment\">No equipment loaded</div>\r\n            </div>\r\n         </div>\r\n\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Canvas Container -->\r\n   <div id=\"canvas-container\" class=\"editor-module__canvas-area editor-module__grid-background\">\r\n      <canvas id=\"graphics-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n      <div class=\"editor-module__info\">\r\n         <div>Shapes: <span id=\"shape-count\">0</span></div>\r\n         <div>Selected: <span id=\"selected-shape\">None</span></div>\r\n         <div id=\"equipment-info\">Equipment: <span id=\"equipment-count\">0</span></div>\r\n         <div id=\"selected-equipment-info\">Selected: <span id=\"selected-equipment\">None</span></div>\r\n         <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Right Sidebar -->\r\n   <div id=\"graphics-rightbar\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n\r\n      <!-- Standard Inspector -->\r\n      <div id=\"inspector\" class=\"editor-module__scroll-y\"></div>\r\n\r\n      <!-- Equipment Inspector -->\r\n      <div id=\"equipment-inspector\">\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Attachment</h4>\r\n\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Bone:</label>\r\n               <select id=\"equipment-bone-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Auto-detect</option>\r\n               </select>\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Position Offset</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-offset-x\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-offset-y\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-offset-z\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Rotation (degrees)</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-x\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-y\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-z\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n            </div>\r\n\r\n            <div class=\"editor-module__message editor-module__message--warning\">\r\n               Select equipment to adjust positioning. Changes apply in real-time.\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Properties -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Properties</h4>\r\n            <div id=\"equipment-property-list\">\r\n               <div class=\"graphics-editor__no-equipment\">Select equipment to view properties</div>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- JSON Editor -->\r\n      <div id=\"json-editor\" style=\"display: none;\">\r\n        <textarea id=\"json-content\" class=\"editor-module__textarea editor-module__input\" placeholder=\"Edit JSON here...\"></textarea>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
      },
      "TextureEditor": {
        "title": "Texture Editor",
        "fileName": "TextureEditor",
        "css": "/* =============================================================================\r\n   TEXTURE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#texture-canvas {\r\n    background-color: transparent;\r\n    image-rendering: pixelated;\r\n    border: 1px solid var(--editor-border-color);\r\n    box-shadow: var(--editor-shadow-md);\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n}\r\n\r\n/* No texture message */\r\n.texture-editor__no-texture-message {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n    color: var(--editor-text-muted);\r\n    font-size: 14px;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Color palette grid */\r\n.texture-editor__color-palette {\r\n    display: grid;\r\n    grid-template-columns: repeat(4, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.texture-editor__color-btn {\r\n    width: 100%;\r\n    aspect-ratio: 1;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.texture-editor__color-btn:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.texture-editor__color-btn--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}",
        "filePath": "/global/interfaces/html/TextureEditor.html",
        "html": "<div id=\"texture-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Tools</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"brush-tool\" class=\"editor-module__btn editor-module__btn--active\">Brush</button>\r\n                <button id=\"eraser-tool\" class=\"editor-module__btn\">Eraser</button>\r\n                <button id=\"fill-tool\" class=\"editor-module__btn\">Fill</button>\r\n                <button id=\"eyedropper-tool\" class=\"editor-module__btn\">Eyedropper</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Brush Size</h3>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"range\" id=\"brush-size\" class=\"editor-module__range\" min=\"1\" max=\"10\" value=\"1\">\r\n                <span id=\"brush-size-display\">1px</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Colors</h3>\r\n            <div id=\"color-palette\" class=\"texture-editor__color-palette\"></div>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"color\" id=\"custom-color-picker\" class=\"editor-module__color-picker\" value=\"#000000\">\r\n                <label for=\"custom-color-picker\" class=\"editor-module__label\">Custom Color</label>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n                <label for=\"transparency-slider\" class=\"editor-module__label\">Opacity:</label>\r\n                <input type=\"range\" id=\"transparency-slider\" class=\"editor-module__range\" min=\"0\" max=\"255\">\r\n                <span id=\"transparency-display\">100%</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Actions</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"new-btn\" class=\"editor-module__btn\">New</button>\r\n                <button id=\"undo-btn\" class=\"editor-module__btn\" disabled>Undo</button>\r\n                <button id=\"redo-btn\" class=\"editor-module__btn\" disabled>Redo</button>\r\n                <button id=\"clear-btn\" class=\"editor-module__btn editor-module__btn--danger\">Clear</button>\r\n                <button class=\"export-btn editor-module__btn editor-module__btn--primary\">Save</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Import</h3>\r\n            <input type=\"file\" class=\"editor-module__input\" accept=\"image/*\">\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <canvas id=\"texture-canvas\" class=\"editor-module__canvas\"></canvas>\r\n        <div id=\"noTextureMessage\" class=\"texture-editor__no-texture-message\">No texture loaded</div>\r\n    </div>\r\n</div>\r\n"
      },
      "terrainEditor": {
        "title": "Terrain Editor",
        "modals": [
          "addTerrainType",
          "generateIsoSprites"
        ],
        "fileName": "terrainEditor",
        "css": "/* =============================================================================\r\n   TERRAIN EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#grid {\r\n    display: block;\r\n    image-rendering: pixelated;\r\n}\r\n\r\n/* Save button styling */\r\n.terrain-editor__save-btn {\r\n    width: 100%;\r\n    font-weight: 600;\r\n}\r\n\r\n/* Terrain list */\r\n.terrain-editor__terrain-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__terrain-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    background-color: rgba(255, 255, 255, 0.03);\r\n    border: 1px solid var(--editor-border-color);\r\n    cursor: move;\r\n    user-select: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__terrain-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__color-option {\r\n    width: 36px;\r\n    height: 36px;\r\n    min-width: 36px;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    border: 2px solid transparent;\r\n    flex-shrink: 0;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__color-option--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__terrain-label {\r\n    flex-grow: 1;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__terrain-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n}\r\n\r\n/* Object controls */\r\n.terrain-editor__object-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__object-controls button {\r\n    flex: 1;\r\n}\r\n\r\n/* Environment objects container */\r\n.terrain-editor__environment-objects {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__environment-type {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    overflow: hidden;\r\n    box-shadow: var(--editor-shadow-sm);\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__environment-type:hover {\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-type-header {\r\n    padding: var(--editor-spacing-md);\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background-color: var(--editor-bg-medium);\r\n    color: var(--editor-text-secondary);\r\n    text-transform: capitalize;\r\n}\r\n\r\n.terrain-editor__environment-type-header::after {\r\n    content: '';\r\n    font-size: 10px;\r\n    transition: transform 0.2s ease;\r\n}\r\n\r\n.terrain-editor__environment-type-header.open::after {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n.terrain-editor__environment-items {\r\n    padding: var(--editor-spacing-md);\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__environment-item {\r\n    width: 128px;\r\n    height: 128px;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    padding: 2px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-light);\r\n    transition: var(--editor-transition);\r\n    position: relative;\r\n}\r\n\r\n.terrain-editor__environment-item:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__environment-item--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__environment-item canvas {\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n    object-fit: contain;\r\n}\r\n\r\n/* Tooltip for environment items */\r\n.terrain-editor__environment-item::before {\r\n    content: attr(data-name);\r\n    position: absolute;\r\n    bottom: calc(100% + 5px);\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background-color: var(--editor-bg-dark);\r\n    color: var(--editor-text-primary);\r\n    text-align: center;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    padding: var(--editor-spacing-xs) var(--editor-spacing-sm);\r\n    font-size: 12px;\r\n    white-space: nowrap;\r\n    visibility: hidden;\r\n    opacity: 0;\r\n    transition: var(--editor-transition);\r\n    z-index: 10;\r\n    pointer-events: none;\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-item:hover::before {\r\n    visibility: visible;\r\n    opacity: 1;\r\n}\r\n\r\n/* Object preview canvas (dragging) */\r\n#object-preview-canvas {\r\n    transition: transform 0.05s ease-out;\r\n    will-change: transform;\r\n    image-rendering: pixelated;\r\n    position: absolute;\r\n    pointer-events: none;\r\n    z-index: 9999;\r\n    opacity: 0.7;\r\n}\r\n\r\n/* Delete mode indicator */\r\n.terrain-editor--delete-mode .editor-module__canvas-area {\r\n    cursor: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"red\" stroke-width=\"2\"><path d=\"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2\"/><path d=\"M10 11v6M14 11v6\"/></svg>'), auto;\r\n}\r\n\r\n/* Height level selector */\r\n.terrain-editor__height-levels {\r\n    display: grid;\r\n    grid-template-columns: repeat(3, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__height-btn {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    background-color: var(--editor-bg-medium);\r\n    border: 1px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    color: var(--editor-text-secondary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    font-size: 12px;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__height-btn:hover {\r\n    background-color: var(--editor-bg-light);\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.terrain-editor__height-btn.active {\r\n    background-color: var(--editor-primary);\r\n    border-color: var(--editor-primary);\r\n    color: white;\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n/* Tool buttons */\r\n.terrain-editor__tool-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__tool-buttons button {\r\n    flex: 1;\r\n}\r\n\r\n/* Slider styling */\r\n.editor-module__slider {\r\n    flex: 1;\r\n    height: 4px;\r\n    border-radius: 2px;\r\n    background: var(--editor-bg-medium);\r\n    outline: none;\r\n    -webkit-appearance: none;\r\n    margin: 0 var(--editor-spacing-sm);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb {\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb {\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    border: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__value-display {\r\n    min-width: 20px;\r\n    text-align: center;\r\n    font-weight: 500;\r\n    color: var(--editor-text-primary);\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .terrain-editor__environment-items {\r\n        justify-content: center;\r\n    }\r\n\r\n    .terrain-editor__environment-item {\r\n        width: 80px;\r\n        height: 80px;\r\n    }\r\n\r\n    .terrain-editor__height-levels {\r\n        grid-template-columns: repeat(2, 1fr);\r\n    }\r\n}\r\n",
        "filePath": "/global/interfaces/html/terrainEditor.html",
        "html": "<div id=\"level-editor-container\" class=\"editor-module\">\r\n   <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n     <div class=\"editor-module__toolbar\">\r\n       <button id=\"terrainsBtn\" class=\"editor-module__btn editor-module__btn--active\">Tiles</button>\r\n       <button id=\"heightsBtn\" class=\"editor-module__btn\">Heights</button>\r\n       <button id=\"environmentBtn\" class=\"editor-module__btn\">Env</button>\r\n       <button id=\"rampsBtn\" class=\"editor-module__btn\">Ramps</button>\r\n     </div>\r\n\r\n     <div class=\"editor-module__scroll-y\">\r\n       <div id=\"terrainsPanel\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Map Settings</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"terrainMapSize\" class=\"editor-module__label\">Map Size:</label>\r\n             <input type=\"number\" id=\"terrainMapSize\" class=\"editor-module__input\" value=\"48\" step=\"1\" min=\"1\">\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n              <label for=\"extensionTerrainType\" class=\"editor-module__label\">Surrounding Type:</label>\r\n              <select id=\"extensionTerrainType\" class=\"editor-module__select extensionTerrainType\"></select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n              <button id=\"saveMapBtn\" class=\"editor-module__btn editor-module__btn--success terrain-editor__save-btn\"> Save Map</button>\r\n            </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"terrainBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"terrainFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"terrainBrushSizeRow\">\r\n             <label for=\"terrainBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"terrainBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"terrainBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Terrain Types</h3>\r\n           <div class=\"terrain-editor__terrain-list\">\r\n             <!-- Terrain items will be dynamically populated here -->\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"environmentPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Environment Objects</h3>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small\" id=\"clear-selection-btn\">Clear Selection</button>\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"delete-mode-btn\">Delete Mode</button>\r\n           </div>\r\n           <div class=\"terrain-editor__environment-objects\"></div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"rampsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Ramp Placement</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Click on tiles to place/remove ramps. Ramps allow units to walk between different terrain heights.</p>\r\n             <p><strong>Current ramps:</strong> <span id=\"rampCount\">0</span></p>\r\n           </div>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"clear-all-ramps-btn\">Clear All Ramps</button>\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"heightsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Height Map Editor</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Paint height levels on the map. Heights are independent of terrain types.</p>\r\n             <p>Click on tiles to paint the selected height level.</p>\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"heightLevel\" class=\"editor-module__label\">Height Level:</label>\r\n             <input type=\"number\" id=\"heightLevel\" class=\"editor-module__input\" value=\"0\" step=\"1\" min=\"0\" max=\"10\">\r\n           </div>\r\n           <div class=\"editor-module__section\">\r\n             <h4 class=\"editor-module__section-title\">Quick Select</h4>\r\n             <div class=\"terrain-editor__height-levels\" id=\"heightLevelButtons\">\r\n               <!-- Height level buttons will be dynamically populated here -->\r\n             </div>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"heightBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"heightFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"heightBrushSizeRow\">\r\n             <label for=\"heightBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"heightBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"heightBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n       </div>\r\n     </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n     <canvas id=\"grid\" class=\"editor-module__canvas\"></canvas>\r\n\r\n     <div class=\"editor-module__status-bar\">\r\n       Cursor: x: 0, y: 0 | Zoom: 100% | Selected: Grass\r\n     </div>\r\n   </div>\r\n </div>\r\n"
      },
      "sceneEditor": {
        "title": "Scene Editor",
        "modals": [],
        "fileName": "sceneEditor",
        "css": "/* =============================================================================\r\n   SCENE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Scene view */\r\n.scene-editor__scene-view {\r\n    flex: 1;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n#scene-canvas-container {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#scene-editor-canvas {\r\n    cursor: crosshair;\r\n    outline: none;\r\n}\r\n\r\n/* No selection message */\r\n.scene-editor__no-selection {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n}\r\n\r\n/* Hierarchy item */\r\n.scene-editor__hierarchy-item {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    cursor: pointer;\r\n    border-left: 2px solid transparent;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.scene-editor__hierarchy-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.scene-editor__hierarchy-item--selected {\r\n    background-color: var(--editor-primary);\r\n    border-left-color: var(--editor-primary-hover);\r\n    color: white;\r\n}\r\n\r\n/* Component styling */\r\n.scene-editor__component {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n}\r\n\r\n.scene-editor__component-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: var(--editor-spacing-sm);\r\n    font-weight: 600;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
        "filePath": "/global/interfaces/html/sceneEditor.html",
        "html": "<div id=\"scene-editor-container\" class=\"editor-module\">\r\n   <div id=\"scene-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n      <h2 class=\"editor-module__panel-title\">Hierarchy</h2>\r\n      <div id=\"scene-hierarchy\" class=\"editor-module__list editor-module__scroll-y\">\r\n        <!-- Entities will be populated here -->\r\n      </div>\r\n      <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n        <select id=\"scene-addPrefabSelect\" class=\"editor-module__select\"></select>\r\n        <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"scene-addPrefabBtn\">+ Add Prefab</button>\r\n        <button class=\"editor-module__btn editor-module__btn--danger\" id=\"scene-removePrefabBtn\">Remove Selected Prefab</button>\r\n      </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area\">\r\n      <div class=\"editor-module__toolbar\">\r\n        <button id=\"scene-translate-tool\" class=\"editor-module__btn editor-module__btn--active\" title=\"Translate (G)\">\r\n            <span>Move</span>\r\n        </button>\r\n        <button id=\"scene-rotate-tool\" class=\"editor-module__btn\" title=\"Rotate (R)\">\r\n            <span>Rotate</span>\r\n        </button>\r\n        <button id=\"scene-scale-tool\" class=\"editor-module__btn\" title=\"Scale (S)\">\r\n            <span>Scale</span>\r\n        </button>\r\n      </div>\r\n      <div id=\"scene-view\" class=\"scene-editor__scene-view\">\r\n         <div id=\"scene-canvas-container\" class=\"editor-module__grid-background\">\r\n            <canvas id=\"scene-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n         </div>\r\n      </div>\r\n   </div>\r\n\r\n   <div id=\"scene-inspector\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n      <h2 class=\"editor-module__panel-title\">Inspector</h2>\r\n      <div class=\"editor-module__scroll-y\">\r\n        <div class=\"scene-editor__no-selection\" id=\"scene-noSelection\">\r\n          No entity selected\r\n        </div>\r\n        <div id=\"scene-entityInspector\" style=\"display: none;\">\r\n          <div id=\"scene-components\">\r\n            <!-- Components will be added here dynamically -->\r\n          </div>\r\n          <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"addComponentBtn\">+ Add Component</button>\r\n        </div>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
      },
      "scriptEditor": {
        "title": "Script Editor",
        "fileName": "scriptEditor",
        "css": "/* =============================================================================\r\n   SCRIPT EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Code container */\r\n.script-editor__code-container {\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.script-editor__code {\r\n    flex: 1;\r\n    height: 100%;\r\n    font-family: 'Courier New', 'Monaco', 'Menlo', monospace;\r\n    font-size: 14px;\r\n    line-height: 1.5;\r\n}\r\n\r\n/* Override global scrollbar suppression for CodeMirror */\r\n#script-editor-container .CodeMirror {\r\n    overflow-y: auto !important;\r\n    -ms-overflow-style: auto !important;\r\n    scrollbar-width: auto !important;\r\n    height: 100%;\r\n    font-size: 14px;\r\n}",
        "filePath": "/global/interfaces/html/scriptEditor.html",
        "html": "<div id=\"script-editor-container\" class=\"editor-module\">\r\n    <div id=\"script-editor-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Script Editor</h3>\r\n            <button id=\"save-script-btn\" class=\"editor-module__btn editor-module__btn--primary\">Save Script</button>\r\n        </div>\r\n    </div>\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <div class=\"script-editor__code-container\">\r\n            <textarea id=\"script-editor\" class=\"editor-module__textarea editor-module__input script-editor__code\" placeholder=\"Enter your script here...\"></textarea>\r\n            <div class=\"handle\"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n"
      },
      "audioEditor": {
        "title": "Audio Editor",
        "fileName": "audioEditor",
        "css": "/* =============================================================================\r\n   AUDIO EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Value display for sliders */\r\n.audio-editor__value-display {\r\n    float: right;\r\n    font-weight: 600;\r\n    color: var(--editor-primary);\r\n    font-size: 12px;\r\n}\r\n\r\n/* Waveform display area */\r\n.audio-editor__waveform-display {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-dark);\r\n    position: relative;\r\n}\r\n\r\n.audio-editor__waveform-display::before {\r\n    content: ' Waveform Visualization';\r\n    color: var(--editor-text-muted);\r\n    font-size: 24px;\r\n}\r\n\r\n/* Status container */\r\n#status-container {\r\n    background-color: var(--editor-bg-light);\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    text-align: center;\r\n    font-size: 12px;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
        "filePath": "/global/interfaces/html/audioEditor.html",
        "html": "<div id=\"audio-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left editor-module__scroll-y\">\r\n        <div id=\"status-container\" class=\"editor-module__status-bar\">\r\n            <span id=\"status-message\">Ready</span>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"playBtn\" class=\"editor-module__btn editor-module__btn--primary\">Play</button>\r\n                <button id=\"exportBtn\" class=\"editor-module__btn editor-module__btn--success\">Save</button>\r\n                <button id=\"randomSoundBtn\" class=\"editor-module__btn editor-module__btn--secondary\"> Randomize Sound</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Basic Parameters</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Waveform:</label>\r\n                <select id=\"waveform\" class=\"editor-module__select\">\r\n                    <option value=\"sine\">Sine</option>\r\n                    <option value=\"square\">Square</option>\r\n                    <option value=\"sawtooth\">Sawtooth</option>\r\n                    <option value=\"triangle\">Triangle</option>\r\n                    <option value=\"noise\">Noise</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Frequency: <span class=\"audio-editor__value-display\">440 Hz</span></label>\r\n                <input type=\"range\" id=\"frequency\" class=\"editor-module__range\" min=\"20\" max=\"2000\" value=\"440\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Duration: <span class=\"audio-editor__value-display\">1.00 s</span></label>\r\n                <input type=\"range\" id=\"duration\" class=\"editor-module__range\" min=\"0.1\" max=\"5\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Volume: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"volume\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Noise Generator</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Type:</label>\r\n                <select id=\"noiseType\" class=\"editor-module__select\">\r\n                    <option value=\"white\">White</option>\r\n                    <option value=\"pink\">Pink</option>\r\n                    <option value=\"brown\">Brown</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Amount: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"noiseAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter:</label>\r\n                <select id=\"noiseFilterType\" class=\"editor-module__select\">\r\n                    <option value=\"none\">None</option>\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter Freq: <span class=\"audio-editor__value-display\">2000 Hz</span></label>\r\n                <input type=\"range\" id=\"noiseFilterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"2000\" step=\"1\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Envelope (ADSR)</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Attack: <span class=\"audio-editor__value-display\">0.010 s</span></label>\r\n                <input type=\"range\" id=\"attack\" class=\"editor-module__range\" min=\"0.001\" max=\"2\" value=\"0.01\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Decay: <span class=\"audio-editor__value-display\">0.10 s</span></label>\r\n                <input type=\"range\" id=\"decay\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.1\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Sustain: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"sustain\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Release: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"release\" class=\"editor-module__range\" min=\"0.001\" max=\"5\" value=\"0.3\" step=\"0.001\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Pitch Envelope</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Start: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvStart\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">End: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvEnd\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Effects</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Type:</label>\r\n                <select id=\"filterType\" class=\"editor-module__select\">\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                    <option value=\"notch\">Notch</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Frequency: <span class=\"audio-editor__value-display\">1000 Hz</span></label>\r\n                <input type=\"range\" id=\"filterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"1000\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Q: <span class=\"audio-editor__value-display\">Q: 1.0</span></label>\r\n                <input type=\"range\" id=\"filterQ\" class=\"editor-module__range\" min=\"0.1\" max=\"20\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Distortion: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"distortion\" class=\"editor-module__range\" min=\"0\" max=\"100\" value=\"0\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Time: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"delayTime\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.3\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Feedback: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"delayFeedback\" class=\"editor-module__range\" min=\"0\" max=\"0.9\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Reverb: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"reverbAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Bitcrusher: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"bitcrusher\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Panning: <span class=\"audio-editor__value-display\">Center</span></label>\r\n                <input type=\"range\" id=\"panning\" class=\"editor-module__range\" min=\"-1\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area audio-editor__waveform-display\">\r\n        <!-- Waveform visualization will go here -->\r\n    </div>\r\n</div>\r\n"
      },
      "createOrJoinRoom": {
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/createOrJoinRoom.html",
        "fileName": "createOrJoinRoom",
        "html": "<div class=\"setup-content\" style=\"background: #1a1a1a; padding: 2rem; border: 2px solid #444; border-radius: 10px; text-align: center; color: white;\">\r\n    <h2> Arena </h2>\r\n    <p>Battle against another player in real-time strategic combat.</p>\r\n    \r\n    <div class=\"player-name-input\" style=\"margin: 1rem 0;\">\r\n        <label for=\"playerName\">Your Name:</label><br>\r\n        <input type=\"text\" id=\"playerName\" placeholder=\"Enter your name\" maxlength=\"20\" value=\"Player\" \r\n                style=\"padding: 0.5rem; margin: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n    </div>\r\n    \r\n    <div class=\"multiplayer-options\" style=\"margin: 1.5rem 0;\">\r\n            <button id=\"createRoomBtn\" class=\"btn btn-primary\" style=\"padding: 0.75rem 1.5rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px;\">Create Room</button><br>\r\n            <div class=\"room-join-section\" style=\"margin-top: 1rem;\">\r\n                <input type=\"text\" id=\"roomIdInput\" value=\"1000\" placeholder=\"Enter Room ID\" maxlength=\"6\" \r\n                        style=\"padding: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n                <button id=\"joinRoomBtn\" class=\"btn btn-secondary\" \r\n                        style=\"padding: 0.5rem 1rem; margin-left: 0.5rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Join Room</button>\r\n            </div>\r\n                    <button id=\"quickMatchBtn\" class=\"btn btn-primary\" \r\n                style=\"padding: 1rem 2rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px; font-size: 1.2rem;\">\r\n             Find Game\r\n        </button>\r\n        <p style=\"color: #999; font-size: 0.9rem; margin-top: 1rem;\">\r\n            You'll be matched with an available opponent or<br>\r\n            wait for another player to join your game.\r\n        </p>\r\n    </div>\r\n    \r\n    <button id=\"cancelMultiplayerBtn\" class=\"btn btn-secondary\" \r\n            style=\"padding: 0.5rem 1rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Cancel</button>\r\n</div>"
      },
      "main": {
        "title": "Main Interface",
        "modals": [],
        "fileName": "main",
        "css": "/* Import fantasy fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap');\r\n\r\n/* === RESET & BASE === */\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n:root {\r\n    /* Fantasy Color Palette */\r\n    --primary-gold: #d4af37;\r\n    --secondary-gold: #b8860b;\r\n    --accent-amber: #daa520;\r\n    --deep-forest: #1b3d1b;\r\n    --medium-forest: #2d4a2b;\r\n    --light-forest: #3d5a3b;\r\n    --forest-brown: #4a3f2a;\r\n    --dark-brown: #3d2f1f;\r\n    --medium-brown: #5d4037;\r\n    --light-brown: #6d4c41;\r\n    --stone-gray: #8d7053;\r\n    --warm-gray: #a68b5b;\r\n    --cream: #f5e6b3;\r\n    --dark-green: #0f2f0f;\r\n    --blood-red: #8b0000;\r\n    --dark-bronze: #8B7355;\r\n    --mystic-blue: #4169E1;\r\n    --rich-purple: #8A2BE2;\r\n    --shadow-black: #000000;\r\n    --parchment: #F5E6B3;\r\n    --forest-green: #1b5e20;\r\n    \r\n    /* Gradients */\r\n    --gold-gradient: linear-gradient(135deg, var(--primary-gold), var(--secondary-gold));\r\n    --forest-gradient: linear-gradient(135deg, var(--deep-forest), var(--medium-forest));\r\n    --earth-gradient: linear-gradient(135deg, var(--dark-brown), var(--medium-brown));\r\n    --natural-gradient: linear-gradient(135deg, var(--forest-brown), var(--medium-brown));\r\n    --command-gradient: linear-gradient(135deg, var(--dark-brown), var(--forest-brown));\r\n    \r\n    /* Typography */\r\n    --font-decorative: 'Cinzel Decorative', serif;\r\n    --font-title: 'Cinzel', serif;\r\n    --font-body: 'MedievalSharp', cursive;\r\n}\r\n\r\nbody {\r\n    font-family: var(--font-body);\r\n    background-color: var(--dark-green);\r\n    color: var(--cream);\r\n    overflow: hidden;\r\n    height: 100vh;\r\n}\r\n\r\n/* Screen Management */\r\n.screen {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100vh;\r\n    display: none;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n}\r\n\r\n.screen.active {\r\n    display: flex;\r\n}\r\n\r\n/* Main Menu Screen */\r\n#mainMenu {\r\n    text-align: center;\r\n}\r\n\r\n#mainMenu, #gameModeSelect, #multiplayerLobby {\r\n    background-color: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.3));\r\n    background-image: url('resources/images/background.png');\r\n    background-size: cover;\r\n    background-position: center center;\r\n    background-repeat: no-repeat;\r\n    overflow-y: auto;\r\n    padding: 2rem;\r\n}\r\n\r\nbody.bg2 #mainMenu, body.bg2 #gameModeSelect, body.bg2 #multiplayerLobby {\r\n    background-image: url('resources/images/background2.png');\r\n}\r\n\r\nbody.bg3 #mainMenu, body.bg3 #gameModeSelect, body.bg3 #multiplayerLobby {\r\n    background-image: url('resources/images/background3.png');\r\n}\r\n\r\n\r\nbody.bg4 #mainMenu, body.bg4 #gameModeSelect, body.bg4 #multiplayerLobby {\r\n    background-image: url('resources/images/background4.png');\r\n}\r\n\r\nbody.bg5 #mainMenu, body.bg5 #gameModeSelect, body.bg5 #multiplayerLobby {\r\n    background-image: url('resources/images/background5.png');\r\n}\r\n\r\n.game-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: clamp(2.5rem, 8vw, 5rem);\r\n    font-weight: 700;\r\n    color: var(--primary-gold);\r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    animation: titleGlow 3s ease-in-out infinite alternate;\r\n    position: relative;\r\n}\r\n\r\n@keyframes titleGlow {\r\n    from {\r\n        filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.5));\r\n    }\r\n    to {\r\n        filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8));\r\n    }\r\n}\r\n\r\n.subtitle {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--cream);\r\n    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);\r\n    margin-bottom: 3rem;\r\n    font-style: italic;\r\n}\r\n\r\n\r\n.main-menu-buttons {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n    min-width: 300px;\r\n}\r\n\r\n\r\n\r\n/* Game Mode Selection */\r\n.mode-selection {\r\n    text-align: center;\r\n    max-width: 1000px;\r\n    width: 100%;\r\n}\r\n\r\n.mode-selection h2 {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 2rem;    \r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n}\r\n\r\n.mode-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.mode-card {\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.8), rgba(13, 10, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 12px;\r\n    padding: 2rem;\r\n    cursor: pointer;\r\n    transition: all 0.4s ease;\r\n    text-align: center;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n.mode-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -50%;\r\n    left: -50%;\r\n    width: 200%;\r\n    height: 200%;\r\n    background: radial-gradient(circle, rgba(212, 175, 55, 0.1) 0%, transparent 70%);\r\n    opacity: 0;\r\n    transition: opacity 0.4s ease;\r\n    z-index: 0;\r\n}\r\n\r\n.mode-card:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.mode-card:hover {\r\n    transform: translateY(-8px) scale(1.02);\r\n    border-color: var(--primary-gold);\r\n    box-shadow: \r\n        0 15px 40px rgba(212, 175, 55, 0.2),\r\n        0 0 30px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.mode-card.selected {\r\n    border-color: var(--accent-amber);\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.4),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.1);\r\n}\r\n\r\n.mode-card > * {\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.mode-icon {\r\n    font-size: 3.5rem;\r\n    margin-bottom: 1rem;\r\n    display: block;\r\n}\r\n\r\n.mode-title {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.mode-description {\r\n    font-size: 0.95rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 1.2rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.mode-difficulty {\r\n    display: inline-block;\r\n    padding: 0.4rem 1rem;\r\n    border-radius: 20px;\r\n    font-size: 0.8rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.easy { \r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.medium { \r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    color: var(--shadow-black);\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.hard { \r\n    background: linear-gradient(135deg, var(--blood-red), #c62828);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(183, 28, 28, 0.3);\r\n}\r\n\r\n.expert { \r\n    background: linear-gradient(135deg, var(--rich-purple), #6a1b9a);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(74, 20, 140, 0.3);\r\n}\r\n\r\n/* Game Screen */\r\n#gameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#gameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#canvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#gameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.08) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(139, 0, 0, 0.08) 0%, transparent 50%),\r\n        #2a3a2a;\r\n    border-left: 2px solid var(--medium-brown);\r\n    cursor: crosshair;\r\n}\r\n\r\n#miniMapContainer {\r\n    min-width: 200px;\r\n    width: 200px;\r\n    height: 200px;\r\n    rotate: -45deg;\r\n    margin: 2em;\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.1rem;\r\n}\r\n\r\n#actionPanel {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    min-height: 200px;\r\n    min-width: 200px;\r\n    max-width: 200px;\r\n    max-height: 200px;\r\n}\r\n\r\n#selectedUnits {\r\n  max-height: 200px;\r\n  width: 100%;\r\n  display: flex;\r\n  gap: .5em;\r\n  pointer-events: none !important;\r\n  flex-wrap: wrap;\r\n}\r\n\r\n#selectedUnits > div {\r\n    display: flex;\r\n    width: 32px;\r\n    height: 32px;\r\n    pointer-events: all;\r\n}\r\n\r\n#selectedUnits > div > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n#selectedUnits > div.selected {\r\n    border: 2px solid  rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n}\r\n\r\n#unitPortrait {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    height: 128px;\r\n    width: 128px;\r\n    min-width: 128px;\r\n    max-width: 128px;\r\n}\r\n\r\n#unitPortrait > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n#gameControls {\r\n    position: absolute;\r\n    bottom: calc(200px + 2em);\r\n    right: 1em;\r\n    width: 200px;\r\n    margin: auto;\r\n}\r\n#undoBtn { display: none;}\r\n#uiContainer {\r\n    pointer-events: none;\r\n    display: flex;\r\n    position: absolute;\r\n    bottom: 1em;\r\n    left: 1em;\r\n    right: 1em;\r\n    align-items: flex-end;\r\n    gap: 1em;\r\n    justify-content: space-between;\r\n}\r\n#uiContainer > div {\r\n    pointer-events: all;\r\n}\r\n/* Buttons */\r\n.btn {\r\n    background: var(--gold-gradient);\r\n    color: var(--shadow-black);\r\n    border: 2px solid var(--secondary-gold);\r\n    padding: 12px 30px;\r\n    font-family: var(--font-title);\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    cursor: pointer;\r\n    border-radius: .5em;\r\n    position: relative;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.btn::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    z-index: -1;\r\n    opacity: 0;\r\n    transition: opacity 0.3s ease;\r\n    border-radius: .5em;\r\n}\r\n\r\n.btn:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.btn:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.4);\r\n}\r\n\r\n.btn:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.btn-secondary {\r\n    background: var(--mystical-gradient);\r\n    color: var(--parchment);\r\n    border-color: var(--mystic-blue);\r\n}\r\n\r\n.btn-secondary:hover {\r\n    box-shadow: 0 8px 20px rgba(21, 101, 192, 0.4);\r\n}\r\n\r\n.btn-danger {\r\n    background: linear-gradient(135deg, var(--blood-red), #d32f2f);\r\n    color: var(--parchment);\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.btn-danger:hover {\r\n    box-shadow: 0 8px 20px rgba(183, 28, 28, 0.4);\r\n}\r\n\r\n/* UI Components for Game */\r\n#resourcesContainer {\r\n    display: flex;\r\n    gap: 1em;\r\n    position: absolute;\r\n    top: 1em;\r\n    right: 1em;\r\n}\r\n.resource-label {\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.resource-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-size: 1.1rem;\r\n    text-shadow: 0 0 5px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.unit-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    text-align: center;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n    overflow: hidden;\r\n    animation: cardSlideIn 0.3s ease-out;\r\n}\r\n\r\n.unit-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);\r\n    transition: left 0.5s ease;\r\n}\r\n\r\n.unit-card:hover::before {\r\n    left: 100%;\r\n}\r\n\r\n.unit-card:hover {\r\n    border-color: var(--primary-gold);\r\n    transform: translateY(-3px) scale(1.02);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3), 0 0 15px rgba(212, 175, 55, 0.2);\r\n}\r\n.unit-card:hover .shimmer {\r\n    left: 100%;\r\n}\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1);\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3));\r\n    transform: translateY(-3px) scale(1.02);\r\n}\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.unit-card.disabled {\r\n    opacity: 0.4;\r\n    cursor: not-allowed;\r\n    filter: grayscale(0.7);\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none;\r\n    border-color: var(--dark-bronze);\r\n    box-shadow: none;\r\n}\r\n.unit-card.disabled:hover .shimmer {\r\n    left: -100%;\r\n}\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n.unit-card.disabled:hover .unit-icon {\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    border-color: var(--dark-bronze);\r\n    transform: scale(1);\r\n}\r\n/* Add these CSS styles to your main.css or in a <style> tag */\r\n\r\n/* Unit Icon Styles */\r\n.unit-icon {\r\n    width: 24px;\r\n    height: 24px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 6px;\r\n    border-radius: 3px;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    transition: all 0.2s ease;\r\n    border: 1px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* Hover effects for icons */\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n/* Selected card icon effects */\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n/* Disabled card icon effects */\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n\r\n/* Alternative styling for larger icons if you prefer */\r\n.unit-icon-large {\r\n    width: 32px;\r\n    height: 32px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 8px;\r\n    border-radius: 4px;\r\n    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n/* Icon error handling - fallback styling */\r\n.unit-icon:not([src]),\r\n.unit-icon[src=\"\"] {\r\n    background: linear-gradient(45deg, var(--dark-bronze), var(--primary-gold));\r\n    display: inline-block;\r\n    position: relative;\r\n}\r\n\r\n.unit-icon:not([src])::before,\r\n.unit-icon[src=\"\"]::before {\r\n    content: \"\";\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    font-size: 16px;\r\n}\r\n\r\n/* Rarity-based icon effects */\r\n.unit-card.rarity-rare:hover {\r\n    border-color: #4169E1;\r\n    box-shadow: 0 8px 20px rgba(65, 105, 225, 0.4), 0 0 15px rgba(65, 105, 225, 0.2);\r\n}\r\n\r\n.unit-card.rarity-epic:hover {\r\n    border-color: #8A2BE2;\r\n    box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4), 0 0 15px rgba(138, 43, 226, 0.2);\r\n}\r\n\r\n.unit-card.rarity-legendary:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.6), 0 0 20px rgba(255, 215, 0, 0.4);\r\n}\r\n\r\n/* Rarity background effects */\r\n.unit-card.rarity-rare {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(65, 105, 225, 0.3) 0%, transparent 70%);\r\n    border-color: #4169E1;\r\n}\r\n\r\n.unit-card.rarity-epic {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(138, 43, 226, 0.3) 0%, transparent 70%);\r\n    border-color: #8A2BE2;\r\n}\r\n\r\n.unit-card.rarity-legendary {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(255, 215, 0, 0.3) 0%, transparent 70%);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Legendary border animation */\r\n.unit-card.rarity-legendary .legendary-border {\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    border-radius: 10px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    animation: legendaryBorder 3s ease-in-out infinite;\r\n    z-index: -1;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Unit cost color states */\r\n.unit-cost.cost-affordable {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.unit-cost.cost-unaffordable {\r\n    color: var(--blood-red);\r\n}\r\n\r\n@keyframes cardSlideIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(20px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .unit-icon {\r\n        width: 20px;\r\n        height: 20px;\r\n        margin-right: 4px;\r\n    }\r\n}\r\n\r\n/* Loading placeholder for icons */\r\n.unit-icon[loading] {\r\n    background: linear-gradient(90deg, \r\n        rgba(212, 175, 55, 0.1) 25%, \r\n        rgba(212, 175, 55, 0.2) 50%, \r\n        rgba(212, 175, 55, 0.1) 75%);\r\n    background-size: 200% 100%;\r\n    animation: shimmer 2s infinite;\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { background-position: -200% 0; }\r\n    100% { background-position: 200% 0; }\r\n}\r\n.unit-name {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    margin-bottom: 6px;\r\n    font-size: 0.9rem;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n}\r\n\r\n.unit-name img {\r\n    width: 24px; \r\n    height: 24px; \r\n    object-fit: cover; \r\n    vertical-align: middle; \r\n    margin-right: 6px; \r\n    border-radius: 3px;\r\n}\r\n\r\n.unit-cost {\r\n    color: var(--accent-amber); \r\n    font-size: 0.8rem; \r\n    margin-bottom: 6px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-stats {\r\n    font-size: 0.75rem; \r\n    line-height: 1.2;\r\n}\r\n\r\n.spec-unit-preview {\r\n    margin-top: 8px;\r\n    padding: 6px;\r\n    background: rgba(255, 170, 0, 0.1);\r\n    border-radius: 4px;\r\n    font-size: 10px;\r\n    color: #ffaa00;\r\n    position: relative;\r\n    z-index: 2;\r\n    border: 1px solid rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.army-list {\r\n    max-height: 200px;\r\n    overflow-y: auto;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n.army-unit {\r\n    padding: 0.8rem;\r\n    margin: 0.3rem 0;\r\n    background: \r\n        linear-gradient(135deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border-radius: 6px;\r\n    border: 1px solid var(--dark-bronze);\r\n    color: var(--parchment);\r\n    font-size: 0.85rem;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.army-unit:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);\r\n}\r\n\r\n.stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.stat-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.ready-status {\r\n    font-weight: bold;\r\n}\r\n\r\n.connection-good {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.connection-waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.connection-bad {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Ready Button - Make it prominent */\r\n.ready-btn {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 3px solid #388e3c;\r\n    padding: 1rem 2rem;\r\n    border-radius: 8px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.1rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    transition: all 0.3s ease;\r\n    box-shadow: \r\n        0 0 20px rgba(27, 94, 32, 0.3),\r\n        0 4px 15px rgba(27, 94, 32, 0.2);\r\n    animation: readyPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.ready-btn:hover {\r\n    background: linear-gradient(135deg, #2e7d32, #388e3c);\r\n    transform: translateY(-3px) scale(1.05);\r\n    box-shadow: \r\n        0 0 30px rgba(27, 94, 32, 0.5),\r\n        0 8px 25px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.ready-btn:disabled {\r\n    background: var(--stone-gray);\r\n    color: #666;\r\n    border-color: #666;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n    animation: none;\r\n    box-shadow: none;\r\n}\r\n\r\n.ready-btn.ready-state {\r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    border-color: var(--accent-amber);\r\n    animation: readyGlow 1.5s ease-in-out infinite alternate;\r\n}\r\n\r\n/* Multiplayer Lobby Enhancements */\r\n.multiplayer-lobby-container {\r\n    max-width: 900px;\r\n    width: 100%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border-radius: 15px;\r\n    padding: 2rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.lobby-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    background: var(--gold-gradient);\r\n    -webkit-background-clip: text;\r\n    -webkit-text-fill-color: transparent;\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    text-align: center;\r\n}\r\n\r\n.room-info {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.room-id-display {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 1rem;\r\n}\r\n\r\n.room-label {\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.room-id {\r\n    font-family: var(--font-title);\r\n    color: var(--accent-amber);\r\n    font-size: 1.2rem;\r\n    font-weight: bold;\r\n    letter-spacing: 2px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.status-indicator {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Players Section */\r\n.players-section {\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.players-section h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.8rem;\r\n    margin-bottom: 1.5rem;\r\n    text-align: center;\r\n}\r\n\r\n.players-grid {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 1.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.player-card {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    position: relative;\r\n}\r\n\r\n.player-card.ready {\r\n    border-color: var(--forest-green);\r\n    box-shadow: 0 0 20px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.player-card.waiting {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.player-card.empty {\r\n    border-color: var(--stone-gray);\r\n    opacity: 0.6;\r\n    border-style: dashed;\r\n}\r\n\r\n.player-name {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.player-status {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.player-status.ready {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.player-status.waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.player-status.empty {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.player-stats {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.lobby-status {\r\n    margin-bottom: 2rem;\r\n    text-align: center;\r\n}\r\n\r\n.status-message {\r\n    font-size: 1.3rem;\r\n    color: var(--accent-amber);\r\n    margin-bottom: 1rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-progress {\r\n    margin-top: 1rem;\r\n}\r\n\r\n.progress-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin-bottom: 0.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.progress-fill {\r\n    height: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    width: 0%;\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.progress-text {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-info h3 {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 1rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.game-settings {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.setting {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.setting-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.setting-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n}\r\n\r\n.lobby-footer {\r\n    border-top: 1px solid var(--dark-bronze);\r\n    padding-top: 2rem;\r\n}\r\n\r\n/* Enhanced Lobby Controls */\r\n.lobby-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n    padding: 1.5rem;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    border-radius: 10px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.lobby-controls-left {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n.lobby-controls-right {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n\r\n/* Retreat button - less prominent */\r\n#leaveLobbyBtn {\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 2px solid #757575;\r\n    padding: 0.8rem 1.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n#leaveLobbyBtn:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.lobby-tips {\r\n    color: var(--stone-gray);\r\n    font-size: 0.9rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.lobby-tips p {\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n/* Multiplayer Game Screen Styles */\r\n#multiplayerGameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#multiplayerGameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#multiplayerCanvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#multiplayerGameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.1) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(183, 28, 28, 0.1) 0%, transparent 50%),\r\n        #111111;\r\n    cursor: crosshair;\r\n}\r\n\r\n.opponent-overlay {\r\n    position: absolute;\r\n    top: 10px;\r\n    right: 10px;\r\n    z-index: 100;\r\n}\r\n\r\n.opponent-info-card {\r\n    background: rgba(0, 0, 0, 0.9);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    min-width: 250px;\r\n    color: var(--parchment);\r\n}\r\n\r\n.opponent-info-card h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.8rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-details {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.opponent-details > div {\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.opponent-details .label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.status-deploying { color: var(--accent-amber); }\r\n.status-ready { color: var(--forest-green); }\r\n.status-battling { color: var(--blood-red); }\r\n\r\n#multiplayerUIContainer {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    width: 380px;\r\n    height: 100%;\r\n    background: \r\n        linear-gradient(180deg, rgba(26, 13, 26, 0.95) 0%, rgba(13, 10, 26, 0.95) 50%, rgba(26, 10, 13, 0.95) 100%);\r\n    border-left: 3px solid var(--primary-gold);\r\n    padding: 1.5rem;\r\n    overflow-y: auto;\r\n}\r\n\r\n.multiplayer-player-panel {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-resources {\r\n    background: \r\n        linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    margin-bottom: 1.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.multiplayer-unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-game-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.multiplayer-phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.versus-info {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    font-size: 0.9rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-indicator {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n}\r\n\r\n.vs {\r\n    color: var(--accent-amber);\r\n    font-weight: bold;\r\n}\r\n\r\n.opponent-indicator {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n}\r\n\r\n.multiplayer-phase-info .phase-title {\r\n    font-size: 1.5rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.5rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.8rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 15px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n.phase-timer {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.round-info {\r\n    color: var(--mystic-blue);\r\n    font-family: var(--font-title);\r\n    font-size: 1.1rem;\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n/* Victory/Defeat Screens */\r\n#victoryScreen, #defeatScreen {\r\n    text-align: center;\r\n}\r\n\r\n#victoryScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(27, 94, 32, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n#defeatScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(183, 28, 28, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n.result-content {\r\n    max-width: 600px;\r\n    width: 90%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.result-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 3.5rem;\r\n    margin-bottom: 2rem;\r\n    text-shadow: 0 0 20px currentColor;\r\n}\r\n\r\n.victory-title {\r\n    color: var(--forest-green);\r\n    animation: victoryPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.defeat-title {\r\n    color: var(--blood-red);\r\n    animation: defeatShake 0.5s ease-in-out infinite;\r\n}\r\n\r\n@keyframes victoryPulse {\r\n    0%, 100% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n}\r\n\r\n@keyframes defeatShake {\r\n    0%, 100% { transform: translateX(0); }\r\n    25% { transform: translateX(-3px); }\r\n    75% { transform: translateX(3px); }\r\n}\r\n\r\n.stats-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(2, 1fr);\r\n    gap: 1rem;\r\n    margin: 2rem 0;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1.5rem;\r\n    border-radius: 10px;\r\n}\r\n\r\n.victory-stats .stat, .defeat-stats .stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    padding: 0.5rem 0;\r\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\r\n}\r\n\r\n.stat-card {\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n}\r\n\r\n.stat-label {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.stat-value {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.victory-controls, .defeat-controls {\r\n    display: flex;\r\n    gap: 1rem;\r\n    justify-content: center;\r\n    margin-top: 2rem;\r\n}\r\n\r\n.victory-controls .btn, .defeat-controls .btn {\r\n    min-width: 150px;\r\n}\r\n\r\n/* Loading Screen */\r\n#loadingScreen {\r\n    background: var(--shadow-gradient);\r\n}\r\n\r\n.loading-content {\r\n    text-align: center;\r\n}\r\n\r\n.loading-spinner {\r\n    width: 60px;\r\n    height: 60px;\r\n    border: 4px solid var(--dark-bronze);\r\n    border-top: 4px solid var(--primary-gold);\r\n    border-radius: 50%;\r\n    animation: spin 1s linear infinite;\r\n    margin: 0 auto 2rem;\r\n    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n.loading-text {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.5rem;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.loading-tip {\r\n    color: var(--stone-gray);\r\n    font-style: italic;\r\n    max-width: 400px;\r\n    margin: 0 auto;\r\n    line-height: 1.4;\r\n}\r\n\r\n/* Pause Menu */\r\n.pause-overlay {\r\n    display: none;\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.85);\r\n    z-index: 2000;\r\n    justify-content: center;\r\n    align-items: center;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.pause-overlay.active {\r\n    display: flex;\r\n}\r\n\r\n.pause-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    text-align: center;\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.pause-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n/* Battle log styles */\r\n.battle-log {\r\n    background: rgba(0, 0, 0, 0.6);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    height: 150px;\r\n    overflow-y: auto;\r\n    font-size: 0.8rem;\r\n    margin-top: 1.5rem;\r\n}\r\n\r\n.log-entry {\r\n    margin: 0.3rem 0;\r\n    padding: 0.3rem 0.5rem;\r\n    border-radius: 3px;\r\n    line-height: 1.3;\r\n}\r\n\r\n.log-damage {\r\n    color: #ff6666;\r\n    background: rgba(255, 102, 102, 0.1);\r\n}\r\n\r\n.log-death {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n    background: rgba(183, 28, 28, 0.1);\r\n}\r\n\r\n.log-victory {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n    background: rgba(27, 94, 32, 0.1);\r\n}\r\n\r\n.log-placement {\r\n    color: var(--primary-gold);\r\n    background: rgba(212, 175, 55, 0.1);\r\n}\r\n\r\n/* Experience Panel Styles */\r\n.experience-panel {\r\n    background: linear-gradient(135deg, rgba(255, 140, 0, 0.15), rgba(212, 175, 55, 0.15));\r\n    border-radius: 10px;\r\n    border: 2px solid var(--accent-amber);\r\n    animation: experienceGlow 2s ease-in-out infinite alternate;\r\n    position: relative;\r\n    overflow: hidden;\r\n    padding: 0.5em;\r\n    margin-bottom: 1em;\r\n}\r\n\r\n.experience-panel .experience-squad-info {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    align-items: center; margin-bottom: 6px; position: relative; z-index: 2;\r\n}\r\n\r\n.experience-panel .experience-squad-name {\r\n    color: var(--parchment); font-size: 13px; font-weight: bold; font-family: var(--font-title);\r\n}\r\n\r\n.experience-panel .experience-levelUpCost {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    font-size: 11px; \r\n    margin-bottom: 6px; \r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-panel .level-up-button {\r\n    position: relative;\r\n    z-index: 2;   \r\n}\r\n\r\n.experience-panel .level-up-button.level-up-button-spec {\r\n    background: 'linear-gradient(135deg, #cc6600, #ff8800)';\r\n    border-color: '#ffaa00';\r\n    box-shadow: '0 0 15px rgba(255, 170, 0, 0.4)';\r\n}\r\n\r\n.experience-nextLevelSpec {\r\n    color: '#ffaa00'; \r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.experience-nextLevel {    \r\n    color: '#44ff44';\r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-card .shimmer {\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);\r\n    transition: left 0.5s ease;\r\n    pointer-events: none;\r\n    z-index: 1;\r\n}\r\n\r\n.insufficientGoldEffect  {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    background: rgba(183, 28, 28, 0.3);\r\n    border-radius: 8px;\r\n    animation: insufficientGoldFlash 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 5;\r\n}\r\n\r\n@keyframes experienceGlow {\r\n    from { box-shadow: 0 0 10px rgba(255, 140, 0, 0.3); }\r\n    to { box-shadow: 0 0 25px rgba(255, 140, 0, 0.6); }\r\n}\r\n.selection-ripple {\r\n    position: absolute;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);\r\n    border-radius: 50%;\r\n    transform: scale(0);\r\n    animation: selectionRipple 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-burst {\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, \r\n        rgba(255, 215, 0, 0.9) 0%, \r\n        rgba(255, 140, 0, 0.6) 50%, \r\n        transparent 100%);\r\n    border-radius: 50%;\r\n    transform: translate(-50%, -50%) scale(0);\r\n    animation: levelUpBurst 1.2s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-sparkle {\r\n    position: absolute;\r\n    width: 4px;\r\n    height: 4px;\r\n    background: var(--primary-gold);\r\n    transform: scale(0);\r\n    animation: sparkle 0.8s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n.experience-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin: 0.5rem 0;\r\n    border: 1px solid var(--dark-bronze);\r\n\r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-fill {\r\n    height: 100%;\r\n    width: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.level-up-button {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 2px solid #388e3c;\r\n    padding: 0.5rem 1rem;\r\n    margin: 0.3rem;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.8rem;\r\n    font-weight: 600;\r\n    transition: all 0.3s ease;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.level-up-button:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 5px 15px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.level-up-button:disabled {\r\n    background: var(--stone-gray);\r\n    border-color: #616161;\r\n    cursor: not-allowed;\r\n    opacity: 0.6;\r\n}\r\n\r\n/* Undo Container */\r\n.undo-container {\r\n    margin-bottom: 1.5rem;\r\n    padding: 1rem;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.undo-button {\r\n    width: 100%;\r\n    padding: 0.8rem;\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 1px solid #757575;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.9rem;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.undo-button:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.undo-button:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n}\r\n\r\n/* Multiplayer Setup Dialog */\r\n.multiplayer-setup-dialog {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.9);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    z-index: 3000;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.setup-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 2.5rem;\r\n    max-width: 500px;\r\n    width: 90%;\r\n    text-align: center;\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.setup-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.player-name-input {\r\n    margin: 2rem 0;\r\n}\r\n\r\n.player-name-input label {\r\n    display: block;\r\n    margin-bottom: 0.8rem;\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-name-input input {\r\n    width: 100%;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    font-size: 1rem;\r\n    font-family: var(--font-title);\r\n    transition: border-color 0.3s ease;\r\n}\r\n\r\n.player-name-input input:focus {\r\n    border-color: var(--primary-gold);\r\n    outline: none;\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.room-join-section {\r\n    margin-top: 1.5rem;\r\n    display: flex;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.room-join-section input {\r\n    flex: 1;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    text-transform: uppercase;\r\n    font-family: var(--font-title);\r\n    font-weight: bold;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.opponent-info {\r\n    background: rgba(0,0,0,0.8);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 5px;\r\n    padding: 1rem;\r\n    color: var(--parchment);\r\n    min-width: 200px;\r\n}\r\n\r\n.opponent-info h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-stats div {\r\n    margin: 0.25rem 0;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.multiplayer-notification {\r\n    background: rgba(0,0,0,0.9);\r\n    border: 2px solid;\r\n    border-radius: 5px;\r\n    padding: 1rem 2rem;\r\n    margin: 0.5rem;\r\n    font-weight: bold;\r\n    animation: notificationSlideIn 0.3s ease-out;\r\n}\r\n\r\n.modal {\r\n    position: fixed; \r\n    top: 0; \r\n    left: 0; \r\n    width: 100%; \r\n    height: 100%;\r\n    background: rgba(0,0,0,0.9); \r\n    display: flex; \r\n    justify-content: center;\r\n    align-items: center; \r\n    z-index: 10000;\r\n}\r\n\r\n.team-health-bar {\r\n    background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    border: 1px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 0.8rem;\r\n    min-width: 200px;\r\n    text-align: center;\r\n    font-family: 'Courier New', monospace;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.player-health {\r\n    border-color: #00ff00;\r\n}\r\n\r\n.opponent-health {\r\n    border-color: #ff4444;\r\n}\r\n\r\n.team-label {\r\n    font-size: 0.9rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n    text-shadow: 0 0 5px currentColor;\r\n}\r\n\r\n.health-bar-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.3rem;\r\n}\r\n\r\n.health-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background: #222;\r\n    border: 1px solid #444;\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n\r\n.health-fill {\r\n    height: 100%;\r\n    transition: width 0.5s ease;\r\n    border-radius: 10px;\r\n    position: relative;\r\n}\r\n\r\n.player-fill {\r\n    background: linear-gradient(90deg, #004400 0%, #00aa00 50%, #00ff00 100%);\r\n    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);\r\n}\r\n\r\n.opponent-fill {\r\n    background: linear-gradient(90deg, #440000 0%, #aa0000 50%, #ff4444 100%);\r\n    box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);\r\n}\r\n\r\n.health-text {\r\n    font-size: 0.8rem;\r\n    color: #fff;\r\n    font-weight: bold;\r\n    text-shadow: 1px 1px 2px #000;\r\n}\r\n\r\n.damage-popup {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    text-shadow: 2px 2px 4px #000;\r\n    animation: damageFloat 2s ease-out forwards;\r\n    pointer-events: none;\r\n    z-index: 1001;\r\n    color: #ff6666;\r\n}\r\n\r\n@keyframes damageFloat {\r\n    0% {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n        font-size: 1.5rem;\r\n    }\r\n    50% {\r\n        opacity: 1;\r\n        transform: translateY(-30px);\r\n        font-size: 2rem;\r\n    }\r\n    100% {\r\n        opacity: 0;\r\n        transform: translateY(-60px);\r\n        font-size: 1rem;\r\n    }\r\n}\r\n@keyframes notificationSlideIn {\r\n    from {\r\n        transform: translateX(100%);\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n/* Scrollbar Styling */\r\n::-webkit-scrollbar {\r\n    width: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border-radius: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: var(--dark-bronze);\r\n    border-radius: 4px;\r\n    transition: background 0.3s ease;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: var(--primary-gold);\r\n}\r\n\r\n/* Responsive Design */\r\n@media (max-width: 768px) {\r\n    .game-title {\r\n        font-size: 2.5rem;\r\n    }\r\n    \r\n    .mode-grid {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    #canvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #uiContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n    \r\n    .phase-info {\r\n        position: relative;\r\n        bottom: auto;\r\n        left: auto;\r\n        margin: 1rem;\r\n    }\r\n\r\n    .unit-shop {\r\n        grid-template-columns: 1fr;\r\n    }\r\n\r\n    #multiplayerCanvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #multiplayerUIContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        height: auto;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n}\r\n\r\n\r\n\r\n/* Ripple Animation */\r\n@keyframes ripple {\r\n    to {\r\n        transform: scale(4);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n@keyframes particleFloat {\r\n    0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }\r\n    10% { opacity: 1; }\r\n    90% { opacity: 1; }\r\n    100% { transform: translate(-100px, -100vh) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { left: -100%; }\r\n    50% { left: 100%; }\r\n    100% { left: 100%; }\r\n}\r\n\r\n@keyframes selectionPulse {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(10); opacity: 0; }\r\n}\r\n\r\n@keyframes selectionBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(8); opacity: 0; }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(6); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(12); opacity: 0; }\r\n}\r\n\r\n@keyframes cardSelect {\r\n    0% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n    100% { transform: scale(1.02); }\r\n}\r\n\r\n@keyframes cardDeselect {\r\n    0% { transform: scale(1.02); }\r\n    100% { transform: scale(1); }\r\n}\r\n\r\n@keyframes copyPulse {\r\n    0%, 100% { transform: scale(1); color: var(--accent-amber); }\r\n    50% { transform: scale(1.1); color: var(--primary-gold); }\r\n}\r\n\r\n@keyframes notificationSlideOut {\r\n    from { transform: translateX(0); opacity: 1; }\r\n    to { transform: translateX(100%); opacity: 0; }\r\n}\r\n\r\n\r\n\r\n @keyframes selectionRipple {\r\n    0% { transform: scale(0); opacity: 1; }\r\n    100% { transform: scale(6); opacity: 0; }\r\n}\r\n\r\n@keyframes insufficientGoldFlash {\r\n    0%, 100% { opacity: 0; }\r\n    50% { opacity: 1; }\r\n}\r\n\r\n@keyframes sparkle {\r\n    0% { transform: scale(0) rotate(0deg); opacity: 1; }\r\n    50% { transform: scale(1) rotate(180deg); opacity: 1; }\r\n    100% { transform: scale(0) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes legendaryBorder {\r\n    0%, 100% { opacity: 0.6; transform: scale(1); }\r\n    50% { opacity: 1; transform: scale(1.02); }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(8); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(15); opacity: 0; }\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber) !important;\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3)) !important;\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1) !important;\r\n    transform: translateY(-3px) scale(1.02) !important;\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none !important;\r\n    border-color: var(--dark-bronze) !important;\r\n    box-shadow: none !important;\r\n}\r\n\r\n\r\n@keyframes readyPulse {\r\n    0%, 100% { \r\n        box-shadow: \r\n            0 0 20px rgba(27, 94, 32, 0.3),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n    50% { \r\n        box-shadow: \r\n            0 0 35px rgba(27, 94, 32, 0.5),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n}\r\n\r\n@keyframes readyGlow {\r\n    from { \r\n        box-shadow: \r\n            0 0 20px rgba(255, 140, 0, 0.4),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n    to { \r\n        box-shadow: \r\n            0 0 40px rgba(255, 140, 0, 0.7),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n}\r\n\r\n@keyframes startGamePulse {\r\n    0%, 100% { \r\n        box-shadow: 0 0 25px rgba(74, 20, 140, 0.4);\r\n    }\r\n    50% { \r\n        box-shadow: 0 0 40px rgba(74, 20, 140, 0.7);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/* Building Shop Container */\r\n#buildingShop {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 8px;\r\n    padding: 10px;\r\n    overflow-y: auto;\r\n    max-height: calc(100vh - 200px);\r\n}\r\n\r\n/* Building Section */\r\n.building-section {\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.building-section-header {\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n    margin-bottom: 10px;\r\n    font-size: 1rem;\r\n}\r\n\r\n/* Building Card */\r\n.building-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    margin-bottom: 8px;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n}\r\n\r\n.building-card.owned {\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n.building-card.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.building-card.phase-disabled {\r\n    opacity: 0.6;\r\n    filter: grayscale(0.5);\r\n}\r\n\r\n.building-card.hover {\r\n    transform: scale(1.02) translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.building-card.shake {\r\n    animation: shake 0.5s;\r\n}\r\n\r\n/* Building Card Header */\r\n.building-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-title {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.building-card-progress {\r\n    color: var(--accent-amber);\r\n    font-size: 0.7rem;\r\n}\r\n\r\n/* Building Card Details */\r\n.building-card-cost {\r\n    color: var(--accent-amber);\r\n    font-size: 0.8rem;\r\n    margin-bottom: 6px;\r\n    font-weight: bold;\r\n}\r\n\r\n.building-card-locked {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-description {\r\n    font-size: 0.75rem;\r\n    line-height: 1.2;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.building-card-owned {\r\n    color: var(--forest-green);\r\n    font-size: 0.7rem;\r\n    margin-top: 6px;\r\n}\r\n\r\n/* Upgrade Modal */\r\n.upgrade-modal {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.8);\r\n    z-index: 10000;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    animation: fadeIn 0.2s;\r\n}\r\n\r\n.upgrade-panel {\r\n    background: linear-gradient(145deg, #1a1a2e, #16213e);\r\n    border: 2px solid var(--primary-gold);\r\n    border-radius: 10px;\r\n    padding: 20px;\r\n    max-width: 500px;\r\n    max-height: 80vh;\r\n    overflow-y: auto;\r\n    width: 90%;\r\n}\r\n\r\n.upgrade-panel-header {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 15px;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n/* Upgrade List */\r\n.upgrade-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 10px;\r\n    margin-bottom: 15px;\r\n}\r\n\r\n/* Upgrade Card */\r\n.upgrade-card {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    transition: all 0.2s;\r\n}\r\n\r\n.upgrade-card.purchased {\r\n    border-color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked {\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.upgrade-card.available {\r\n    cursor: pointer;\r\n}\r\n\r\n.upgrade-card.available:hover {\r\n    transform: translateX(5px);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Upgrade Card Header */\r\n.upgrade-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: start;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-name {\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n}\r\n\r\n.upgrade-card-status {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.upgrade-card.purchased .upgrade-card-status {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked .upgrade-card-status {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Upgrade Card Details */\r\n.upgrade-card-description {\r\n    color: var(--stone-gray);\r\n    font-size: 0.85rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-requirement {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n}\r\n\r\n/* Upgrade Close Button */\r\n.upgrade-close-button {\r\n    width: 100%;\r\n}\r\n\r\n/* Animations */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n@keyframes shake {\r\n    0%, 100% {\r\n        transform: translateX(0);\r\n    }\r\n    10%, 30%, 50%, 70%, 90% {\r\n        transform: translateX(-5px);\r\n    }\r\n    20%, 40%, 60%, 80% {\r\n        transform: translateX(5px);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.shop-container {\r\n    display: grid;\r\n    grid-template-columns: 200px 1fr;\r\n    gap: 1rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n\r\n.action-panel-header {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.6rem;\r\n    font-size: 1.1rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 1rem;\r\n    padding-bottom: 0.6rem;\r\n    border-bottom: 2px solid rgba(255, 170, 0, 0.3);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.deselect-btn {\r\n    background: rgba(255, 170, 0, 0.2);\r\n    border: 1px solid rgba(255, 170, 0, 0.5);\r\n    border-radius: 4px;\r\n    padding: 0.3rem 0.6rem;\r\n    color: #ffaa00;\r\n    cursor: pointer;\r\n    font-weight: bold;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.deselect-btn:hover {\r\n    background: rgba(255, 170, 0, 0.3);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n}\r\n\r\n.action-section {\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.action-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.action-section-header {\r\n    font-size: 0.85rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 0.8rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.action-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));\r\n    gap: 0.6rem;\r\n    width: 100%;\r\n}\r\n\r\n.action-btn {\r\n    position: relative;\r\n    background: linear-gradient(145deg, #2a2a3e, #1a1a2e);\r\n    border: 2px solid rgba(255, 170, 0, 0.4);\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n}\r\n\r\n.action-btn:hover:not(.locked):not(.disabled):not(.purchased) {\r\n    background: linear-gradient(145deg, #3a3a4e, #2a2a3e);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.action-btn.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: rgba(100, 100, 100, 0.4);\r\n}\r\n\r\n.action-btn.disabled {\r\n    opacity: 0.6;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.action-btn.purchased {\r\n    background: linear-gradient(145deg, #2a3a2e, #1a2a1e);\r\n    border-color: rgba(74, 222, 128, 0.6);\r\n    opacity: 0.8;\r\n    cursor: default;\r\n}\r\n\r\n.action-btn-icon {\r\n    font-size: 2rem;\r\n}\r\n\r\n.action-btn-icon > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n.action-btn-title {\r\n    font-size: 0.75rem;\r\n    font-weight: 600;\r\n    color: #fff;\r\n    text-align: center;\r\n    line-height: 1.2;\r\n}\r\n\r\n.action-btn-cost {\r\n    font-size: 0.75rem;\r\n    color: #ffaa00;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-check {\r\n    color: #4ade80;\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-lock {\r\n    position: absolute;\r\n    top: 4px;\r\n    right: 4px;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.action-btn-tooltip {\r\n    position: absolute;\r\n    bottom: 100%;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background: rgba(0, 0, 0, 0.95);\r\n    color: #fff;\r\n    padding: 0.4rem 0.6rem;\r\n    border-radius: 4px;\r\n    font-size: 0.7rem;\r\n    white-space: nowrap;\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    transition: opacity 0.2s ease;\r\n    margin-bottom: 4px;\r\n    z-index: 1000;\r\n}\r\n\r\n.action-btn.locked:hover .action-btn-tooltip {\r\n    opacity: 1;\r\n}\r\n\r\n.action-empty {\r\n    text-align: center;\r\n    color: rgba(255, 255, 255, 0.4);\r\n    font-style: italic;\r\n    padding: 3rem 1rem;\r\n}\r\n\r\n@media (max-width: 768px) {\r\n    .shop-container {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    .building-list {\r\n        max-height: 200px;\r\n        display: flex;\r\n        flex-wrap: nowrap;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n        gap: 0.5rem;\r\n        padding: 0.6rem;\r\n    }\r\n    \r\n    .building-list-item {\r\n        flex-direction: column;\r\n        min-width: 80px;\r\n        margin-bottom: 0;\r\n        padding: 0.5rem;\r\n    }\r\n    \r\n    .building-list-info {\r\n        text-align: center;\r\n    }\r\n    \r\n    .action-grid {\r\n        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/main.html",
        "html": "<!-- Main Menu Screen -->\r\n<div id=\"mainMenu\" class=\"screen active\">\r\n    <div class=\"game-title\">LEGENDS OF THE ARENA</div>\r\n    <div class=\"subtitle\">Where Heroes Rise and Legends Are Forged</div>\r\n    <div class=\"main-menu-buttons\">\r\n        <button id=\"mainMenu_PlayGameBtn\" class=\"btn\"> ENTER BATTLE</button>\r\n        <button id=\"mainMenu_SettingsBtn\" class=\"btn btn-secondary\"> SETTINGS</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Mode Selection Screen -->\r\n<div id=\"gameModeSelect\" class=\"screen\">\r\n    <div class=\"mode-selection\">\r\n        <h2> CHOOSE YOUR DESTINY</h2>\r\n        <div class=\"mode-grid\" id=\"modeGrid\">\r\n            <!-- Game mode cards populated by GameModeManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"gameMode_BackBtn\" class=\"btn btn-secondary\"> RETURN</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Multiplayer Lobby -->\r\n<div id=\"multiplayerLobby\" class=\"screen\">\r\n    <div class=\"multiplayer-lobby-container\">\r\n        <div class=\"lobby-header\">\r\n            <h1 class=\"lobby-title\"> WAR COUNCIL</h1>\r\n            <div class=\"room-info\">\r\n                <div class=\"room-id-display\">\r\n                    <span class=\"room-label\">Battle Hall:</span>\r\n                    <span id=\"lobbyRoomId\" class=\"room-id\">------</span>\r\n                    <button id=\"copyRoomIdBtn\" class=\"btn-small\"> Copy</button>\r\n                </div>\r\n                <div class=\"connection-status\">\r\n                    <span id=\"connectionStatus\" class=\"status-indicator\"> Summoning...</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"lobby-content\">\r\n            <div class=\"players-section\">\r\n                <h2> Warriors (<span id=\"playerCount\">1</span>/2)</h2>\r\n                <div id=\"playersContainer\" class=\"players-grid\">\r\n                    <div class=\"player-card\" id=\"player1Card\">\r\n                        <div class=\"player-name\" id=\"player1Name\">You</div>\r\n                        <div class=\"player-status waiting\" id=\"player1Status\"> Preparing...</div>\r\n                        <div class=\"player-stats\">Ready to battle</div>\r\n                    </div>\r\n                    <div class=\"player-card empty\" id=\"player2Card\">\r\n                        <div class=\"player-name\" id=\"player2Name\">Waiting for opponent</div>\r\n                        <div class=\"player-status empty\" id=\"player2Status\"> Empty slot</div>\r\n                        <div class=\"player-stats\">Seeking worthy challenger</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n\r\n\r\n            <div class=\"lobby-status\">\r\n                <div class=\"status-message\" id=\"lobbyStatusMessage\">Waiting for worthy opponents...</div>\r\n                <div class=\"game-progress\">\r\n                    <div class=\"progress-bar\">\r\n                        <div class=\"progress-fill\" id=\"gameProgressFill\"></div>\r\n                    </div>\r\n                    <div class=\"progress-text\" id=\"gameProgressText\">Preparing battlefield...</div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"game-info\">\r\n                <h3> Battle Configuration</h3>\r\n                <div class=\"game-settings\">\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\"> Game Mode</span>\r\n                        <span class=\"setting-value\" id=\"lobbyGameMode\">Arena Combat</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\"> Turn Timer</span>\r\n                        <span class=\"setting-value\" id=\"lobbyTurnTimer\">30 seconds</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\"> Starting Gold</span>\r\n                        <span class=\"setting-value\" id=\"lobbyStartGold\">100 coins</span>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"lobby-footer\">\r\n                <div class=\"lobby-controls\">\r\n                    <div class=\"lobby-controls-left\">\r\n                        <button id=\"leaveLobbyBtn\" class=\"btn btn-secondary\"> Retreat</button>\r\n                    </div>\r\n                    <div class=\"lobby-controls-right\">\r\n                        <button id=\"player1ReadyBtn\" class=\"ready-btn\"> READY FOR BATTLE</button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"lobby-tips\">\r\n                    <p> Prepare your strategies while waiting for opponents</p>\r\n                    <p> Victory requires both tactical skill and wise resource management</p>\r\n                    <p> The realm's fate lies in your hands, Commander</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Screen -->\r\n<div id=\"gameScreen\" class=\"screen\">\r\n    <div id=\"gameContainer\">\r\n        <div id=\"canvasContainer\">\r\n            <canvas id=\"gameCanvas\"></canvas>\r\n        </div>\r\n        <div id=\"resourcesContainer\" class=\"resources\">\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\"></span>\r\n                <span class=\"resource-value\" id=\"playerGold\">--</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\"></span>\r\n                <span class=\"resource-value\" id=\"playerSupplies\">0</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\"></span>\r\n                <span class=\"resource-value\" id=\"currentRound\">--</span>\r\n            </div>\r\n        </div>\r\n        <div id=\"unitPromotions\" style=\"display: none\"></div>  \r\n        <div id=\"gameControls\">\r\n            <button id=\"game_ExitBtn\" class=\"btn btn-secondary\" style=\"display:none\"> RETREAT</button>\r\n            <button id=\"undoBtn\" class=\"btn btn-secondary\"> Undo</button>\r\n            <button id=\"placementReadyBtn\" class=\"btn btn-primary\">Ready for Battle!</button>\r\n        </div>\r\n        <div id=\"uiContainer\">              \r\n            <div id=\"miniMapContainer\"></div>\r\n            <div id=\"selectedUnits\"></div>  \r\n            <div id=\"unitPortrait\"></div>            \r\n            <div class=\"action-panel\" id=\"actionPanel\"></div>\r\n        </div>  \r\n    </div>\r\n</div>\r\n\r\n<!-- Victory Screen -->\r\n<div id=\"victoryScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title victory-title\"> GLORIOUS VICTORY! </div>\r\n        <div class=\"stats-grid\" id=\"victoryStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"victory_NextRoundBtn\" class=\"btn\"> NEXT CONQUEST</button>\r\n            <button id=\"victory_RestartBtn\" class=\"btn btn-secondary\"> RETRY BATTLE</button>\r\n            <button id=\"victory_MainMenuBtn\" class=\"btn btn-secondary\"> RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Defeat Screen -->\r\n<div id=\"defeatScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title defeat-title\"> DEFEAT </div>\r\n        <div class=\"stats-grid\" id=\"defeatStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"defeat_RetryBtn\" class=\"btn\"> SEEK REVENGE</button>\r\n            <button id=\"defeat_ChangeModeBtn\" class=\"btn btn-secondary\"> CHANGE PATH</button>\r\n            <button id=\"defeat_MainMenuBtn\" class=\"btn btn-secondary\"> RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Pause Menu (Overlay) -->\r\n<div id=\"pauseMenu\" class=\"pause-overlay\">\r\n    <div class=\"pause-content\">\r\n        <h2> WAR COUNCIL RECESS</h2>\r\n        <button id=\"paused_ResumeBtn\" class=\"btn\"> RETURN TO BATTLE</button>\r\n        <button id=\"paused_RestartBtn\" class=\"btn btn-secondary\"> RESTART CAMPAIGN</button>\r\n        <button id=\"paused_MainMenuBtn\" class=\"btn btn-secondary\"> RETURN HOME</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Loading Screen -->\r\n<div id=\"loadingScreen\" class=\"screen\">\r\n    <div class=\"loading-content\">\r\n        <div class=\"loading-spinner\"></div>\r\n        <div class=\"loading-text\"> SUMMONING WARRIORS...</div>\r\n        <div class=\"loading-tip\">Tip: Position ranged units behind your frontline for maximum effectiveness</div>\r\n    </div>\r\n</div>"
      }
    },
    "libraries": {
      "codemirror.min.js": {
        "title": "CodeMirror.min.js",
        "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js",
        "className": "CodeMirror",
        "fileName": "codemirror.min.js"
      },
      "jszip.min.js": {
        "title": "jszip.min.js",
        "href": "/node_modules/jszip/dist/jszip.min.js",
        "fileName": "jszip.min.js"
      },
      "Rapier": {
        "fileName": "Rapier",
        "href": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
        "requireName": "RAPIER",
        "importName": "RAPIER",
        "isModule": true
      },
      "three_EffectComposer": {
        "title": "THREE.EffectComposer",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "EffectComposer",
        "importName": "EffectComposer",
        "fileName": "three_EffectComposer"
      },
      "three_OrbitControls": {
        "title": "THREE.OrbitControls",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "OrbitControls",
        "importName": "OrbitControls",
        "fileName": "three_OrbitControls"
      },
      "three_PointerLockControls": {
        "title": "THREE.PointerLockControls",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/PointerLockControls.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "PointerLockControls",
        "importName": "PointerLockControls",
        "fileName": "three_PointerLockControls"
      },
      "BaseSystem": {
        "script": "class BaseSystem {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.engine = game.app;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n    }\r\n    postAllInit() {\r\n\r\n    }\r\n    \r\n    update(){\r\n\r\n    }\r\n\r\n    render() {\r\n\r\n    }\r\n\r\n}\r\n\r\nif(typeof BaseSystem != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.BaseSystem = BaseSystem;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = BaseSystem;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = BaseSystem;\r\n        exports.BaseSystem = BaseSystem;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/BaseSystem.js",
        "fileName": "BaseSystem"
      },
      "Compiler": {
        "script": "class Compiler {\r\n    constructor(engine) {\r\n        this.engine = engine;\r\n        this.collections = null;\r\n        this.compiledBundle = null;\r\n        this.compiledEngine = null;\r\n        this.classRegistry = {\r\n            systems: new Map(),\r\n            managers: new Map(),\r\n            components: new Map(),\r\n            functions: new Map(),\r\n            renderers: new Map(),\r\n            classes: new Map()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Main compile method - orchestrates the entire compilation process\r\n     * @param {string} projectName - Name of the project to compile\r\n     * @param {Object} collections - Project collections\r\n     * @param {Object} engineFilePaths - Optional paths to engine files\r\n     * @returns {Object} - Compilation result with bundle code and metadata\r\n     */\r\n    async compile(projectName, collections, engineFilePaths) {\r\n        console.log(`Starting compilation for project: ${projectName}`);\r\n        \r\n        this.collections = collections;\r\n        if (!this.collections) {\r\n            throw new Error(\"Failed to load game configuration\");\r\n        }\r\n\r\n        const result = {\r\n            projectName: projectName,\r\n            timestamp: new Date().toISOString(),\r\n            sections: [],\r\n            code: '',\r\n            classRegistry: {},\r\n            dependencies: [],\r\n            engineCode: null\r\n        };\r\n        \r\n        // Build the bundle in order\r\n        await this.buildHeader(result);\r\n        await this.buildLibraries(result);\r\n        await this.buildGameClasses(result);\r\n        await this.buildClassRegistry(result);\r\n        await this.buildInitializer(result);\r\n\r\n        // Combine all sections\r\n        result.code = result.sections.join('\\n\\n');\r\n        \r\n        // Compile engine if paths provided\r\n        if (engineFilePaths) {\r\n            try {\r\n                result.engineCode = await this.compileEngine(engineFilePaths);\r\n                this.compiledEngine = result.engineCode;\r\n                console.log(' Engine bundle compiled');\r\n            } catch (error) {\r\n                console.warn('Could not compile engine bundle:', error.message);\r\n            }\r\n        }\r\n        \r\n        this.compiledBundle = result;\r\n        return result;\r\n    }\r\n\r\n    async createZipBundle(result) {\r\n        if (typeof JSZip === 'undefined') {\r\n            throw new Error('JSZip library not loaded. Include jszip.min.js before using this feature.');\r\n        }\r\n\r\n        const zip = new JSZip();\r\n        \r\n        // Add game bundle\r\n        zip.file(\"game.js\", result.code);\r\n        \r\n        // Add engine bundle if available\r\n        if (result.engineCode) {\r\n            zip.file('engine.js', result.engineCode);\r\n        }\r\n        \r\n        // Add local module files\r\n        if (result.localModuleFiles && result.localModuleFiles.length > 0) {\r\n            console.log(`Bundling ${result.localModuleFiles.length} local module files...`);\r\n            \r\n            const modulesFolder = zip.folder('modules');\r\n            \r\n            for (const moduleInfo of result.localModuleFiles) {\r\n                if (moduleInfo.libraryDef.isModule) {\r\n                    try {\r\n                        const response = await fetch(moduleInfo.path);\r\n                        const content = await response.text();\r\n                        const filename = moduleInfo.path.split('/').pop();\r\n                        \r\n                        modulesFolder.file(filename, content);\r\n                        console.log(` Bundled module: ${filename}`);\r\n                    } catch (error) {\r\n                        console.error(`Failed to bundle module ${moduleInfo.name}:`, error);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n \r\n         // Generate zip blob\r\n        const zipBlob = await zip.generateAsync({ type: 'blob' });\r\n        \r\n        console.log(' Zip bundle created');\r\n        return zipBlob;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Build the header section with metadata and utility functions\r\n     */\r\n    buildHeader(result) {\r\n        const header = `/**\r\n * Compiled Game Bundle\r\n * Project: ${result.projectName}\r\n * Generated: ${result.timestamp}\r\n */\r\n\r\nwindow.engine = {};\r\n\r\n// Global bundle namespace\r\nwindow.COMPILED_GAME = {\r\n    projectName: \"${result.projectName}\",\r\n    version: \"${result.timestamp}\",\r\n    classRegistry: {},\r\n    libraryClasses: {},\r\n    compiled: true,\r\n    initialized: false\r\n};\r\n\r\n// FLAG TO PREVENT DUPLICATE LIBRARY LOADING\r\nwindow.COMPILED_GAME_LOADED = true;`;\r\n        result.sections.push(header);\r\n    }\r\n\r\nasync buildLibraries(result) {\r\n    const projectConfig = this.collections.configs.game;\r\n    if (!projectConfig.libraries) {\r\n        console.warn(\"No libraries defined in game config\");\r\n        return;\r\n    }\r\n\r\n    const librariesSection = ['// ========== LIBRARIES =========='];\r\n    const externalLibraries = [];\r\n    const importMap = {};\r\n    const localModuleFiles = [];\r\n\r\n    for (const libraryName of projectConfig.libraries) {\r\n        const libraryDef = this.collections.libraries[libraryName];\r\n        if (!libraryDef) {\r\n            console.warn(`Library ${libraryName} not found in collections`);\r\n            continue;\r\n        }\r\n        \r\n        let libraryKey = libraryDef.requireName || libraryName.replace(/-/g, \"__\").replace(/\\./g, \"_\");\r\n        \r\n        // Handle local files with filePath\r\n        if (libraryDef.filePath && !libraryDef.href) {\r\n            const path = libraryDef.filePath;\r\n            \r\n            // Store local module info for bundling into zip\r\n            localModuleFiles.push({\r\n                name: libraryName,\r\n                path: path,\r\n                libraryDef: libraryDef,\r\n                libraryKey: libraryKey\r\n            });\r\n            \r\n            // For modules, create runtime loader that references bundled file\r\n            if (libraryDef.isModule) {\r\n                const bundledPath = `./modules/${path.split('/').pop()}`;\r\n                \r\n                if (libraryDef.importName) {\r\n                    importMap[libraryDef.importName] = bundledPath;\r\n                }\r\n                \r\n                librariesSection.push(`\\n// Library: ${libraryName} (local module - bundled)`);\r\n                librariesSection.push(`// Original path: ${path}`);\r\n                librariesSection.push(`// Bundled path: ${bundledPath}`);\r\n                \r\n                // Create a placeholder that will be filled at runtime\r\n                if (libraryDef.windowContext) {\r\n                    librariesSection.push(`\r\nif (!window[\"${libraryDef.windowContext}\"]) {\r\n    window[\"${libraryDef.windowContext}\"] = {};\r\n}\r\nwindow[\"${libraryDef.windowContext}\"][\"${libraryKey}\"] = null; // Will be loaded at runtime\r\nwindow.COMPILED_GAME.libraryClasses.${libraryKey} = null; // Placeholder\r\n                    `.trim());\r\n                } else {\r\n                    librariesSection.push(`window[\"${libraryKey}\"] = null; // Will be loaded at runtime`);\r\n                    librariesSection.push(`window.COMPILED_GAME.libraryClasses.${libraryKey} = null; // Placeholder`);\r\n                }\r\n                \r\n                externalLibraries.push({\r\n                    name: libraryName,\r\n                    url: bundledPath,\r\n                    isModule: true,\r\n                    requireName: libraryDef.requireName || libraryName,\r\n                    windowContext: libraryDef.windowContext,\r\n                    isLocalModule: true\r\n                });\r\n                \r\n                result.dependencies.push({\r\n                    name: libraryName,\r\n                    type: 'local-module',\r\n                    originalPath: path,\r\n                    bundledPath: bundledPath,\r\n                    isModule: true,\r\n                    requireName: libraryDef.requireName || libraryName\r\n                });\r\n            } else {\r\n                // For non-modules, fetch and include inline\r\n                try {\r\n                    const response = await fetch(path);\r\n                    let fileContent = await response.text();\r\n                    \r\n                    librariesSection.push(`\\n// Library: ${libraryName} (non-module - inline)`);\r\n                    librariesSection.push(`// Original path: ${path}`);\r\n                    \r\n                    // Extract class names from the file\r\n                    const classMatches = fileContent.match(/class\\s+(\\w+)/g);\r\n                    const className = libraryDef.requireName || libraryDef.fileName;\r\n                    \r\n                    // Execute the code and explicitly export classes to global scope\r\n                    librariesSection.push(`\r\n// Execute and register library code\r\n(function() {\r\n    try {\r\n        // Execute the library code\r\n        ${fileContent}\r\n        \r\n        // Explicitly register classes to window\r\n        var className = \"${className}\";\r\n        if (typeof eval(className) !== 'undefined') {\r\n            window[className] = eval(className);\r\n            console.log(\"set \", className);\r\n        }\r\n        \r\n    } catch (error) {\r\n        console.error(\"Error executing ${libraryName}:\", error);\r\n    }\r\n})();\r\n\r\n// Register library in COMPILED_GAME\r\n(function() {\r\n    var foundLibrary = null;\r\n    var libraryKey = \"${libraryKey}\";\r\n    var className = \"${className}\";\r\n    \r\n    // Check for classes defined in the file\r\n\r\n    if (window[className]) {\r\n        foundLibrary = window[className];\r\n        \r\n        // Register this class by its actual name\r\n        window.COMPILED_GAME.libraryClasses[className] = window[className];\r\n        window.engine[className] = window[className];\r\n    }\r\n    \r\n    \r\n    if (foundLibrary) {\r\n        window.COMPILED_GAME.libraryClasses.${libraryKey} = foundLibrary;\r\n        window.engine.${libraryKey} = foundLibrary;\r\n        ${libraryDef.windowContext ? `\r\n        if (!window[\"${libraryDef.windowContext}\"]) {\r\n            window[\"${libraryDef.windowContext}\"] = {};\r\n        }\r\n        window[\"${libraryDef.windowContext}\"][\"${libraryKey}\"] = foundLibrary;\r\n        ` : ''}\r\n    } else {\r\n        console.warn(\"Could not find ${libraryName} after loading\");\r\n    }\r\n})();\r\n                    `.trim());\r\n                    \r\n                    result.dependencies.push({\r\n                        name: libraryName,\r\n                        type: 'inline-file',\r\n                        path: path,\r\n                        key: libraryKey,\r\n                        classes: [className]\r\n                    });\r\n                } catch (error) {\r\n                    console.error(`Failed to load local file ${libraryName}:`, error);\r\n                }\r\n            }\r\n        }\r\n        // Handle external URLs with href - keep as runtime import\r\n        else if (libraryDef.href) {\r\n            const path = libraryDef.href;\r\n            \r\n            // Build import map entry if needed\r\n            if (libraryDef.importName && libraryDef.isModule) {\r\n                importMap[libraryDef.importName] = path;\r\n            }\r\n            \r\n            librariesSection.push(`\\n// Library: ${libraryName} (external module - loaded at runtime)`);\r\n            librariesSection.push(`// Loaded from: ${path}`);\r\n            \r\n            // Create a placeholder that will be filled at runtime\r\n            if (libraryDef.windowContext) {\r\n                librariesSection.push(`\r\nif (!window[\"${libraryDef.windowContext}\"]) {\r\n    window[\"${libraryDef.windowContext}\"] = {};\r\n}\r\nwindow[\"${libraryDef.windowContext}\"][\"${libraryKey}\"] = null; // Will be loaded at runtime\r\nwindow.COMPILED_GAME.libraryClasses.${libraryKey} = null; // Placeholder\r\n                `.trim());\r\n            } else {\r\n                librariesSection.push(`window[\"${libraryKey}\"] = null; // Will be loaded at runtime`);\r\n                librariesSection.push(`window.COMPILED_GAME.libraryClasses.${libraryKey} = null; // Placeholder`);\r\n            }\r\n            \r\n            externalLibraries.push({\r\n                name: libraryName,\r\n                url: path,\r\n                isModule: true,\r\n                requireName: libraryDef.requireName || libraryName,\r\n                windowContext: libraryDef.windowContext,\r\n                isLocalModule: false\r\n            });\r\n            \r\n            result.dependencies.push({\r\n                name: libraryName,\r\n                type: 'external-module',\r\n                url: path,\r\n                isModule: true,\r\n                requireName: libraryDef.requireName || libraryName\r\n            });\r\n        }\r\n        // Handle inline scripts (script property)\r\n        else if (libraryDef.script) {\r\n            librariesSection.push(`\\n// Library: ${libraryName} (inline script)`);\r\n            \r\n            // Evaluate the script and register it\r\n            librariesSection.push(`(function() {`);\r\n            librariesSection.push(`  var libraryClass = ${libraryDef.script};`);\r\n            librariesSection.push(`  window.COMPILED_GAME.libraryClasses.${libraryKey} = libraryClass;`);\r\n            librariesSection.push(`  window.engine.${libraryKey} = libraryClass;`);\r\n            \r\n            if (libraryDef.windowContext) {\r\n                librariesSection.push(`  if (!window[\"${libraryDef.windowContext}\"]) {`);\r\n                librariesSection.push(`    window[\"${libraryDef.windowContext}\"] = {};`);\r\n                librariesSection.push(`  }`);\r\n                librariesSection.push(`  window[\"${libraryDef.windowContext}\"][\"${libraryKey}\"] = libraryClass;`);\r\n            } else {\r\n                librariesSection.push(`  window[\"${libraryKey}\"] = libraryClass;`);\r\n            }\r\n            \r\n            librariesSection.push(`})();`);\r\n            \r\n            result.dependencies.push({\r\n                name: libraryName,\r\n                type: 'inline',\r\n                key: libraryKey\r\n            });\r\n        }\r\n    }\r\n\r\n    // Add import map if needed\r\n    if (Object.keys(importMap).length > 0) {\r\n        librariesSection.push(`\\n// ========== IMPORT MAP ==========`);\r\n        librariesSection.push(`window.COMPILED_GAME.importMap = ${JSON.stringify(importMap, null, 2)};`);\r\n        librariesSection.push(`\r\n// Create and inject import map\r\n(function() {\r\n    if (!document.querySelector('script[type=\"importmap\"]')) {\r\n        const importMapScript = document.createElement('script');\r\n        importMapScript.setAttribute('type', 'importmap');\r\n        importMapScript.textContent = JSON.stringify({ \r\n            imports: window.COMPILED_GAME.importMap \r\n        }, null, 2);\r\n        document.head.prepend(importMapScript);\r\n    }\r\n})();\r\n        `.trim());\r\n    }\r\n\r\n    // Add external library loader code that runs at bundle load time\r\n    if (externalLibraries.length > 0) {\r\n        librariesSection.push(`\\n// ========== EXTERNAL LIBRARY LOADER ==========`);\r\n        librariesSection.push(`window.COMPILED_GAME.externalLibraries = ${JSON.stringify(externalLibraries, null, 2)};`);\r\n        \r\n        librariesSection.push(`\r\n// Load external libraries at bundle initialization\r\n(async function() {\r\n    const loadPromises = [];\r\n    \r\n    for (const lib of window.COMPILED_GAME.externalLibraries) {\r\n        if (lib.isModule) {\r\n            // Import as ES module\r\n            const loadPromise = import(lib.url).then((module) => {\r\n                const libName = lib.requireName || lib.name;\r\n                const loadedModule = module[libName] || module.default || module;\r\n                \r\n                const libraryKey = libName.replace(/-/g, \"__\").replace(/\\\\./g, \"_\");\r\n                \r\n                if (lib.windowContext) {\r\n                    if (!window[lib.windowContext]) {\r\n                        window[lib.windowContext] = {};\r\n                    }\r\n                    window[lib.windowContext][libName] = loadedModule;\r\n                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;\r\n                    window.engine[libraryKey] = loadedModule;\r\n                } else {\r\n                    window[libName] = loadedModule;\r\n                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;\r\n                    window.engine[libraryKey] = loadedModule;\r\n                }\r\n                \r\n                console.log(\\`Loaded \\${lib.isLocalModule ? 'bundled' : 'external'} module: \\${lib.name}\\`);\r\n            }).catch(error => {\r\n                console.error(\\`Failed to load module \\${lib.name}:\\`, error);\r\n            });\r\n            \r\n            loadPromises.push(loadPromise);\r\n        }\r\n    }\r\n    \r\n    // Wait for all external modules to load\r\n    await Promise.all(loadPromises);\r\n    console.log('All libraries loaded');\r\n    \r\n    // Dispatch event when libraries are ready\r\n    window.dispatchEvent(new CustomEvent('compiled-libraries-ready'));\r\n})();\r\n        `.trim());\r\n    }\r\n\r\n    // Store local module files for zip bundling\r\n    result.localModuleFiles = localModuleFiles;\r\n    \r\n    result.sections.push(librariesSection.join('\\n'));\r\n}\r\n    /**\r\n     * Build game classes section - compile all systems, managers, components, etc.\r\n     */\r\n    async buildGameClasses(result) {\r\n        const classesSection = ['// ========== GAME CLASSES =========='];\r\n        \r\n        // Collect all unique classes from all scenes\r\n        const collectedClasses = {\r\n            systems: new Set(),\r\n            managers: new Set(),\r\n            components: new Set(),\r\n            functions: new Set(),\r\n            renderers: new Set(),\r\n            classes: new Set()\r\n        };\r\n\r\n        // Scan all scenes to find which classes are used\r\n        if (this.collections.scenes) {\r\n            for (const sceneName in this.collections.scenes) {\r\n                const scene = this.collections.scenes[sceneName];\r\n                this.collectClassesFromScene(scene, collectedClasses);\r\n            }\r\n        }\r\n\r\n        // Compile functions first (they might be used by other classes)\r\n        if (this.collections.functions) {\r\n            classesSection.push('\\n// ========== FUNCTIONS ==========');\r\n            for (const funcName in this.collections.functions) {\r\n                const funcDef = this.collections.functions[funcName];\r\n                if (funcDef.script) {\r\n                    classesSection.push(`\\n// Function: ${funcName}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.functions = window.COMPILED_GAME.classRegistry.functions || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.functions['${funcName}'] = ${funcDef.script};`);\r\n                    this.classRegistry.functions.set(funcName, true);\r\n                    collectedClasses.functions.add(funcName);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile systems\r\n        if (this.collections.systems && collectedClasses.systems.size > 0) {\r\n            classesSection.push('\\n// ========== SYSTEMS ==========');\r\n            for (const systemName of collectedClasses.systems) {\r\n                const systemDef = this.collections.systems[systemName];\r\n                if (systemDef && systemDef.script) {\r\n                    classesSection.push(`\\n// System: ${systemName}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.systems['${systemName}'] = ${systemDef.script};`);\r\n                    this.classRegistry.systems.set(systemName, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile managers\r\n        if (this.collections.managers && collectedClasses.managers.size > 0) {\r\n            classesSection.push('\\n// ========== MANAGERS ==========');\r\n            for (const managerName of collectedClasses.managers) {\r\n                const managerDef = this.collections.managers[managerName];\r\n                if (managerDef && managerDef.script) {\r\n                    classesSection.push(`\\n// Manager: ${managerName}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.managers['${managerName}'] = ${managerDef.script};`);\r\n                    this.classRegistry.managers.set(managerName, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile components\r\n        if (this.collections.components && collectedClasses.components.size > 0) {\r\n            classesSection.push('\\n// ========== COMPONENTS ==========');\r\n            for (const componentName of collectedClasses.components) {\r\n                const componentDef = this.collections.components[componentName];\r\n                if (componentDef && componentDef.script) {\r\n                    classesSection.push(`\\n// Component: ${componentName}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.components = window.COMPILED_GAME.classRegistry.components || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.components['${componentName}'] = ${componentDef.script};`);\r\n                    this.classRegistry.components.set(componentName, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile renderers\r\n        if (this.collections.renderers && collectedClasses.renderers.size > 0) {\r\n            classesSection.push('\\n// ========== RENDERERS ==========');\r\n            for (const rendererName of collectedClasses.renderers) {\r\n                const rendererDef = this.collections.renderers[rendererName];\r\n                if (rendererDef && rendererDef.script) {\r\n                    classesSection.push(`\\n// Renderer: ${rendererName}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.renderers = window.COMPILED_GAME.classRegistry.renderers || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.renderers['${rendererName}'] = ${rendererDef.script};`);\r\n                    this.classRegistry.renderers.set(rendererName, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Compile other classes\r\n        if (this.collections.classes && collectedClasses.classes.size > 0) {\r\n            classesSection.push('\\n// ========== OTHER CLASSES ==========');\r\n            for (const className of collectedClasses.classes) {\r\n                const classDef = this.collections.classes[className];\r\n                if (classDef && classDef.script) {\r\n                    classesSection.push(`\\n// Class: ${className}`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.classes = window.COMPILED_GAME.classRegistry.classes || {};`);\r\n                    classesSection.push(`window.COMPILED_GAME.classRegistry.classes['${className}'] = ${classDef.script};`);\r\n                    this.classRegistry.classes.set(className, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        result.sections.push(classesSection.join('\\n'));\r\n        result.classRegistry = {\r\n            systems: Array.from(collectedClasses.systems),\r\n            managers: Array.from(collectedClasses.managers),\r\n            components: Array.from(collectedClasses.components),\r\n            functions: Array.from(collectedClasses.functions),\r\n            renderers: Array.from(collectedClasses.renderers),\r\n            classes: Array.from(collectedClasses.classes)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Collect all classes referenced in a scene\r\n     */\r\n    collectClassesFromScene(scene, collectedClasses) {\r\n        if (!scene.sceneData || !Array.isArray(scene.sceneData)) return;\r\n\r\n        scene.sceneData.forEach(sceneEntity => {\r\n            // Collect systems\r\n            if (sceneEntity.systems) {\r\n                sceneEntity.systems.forEach(systemDef => {\r\n                    if (systemDef.type) {\r\n                        collectedClasses.systems.add(systemDef.type);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Collect managers\r\n            if (sceneEntity.managers) {\r\n                sceneEntity.managers.forEach(managerDef => {\r\n                    if (managerDef.type) {\r\n                        collectedClasses.managers.add(managerDef.type);\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Collect classes from ECS scenes\r\n            if (sceneEntity.classes) {\r\n                sceneEntity.classes.forEach(classDef => {\r\n                    const collectionName = classDef.collection;\r\n                    const baseClassId = classDef.baseClass;\r\n                    \r\n                    if (baseClassId && this.collections[collectionName]) {\r\n                        if (collectionName === 'components') {\r\n                            collectedClasses.components.add(baseClassId);\r\n                        } else if (collectionName === 'systems') {\r\n                            collectedClasses.systems.add(baseClassId);\r\n                        } else if (collectionName === 'managers') {\r\n                            collectedClasses.managers.add(baseClassId);\r\n                        } else if (collectionName === 'renderers') {\r\n                            collectedClasses.renderers.add(baseClassId);\r\n                        } else {\r\n                            collectedClasses.classes.add(baseClassId);\r\n                        }\r\n                    }\r\n\r\n                    // Also collect all classes from the collection\r\n                    if (this.collections[collectionName]) {\r\n                        for (const classId in this.collections[collectionName]) {\r\n                            if (collectionName === 'components') {\r\n                                collectedClasses.components.add(classId);\r\n                            } else if (collectionName === 'systems') {\r\n                                collectedClasses.systems.add(classId);\r\n                            } else if (collectionName === 'managers') {\r\n                                collectedClasses.managers.add(classId);\r\n                            } else if (collectionName === 'renderers') {\r\n                                collectedClasses.renderers.add(classId);\r\n                            } else {\r\n                                collectedClasses.classes.add(classId);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            // Collect components from non-ECS scenes\r\n            if (sceneEntity.components) {\r\n                sceneEntity.components.forEach(componentDef => {\r\n                    if (componentDef.type) {\r\n                        collectedClasses.components.add(componentDef.type);\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Build class registry accessor functions\r\n     */\r\n    buildClassRegistry(result) {\r\n        const registrySection = `// ========== CLASS REGISTRY ACCESSORS ==========\r\n\r\n/**\r\n * Get a compiled class by name and type\r\n * This replaces the ModuleManager.getCompiledScript method for compiled bundles\r\n */\r\nwindow.COMPILED_GAME.getClass = function(className, collectionType) {\r\n    const collection = window.COMPILED_GAME.classRegistry[collectionType];\r\n    if (!collection) {\r\n        console.error(\\`Collection \\${collectionType} not found in compiled bundle\\`);\r\n        return null;\r\n    }\r\n    \r\n    const ClassDef = collection[className];\r\n    if (!ClassDef) {\r\n        console.error(\\`Class \\${className} not found in collection \\${collectionType}\\`);\r\n        return null;\r\n    }\r\n    \r\n    return ClassDef;\r\n};\r\n\r\n/**\r\n * Check if a class exists in the compiled bundle\r\n */\r\nwindow.COMPILED_GAME.hasClass = function(className, collectionType) {\r\n    const collection = window.COMPILED_GAME.classRegistry[collectionType];\r\n    return collection && collection[className] !== undefined;\r\n};`;\r\n        result.sections.push(registrySection);\r\n    }\r\n\r\n    /**\r\n     * Build initialization code that integrates with existing engine\r\n     */\r\n    buildInitializer(result) {\r\n        const initSection = `// ========== INITIALIZATION ==========\r\n\r\n/**\r\n * Initialize the compiled bundle - patches ModuleManager to prevent duplicate loading\r\n */\r\nwindow.COMPILED_GAME.init = function(engine) {\r\n    if (window.COMPILED_GAME.initialized) {\r\n        console.log('Compiled game bundle already initialized');\r\n        return;\r\n    }\r\n    \r\n    console.log('Initializing compiled game bundle...');\r\n    \r\n    // Store original methods\r\n    const originalGetCompiledScript = ModuleManager.prototype.getCompiledScript;\r\n    const originalCompileScript = ModuleManager.prototype.compileScript;\r\n    const originalCompileFunction = ModuleManager.prototype.compileFunction;\r\n    \r\n    // Patch getCompiledScript\r\n    ModuleManager.prototype.getCompiledScript = function(typeName, collectionType) {\r\n        if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {\r\n            return window.COMPILED_GAME.getClass(typeName, collectionType);\r\n        }\r\n        return originalGetCompiledScript.call(this, typeName, collectionType);\r\n    };\r\n    \r\n    // Patch compileScript\r\n    ModuleManager.prototype.compileScript = function(scriptText, typeName) {\r\n        for (const collectionType in window.COMPILED_GAME.classRegistry) {\r\n            if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {\r\n                return window.COMPILED_GAME.getClass(typeName, collectionType);\r\n            }\r\n        }\r\n        return originalCompileScript.call(this, scriptText, typeName);\r\n    };\r\n    \r\n    // Patch compileFunction\r\n    ModuleManager.prototype.compileFunction = function(scriptText, typeName) {\r\n        if (window.COMPILED_GAME.hasClass(typeName, 'functions')) {\r\n            return window.COMPILED_GAME.getClass(typeName, 'functions');\r\n        }\r\n        return originalCompileFunction.call(this, scriptText, typeName);\r\n    };\r\n    \r\n    // Make library classes available\r\n    if (engine.moduleManager) {\r\n        engine.moduleManager.libraryClasses = {\r\n            ...engine.moduleManager.libraryClasses,\r\n            ...window.COMPILED_GAME.libraryClasses\r\n        };\r\n        window.GUTS = engine.moduleManager.libraryClasses;\r\n    }\r\n    \r\n    window.COMPILED_GAME.initialized = true;\r\n    console.log('Compiled game bundle initialized successfully');\r\n};\r\n\r\n// Wait for external libraries to load before allowing engine init\r\nwindow.COMPILED_GAME.ready = new Promise((resolve) => {\r\n    if (window.COMPILED_GAME.externalLibraries && window.COMPILED_GAME.externalLibraries.length > 0) {\r\n        window.addEventListener('compiled-libraries-ready', () => {\r\n            console.log(' Compiled game ready');\r\n            resolve();\r\n        });\r\n    } else {\r\n        // No external libraries, ready immediately\r\n        resolve();\r\n    }\r\n});`;\r\n        result.sections.push(initSection);\r\n    }\r\n\r\n    /**\r\n     * Compile the engine core files into a single bundle\r\n     */\r\n    async compileEngine(engineFilePaths) {\r\n        console.log('Compiling engine core files...');\r\n        \r\n        const engineSections = [];\r\n        \r\n        engineSections.push(`/**\r\n * Compiled Engine Bundle\r\n * Generated: ${new Date().toISOString()}\r\n * \r\n * Contains: ModuleManager.js, BaseEngine.js, Engine.js\r\n */\r\n`);\r\n\r\n        const defaultPaths = {\r\n            moduleManager: './../../engine/ModuleManager.js',\r\n            baseEngine: './../../engine/BaseEngine.js',\r\n            engine: './../../engine/Engine.js'\r\n        };\r\n        \r\n        const paths = engineFilePaths || defaultPaths;\r\n        \r\n        try {\r\n            engineSections.push('\\n// ========== MODULE MANAGER ==========');\r\n            const moduleManagerResponse = await fetch(paths.moduleManager);\r\n            const moduleManagerCode = await moduleManagerResponse.text();\r\n            engineSections.push(moduleManagerCode);\r\n            \r\n            engineSections.push('\\n// ========== BASE ENGINE ==========');\r\n            const baseEngineResponse = await fetch(paths.baseEngine);\r\n            const baseEngineCode = await baseEngineResponse.text();\r\n            engineSections.push(baseEngineCode);\r\n            \r\n            engineSections.push('\\n// ========== ENGINE ==========');\r\n            const engineResponse = await fetch(paths.engine);\r\n            const engineCode = await engineResponse.text();\r\n            engineSections.push(engineCode);\r\n            \r\n            console.log(' Engine files compiled successfully');\r\n        } catch (error) {\r\n            console.error('Error compiling engine files:', error);\r\n            throw error;\r\n        }\r\n        \r\n        return engineSections.join('\\n\\n');\r\n    }\r\n\r\n    /**\r\n     * Save the compiled bundle to a file\r\n     */\r\n    async saveBundle(outputPath) {\r\n        if (!this.compiledBundle) {\r\n            throw new Error(\"No compiled bundle available. Run compile() first.\");\r\n        }\r\n\r\n        const fs = require('fs').promises;\r\n        await fs.writeFile(outputPath, this.compiledBundle.code, 'utf8');\r\n        console.log(`Compiled bundle saved to: ${outputPath}`);\r\n        \r\n        const metadataPath = outputPath.replace('.js', '.meta.json');\r\n        const metadata = {\r\n            projectName: this.compiledBundle.projectName,\r\n            timestamp: this.compiledBundle.timestamp,\r\n            classRegistry: this.compiledBundle.classRegistry,\r\n            dependencies: this.compiledBundle.dependencies\r\n        };\r\n        await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2), 'utf8');\r\n        console.log(`Metadata saved to: ${metadataPath}`);\r\n        \r\n        return {\r\n            bundlePath: outputPath,\r\n            metadataPath: metadataPath\r\n        };\r\n    }\r\n\r\n}\r\n\r\nif (typeof Compiler != 'undefined') {\r\n    if (typeof window !== 'undefined') {\r\n        window.Compiler = Compiler;\r\n    }\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = Compiler;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/Compiler.js",
        "fileName": "Compiler"
      },
      "GameLoader": {
        "script": "class GameLoader {\r\n    constructor(game) {\r\n        this.game = game;\r\n    }    \r\n    async load(){\r\n        this.collections = this.game.getCollections();        \r\n       // this.collections.configs.game.canvasWidth = window.outerWidth;\r\n       // this.collections.configs.game.canvasHeight = window.outerHeight;\r\n        this.game.palette = this.collections.palettes && this.collections.configs.game.palette ? this.collections.palettes[this.collections.configs.game.palette] : null;\r\n        this.isometric = this.collections.configs.game.isIsometric;\r\n        this.game.state.tileMapData = this.collections.levels[this.game.state.level].tileMap;\r\n        this.game.state.isometric = this.collections.configs.game.isIsometric;\r\n        if (this.game.state.modifierSet && this.collections.modifierSets) {\r\n            this.game.state.stats = this.collections.modifierSets[this.game.state.modifierSet];\r\n            this.game.state.defaultStats = { ...this.game.state.stats };\r\n        }   \r\n\r\n        this.setupCanvas(this.collections.configs.game.canvasWidth, this.collections.configs.game.canvasHeight);\r\n        await this.loadAssets();\r\n        this.game.translator = new GUTS.CoordinateTranslator(this.collections.configs.game, this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.isometric);\r\n        \r\n    \r\n        this.game.spatialGrid = new GUTS.SpatialGrid(this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.collections.configs.game.gridSize);\r\n        const terrainImages = this.game.imageManager.getImages(\"levels\", this.game.state.level);\r\n\r\n        // Use ModuleManager's script environment\r\n        this.game.terrainTileMapper = new GUTS.TileMap(this, {}, {CanvasUtility: GUTS.CanvasUtility});\r\n\r\n        this.game.terrainTileMapper.init(this.game.terrainCanvasBuffer, this.collections.configs.game.gridSize, terrainImages, this.isometric);\r\n\r\n        this.game.sceneManager.load(this.collections.configs.game.initialScene);\r\n\r\n        this.game.init();\r\n\r\n    }\r\n\r\n    setupCanvas(canvasWidth, canvasHeight) {\r\n        \r\n        this.canvas = document.getElementById(\"gameCanvas\");\r\n        if(this.game.getCollections().configs.game.is3D){\r\n            this.finalCtx = this.canvas.getContext(\"webgl2\");\r\n        } else {\r\n            this.finalCtx = this.canvas.getContext(\"2d\");\r\n        }\r\n        this.canvasBuffer = document.createElement(\"canvas\");\r\n        this.ctx = this.canvasBuffer.getContext(\"2d\");\r\n        this.canvasBuffer.setAttribute('width', canvasWidth);\r\n        this.canvasBuffer.setAttribute('height', canvasHeight);\r\n        this.canvas.setAttribute('width', canvasWidth);\r\n        this.canvas.setAttribute('height', canvasHeight);  \r\n        \r\n        this.terrainCanvasBuffer = document.createElement('canvas');\r\n        this.terrainCanvasBuffer.width = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap[0].length;\r\n        this.terrainCanvasBuffer.height = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap.length;\r\n\r\n        this.game.canvas = this.canvas;\r\n        this.game.finalCtx = this.finalCtx;\r\n        this.game.canvasBuffer = this.canvasBuffer;\r\n        this.game.ctx = this.ctx;\r\n        this.game.terrainCanvasBuffer = this.terrainCanvasBuffer;\r\n    }\r\n    async loadAssets() {\r\n         // Load all images\r\n        for(let objectType in this.collections) {\r\n            await this.game.imageManager.loadImages(objectType, this.collections[objectType]);\r\n        }  \r\n        this.game.modelManager = new GUTS.ModelManager(this.game.app, {}, { ShapeFactory: GUTS.ShapeFactory, palette: this.game.palette, textures: this.game.getCollections().textures});\r\n        \r\n        for(let objectType in this.collections) {\r\n            await this.game.modelManager.loadModels(objectType, this.collections[objectType]);\r\n        }  \r\n \r\n    }\r\n}",
        "filePath": "/global/libraries/js/GameLoader.js",
        "fileName": "GameLoader"
      },
      "ECGame": {
        "script": "class ECGame {\n    constructor(app){\n        this.app = app;     \n        this.imageManager = new GUTS.ImageManager(app, \n            { \n                imageSize: this.getCollections().configs.game.imageSize, \n                palette: this.getCollections().configs.game.palette, \n                textures: this.getCollections().textures\n            }\n        );         \n        this.state = new GUTS.GameState(this.getCollections());  \n        this.sceneManager = new GUTS.SceneManager(this); \n        this.moduleManager = app.moduleManager;\n                \n        this.entityId = 0;\n        this.entitiesToAdd = [];\n        this.entities = new Map();\n    }\n    init() {       \n        this.imageManager.dispose();\n    }\n\n    getCollections() {\n        return this.app.getCollections();\n    }\n\n    update() {\n  \n        if (!this.state.isPaused) {\n            this.currentTime = Date.now();\n\n            // Only update if a reasonable amount of time has passed\n            const timeSinceLastUpdate = this.currentTime - this.lastTime;\n\n            // Skip update if more than 1 second has passed (tab was inactive)\n            if (timeSinceLastUpdate > 1000) {\n                this.lastTime = this.currentTime; // Reset timer without updating\n                return;\n            }\n\n            this.deltaTime = Math.min(1/30, timeSinceLastUpdate / 1000); // Cap at 1/30th of a second        \n            this.lastTime = this.currentTime;\n\n            let entitiesToRemove = [];\n            for (const e of this.entities.values()) {\n                e.update();\n                if(!e.destroyed){\n                    if(!this.isServer){\n                        e.draw();\n                    }\n                    e.postUpdate();  \n                } else {\n                    entitiesToRemove.push(e);\n                }     \n            }\n\n            for(let i = 0; i < entitiesToRemove.length; i++){\n                this.removeEntity(entitiesToRemove[i]);\n            }\n\n            this.postUpdate();\n        }     \n    }\n\n    postUpdate() {\n    \n        this.entitiesToAdd.forEach((entity) => this.addEntity(entity));        \n        this.entitiesToAdd = [];\n\n        if (this.state.gameOver || this.state.victory || this.state.isLevelingUp) return;\n                \n        // Game over check\n        if (this.state.bloodCoreHP <= 0 && !this.state.gameOver) {\n            this.gameOver();\n        }\n        \n    }\n\n    gameOver() {\n        this.state.gameOver = true;\n        this.state.isPaused = true;\n        gameOverWave.textContent = this.state.round + 1;\n        gameOverMenu.style.display = 'block';\n        overlay.style.display = 'block';\n    }\n\n    gameVictory() {\n        this.state.victory = true;\n        this.state.isPaused = true;\n        victoryMenu.style.display = 'block';\n        overlay.style.display = 'block';\n    }\n\n    spawn(type, params) {\n        let entity = this.createEntityFromCollections(type, params);\n        if(!entity.excluded){\n            this.entitiesToAdd.push(entity);        \n        }\n        return entity;\n    }\n    \n    createEntityFromCollections(type, params) {\n\n        const entity = this.createEntity(type);\n        const def = this.getCollections().entities[type];\n\n        entity.transform = entity.addComponent(\"transform\");\n        if(def.id){\n            entity.id = def.id;\n        }\n        if (def.components) {\n            def.components.forEach((componentType) => {\n                const componentDef = this.getCollections().components[componentType];\n                if (componentDef.script) {\n                    const ScriptComponent = this.moduleManager.getCompiledScript(componentType, 'components');\n                    if (ScriptComponent) {\n                        entity.addComponent(componentType);                  \n                    }\n                }\n            });\n        }\n        if (def.renderers) {\n            def.renderers.forEach((rendererType) => {\n                const componentDef = this.getCollections().renderers[rendererType];\n                if (componentDef.script) {\n                    const ScriptComponent = this.moduleManager.getCompiledScript(rendererType, 'renderers');\n                    if (ScriptComponent) {\n                        entity.addRenderer(rendererType);                  \n                    }\n                }\n            });\n        }\n        //this allows components to reference other components on the entity at init, since they will now all exist before init.\n        entity.init(params);\n        return entity;\n    }\n\n    createEntity(type) {\n        const entity = new GUTS.Entity(this, type);\n        entity.id = ++this.entityId;\n        return entity;\n    }\n\n    getEntityById(id){\n        return this.entities.get(id);\n    }\n\n    addEntity(entity) {\n        this.entities.set(entity.id, entity);\n    }\n    removeEntity(entity) {        \n        this.entities.delete(entity.id);        \n    }\n}",
        "filePath": "/global/libraries/js/ECGame.js",
        "fileName": "ECGame"
      },
      "GameRoom": {
        "script": "class GameRoom {\r\n    constructor(engine, roomId, gameInstance, maxPlayers) {\r\n        this.id = roomId;\r\n        this.engine = engine;\r\n        this.game = gameInstance;\r\n        this.serverNetworkManager = this.engine.serverNetworkManager;\r\n        this.game.room = this;\r\n        this.maxPlayers = maxPlayers;\r\n        this.players = new Map();\r\n        this.isActive = false;\r\n        this.lastStateSnapshot = null;\r\n        this.stateHistory = []; // For lag compensation\r\n        this.inputBuffer = new Map(); // Player inputs awaiting processing\r\n    }\r\n\r\n    addPlayer(playerId, playerData) {\r\n        if (this.players.size >= this.maxPlayers) {\r\n            return { success: false, reason: 'Room full' };\r\n        }\r\n\r\n        this.players.set(playerId, {\r\n            id: playerId,\r\n            ...playerData,\r\n            lastInputSequence: 0,\r\n            inputBuffer: [],\r\n            latency: 0\r\n        });\r\n\r\n\r\n        if (this.players.size === this.maxPlayers) {\r\n            this.startGame();\r\n        }\r\n\r\n        return { success: true };\r\n    }\r\n\r\n    removePlayer(playerId) {\r\n        if (this.players.has(playerId)) {\r\n            // Remove player entity from game\r\n            this.players.delete(playerId);\r\n            \r\n            if (this.players.size === 0) {\r\n                this.isActive = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getPlayer(playerId){\r\n        return this.players.get(playerId);\r\n    }\r\n\r\n\r\n\r\n    startGame() {\r\n        this.isActive = true;\r\n        \r\n        // Initialize game scene\r\n        this.game.sceneManager.load(this.game.getCollections().configs.server.initialScene);\r\n\r\n    }\r\n\r\n    processPlayerInput(playerId, inputData) {\r\n        const player = this.players.get(playerId);\r\n        if (!player) return;\r\n\r\n        // Validate input sequence to prevent replay attacks\r\n        if (inputData.sequence <= player.lastInputSequence) {\r\n            return;\r\n        }\r\n\r\n        player.lastInputSequence = inputData.sequence;\r\n        \r\n        // Queue input for processing\r\n        if (!this.inputBuffer.has(playerId)) {\r\n            this.inputBuffer.set(playerId, []);\r\n        }\r\n        \r\n        this.inputBuffer.get(playerId).push({\r\n            ...inputData,\r\n            timestamp: Date.now()\r\n        });\r\n    }\r\n\r\n    update(deltaTime) {\r\n        if (!this.isActive) return;\r\n\r\n        // Process all queued inputs\r\n        this.processQueuedInputs();\r\n        \r\n        // Update game state\r\n        this.game.update(deltaTime);\r\n        \r\n        // Store state snapshot for lag compensation\r\n        this.storeStateSnapshot();\r\n        \r\n        // Prepare network update\r\n        this.prepareNetworkUpdate();\r\n    }\r\n\r\n    processQueuedInputs() {\r\n        for (const [playerId, inputs] of this.inputBuffer) {\r\n            const player = this.players.get(playerId);\r\n            if (!player || !player.entityId) continue;\r\n\r\n            for (const input of inputs) {\r\n                this.applyPlayerInput(player.entityId, input);\r\n            }\r\n            \r\n            // Clear processed inputs\r\n            inputs.length = 0;\r\n        }\r\n    }\r\n\r\n    applyPlayerInput(entityId, inputData) {\r\n        const transform = this.game.getComponent(entityId, 'Transform');\r\n        if (!transform) return;\r\n\r\n        const speed = 200; // pixels per second\r\n        const deltaTime = 1/20; // Server tick rate\r\n\r\n        // Apply movement\r\n        if (inputData.keys.left) transform.x -= speed * deltaTime;\r\n        if (inputData.keys.right) transform.x += speed * deltaTime;\r\n        if (inputData.keys.up) transform.y -= speed * deltaTime;\r\n        if (inputData.keys.down) transform.y += speed * deltaTime;\r\n\r\n        // Validate movement (bounds checking, collision, etc.)\r\n        this.validateMovement(entityId, transform);\r\n    }\r\n\r\n    validateMovement(entityId, transform) {\r\n        // Implement game-specific validation\r\n        // Bounds checking, collision detection, etc.\r\n        const bounds = this.game.getCollections().configs.game.worldBounds;\r\n        \r\n        transform.x = Math.max(0, Math.min(bounds.width, transform.x));\r\n        transform.y = Math.max(0, Math.min(bounds.height, transform.y));\r\n    }\r\n\r\n    storeStateSnapshot() {\r\n        const snapshot = {\r\n            timestamp: Date.now(),\r\n            entities: new Map()\r\n        };\r\n\r\n        // Store relevant entity states\r\n        for (const [playerId, player] of this.players) {\r\n            if (player.entityId) {\r\n                const transform = this.game.getComponent(player.entityId, 'Transform');\r\n                const playerComp = this.game.getComponent(player.entityId, 'Player');\r\n                \r\n                snapshot.entities.set(player.entityId, {\r\n                    transform: { ...transform },\r\n                    player: { ...playerComp }\r\n                });\r\n            }\r\n        }\r\n\r\n        this.stateHistory.push(snapshot);\r\n        \r\n        // Keep only last 1 second of history (20 snapshots at 20 TPS)\r\n        if (this.stateHistory.length > 20) {\r\n            this.stateHistory.shift();\r\n        }\r\n    }\r\n\r\n    prepareNetworkUpdate() {\r\n        const gameState = {\r\n            type: 'GAME_STATE',\r\n            timestamp: Date.now(),\r\n            entities: {}\r\n        };\r\n\r\n        // Include all network-synced entities\r\n        for (const [playerId, player] of this.players) {\r\n            if (player.entityId) {\r\n                const transform = this.game.getComponent(player.entityId, 'Transform');\r\n                const playerComp = this.game.getComponent(player.entityId, 'Player');\r\n                \r\n                gameState.entities[player.entityId] = {\r\n                    playerId: playerId,\r\n                    transform,\r\n                    player: playerComp\r\n                };\r\n            }\r\n        }\r\n\r\n        this.lastStateSnapshot = gameState;\r\n    }\r\n\r\n    broadcastToPlayers(type, data) {\r\n            console.log('broadcasting to all players', message);\r\n        this.serverNetworkManager.broadcastToRoom(this.id, type, data);\r\n    }\r\n}\r\n\r\nif(typeof GameRoom != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.GameRoom = GameRoom;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = GameRoom;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = GameRoom;\r\n        exports.GameRoom = GameRoom;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GameRoom.js",
        "fileName": "GameRoom"
      },
      "InputManager": {
        "script": "class InputManager {\r\n    constructor() {\r\n        this.keys = {};\r\n        this.onInput = null;\r\n        this.lastInputSent = 0;\r\n        this.inputRate = 1000 / 20; // Send input 20 times per second\r\n\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    setupEventListeners() {\r\n        window.addEventListener('keydown', (e) => {\r\n            this.keys[e.code] = true;\r\n        });\r\n\r\n        window.addEventListener('keyup', (e) => {\r\n            this.keys[e.code] = false;\r\n        });\r\n    }\r\n\r\n    update() {\r\n        const now = Date.now();\r\n        \r\n        if (now - this.lastInputSent >= this.inputRate) {\r\n            const inputData = {\r\n                keys: {\r\n                    left: this.keys['ArrowLeft'] || this.keys['KeyA'],\r\n                    right: this.keys['ArrowRight'] || this.keys['KeyD'],\r\n                    up: this.keys['ArrowUp'] || this.keys['KeyW'],\r\n                    down: this.keys['ArrowDown'] || this.keys['KeyS']\r\n                }\r\n            };\r\n\r\n            // Only send if there's actual input\r\n            if (Object.values(inputData.keys).some(pressed => pressed)) {\r\n                if (this.onInput) {\r\n                    this.onInput(inputData);\r\n                }\r\n            }\r\n\r\n            this.lastInputSent = now;\r\n        }\r\n    }\r\n}",
        "filePath": "/global/libraries/js/InputManager.js",
        "fileName": "InputManager"
      },
      "PerformanceProfiler": {
        "script": "class PerformanceProfiler {\r\n    constructor(game, sampleSize = 60) {\r\n        this.game = game;\r\n        this.game.profiler = this;\r\n        this.sampleSize = sampleSize;\r\n        this.timings = new Map();\r\n        this.frameTimes = [];\r\n        this.enabled = true;\r\n        this.startTime = performance.now();\r\n    }\r\n\r\n    startMeasure(label) {\r\n        if (!this.enabled) return;\r\n        if (!this.timings.has(label)) {\r\n            this.timings.set(label, {\r\n                samples: [],\r\n                totalTime: 0,\r\n                calls: 0,\r\n                avgTime: 0,\r\n                maxTime: 0,\r\n                minTime: Infinity\r\n            });\r\n        }\r\n        return performance.now();\r\n    }\r\n\r\n    endMeasure(label, startTime) {\r\n        if (!this.enabled) return;\r\n        const duration = performance.now() - startTime;\r\n        const stats = this.timings.get(label);\r\n        \r\n        if (stats) {\r\n            stats.samples.push(duration);\r\n            if (stats.samples.length > this.sampleSize) {\r\n                stats.samples.shift();\r\n            }\r\n            \r\n            stats.totalTime += duration;\r\n            stats.calls++;\r\n            stats.maxTime = Math.max(stats.maxTime, duration);\r\n            stats.minTime = Math.min(stats.minTime, duration);\r\n            stats.avgTime = stats.samples.reduce((a, b) => a + b, 0) / stats.samples.length;\r\n        }\r\n    }\r\n\r\n    measure(label, fn) {\r\n        const start = this.startMeasure(label);\r\n        try {\r\n            return fn();\r\n        } finally {\r\n            this.endMeasure(label, start);\r\n        }\r\n    }\r\n\r\n    async measureAsync(label, fn) {\r\n        const start = this.startMeasure(label);\r\n        try {\r\n            return await fn();\r\n        } finally {\r\n            this.endMeasure(label, start);\r\n        }\r\n    }\r\n\r\n    getReport(sortBy = 'avgTime') {\r\n        const report = [];\r\n        for (const [label, stats] of this.timings) {\r\n            report.push({\r\n                label,\r\n                avgTime: stats.avgTime,\r\n                maxTime: stats.maxTime,\r\n                minTime: stats.minTime,\r\n                totalTime: stats.totalTime,\r\n                calls: stats.calls,\r\n                percentOfFrame: 0\r\n            });\r\n        }\r\n\r\n        const totalTime = report.reduce((sum, stat) => sum + stat.avgTime, 0);\r\n        report.forEach(stat => {\r\n            stat.percentOfFrame = totalTime > 0 ? (stat.avgTime / totalTime * 100) : 0;\r\n        });\r\n\r\n        report.sort((a, b) => b[sortBy] - a[sortBy]);\r\n        return report;\r\n    }\r\n\r\n    printReport() {\r\n        const report = this.getReport();\r\n        console.log('\\n=== Performance Report ===');\r\n        console.log('Label'.padEnd(30), 'Avg(ms)', 'Max(ms)', 'Min(ms)', '% Frame', 'Calls');\r\n        console.log('-'.repeat(80));\r\n        \r\n        report.forEach(stat => {\r\n            console.log(\r\n                stat.label.padEnd(30),\r\n                stat.avgTime.toFixed(3).padStart(7),\r\n                stat.maxTime.toFixed(3).padStart(7),\r\n                stat.minTime.toFixed(3).padStart(7),\r\n                stat.percentOfFrame.toFixed(1).padStart(6) + '%',\r\n                stat.calls.toString().padStart(6)\r\n            );\r\n        });\r\n        \r\n        const totalAvg = report.reduce((sum, stat) => sum + stat.avgTime, 0);\r\n        console.log('-'.repeat(80));\r\n        console.log('Total'.padEnd(30), totalAvg.toFixed(3).padStart(7));\r\n        console.log('\\n');\r\n    }\r\n\r\n    reset() {\r\n        this.timings.clear();\r\n        this.frameTimes = [];\r\n    }\r\n\r\n    toggle() {\r\n        this.enabled = !this.enabled;\r\n        return this.enabled;\r\n    }\r\n\r\n    \r\n    setupCommands() {\r\n        window.debug = {\r\n            profileSystem: (systemName) => {\r\n                const system = this.game.systems.find(s => \r\n                    s.constructor.name.toLowerCase().includes(systemName.toLowerCase())\r\n                );\r\n                if (system) {\r\n                    console.log(`Profiling ${system.constructor.name}...`);\r\n                    this.game.profiler.reset();\r\n                    setTimeout(() => {\r\n                        this.game.profiler.printReport();\r\n                    }, 3000);\r\n                } else {\r\n                    console.log(`System \"${systemName}\" not found`);\r\n                }\r\n            },\r\n            \r\n            listSystems: () => {\r\n                console.log('Active Systems:');\r\n                this.game.systems.forEach((system, i) => {\r\n                    console.log(`${i + 1}. ${system.constructor.name}`);\r\n                });\r\n            },\r\n            \r\n            compareRuns: (duration = 5000) => {\r\n                console.log('Starting comparison run...');\r\n                this.game.profiler.reset();\r\n                \r\n                setTimeout(() => {\r\n                    const baseline = this.game.getPerformanceReport();\r\n                    console.log('Baseline recorded. Make changes and wait...');\r\n                    \r\n                    setTimeout(() => {\r\n                        const current = this.game.getPerformanceReport();\r\n                        console.log('\\n=== Performance Comparison ===');\r\n                        console.log('System'.padEnd(30), 'Before', 'After', 'Diff');\r\n                        console.log('-'.repeat(70));\r\n                        \r\n                        baseline.forEach(before => {\r\n                            const after = current.find(s => s.label === before.label);\r\n                            if (after) {\r\n                                const diff = after.avgTime - before.avgTime;\r\n                                const diffStr = (diff > 0 ? '+' : '') + diff.toFixed(3);\r\n                                const color = diff > 0 ? '\\x1b[31m' : '\\x1b[32m';\r\n                                console.log(\r\n                                    before.label.padEnd(30),\r\n                                    before.avgTime.toFixed(3).padStart(7),\r\n                                    after.avgTime.toFixed(3).padStart(7),\r\n                                    `${color}${diffStr}\\x1b[0m`.padStart(10)\r\n                                );\r\n                            }\r\n                        });\r\n                    }, duration);\r\n                }, duration);\r\n            }\r\n        };\r\n        \r\n        console.log('Debug commands loaded. Available: debug.profileSystem(), debug.listSystems(), debug.compareRuns()');\r\n    }\r\n}\r\nif(typeof PerformanceProfiler != 'undefined'){\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = PerformanceProfiler;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/PerformanceProfiler.js",
        "fileName": "PerformanceProfiler"
      },
      "SceneEditor": {
        "script": "class SceneEditor {\r\n    constructor(gameEditor, config, {ShapeFactory, SE_GizmoManager, ModelManager, GameState, ImageManager}) {\r\n        this.gameEditor = gameEditor;\r\n        this.config = config;\r\n        this.scene = null;\r\n        this.camera = null;\r\n        this.renderer = null;\r\n        this.controls = null;\r\n        this.collections = this.gameEditor.getCollections();\r\n        this.clock = new window.THREE.Clock();\r\n        this.gameEditor.state = new GameState(this.gameEditor.getCollections());  \r\n        this.canvas = document.getElementById('scene-editor-canvas');\r\n        this.terrainCanvasBuffer = document.createElement('canvas');\r\n        let palette = this.gameEditor.getPalette();\r\n        this.gameEditor.imageManager = new GUTS.ImageManager(this.gameEditor, { imageSize: this.config.imageSize, palette: palette}, {ShapeFactory: GUTS.ShapeFactory});\r\n\r\n        this.state = {\r\n            sceneData: [],\r\n            selectedEntityIndex: -1,\r\n            selectedEntity: null,\r\n            selectedEntityObject: null\r\n        };\r\n        this.elements = {\r\n            hierarchy: document.getElementById('scene-hierarchy'),\r\n            inspector: document.getElementById('scene-inspector'),\r\n            noSelection: document.getElementById('scene-noSelection'),\r\n            entityInspector: document.getElementById('scene-entityInspector'),\r\n            components: document.getElementById('scene-components'),\r\n            addPrefabSelect: document.getElementById('scene-addPrefabSelect'),\r\n            addPrefabBtn: document.getElementById('scene-addPrefabBtn'),\r\n            removePrefabBtn: document.getElementById('scene-removePrefabBtn'),\r\n        } \r\n        this.componentsToUpdate = [];\r\n        this.gameEditor.palette = this.gameEditor.getPalette();\r\n        this.shapeFactory = new ShapeFactory(this.gameEditor.getResourcesPath(), this.gameEditor.palette, this.gameEditor.getCollections().textures, null);\r\n        if(location.hostname.indexOf('github') >= 0) {\r\n            this.shapeFactory.setURLRoot(\"/GUTS/\");\r\n        }   \r\n        this.gameEditor.modelManager = new ModelManager(this.gameEditor, {}, {ShapeFactory, palette: this.gameEditor.palette, textures: this.gameEditor.getCollections().textures});    \r\n     \r\n        this.initThreeJS(this.canvas);\r\n        this.gizmoManager = new SE_GizmoManager();\r\n        this.gizmoManager.init(this);\r\n        this.initEventListeners();\r\n        this.animate();\r\n    }\r\n\r\n    initEventListeners() {\r\n        document.body.addEventListener('renderSceneObject', this.handleRenderSceneObject.bind(this));\r\n        document.body.addEventListener('resizedEditor', () => { \r\n            this.canvas.width = this.gameEditor.getCollections().configs.game.canvasWidth;\r\n            this.canvas.height = this.gameEditor.getCollections().configs.game.canvasHeight;\r\n            this.canvas.setAttribute('style','');\r\n            this.handleResize();  \r\n            this.refreshScene(false); \r\n        });\r\n        this.elements.addPrefabBtn.addEventListener('click', (e) => {\r\n            let parts = this.elements.addPrefabSelect.value.split(\".\");\r\n            const objType = parts[0];\r\n            const spawnType = parts[1];\r\n            const prefabData = this.gameEditor.getCollections()[objType][spawnType];\r\n            if(prefabData.entity){\r\n                this.createEntity(prefabData.entity, { \"objectType\": objType, \"spawnType\": spawnType, ...prefabData });\r\n            }\r\n        });\r\n        this.elements.removePrefabBtn.addEventListener('click', () => {\r\n            if (this.state.selectedEntity) {\r\n                // Remove from Three.js scene\r\n                const entityObject = this.state.selectedEntityObject || this.findEntityObject(this.state.selectedEntity);\r\n                if (entityObject) {\r\n                    this.shapeFactory.disposeObject(entityObject);\r\n                    this.rootGroup.remove(entityObject);\r\n                }\r\n    \r\n                // Remove from entities array\r\n                const index = this.state.sceneData.indexOf(this.state.selectedEntity);\r\n                if (index > -1) {\r\n                    this.state.sceneData.splice(index, 1);\r\n                }\r\n    \r\n                // Clear selection\r\n                this.state.selectedEntity = null;\r\n                this.state.selectedEntityObject = null;\r\n                this.gizmoManager.detach();\r\n    \r\n                // Update UI\r\n                this.handleSave(false);\r\n                this.renderHierarchy();\r\n                this.renderInspector();\r\n            }\r\n        });\r\n        const collectionDefs = this.gameEditor.getCollectionDefs();\r\n        let prefabTypes = [];\r\n        for(let collectionDef of collectionDefs) {\r\n            if(collectionDef.category.toLowerCase() == \"prefabs\") {\r\n                prefabTypes.push(collectionDef.id);\r\n            }\r\n        }\r\n        const collections = this.gameEditor.getCollections();\r\n        for(let prefabTypeName of prefabTypes){\r\n            let objectTypes = collections[prefabTypeName];\r\n            for(let spawnTypeName in objectTypes){\r\n                let spawnData = objectTypes[spawnTypeName];\r\n                if(spawnData.entity){\r\n                    let option = document.createElement('option');\r\n                    option.innerText = spawnData.title;\r\n                    option.value = `${prefabTypeName}.${spawnTypeName}`;\r\n                    this.elements.addPrefabSelect.append(option);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Add click event listeners\r\n        document.getElementById('scene-translate-tool').addEventListener('click', () => {\r\n            this.setGizmoMode('translate');\r\n            this.updateGizmoToolbarUI('scene-translate-tool');\r\n        });\r\n        \r\n        document.getElementById('scene-rotate-tool').addEventListener('click', () => {\r\n            this.setGizmoMode('rotate');\r\n            this.updateGizmoToolbarUI('scene-rotate-tool');\r\n        });\r\n        \r\n        document.getElementById('scene-scale-tool').addEventListener('click', () => {\r\n            this.setGizmoMode('scale');\r\n            this.updateGizmoToolbarUI('scene-scale-tool');\r\n        });\r\n    }\r\n\r\n    initThreeJS(canvas) {\r\n        // Scene setup\r\n        this.scene = new window.THREE.Scene();\r\n        this.gameEditor.scene = this.scene;\r\n        this.rootGroup = new window.THREE.Group(); // Main container for all shapes\r\n        this.rootGroup.name = \"rootGroup\";\r\n        this.scene.add(this.rootGroup);\r\n        // Camera setup\r\n        this.camera = new window.THREE.PerspectiveCamera(\r\n            75, \r\n            canvas.clientWidth / canvas.clientHeight, \r\n            0.1, \r\n            100000\r\n        );\r\n        this.gameEditor.camera = this.camera;\r\n        this.camera.position.set(100, 100, 100);\r\n        this.camera.lookAt(0, 0, 0);\r\n\r\n        // Renderer setup\r\n        this.renderer = new window.THREE.WebGLRenderer({ \r\n            canvas: canvas, \r\n            antialias: false, \r\n            alpha: true \r\n        });\r\n        this.gameEditor.renderer = this.renderer;\r\n        this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n\r\n        // Add helpers\r\n        const gridHelper = new window.THREE.GridHelper(1000, 100);\r\n        this.scene.add(gridHelper);\r\n\r\n        const axesHelper = new window.THREE.AxesHelper(10);\r\n        this.scene.add(axesHelper);\r\n\r\n        // Orbit controls\r\n        this.controls = new window.THREE_.OrbitControls(this.camera, this.renderer.domElement);\r\n        this.controls.enableDamping = true;\r\n        this.controls.dampingFactor = 0.25;\r\n\r\n        // Resize handling\r\n        window.addEventListener('resize', this.handleResize.bind(this));\r\n    }\r\n    \r\n    async handleRenderSceneObject(event) {\r\n        this.canvas.width = this.gameEditor.getCollections().configs.game.canvasWidth;\r\n        this.canvas.height = this.gameEditor.getCollections().configs.game.canvasHeight;\r\n        this.canvas.setAttribute('style','');   \r\n        await this.loadAssets();    \r\n        this.clearScene();\r\n        this.renderSceneData(event.detail.data);\r\n        this.handleResize();\r\n        this.clock = new window.THREE.Clock();\r\n        this.clock.start(); \r\n        requestAnimationFrame(() => {\r\n            this.state.selectedEntityIndex = -1;\r\n        });\r\n    }\r\n\r\n    async loadAssets() {\r\n        if(!this.gameEditor.modelManager.assetsLoaded){\r\n            let collections = this.gameEditor.getCollections();\r\n            for(let objectType in collections) {            \r\n                await this.gameEditor.modelManager.loadModels(objectType, collections[objectType]);\r\n            }  \r\n        } \r\n       \r\n        this.gameEditor.terrainTileMapper = this.gameEditor.editorModuleInstances.TileMap; \r\n       \r\n        await this.gameEditor.imageManager.loadImages(\"levels\", { level: this.gameEditor.getCollections().levels[\"level1\"] }, false, false);\r\n        const terrainImages = this.gameEditor.imageManager.getImages(\"levels\", \"level\");\r\n        this.gameEditor.terrainTileMapper.init(this.terrainCanvasBuffer, this.gameEditor.getCollections().configs.game.gridSize, terrainImages, this.gameEditor.getCollections().configs.game.isIsometric);\r\n    }\r\n\r\n    animate() {\r\n        requestAnimationFrame(this.animate.bind(this));\r\n        this.controls.update();\r\n        this.componentsToUpdate.forEach((component) => component.update());\r\n        // Calculate delta once per frame\r\n        const delta = this.clock ? this.clock.getDelta() : 0;\r\n        this.gameEditor.deltaTime = delta;\r\n        // Update all mixers with the same delta\r\n        this.scene.traverse(object => {\r\n            if (object.userData.mixer) {\r\n                object.userData.mixer.update(delta);\r\n            }\r\n            if (object.isSkinnedMesh) {\r\n                object.skeleton.update();\r\n            }\r\n        });\r\n        \r\n        if (this.gizmoManager && this.gizmoManager.targetObject) {\r\n            this.gizmoManager.updateGizmoTransform();\r\n        }\r\n        this.renderer.render(this.scene, this.camera);\r\n    }\r\n\r\n    handleResize() {\r\n        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);\r\n    }\r\n\r\n    async handleSave(fireSave) {\r\n     \r\n        if (fireSave) {\r\n            const saveEvent = new CustomEvent('saveSceneObject', {\r\n                detail: { \r\n                    data: this.state.sceneData, \r\n                    propertyName: 'sceneData' \r\n                },\r\n                bubbles: true,\r\n                cancelable: true\r\n            });\r\n            document.body.dispatchEvent(saveEvent);\r\n        } else {\r\n            const valueElement = this.gameEditor.elements.editor\r\n                .querySelector('#sceneData-value');\r\n            if (valueElement) {\r\n                let renderDataCopy = JSON.parse(JSON.stringify(this.state.sceneData));  \r\n                valueElement.value = JSON.stringify(renderDataCopy, null, 2);\r\n            }\r\n        }\r\n    }\r\n\r\n    async renderSceneData(sceneData) {\r\n        for(let entity of sceneData){\r\n\r\n            const prefabData = this.gameEditor.getCollections()[entity.objectType][entity.spawnType];   \r\n            let componentData = {};\r\n            entity.components.forEach((c) => {\r\n                componentData[c.type] = c.parameters;\r\n            });\r\n            let params = { \"objectType\": entity.objectType, \"spawnType\": entity.spawnType, ...componentData, ...prefabData };             \r\n            if(params.render && params.render.model){\r\n                await this.addModelToScene(entity.type, params);                \r\n            }\r\n            \r\n            this.createEntity(entity.type, params);\r\n        }        \r\n    }\r\n\r\n    async createEntityFromCollections(type, params) {\r\n        const entity = this.createEntity(type, params);  \r\n\r\n        return entity;\r\n    }\r\n\r\n    async addModelToScene(name, params) {     \r\n        const model = params.render.model;\r\n        const modelGroup = new window.THREE.Group(); // Main container for all shapes\r\n        modelGroup.name = name;   \r\n        for (const groupName in model) {            \r\n            const mergedGroup = model[groupName];\r\n            if (mergedGroup) {\r\n                let groupGroup = await this.shapeFactory.createGroupFromJSON(groupName, mergedGroup); \r\n                groupGroup.name = groupName;\r\n                modelGroup.add(groupGroup);\r\n            }\r\n        }\r\n        this.rootGroup.add(modelGroup);\r\n        if(params.transform?.position){\r\n            modelGroup.position.x = params.transform.position.x;\r\n            modelGroup.position.y = params.transform.position.y;\r\n            modelGroup.position.z = params.transform.position.z;\r\n        }\r\n        if(params.transform?.scale){\r\n            modelGroup.scale.x = params.transform.scale.x;\r\n            modelGroup.scale.y = params.transform.scale.y;\r\n            modelGroup.scale.z = params.transform.scale.z;\r\n        }\r\n        if(params.transform?.rotation){\r\n            modelGroup.rotation.x = params.transform.rotation.x;\r\n            modelGroup.rotation.y = params.transform.rotation.y;\r\n            modelGroup.rotation.z = params.transform.rotation.z;\r\n        }\r\n    }\r\n\r\n    async clearScene() {\r\n        this.componentsToUpdate.forEach((component) => component.destroy());\r\n        this.componentsToUpdate = [];\r\n        while (this.rootGroup.children.length > 0) {\r\n            const obj = this.rootGroup.children[0];\r\n            this.shapeFactory.disposeObject(obj);\r\n            this.rootGroup.remove(obj);\r\n        }        \r\n        this.state.sceneData = []; \r\n    }\r\n\r\n    createEntity(type, prefabData) {\r\n        const id = this.game.getEntityId();\r\n        const entity = {\r\n            id,\r\n            type,\r\n            objectType: prefabData.objectType,\r\n            spawnType: prefabData.spawnType,\r\n            parent: null,\r\n            children: [],\r\n            components: this.getEntityComponents(type, prefabData)\r\n        };\r\n\r\n\r\n        this.state.sceneData.push(entity);\r\n        this.handleSave(false);\r\n        this.renderHierarchy();\r\n        \r\n        return entity;\r\n    }\r\n\r\n    getEntityComponents(type, prefabData){\r\n        let components = [];\r\n        // Add transform component by default\r\n        components.push({\r\n            type: 'transform',\r\n            parameters: {\r\n                position: prefabData.transform && prefabData.transform.position ? prefabData.transform.position : { x: 0, y: 0, z: 0 },\r\n                rotation: prefabData.transform && prefabData.transform.rotation ? prefabData.transform.rotation : { x: 0, y: 0, z: 0 },\r\n                scale: prefabData.transform && prefabData.transform.scale ? prefabData.transform.scale : { x: 1, y: 1, z: 1 }\r\n            }\r\n        });\r\n        const entityObjData = this.gameEditor.getCollections().entities[type];\r\n        const combined = [...entityObjData.renderers, ...entityObjData.components];\r\n\r\n        let compsToInit = [];\r\n         \r\n        combined.forEach((componentName) => {\r\n            const componentDataKey = componentName.charAt(0).toLowerCase() + componentName.slice(1, componentName.length);\r\n            const compInstanceId = prefabData[componentDataKey];\r\n            if(compInstanceId){\r\n                let componentDef = this.gameEditor.getCollections().components[componentName];\r\n                if(!componentDef) {\r\n                    componentDef = this.gameEditor.getCollections().renderers[componentName];\r\n                }\r\n\r\n                let component = {\r\n                    type: componentName,\r\n                    parameters: {}\r\n                };       \r\n                let componentDataCollectionDef = this.gameEditor.getCollectionDefs().find(t =>                     \r\n                    componentName.toLowerCase() == t.singular.replace(/ /g,'').toLowerCase() \r\n                );\r\n                if(!componentDataCollectionDef){\r\n                    componentDataCollectionDef = this.gameEditor.getCollectionDefs().find(t =>   \r\n                        componentName.toLowerCase().endsWith(t.singular.replace(/ /g,'').toLowerCase())\r\n                    );\r\n                }\r\n                if(componentDataCollectionDef){\r\n                    component.parameters = this.gameEditor.getCollections()[componentDataCollectionDef.id][prefabData[componentDataKey]];\r\n                    delete component.parameters.title;\r\n                }\r\n                components.push(component);\r\n                if(componentDef.updateInEditor){\r\n             \r\n\r\n                    let comp = this.gameEditor.instantiateComponent(componentName);\r\n                    let params = {...component.parameters, canvas: this.canvas, scene: this.scene, camera: this.camera, renderer: this.renderer, isEditor: true};\r\n                    compsToInit.push({\r\n                        component: comp,\r\n                        params: params\r\n                    })\r\n                }\r\n            }\r\n        });\r\n\r\n        compsToInit.forEach((compObj) => {\r\n            let comp = compObj.component;\r\n            let params = compObj.params;\r\n            comp.init(params)\r\n            this.componentsToUpdate.push(comp);\r\n        })\r\n \r\n        return components;\r\n    }\r\n\r\n    addComponent(entity, componentType) {\r\n        if (!entity) return;\r\n        \r\n        // Check if the component already exists\r\n        const exists = entity.components.some(c => c.type === componentType);\r\n        if (exists) {\r\n            console.log(`Entity already has a ${componentType} component`);\r\n            return;\r\n        }\r\n        \r\n        let component = {\r\n            type: componentType,\r\n            parameters: {}\r\n        };\r\n        \r\n        // Initialize parameters based on component type\r\n        switch (componentType) {\r\n            case 'meshRenderer':\r\n                component.parameters = {\r\n                    geometry: entity.type || 'cube',\r\n                    material: 'standard',\r\n                    color: '#cccccc',\r\n                    receiveShadow: true,\r\n                    castShadow: true\r\n                };\r\n                break;\r\n            case 'light':\r\n                component.parameters = {\r\n                    type: 'point',\r\n                    color: '#ffffff',\r\n                    intensity: 1.0,\r\n                    castShadow: true\r\n                };\r\n                break;\r\n            case 'collider':\r\n                component.parameters = {\r\n                    type: 'box',\r\n                    isTrigger: false,\r\n                    size: { x: 1, y: 1, z: 1 }\r\n                };\r\n                break;\r\n            case 'rigidbody':\r\n                component.parameters = {\r\n                    mass: 1.0,\r\n                    drag: 0.1,\r\n                    useGravity: true,\r\n                    isKinematic: false\r\n                };\r\n                break;\r\n            case 'audio':\r\n                component.parameters = {\r\n                    clip: 'none',\r\n                    volume: 1.0,\r\n                    pitch: 1.0,\r\n                    loop: false,\r\n                    playOnAwake: false\r\n                };\r\n                break;\r\n            case 'script':\r\n                component.parameters = {\r\n                    script: 'NewScript.js',\r\n                    enabled: true\r\n                };\r\n                break;\r\n        }\r\n        \r\n        entity.components.push(component);\r\n        \r\n        // Re-render the inspector to show the new component\r\n        if (this.state.selectedEntity === entity) {\r\n            this.selectEntity(entity);\r\n        }\r\n    }\r\n\r\n    removeComponent(entity, componentType) {\r\n        if (!entity) return;\r\n        \r\n        // Don't allow removing transform component\r\n        if (componentType === 'transform') {\r\n            console.log(\"Cannot remove transform component\");\r\n            return;\r\n        }\r\n        \r\n        const index = entity.components.findIndex(c => c.type === componentType);\r\n        if (index !== -1) {\r\n            entity.components.splice(index, 1);\r\n            \r\n            // Re-render the inspector\r\n            if (this.state.selectedEntity === entity) {\r\n                this.selectEntity(entity);\r\n            }\r\n        }\r\n    }\r\n\r\n    renderHierarchy() {\r\n        this.elements.hierarchy.innerHTML = '';\r\n        \r\n        // Get top-level entities (those without a parent)\r\n        const rootEntities = this.state.sceneData.filter(e => e.parent === null);\r\n        \r\n        // Render each root entity and its children\r\n        rootEntities.forEach(entity => {\r\n            this.renderEntityInHierarchy(entity, this.elements.hierarchy);\r\n        });\r\n    }\r\n\r\n    renderEntityInHierarchy(entity, parentElement, level = 0) {\r\n        const itemEl = document.createElement('div');\r\n        itemEl.className = 'scene-editor__hierarchy-item';\r\n        itemEl.dataset.entityId = entity.id;\r\n\r\n        if (this.state.selectedEntity === entity) {\r\n            itemEl.classList.add('selected');\r\n        }    \r\n        // Create entity name\r\n        const nameEl = document.createElement('span');\r\n        nameEl.textContent = entity.type;\r\n        itemEl.appendChild(nameEl);\r\n        \r\n        // Add click event\r\n        itemEl.addEventListener('click', () => {\r\n            this.selectEntity(entity);\r\n        });\r\n        \r\n        parentElement.appendChild(itemEl);\r\n        \r\n        // Find children of this entity\r\n        const children = this.state.sceneData.filter(e => e.parent === entity);\r\n        children.forEach(child => {\r\n            this.renderEntityInHierarchy(child, parentElement, level + 1);\r\n        });\r\n    }\r\n\r\n    selectEntity(entity) {\r\n        // Clear previous selection\r\n        const prevSelected = document.querySelector('.scene-editor__hierarchy-item.selected');\r\n        if (prevSelected) {\r\n            prevSelected.classList.remove('selected');\r\n        }\r\n        \r\n        this.state.selectedEntity = entity;\r\n        \r\n        // Update hierarchy selection\r\n        const entityEl = document.querySelector(`.hierarchy-item[data-entity-id=\"${entity.id}\"]`);\r\n        if (entityEl) {\r\n            entityEl.classList.add('selected');\r\n        }\r\n        \r\n        // Show inspector with entity data\r\n        this.renderInspector();\r\n\r\n        if (entity) {\r\n            const entityObject = this.findEntityObject(entity);            \r\n            if (entityObject) {\r\n                this.state.selectedEntityObject = entityObject;\r\n                this.gizmoManager.attach(entityObject);\r\n            } else {\r\n                this.state.selectedEntityObject = null;\r\n                this.gizmoManager.detach();\r\n            }\r\n        } else {\r\n            this.gizmoManager.detach();\r\n        }\r\n    }\r\n\r\n    renderInspector() {\r\n        // Show/hide the appropriate sections\r\n        if (!this.state.selectedEntity) {\r\n            this.elements.noSelection.style.display = 'block';\r\n            this.elements.entityInspector.style.display = 'none';\r\n            return;\r\n        }\r\n        \r\n        this.elements.noSelection.style.display = 'none';\r\n        this.elements.entityInspector.style.display = 'block';\r\n        \r\n        // Update transform values\r\n        const entity = this.state.selectedEntity;\r\n\r\n\r\n        if (entity) {\r\n            // Clear and re-render components\r\n            this.elements.components.innerHTML = '';\r\n            \r\n            entity.components.forEach(component => {        \r\n                this.renderComponent(component);\r\n            });\r\n            const entityObject = this.findEntityObject(entity);\r\n            if (entityObject) {\r\n                // Sync transform values from entity to 3D object\r\n                const transformComponent = entity.components.find(c => c.type === 'transform');\r\n                if (transformComponent) {\r\n                    const position = transformComponent.parameters.position;\r\n                    const rotation = transformComponent.parameters.rotation;\r\n                    const scale = transformComponent.parameters.scale;\r\n                    \r\n                    entityObject.position.set(position.x, position.y, position.z);\r\n                    entityObject.rotation.set(rotation.x, rotation.y, rotation.z);\r\n                    entityObject.scale.set(scale.x, scale.y, scale.z);\r\n                    \r\n                    // Update gizmo position\r\n                    this.gizmoManager.updateGizmoTransform();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    renderComponent(component) {\r\n        const componentEl = document.createElement('div');\r\n        componentEl.className = 'component-section';\r\n        \r\n        // Component header\r\n        const headerEl = document.createElement('h3');\r\n        headerEl.className = 'component-header';        \r\n        headerEl.textContent = this.formatComponentName(component.type);\r\n        \r\n        // Remove component button\r\n        const removeBtn = document.createElement('button');\r\n        removeBtn.className = 'btn';\r\n        removeBtn.textContent = 'X';\r\n        removeBtn.addEventListener('click', () => {\r\n            this.removeComponent(this.state.selectedEntity, component.type);\r\n        });\r\n        headerEl.appendChild(removeBtn);\r\n        \r\n        componentEl.appendChild(headerEl);\r\n        \r\n        // Component parameters\r\n        Object.entries(component.parameters).forEach(([key, value]) => {\r\n            const propEl = document.createElement('div');\r\n            propEl.className = 'property';\r\n            \r\n            // Property label\r\n            const labelEl = document.createElement('label');\r\n            labelEl.textContent = this.formatPropertyName(key);\r\n            propEl.appendChild(labelEl);\r\n            \r\n            // Property input\r\n            let inputEl;\r\n            \r\n            if (typeof value === 'boolean') {\r\n                // Boolean checkbox\r\n                inputEl = document.createElement('input');\r\n                inputEl.type = 'checkbox';\r\n                inputEl.checked = value;\r\n                inputEl.dataset.key = key;\r\n            } else if (typeof value === 'number') {\r\n                // Number input\r\n                inputEl = document.createElement('input');\r\n                inputEl.type = 'number';\r\n                inputEl.value = value;\r\n                inputEl.step = key.includes('scale') ? '0.1' : '1';\r\n                inputEl.dataset.key = key;\r\n            } else if (typeof value === 'object' && value !== null) {\r\n                // Vector3 input for position, rotation, scale, etc.\r\n                inputEl = document.createElement('div');\r\n                inputEl.className = 'vector3-input';\r\n                \r\n                ['x', 'y', 'z'].forEach(axis => {\r\n                if (axis in value) {\r\n                    const axisInput = document.createElement('input');\r\n                    axisInput.type = 'number';\r\n                    axisInput.value = value[axis];\r\n                    axisInput.step = '0.1';\r\n                    axisInput.dataset.axis = axis;\r\n                    axisInput.dataset.key = key;\r\n                    inputEl.appendChild(axisInput);\r\n                }\r\n                });\r\n            } else if (key === 'type' && component.type === 'light') {\r\n                // Select dropdown for light type\r\n                inputEl = document.createElement('select');\r\n                ['directional', 'point', 'spot', 'ambient'].forEach(type => {\r\n                    const option = document.createElement('option');\r\n                    option.value = type;\r\n                    option.textContent = this.formatPropertyName(type);\r\n                    option.selected = value === type;\r\n                    inputEl.appendChild(option);\r\n                });\r\n                inputEl.dataset.key = key;\r\n            } else if (key === 'color') {\r\n                // Color input\r\n                inputEl = document.createElement('div');\r\n                inputEl.className = 'color-input';\r\n                \r\n                const colorInput = document.createElement('input');\r\n                colorInput.type = 'text';\r\n                colorInput.value = value;\r\n                inputEl.appendChild(colorInput);\r\n                \r\n                const colorPreview = document.createElement('div');\r\n                colorPreview.className = 'color-preview';\r\n                colorPreview.style.backgroundColor = value;\r\n                inputEl.appendChild(colorPreview);\r\n                colorInput.dataset.key = key;\r\n            } else {\r\n                // Default text input\r\n                inputEl = document.createElement('input');\r\n                inputEl.type = 'text';\r\n                inputEl.value = value;\r\n                inputEl.dataset.key = key;\r\n            }\r\n            inputEl.addEventListener('change', (e)=> {\r\n                if(e.target.dataset.axis) {                   \r\n                    component.parameters[e.target.dataset.key][e.target.dataset.axis] = Number(e.target.value);\r\n                    this.state.selectedEntityObject[e.target.dataset.key][e.target.dataset.axis] = Number(e.target.value);\r\n                } else {\r\n                    component.parameters[e.target.dataset.key] = e.target.value;\r\n                }\r\n                this.handleSave(false);\r\n            });\r\n            propEl.appendChild(inputEl);\r\n            componentEl.appendChild(propEl);\r\n        });\r\n        \r\n        this.elements.components.appendChild(componentEl);\r\n    }\r\n    \r\n    formatComponentName(name) {\r\n        // Convert camelCase or snake_case to Title Case with spaces\r\n        return name\r\n        .replace(/([A-Z])/g, ' $1')\r\n        .replace(/_/g, ' ')\r\n        .replace(/^./, str => str.toUpperCase());\r\n    }\r\n    \r\n    formatPropertyName(name) {\r\n        // Convert camelCase or snake_case to Title Case with spaces\r\n        return name\r\n        .replace(/([A-Z])/g, ' $1')\r\n        .replace(/_/g, ' ')\r\n        .replace(/^./, str => str.toUpperCase());\r\n    }\r\n    \r\n    getMergedGroup(groupName){\r\n        let model = this.state.renderData.model;\r\n        const modelGroup = model[groupName];\r\n        if(this.state.editingModel){\r\n            return modelGroup;\r\n        }\r\n        return this.shapeFactory.getMergedGroup(model, this.getCurrentAnimation()[this.state.currentFrame], groupName );\r\n    }\r\n\r\n    updateGizmoToolbarUI(activeButtonId) {\r\n        // Remove active class from all gizmo tool buttons\r\n        ['scene-translate-tool', 'scene-rotate-tool', 'scene-scale-tool'].forEach(id => {\r\n            const btn = document.getElementById(id);\r\n            if (btn) btn.classList.remove('active');\r\n        });\r\n\r\n        // Add active class to the clicked button\r\n        const activeBtn = document.getElementById(activeButtonId);\r\n        if (activeBtn) activeBtn.classList.add('active');\r\n    }\r\n    \r\n    setGizmoMode(mode) {\r\n        if (this.gizmoManager) {\r\n            this.gizmoManager.setMode(mode);\r\n        }\r\n    }\r\n    findEntityObject(entity) {\r\n        // Look for the object in the scene with the same name as the entity type\r\n        // This needs to be adjusted based on how your entities are mapped to 3D objects\r\n        const entityName = entity.type;\r\n        \r\n        let foundObject = null;\r\n        this.rootGroup.traverse((object) => {\r\n            if (object.name === entityName) {\r\n                foundObject = object;\r\n            }\r\n        });\r\n        \r\n        return foundObject;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/SceneEditor.js",
        "fileName": "SceneEditor"
      },
      "SeededRandom": {
        "script": "class SeededRandom {\r\n    constructor(seed) {\r\n        this.seed = seed;\r\n        this.current = seed;\r\n    }\r\n    \r\n    next() {\r\n        this.current = (this.current * 1664525 + 1013904223) % Math.pow(2, 32);\r\n        return this.current / Math.pow(2, 32);\r\n    }\r\n    \r\n    range(min, max) {\r\n        return min + this.next() * (max - min);\r\n    }\r\n    \r\n    int(min, max) {\r\n        return Math.floor(this.range(min, max + 1));\r\n    }\r\n}\r\n\r\nif(typeof SeededRandom != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.SeededRandom = SeededRandom;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = SeededRandom;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = SeededRandom;\r\n        exports.SeededRandom = SeededRandom;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/SeededRandom.js",
        "fileName": "SeededRandom"
      },
      "ServerEventManager": {
        "script": "export default class ServerEventManager {\r\n    constructor(engine) {\r\n        this.engine = engine;\r\n        this.listeners = new Map(); // eventType -> [callbacks]\r\n    }\r\n    \r\n    subscribe(eventType, callback) {\r\n        console.log(\"subscribing\", eventType);\r\n        if (!this.listeners.has(eventType)) {\r\n            this.listeners.set(eventType, []);\r\n        }\r\n        this.listeners.get(eventType).push(callback);\r\n    }\r\n    \r\n    emit(eventType, data) {\r\n        const callbacks = this.listeners.get(eventType) || [];\r\n        const results = [];\r\n        for (const callback of callbacks) {\r\n            try {\r\n                const result = callback(data);\r\n                if (result) results.push(result);\r\n            } catch (error) {\r\n                console.error(`Event handler error for ${eventType}:`, error);\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ServerEventManager.js",
        "fileName": "ServerEventManager"
      },
      "ServerGameRoom": {
        "script": "import GameRoom from './GameRoom.js';\r\n\r\nexport default class ServerGameRoom extends GameRoom {\r\n    constructor(engine, roomId, gameInstance, maxPlayers = 2, gameConfig = {}) {\r\n        super(engine, roomId, gameInstance, maxPlayers);\r\n        \r\n        // Add multiplayer lobby functionality\r\n        this.game.state.phase = 'waiting'; // 'waiting', 'lobby', 'playing', 'ended'\r\n        this.gameConfig = gameConfig;\r\n        this.createdAt = Date.now();\r\n        this.nextRoomId = 1000;\r\n        this.currentRoomIds = [];\r\n        \r\n        // Subscribe to events from network manager\r\n        this.subscribeToEvents();\r\n        \r\n        console.log(`ServerGameRoom ${roomId} created for ${maxPlayers} players`);\r\n    }\r\n\r\n    subscribeToEvents() {\r\n        console.log('game room subscribing to events');\r\n        if (!this.game.serverEventManager) {\r\n            console.error('No event manager found on engine');\r\n            return;\r\n        }\r\n\r\n        // Subscribe to room management events\r\n        this.game.serverEventManager.subscribe('QUICK_MATCH', this.handleQuickMatch.bind(this));\r\n        this.game.serverEventManager.subscribe('LEAVE_ROOM', this.handleLeaveRoom.bind(this));\r\n        this.game.serverEventManager.subscribe('PLAYER_DISCONNECT', this.handlePlayerDisconnect.bind(this));\r\n        this.game.serverEventManager.subscribe('TOGGLE_READY', this.handleToggleReady.bind(this));\r\n    }\r\n\r\n\r\n\r\n    handleQuickMatch(eventData) {\r\n        const { playerId, data } = eventData;\r\n        \r\n        try {\r\n            const { playerName } = data;\r\n            \r\n            // Find available room\r\n            let availableRoom = null;\r\n            for (const [roomId, room] of this.engine.gameRooms) {\r\n                if ((this.game.state.phase === 'waiting' || this.game.state.phase === 'lobby') && \r\n                    room.players.size < room.maxPlayers) {\r\n                    availableRoom = room;\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            if (!availableRoom) {\r\n                // Create new room for quick match\r\n                const roomId = this.generateRoomId();\r\n                availableRoom = this.engine.createGameRoom(roomId, 2);\r\n            }\r\n            \r\n            if (!availableRoom) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { \r\n                    error: 'Failed to create or find room' \r\n                });\r\n                return;\r\n            }\r\n\r\n            const result = availableRoom.addPlayer(playerId, {\r\n                name: playerName || `Player ${playerId.substr(-4)}`,\r\n                isHost: availableRoom.players.size === 0\r\n            });\r\n\r\n            if (result.success) {\r\n                this.serverNetworkManager.joinRoom(playerId, availableRoom.id);\r\n                \r\n                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FOUND', {\r\n                    roomId: availableRoom.id,\r\n                    playerId: playerId,\r\n                    isHost: availableRoom.players.size === 1,\r\n                    gameState: availableRoom.getGameState()\r\n                });\r\n                \r\n                // Notify other players in room\r\n                this.serverNetworkManager.broadcastToRoom(availableRoom.id, 'PLAYER_JOINED', {\r\n                    playerId: playerId,\r\n                    playerName: playerName,\r\n                    gameState: availableRoom.getGameState()\r\n                });\r\n                \r\n                console.log(`Player ${playerName} quick-matched into room ${availableRoom.id}`);\r\n            } else {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { \r\n                    error: result.error || result.reason || 'Failed to find match' \r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error in quick match:', error);\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { \r\n                error: 'Server error during quick match' \r\n            });\r\n        }\r\n    }\r\n\r\n    handleToggleReady(eventData) {\r\n        const { playerId } = eventData;\r\n        try {\r\n            const success = this.togglePlayerReady(playerId);\r\n            if (!success) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'ERROR', { \r\n                    error: 'Cannot toggle ready in current phase' \r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error toggling ready:', error);\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'ERROR', { \r\n                error: 'Server error' \r\n            });\r\n        }\r\n    }\r\n\r\n    handlePlayerDisconnect(eventData) {\r\n        const { playerId } = eventData;\r\n        console.log(`Player ${playerId} disconnected`);\r\n        \r\n        // Get the room the player was in\r\n        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n        if (roomId) {\r\n            const room = this.engine.gameRooms.get(roomId);\r\n            if (room) {\r\n                // Get player data before removing\r\n                const player = room.players.get(playerId);\r\n                const playerName = player?.name || 'Unknown';\r\n                \r\n                // Notify other players\r\n                this.serverNetworkManager.broadcastToRoom(roomId, 'PLAYER_LEFT', {\r\n                    playerId: playerId,\r\n                    playerName: playerName\r\n                });\r\n                \r\n                // Clean up player state completely\r\n                this.cleanupPlayerState(room, playerId);\r\n                \r\n                // Remove from room\r\n                room.removePlayer(playerId);\r\n                this.serverNetworkManager.leaveRoom(playerId, roomId);\r\n\r\n                \r\n                // Clean up empty rooms\r\n                if (room.players.size === 0) {\r\n                    this.cleanupRoom(room);\r\n                    this.engine.gameRooms.delete(roomId);\r\n                    console.log(`Removed empty room ${roomId}`);\r\n                } else {\r\n                    // If room still has players, reset their states for next game\r\n                    this.resetPlayersForNextGame(room);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Clean up network manager state\r\n        this.serverNetworkManager.playerSockets.delete(playerId);\r\n    }\r\n\r\n    handleLeaveRoom(eventData) {\r\n        const { playerId } = eventData;\r\n        \r\n        // Use the same cleanup logic as disconnect\r\n        this.handlePlayerDisconnect(eventData);\r\n    }\r\n\r\n    cleanupPlayerState(room, playerId) {\r\n        const player = room.players.get(playerId);\r\n        if (!player) return;\r\n        \r\n        // Clear any placement data\r\n        if (room.game && room.game.placementSystem) {\r\n            room.game.placementSystem.clearPlayerPlacements(playerId);\r\n        }\r\n        \r\n        // Clear any battle data\r\n        if (room.game && room.game.battlePhaseSystem) {\r\n            const battleSystem = room.game.battlePhaseSystem;\r\n            if (battleSystem.createdSquads) {\r\n                battleSystem.createdSquads.delete(playerId);\r\n            }\r\n            if (battleSystem.battleResults) {\r\n                battleSystem.battleResults.delete(playerId);\r\n            }\r\n        }\r\n        \r\n        // Clear any entities owned by this player\r\n        if (room.game && room.game.componentManager) {\r\n            const ComponentTypes = room.game.componentManager.getComponentTypes();\r\n            const playerEntities = room.game.getEntitiesWith(ComponentTypes.PLAYER_OWNED)\r\n                .filter(entityId => {\r\n                    const ownerComp = room.game.getComponent(entityId, ComponentTypes.PLAYER_OWNED);\r\n                    return ownerComp && ownerComp.playerId === playerId;\r\n                });\r\n            \r\n            playerEntities.forEach(entityId => {\r\n                try {\r\n                    room.game.destroyEntity(entityId);\r\n                } catch (error) {\r\n                    console.warn(`Error destroying player entity ${entityId}:`, error);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // Override parent's auto-start behavior to add lobby phase\r\n    addPlayer(playerId, playerData) {\r\n        const result = super.addPlayer(playerId, playerData);\r\n        \r\n        if (result.success) {\r\n            // Add multiplayer-specific player properties\r\n            const player = this.players.get(playerId);\r\n            player.ready = false;\r\n            player.placementReady = false;\r\n            player.isHost = playerData.isHost || false;\r\n            \r\n            player.stats = {\r\n                health: this.game.state.teamMaxHealth,                \r\n                gold: this.game.state.startingGold,\r\n                side: playerData.isHost ? 'left' : 'right',\r\n                upgrades: []\r\n            };\r\n            // If room is full, enter lobby phase (don't auto-start like parent does)\r\n            if (this.players.size === this.maxPlayers && this.game.state.phase === 'waiting') {\r\n                this.enterLobbyPhase();\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    enterLobbyPhase() {\r\n        this.game.state.phase = 'lobby';\r\n        \r\n        // Broadcast lobby entered to all players in room\r\n        if (this.serverNetworkManager) {\r\n            this.serverNetworkManager.broadcastToRoom(this.id, 'LOBBY_ENTERED', {\r\n                gameState: this.getGameState()\r\n            });\r\n        }\r\n        \r\n        console.log(`Room ${this.id} entered lobby phase`);\r\n    }\r\n\r\n    togglePlayerReady(playerId) {\r\n        const player = this.players.get(playerId);\r\n        if (!player || (this.game.state.phase !== 'lobby' && this.game.state.phase !== 'waiting')) {\r\n            console.log(\"no player or not in lobby/waiting phase\", this.game.state.phase);\r\n            return false;\r\n        }\r\n        \r\n        player.ready = !player.ready;\r\n        \r\n        const allReady = Array.from(this.players.values()).every(p => p.ready);\r\n        \r\n        // Broadcast ready state update\r\n        if (this.serverNetworkManager) {\r\n            this.serverNetworkManager.broadcastToRoom(this.id, 'PLAYER_READY_UPDATE', {\r\n                playerId: playerId,\r\n                ready: player.ready,\r\n                allReady: allReady,\r\n                gameState: this.getGameState()\r\n            });\r\n        }\r\n        \r\n        // Auto-start if all ready\r\n        if (allReady) {\r\n            setTimeout(() => this.startGame(), 1000);\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    // Override parent's startGame to add multiplayer lobby logic\r\n    startGame() {\r\n        if (this.game.state.phase !== 'lobby') {\r\n            console.log(`Cannot start game, not in lobby phase. Current phase: ${this.game.state.phase}`);\r\n            return false;\r\n        }\r\n        \r\n        // Check if all players are ready\r\n        const allReady = Array.from(this.players.values()).every(p => p.ready);\r\n        if (!allReady) {\r\n            return false;\r\n        }\r\n        \r\n        this.game.state.phase = 'placement';\r\n        \r\n        // Call parent's startGame (loads scene, spawns entities, etc.)\r\n        super.startGame();\r\n        \r\n        // Broadcast game started\r\n        if (this.serverNetworkManager) {\r\n            let gameState = this.getGameState();\r\n            this.serverNetworkManager.broadcastToRoom(this.id, 'GAME_STARTED', {\r\n                gameState: gameState\r\n            });            \r\n        }\r\n        \r\n        console.log(`Game started in room ${this.id}`);\r\n        return true;\r\n    }\r\n\r\n    // Enhanced game state for multiplayer\r\n    getGameState() {\r\n        let players = Array.from(this.players.values());\r\n        let playerData = [];\r\n        players.forEach((p) => {\r\n            let placements = null;\r\n            if(this.game.placementSystem){\r\n                placements = this.game.placementSystem.playerPlacements.get(p.id);\r\n            }\r\n\r\n            if(this.game.squadExperienceSystem && placements){                \r\n                placements.forEach((placement) => {\r\n                    placement.experience = this.game.squadExperienceSystem.getSquadInfo(placement.placementId)\r\n                });\r\n            }\r\n            playerData.push({\r\n                id: p.id,\r\n                name: p.name,\r\n                ready: p.ready || false,\r\n                isHost: p.isHost || false,\r\n                stats: p.stats,\r\n                placements: placements || [],\r\n                entityId: p.entityId,\r\n                lastInputSequence: p.lastInputSequence || 0,\r\n                latency: p.latency || 0\r\n            });\r\n        });\r\n        return {\r\n            roomId: this.id,\r\n            phase: this.game.state.phase,\r\n            isActive: this.isActive,\r\n            maxPlayers: this.maxPlayers,\r\n            gameType: this.gameConfig?.type || 'default',\r\n            players: playerData,\r\n            round: this.game.state.round,\r\n            // Let the game instance provide additional state if needed\r\n            gameData: this.game.getGameState ? this.game.getGameState() : null\r\n        };\r\n    }\r\n\r\n    generateRoomId() {\r\n        let id;\r\n        do {\r\n            id = this.nextRoomId++;\r\n            if (this.nextRoomId > 9999) {\r\n                this.nextRoomId = 1000;\r\n            }\r\n        } while (this.currentRoomIds.includes(id.toString()));\r\n        \r\n        this.currentRoomIds.push(id.toString());\r\n        return id.toString();\r\n    }\r\n\r\n\r\n    // NEW METHOD: Reset all remaining players for next game\r\n    resetPlayersForNextGame(room) {\r\n        for (const [playerId, player] of room.players) {\r\n            // Reset player stats to initial values\r\n            player.stats = {\r\n                health: this.game.state.teamMaxHealth,\r\n                gold: this.game.state.startingGold,\r\n                side: player.stats.side // Keep their side assignment\r\n            };\r\n            \r\n            // Reset ready states\r\n            player.ready = false;\r\n            player.placementReady = false;\r\n            \r\n            console.log(`Reset player ${playerId} stats:`, player.stats);\r\n        }\r\n        \r\n        // Broadcast updated game state\r\n        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_STATE_UPDATE', {\r\n            gameState: room.getGameState()\r\n        });\r\n    }\r\n\r\n    // NEW METHOD: Complete room cleanup\r\n    cleanupRoom(room) {\r\n        try {\r\n            // Clear all game systems\r\n            if (room.game) {                \r\n                room.game.triggerEvent('dispose');\r\n            }\r\n            // Remove room ID from tracking\r\n            const roomIndex = this.currentRoomIds.indexOf(room.id);\r\n            if (roomIndex > -1) {\r\n                this.currentRoomIds.splice(roomIndex, 1);\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error('Error during room cleanup:', error);\r\n        }\r\n    }\r\n}\r\n",
        "filePath": "/global/libraries/js/ServerGameRoom.js",
        "fileName": "ServerGameRoom"
      },
      "SE_GizmoManager": {
        "script": "class SE_GizmoManager {\r\n    constructor() {}\r\n\r\n    init(sceneEditor){        \r\n        this.sceneEditor = sceneEditor; // Store reference to the scene editor\r\n        this.scene = sceneEditor.scene;\r\n        this.camera = sceneEditor.camera;\r\n        this.renderer = sceneEditor.renderer;\r\n        this.controls = sceneEditor.controls;\r\n        \r\n        this.gizmoGroup = new THREE.Group();\r\n        this.gizmoGroup.name = \"transformGizmo\";\r\n        this.scene.add(this.gizmoGroup);\r\n        \r\n        this.mode = 'translate'; // 'translate', 'rotate', 'scale'\r\n        this.selectedAxis = null;\r\n        this.isDragging = false;\r\n        this.targetObject = null;\r\n        this.startPosition = new THREE.Vector3();\r\n        this.startRotation = new THREE.Euler();\r\n        this.startScale = new THREE.Vector3();\r\n        this.dragStartPoint = new THREE.Vector3();\r\n        this.dragCurrentPoint = new THREE.Vector3();\r\n        \r\n        this.raycaster = new THREE.Raycaster();\r\n        this.mouse = new THREE.Vector2();\r\n        \r\n        this.axisColors = {\r\n            x: 0xff0000, // red\r\n            y: 0x00ff00, // green\r\n            z: 0x0000ff  // blue\r\n        };\r\n        \r\n        this.highlightColor = 0xffff00; // yellow for highlighting\r\n        \r\n        this.initializeGizmos();\r\n        this.setupEventListeners();\r\n    }\r\n    \r\n    initializeGizmos() {\r\n        this.translateGizmo = this.createTranslateGizmo();\r\n        this.rotateGizmo = this.createRotateGizmo();\r\n        this.scaleGizmo = this.createScaleGizmo();\r\n        \r\n        this.gizmoGroup.add(this.translateGizmo);\r\n        this.gizmoGroup.add(this.rotateGizmo);\r\n        this.gizmoGroup.add(this.scaleGizmo);\r\n        \r\n        // Initially hide all gizmos\r\n        this.gizmoGroup.visible = false;\r\n        this.translateGizmo.visible = false;\r\n        this.rotateGizmo.visible = false;\r\n        this.scaleGizmo.visible = false;\r\n    }\r\n    \r\n    createTranslateGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = \"translateGizmo\";\r\n        \r\n        // Create axis arrows\r\n        const arrowLength = 2;\r\n        const arrowHeadLength = .5;\r\n        const arrowHeadWidth = .5;\r\n        \r\n        // X axis (red)\r\n        const xArrow = new THREE.ArrowHelper(\r\n            new THREE.Vector3(1, 0, 0),\r\n            new THREE.Vector3(0, 0, 0),\r\n            arrowLength,\r\n            this.axisColors.x,\r\n            arrowHeadLength,\r\n            arrowHeadWidth\r\n        );\r\n        xArrow.name = \"translateX\";\r\n        xArrow.line.material.linewidth = 3;\r\n        xArrow.line.material.depthTest = false;\r\n        xArrow.line.material.transparent = true;\r\n        xArrow.line.material.opacity = 0.6;\r\n        xArrow.cone.material.depthTest = false;\r\n        xArrow.cone.material.transparent = true;\r\n        xArrow.cone.material.opacity = 0.6;\r\n        // Make arrow cone and line both interactive\r\n        xArrow.cone.userData.axis = 'x';\r\n        xArrow.cone.userData.gizmoType = 'translate';\r\n        xArrow.line.userData.axis = 'x';\r\n        xArrow.line.userData.gizmoType = 'translate';\r\n        \r\n        // Y axis (green)\r\n        const yArrow = new THREE.ArrowHelper(\r\n            new THREE.Vector3(0, 1, 0),\r\n            new THREE.Vector3(0, 0, 0),\r\n            arrowLength,\r\n            this.axisColors.y,\r\n            arrowHeadLength,\r\n            arrowHeadWidth\r\n        );\r\n        yArrow.name = \"translateY\";\r\n        yArrow.line.material.linewidth = 3;\r\n        yArrow.line.material.depthTest = false;\r\n        yArrow.line.material.transparent = true;\r\n        yArrow.line.material.opacity = 0.6;\r\n        yArrow.cone.material.depthTest = false;\r\n        yArrow.cone.material.transparent = true;\r\n        yArrow.cone.material.opacity = 0.6;\r\n        // Make arrow cone and line both interactive\r\n        yArrow.cone.userData.axis = 'y';\r\n        yArrow.cone.userData.gizmoType = 'translate';\r\n        yArrow.line.userData.axis = 'y';\r\n        yArrow.line.userData.gizmoType = 'translate';\r\n        \r\n        // Z axis (blue)\r\n        const zArrow = new THREE.ArrowHelper(\r\n            new THREE.Vector3(0, 0, 1),\r\n            new THREE.Vector3(0, 0, 0),\r\n            arrowLength,\r\n            this.axisColors.z,\r\n            arrowHeadLength,\r\n            arrowHeadWidth\r\n        );\r\n        zArrow.name = \"translateZ\";\r\n        zArrow.line.material.linewidth = 3;\r\n        zArrow.line.material.depthTest = false;\r\n        zArrow.line.material.transparent = true;\r\n        zArrow.line.material.opacity = 0.6;\r\n        zArrow.cone.material.depthTest = false;\r\n        zArrow.cone.material.transparent = true;\r\n        zArrow.cone.material.opacity = 0.6;\r\n        // Make arrow cone and line both interactive\r\n        zArrow.cone.userData.axis = 'z';\r\n        zArrow.cone.userData.gizmoType = 'translate';\r\n        zArrow.line.userData.axis = 'z';\r\n        zArrow.line.userData.gizmoType = 'translate';\r\n        \r\n        group.add(xArrow);\r\n        group.add(yArrow);\r\n        group.add(zArrow);\r\n        \r\n        return group;\r\n    }\r\n    \r\n    createRotateGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = \"rotateGizmo\";\r\n        \r\n        const radius = 1;\r\n        const tube = 0.05; // Increased tube size for better visibility and interaction\r\n        const radialSegments = 24;\r\n        const tubularSegments = 48;\r\n        \r\n        // X axis ring (red)\r\n        const xGeometry = new THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments);\r\n        const xMaterial = new THREE.MeshBasicMaterial({ color: this.axisColors.x, transparent: true, opacity: 0.6, depthTest: false });\r\n        const xRing = new THREE.Mesh(xGeometry, xMaterial);\r\n        xRing.name = \"rotateX\";\r\n        xRing.rotation.y = Math.PI / 2;\r\n        xRing.userData.axis = 'x';\r\n        xRing.userData.gizmoType = 'rotate';\r\n        \r\n        // Y axis ring (green)\r\n        const yGeometry = new THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments);\r\n        const yMaterial = new THREE.MeshBasicMaterial({ color: this.axisColors.y, transparent: true, opacity: 0.6, depthTest: false });\r\n        const yRing = new THREE.Mesh(yGeometry, yMaterial);\r\n        yRing.name = \"rotateY\";\r\n        yRing.rotation.x = Math.PI / 2; // Fixed rotation axis\r\n        yRing.userData.axis = 'y';\r\n        yRing.userData.gizmoType = 'rotate';\r\n        \r\n        // Z axis ring (blue)\r\n        const zGeometry = new THREE.TorusGeometry(radius, tube, radialSegments, tubularSegments);\r\n        const zMaterial = new THREE.MeshBasicMaterial({ color: this.axisColors.z, transparent: true, opacity: 0.6, depthTest: false });\r\n        const zRing = new THREE.Mesh(zGeometry, zMaterial);\r\n        zRing.name = \"rotateZ\";\r\n        zRing.userData.axis = 'z';\r\n        zRing.userData.gizmoType = 'rotate';\r\n        \r\n        group.add(xRing);\r\n        group.add(yRing);\r\n        group.add(zRing);\r\n        \r\n        return group;\r\n    }\r\n    \r\n    createScaleGizmo() {\r\n        const group = new THREE.Group();\r\n        group.name = \"scaleGizmo\";\r\n        \r\n        const lineLength = 1.5; // Increased for better visibility\r\n        const boxSize = 0.2;    // Increased for better interaction\r\n        \r\n        // X axis (red)\r\n        const xLine = new THREE.Line(\r\n            new THREE.BufferGeometry().setFromPoints([\r\n                new THREE.Vector3(0, 0, 0),\r\n                new THREE.Vector3(lineLength, 0, 0)\r\n            ]),\r\n            new THREE.LineBasicMaterial({ color: this.axisColors.x, transparent: true, opacity: 0.6, depthTest: false, linewidth: 2 })\r\n        );\r\n        xLine.userData.axis = 'x';\r\n        xLine.userData.gizmoType = 'scale';\r\n        \r\n        const xBox = new THREE.Mesh(\r\n            new THREE.BoxGeometry(boxSize, boxSize, boxSize),\r\n            new THREE.MeshBasicMaterial({ color: this.axisColors.x, transparent: true, opacity: 0.6, depthTest: false })\r\n        );\r\n        xBox.position.set(lineLength, 0, 0);\r\n        xBox.name = \"scaleX\";\r\n        xBox.userData.axis = 'x';\r\n        xBox.userData.gizmoType = 'scale';\r\n        \r\n        // Y axis (green)\r\n        const yLine = new THREE.Line(\r\n            new THREE.BufferGeometry().setFromPoints([\r\n                new THREE.Vector3(0, 0, 0),\r\n                new THREE.Vector3(0, lineLength, 0)\r\n            ]),\r\n            new THREE.LineBasicMaterial({ color: this.axisColors.y, transparent: true, opacity: 0.6, depthTest: false, linewidth: 2 })\r\n        );\r\n        yLine.userData.axis = 'y';\r\n        yLine.userData.gizmoType = 'scale';\r\n        \r\n        const yBox = new THREE.Mesh(\r\n            new THREE.BoxGeometry(boxSize, boxSize, boxSize),\r\n            new THREE.MeshBasicMaterial({ color: this.axisColors.y, transparent: true, opacity: 0.6,  depthTest: false })\r\n        );\r\n        yBox.position.set(0, lineLength, 0);\r\n        yBox.name = \"scaleY\";\r\n        yBox.userData.axis = 'y';\r\n        yBox.userData.gizmoType = 'scale';\r\n        \r\n        // Z axis (blue)\r\n        const zLine = new THREE.Line(\r\n            new THREE.BufferGeometry().setFromPoints([\r\n                new THREE.Vector3(0, 0, 0),\r\n                new THREE.Vector3(0, 0, lineLength)\r\n            ]),\r\n            new THREE.LineBasicMaterial({ color: this.axisColors.z, transparent: true, opacity: 0.6, depthTest: false, linewidth: 2 })\r\n        );\r\n        zLine.userData.axis = 'z';\r\n        zLine.userData.gizmoType = 'scale';\r\n        \r\n        const zBox = new THREE.Mesh(\r\n            new THREE.BoxGeometry(boxSize, boxSize, boxSize),\r\n            new THREE.MeshBasicMaterial({ color: this.axisColors.z, transparent: true, opacity: 0.6, depthTest: false })\r\n        );\r\n        zBox.position.set(0, 0, lineLength);\r\n        zBox.name = \"scaleZ\";\r\n        zBox.userData.axis = 'z';\r\n        zBox.userData.gizmoType = 'scale';\r\n        \r\n        // Uniform scale handle (white)\r\n        const uniformBox = new THREE.Mesh(\r\n            new THREE.BoxGeometry(boxSize * 1.5, boxSize * 1.5, boxSize * 1.5),\r\n            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6,  depthTest: false })\r\n        );\r\n        uniformBox.position.set(0, 0, 0);\r\n        uniformBox.name = \"scaleXYZ\";\r\n        uniformBox.userData.axis = 'xyz';\r\n        uniformBox.userData.gizmoType = 'scale';\r\n        \r\n        group.add(xLine);\r\n        group.add(xBox);\r\n        group.add(yLine);\r\n        group.add(yBox);\r\n        group.add(zLine);\r\n        group.add(zBox);\r\n        group.add(uniformBox);\r\n        \r\n        return group;\r\n    }\r\n    \r\n    setupEventListeners() {\r\n        const canvas = this.renderer.domElement;\r\n        \r\n        canvas.addEventListener('mousemove', this.onMouseMove.bind(this), false);\r\n        canvas.addEventListener('mousedown', this.onMouseDown.bind(this), false);\r\n        canvas.addEventListener('mouseup', this.onMouseUp.bind(this), false);\r\n        \r\n        // Add keyboard shortcuts for switching transform modes\r\n        document.addEventListener('keydown', (event) => {\r\n            if (!this.targetObject) return;\r\n            \r\n            switch (event.key.toLowerCase()) {\r\n                case 'g':\r\n                    this.setMode('translate');\r\n                    break;\r\n                case 'r':\r\n                    this.setMode('rotate');\r\n                    break;\r\n                case 's':\r\n                    this.setMode('scale');\r\n                    break;\r\n            }\r\n        }, false);\r\n    }\r\n    \r\n    onMouseMove(event) {\r\n        // Update mouse position\r\n        const canvas = this.renderer.domElement;\r\n        const rect = canvas.getBoundingClientRect();\r\n        \r\n        this.mouse.x = ((event.clientX - rect.left) / canvas.clientWidth) * 2 - 1;\r\n        this.mouse.y = -((event.clientY - rect.top) / canvas.clientHeight) * 2 + 1;\r\n        \r\n        if (!this.targetObject) return;\r\n        \r\n        if (this.isDragging) {\r\n            this.handleDrag();\r\n        } else {\r\n            this.highlightGizmo();\r\n        }\r\n    }\r\n    \r\n    onMouseDown(event) {\r\n        if (!this.targetObject) return;\r\n        \r\n        const intersectedAxis = this.getIntersectedGizmo();\r\n        if (!intersectedAxis) return;\r\n        \r\n        this.isDragging = true;\r\n        this.selectedAxis = intersectedAxis;\r\n        \r\n        // Store starting position for reference during drag\r\n        this.startPosition.copy(this.targetObject.position);\r\n        this.startRotation.copy(this.targetObject.rotation);\r\n        this.startScale.copy(this.targetObject.scale);\r\n        \r\n        // Disable camera controls during drag\r\n        this.controls.enabled = false;\r\n        \r\n        // Reset drag points for reference\r\n        this.dragStartPoint = this.getPointOnDragPlane();\r\n        \r\n        // Log for debugging\r\n        console.log(`Started dragging ${this.mode} gizmo on axis: ${this.selectedAxis}`);\r\n    }\r\n    \r\n    onMouseUp() {\r\n        if (this.isDragging) {\r\n            this.isDragging = false;\r\n            \r\n            // Re-enable camera controls\r\n            this.controls.enabled = true;\r\n            \r\n            // Update entity data in the SceneEditor\r\n            if (this.targetObject && this.sceneEditor.state.selectedEntity) {\r\n                const entity = this.sceneEditor.state.selectedEntity;\r\n                const transformComponent = entity.components.find(c => c.type === 'transform');\r\n                \r\n                if (transformComponent) {\r\n                    const position = this.targetObject.position;\r\n                    const rotation = this.targetObject.rotation;\r\n                    const scale = this.targetObject.scale;\r\n                    \r\n                    // Update the entity data\r\n                    transformComponent.parameters.position = { x: position.x, y: position.y, z: position.z };\r\n                    transformComponent.parameters.rotation = { x: rotation.x, y: rotation.y, z: rotation.z };\r\n                    transformComponent.parameters.scale = { x: scale.x, y: scale.y, z: scale.z };\r\n                    \r\n                    // Trigger save to update the UI\r\n                    this.sceneEditor.handleSave(false);\r\n                    this.sceneEditor.renderInspector();\r\n                    \r\n                    // Log for debugging\r\n                    console.log(`Updated entity transform:`, {\r\n                        position: transformComponent.parameters.position,\r\n                        rotation: transformComponent.parameters.rotation,\r\n                        scale: transformComponent.parameters.scale\r\n                    });\r\n                }\r\n            }\r\n            \r\n            this.selectedAxis = null;\r\n        }\r\n    }\r\n    \r\n    getIntersectedGizmo() {\r\n        if (!this.gizmoGroup.visible) return null;\r\n        \r\n        this.raycaster.setFromCamera(this.mouse, this.camera);\r\n        \r\n        let activeGizmo;\r\n        switch (this.mode) {\r\n            case 'translate':\r\n                activeGizmo = this.translateGizmo;\r\n                break;\r\n            case 'rotate':\r\n                activeGizmo = this.rotateGizmo;\r\n                break;\r\n            case 'scale':\r\n                activeGizmo = this.scaleGizmo;\r\n                break;\r\n        }\r\n        \r\n        // Get all intersections with the active gizmo and its children\r\n        const intersects = this.raycaster.intersectObject(activeGizmo, true);\r\n        \r\n        if (intersects.length > 0) {\r\n            // The first intersection is the closest one\r\n            const object = intersects[0].object;\r\n            \r\n            // Return the axis from the userData\r\n            if (object.userData.axis) {\r\n                return object.userData.axis;\r\n            }\r\n            \r\n            // Legacy support for objects without userData\r\n            if (object.name.startsWith('translate')) {\r\n                return object.name.charAt(object.name.length - 1).toLowerCase();\r\n            } else if (object.name.startsWith('rotate')) {\r\n                return object.name.charAt(object.name.length - 1).toLowerCase();\r\n            } else if (object.name.startsWith('scale')) {\r\n                return object.name.substring(5).toLowerCase();\r\n            }\r\n            \r\n            // For debugging\r\n            console.log(\"Intersected object:\", object);\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    highlightGizmo() {\r\n        const axis = this.getIntersectedGizmo();\r\n        \r\n        // Reset all gizmos to their original colors\r\n        this.resetGizmoColors();\r\n        \r\n        // Highlight the intersected axis\r\n        if (axis) {\r\n            this.highlightAxis(axis);\r\n        }\r\n    }\r\n    \r\n    resetGizmoColors() {\r\n        // Reset translate gizmo colors\r\n        this.translateGizmo.traverse((object) => {\r\n            if (object.userData.gizmoType === 'translate') {\r\n                if (object.isMesh || object.type === 'Mesh') {\r\n                    object.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n                } else if (object.isLine || object.type === 'Line') {\r\n                    object.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n                } else if (object.type === 'ArrowHelper') {\r\n                    if (object.line) object.line.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n                    if (object.cone) object.cone.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Reset rotate gizmo colors\r\n        this.rotateGizmo.traverse((object) => {\r\n            if (object.userData.gizmoType === 'rotate' && object.material) {\r\n                object.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n            }\r\n        });\r\n        \r\n        // Reset scale gizmo colors\r\n        this.scaleGizmo.traverse((object) => {\r\n            if (object.userData.gizmoType === 'scale' && object.material) {\r\n                if (object.userData.axis === 'xyz') {\r\n                    object.material.color.setHex(0xffffff);\r\n                } else {\r\n                    object.material.color.setHex(this.axisColors[object.userData.axis] || 0xffffff);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    highlightAxis(axis) {\r\n        const highlightColor = this.highlightColor;\r\n        \r\n        switch (this.mode) {\r\n            case 'translate':\r\n                this.translateGizmo.traverse((object) => {\r\n                    if (object.userData.gizmoType === 'translate' && object.userData.axis === axis) {\r\n                        if (object.isMesh || object.type === 'Mesh') {\r\n                            object.material.color.setHex(highlightColor);\r\n                        } else if (object.isLine || object.type === 'Line') {\r\n                            object.material.color.setHex(highlightColor);\r\n                        } else if (object.type === 'ArrowHelper') {\r\n                            if (object.line) object.line.material.color.setHex(highlightColor);\r\n                            if (object.cone) object.cone.material.color.setHex(highlightColor);\r\n                        }\r\n                    }\r\n                });\r\n                break;\r\n                \r\n            case 'rotate':\r\n                this.rotateGizmo.traverse((object) => {\r\n                    if (object.userData.gizmoType === 'rotate' && object.userData.axis === axis && object.material) {\r\n                        object.material.color.setHex(highlightColor);\r\n                    }\r\n                });\r\n                break;\r\n                \r\n            case 'scale':\r\n                this.scaleGizmo.traverse((object) => {\r\n                    if (object.userData.gizmoType === 'scale' && \r\n                        (object.userData.axis === axis || (axis === 'xyz' && object.userData.axis === 'xyz')) && \r\n                        object.material) {\r\n                        object.material.color.setHex(highlightColor);\r\n                    }\r\n                });\r\n                break;\r\n        }\r\n    }\r\n    \r\n    getPointOnDragPlane() {\r\n        // Create a plane based on the camera view and selected axis\r\n        const cameraDirection = new THREE.Vector3();\r\n        this.camera.getWorldDirection(cameraDirection);\r\n        \r\n        let planeNormal;\r\n        \r\n        // Set plane normal based on selected axis and camera direction\r\n        if (this.selectedAxis === 'x') {\r\n            planeNormal = new THREE.Vector3(0, 1, 0);\r\n            if (Math.abs(cameraDirection.dot(planeNormal)) < 0.2) {\r\n                planeNormal.set(0, 0, 1);\r\n            }\r\n        } else if (this.selectedAxis === 'y') {\r\n            planeNormal = new THREE.Vector3(1, 0, 0);\r\n            if (Math.abs(cameraDirection.dot(planeNormal)) < 0.2) {\r\n                planeNormal.set(0, 0, 1);\r\n            }\r\n        } else if (this.selectedAxis === 'z') {\r\n            planeNormal = new THREE.Vector3(1, 0, 0);\r\n            if (Math.abs(cameraDirection.dot(planeNormal)) < 0.2) {\r\n                planeNormal.set(0, 1, 0);\r\n            }\r\n        } else if (this.selectedAxis === 'xyz') {\r\n            planeNormal = cameraDirection;\r\n        }\r\n        \r\n        // Create drag plane\r\n        const plane = new THREE.Plane(planeNormal, -this.targetObject.position.dot(planeNormal));\r\n        \r\n        // Cast ray from mouse and get intersection point with the plane\r\n        this.raycaster.setFromCamera(this.mouse, this.camera);\r\n        \r\n        const intersectionPoint = new THREE.Vector3();\r\n        const didIntersect = this.raycaster.ray.intersectPlane(plane, intersectionPoint);\r\n        \r\n        if (!didIntersect) {\r\n            console.warn(\"Failed to intersect with drag plane\");\r\n            // Return a fallback point to prevent errors\r\n            return this.targetObject.position.clone();\r\n        }\r\n        \r\n        return intersectionPoint;\r\n    }\r\n    \r\n    handleDrag() {\r\n        if (!this.selectedAxis) return;\r\n        \r\n        // Get current point on drag plane\r\n        this.dragCurrentPoint = this.getPointOnDragPlane();\r\n        \r\n        // Calculate delta movement\r\n        const delta = new THREE.Vector3().subVectors(this.dragCurrentPoint, this.dragStartPoint);\r\n        \r\n        switch (this.mode) {\r\n            case 'translate':\r\n                this.handleTranslation(delta);\r\n                break;\r\n            case 'rotate':\r\n                this.handleRotation(delta);\r\n                break;\r\n            case 'scale':\r\n                this.handleScaling(delta);\r\n                break;\r\n        }\r\n        \r\n        // Update gizmo position to match target object\r\n        this.updateGizmoTransform();\r\n        \r\n        // Update the drag start point to prevent accumulation of tiny movements\r\n        this.dragStartPoint = this.dragCurrentPoint;\r\n    }\r\n    \r\n    handleTranslation(delta) {\r\n        // Restrict movement to the selected axis\r\n        let moveVector = new THREE.Vector3();\r\n        \r\n        if (this.selectedAxis === 'x') {\r\n            moveVector.x = delta.x;\r\n        } else if (this.selectedAxis === 'y') {\r\n            moveVector.y = delta.y;\r\n        } else if (this.selectedAxis === 'z') {\r\n            moveVector.z = delta.z;\r\n        } else if (this.selectedAxis === 'xyz') {\r\n            // Allow movement in all directions for xyz\r\n            moveVector.copy(delta);\r\n        }\r\n        \r\n        // Apply the translation\r\n        this.targetObject.position.add(moveVector);\r\n    }\r\n    \r\n    handleRotation(delta) {\r\n        if (!this.targetObject) return;\r\n        \r\n        // Calculate rotation angle based on mouse movement\r\n        const rotationSpeed = 2.0;\r\n        let angle = 0;\r\n        \r\n        // Calculate angle based on the delta movement and distance from center\r\n        switch (this.selectedAxis) {\r\n            case 'x':\r\n                angle = delta.y * rotationSpeed;\r\n                this.targetObject.rotation.x += angle;\r\n                break;\r\n            case 'y':\r\n                angle = delta.x * rotationSpeed;\r\n                this.targetObject.rotation.y += angle;\r\n                break;\r\n            case 'z':\r\n                angle = (delta.x + delta.y) * rotationSpeed;\r\n                this.targetObject.rotation.z += angle;\r\n                break;\r\n            case 'xyz':\r\n                // For free rotation, we would need quaternions and would be more complex\r\n                break;\r\n        }\r\n    }\r\n    \r\n    handleScaling(delta) {\r\n        if (!this.targetObject) return;\r\n        \r\n        // Calculate scaling factor based on mouse movement\r\n        // Use the dot product of delta and direction from object to camera to determine increase/decrease\r\n        const cameraDelta = new THREE.Vector3().subVectors(this.camera.position, this.targetObject.position).normalize();\r\n        const scaleDirection = Math.sign(delta.dot(cameraDelta));\r\n        \r\n        // Adjust scaling sensitivity\r\n        const scaleFactor = 1 + delta.length() * scaleDirection * 0.1;\r\n        \r\n        // Apply scale based on selected axis\r\n        if (this.selectedAxis === 'xyz') {\r\n            // Uniform scaling\r\n            this.targetObject.scale.multiplyScalar(scaleFactor);\r\n        } else {\r\n            // Scale along specific axis\r\n            if (this.selectedAxis === 'x') {\r\n                this.targetObject.scale.x *= scaleFactor;\r\n            } else if (this.selectedAxis === 'y') {\r\n                this.targetObject.scale.y *= scaleFactor;\r\n            } else if (this.selectedAxis === 'z') {\r\n                this.targetObject.scale.z *= scaleFactor;\r\n            }\r\n        }\r\n    }\r\n    \r\n    attach(object) {\r\n        if (!object) return;\r\n        \r\n        this.detach(); // Detach from previous object if any\r\n        \r\n        this.targetObject = object;\r\n        this.updateGizmoTransform();\r\n        \r\n        // Show the active gizmo\r\n        this.gizmoGroup.visible = true;\r\n        this.setMode(this.mode);\r\n        \r\n        console.log(\"Attached gizmo to:\", object.name);\r\n    }\r\n    \r\n    detach() {\r\n        if (this.isDragging) {\r\n            this.onMouseUp(); // End any active drag operation\r\n        }\r\n        \r\n        this.targetObject = null;\r\n        this.gizmoGroup.visible = false;\r\n        this.translateGizmo.visible = false;\r\n        this.rotateGizmo.visible = false;\r\n        this.scaleGizmo.visible = false;\r\n    }\r\n    \r\n    setMode(mode) {\r\n        this.mode = mode;\r\n        \r\n        // Hide all gizmos\r\n        this.translateGizmo.visible = false;\r\n        this.rotateGizmo.visible = false;\r\n        this.scaleGizmo.visible = false;\r\n        \r\n        // Show the selected gizmo\r\n        switch (mode) {\r\n            case 'translate':\r\n                this.translateGizmo.visible = true;\r\n                break;\r\n            case 'rotate':\r\n                this.rotateGizmo.visible = true;\r\n                break;\r\n            case 'scale':\r\n                this.scaleGizmo.visible = true;\r\n                break;\r\n        }\r\n        \r\n        console.log(`Set gizmo mode: ${mode}`);\r\n    }\r\n    \r\n    updateGizmoTransform() {\r\n        if (!this.targetObject) return;\r\n        \r\n        // Update position to match target object\r\n        this.gizmoGroup.position.copy(this.targetObject.position);\r\n        \r\n        // Calculate appropriate scale for the gizmo based on camera distance\r\n        const distance = this.camera.position.distanceTo(this.gizmoGroup.position);\r\n        const scale = distance / 20; // Adjusted for better visibility\r\n        \r\n        this.gizmoGroup.scale.set(scale, scale, scale);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/SE_GizmoManager.js",
        "fileName": "SE_GizmoManager"
      },
      "CodeMirror.js.min.js": {
        "title": "CodeMirror.js.min.js",
        "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js",
        "className": "CodeMirror.js",
        "fileName": "CodeMirror.js.min.js"
      },
      "socket.io.min.js": {
        "title": "Socket.IO",
        "fileName": "socket.io.min.js",
        "href": "https://cdn.socket.io/4.7.2/socket.io.min.js",
        "isModule": true
      },
      "threejs": {
        "title": "THREE",
        "filePath": "/node_modules/three/build/three.module.min.js",
        "requireName": "THREE",
        "importName": "three",
        "fileName": "threejs",
        "windowName": "THREE",
        "isModule": true
      },
      "three_RenderPixelatedPass": {
        "title": "THREE.RenderPixelatedPass",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "RenderPixelatedPass",
        "importName": "RenderPixelatedPass",
        "fileName": "three_RenderPixelatedPass"
      },
      "BaseECSGame": {
        "script": "class BaseECSGame {\r\n    constructor(app) {\r\n        this.app = app;\r\n        this.state = null; // Will be set by subclasses\r\n        this.sceneManager = null; // Will be set by subclasses\r\n        this.moduleManager = app.moduleManager;\r\n        \r\n        this.entityId = 0;\r\n        this.entitiesToAdd = [];\r\n        this.entities = new Map();\r\n        this.components = new Map();\r\n        this.classes = [];\r\n        this.systems = [];\r\n        \r\n        this.nextEntityId = 1;\r\n        this.lastTime = 0;\r\n        this.currentTime = 0;\r\n        this.deltaTime = 0;\r\n\r\n        this.isServer = false;        \r\n\r\n        this.componentTypes = null;\r\n    }\r\n    init() {\r\n        if(document){\r\n            document.addEventListener('keydown', (e) => {                \r\n                this.triggerEvent('onKeyDown', e.key);\r\n            });\r\n        }\r\n    }\r\n    getEntityId() {\r\n        return this.nextEntityId++;\r\n    }\r\n    getCollections() {\r\n        return this.app.getCollections();\r\n    }\r\n\r\n    async update(deltaTime) {\r\n  \r\n        if (!this.state.isPaused) {\r\n            this.currentTime = this.currentTime + deltaTime;\r\n\r\n            // Only update if a reasonable amount of time has passed\r\n            // const timeSinceLastUpdate = this.currentTime - this.lastTime;\r\n\r\n            // // Skip update if more than 1 second has passed (tab was inactive)\r\n            // if (timeSinceLastUpdate > 1000) {\r\n            //     this.lastTime = this.currentTime; // Reset timer without updating\r\n            //     return;\r\n            // }\r\n            this.state.now = this.currentTime;\r\n            this.state.deltaTime = deltaTime;\r\n            this.deltaTime = deltaTime;        \r\n\r\n            this.systems.forEach(async system => {\r\n                if (system.update) {\r\n                    await system.update();\r\n                }\r\n                if(system.render && !this.isServer){\r\n                    await system.render();\r\n                }\r\n            });\r\n            \r\n            this.postUpdate();\r\n        }     \r\n    }\r\n\r\n    postUpdate() {\r\n       // this.desyncDebugger?.displaySync(false); \r\n       \r\n        this.lastTime = this.currentTime;\r\n    \r\n        this.entitiesToAdd.forEach((entity) => this.addEntity(entity));        \r\n        this.entitiesToAdd = [];\r\n        \r\n    }\r\n\r\n    createEntity(setId) {\r\n        const id = setId || this.getEntityId();\r\n        this.entities.set(id, new Set());\r\n        return id;\r\n    }\r\n    \r\n    destroyEntity(entityId) {\r\n        if (this.entities.has(entityId)) {\r\n\r\n            this.systems.forEach(system => {\r\n                if (system.entityDestroyed) {\r\n                    system.entityDestroyed(entityId);                    \r\n                }\r\n            });\r\n\r\n            const componentTypes = this.entities.get(entityId);\r\n            componentTypes.forEach(type => {\r\n                this.removeComponent(entityId, type);\r\n            });\r\n            this.entities.delete(entityId);\r\n        }\r\n    }\r\n    \r\n    addComponent(entityId, componentId, componentData) {\r\n        if (!this.entities.has(entityId)) {\r\n            throw new Error(`Entity ${entityId} does not exist`);\r\n        }\r\n        \r\n        if (!this.components.has(componentId)) {\r\n            this.components.set(componentId, new Map());\r\n        }\r\n        \r\n        this.components.get(componentId).set(entityId, componentData);\r\n        this.entities.get(entityId).add(componentId);\r\n    }\r\n    \r\n    removeComponent(entityId, componentType) {\r\n        let component = this.getComponent(entityId, componentType);\r\n        if (this.components.has(componentType)) {\r\n            this.components.get(componentType).delete(entityId);\r\n        }\r\n        if (this.entities.has(entityId)) {\r\n            this.entities.get(entityId).delete(componentType);\r\n        }\r\n        return component;\r\n    }\r\n    \r\n    getComponent(entityId, componentType) {\r\n        if (this.components.has(componentType)) {\r\n            return this.components.get(componentType).get(entityId);\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    hasComponent(entityId, componentType) {\r\n        return this.components.has(componentType) && \r\n                this.components.get(componentType).has(entityId);\r\n    }\r\n    \r\n    getEntitiesWith(...componentTypes) {\r\n        const result = [];\r\n        for (const [entityId, entityComponents] of this.entities) {\r\n            if (componentTypes.every(type => entityComponents.has(type))) {\r\n                result.push(entityId);\r\n            }\r\n        }\r\n        return result.sort((a, b) => String(a).localeCompare(String(b)));\r\n    }\r\n    \r\n    addSystem(system, params) {\r\n        system.game = this;\r\n        this.systems.push(system);\r\n        if (system.init) {\r\n            system.init(params);\r\n        }\r\n    }\r\n\r\n    addClass(classId, classRef, params) {\r\n        this.classes[classId] = { classRef: classRef, defaultParams: params };\r\n        this.app.appClasses[classId] = classRef;\r\n    }\r\n\r\n\r\n    triggerEvent(eventName, data) {\r\n        this.systems.forEach(system => {\r\n            if (system[eventName]) {\r\n                system[eventName](data);\r\n            }\r\n        });\r\n    }\r\n\r\n    gameOver() {\r\n        this.state.gameOver = true;\r\n    }\r\n\r\n    gameVictory() {\r\n        this.state.victory = true;\r\n    }\r\n    resetCurrentTime() {\r\n        this.state.now = 0;\r\n        this.lastTime = 0;\r\n        this.currentTime = 0;     \r\n    }\r\n}\r\n\r\nif(typeof BaseECSGame != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.BaseECSGame = BaseECSGame;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = BaseECSGame;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = BaseECSGame;\r\n        exports.BaseECSGame = BaseECSGame;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/BaseECSGame.js",
        "fileName": "BaseECSGame"
      },
      "CompilerModule": {
        "script": "class CompilerModule {\r\n    constructor(app, config, libraries) {\r\n        this.app = app;\r\n        this.config = config;\r\n        this.libraries = libraries;\r\n        this.compiler = null;\r\n        this.currentCompilation = null;\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.compiler = new GUTS.Compiler(this.app);\r\n        this.setupUI();\r\n    }\r\n\r\n    setupUI() {\r\n        const toolbar = document.querySelector('.sidebar-actions');\r\n        if (!toolbar) return;\r\n\r\n        const compileBtn = document.createElement('button');\r\n        compileBtn.innerHTML = ' Compile';\r\n        compileBtn.onclick = () => this.openCompilerDialog();\r\n        \r\n        toolbar.appendChild(compileBtn);\r\n    }\r\n\r\n    openCompilerDialog() {\r\n        document.getElementById('modal-compilerModal')?.classList.add('show');\r\n        window.compilerModule = this;\r\n    }\r\n\r\n    async compile() {\r\n        const projectName = this.app.model.state.currentProject;\r\n        const includeMetadata = document.getElementById('compileIncludeMetadata').checked;\r\n        const includeEngine = document.getElementById('compileIncludeEngine')?.checked ?? true;\r\n        const createZip = document.getElementById('compileCreateZip')?.checked ?? true; // NEW\r\n\r\n        const output = document.getElementById('compilationOutput');\r\n        const log = document.getElementById('compilationLog');\r\n        \r\n        output.style.display = 'block';\r\n        log.textContent = 'Starting compilation...\\n';\r\n\r\n        try {\r\n            log.textContent += 'Loading project configuration...\\n';\r\n            \r\n            const enginePaths = includeEngine ? {\r\n                moduleManager: './../../engine/ModuleManager.js',\r\n                baseEngine: './../../engine/BaseEngine.js',\r\n                engine: './../../engine/Engine.js'\r\n            } : null;\r\n            \r\n            const result = await this.compiler.compile(\r\n                projectName, \r\n                this.app.getCollections(),\r\n                enginePaths\r\n            );\r\n            \r\n            log.textContent += ` Compiled ${result.classRegistry.systems.length} systems\\n`;\r\n            log.textContent += ` Compiled ${result.classRegistry.managers.length} managers\\n`;\r\n            log.textContent += ` Compiled ${result.classRegistry.components.length} components\\n`;\r\n            log.textContent += ` Compiled ${result.classRegistry.functions.length} functions\\n`;\r\n            log.textContent += ` Game bundle: ${Math.round(result.code.length / 1024)} KB\\n`;\r\n            \r\n            if (result.engineCode) {\r\n                log.textContent += ` Engine bundle: ${Math.round(result.engineCode.length / 1024)} KB\\n`;\r\n            }\r\n            \r\n            log.textContent += '\\n';\r\n\r\n            // Create downloads (individual files or zip)\r\n            if (createZip) {\r\n                await this.createZipDownload(result);\r\n                log.textContent += ' Created zip bundle!\\n';\r\n            } else {\r\n                this.createDownloads(result, includeMetadata);\r\n            }\r\n            \r\n            log.textContent += ' Compilation complete!\\n';\r\n            log.textContent += 'Download links created above.\\n';\r\n\r\n            this.currentCompilation = result;\r\n\r\n        } catch (error) {\r\n            log.textContent += `\\n Error: ${error.message}\\n`;\r\n            console.error(error);\r\n        }\r\n    }\r\n\r\n    async createZipDownload(result) {\r\n        const modal = document.querySelector('#modal-compilerModal .modal-body');\r\n        \r\n        const oldSection = modal.querySelector('.downloads-section');\r\n        if (oldSection) oldSection.remove();\r\n\r\n        const downloads = document.createElement('div');\r\n        downloads.className = 'downloads-section';\r\n        downloads.innerHTML = '<h3>Download Files:</h3>';\r\n\r\n        try {\r\n            // Create zip bundle\r\n            const zipBlob = await this.compiler.createZipBundle(result);\r\n            \r\n            // Create download link\r\n            const zipUrl = URL.createObjectURL(zipBlob);\r\n            const zipLink = document.createElement('a');\r\n            zipLink.href = zipUrl;\r\n            zipLink.download = `${result.projectName.toLowerCase().replace(/\\s+/g, '-')}-compiled.zip`;\r\n            zipLink.textContent = ` ${result.projectName}-compiled.zip (${Math.round(zipBlob.size / 1024)} KB)`;\r\n            zipLink.className = 'download-link';\r\n            downloads.appendChild(zipLink);\r\n            \r\n        } catch (error) {\r\n            downloads.innerHTML += `<p style=\"color: red;\">Error creating zip: ${error.message}</p>`;\r\n        }\r\n\r\n        modal.insertBefore(downloads, document.getElementById('compilationOutput'));\r\n    }\r\n\r\n    createDownloads(result, includeMetadata) {\r\n        const modal = document.querySelector('#modal-compilerModal .modal-body');\r\n        const outputName = \"game.js\";\r\n        const oldSection = modal.querySelector('.downloads-section');\r\n        if (oldSection) oldSection.remove();\r\n\r\n        const downloads = document.createElement('div');\r\n        downloads.className = 'downloads-section';\r\n        downloads.innerHTML = '<h3>Download Files:</h3>';\r\n\r\n        // Game bundle\r\n        const bundleBlob = new Blob([result.engineCode + \"\\n\\n\" + result.code], { type: 'application/javascript' });\r\n        const bundleUrl = URL.createObjectURL(bundleBlob);\r\n        const bundleLink = document.createElement('a');\r\n        bundleLink.href = bundleUrl;\r\n        bundleLink.download = outputName;\r\n        bundleLink.textContent = ` ${outputName}`;\r\n        bundleLink.className = 'download-link';\r\n        downloads.appendChild(bundleLink);\r\n        downloads.appendChild(document.createElement('br'));\r\n\r\n        // // Engine bundle\r\n        // if (result.engineCode) {\r\n        //     const engineBlob = new Blob([result.engineCode], { type: 'application/javascript' });\r\n        //     const engineUrl = URL.createObjectURL(engineBlob);\r\n        //     const engineLink = document.createElement('a');\r\n        //     engineLink.href = engineUrl;\r\n        //     engineLink.download = 'engine.js';\r\n        //     engineLink.textContent = ` engine.js`;\r\n        //     engineLink.className = 'download-link';\r\n        //     downloads.appendChild(engineLink);\r\n        //     downloads.appendChild(document.createElement('br'));\r\n        // }\r\n\r\n        // Metadata\r\n        if (includeMetadata) {\r\n            const metadata = {\r\n                projectName: result.projectName,\r\n                timestamp: result.timestamp,\r\n                classRegistry: result.classRegistry,\r\n                dependencies: result.dependencies\r\n            };\r\n            const metaBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });\r\n            const metaUrl = URL.createObjectURL(metaBlob);\r\n            const metaLink = document.createElement('a');\r\n            metaLink.href = metaUrl;\r\n            metaLink.download = outputName.replace('.js', '.meta.json');\r\n            metaLink.textContent = ` ${outputName.replace('.js', '.meta.json')}`;\r\n            metaLink.className = 'download-link';\r\n            downloads.appendChild(metaLink);\r\n            downloads.appendChild(document.createElement('br'));\r\n        }\r\n\r\n        modal.insertBefore(downloads, document.getElementById('compilationOutput'));\r\n    }\r\n\r\n    async quickCompile() {\r\n        if (!this.app.currentProject) {\r\n            alert('No project loaded');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            console.log('Quick compiling...');\r\n            const result = await this.compiler.compile(\r\n                this.app.currentProject,\r\n                this.app.getCollections()\r\n            );\r\n            \r\n            const blob = new Blob([result.code], { type: 'application/javascript' });\r\n            const url = URL.createObjectURL(blob);\r\n            const a = document.createElement('a');\r\n            a.href = url;\r\n            a.download = `${this.app.currentProject.toLowerCase()}-compiled.js`;\r\n            a.click();\r\n            \r\n            console.log('Quick compile complete!', result);\r\n            alert(`Compiled successfully!\\nBundle size: ${Math.round(result.code.length / 1024)} KB`);\r\n\r\n        } catch (error) {\r\n            console.error('Quick compile failed:', error);\r\n            alert(`Compilation failed: ${error.message}`);\r\n        }\r\n    }\r\n}\r\n\r\nif(typeof CompilerModule != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.CompilerModule = CompilerModule;    \r\n    }\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = { CompilerModule, compilerModuleDefinition, compilerCSS };\r\n    }\r\n}",
        "filePath": "/global/libraries/js/CompilerModule.js",
        "fileName": "CompilerModule"
      },
      "ServerECSGame": {
        "script": "class ServerECSGame extends global.GUTS.BaseECSGame {\r\n    constructor(app) {\r\n        super(app);\r\n        this.state = new global.GUTS.GameState(this.getCollections());\r\n        this.sceneManager = new global.GUTS.ServerSceneManager(this);\r\n        this.moduleManager = app.moduleManager;\r\n        this.desyncDebugger = new global.GUTS.DesyncDebugger(this);        \r\n        this.serverEventManager = new global.GUTS.ServerEventManager(this);\r\n        this.isServer = true;\r\n    }\r\n\r\n\r\n}\r\n      \r\nif(typeof ServerECSGame != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.ServerECSGame = ServerECSGame;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = ServerECSGame;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = ServerECSGame;\r\n        exports.ServerECSGame = ServerECSGame;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ServerECSGame.js",
        "fileName": "ServerECSGame"
      },
      "ServerSceneManager": {
        "script": "export default class ServerSceneManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.state.currentScene = null;\r\n        this.currentSceneData = null;\r\n        this.currentSceneName = null;\r\n    }\r\n\r\n    load(sceneName) {\r\n        console.log(\"load scene\", sceneName);\r\n        this.currentSceneName = sceneName;\r\n        this.currentSceneData = this.game.getCollections().scenes[this.currentSceneName];\r\n\r\n        if (this.currentSceneData.type === \"ECS\") {\r\n            return this.loadECS();\r\n        }\r\n\r\n        console.log(`Loaded server scene: ${sceneName}`);\r\n    }\r\n\r\n    loadECS() {\r\n        const sceneEntities = this.currentSceneData.sceneData;\r\n        \r\n        sceneEntities.forEach(async (sceneEntity) => {\r\n            // Load classes\r\n            sceneEntity.classes.forEach((sceneClassDef) => {\r\n                const collectionName = sceneClassDef.collection;\r\n                const baseClassId = sceneClassDef.baseClass;\r\n                const classCollection = this.game.getCollections()[collectionName];\r\n                \r\n                if (baseClassId) {\r\n                    const collectionClassDef = classCollection[baseClassId];\r\n                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters };\r\n                    const BaseClassDef = this.game.moduleManager.getCompiledScript(baseClassId, collectionName);\r\n                    this.game.addClass(baseClassId, BaseClassDef, params);\r\n                }\r\n                \r\n                for (const collectionClassId in classCollection) {\r\n                    if (baseClassId && collectionClassId === baseClassId) continue;\r\n                    \r\n                    const collectionClassDef = classCollection[collectionClassId];\r\n                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters };\r\n                    const ClassDef = this.game.moduleManager.getCompiledScript(collectionClassId, collectionName);\r\n                    this.game.addClass(collectionClassId, ClassDef, params);\r\n                }\r\n            });\r\n\r\n            // Load managers (no canvas needed)\r\n            sceneEntity.managers.forEach((managerDef) => {\r\n                let params = { ...managerDef.parameters };\r\n                const ManagerClass = this.game.moduleManager.getCompiledScript(managerDef.type, 'managers');\r\n                const managerInst = new ManagerClass(this.game, true);\r\n                if (managerInst.init) {\r\n                    managerInst.init(params);\r\n                }\r\n            });\r\n\r\n            // Load systems (server-specific systems only)\r\n            sceneEntity.systems.forEach((systemDef) => {\r\n                let params = { ...systemDef.parameters };\r\n                const SystemClass = this.game.moduleManager.getCompiledScript(systemDef.type, 'systems');\r\n                const systemInst = new SystemClass(this.game, true);\r\n                this.game.addSystem(systemInst, params);\r\n            });\r\n        });\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ServerSceneManager.js",
        "fileName": "ServerSceneManager"
      },
      "ServerMatchmakingService": {
        "script": "// MatchmakingService.js - Server-level service (not a game system)\r\nexport default class ServerMatchmakingService {\r\n    constructor(engine) {\r\n        this.engine = engine;\r\n        \r\n        // Matchmaking pool management\r\n        this.matchmakingPool = new Map(); // playerId -> { playerName, timestamp, playerId }\r\n        this.nextRoomId = 1000;\r\n        \r\n        // Timing for periodic operations\r\n        this.lastPoolCheck = 0;\r\n        this.poolCheckInterval = 2000; // Check every 2 seconds\r\n        this.lastPoolUpdate = 0;\r\n        this.poolUpdateInterval = 5000; // Update waiting players every 5 seconds\r\n        this.maxWaitTime = 60000; // Remove stale requests after 60 seconds\r\n        \r\n        // Subscribe to network events\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    // =============================================\r\n    // ENGINE-LEVEL UPDATE FUNCTION\r\n    // =============================================\r\n\r\n    update(deltaTime, currentTime) {\r\n        // Check for matches periodically\r\n        if (currentTime - this.lastPoolCheck >= this.poolCheckInterval) {\r\n            this.processMatchmakingPool();\r\n            this.lastPoolCheck = currentTime;\r\n        }\r\n\r\n        // Update waiting players with current status\r\n        if (currentTime - this.lastPoolUpdate >= this.poolUpdateInterval) {\r\n            this.updateWaitingPlayers();\r\n            this.lastPoolUpdate = currentTime;\r\n        }\r\n\r\n        // Clean up stale matchmaking requests\r\n        this.cleanupStaleRequests(currentTime);\r\n    }\r\n\r\n    // =============================================\r\n    // EVENT LISTENERS\r\n    // =============================================\r\n\r\n    setupEventListeners() {\r\n        if (!this.engine.serverEventManager) {\r\n            console.error('No server event manager found');\r\n            return;\r\n        }\r\n\r\n        // Subscribe to matchmaking events\r\n        this.engine.serverEventManager.subscribe('QUICK_MATCH', this.handleQuickMatch.bind(this));\r\n        this.engine.serverEventManager.subscribe('CANCEL_MATCHMAKING', this.handleCancelMatchmaking.bind(this));\r\n        this.engine.serverEventManager.subscribe('PLAYER_DISCONNECT', this.handlePlayerDisconnect.bind(this));\r\n    }\r\n\r\n    // =============================================\r\n    // MATCHMAKING POOL MANAGEMENT\r\n    // =============================================\r\n\r\n    addToMatchmakingPool(playerId, playerName) {\r\n        // Check if player is already in a room\r\n        if (this.findPlayerRoom(playerId)) {\r\n            return {\r\n                success: false,\r\n                error: 'Player already in a game room'\r\n            };\r\n        }\r\n\r\n        // Check if player is already in pool\r\n        if (this.matchmakingPool.has(playerId)) {\r\n            return {\r\n                success: false,\r\n                error: 'Player already searching for a match'\r\n            };\r\n        }\r\n\r\n        this.matchmakingPool.set(playerId, {\r\n            playerId,\r\n            playerName: playerName || `Player ${playerId.substr(-4)}`,\r\n            timestamp: Date.now()\r\n        });\r\n        \r\n        console.log(`Player ${playerName} added to matchmaking pool. Pool size: ${this.matchmakingPool.size}`);\r\n        \r\n        // Send confirmation to player\r\n        this.engine.serverNetworkManager.sendToPlayer(playerId, 'MATCHMAKING_SEARCHING', {\r\n            message: 'Searching for opponent...',\r\n            playersInPool: this.matchmakingPool.size\r\n        });\r\n        \r\n        return { success: true };\r\n    }\r\n\r\n    removeFromMatchmakingPool(playerId) {\r\n        const removed = this.matchmakingPool.delete(playerId);\r\n        if (removed) {\r\n            console.log(`Player removed from matchmaking pool. Pool size: ${this.matchmakingPool.size}`);\r\n        }\r\n        return removed;\r\n    }\r\n\r\n    processMatchmakingPool() {\r\n        if (this.matchmakingPool.size < 2) {\r\n            return; // Need at least 2 players\r\n        }\r\n\r\n        // Get two players from the pool (first come, first served)\r\n        const players = Array.from(this.matchmakingPool.values());\r\n        const player1 = players[0];\r\n        const player2 = players[1];\r\n\r\n        // Remove matched players from pool\r\n        this.removeFromMatchmakingPool(player1.playerId);\r\n        this.removeFromMatchmakingPool(player2.playerId);\r\n\r\n        // Create a new room for these players\r\n        this.createMatchmadeRoom(player1, player2);\r\n    }\r\n\r\n    updateWaitingPlayers() {\r\n        if (this.matchmakingPool.size === 0) return;\r\n\r\n        // Send updates to all players in the pool\r\n        for (const [playerId, playerData] of this.matchmakingPool) {\r\n            const currentTime = Date.now();\r\n            const waitTime = Math.floor((currentTime - playerData.timestamp) / 1000);\r\n            \r\n            this.engine.serverNetworkManager.sendToPlayer(playerId, 'MATCHMAKING_SEARCHING', {\r\n                message: this.matchmakingPool.size === 1 ? \r\n                    'Waiting for another player...' : \r\n                    `Found ${this.matchmakingPool.size} players searching...`,\r\n                playersInPool: this.matchmakingPool.size,\r\n                waitTime: waitTime\r\n            });\r\n        }\r\n    }\r\n\r\n    cleanupStaleRequests(currentTime) {\r\n        const toRemove = [];\r\n        \r\n        for (const [playerId, playerData] of this.matchmakingPool) {\r\n            const waitTime = currentTime - playerData.timestamp;\r\n            if (waitTime > this.maxWaitTime) {\r\n                toRemove.push(playerId);\r\n            }\r\n        }\r\n        \r\n        toRemove.forEach(playerId => {\r\n            this.removeFromMatchmakingPool(playerId);\r\n            this.engine.serverNetworkManager.sendToPlayer(playerId, 'MATCHMAKING_CANCELLED', {\r\n                message: 'Matchmaking request timed out'\r\n            });\r\n        });\r\n    }\r\n\r\n    // =============================================\r\n    // ROOM CREATION\r\n    // =============================================\r\n\r\n    createMatchmadeRoom(player1, player2) {\r\n        try {\r\n            // Generate room ID\r\n            const roomId = this.generateRoomId();\r\n            \r\n            // Create new game room using the engine's method\r\n            const room = this.engine.createGameRoom(roomId, 2);\r\n            \r\n            if (!room) {\r\n                console.error('Failed to create game room');\r\n                // Return players to pool if room creation fails\r\n                this.addToMatchmakingPool(player1.playerId, player1.playerName);\r\n                this.addToMatchmakingPool(player2.playerId, player2.playerName);\r\n                return;\r\n            }\r\n\r\n            // Add both players to the room\r\n            const result1 = room.addPlayer(player1.playerId, {\r\n                name: player1.playerName,\r\n                isHost: true\r\n            });\r\n\r\n            const result2 = room.addPlayer(player2.playerId, {\r\n                name: player2.playerName,\r\n                isHost: false\r\n            });\r\n\r\n            if (result1.success && result2.success) {\r\n                // Join both players to the room via network manager\r\n                this.engine.serverNetworkManager.joinRoom(player1.playerId, roomId);\r\n                this.engine.serverNetworkManager.joinRoom(player2.playerId, roomId);\r\n\r\n                // Send match found messages\r\n                this.engine.serverNetworkManager.sendToPlayer(player1.playerId, 'QUICK_MATCH_FOUND', {\r\n                    roomId: roomId,\r\n                    playerId: player1.playerId,\r\n                    isHost: true,\r\n                    gameState: room.getGameState(),\r\n                    opponent: player2.playerName\r\n                });\r\n\r\n                this.engine.serverNetworkManager.sendToPlayer(player2.playerId, 'QUICK_MATCH_FOUND', {\r\n                    roomId: roomId,\r\n                    playerId: player2.playerId,\r\n                    isHost: false,\r\n                    gameState: room.getGameState(),\r\n                    opponent: player1.playerName\r\n                });\r\n\r\n                console.log(`Match created: ${player1.playerName} vs ${player2.playerName} in room ${roomId}`);\r\n            } else {\r\n                // If adding players failed, return them to pool\r\n                console.error('Failed to add players to room:', result1, result2);\r\n                this.addToMatchmakingPool(player1.playerId, player1.playerName);\r\n                this.addToMatchmakingPool(player2.playerId, player2.playerName);\r\n                \r\n                // Clean up the room if it was created\r\n                this.engine.gameRooms.delete(roomId);\r\n            }\r\n        } catch (error) {\r\n            console.error('Error creating matchmade room:', error);\r\n            // Return players to pool\r\n            this.addToMatchmakingPool(player1.playerId, player1.playerName);\r\n            this.addToMatchmakingPool(player2.playerId, player2.playerName);\r\n        }\r\n    }\r\n\r\n    // =============================================\r\n    // EVENT HANDLERS\r\n    // =============================================\r\n\r\n    handleQuickMatch(eventData) {\r\n        const { playerId, data } = eventData;\r\n        \r\n        try {\r\n            const { playerName } = data;\r\n            \r\n            const result = this.addToMatchmakingPool(playerId, playerName);\r\n            \r\n            if (!result.success) {\r\n                this.engine.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { \r\n                    error: result.error \r\n                });\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error('Error in quick match:', error);\r\n            this.engine.serverNetworkManager.sendToPlayer(playerId, 'QUICK_MATCH_FAILED', { \r\n                error: 'Server error during quick match' \r\n            });\r\n        }\r\n    }\r\n\r\n    handleCancelMatchmaking(eventData) {\r\n        const { playerId } = eventData;\r\n        \r\n        const removed = this.removeFromMatchmakingPool(playerId);\r\n        if (removed) {\r\n            this.engine.serverNetworkManager.sendToPlayer(playerId, 'MATCHMAKING_CANCELLED', {\r\n                message: 'Matchmaking cancelled'\r\n            });\r\n        }\r\n    }\r\n\r\n    handlePlayerDisconnect(eventData) {\r\n        const { playerId } = eventData;\r\n        \r\n        // Remove from matchmaking pool if they were searching\r\n        this.removeFromMatchmakingPool(playerId);\r\n    }\r\n\r\n    // =============================================\r\n    // UTILITY METHODS\r\n    // =============================================\r\n\r\n    findPlayerRoom(playerId) {\r\n        for (const [roomId, room] of this.engine.gameRooms) {\r\n            if (room.players && room.players.has(playerId)) {\r\n                return room;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    generateRoomId() {\r\n        let roomId;\r\n        do {\r\n            roomId = (Math.floor(Math.random() * 9000) + 1000).toString();\r\n        } while (this.engine.gameRooms.has(roomId));\r\n        return roomId;\r\n    }\r\n\r\n    getMatchmakingStats() {\r\n        const totalPlayersInRooms = Array.from(this.engine.gameRooms.values())\r\n            .reduce((total, room) => total + (room.players ? room.players.size : 0), 0);\r\n            \r\n        return {\r\n            playersInPool: this.matchmakingPool.size,\r\n            activeRooms: this.engine.gameRooms.size,\r\n            playersInRooms: totalPlayersInRooms,\r\n            totalPlayers: totalPlayersInRooms + this.matchmakingPool.size\r\n        };\r\n    }\r\n\r\n    // =============================================\r\n    // CLEANUP\r\n    // =============================================\r\n\r\n    destroy() {\r\n        // Notify all players in pool that matchmaking is shutting down\r\n        for (const [playerId, player] of this.matchmakingPool) {\r\n            this.engine.serverNetworkManager.sendToPlayer(playerId, 'MATCHMAKING_CANCELLED', {\r\n                message: 'Server shutting down'\r\n            });\r\n        }\r\n        \r\n        this.matchmakingPool.clear();\r\n        console.log('MatchmakingService destroyed');\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ServerMatchmakingService.js",
        "fileName": "ServerMatchmakingService"
      },
      "InstancePool": {
        "script": "class InstancePool {\r\n    constructor(geometry, material, initialSize) {\r\n        this.mesh = new THREE.InstancedMesh(geometry, material, initialSize);\r\n        this.mesh.count = 0;\r\n        this.freeIndices = [];\r\n        this.maxIndex = 0;\r\n    }\r\n\r\n    addInstance(matrix) {\r\n        let index;\r\n        if (this.freeIndices.length > 0) {\r\n            index = this.freeIndices.pop();\r\n        } else {\r\n            index = this.maxIndex++;\r\n            if (index >= this.mesh.instanceMatrix.count) {\r\n                this.expandPool(Math.max(this.mesh.count * 2, 100));\r\n            }\r\n        }\r\n\r\n        this.mesh.setMatrixAt(index, matrix);\r\n        this.mesh.count = Math.max(this.mesh.count, index + 1);\r\n        this.mesh.instanceMatrix.needsUpdate = true;\r\n        return index;\r\n    }\r\n\r\n    removeInstance(index) {\r\n        this.freeIndices.push(index);\r\n        // Set identity matrix to hide instance\r\n        this.mesh.setMatrixAt(index, new THREE.Matrix4());\r\n        this.mesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n\r\n    expandPool(additionalSize) {\r\n        const newCount = this.mesh.instanceMatrix.count + additionalSize;\r\n        const newMesh = new THREE.InstancedMesh(\r\n            this.mesh.geometry,\r\n            this.mesh.material,\r\n            newCount\r\n        );\r\n        \r\n        newMesh.instanceMatrix.copy(this.mesh.instanceMatrix);\r\n        newMesh.count = this.mesh.count;\r\n        this.mesh.dispose();\r\n        this.mesh = newMesh;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/InstancePool.js",
        "fileName": "InstancePool"
      },
      "ClientNetworkManager": {
        "script": "class ClientNetworkManager {\r\n    constructor(game, options = {}) {\r\n        this.game = game;\r\n        this.game.clientNetworkManager = this;\r\n        this.socket = null;\r\n        this.isConnected = false;\r\n        \r\n        // Configuration\r\n        this.serverUrl = options.serverUrl || this.game.getCollections().configs.multiplayer.serverUrl;\r\n        this.reconnectAttempts = 0;\r\n        this.maxReconnectAttempts = options.maxReconnectAttempts || 5;\r\n        this.reconnectDelay = options.reconnectDelay || 1000;\r\n        this.callTimeout = options.callTimeout || 10000;\r\n        \r\n        // Event system\r\n        this.listeners = new Map(); // eventName -> Set of callbacks\r\n        this.oneTimeCallbacks = new Map(); // eventName -> Map of callbackId -> callback\r\n        this.callbackCounter = 0;\r\n        \r\n    }\r\n\r\n    // =============================================\r\n    // CONNECTION MANAGEMENT\r\n    // =============================================\r\n\r\n    async connect(serverUrl = null) {\r\n        if (serverUrl) {\r\n            this.serverUrl = serverUrl;\r\n        }\r\n\r\n        try {\r\n            // Uncomment when socket.io is available\r\n            // const { io } = await import('/socket.io/socket.io.js');\r\n            this.socket = io(this.serverUrl, {\r\n                transports: ['websocket', 'polling'],\r\n                autoConnect: true, // Disable auto-connection\r\n                reconnection: false // Disable auto-reconnection during development\r\n            });\r\n\r\n            this.setupSocketEventHandlers();\r\n            \r\n            return new Promise((resolve, reject) => {\r\n                this.socket.on('connect', () => {\r\n                    console.log('Connected to server');\r\n                    this.isConnected = true;\r\n                    this.reconnectAttempts = 0;\r\n                    this.emit('connect', { connected: true });\r\n                    resolve();\r\n                });\r\n\r\n                this.socket.on('connect_error', (error) => {\r\n                    console.log('disconnected:', error);\r\n                    this.emit('connect_error', error);\r\n                    reject(error);\r\n                });\r\n            });\r\n        } catch (error) {\r\n            console.error('Failed to initialize socket connection:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    setupSocketEventHandlers() {\r\n        // Handle disconnect\r\n        this.socket.on('disconnect', (reason) => {\r\n            console.log('Disconnected from server:', reason);\r\n            this.isConnected = false;\r\n            this.emit('disconnect', { reason });\r\n            this.handleDisconnection();\r\n        });\r\n\r\n        // Forward all events to our event system\r\n        if (typeof this.socket.onAny === 'function') {\r\n            this.socket.onAny((eventName, data) => {\r\n                this.emit(eventName, data);\r\n            });\r\n        } else {\r\n            // Fallback for older socket.io versions\r\n            const originalOn = this.socket.on.bind(this.socket);\r\n            \r\n            this.socket.on = (eventName, callback) => {\r\n                const wrappedCallback = (data) => {\r\n                    if (callback) callback(data);\r\n                    this.emit(eventName, data);\r\n                };\r\n                \r\n                return originalOn(eventName, wrappedCallback);\r\n            };\r\n        }\r\n\r\n        window.addEventListener('beforeunload', () => {\r\n            this.disconnect();\r\n        });\r\n        \r\n        window.addEventListener('unload', () => {\r\n            this.disconnect();\r\n        });\r\n    }\r\n\r\n    handleDisconnection() {\r\n        if (this.reconnectAttempts < this.maxReconnectAttempts) {\r\n            console.log(`Attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);\r\n            \r\n            setTimeout(() => {\r\n                this.reconnectAttempts++;\r\n                this.connect().catch(() => {\r\n                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\r\n                        this.emit('connection_lost', {\r\n                            attempts: this.reconnectAttempts,\r\n                            maxAttempts: this.maxReconnectAttempts\r\n                        });\r\n                    }\r\n                });\r\n            }, this.reconnectDelay * this.reconnectAttempts);\r\n        } else {\r\n            this.emit('connection_lost', {\r\n                attempts: this.reconnectAttempts,\r\n                maxAttempts: this.maxReconnectAttempts\r\n            });\r\n        }\r\n    }\r\n\r\n    disconnect() {\r\n        if (this.socket) {\r\n            this.socket.removeAllListeners(); // Remove all listeners first\r\n            this.socket.disconnect(true); // Force disconnect\r\n            this.socket = null;\r\n        }\r\n        this.isConnected = false;\r\n        this.emit('disconnect', { reason: 'Manual disconnect' });\r\n    }\r\n\r\n    // =============================================\r\n    // EVENT SYSTEM\r\n    // =============================================\r\n\r\n    /**\r\n     * Listen for an event from the server\r\n     * @param {string} eventName - The event name to listen for\r\n     * @param {function} callback - The callback function\r\n     * @returns {function} - Unsubscribe function\r\n     */\r\n    listen(eventName, callback) {\r\n        if (!this.listeners.has(eventName)) {\r\n            this.listeners.set(eventName, new Set());\r\n        }\r\n        \r\n        this.listeners.get(eventName).add(callback);\r\n        \r\n        // Return unsubscribe function\r\n        return () => {\r\n            const callbacks = this.listeners.get(eventName);\r\n            if (callbacks) {\r\n                callbacks.delete(callback);\r\n                if (callbacks.size === 0) {\r\n                    this.listeners.delete(eventName);\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Remove a listener for an event\r\n     * @param {string} eventName - The event name\r\n     * @param {function} callback - The callback to remove\r\n     */\r\n    unlisten(eventName, callback) {\r\n        const callbacks = this.listeners.get(eventName);\r\n        if (callbacks) {\r\n            callbacks.delete(callback);\r\n            if (callbacks.size === 0) {\r\n                this.listeners.delete(eventName);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emit an event to all listeners\r\n     * @param {string} eventName - The event name\r\n     * @param {any} data - The event data\r\n     */\r\n    emit(eventName, data) {\r\n        // Emit to persistent listeners\r\n        const callbacks = this.listeners.get(eventName);\r\n        if (callbacks) {\r\n            callbacks.forEach(callback => {\r\n                try {\r\n                    callback(data);\r\n                } catch (error) {\r\n                    console.error(`Error in event listener for ${eventName}:`, error);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Emit to one-time callbacks\r\n        const oneTimeCallbacks = this.oneTimeCallbacks.get(eventName);\r\n        if (oneTimeCallbacks) {\r\n            oneTimeCallbacks.forEach(callback => {\r\n                try {\r\n                    callback(data);\r\n                } catch (error) {\r\n                    console.error(`Error in one-time callback for ${eventName}:`, error);\r\n                }\r\n            });\r\n            this.oneTimeCallbacks.delete(eventName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Call a server method - optionally wait for a response\r\n     * @param {string} sendEvent - The event to send to server\r\n     * @param {any} data - Data to send\r\n     * @param {string} responseEvent - The event to wait for (optional)\r\n     * @param {function} callback - Callback when response is received (optional)\r\n     * @param {number} timeout - Timeout in milliseconds (optional)\r\n     * @returns {number|null} - Callback ID that can be used to cancel, or null for fire-and-forget\r\n     */\r\n    call(sendEvent, data = {}, responseEvent = null, callback = null, timeout = null) {\r\n        if (!this.isConnected) {\r\n            const error = new Error('Not connected to server');\r\n            if (callback) {\r\n                setTimeout(() => callback(null, error), 0);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // If no response event expected, just send (fire and forget)\r\n        if (!responseEvent || !callback) {\r\n            this.socket.emit(sendEvent, data);\r\n            if (callback) {\r\n                setTimeout(() => callback(true), 0);\r\n            }\r\n            return null;\r\n        }\r\n\r\n        // Generate unique callback ID\r\n        const callbackId = ++this.callbackCounter;\r\n\r\n        // Store the one-time callback\r\n        if (!this.oneTimeCallbacks.has(responseEvent)) {\r\n            this.oneTimeCallbacks.set(responseEvent, new Map());\r\n        }\r\n        \r\n        const responseCallbacks = this.oneTimeCallbacks.get(responseEvent);\r\n        responseCallbacks.set(callbackId, callback);\r\n\r\n        // Set up timeout\r\n        const timeoutMs = timeout || this.callTimeout;\r\n        let timeoutId = null;\r\n        if (timeoutMs > 0) {\r\n            timeoutId = setTimeout(() => {\r\n                const callbacks = this.oneTimeCallbacks.get(responseEvent);\r\n                if (callbacks && callbacks.has(callbackId)) {\r\n                    callbacks.delete(callbackId);\r\n                    if (callbacks.size === 0) {\r\n                        this.oneTimeCallbacks.delete(responseEvent);\r\n                    }\r\n                    const timeoutError = new Error(`Timeout waiting for ${responseEvent}`);\r\n                    callback(null, timeoutError);\r\n                }\r\n            }, timeoutMs);\r\n        }\r\n\r\n        // Wrap callback to clear timeout\r\n        if (timeoutId) {\r\n            const originalCallback = responseCallbacks.get(callbackId);\r\n            responseCallbacks.set(callbackId, (data) => {\r\n                clearTimeout(timeoutId);\r\n                originalCallback(data);\r\n            });\r\n        }\r\n\r\n        // Send the event\r\n        this.socket.emit(sendEvent, data);\r\n\r\n        return callbackId;\r\n    }\r\n\r\n    /**\r\n     * Cancel a pending call\r\n     * @param {string} responseEvent - The response event\r\n     * @param {number} callbackId - The callback ID\r\n     */\r\n    cancelCall(responseEvent, callbackId) {\r\n        const callbacks = this.oneTimeCallbacks.get(responseEvent);\r\n        if (callbacks && callbacks.has(callbackId)) {\r\n            callbacks.delete(callbackId);\r\n            if (callbacks.size === 0) {\r\n                this.oneTimeCallbacks.delete(responseEvent);\r\n            }\r\n        }\r\n    }\r\n\r\n    // =============================================\r\n    // UTILITY METHODS\r\n    // =============================================\r\n\r\n    /**\r\n     * Get connection state\r\n     */\r\n    getConnectionState() {\r\n        return {\r\n            isConnected: this.isConnected,\r\n            reconnectAttempts: this.reconnectAttempts,\r\n            maxReconnectAttempts: this.maxReconnectAttempts\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Set reconnection options\r\n     */\r\n    setReconnectionOptions(options) {\r\n        if (options.maxReconnectAttempts !== undefined) {\r\n            this.maxReconnectAttempts = options.maxReconnectAttempts;\r\n        }\r\n        if (options.reconnectDelay !== undefined) {\r\n            this.reconnectDelay = options.reconnectDelay;\r\n        }\r\n        if (options.callTimeout !== undefined) {\r\n            this.callTimeout = options.callTimeout;\r\n        }\r\n    }\r\n\r\n    // =============================================\r\n    // CLEANUP\r\n    // =============================================\r\n\r\n    destroy() {\r\n        // Clean up all listeners\r\n        this.listeners.clear();\r\n        this.oneTimeCallbacks.clear();\r\n        \r\n        // Disconnect socket\r\n        this.disconnect();\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ClientNetworkManager.js",
        "fileName": "ClientNetworkManager"
      },
      "SceneManager": {
        "script": "class SceneManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.state.currentScene = null;\r\n        this.currentSceneData = null;\r\n        this.currentSceneName = null;\r\n    }\r\n\r\n    addEntityToScene(entity){        \r\n        if(this.game.state.currentScene){\r\n            return this.game.state.currentScene.addChild(entity);  \r\n        }\r\n        return entity;\r\n    }\r\n\r\n    load(sceneName){\r\n        this.currentSceneName = sceneName;\r\n        if(this.game.currentScene) {\r\n            this.game.currentScene.destroy();\r\n        } \r\n        this.currentSceneData = this.game.getCollections().scenes[this.currentSceneName];\r\n\r\n        \r\n        if(this.currentSceneData.type == \"ECS\") {\r\n            return this.loadECS();\r\n        }\r\n        this.game.state.currentScene = this.game.spawn(\"scene\", {sceneData: this.currentSceneData});\r\n\r\n        const sceneEntities = this.currentSceneData.sceneData;\r\n        sceneEntities.forEach(async (sceneEntity) => {\r\n            let params = {\r\n                \"objectType\": sceneEntity.objectType,\r\n                \"spawnType\": sceneEntity.spawnType,\r\n            };\r\n            sceneEntity.components.forEach((entityComp) => {\r\n                params = {...params, ...entityComp.parameters, canvas: this.game.canvas };\r\n            });                              \r\n            let e = this.game.spawn(sceneEntity.type, params);\r\n            this.addEntityToScene(e);  \r\n        });\r\n    }\r\n\r\n    loadECS() {\r\n        \r\n        const sceneEntities = this.currentSceneData.sceneData;\r\n          sceneEntities.forEach(async (sceneEntity) => {   \r\n\r\n            sceneEntity.classes.forEach((sceneClassDef) => {\r\n                const collectionName = sceneClassDef.collection;\r\n                const baseClassId = sceneClassDef.baseClass;\r\n                const classCollection = this.game.getCollections()[collectionName];\r\n                \r\n                if(baseClassId){\r\n                    const collectionClassDef = classCollection[baseClassId];\r\n                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };\r\n                    const BaseClassDef = this.game.moduleManager.getCompiledScript(baseClassId, collectionName);\r\n                    this.game.addClass(baseClassId, BaseClassDef, params);\r\n                }\r\n                for(const collectionClassId in classCollection) {    \r\n                    if(baseClassId && collectionClassId == baseClassId) continue;                \r\n                    const collectionClassDef = classCollection[collectionClassId];\r\n                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };\r\n                    const ClassDef = this.game.moduleManager.getCompiledScript(collectionClassId, collectionName);\r\n                    this.game.addClass(collectionClassId, ClassDef, params);\r\n                }\r\n            });         \r\n            \r\n            sceneEntity.managers.forEach((managerDef) => {\r\n                let params = {...managerDef.parameters, canvas: this.game.canvas };\r\n                const ManagerClass = this.game.moduleManager.getCompiledScript(managerDef.type, 'managers');\r\n                const managerInst = new ManagerClass(this.game, this);\r\n                if(managerInst.init){\r\n                    managerInst.init(params);\r\n                }                \r\n            });   \r\n\r\n            sceneEntity.systems.forEach((systemDef) => {\r\n                let params = {...systemDef.parameters, canvas: this.game.canvas };\r\n                const SystemClass = this.game.moduleManager.getCompiledScript(systemDef.type, 'systems');\r\n                const systemInst = new SystemClass(this.game, this);\r\n   \r\n                this.game.addSystem(systemInst, params);\r\n                \r\n            });   \r\n            this.game.systems.forEach((system) => {\r\n                system.postAllInit();                \r\n            });                      \r\n        });\r\n    }\r\n\r\n}",
        "filePath": "/global/libraries/js/SceneManager.js",
        "fileName": "SceneManager"
      },
      "ServerNetworkManager": {
        "script": "export default class ServerNetworkManager {\r\n    constructor(engine) {\r\n        this.engine = engine;\r\n        this.io = null;\r\n        this.playerSockets = new Map();\r\n        this.nextRoomId = 1000; // Starting room code\r\n        this.currentRoomIds = [];\r\n        this._initialized = false;\r\n    }\r\n\r\n    async init() {\r\n        if (this._initialized) return;\r\n\r\n        if (!this.io) {\r\n            const g = (typeof globalThis !== 'undefined' ? globalThis : global);\r\n            if (g && (g.io || g._io)) {\r\n                this.io = g.io || g._io;\r\n            }\r\n        }\r\n\r\n        if (!this.io) {\r\n            const { Server } = await import('socket.io');\r\n            this.io = new Server({\r\n                cors: {\r\n                    origin: \"*\",\r\n                    methods: [\"GET\", \"POST\"]\r\n                }\r\n            });\r\n            this.io.listen(3001);\r\n            console.log('Socket.IO fallback listening on port 3001');\r\n        }\r\n\r\n        this.setupEventHandlers();\r\n        this._initialized = true;\r\n        console.log('ServerNetworkManager initialized');\r\n    }\r\n\r\n    setupEventHandlers() {\r\n        this.io.removeAllListeners('connection');\r\n\r\n        this.io.on('connection', (socket) => {\r\n\r\n            console.log('Player connected:', socket.id);\r\n\r\n            this.playerSockets.set(socket.id, { socket });\r\n\r\n            socket.on('CREATE_ROOM', (data) => {\r\n                this.handleCreateRoom(socket, data);\r\n            });\r\n            socket.on('JOIN_ROOM', (data) => {\r\n                this.handleJoinRoom(socket, data);\r\n            });\r\n            // Catch ALL events and route to game systems\r\n            socket.onAny((eventName, data) => {\r\n                // Skip internal socket.io events\r\n                if (eventName.startsWith('__') || eventName === 'disconnect') {\r\n                    return;\r\n                }\r\n                \r\n                this.routeEventToEngine(socket, eventName, data);\r\n            });\r\n\r\n            socket.on('disconnect', () => {\r\n                console.log('Player disconnected:', socket.id);\r\n                this.routeEventToEngine(socket, 'PLAYER_DISCONNECT', { playerId: socket.id });\r\n                this.playerSockets.delete(socket.id);\r\n            });\r\n\r\n            socket.emit('CONNECTED', { \r\n                playerId: socket.id,\r\n                serverTime: Date.now() \r\n            });\r\n        });\r\n    }\r\n\r\n    handleCreateRoom(socket, data) {\r\n        try {\r\n            const { playerName, maxPlayers = 2 } = data;\r\n            \r\n            // Generate room code\r\n            const roomId = this.generateRoomId();            \r\n            \r\n            // Create new game room using the engine's method\r\n            const room = this.engine.createGameRoom(roomId, maxPlayers);\r\n            \r\n            const result = room.addPlayer(socket.id, {\r\n                name: playerName || `Player ${socket.id.substr(-4)}`,\r\n                socket: socket,\r\n                isHost: true\r\n            });\r\n\r\n            if (result.success) {\r\n                this.currentRoomIds.push(roomId);\r\n                this.playerSockets.set(socket.id, { \r\n                    socket, \r\n                    roomId,\r\n                    isHost: true \r\n                });\r\n                socket.join(roomId);\r\n                \r\n                socket.emit('ROOM_CREATED', {\r\n                    roomId: roomId,\r\n                    playerId: socket.id,\r\n                    isHost: true,\r\n                    gameState: room.getGameState()\r\n                });\r\n                \r\n                console.log(`Player ${playerName} created room ${roomId}`);\r\n            } else {\r\n                socket.emit('CREATE_ROOM_FAILED', { \r\n                    error: result.error || 'Failed to create room' \r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error creating room:', error);\r\n            socket.emit('CREATE_ROOM_FAILED', { \r\n                error: 'Server error while creating room' \r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    handleJoinRoom(socket, data) {\r\n        \r\n        const playerId = socket.id;\r\n        console.log('joinRoom', data)\r\n        try {\r\n            const { roomId, playerName } = data;\r\n            \r\n            if (!roomId) {\r\n                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { \r\n                    error: 'Room code required' \r\n                });\r\n                return;\r\n            }\r\n            \r\n            const room = this.engine.gameRooms.get(roomId);\r\n            if (!room) {\r\n                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { \r\n                    error: 'Room not found' \r\n                });\r\n                return;\r\n            }\r\n            \r\n            // Check if room allows joining\r\n            if (room.game.state.phase !== 'waiting' && room.game.state.phase !== 'lobby') {\r\n                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { \r\n                    error: 'Game already in progress' \r\n                });\r\n                return;\r\n            }\r\n\r\n            const result = room.addPlayer(playerId, {\r\n                name: playerName || `Player ${playerId.substr(-4)}`,\r\n                isHost: false\r\n            });\r\n\r\n            if (result.success) {\r\n                this.joinRoom(playerId, roomId);\r\n                \r\n                this.sendToPlayer(playerId, 'ROOM_JOINED', {\r\n                    roomId: roomId,\r\n                    playerId: playerId,\r\n                    isHost: false,\r\n                    gameState: room.getGameState()\r\n                });\r\n                \r\n                // Notify other players\r\n                this.broadcastToRoom(roomId, 'PLAYER_JOINED', {\r\n                    playerId: playerId,\r\n                    playerName: playerName,\r\n                    gameState: room.getGameState()\r\n                });\r\n                \r\n                console.log(`Player ${playerName} joined room ${roomId}`);\r\n            } else {\r\n                this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { \r\n                    error: result.error || result.reason || 'Failed to join room' \r\n                });\r\n            }\r\n        } catch (error) {\r\n            console.error('Error joining room:', error);\r\n            this.sendToPlayer(playerId, 'JOIN_ROOM_FAILED', { \r\n                error: 'Server error while joining room' \r\n            });\r\n        }\r\n    }\r\n\r\n    generateRoomId() {\r\n        let id;\r\n        do {\r\n            id = this.nextRoomId++;\r\n            if (this.nextRoomId > 9999) {\r\n                this.nextRoomId = 1000; // Reset to avoid very long codes\r\n            }\r\n        } while (this.currentRoomIds.includes(id.toString()));\r\n        \r\n        return id.toString();\r\n    }\r\n\r\n    // Generic event routing - just forwards to appropriate room's event manager\r\n    routeEventToEngine(socket, eventName, data) {\r\n        const playerId = socket.id;\r\n        const roomId = this.getPlayerRoom(playerId);\r\n        \r\n        try {\r\n            // For player-specific events, route to their room's event manager\r\n            if (roomId) {\r\n                const room = this.engine.gameRooms.get(roomId);\r\n                if (room && room.game.serverEventManager) {\r\n                    room.game.serverEventManager.emit(eventName, {\r\n                        playerId: playerId,\r\n                        eventName: eventName,\r\n                        data: data,\r\n                        socket: socket,\r\n                        networkManager: this\r\n                    });\r\n                    return;\r\n                }\r\n            }\r\n                        \r\n            console.warn(`No room found for event ${eventName} from player ${playerId}`);\r\n            \r\n        } catch (error) {\r\n            console.error(`Error routing event ${eventName}:`, error);\r\n        }\r\n    }\r\n\r\n\r\n    // Helper methods for systems to use\r\n    sendToPlayer(playerId, eventName, data) {\r\n        const playerData = this.playerSockets.get(playerId);\r\n        if (playerData && playerData.socket) {\r\n            playerData.socket.emit(eventName, data);\r\n        }\r\n    }\r\n\r\n    broadcastToRoom(roomId, eventName, data) {\r\n        this.io.to(roomId).emit(eventName, data);\r\n    }\r\n\r\n    joinRoom(playerId, roomId) {\r\n        const playerData = this.playerSockets.get(playerId);\r\n        if (playerData && playerData.socket) {\r\n            playerData.socket.join(roomId);\r\n            playerData.roomId = roomId;\r\n        }\r\n    }\r\n\r\n    leaveRoom(playerId, roomId) {\r\n        const playerData = this.playerSockets.get(playerId);\r\n        if (playerData && playerData.socket) {\r\n            playerData.socket.leave(roomId);\r\n            delete playerData.roomId;\r\n        }\r\n    }\r\n\r\n    getPlayerRoom(playerId) {\r\n        const playerData = this.playerSockets.get(playerId);\r\n        return playerData?.roomId;\r\n    }\r\n\r\n    broadcastGameStates() {\r\n        for (const [roomId, room] of this.engine.gameRooms) {\r\n            if (room.isActive && room.lastStateSnapshot) {\r\n                this.io.to(roomId).emit('GAME_STATE_UPDATE', room.lastStateSnapshot);\r\n            }\r\n        }\r\n    }\r\n\r\n    getServerStats() {\r\n        return {\r\n            connectedPlayers: this.playerSockets.size\r\n        };\r\n    }\r\n\r\n    cleanup() {\r\n        this.playerSockets.clear();\r\n        console.log('ServerNetworkManager cleaned up');\r\n    }\r\n}\r\n",
        "filePath": "/global/libraries/js/ServerNetworkManager.js",
        "fileName": "ServerNetworkManager"
      },
      "three_OutputPass": {
        "title": "THREE.OutputPass",
        "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "OutputPass",
        "importName": "OutputPass",
        "fileName": "three_OutputPass"
      },
      "ECSGame": {
        "script": "class ECSGame extends engine.BaseECSGame {\r\n    constructor(app){\r\n        super(app);   \r\n        this.imageManager = new GUTS.ImageManager(app, \r\n            { \r\n                imageSize: this.getCollections().configs.game.imageSize, \r\n                palette: this.getCollections().configs.game.palette, \r\n                textures: this.getCollections().textures\r\n            }\r\n        );         \r\n        this.state = new GUTS.GameState(this.getCollections());  \r\n        this.sceneManager = new GUTS.SceneManager(this); \r\n        this.moduleManager = app.moduleManager;\r\n        this.desyncDebugger = new GUTS.DesyncDebugger(this);\r\n    }\r\n\r\n    init() {    \r\n        super.init();   \r\n        this.imageManager.dispose();\r\n    }\r\n}\r\n\r\nif(typeof ECSGame != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.ECSGame = ECSGame;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = ECSGame;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = ECSGame;\r\n        exports.ECSGame = ECSGame;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ECSGame.js",
        "fileName": "ECSGame"
      },
      "ServerGameLoader": {
        "script": "class ServerGameLoader {\r\n    constructor(game) {\r\n        this.game = game;\r\n    }\r\n    \r\n    async load() {\r\n        this.collections = this.game.getCollections();\r\n        console.log('Server game loader initialized');\r\n        \r\n        // No canvas or image loading needed on server\r\n        // Just load the scene\r\n        this.game.sceneManager.load(this.collections.configs.game.initialScene);\r\n        \r\n        // Initialize any server-specific systems\r\n        this.game.init();\r\n        \r\n        console.log('Server game loaded successfully');\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ServerGameLoader.js",
        "fileName": "ServerGameLoader"
      },
      "MultiplayerECSGame": {
        "script": "class MultiplayerECSGame extends engine.ECSGame {\r\n    constructor(app) {\r\n        super(app);\r\n        this.networkManager = new GUTS.ClientNetworkManager(this);\r\n        this.isMultiplayer = true;\r\n        this.isConnected = false;\r\n        this.isServer = false;\r\n    }\r\n\r\n    async init() {\r\n        super.init();\r\n        \r\n        // Check if this is a multiplayer game\r\n        const config = this.getCollections().configs.game;\r\n        if (config.isMultiplayer && !this.app.isServer) {\r\n            console.log('Initializing multiplayer client...');\r\n            \r\n            // Connect to server\r\n            try {\r\n                await this.networkManager.connect(config.networkConfig?.serverUrl);\r\n                this.isConnected = true;\r\n                console.log('Connected to multiplayer server');\r\n                \r\n     \r\n                \r\n                // Show multiplayer UI\r\n                this.showMultiplayerUI();\r\n                \r\n            } catch (error) {\r\n                console.error('Failed to connect to server:', error);\r\n                this.handleConnectionError(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    showMultiplayerUI() {\r\n        // Show the join room UI\r\n        const joinUI = document.getElementById('joinUI');\r\n        const multiplayerUI = document.getElementById('multiplayerUI');\r\n        \r\n        if (joinUI) {\r\n            joinUI.style.display = 'block';\r\n        }\r\n        if (multiplayerUI) {\r\n            multiplayerUI.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    handleConnectionError(error) {\r\n        // Show error message to user\r\n        const errorUI = document.getElementById('connectionError') || this.createErrorUI();\r\n        errorUI.textContent = `Connection failed: ${error.message}`;\r\n        errorUI.style.display = 'block';\r\n    }\r\n\r\n    createErrorUI() {\r\n        const errorDiv = document.createElement('div');\r\n        errorDiv.id = 'connectionError';\r\n        errorDiv.style.cssText = `\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: red;\r\n            color: white;\r\n            padding: 10px;\r\n            border-radius: 5px;\r\n            z-index: 9999;\r\n        `;\r\n        document.body.appendChild(errorDiv);\r\n        return errorDiv;\r\n    }\r\n\r\n}",
        "filePath": "/global/libraries/js/MultiplayerECSGame.js",
        "fileName": "MultiplayerECSGame"
      },
      "TerrainGenerator": {
        "title": "TerrainGenerator",
        "fileName": "TerrainGenerator",
        "script": "class TerrainGenerator {\r\n    init(biomes, chunkSize, chunkResolution, noise) {\r\n        this.noise = noise;\r\n        this.biomes = biomes;\r\n        this.chunkSize = chunkSize;\r\n        this.chunkResolution = chunkResolution;\r\n    }\r\n\r\n    fractalNoise(x, y, settings) {\r\n        let value = 0;\r\n        let amplitude = 1;\r\n        let frequency = 1;\r\n        for (let i = 0; i < settings.octaves; i++) {\r\n            value += this.noise.noise2D(x * frequency * settings.scale, y * frequency * settings.scale) * amplitude;\r\n            amplitude *= settings.persistence;\r\n            frequency *= settings.lacunarity;\r\n        }\r\n        return value * settings.heightScale;\r\n    }\r\n\r\n    getBiomeWeights(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const biomeNoise = this.noise.noise2D(wx * 0.00001, wz * 0.00001);\r\n        const biomeValue = (biomeNoise + 1) / 2;\r\n        const weights = {};\r\n\r\n        Object.keys(this.biomes).forEach((biomeName) => {\r\n            const biome = this.biomes[biomeName];\r\n            const [min, max] = biome.range.elevation || biome.range; // Adjust for range format\r\n            let weight = 0;\r\n            if (biomeValue >= min && biomeValue <= max) {\r\n                weight = 1 - Math.abs(biomeValue - (min + max) / 2) / ((max - min) / 2);\r\n                weight = Math.max(0, weight);\r\n            }\r\n            weights[biomeName] = weight;\r\n        });\r\n\r\n        const totalWeight = Object.values(weights).reduce((sum, w) => sum + w, 0);\r\n        if (totalWeight > 0) {\r\n            for (const biome in weights) {\r\n                weights[biome] /= totalWeight;\r\n            }\r\n        } else {\r\n            weights.plains = 1;\r\n        }\r\n        return weights;\r\n    }\r\n\r\n    getBiomeAt(x, z) {\r\n        const position = { x, z };\r\n        const weights = this.getBiomeWeights(position);\r\n        let maxWeight = 0;\r\n        let selectedBiome = \"plains\";\r\n        for (const biomeName in weights) {\r\n            if (weights[biomeName] > maxWeight) {\r\n                maxWeight = weights[biomeName];\r\n                selectedBiome = biomeName;\r\n            }\r\n        }\r\n        return selectedBiome;\r\n    }\r\n\r\n    getHeight(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const weights = this.getBiomeWeights(position);\r\n        let totalHeight = 0;\r\n        for (const biomeName in weights) {\r\n            const weight = weights[biomeName];\r\n            if (weight === 0) continue;\r\n            const biome = this.biomes[biomeName];\r\n            let height = 0;\r\n            height += this.fractalNoise(wx, wz, biome.noiseSettings.elevation);\r\n            height += this.fractalNoise(wx * 2, wz * 2, biome.noiseSettings.detail);\r\n            if (biome.noiseSettings.ridge) {\r\n                const ridgeNoise = Math.abs(this.noise.noise2D(wx * biome.noiseSettings.ridge.scale, wz * biome.noiseSettings.ridge.scale));\r\n                height += Math.pow(ridgeNoise, biome.noiseSettings.ridge.power) * biome.noiseSettings.ridge.heightScale;\r\n            }\r\n            totalHeight += height * weight;\r\n        }\r\n        return totalHeight;\r\n    }\r\n\r\n    getNormalAt(position) {\r\n        const heightAtPoint = this.getHeight(position);\r\n        const sampleDistance = 1;\r\n\r\n        const heightAtPointPlusX = this.getHeight({ x: position.x + sampleDistance, z: position.z });\r\n        const heightAtPointPlusZ = this.getHeight({ x: position.x, z: position.z + sampleDistance });\r\n\r\n        const tangentX = { x: sampleDistance, y: heightAtPointPlusX - heightAtPoint, z: 0 };\r\n        const tangentZ = { x: 0, y: heightAtPointPlusZ - heightAtPoint, z: sampleDistance };\r\n\r\n        const normal = {\r\n            x: -tangentX.y * tangentZ.z + tangentX.z * tangentZ.y,\r\n            y: tangentX.x * tangentZ.z - tangentX.z * tangentZ.x,\r\n            z: -tangentX.x * tangentZ.y + tangentX.y * tangentZ.x\r\n        };\r\n\r\n        const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\r\n        normal.x /= normalLength || 1;\r\n        normal.y /= normalLength || 1;\r\n        normal.z /= normalLength || 1;\r\n\r\n        return normal;\r\n    }\r\n\r\n    getReflectionAt(position, velocity, restitution) {\r\n\r\n        const normal = this.getNormalAt(position);\r\n        const dotProduct = \r\n            velocity.x * normal.x + \r\n            velocity.y * normal.y + \r\n            velocity.z * normal.z;\r\n        \r\n        // Only reflect if moving toward the surface\r\n        if (dotProduct < 0) {\r\n            let r = (restitution || 0.3);\r\n            const slopeAmount = 1 - normal.y;\r\n            // Calculate reflection vector correctly (r affects the entire reflection, not just normal component)\r\n            // v_reflect = v - 2(vn)n then scaled by restitution\r\n            let reflection = new THREE.Vector3(\r\n                velocity.x - 2 * dotProduct * normal.x,\r\n                velocity.y - 2 * dotProduct * normal.y,\r\n                velocity.z - 2 * dotProduct * normal.z\r\n            );\r\n\r\n\r\n            if(dotProduct > -10 || slopeAmount > .5 ){          \r\n                // r = normal.y;\r\n                r = .99;\r\n                // Scale by restitution (energy loss on bounce)\r\n            }\r\n            reflection.x *= r;\r\n            reflection.y *= r;\r\n            reflection.z *= r;\r\n            \r\n            return reflection;\r\n        } else {\r\n            // Not heading into surface, return original velocity\r\n            return { ...velocity };\r\n        }\r\n    }\r\n\r\n    getSlope(position) {\r\n        const wx = position.x;\r\n        const wz = position.z;\r\n        const delta = 1.0;\r\n\r\n        const dx = this.getHeight({ x: wx + delta, z: wz }) - this.getHeight({ x: wx - delta, z: wz });\r\n        const dz = this.getHeight({ x: wx, z: wz + delta }) - this.getHeight({ x: wx, z: wz - delta });\r\n        return Math.sqrt(dx * dx + dz * dz) / (2 * delta);\r\n    }\r\n\r\n    getRandomFromPosition(position, seed = 0) {\r\n        const a = 12345.6789 * (position.x + 1);\r\n        const b = 9876.54321 * (position.z + 1);\r\n        const c = 567.89 * seed;\r\n        const val = Math.sin(a + b + c) * 43758.5453;\r\n        return val - Math.floor(val);\r\n    }\r\n    // Convert hex color (e.g., \"#FF0000\") to RGB object { r, g, b } with values in [0, 1]\r\n    hexToRGB(hex) {\r\n        const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n        const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n        const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n        return { r, g, b };\r\n    }\r\n\r\n    // Convert RGB object { r, g, b } (values in [0, 1]) to hex color string (e.g., \"#FF0000\")\r\n    rgbToHex(rgb) {\r\n        const r = Math.round(rgb.r * 255).toString(16).padStart(2, '0');\r\n        const g = Math.round(rgb.g * 255).toString(16).padStart(2, '0');\r\n        const b = Math.round(rgb.b * 255).toString(16).padStart(2, '0');\r\n        return `#${r}${g}${b}`;\r\n    }\r\n    generateChunk(cx, cz, chunkSize, chunkResolution) {\r\n        // Pre-calculate frequently used values\r\n        const size = chunkSize / chunkResolution;\r\n        const nx = chunkResolution + 1;\r\n        const ny = chunkResolution + 1;\r\n        const vertexCount = nx * ny;\r\n        \r\n        // Pre-allocate arrays for better performance\r\n        const positions = new Float32Array(vertexCount * 3);\r\n        const colors = new Float32Array(vertexCount * 3);\r\n        const normals = new Float32Array(vertexCount * 3);\r\n        const biomeMap = new Array(vertexCount);\r\n        \r\n        // Use a more efficient data structure for vertex heights\r\n        const vertexHeights = new Map();\r\n\r\n        // Generate positions and heights\r\n        for (let z = 0, idx = 0, posIdx = 0; z < ny; z++) {\r\n            for (let x = 0; x < nx; x++, idx++, posIdx += 3) {\r\n                const vx = x * size - chunkSize / 2;\r\n                const vz = z * size - chunkSize / 2;\r\n                const wx = cx * chunkSize + vx;\r\n                const wz = cz * chunkSize + vz;\r\n\r\n                // Use a more efficient boundary key calculation\r\n                let height;\r\n                if ((x === 0 || x === chunkResolution || z === 0 || z === chunkResolution)) {\r\n                    const boundaryKey = `${Math.floor(wx * 1000)},${Math.floor(wz * 1000)}`;\r\n                    if (vertexHeights.has(boundaryKey)) {\r\n                        height = vertexHeights.get(boundaryKey);\r\n                    } else {\r\n                        height = this.getHeight({x: wx, z: wz});\r\n                        vertexHeights.set(boundaryKey, height);\r\n                    }\r\n                } else {\r\n                    height = this.getHeight({x: wx, z: wz});\r\n                }\r\n                \r\n                positions[posIdx] = vx;\r\n                positions[posIdx + 1] = height;\r\n                positions[posIdx + 2] = vz;\r\n                \r\n                const position = {x: wx, y: height, z: wz};\r\n                biomeMap[idx] = {\r\n                    weights: this.getBiomeWeights(position),\r\n                    position: position,\r\n                    slope: this.getSlope(position)\r\n                };\r\n            }\r\n        }\r\n\r\n        // Generate indices more efficiently\r\n        const indexCount = chunkResolution * chunkResolution * 6;\r\n        const indices = new Uint32Array(indexCount);\r\n        \r\n        // Initialize accumulator arrays for normals\r\n        const normalAccum = new Float32Array(vertexCount * 3);\r\n        const contributions = new Uint16Array(vertexCount);\r\n\r\n        // Generate indices and calculate normals\r\n        for (let z = 0, idx = 0; z < chunkResolution; z++) {\r\n            for (let x = 0; x < chunkResolution; x++, idx += 6) {\r\n                const a = x + (z * nx);\r\n                const b = a + 1;\r\n                const c = a + nx;\r\n                const d = c + 1;\r\n\r\n                // Store indices in a more compact way\r\n                indices[idx] = a;\r\n                indices[idx + 1] = c;\r\n                indices[idx + 2] = b;\r\n                indices[idx + 3] = c;\r\n                indices[idx + 4] = d;\r\n                indices[idx + 5] = b;\r\n                \r\n                // Calculate triangle normals more efficiently\r\n                this._calculateTriangleNormals(\r\n                    positions, a, c, b, d,\r\n                    normalAccum, contributions\r\n                );\r\n            }\r\n        }\r\n\r\n        // Normalize accumulated normals\r\n        this._normalizeNormals(normalAccum, contributions, normals);\r\n        // Calculate vertex colors and vegetation\r\n        const { vegetation, grassData, restitution, friction } = this._processVegetationAndColors(\r\n            biomeMap, colors, positions, nx, ny, chunkSize, chunkResolution\r\n        );\r\n\r\n        return {\r\n            cx,\r\n            cz,\r\n            positions: Array.from(positions),\r\n            indices: Array.from(indices),\r\n            colors: Array.from(colors),\r\n            normals: Array.from(normals),\r\n            restitution,\r\n            friction,\r\n            vegetation,\r\n            grassData\r\n        };\r\n    }\r\n\r\n    // Extracted method for triangle normal calculation\r\n    _calculateTriangleNormals(positions, a, c, b, d, normalAccum, contributions) {\r\n        // Calculate vertex positions for the first triangle\r\n        const a3 = a * 3;\r\n        const b3 = b * 3;\r\n        const c3 = c * 3;\r\n        const d3 = d * 3;\r\n        \r\n        // First triangle normal\r\n        const normal1 = this._computeNormal(\r\n            positions[a3], positions[a3 + 1], positions[a3 + 2],\r\n            positions[c3], positions[c3 + 1], positions[c3 + 2],\r\n            positions[b3], positions[b3 + 1], positions[b3 + 2]\r\n        );\r\n        \r\n        // Second triangle normal\r\n        const normal2 = this._computeNormal(\r\n            positions[c3], positions[c3 + 1], positions[c3 + 2],\r\n            positions[d3], positions[d3 + 1], positions[d3 + 2],\r\n            positions[b3], positions[b3 + 1], positions[b3 + 2]\r\n        );\r\n        \r\n        // Accumulate normals for first triangle\r\n        this._accumulateNormal(normal1, normalAccum, a, contributions);\r\n        this._accumulateNormal(normal1, normalAccum, c, contributions);\r\n        this._accumulateNormal(normal1, normalAccum, b, contributions);\r\n        \r\n        // Accumulate normals for second triangle\r\n        this._accumulateNormal(normal2, normalAccum, c, contributions);\r\n        this._accumulateNormal(normal2, normalAccum, d, contributions);\r\n        this._accumulateNormal(normal2, normalAccum, b, contributions);\r\n    }\r\n\r\n    // Compute normal from three vertices\r\n    _computeNormal(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\r\n        // Calculate edges\r\n        const e1x = x2 - x1;\r\n        const e1y = y2 - y1;\r\n        const e1z = z2 - z1;\r\n        \r\n        const e2x = x3 - x1;\r\n        const e2y = y3 - y1;\r\n        const e2z = z3 - z1;\r\n        \r\n        // Cross product\r\n        let nx = e1y * e2z - e1z * e2y;\r\n        let ny = e1z * e2x - e1x * e2z;\r\n        let nz = e1x * e2y - e1y * e2x;\r\n        \r\n        // Normalize\r\n        const mag = Math.sqrt(nx * nx + ny * ny + nz * nz);\r\n        if (mag < 0.00001) {\r\n            return [0, 1, 0];\r\n        }\r\n        \r\n        nx /= mag;\r\n        ny /= mag;\r\n        nz /= mag;\r\n        \r\n        // Ensure normal points upward\r\n        if (ny < 0) {\r\n            nx = -nx;\r\n            ny = -ny;\r\n            nz = -nz;\r\n        }\r\n        \r\n        return [nx, ny, nz];\r\n    }\r\n\r\n    // Accumulate normal at vertex\r\n    _accumulateNormal(normal, normalAccum, vertexIndex, contributions) {\r\n        const idx = vertexIndex * 3;\r\n        normalAccum[idx] += normal[0];\r\n        normalAccum[idx + 1] += normal[1];\r\n        normalAccum[idx + 2] += normal[2];\r\n        contributions[vertexIndex]++;\r\n    }\r\n\r\n    // Normalize accumulated normals\r\n    _normalizeNormals(normalAccum, contributions, normals) {\r\n        for (let i = 0, idx = 0; i < contributions.length; i++, idx += 3) {\r\n            if (contributions[i] > 0) {\r\n                const nx = normalAccum[idx];\r\n                const ny = normalAccum[idx + 1];\r\n                const nz = normalAccum[idx + 2];\r\n                \r\n                const mag = Math.sqrt(nx * nx + ny * ny + nz * nz);\r\n                if (mag > 0.00001) {\r\n                    normals[idx] = nx / mag;\r\n                    normals[idx + 1] = ny / mag;\r\n                    normals[idx + 2] = nz / mag;\r\n                } else {\r\n                    normals[idx] = 0;\r\n                    normals[idx + 1] = 1;\r\n                    normals[idx + 2] = 0;\r\n                }\r\n            } else {\r\n                normals[idx] = 0;\r\n                normals[idx + 1] = 1;\r\n                normals[idx + 2] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extracted method for vegetation and color processing\r\n    _processVegetationAndColors(biomeMap, colors, positions, nx, ny, chunkSize, chunkResolution) {\r\n        const vegetation = new Map();\r\n        let blendedGrass = null;\r\n        let totalGrassWeight = 0;\r\n        let restitution = 0;\r\n        let friction = 0;\r\n        for (let i = 0; i < biomeMap.length; i++) {\r\n            const { weights, position, slope } = biomeMap[i];\r\n            const objectTypes = new Map();\r\n            \r\n            // Calculate blended ground color\r\n            let r = 0, g = 0, b = 0;\r\n            for (const biomeName in weights) {\r\n                const biome = this.biomes[biomeName];\r\n                const weight = weights[biomeName];\r\n                \r\n                // Add weighted color contributions\r\n                r += biome.groundColor.r * weight;\r\n                g += biome.groundColor.g * weight;\r\n                b += biome.groundColor.b * weight;\r\n                if (weight === 0) continue;\r\n                restitution += biome.groundRestitution * weight;\r\n                friction += biome.groundFriction * weight;\r\n                // Process biome objects\r\n                this._processWorldObjects(biome, weight, objectTypes, position, slope, vegetation);\r\n                \r\n                // Process grass\r\n                blendedGrass = this._processGrass(biome, weight, blendedGrass);\r\n                totalGrassWeight += weight;\r\n            }\r\n            \r\n            // Store the blended color\r\n            const colorIdx = i * 3;\r\n            colors[colorIdx] = r;\r\n            colors[colorIdx + 1] = g;\r\n            colors[colorIdx + 2] = b;\r\n        }\r\n        \r\n        // Generate grass instances if needed\r\n        const grassData = totalGrassWeight > 0 ? \r\n            this._finalizeGrass(blendedGrass, totalGrassWeight, chunkSize, chunkResolution, positions, nx) : \r\n            null;\r\n        return { vegetation: this._finalizeVegetation(vegetation), grassData, restitution: restitution / totalGrassWeight, friction: friction / totalGrassWeight };\r\n    }\r\n\r\n    // Process world objects from a biome\r\n    _processWorldObjects(biome, weight, objectTypes, position, slope, vegetation) {\r\n        biome.worldObjects.forEach((objDef, type) => {\r\n            if (!objDef.worldObjectPrefab || objDef.title?.toLowerCase().endsWith('grass')) {\r\n                // Skip grass objects, they're handled separately\r\n                return;\r\n            }\r\n            \r\n            if (!objectTypes.has(objDef.worldObjectPrefab)) {\r\n                objectTypes.set(objDef.worldObjectPrefab, []);\r\n            }\r\n            \r\n            objectTypes.get(objDef.worldObjectPrefab).push({\r\n                density: objDef.density,\r\n                maxSlope: objDef.maxSlope,\r\n                weight\r\n            });\r\n        });\r\n        \r\n        // Generate world object instances\r\n        let index = 0;\r\n        objectTypes.forEach((defs, worldObjectPrefab) => {\r\n            if (!worldObjectPrefab) return;\r\n            \r\n            // Calculate blended properties\r\n            const { density, maxSlope } = this._blendObjectProperties(defs);\r\n            \r\n            // Generate instances based on density and slope\r\n            index++;\r\n            this._generateWorldObjectInstances(\r\n                worldObjectPrefab, \r\n                density, \r\n                maxSlope, \r\n                position, \r\n                slope, \r\n                index,\r\n                vegetation\r\n            );\r\n        });\r\n    }\r\n\r\n    // Blend properties for world objects\r\n    _blendObjectProperties(defs) {\r\n        let blendedDensity = 0;\r\n        let blendedMaxSlope = 0;\r\n        let totalWeight = 0;\r\n        \r\n        defs.forEach(def => {\r\n            blendedDensity += def.density * def.weight;\r\n            blendedMaxSlope += def.maxSlope * def.weight;\r\n            totalWeight += def.weight;\r\n        });\r\n        \r\n        if (totalWeight === 0) {\r\n            return { density: 0, maxSlope: 0 };\r\n        }\r\n        \r\n        return {\r\n            density: blendedDensity / totalWeight,\r\n            maxSlope: blendedMaxSlope / totalWeight\r\n        };\r\n    }\r\n\r\n    // Generate world object instances\r\n    _generateWorldObjectInstances(worldObjectPrefab, density, maxSlope, position, slope, index, vegetation) {\r\n        const instances = vegetation.get(worldObjectPrefab) || [];\r\n        const collisionData = vegetation.get(worldObjectPrefab + '_collision') || [];\r\n        \r\n        // Random check based on density\r\n        const randomSeed = { \r\n            x: position.x * index * 10000, \r\n            y: 0, \r\n            z: position.z * index * 10000 \r\n        };\r\n        \r\n        if (this.getRandomFromPosition(randomSeed, 1) < density && slope <= maxSlope) {\r\n            const instance = {\r\n                position: { x: position.x, y: position.y - 5, z: position.z },\r\n                rotation: this.getRandomFromPosition(position, 2) * Math.PI * 2,\r\n                scale: 0.8 + this.getRandomFromPosition(position, 3) * 0.4\r\n            };\r\n            instances.push(instance);\r\n            \r\n            // Generate collision data\r\n            const aabb = this._generateCollisionAABB(worldObjectPrefab, position, instance.scale);\r\n            if (aabb) {\r\n                collisionData.push(aabb);\r\n            }\r\n        }\r\n        \r\n        vegetation.set(worldObjectPrefab, instances);\r\n        if (collisionData.length > 0) {\r\n            vegetation.set(`${worldObjectPrefab}_collision`, collisionData);\r\n        }\r\n    }\r\n\r\n    // Generate collision AABB for an object\r\n    _generateCollisionAABB(worldObjectPrefab, position, scale) {\r\n        if (worldObjectPrefab.endsWith('tree')) {\r\n            const trunkRadius = 7.0 * scale;\r\n            const trunkHeight = 40.0 * scale;\r\n            return {\r\n                id: `${worldObjectPrefab}_${Math.floor(position.x)}_${Math.floor(position.z)}`,\r\n                min: { \r\n                    x: position.x - trunkRadius, \r\n                    y: position.y - trunkHeight, \r\n                    z: position.z - trunkRadius \r\n                },\r\n                max: { \r\n                    x: position.x + trunkRadius, \r\n                    y: position.y + trunkHeight, \r\n                    z: position.z + trunkRadius \r\n                }\r\n            };\r\n        } else if (worldObjectPrefab.endsWith('rock')) {\r\n            const rockRadius = 5.0 * scale;\r\n            const rockHeight = 10.0 * scale;\r\n            return {\r\n                id: `${worldObjectPrefab}_${Math.floor(position.x)}_${Math.floor(position.z)}`,\r\n                min: { \r\n                    x: position.x - rockRadius, \r\n                    y: position.y, \r\n                    z: position.z - rockRadius \r\n                },\r\n                max: { \r\n                    x: position.x + rockRadius, \r\n                    y: position.y + rockHeight, \r\n                    z: position.z + rockRadius \r\n                }\r\n            };\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    // Process grass from a biome\r\n    _processGrass(biome, weight, blendedGrass) {\r\n        if (!blendedGrass) {\r\n            blendedGrass = {\r\n                bladeWidth: 0,\r\n                bladeHeight: 0,\r\n                baseColor: { r: 0, g: 0, b: 0 },\r\n                tipColor: { r: 0, g: 0, b: 0 },\r\n                density: 0,\r\n                maxSlope: 0,\r\n                weight: 0,\r\n                transforms: []\r\n            };\r\n        }\r\n        \r\n        biome.worldObjects.forEach((objDef) => {\r\n            if (!objDef.worldObjectPrefab && objDef.title?.toLowerCase().endsWith('grass')) {\r\n                // Convert hex colors to RGB for blending\r\n                const baseColorRGB = this.hexToRGB(objDef.baseColor);\r\n                const tipColorRGB = this.hexToRGB(objDef.tipColor);\r\n                \r\n                // Accumulate weighted grass properties\r\n                blendedGrass.bladeWidth += objDef.bladeWidth * weight;\r\n                blendedGrass.bladeHeight += objDef.bladeHeight * weight;\r\n                blendedGrass.baseColor.r += baseColorRGB.r * weight;\r\n                blendedGrass.baseColor.g += baseColorRGB.g * weight;\r\n                blendedGrass.baseColor.b += baseColorRGB.b * weight;\r\n                blendedGrass.tipColor.r += tipColorRGB.r * weight;\r\n                blendedGrass.tipColor.g += tipColorRGB.g * weight;\r\n                blendedGrass.tipColor.b += tipColorRGB.b * weight;\r\n                blendedGrass.density += objDef.density * weight;\r\n                blendedGrass.maxSlope += objDef.maxSlope * weight;\r\n            }\r\n        });\r\n        \r\n        return blendedGrass;\r\n    }\r\n\r\n    // Finalize grass properties and generate instances\r\n    _finalizeGrass(blendedGrass, totalGrassWeight, chunkSize, chunkResolution, positions, vertexCountPerRow) {\r\n        if (!blendedGrass || totalGrassWeight === 0) return null;\r\n        \r\n        // Normalize grass properties\r\n        blendedGrass.bladeWidth /= totalGrassWeight;\r\n        blendedGrass.bladeHeight /= totalGrassWeight;\r\n        blendedGrass.baseColor.r /= totalGrassWeight;\r\n        blendedGrass.baseColor.g /= totalGrassWeight;\r\n        blendedGrass.baseColor.b /= totalGrassWeight;\r\n        blendedGrass.tipColor.r /= totalGrassWeight;\r\n        blendedGrass.tipColor.g /= totalGrassWeight;\r\n        blendedGrass.tipColor.b /= totalGrassWeight;\r\n        blendedGrass.density /= totalGrassWeight;\r\n        blendedGrass.maxSlope /= totalGrassWeight;\r\n        \r\n        // Convert back to hex if needed\r\n        blendedGrass.baseColor = this.rgbToHex(blendedGrass.baseColor);\r\n        blendedGrass.tipColor = this.rgbToHex(blendedGrass.tipColor);\r\n        \r\n        // Generate grass instances\r\n        const grassPerChunk = Math.floor(blendedGrass.density * chunkSize * chunkResolution);\r\n        blendedGrass.grassPerChunk = grassPerChunk;\r\n        const step = chunkSize / chunkResolution;\r\n        \r\n        // Pre-allocate arrays\r\n        blendedGrass.phases = new Float32Array(grassPerChunk);\r\n        blendedGrass.transforms = new Array(grassPerChunk);\r\n        \r\n        for (let i = 0; i < grassPerChunk; i++) {\r\n            const x = Math.random() * chunkResolution;\r\n            const z = Math.random() * chunkResolution;\r\n            const xIdx = Math.floor(x);\r\n            const zIdx = Math.floor(z);\r\n            const fx = x - xIdx;\r\n            const fz = z - zIdx;\r\n            \r\n            const height = this.interpolateHeight(positions, xIdx, zIdx, fx, fz, vertexCountPerRow);\r\n            const worldX = (x * step - chunkSize / 2);\r\n            const worldZ = (z * step - chunkSize / 2);\r\n            \r\n            blendedGrass.transforms[i] = {\r\n                position: { x: worldX, y: height, z: worldZ },\r\n                rotation: Math.random() * Math.PI * 2,\r\n                scale: 0.7 + Math.random() * 0.5\r\n            };\r\n            \r\n            blendedGrass.phases[i] = Math.random() * Math.PI * 2;\r\n        }\r\n        \r\n        return blendedGrass.transforms.length > 0 ? blendedGrass : null;\r\n    }\r\n\r\n    // Finalize vegetation data\r\n    _finalizeVegetation(vegetation) {\r\n        return Array.from(vegetation.entries()).map(([worldObject, data]) => ({ \r\n            worldObject, \r\n            data \r\n        }));\r\n    }\r\n\r\n    // Interpolate height at a position\r\n    interpolateHeight(positions, x, z, fx, fz, vertexCountPerRow) {\r\n        const idx1 = (z * vertexCountPerRow + x) * 3;\r\n        const idx2 = idx1 + 3;\r\n        const idx3 = ((z + 1) * vertexCountPerRow + x) * 3;\r\n        const idx4 = idx3 + 3;\r\n        \r\n        const h1 = positions[idx1 + 1];\r\n        const h2 = positions[idx2 + 1];\r\n        const h3 = positions[idx3 + 1];\r\n        const h4 = positions[idx4 + 1];\r\n        \r\n        // Bilinear interpolation\r\n        const top = h1 * (1 - fx) + h2 * fx;\r\n        const bottom = h3 * (1 - fx) + h4 * fx;\r\n        \r\n        return top * (1 - fz) + bottom * fz;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/TerrainGenerator.js"
      },
      "CanvasUtility": {
        "fileName": "CanvasUtility",
        "script": "class CanvasUtility {\r\n    constructor() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\r\n\t\tthis.ctx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency\r\n        \r\n\t\tthis.tempCanvas = document.createElement('canvas');\r\n        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });\r\n\t\tthis.tempCtx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency\r\n    }\r\n\r\n    setSize(width, height) {\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n    }\r\n    paintTexture(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\trotateTexture(imageData, angle) {\r\n        // Set the canvas size to accommodate the rotated image\r\n        // Note: If the rotation results in a change in width/height, adjust these values accordingly\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original imageData to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Apply the rotation\r\n        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n        this.ctx.rotate(angle);\r\n        this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);\r\n\r\n        // Create a temporary canvas to hold the current state\r\n        this.tempCanvas.width = this.canvas.width;\r\n        this.tempCanvas.height = this.canvas.height;\r\n        this.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Clear the main canvas and draw the rotated image\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.drawImage(this.tempCanvas, 0, 0);\r\n\r\n        // Capture the rotated image data\r\n        let rotatedData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n \r\n\r\n        return rotatedData;\r\n    }\r\n\tflipTextureVertical(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original image data to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Use an off-screen canvas to perform the flip\r\n        this.tempCanvas.width = imageData.width;\r\n        this.tempCanvas.height = imageData.height;\r\n  \r\n        // Apply the flip on the off-screen canvas\r\n        this.tempCtx.translate(0, this.tempCanvas.height);\r\n\t\tthis.tempCtx.scale(1, -1);\r\n\t\tthis.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Extract the flipped image data\r\n        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);\r\n    }\r\n\r\n    flipTextureHorizontal(imageData) {\r\n        this.setSize(imageData.width, imageData.height);\r\n\r\n        // Draw the original image data to the canvas\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n\r\n        // Use an off-screen canvas to perform the flip\r\n        this.tempCanvas.width = imageData.width;\r\n        this.tempCanvas.height = imageData.height;\r\n        // Apply the flip on the off-screen canvas\r\n\t\tthis.tempCtx.translate(this.tempCanvas.width, 0);\r\n\t\tthis.tempCtx.scale(-1, 1);\r\n\t\tthis.tempCtx.drawImage(this.canvas, 0, 0);\r\n\r\n        // Extract the flipped image data\r\n        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);\r\n    }\r\n\tdrawImage(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n\trotateImage(image, angle) {\r\n\t\tthis.setSize(image.width, image.height);\r\n\t\t// Set up the rotation\r\n\t\tthis.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n\t\tthis.ctx.rotate(angle);\r\n\t\tthis.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);\r\n\t\tthis.ctx.fillStyle = 'rgba(0, 0, 0, 0)'; // Fully transparent\r\n\t\tthis.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\t\r\n\t\t// Draw the image\r\n\t\tthis.ctx.drawImage(image, 0, 0);\r\n\t\treturn this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n\t}\r\n\r\n    flipImageVertical(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.translate(0, this.canvas.height);\r\n        this.ctx.scale(1, -1);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    flipCanvasVertical() {\r\n        this.ctx.translate(0, this.canvas.height);\r\n        this.ctx.scale(1, -1);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n\r\n    flipImageHorizontal(image) {\r\n        this.setSize(image.width, image.height);\r\n        this.ctx.translate(this.canvas.width, 0);\r\n        this.ctx.scale(-1, 1);\r\n        this.ctx.drawImage(image, 0, 0);\r\n        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/CanvasUtility.js"
      },
      "AudioEditor": {
        "fileName": "AudioEditor",
        "script": "class AudioEditor {\r\n    constructor(gameEditor) {\r\n        this.gameEditor = gameEditor;\r\n        let collectionObj = { state: {}, collections: this.gameEditor.getCollections() };\r\n        this.audioManager = new (this.gameEditor.scriptContext.getComponent(\"AudioManager\"))(collectionObj, null, {} );\r\n        this.audioManager.init();\r\n        this.volume = 1;\r\n        this.setupEventListeners();\r\n        this.updateNoiseUI(); \r\n    }\r\n\r\n    setupEventListeners() {\r\n        const updateStatus = (message, type = 'default') => {\r\n            const status = document.getElementById('status-message');\r\n            if (status) {\r\n                status.textContent = message;\r\n                status.className = type === 'success' ? 'success' : type === 'error' ? 'error' : '';\r\n            }\r\n        };\r\n\r\n        const updateSliderDisplay = (sliderId, formatFn) => {\r\n            const slider = document.getElementById(sliderId);\r\n            if (slider) {\r\n                const updateDisplayValue = () => {\r\n                    const display = slider.nextElementSibling;\r\n                    if (display && display.classList.contains('value-display')) {\r\n                        display.textContent = formatFn(parseFloat(slider.value));\r\n                    }\r\n                };\r\n                \r\n                slider.addEventListener('input', updateDisplayValue);\r\n                updateDisplayValue();\r\n            }\r\n        };\r\n\r\n        document.body.addEventListener('editAudio', (event) => {\r\n            try {\r\n                const settings = event.detail.data;\r\n                this.updateUIFromSettings(settings);                \r\n                updateStatus('Audio settings imported', 'success');\r\n            } catch (err) {\r\n                updateStatus('Error importing audio settings: ' + err.message, 'error');\r\n            }\r\n        });\r\n\r\n        const playBtn = document.getElementById('playBtn');\r\n        \r\n        playBtn?.addEventListener('click', () => {\r\n            this.playCurrentSound();\r\n        });\r\n\r\n        document.getElementById('exportBtn')?.addEventListener('click', () => {\r\n            const settings = this.getUISettings();\r\n            this.saveAudio(settings);\r\n            updateStatus('Audio settings exported', 'success');\r\n        });\r\n\r\n        this.setupUIControls(updateSliderDisplay);\r\n\r\n\r\n\r\n    }\r\n    setVolume(value) {\r\n        this.volume = value;\r\n    }\r\n    setupUIControls(updateSliderDisplay) {\r\n        updateSliderDisplay('volume', (val) => `${Math.round(val * 100)}%`);\r\n        document.getElementById('volume')?.addEventListener('input', (e) => {\r\n            const volume = parseFloat(e.target.value);\r\n            this.setVolume(volume, e);\r\n        });\r\n\r\n        updateSliderDisplay('frequency', (val) => `${val} Hz`);\r\n        updateSliderDisplay('duration', (val) => `${val.toFixed(2)} s`);\r\n        \r\n        updateSliderDisplay('attack', (val) => `${val.toFixed(3)} s`);\r\n        updateSliderDisplay('decay', (val) => `${val.toFixed(2)} s`);\r\n        updateSliderDisplay('sustain', (val) => `${Math.round(val * 100)}%`);\r\n        updateSliderDisplay('release', (val) => `${val.toFixed(2)} s`);\r\n        \r\n        updateSliderDisplay('pitchEnvStart', (val) => `${val.toFixed(2)}x`);\r\n        updateSliderDisplay('pitchEnvEnd', (val) => `${val.toFixed(2)}x`);\r\n        \r\n\r\n        updateSliderDisplay('filterFreq', (val) => `${val} Hz`);\r\n\r\n        \r\n        updateSliderDisplay('filterQ', (val) => `Q: ${val.toFixed(1)}`);\r\n        \r\n        updateSliderDisplay('distortion', (val) => `${Math.round(val)}%`);\r\n\r\n        \r\n        updateSliderDisplay('delayTime', (val) => `${val.toFixed(2)} s`);\r\n \r\n        \r\n        updateSliderDisplay('delayFeedback', (val) => `${Math.round(val * 100)}%`);\r\n\r\n        \r\n        updateSliderDisplay('reverbAmount', (val) => `${Math.round(val * 100)}%`);\r\n   \r\n        \r\n        updateSliderDisplay('bitcrusher', (val) => `${Math.round(val * 100)}%`);\r\n\r\n        \r\n        updateSliderDisplay('panning', (val) => {\r\n            if (val === 0) return \"Center\";\r\n            return val < 0 ? `${Math.abs(Math.round(val * 100))}% Left` : `${Math.round(val * 100)}% Right`;\r\n        });\r\n\r\n    }\r\n\r\n    getUISettings() {\r\n        return {\r\n            waveform: document.getElementById('waveform')?.value || 'sine',\r\n            frequency: parseFloat(document.getElementById('frequency')?.value || 440),\r\n            duration: parseFloat(document.getElementById('duration')?.value || 1),\r\n            noise: {\r\n                type: document.getElementById('noiseType')?.value || 'white',\r\n                amount: parseFloat(document.getElementById('noiseAmount')?.value || 0),\r\n                filter: {\r\n                    type: document.getElementById('noiseFilterType')?.value || 'none',\r\n                    frequency: parseFloat(document.getElementById('noiseFilterFreq')?.value || 2000)\r\n                }\r\n            },\r\n            envelope: {\r\n                attack: parseFloat(document.getElementById('attack')?.value || 0.01),\r\n                decay: parseFloat(document.getElementById('decay')?.value || 0.1),\r\n                sustain: parseFloat(document.getElementById('sustain')?.value || 0.7),\r\n                release: parseFloat(document.getElementById('release')?.value || 0.3),\r\n            },\r\n            pitchEnvelope: {\r\n                start: parseFloat(document.getElementById('pitchEnvStart')?.value || 1),\r\n                end: parseFloat(document.getElementById('pitchEnvEnd')?.value || 1),\r\n                time: parseFloat(document.getElementById('duration')?.value || 1)\r\n            },\r\n            effects: {\r\n                filter: {\r\n                    type: document.getElementById('filterType')?.value || 'lowpass',\r\n                    frequency: parseFloat(document.getElementById('filterFreq')?.value || 1000),\r\n                    Q: parseFloat(document.getElementById('filterQ')?.value || 1)\r\n                },\r\n                distortion: parseFloat(document.getElementById('distortion')?.value || 0),\r\n                delay: {\r\n                    time: parseFloat(document.getElementById('delayTime')?.value || 0.3),\r\n                    feedback: parseFloat(document.getElementById('delayFeedback')?.value || 0)\r\n                },\r\n                reverb: parseFloat(document.getElementById('reverbAmount')?.value || 0),\r\n                bitcrusher: parseFloat(document.getElementById('bitcrusher')?.value || 0),\r\n                pan: parseFloat(document.getElementById('panning')?.value || 0)\r\n            }\r\n        };\r\n    }\r\n\r\n    updateUIFromSettings(settings) {\r\n        if (!settings) return;\r\n        \r\n        this.setElementValue('waveform', settings.waveform);\r\n        this.setElementValue('frequency', settings.frequency);\r\n        this.setElementValue('duration', settings.duration);\r\n        \r\n        if (settings.envelope) {\r\n            this.setElementValue('attack', settings.envelope.attack);\r\n            this.setElementValue('decay', settings.envelope.decay);\r\n            this.setElementValue('sustain', settings.envelope.sustain);\r\n            this.setElementValue('release', settings.envelope.release);\r\n        }\r\n        \r\n        if (settings.pitchEnvelope) {\r\n            this.setElementValue('pitchEnvStart', settings.pitchEnvelope.start);\r\n            this.setElementValue('pitchEnvEnd', settings.pitchEnvelope.end);\r\n        }\r\n        \r\n        if (settings.effects) {\r\n            if (settings.effects.filter) {\r\n                this.setElementValue('filterType', settings.effects.filter.type);\r\n                this.setElementValue('filterFreq', settings.effects.filter.frequency);\r\n                this.setElementValue('filterQ', settings.effects.filter.Q);\r\n                \r\n            }\r\n            \r\n            this.setElementValue('distortion', settings.effects.distortion);\r\n            \r\n            if (settings.effects.delay) {\r\n                this.setElementValue('delayTime', settings.effects.delay.time);\r\n                this.setElementValue('delayFeedback', settings.effects.delay.feedback);\r\n            }\r\n            \r\n            this.setElementValue('reverbAmount', settings.effects.reverb);\r\n            \r\n            this.setElementValue('bitcrusher', settings.effects.bitcrusher);\r\n\r\n            this.setElementValue('panning', settings.effects.pan);\r\n        }\r\n        if (settings.noise) {\r\n            this.setElementValue('noiseType', settings.noise.type);\r\n            this.setElementValue('noiseAmount', settings.noise.amount);\r\n            \r\n            if (settings.noise.filter) {\r\n                this.setElementValue('noiseFilterType', settings.noise.filter.type);\r\n                this.setElementValue('noiseFilterFreq', settings.noise.filter.frequency);\r\n            }\r\n        }\r\n        document.querySelectorAll('input[type=\"range\"]').forEach(el => {\r\n            el.dispatchEvent(new Event('input'));\r\n        });\r\n        document.getElementById('randomSoundBtn')?.addEventListener('click', () => {\r\n            this.generateRandomSound();\r\n            this.playCurrentSound();\r\n        });\r\n    }\r\n    generateRandomSound() {\r\n        // Waveform options (including noise)\r\n        const waveforms = ['sine', 'square', 'sawtooth', 'triangle', 'noise'];\r\n        \r\n        // Noise types\r\n        const noiseTypes = ['white', 'pink', 'brown'];\r\n        \r\n        // Filter types\r\n        const filterTypes = ['lowpass', 'highpass', 'bandpass', 'none'];\r\n        \r\n        // Random helpers\r\n        const random = (min, max) => Math.random() * (max - min) + min;\r\n        const randomInt = (min, max) => Math.floor(random(min, max + 1));\r\n        const randomItem = (arr) => arr[randomInt(0, arr.length - 1)];\r\n        \r\n        // Generate random settings\r\n        const settings = {\r\n            waveform: randomItem(waveforms),\r\n            frequency: random(50, 2000),\r\n            duration: random(0.1, 3),\r\n            noise: {\r\n                type: randomItem(noiseTypes),\r\n                amount: random(0, 0), // Keep below 1.0 to avoid overpowering\r\n                filter: {\r\n                    type: randomItem(filterTypes),\r\n                    frequency: random(100, 10000),\r\n                    Q: random(0.5, 5)\r\n                }\r\n            },\r\n            envelope: {\r\n                attack: random(0.001, 0.5),\r\n                decay: random(0.01, 1),\r\n                sustain: random(0, 1),\r\n                release: random(0.01, 2)\r\n            },\r\n            pitchEnvelope: {\r\n                start: random(0.5, 2),\r\n                end: random(0.5, 2),\r\n                time: random(0.1, 2)\r\n            },\r\n            effects: {\r\n                filter: {\r\n                    type: randomItem(filterTypes),\r\n                    frequency: random(50, 10000),\r\n                    Q: random(0.5, 5)\r\n                },\r\n                distortion: random(0, 0.8),\r\n                delay: {\r\n                    time: random(0, 1),\r\n                    feedback: random(0, 0.7) // Avoid infinite feedback\r\n                },\r\n                reverb: random(0, 0.7),\r\n                bitcrusher: random(0, 0.5),\r\n                pan: random(-1, 1)\r\n            }\r\n        };\r\n\r\n        // Special case: If waveform is noise, disable oscillator frequency\r\n        if (settings.waveform === 'noise') {\r\n            settings.noise.amount = 1.0; // Full noise when selected\r\n            settings.frequency = 440; // Dummy value (unused)\r\n        }\r\n\r\n        // Ensure noise filter isn't \"none\" if noise is active\r\n        if (settings.noise.amount > 0 && settings.noise.filter.type === 'none') {\r\n            settings.noise.filter.type = randomItem(filterTypes.filter(t => t !== 'none'));\r\n        }\r\n\r\n        // Update UI with the new random sound\r\n        this.updateUIFromSettings(settings);\r\n        return settings;\r\n    }\r\n\r\n    updateNoiseUI() {\r\n    \r\n        // Setup the slider display update\r\n        this.setupNoiseControls();\r\n    }\r\n    \r\n    setupNoiseControls() {\r\n        const updateSliderDisplay = (sliderId, formatFn) => {\r\n            const slider = document.getElementById(sliderId);\r\n            if (slider) {\r\n                const updateDisplayValue = () => {\r\n                    const display = slider.nextElementSibling;\r\n                    if (display && display.classList.contains('value-display')) {\r\n                        display.textContent = formatFn(parseFloat(slider.value));\r\n                    }\r\n                };\r\n                \r\n                slider.addEventListener('input', updateDisplayValue);\r\n                updateDisplayValue();\r\n            }\r\n        };\r\n    \r\n        updateSliderDisplay('noiseAmount', (val) => `${Math.round(val * 100)}%`);\r\n        updateSliderDisplay('noiseFilterFreq', (val) => `${val} Hz`);\r\n    }\r\n\r\n    setElementValue(id, value) {\r\n        const element = document.getElementById(id);\r\n        if (element) element.value = value;\r\n    }\r\n\r\n\r\n    saveAudio(settingsObj) {\r\n        document.body.dispatchEvent(new CustomEvent('saveAudio', {   \r\n            detail: { data: settingsObj, propertyName: 'audio' },\r\n        }));\r\n    }\r\n\r\n    playCurrentSound() {\r\n        const settings = this.getUISettings();\r\n        this.audioManager.playSynthSound('audioEditorSound', settings);\r\n    }\r\n    \r\n}\r\n\r\n// setupKeyboard() {\r\n//     const keyboard = document.getElementById('keyboard');\r\n//     if (!keyboard) return;\r\n    \r\n//     keyboard.innerHTML = '';\r\n    \r\n//     const keyboardLayout = [\r\n//         { note: 'C4', key: 'a', frequency: 261.63, type: 'white' },\r\n//         { note: 'C#4', key: 'w', frequency: 277.18, type: 'black' },\r\n//         { note: 'D4', key: 's', frequency: 293.66, type: 'white' },\r\n//         { note: 'D#4', key: 'e', frequency: 311.13, type: 'black' },\r\n//         { note: 'E4', key: 'd', frequency: 329.63, type: 'white' },\r\n//         { note: 'F4', key: 'f', frequency: 349.23, type: 'white' },\r\n//         { note: 'F#4', key: 't', frequency: 369.99, type: 'black' },\r\n//         { note: 'G4', key: 'g', frequency: 392.00, type: 'white' },\r\n//         { note: 'G#4', key: 'y', frequency: 415.30, type: 'black' },\r\n//         { note: 'A4', key: 'h', frequency: 440.00, type: 'white' },\r\n//         { note: 'A#4', key: 'u', frequency: 466.16, type: 'black' },\r\n//         { note: 'B4', key: 'j', frequency: 493.88, type: 'white' },\r\n//         { note: 'C5', key: 'k', frequency: 523.25, type: 'white' }\r\n//     ];\r\n    \r\n//     keyboardLayout.forEach(note => {\r\n//         const key = document.createElement('div');\r\n//         key.className = `key ${note.type}`;\r\n//         key.dataset.note = note.note;\r\n//         key.dataset.frequency = note.frequency;\r\n//         key.innerHTML = `<span>${note.note}</span><span class=\"key-label\">${note.key}</span>`;\r\n        \r\n//         key.addEventListener('mousedown', () => {\r\n//             key.classList.add('active');\r\n//             this.playNote(note.frequency);\r\n//         });\r\n//         key.addEventListener('mouseup', () => {\r\n//             key.classList.remove('active');\r\n//             this.stopNote(note.frequency);\r\n//         });\r\n//         key.addEventListener('mouseleave', () => {\r\n//             if (key.classList.contains('active')) {\r\n//                 key.classList.remove('active');\r\n//                 this.stopNote(note.frequency);\r\n//             }\r\n//         });\r\n        \r\n//         keyboard.appendChild(key);\r\n//     });\r\n    \r\n//     const keyToNote = {};\r\n//     keyboardLayout.forEach(note => {\r\n//         keyToNote[note.key] = note.frequency;\r\n//     });\r\n    \r\n//     window.addEventListener('keydown', (e) => {\r\n//         if (e.repeat) return;\r\n//         const key = e.key.toLowerCase();\r\n//         if (keyToNote[key]) {\r\n//             this.playNote(keyToNote[key]);\r\n//             const keyElement = Array.from(keyboard.children).find(\r\n//                 k => k.dataset.frequency == keyToNote[key]\r\n//             );\r\n//             if (keyElement) keyElement.classList.add('active');\r\n//         }\r\n//     });\r\n    \r\n//     window.addEventListener('keyup', (e) => {\r\n//         const key = e.key.toLowerCase();\r\n//         if (keyToNote[key]) {\r\n//             this.stopNote(keyToNote[key]);\r\n//             const keyElement = Array.from(keyboard.children).find(\r\n//                 k => k.dataset.frequency == keyToNote[key]\r\n//             );\r\n//             if (keyElement) keyElement.classList.remove('active');\r\n//         }\r\n//     });\r\n// }\r\n\r\n// stopNote(frequency) {\r\n//     if (!this.activeNotes.has(frequency)) return;\r\n    \r\n//     const note = this.activeNotes.get(frequency);\r\n//     const now = this.audioContext.currentTime;\r\n//     const settings = this.getUISettings();\r\n//     const release = settings.envelope.release;\r\n    \r\n//     note.envelopeGain.gain.cancelScheduledValues(now);\r\n//     note.envelopeGain.gain.setValueAtTime(note.envelopeGain.gain.value, now);\r\n//     note.envelopeGain.gain.linearRampToValueAtTime(0, now + release);\r\n    \r\n//     note.oscillator.stop(now + release + 0.1);\r\n    \r\n//     setTimeout(() => {\r\n//         this.activeNotes.delete(frequency);\r\n//     }, (release + 0.2) * 1000);\r\n// }\r\n// playNote(frequency) {\r\n//     if (this.activeNotes.has(frequency)) {\r\n//         this.stopNote(frequency);\r\n//     }\r\n    \r\n//     const settings = this.getUISettings();\r\n//     settings.frequency = frequency;\r\n    \r\n//     const now = this.audioContext.currentTime;\r\n//     const oscillator = this.createOscillator(settings);\r\n//     oscillator.connect(this.filter);\r\n//     oscillator.start(now);\r\n    \r\n//     this.activeNotes.set(frequency, {\r\n//         oscillator,\r\n//         envelopeGain: this.masterGainNode,\r\n//         startTime: now\r\n//     });\r\n    \r\n//     this.connectVisualizer(oscillator);\r\n// }\r\n// Audio Visualizer class\r\nclass AudioVisualizer {\r\n    constructor(canvas, audioContext) {\r\n        this.canvas = canvas;\r\n        this.ctx = canvas.getContext('2d');\r\n        this.audioContext = audioContext;\r\n        this.analyzer = audioContext.createAnalyser();\r\n        this.analyzer.fftSize = 2048;\r\n        this.bufferLength = this.analyzer.frequencyBinCount;\r\n        this.dataArray = new Uint8Array(this.bufferLength);\r\n        this.analyzer.connect(audioContext.destination);\r\n        \r\n      \r\n        \r\n        // Start visualization loop\r\n        this.visualize();\r\n    }\r\n    \r\n    connectSource(source) {\r\n        source.connect(this.analyzer);\r\n    }\r\n    \r\n    drawWaveform(audioBuffer) {\r\n        const data = audioBuffer.getChannelData(0);\r\n        const step = Math.ceil(data.length / this.canvas.width);\r\n        const amp = this.canvas.height / 2;\r\n        \r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(0, amp);\r\n        \r\n        for (let i = 0; i < this.canvas.width; i++) {\r\n            const idx = Math.floor(i * step);\r\n            const y = amp + data[idx] * amp;\r\n            this.ctx.lineTo(i, y);\r\n        }\r\n        \r\n        this.ctx.strokeStyle = '#2196F3';\r\n        this.ctx.stroke();\r\n    }\r\n    \r\n    visualize() {\r\n        requestAnimationFrame(() => this.visualize());\r\n        \r\n        this.analyzer.getByteTimeDomainData(this.dataArray);\r\n        \r\n        this.ctx.fillStyle = 'rgb(200, 200, 200)';\r\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        this.ctx.lineWidth = 2;\r\n        this.ctx.strokeStyle = 'rgb(0, 0, 0)';\r\n        this.ctx.beginPath();\r\n        \r\n        const sliceWidth = this.canvas.width * 1.0 / this.bufferLength;\r\n        let x = 0;\r\n        \r\n        for (let i = 0; i < this.bufferLength; i++) {\r\n            const v = this.dataArray[i] / 128.0;\r\n            const y = v * this.canvas.height / 2;\r\n            \r\n            if (i === 0) {\r\n                this.ctx.moveTo(x, y);\r\n            } else {\r\n                this.ctx.lineTo(x, y);\r\n            }\r\n            \r\n            x += sliceWidth;\r\n        }\r\n        \r\n        this.ctx.lineTo(this.canvas.width, this.canvas.height / 2);\r\n        this.ctx.stroke();\r\n    }\r\n    \r\n}",
        "filePath": "/global/libraries/js/AudioEditor.js"
      },
      "AIPromptPanel": {
        "fileName": "AIPromptPanel",
        "script": "class AIPromptPanel {\r\n    constructor(gameEditor) {\r\n        this.gameEditor = gameEditor;\r\n        const aiConfig = this.gameEditor.getCollections().configs.ai;\r\n        this.elements = {\r\n            launchBtn: null,\r\n            aiPromptModal: null,\r\n            promptTextarea: null,\r\n            sendBtn: null,\r\n            closeBtn: null,\r\n            previewArea: null,\r\n            applyBtn: null\r\n        };\r\n        this.init(aiConfig);\r\n    }\r\n\r\n    init(aiConfig) {\r\n       this.setupHooks();\r\n        // Create the AI Prompt Modal\r\n        const modal = document.getElementById('modal-aiPromptPanel');\r\n\r\n        this.config = aiConfig;\r\n        // Cache elements\r\n        this.elements = {\r\n            aiPromptModal: modal,\r\n            promptTextarea: modal.querySelector('#ai-prompt-textarea'),\r\n            prePromptTextarea: modal.querySelector('#ai-pre-prompt-textarea'),\r\n            sendBtn: modal.querySelector('#send-ai-prompt-btn'),\r\n            closeBtn: modal.querySelector('#close-ai-prompt-modal'),\r\n            previewArea: modal.querySelector('#ai-response-preview'),\r\n            applyBtn: modal.querySelector('#apply-ai-response-btn')\r\n        };\r\n\r\n        // Setup event listeners\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    setupEventListeners() {\r\n        this.elements.sendBtn.addEventListener('click', () => this.sendPromptToAI());\r\n        this.elements.closeBtn.addEventListener('click', () => {\r\n            this.elements.aiPromptModal.classList.remove('show');\r\n        });\r\n        this.elements.applyBtn.addEventListener('click', () => {\r\n            this.applyAIResponse();\r\n        });\r\n    }\r\n\r\n    setupHooks() {\r\n        \r\n        document.body.addEventListener('renderEditor', () => {\r\n            if(this.elements.launchBtn) this.elements.launchBtn.remove();\r\n            this.elements.launchBtn = document.createElement('button');\r\n            this.elements.launchBtn.innerHTML = \"AI Prompt\";\r\n            this.elements.launchBtn.id = 'ai-prompt-modal';\r\n            this.gameEditor.elements.editor.querySelector(\".actions>div\")?.appendChild(this.elements.launchBtn);\r\n            this.elements.launchBtn.addEventListener('click', () => {\r\n                this.showModal();\r\n            });\r\n        });\r\n    }\r\n\r\n    generateContextPrompt(object) {\r\n        const type = this.gameEditor.model.getSingularType(this.gameEditor.model.state.selectedType);\r\n\t\tlet defaultPrompt = this.config.defaultPrompt.trim().replace(/\\$\\{type\\}/g, type);\r\n        let outputObj = {...object};\r\n        const { selectedObject } = this.gameEditor.model.state;\r\n        outputObj.id = selectedObject;\r\n        \r\n        return `${defaultPrompt}\\n\\nContext Object: \\n\\n${JSON.stringify(outputObj, null, 2)}`;\r\n\t\t\r\n    }\r\n\r\n    async sendPromptToAI() {\r\n        const prompt = `${this.elements.prePromptTextarea.value} \\n\\n ${this.elements.promptTextarea.value}`;\r\n\r\n        try {\r\n            this.elements.previewArea.value = \"Generating ...\"; // Use .value for textarea\r\n\r\n            const { aiEndPoint, aiModel, apiKey, headers, requestBody } = this.prepareAIConfig(prompt);\r\n            console.log('Request config:', { aiEndPoint, aiModel, apiKey, headers, requestBody });\r\n\r\n            const response = await fetch(aiEndPoint, {\r\n                method: 'POST',\r\n                headers,\r\n                body: JSON.stringify(requestBody)\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`AI generation failed: ${response.statusText}`);\r\n            }\r\n\r\n            const responseData = await response.json();\r\n            console.log('Raw API response:', responseData);\r\n\r\n            const aiOutput = this.extractAIOutput(responseData);\r\n            const cleanedOutput = this.cleanOutput(aiOutput);\r\n            console.log('Cleaned output:', cleanedOutput);\r\n\r\n            const parsedResponse = this.parseJSONResponse(cleanedOutput);\r\n            this.elements.previewArea.value = JSON.stringify(parsedResponse, null, 2); // Use .value\r\n            this.elements.applyBtn.style.display = 'block';\r\n        } catch (error) {\r\n            console.error('AI Generation Error:', error);\r\n            this.elements.previewArea.value = `Error: ${error.message}`; // Use .value\r\n            this.elements.applyBtn.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    prepareAIConfig(prompt) {\r\n        let updated = false;\r\n\r\n        let aiEndPoint = this.config.aiEndPoint || \"http://127.0.0.1:11434/api/generate\";\r\n        let aiModel = this.config.aiModel || \"deepseek-r1:32b\";\r\n        const apiKey = this.config.aiApiKey || \"\";\r\n\r\n        if (!this.config.aiEndPoint) {\r\n            this.config.aiEndPoint = aiEndPoint;\r\n            updated = true;\r\n        }\r\n        if (!this.config.aiModel) {\r\n            this.config.aiModel = aiModel;\r\n            updated = true;\r\n        }\r\n        if (updated) {\r\n            this.gameEditor.renderObjectList();\r\n            this.gameEditor.saveProject();\r\n        }\r\n\r\n        const headers = { 'Content-Type': 'application/json' };\r\n        let requestBody = { \r\n            prompt, \r\n            model: aiModel, \r\n            jsonOnly: true, \r\n            stream: false \r\n        };\r\n\r\n        if (apiKey) {\r\n            headers.Authorization = `Bearer ${apiKey}`;\r\n            requestBody = {\r\n                model: aiModel,\r\n                messages: [\r\n                    { role: 'system', content: 'You are a helpful assistant that generates valid JSON objects based on user prompts.' },\r\n                    { role: 'user', content: prompt }\r\n                ],\r\n                temperature: 0.7,\r\n                max_tokens: 500\r\n            };\r\n        }\r\n\r\n        return { aiEndPoint, aiModel, apiKey, headers, requestBody };\r\n    }\r\n\r\n    extractAIOutput(responseData) {\r\n        return responseData.response || responseData.result || responseData;\r\n    }\r\n\r\n cleanOutput(aiOutput) {\r\n        const outputString = typeof aiOutput === 'string' ? aiOutput : JSON.stringify(aiOutput);\r\n        return outputString\r\n            .replace(/```json\\s*/g, '') // Remove ```json and optional whitespace/newlines\r\n            .replace(/```\\s*/g, '')     // Remove ``` and optional whitespace/newlines\r\n            .replace(/<think\\s*>[\\s\\S]*?<\\/think\\s*>/gi, '') // Remove <think> tags\r\n            .replace(/<think[\\s\\S]*?\\/>/gi, '') // Remove self-closing <think> tags\r\n            .trim(); // Remove leading/trailing whitespace\r\n    }\r\n\r\n    parseJSONResponse(cleanedOutput) {\r\n        try {\r\n            return JSON.parse(cleanedOutput);\r\n        } catch (parseError) {\r\n            throw new Error('Invalid JSON response from AI:\\n' + cleanedOutput);\r\n        }\r\n    }\r\n\r\n    applyAIResponse() {\r\n        try {\r\n            const responseText = this.elements.previewArea.value; // Use .value for textarea\r\n            const parsedResponse = JSON.parse(responseText);\r\n\r\n            if (!parsedResponse.id) {\r\n                alert(\"Must include id in new object.\");\r\n                return;\r\n            }\r\n\r\n            const { selectedType } = this.gameEditor.model.state;\r\n            this.gameEditor.model.getCollections()[selectedType][parsedResponse.id] = parsedResponse;\r\n\r\n            this.gameEditor.renderObjectList();\r\n            this.gameEditor.selectObject(parsedResponse.id); // Use new id instead of old selectedObject\r\n\r\n            this.elements.aiPromptModal.classList.remove('show');\r\n        } catch (error) {\r\n            console.error('Error applying AI response:', error);\r\n            alert('Failed to apply AI response. Please check the JSON format.');\r\n        }\r\n    }\r\n\r\n    showModal() {\r\n        const currentObject = this.gameEditor.getCurrentObject();\r\n        this.elements.prePromptTextarea.value = this.generateContextPrompt(currentObject); // Use .value\r\n        this.elements.previewArea.value = ''; // Use .value\r\n        this.elements.applyBtn.style.display = 'none';\r\n        this.elements.aiPromptModal.classList.add('show');\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "filePath": "/global/libraries/js/AIPromptPanel.js"
      },
      "GE_GroupManager": {
        "title": "GE_GroupManager",
        "fileName": "GE_GroupManager",
        "script": "class GE_GroupManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        this.DEFAULT_GROUP = {\r\n            shapes: [],\r\n            position: { x: 0, y: 0, z: 0 },\r\n            rotation: { x: 0, y: 0, z: 0 },\r\n            scale: { x: 1.0, y: 1.0, z: 1.0 }\r\n        };\r\n    }\r\n\r\n    init() {\r\n        document.getElementById('create-group').addEventListener('click', this.createGroup.bind(this));\r\n        document.getElementById('delete-group').addEventListener('click', this.deleteGroup.bind(this));\r\n        \r\n       \r\n        // Update the group list initially\r\n        this.updateGroupList();\r\n        \r\n        // Initialize drag-and-drop\r\n        this.initDragAndDrop();\r\n    }\r\n\r\n    // Initialize drag and drop functionality\r\n    initDragAndDrop() {\r\n        // Make group items drop targets\r\n        const groupList = document.getElementById('group-list');\r\n        groupList.addEventListener('dragover', this.handleDragOver.bind(this));\r\n        groupList.addEventListener('drop', this.handleDrop.bind(this));\r\n    }\r\n    \r\n    handleDragOver(e) {\r\n        e.preventDefault(); // Allow drop\r\n        e.dataTransfer.dropEffect = 'move';\r\n        \r\n        // Highlight the group being dragged over\r\n        const groupItem = this.findGroupItemFromEvent(e);\r\n        if (groupItem) {\r\n            // Remove highlight from all groups\r\n            document.querySelectorAll('.group-item').forEach(item => {\r\n                item.classList.remove('drag-over');\r\n            });\r\n            \r\n            // Add highlight to target group\r\n            groupItem.classList.add('drag-over');\r\n        }\r\n    }\r\n    \r\n    handleDrop(e) {\r\n        e.preventDefault();\r\n        \r\n        // Remove all drag-over highlights\r\n        document.querySelectorAll('.group-item').forEach(item => {\r\n            item.classList.remove('drag-over');\r\n        });\r\n        \r\n        // Find the target group\r\n        const groupItem = this.findGroupItemFromEvent(e);\r\n        if (!groupItem) return;\r\n        \r\n        const targetGroup = groupItem.dataset.group;\r\n        \r\n        // Get the shape data from dataTransfer\r\n        const data = e.dataTransfer.getData('text/plain');\r\n        if (!data) return;\r\n        \r\n        try {\r\n            const dragData = JSON.parse(data);\r\n            const { shapeIndex, sourceGroup } = dragData;\r\n            \r\n            // Don't move if source and target are the same\r\n            if (sourceGroup === targetGroup) return;\r\n            \r\n            // Move the shape to the target group\r\n            this.moveToGroup(parseInt(shapeIndex), sourceGroup, targetGroup);\r\n        } catch (err) {\r\n            console.error('Error processing drop:', err);\r\n        }\r\n    }\r\n    \r\n    findGroupItemFromEvent(e) {\r\n        let target = e.target;\r\n        // Traverse up to find the group-item\r\n        while (target && !target.classList.contains('group-item')) {\r\n            target = target.parentElement;\r\n            if (!target || target === document.body) return null;\r\n        }\r\n        return target;\r\n    }\r\n\r\n    // Create a new group at the frame level\r\n    createGroup() {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        const groupName = prompt(\"Enter group name:\", \"group_\" + Date.now());\r\n\r\n        const currentFrame = this.graphicsEditor.state.currentFrame;\r\n        \r\n        // Ensure we have current frame data\r\n        if (!this.graphicsEditor.getCurrentFrame()) {\r\n            this.graphicsEditor.getCurrentAnimation()[currentFrame] = {};\r\n        }\r\n        \r\n        // Switch selection to the new group\r\n        this.graphicsEditor.state.currentGroup = groupName;\r\n        // Initialize group if it doesn't exist\r\n        if (!this.graphicsEditor.getCurrentGroup()) {\r\n            // Using JSON parse/stringify for deep copying\r\n            this.graphicsEditor.getCurrentFrame()[groupName] = JSON.parse(JSON.stringify(this.DEFAULT_GROUP));\r\n        }\r\n        \r\n        \r\n        // Refresh UI\r\n        this.graphicsEditor.uiManager.updateList();\r\n        this.graphicsEditor.refreshShapes(true);\r\n    }\r\n\r\n    // Move an object from one group to another\r\n    moveToGroup(shapeIndex, fromGroupName, toGroupName) {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        const currentFrameData = this.graphicsEditor.getCurrentFrame();\r\n        \r\n        // Find the shape in the source group\r\n        const sourceGroup = currentFrameData[fromGroupName];\r\n        if (!sourceGroup) {\r\n            console.warn(`Source group ${fromGroupName} not found`);\r\n            return;\r\n        }\r\n        \r\n        // Find the shape\r\n        const shapeToMove = sourceGroup.shapes[shapeIndex];\r\n        if (!shapeToMove) {\r\n            console.warn(`Shape at index ${shapeIndex} not found in ${fromGroupName}`);\r\n            return;\r\n        }\r\n        \r\n        // Remove from source group\r\n        sourceGroup.shapes.splice(shapeIndex, 1);\r\n        \r\n        // Ensure target group exists\r\n        if (!currentFrameData[toGroupName]) {\r\n            currentFrameData[toGroupName] = this.DEFAULT_GROUP;\r\n        }\r\n        \r\n        // Add to target group\r\n        currentFrameData[toGroupName].shapes.push(shapeToMove);\r\n        \r\n        // Clear selection\r\n        this.graphicsEditor.state.selectedShapeIndex = -1;\r\n        \r\n        // Update UI\r\n        this.graphicsEditor.refreshShapes(true);\r\n    }\r\n\r\n    getGroupData(groupName){\r\n        let groupData = this.graphicsEditor.getCurrentFrame()[groupName];\r\n        if(!groupData){\r\n            return this.graphicsEditor.state.renderData.model[groupName];\r\n        }\r\n        return groupData;\r\n    }\r\n    // Select a group to work with\r\n    selectGroup(groupName) {\r\n        if (!groupName) return;\r\n        \r\n        // Update the selected group name\r\n        this.graphicsEditor.state.currentGroup = groupName;\r\n        this.graphicsEditor.state.selectedShapeIndex = -1;\r\n        let groupData = this.graphicsEditor.getMergedGroup(groupName);\r\n        this.graphicsEditor.uiManager.updateList();\r\n        if(groupData){\r\n            // Update the UI to show shapes in this group\r\n            this.graphicsEditor.uiManager.createGroupInspector(groupData);\r\n            this.graphicsEditor.gizmoManager.transformSelectedObject(this.getGroupObject(groupName));\r\n            \r\n        }\r\n        // Update the selected class on group items\r\n        this.updateSelectedGroupClass(groupName);\r\n    }\r\n    updateSelectedGroupClass(groupName) {\r\n        // Remove selected class from all group items\r\n        const groupItems = document.querySelectorAll('.group-item');\r\n        groupItems.forEach(item => {\r\n            item.classList.remove('selected');\r\n        });\r\n        \r\n        // Add selected class to the newly selected group\r\n        const selectedGroupItem = Array.from(groupItems).find(\r\n            item => item.dataset.group === groupName\r\n        );\r\n        \r\n        if (selectedGroupItem) {\r\n            selectedGroupItem.classList.add('selected');\r\n        }\r\n    }\r\n    // Remove a group and place its contents back in the shapes group\r\n    deleteGroup() {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        const currentFrameData = this.graphicsEditor.getCurrentFrame();\r\n        const currentGroup = this.graphicsEditor.getCurrentGroup();\r\n        // Get shapes from the selected group\r\n        const groupShapes = currentGroup.shapes;\r\n        if (groupShapes.length > 0) {\r\n            alert('Group must be empty to delete.');\r\n            return;\r\n        }\r\n                        \r\n        // Remove the group\r\n        delete currentFrameData[this.graphicsEditor.state.currentGroup];\r\n        \r\n        // Reset selection to shapes group\r\n        this.graphicsEditor.state.currentGroup = Object.keys(currentFrameData)[0];\r\n        this.graphicsEditor.state.selectedShapeIndex = -1;\r\n        \r\n        // Update UI\r\n        this.updateGroupList();\r\n        this.graphicsEditor.refreshShapes(true);\r\n    }\r\n    getGroupObject(groupName) {\r\n        let foundGroup = null;\r\n        this.graphicsEditor.rootGroup.traverse(obj => {\r\n            if (obj.isGroup && obj.name === groupName && obj.userData.isGroup) {\r\n                foundGroup = obj;\r\n            }\r\n        });\r\n        return foundGroup;\r\n    }\r\n\r\n\r\n    applyGroupTransform(groupName, position, rotation, scale) {\r\n        // Get the current frame data\r\n        const frameData = this.graphicsEditor.getCurrentFrame();\r\n        \r\n        // Ensure the group exists in the frame data\r\n        if (!frameData[groupName]) {\r\n            console.warn(`Group ${groupName} not found in frame data`);\r\n            return;\r\n        }\r\n \r\n        // Save transformations to the group data\r\n        frameData[groupName].position = {\r\n            x: position.x,\r\n            y: position.y,\r\n            z: position.z\r\n        };\r\n        frameData[groupName].rotation = {\r\n            x: rotation.x,\r\n            y: rotation.y,\r\n            z: rotation.z\r\n        };\r\n        frameData[groupName].scale = {\r\n            x: scale.x,\r\n            y: scale.y,\r\n            z: scale.z\r\n        };\r\n    \r\n        // Refresh the scene to see changes\r\n        this.graphicsEditor.refreshShapes(true);\r\n    }\r\n    // Update the group list in the UI\r\n    updateGroupList() {\r\n        const list = document.getElementById('group-list');\r\n        if (!list) {\r\n            console.warn(\"Group list element not found\");\r\n            return;\r\n        }\r\n        \r\n        list.innerHTML = '';\r\n        \r\n        for (const group of Object.keys(this.graphicsEditor.state.renderData.model)) {\r\n            const groupItem = document.createElement('div');\r\n            groupItem.classList.add('group-item');\r\n            if (group === this.graphicsEditor.state.currentGroup) {\r\n                groupItem.classList.add('selected');\r\n            }\r\n            \r\n            groupItem.textContent = group;\r\n            groupItem.addEventListener('click', () => this.selectGroup(group));\r\n            \r\n            // Make it a valid drop target for drag and drop\r\n            groupItem.dataset.group = group;\r\n            \r\n            list.appendChild(groupItem);\r\n        }\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GE_GroupManager.js"
      },
      "NetworkManager": {
        "fileName": "NetworkManager",
        "script": "class NetworkManager {\r\n  constructor(multiplayerManager) {\r\n    this.socket = null;\r\n    this.connected = false;\r\n    this.networkId = null;\r\n    this.players = {}; // Other players\r\n    this.multiplayerManager = multiplayerManager; // Reference to your main game engine\r\n    this.pendingObjects = {}; // Objects waiting for server ID\r\n    \r\n    // Server reconciliation\r\n    this.serverState = {};\r\n    this.inputSequence = 0;\r\n    this.pendingInputs = [];\r\n    this.pendingRequests = new Map();\r\n    this.requestId = 0;\r\n  }\r\n  \r\n  // Connect to the multiplayer server\r\n  connect(serverUrl = window.location.origin) {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        console.log(`Connecting to game server at: ${serverUrl}`);\r\n        \r\n        // Load Socket.IO client from CDN if not already available\r\n        if (!window.io) {\r\n          const script = document.createElement('script');\r\n          script.src = 'https://cdn.socket.io/4.5.4/socket.io.min.js';\r\n          script.onload = () => this.setupConnection(serverUrl, resolve, reject);\r\n          script.onerror = (err) => reject(new Error('Failed to load Socket.IO client'));\r\n          document.head.appendChild(script);\r\n        } else {\r\n          this.setupConnection(serverUrl, resolve, reject);\r\n        }\r\n      } catch (err) {\r\n        reject(err);\r\n      }\r\n    });\r\n  }\r\n  \r\n  setupConnection(serverUrl, resolve, reject) {\r\n    try {\r\n      this.socket = io(serverUrl);\r\n      \r\n      // Handle connection events\r\n      this.socket.on('connect', () => {\r\n        console.log('Connected to game server');\r\n        this.connected = true;\r\n        this.networkId = this.socket.id;\r\n        resolve(this.networkId);\r\n      });\r\n      \r\n      this.socket.on('connect_error', (err) => {\r\n        console.error('Connection error:', err);\r\n        this.disconnect();\r\n        reject(err);\r\n      });\r\n      \r\n      // Set up game-specific event handlers\r\n      this.setupEventHandlers();\r\n      \r\n    } catch (err) {\r\n      console.error('Error setting up connection:', err);\r\n      reject(err);\r\n    }\r\n  }\r\n  \r\n  requestServerData(params, callback){\r\n    if (!this.connected) return;\r\n    console.log(\"is connected\");\r\n    this.requestId++;\r\n    this.pendingRequests.set(this.requestId, callback);\r\n    // Send to server\r\n    this.socket.emit('serverDataRequest', {networkId: this.networkId, requestId: this.requestId, ...params});\r\n  }\r\n  serverDataResponse(params){\r\n          console.log('serverDataResponse');\r\n    if (!this.connected) return;\r\n    this.socket.emit('serverDataResponse', {networkId: this.networkId, ...params});\r\n  }\r\n\r\n  setupEventHandlers() {\r\n    if (!this.socket) return;\r\n\r\n    this.socket.on('setHost', (data) => {\r\n      console.log('Setting host:', data);\r\n      this.isHost = data.isHost;  \r\n      this.multiplayerManager.setHost(this.isHost);\r\n    });\r\n   \r\n    // New player joined\r\n    this.socket.on('playerConnected', (playerData) => {\r\n      \r\n      if(!this.players[playerData.networkId]){\r\n        this.addRemotePlayer(playerData);\r\n        console.log('Player joined:', playerData);\r\n\r\n      }\r\n    });\r\n    \r\n    // Player left\r\n    this.socket.on('playerDisconnected', (data) => {\r\n      let player = this.players[data.networkId];\r\n      if(player){\r\n        console.log('Player left:', data.networkId);\r\n        this.removeRemotePlayer(data.networkId);\r\n        if(this.isHost){\r\n          this.socket.emit('playerDisconnected', data);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Player moved\r\n    this.socket.on('playerInput', (data) => {\r\n      if(data.networkId && this.isHost){\r\n        let player = this.players[data.networkId];\r\n        if(player){\r\n          player.setNetworkComponentData(data, true);                 \r\n        }\r\n      }\r\n    });\r\n    // Player moved\r\n    this.socket.on('serverDataRequest', (data) => {\r\n      if(data.networkId && this.isHost){     \r\n        let responseObj = {\r\n          requestId: data.requestId,\r\n          clientId: data.networkId\r\n        };           \r\n    \r\n        let requestKey = `${responseObj.clientId}_${responseObj.requestId}`;\r\n        this.multiplayerManager.handleServerDataRequest(requestKey, responseObj, data);\r\n      }\r\n    });\r\n    this.socket.on('serverDataResponse', (data) => {\r\n          console.log('serverDataResponse');\r\n      if(data.clientId == this.networkId){        \r\n        \r\n        let callback = this.pendingRequests.get(data.requestId);\r\n        if(callback){\r\n          console.log('callback');\r\n          callback(data);\r\n          this.pendingRequests.delete(data.requestId);\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Object update from server\r\n    this.socket.on('objectUpdated', (objectData) => {\r\n      this.multiplayerManager.updateObjectFromServer(objectData);\r\n    });\r\n    \r\n    // New object created\r\n    this.socket.on('newObject', (objectData) => {\r\n      this.multiplayerManager.createObjectFromServer(objectData);\r\n    });\r\n    \r\n    // Object added confirmation\r\n    this.socket.on('objectAdded', (data) => {\r\n      // Map the client-side temporary ID to the server's permanent ID\r\n      if (this.pendingObjects[data.clientId]) {\r\n        const object = this.pendingObjects[data.clientId];\r\n        delete this.pendingObjects[data.clientId];\r\n        // Update the object with the server ID\r\n        this.multiplayerManager.updateObjectId(data.clientId, data.serverId);\r\n      }\r\n    });\r\n    \r\n    // Server state update (server-authoritative mode)\r\n    this.socket.on('gameState', (update) => {\r\n      // Process server reconciliation\r\n      if(!this.isHost){\r\n        this.serverState = update;\r\n        update.players.forEach((playerData) => {\r\n          if(!this.players[playerData.networkId]){\r\n            this.addRemotePlayer(playerData);\r\n          }\r\n          // Server reconciliation for player character             \r\n          this.multiplayerManager.updatePlayer(playerData);       \r\n        });\r\n      }\r\n    });\r\n    \r\n    // Handle disconnection\r\n    this.socket.on('disconnect', () => {\r\n      console.log('Disconnected from game server');\r\n      this.connected = false;\r\n      this.multiplayerManager.handleDisconnect();\r\n    });\r\n  }\r\n  \r\n  // Send player position and rotation to server\r\n  sendPlayerUpdate(position, quaternion, velocity) {\r\n    if (!this.connected) return;\r\n    \r\n    this.socket.emit('playerUpdate', {\r\n      position: position,\r\n      quaternion: quaternion,\r\n      velocity: velocity\r\n    });\r\n  }\r\n  \r\n  // Send player input for server-authoritative physics\r\n  sendPlayerInput(playerData) {\r\n    if (!this.connected) return;\r\n    \r\n    // Add sequence number for reconciliation\r\n    playerData.seq = this.inputSequence++;\r\n\r\n    // Send to server\r\n    this.socket.emit('playerInput', {networkId: this.networkId, ...playerData});\r\n    \r\n    // Save this input for reconciliation\r\n    this.pendingInputs.push(playerData);\r\n    \r\n    return playerData.seq;\r\n  }\r\n    // Send player input for server-authoritative physics\r\n  sendGameState(data) {\r\n    if (!this.connected || !this.isHost) return;\r\n    \r\n\r\n    // Send to server\r\n    this.socket.emit('gameState', data);    \r\n    \r\n  }\r\n  \r\n  // Create a new object on the server\r\n  createObject(objectData) {\r\n    if (!this.connected) return null;\r\n    \r\n    // Create a temporary client ID\r\n    const clientId = `temp_${Date.now()}_${Math.floor(Math.random() * 1000)}`;\r\n    \r\n    // Store in pending objects\r\n    this.pendingObjects[clientId] = objectData;\r\n    \r\n    // Send to server\r\n    this.socket.emit('addObject', {\r\n      ...objectData,\r\n      clientId: clientId\r\n    });\r\n    \r\n    return clientId;\r\n  }\r\n  \r\n  // Update object state (for objects the client has authority over)\r\n  updateObject(objectId, objectData) {\r\n    if (!this.connected) return;\r\n    \r\n    this.socket.emit('objectUpdate', {\r\n      id: objectId,\r\n      ...objectData\r\n    });\r\n  }\r\n  \r\n  // Add a new remote player\r\n  addRemotePlayer(data) {\r\n    if (this.players[data.networkId] || data.networkId === this.networkId) return;\r\n    \r\n    // Create remote player representation\r\n    this.players[data.networkId] = this.multiplayerManager.createRemotePlayer(data);\r\n  }\r\n  \r\n  // Remove a remote player\r\n  removeRemotePlayer(playerId) {\r\n    if (!this.players[playerId]) return;\r\n    \r\n    // Remove from scene\r\n    this.multiplayerManager.removeRemotePlayer(playerId);\r\n    \r\n    // Remove from local cache\r\n    delete this.players[playerId];\r\n  }\r\n  \r\n  // Update remote player position and rotation\r\n  updateRemotePlayer(playerData) {\r\n    // Update the player in the game engine\r\n    this.multiplayerManager.updateRemotePlayer(playerData);\r\n  }\r\n  \r\n \r\n  // Disconnect from server\r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      this.connected = false;\r\n    }\r\n  }\r\n}",
        "filePath": "/global/libraries/js/NetworkManager.js"
      },
      "GE_ShapeManager": {
        "title": "GE_ShapeManager",
        "fileName": "GE_ShapeManager",
        "script": "class GE_ShapeManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        this.originalMaterials = new Map();\r\n        \r\n    }    \r\n\r\n    init() {   \r\n        this.initEventListeners();\r\n\r\n    }\r\n    initEventListeners() {\r\n        // Button event listeners\r\n        const buttonMappings = {\r\n            'add-shape': this.addSelectedShape.bind(this),\r\n            'delete-shape': this.deleteSelectedShape.bind(this)\r\n        };\r\n        Object.entries(buttonMappings).forEach(([id, handler]) => {\r\n            const button = document.getElementById(id);\r\n            if (button) button.addEventListener('click', handler);\r\n        });\r\n        \r\n        document.getElementById('move-cancel').addEventListener('click', () => {            \r\n            const inspector = document.getElementById('inspector');\r\n            inspector.innerHTML = ``;\r\n        });\r\n    }\r\n    getShapeData(shapeId){\r\n        let currentGroup = this.graphicsEditor.getCurrentGroup();\r\n        if(!currentGroup){\r\n            currentGroup = { shapes: [] };\r\n            let currentAnimation = this.graphicsEditor.getCurrentAnimation();\r\n            let currentFrame = currentAnimation[this.graphicsEditor.state.currentFrame];\r\n            if(!currentFrame){\r\n                currentFrame = {};\r\n            }\r\n            currentFrame[this.graphicsEditor.state.currentGroup] = currentGroup;\r\n            currentAnimation[this.graphicsEditor.state.currentFrame] = currentFrame;\r\n        }\r\n        currentGroup.shapes = currentGroup.shapes || [];\r\n        if(currentGroup.shapes.length == 0){\r\n            let shapeData = JSON.parse(JSON.stringify(this.graphicsEditor.state.renderData.model[this.graphicsEditor.state.currentGroup])).shapes[shapeId];\r\n            shapeData.id = shapeId;\r\n            currentGroup.shapes = [shapeData];\r\n            return shapeData;\r\n        }\r\n        let shapeData = (currentGroup.shapes).find(s => s.id == shapeId);\r\n        if(this.graphicsEditor.state.editingModel){\r\n            shapeData = currentGroup.shapes[shapeId];\r\n        }\r\n        return shapeData;\r\n    }\r\n    selectShape(index) {\r\n        if (this.graphicsEditor.animationManager.isPreviewingAnimation) {\r\n            this.graphicsEditor.setPreviewAnimationState(false);\r\n        }\r\n        \r\n        // Toggle selection if clicking the same shape\r\n        this.graphicsEditor.state.selectedShapeIndex = (this.graphicsEditor.state.selectedShapeIndex === index) ? -1 : index;\r\n\r\n        // Update shape list and highlighting\r\n        this.graphicsEditor.uiManager.updateList();\r\n        // Show inspector for selected shape\r\n        const shape = this.graphicsEditor.getMergedShape();\r\n        if (shape) {\r\n            this.graphicsEditor.createInspector(shape);\r\n            this.graphicsEditor.gizmoManager.transformSelectedObject();\r\n        } else {\r\n            this.graphicsEditor.gizmoManager.destroyGizmo();\r\n            this.graphicsEditor.groupManager.selectGroup(this.graphicsEditor.state.currentGroup);\r\n        }\r\n    }\r\n    addNewShape() {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        const newShape = {\r\n            type: 'sphere',\r\n            size: 2,\r\n            color: '#ff0000',\r\n            x: 0,\r\n            y: 0,\r\n            z: 0,\r\n            rotationX: 0,\r\n            rotationY: 0,\r\n            rotationZ: 0\r\n        };\r\n        this.graphicsEditor.getCurrentGroup().shapes.push(newShape);\r\n        this.graphicsEditor.state.selectedShapeIndex = this.graphicsEditor.getCurrentGroup().shapes.length - 1;\r\n        this.graphicsEditor.refreshShapes(true); \r\n    }\r\n\r\n    addSelectedShape() {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        if (this.graphicsEditor.state.selectedShapeIndex >= 0) {\r\n            const originalShape = this.graphicsEditor.state.editingModel ? \r\n                                    this.graphicsEditor.getCurrentGroup().shapes[this.graphicsEditor.state.selectedShapeIndex] : \r\n                                    this.graphicsEditor.getCurrentGroup().shapes.find(s => s.id == this.graphicsEditor.state.selectedShapeIndex);\r\n            const newShape = JSON.parse(JSON.stringify(originalShape));\r\n            this.graphicsEditor.getCurrentGroup().shapes.push(newShape);\r\n            this.graphicsEditor.state.selectedShapeIndex = this.graphicsEditor.getCurrentGroup().shapes.length - 1;\r\n            this.graphicsEditor.refreshShapes(true);\r\n        } else {\r\n            this.addNewShape();\r\n        }\r\n    }\r\n\r\n    deleteSelectedShape() {\r\n        if(!this.graphicsEditor.state.editingModel) {            \r\n            return;\r\n        }\r\n        if (this.graphicsEditor.state.selectedShapeIndex >= 0) {\r\n            this.graphicsEditor.getCurrentGroup().shapes.splice(this.graphicsEditor.state.selectedShapeIndex, 1);\r\n            if (this.graphicsEditor.getCurrentGroup().shapes.length > 0) {\r\n                this.graphicsEditor.state.selectedShapeIndex = Math.min(this.graphicsEditor.state.selectedShapeIndex, this.graphicsEditor.getCurrentGroup().shapes.length - 1);\r\n            } else {\r\n                this.graphicsEditor.state.selectedShapeIndex = -1;\r\n            }\r\n            this.graphicsEditor.refreshShapes(true);\r\n        }\r\n    }\r\n\r\n}",
        "filePath": "/global/libraries/js/GE_ShapeManager.js"
      },
      "SpatialGrid": {
        "fileName": "SpatialGrid",
        "script": " \r\n    class SpatialGrid {\r\n        constructor(worldSize, cellSize) {\r\n            this.cellSize = cellSize;\r\n            this.cols = worldSize;\r\n            this.rows = worldSize;\r\n            this.grid = new Array(this.cols * this.rows).fill().map(() => []);\r\n            \r\n            // Track which cell each entity is in\r\n            this.entityCells = new Map(); // Map of entity -> cell index\r\n        }\r\n        \r\n        getIndex(x, y) {\r\n            return y * this.cols + x;\r\n        }\r\n\r\n        insert(entity) {\r\n            const newIndex = this.getIndex(entity.transform.gridPosition.x, entity.transform.gridPosition.y);\r\n            const oldIndex = this.entityCells.get(entity);\r\n            \r\n            // If entity moved to a new cell\r\n            if (oldIndex !== newIndex) {\r\n                // Remove from old cell if it exists\r\n                if (oldIndex !== undefined) {\r\n                    const oldCell = this.grid[oldIndex];\r\n                    const entityIndex = oldCell.indexOf(entity);\r\n                    if (entityIndex !== -1) {\r\n                        oldCell.splice(entityIndex, 1);\r\n                    }\r\n                }\r\n                \r\n                // Add to new cell\r\n                if (newIndex >= 0 && newIndex < this.grid.length) {\r\n                    this.grid[newIndex].push(entity);\r\n                    this.entityCells.set(entity, newIndex);\r\n                }\r\n            }\r\n        }\r\n        \r\n        remove(entity) {\r\n            const index = this.entityCells.get(entity);\r\n            if (index !== undefined) {\r\n                const cell = this.grid[index];\r\n                const entityIndex = cell.indexOf(entity);\r\n                if (entityIndex !== -1) {\r\n                    cell.splice(entityIndex, 1);\r\n                }\r\n                this.entityCells.delete(entity);\r\n            }\r\n        }\r\n        getNearbyEntities(x, y, radius, type=\"\") {\r\n            const nearby = [];\r\n            // Get cells that could contain entities within radius\r\n            const startX = Math.max(0, Math.floor((x - radius)));\r\n            const endX = Math.min(this.cols - 1, Math.floor((x + radius)));\r\n            const startY = Math.max(0, Math.floor((y - radius)));\r\n            const endY = Math.min(this.rows - 1, Math.floor((y + radius)));\r\n       \r\n            // Collect potential candidates from relevant cells\r\n            for (let row = startY; row <= endY; row++) {\r\n                for (let col = startX; col <= endX; col++) {\r\n                    const index = row * this.cols + col;\r\n                    if (index >= 0 && index < this.grid.length) {\r\n                        for (let entity of this.grid[index]) {\r\n                            const dx = (entity.transform.gridPosition.x) - (x + .5);\r\n                            const dy = (entity.transform.gridPosition.y) - (y + .5);\r\n                            const distSquared = dx * dx + dy * dy;\r\n                            \r\n                            if (distSquared <= radius * radius) {\r\n                                if(type) {\r\n                                    if( entity.type == type ) {\r\n                                        nearby.push(entity);\r\n                                    }\r\n                                } else {\r\n                                    nearby.push(entity);\r\n                                }\r\n                            }                            \r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            return nearby;\r\n        }\r\n        clear() {\r\n            this.grid = this.grid.map(() => []);\r\n            this.entityCells.clear();\r\n        }\r\n        \r\n        // Optional: Only clear but maintain all entity positions\r\n        // Useful for when reusing the same grid across updates\r\n        resetKeepingEntities() {\r\n            const allEntities = [];\r\n            this.entityCells.forEach((_, entity) => {\r\n                allEntities.push(entity);\r\n            });\r\n            \r\n            this.clear();\r\n            \r\n            allEntities.forEach(entity => {\r\n                this.insert(entity);\r\n            });\r\n        }\r\n    }\r\n",
        "filePath": "/global/libraries/js/SpatialGrid.js"
      },
      "ZipExporter": {
        "fileName": "ZipExporter",
        "script": "class ZipExporter {\r\n    constructor(gameEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.elements = {};\r\n        if(window.location.hostname != \"localhost\") {\r\n            this.init();\r\n        }\r\n    }\r\n\r\n    init(aiConfig) {\r\n        this.setupHooks();\r\n        const modal = document.getElementById('modal-ZipExporterPanel');\r\n        this.config = aiConfig;\r\n        this.elements = { modal: modal };\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    setCurrentObjectValues(data) {\r\n        const { selectedType, selectedObject } = this.gameEditor.model.getCurrentObjectContext();\r\n        this.gameEditor.getCollections()[selectedType][selectedObject] = data;\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // Placeholder for future listeners\r\n    }\r\n\r\n    setupHooks() {\r\n        document.body.addEventListener('renderEditor', () => {\r\n      \r\n            // Export Current Object Button\r\n            if (this.elements.exportCurrentObjectBtn) this.elements.exportCurrentObjectBtn.remove();\r\n            this.elements.exportCurrentObjectBtn = document.createElement('button');\r\n            this.elements.exportCurrentObjectBtn.innerHTML = \"Export Object\";\r\n            this.elements.exportCurrentObjectBtn.id = 'save-object-btn';\r\n            this.gameEditor.elements.editor.querySelector(\".actions>div\")?.appendChild(this.elements.exportCurrentObjectBtn);\r\n            this.elements.exportCurrentObjectBtn.addEventListener('click', () => {\r\n                this.exportCurrentObject();\r\n            });\r\n\r\n            // Import Current Object Button\r\n            if (this.elements.importCurrentObjectBtn) this.elements.importCurrentObjectBtn.remove();\r\n            this.elements.importCurrentObjectBtn = document.createElement('button');\r\n            this.elements.importCurrentObjectBtn.innerHTML = \"Import Object\";\r\n            this.elements.importCurrentObjectBtn.id = 'import-object-btn';\r\n            this.gameEditor.elements.editor.querySelector(\".actions>div\")?.appendChild(this.elements.importCurrentObjectBtn);\r\n            this.elements.importCurrentObjectBtn.addEventListener('click', () => {\r\n                this.triggerImportJson();\r\n            });\r\n        });\r\n\r\n        document.body.addEventListener('selectObject', () => {\r\n            const { selectedType } = this.gameEditor.model.getCurrentObjectContext();\r\n            const category = this.gameEditor.model.getCategoryByType(selectedType);\r\n\r\n            requestAnimationFrame(() => {\r\n                // Export Project Button\r\n                if (this.elements.exportProjectBtn) this.elements.exportProjectBtn.remove();\r\n                this.elements.exportProjectBtn = document.createElement('button');\r\n                this.elements.exportProjectBtn.innerHTML = \"Export Project\";\r\n                this.elements.exportProjectBtn.id = 'export-project-btn';\r\n                this.gameEditor.elements.sidebar.querySelector(\".sidebar-actions>.primary\")?.after(this.elements.exportProjectBtn);\r\n                this.elements.exportProjectBtn.addEventListener('click', () => {\r\n                    this.exportFullProject();\r\n                });\r\n                // Import Project Button\r\n                if (this.elements.importProjectBtn) this.elements.importProjectBtn.remove();\r\n                this.elements.importProjectBtn = document.createElement('button');\r\n                this.elements.importProjectBtn.innerHTML = \"Import Project\";\r\n                this.elements.importProjectBtn.id = 'import-project-btn';\r\n                this.gameEditor.elements.sidebar.querySelector(\".sidebar-actions>.primary\")?.after(this.elements.importProjectBtn);\r\n                this.elements.importProjectBtn.addEventListener('click', () => {\r\n                    this.triggerImportProject();\r\n                });\r\n                // Export All in Category Button\r\n                if (this.elements.exportAllBtn) this.elements.exportAllBtn.remove();\r\n                this.elements.exportAllBtn = document.createElement('button');\r\n                this.elements.exportAllBtn.innerHTML = `Export All ${category}`;\r\n                this.elements.exportAllBtn.id = 'export-all-btn';\r\n                this.gameEditor.elements.sidebar.querySelector(\".sidebar-actions>.primary\")?.after(this.elements.exportAllBtn);\r\n                this.elements.exportAllBtn.addEventListener('click', () => {\r\n                    this.exportCategory(category);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    // Export a JSON file\r\n    exportJSON(fileName, jsonObj) {\r\n        const blob = new Blob([JSON.stringify(jsonObj, null, 2)], { type: 'application/json' });\r\n        const url = window.URL.createObjectURL(blob);\r\n        const link = document.createElement('a');\r\n        link.href = url;\r\n        link.download = `${fileName}.json`;\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n        window.URL.revokeObjectURL(url);\r\n    }\r\n\r\n    // Export current object as JSON\r\n    exportCurrentObject() {\r\n        const selectedObject = this.gameEditor.model.getCurrentObject();   \r\n        this.exportJSON(selectedObject, this.gameEditor.getCurrentObject());\r\n    }\r\n\r\n    // Export a category as a zip\r\n    exportCategory(category) {\r\n        const scripts = this.gameEditor.model.getCollectionsByCategory(category);\r\n        this.exportZip(category, scripts);\r\n    }\r\n\r\n    // Export the entire project as a zip\r\n    exportFullProject() {\r\n        const allCollections = {};\r\n        const defs = this.gameEditor.model.getCollectionDefs();\r\n\r\n        defs.forEach(def => {\r\n            const category = def.category;\r\n            const collectionKey = def.id;\r\n            const collectionData = this.gameEditor.model.getCollections()[collectionKey];\r\n            if (collectionData) {\r\n                if (!allCollections[category]) {\r\n                    allCollections[category] = {};\r\n                }\r\n                allCollections[category][collectionKey] = collectionData;\r\n            }\r\n        });\r\n\r\n        this.exportZip(this.gameEditor.model.getCurrentProject(), allCollections);\r\n    }\r\n\r\n    // Generic zip export method\r\n    exportZip(fileName, projectData) {\r\n        const zip = new JSZip();\r\n\r\n        Object.keys(projectData).forEach(category => {\r\n            const collections = projectData[category];\r\n            Object.keys(collections).forEach(collection => {\r\n                const objects = collections[collection];\r\n                const folder = zip.folder(`${category}/${collection}`);\r\n\r\n                Object.keys(objects).forEach(objKey => {\r\n                    const objData = objects[objKey];\r\n                    const scriptContent = objData.script || '';\r\n                    if (scriptContent) {\r\n                        folder.file(`${objKey}.js`, scriptContent);\r\n                    } else {\r\n                        folder.file(`${objKey}.json`, JSON.stringify(objData, null, 2));\r\n                    }\r\n                });\r\n            });\r\n        });\r\n\r\n        zip.generateAsync({ type: 'blob' }).then(blob => {\r\n            const url = window.URL.createObjectURL(blob);\r\n            const link = document.createElement('a');\r\n            link.href = url;\r\n            link.download = `${fileName}.zip`;\r\n            document.body.appendChild(link);\r\n            link.click();\r\n            document.body.removeChild(link);\r\n            window.URL.revokeObjectURL(url);\r\n        }).catch(error => {\r\n            console.error('Error generating zip file:', error);\r\n        });\r\n    }\r\n\r\n    // Trigger JSON import\r\n    triggerImportJson() {\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = '.json';\r\n        input.style.display = 'none';\r\n        input.addEventListener('change', (e) => this.importJson(e));\r\n        document.body.appendChild(input);\r\n        input.click();\r\n        document.body.removeChild(input);\r\n    }\r\n    triggerImportProject() {\r\n        const input = document.createElement('input');\r\n        input.type = 'file';\r\n        input.accept = '.zip';\r\n        input.style.display = 'none';\r\n        input.addEventListener('change', (e) => this.importProject(e));\r\n        document.body.appendChild(input);\r\n        input.click();\r\n        document.body.removeChild(input);\r\n    }\r\n    // Import a single JSON file\r\n    async importJson(event) {\r\n        const file = event.target.files[0];\r\n        if (!file) return;\r\n\r\n        try {\r\n            const reader = new FileReader();\r\n            reader.onload = (e) => {\r\n                const jsonContent = JSON.parse(e.target.result);\r\n                this.setCurrentObjectValues(jsonContent);\r\n                const myCustomEvent = new CustomEvent('updateCurrentObject', { cancelable: true });\r\n                document.body.dispatchEvent(myCustomEvent);\r\n            };\r\n            reader.onerror = (error) => {\r\n                console.error('Error reading JSON file:', error);\r\n            };\r\n            reader.readAsText(file);\r\n        } catch (error) {\r\n            console.error('Error importing JSON:', error);\r\n        }\r\n    }\r\n  \r\n  \t// Import a project zip file\r\n    async importProject(event) {\r\n        const file = event.target.files[0];\r\n        if (!file) return;\r\n\r\n        try {\r\n            const jsZip = new JSZip();\r\n            const zipContent = await jsZip.loadAsync(file);\r\n\r\n            const projectData = {};\r\n\r\n            // Process all files in the zip\r\n            const fileProcessingPromises = [];\r\n\r\n            zipContent.forEach((relativePath, zipEntry) => {\r\n                if (!zipEntry.dir) {\r\n                    const promise = zipEntry.async('string').then(content => {\r\n                        // Parse path: category/collection/objectKey.ext\r\n                        const pathParts = relativePath.split('/');\r\n                        if (pathParts.length >= 3) {\r\n                            const category = pathParts[0];\r\n                            const collection = pathParts[1];\r\n                            const fileName = pathParts[2];\r\n                            const objectKey = fileName.substring(0, fileName.lastIndexOf('.'));\r\n                            const fileExt = fileName.substring(fileName.lastIndexOf('.') + 1);\r\n\r\n                            // Initialize the data structure if needed\r\n                            if (!projectData[category]) projectData[category] = {};\r\n                            if (!projectData[category][collection]) projectData[category][collection] = {};\r\n\r\n                            // Parse content based on file extension\r\n                            if (fileExt === 'js') {\r\n                                projectData[category][collection][objectKey] = { script: content };\r\n                            } else if (fileExt === 'json') {\r\n                                projectData[category][collection][objectKey] = JSON.parse(content);\r\n                            }\r\n                        }\r\n                    });\r\n                    fileProcessingPromises.push(promise);\r\n                }\r\n            });\r\n\r\n            // Wait for all files to be processed\r\n            await Promise.all(fileProcessingPromises);\r\n\r\n            // Update game editor state with imported data\r\n            const defs = this.gameEditor.model.getCollectionDefs();\r\n            defs.forEach(def => {\r\n                const category = def.category;\r\n                const collectionKey = def.id;\r\n\r\n                if (projectData[category] && projectData[category][collectionKey]) {\r\n                    if (!this.gameEditor.model.state.project.objectTypes[collectionKey]) {\r\n                        this.gameEditor.model.state.project.objectTypes[collectionKey] = {};\r\n                    }\r\n\r\n                    // Merge imported objects with existing\r\n                    Object.keys(projectData[category][collectionKey]).forEach(objKey => {\r\n                        this.gameEditor.model.state.project.objectTypes[collectionKey][objKey] = \r\n                            projectData[category][collectionKey][objKey];\r\n                    });\r\n                }\r\n            });\r\n\r\n            // Trigger UI update\r\n            const updateEvent = new CustomEvent('projectUpdated', { cancelable: true });\r\n            document.body.dispatchEvent(updateEvent);\r\n\r\n            alert('Project imported successfully');\r\n        } catch (error) {\r\n            console.error('Error importing project:', error);\r\n            alert('Error importing project. See console for details.');\r\n        }\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ZipExporter.js"
      },
      "GameState": {
        "fileName": "GameState",
        "script": "class GameState {\r\n    constructor(gameConfig = {}) {\r\n        this.collections = gameConfig;\r\n        let state = gameConfig.configs?.state;\r\n     \r\n        // Clear all existing properties\r\n        for (let prop in this) {\r\n            if (Object.prototype.hasOwnProperty.call(this, prop)) {\r\n                delete this[prop];\r\n            }\r\n        }\r\n\r\n        // Set only the properties from params\r\n        for (let key in state) {\r\n            if (Object.prototype.hasOwnProperty.call(state, key)) {\r\n                this[key] = state[key];\r\n            }\r\n        }\r\n        // If stats is present, create defaultStats as a copy\r\n  \r\n    }\r\n}\r\n\r\nif(typeof GameState != 'undefined'){\r\n    if (typeof window !== 'undefined') {\r\n        window.GameState = GameState;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = GameState;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = GameState;\r\n        exports.GameState = GameState;\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GameState.js"
      },
      "GE_GizmoManager": {
        "title": "GE_GizmoManager",
        "fileName": "GE_GizmoManager",
        "script": "class GE_GizmoManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        this.gizmoMode = 'translate';\r\n        this.gizmoGroup = null;\r\n        this.isDragging = false;\r\n        this.selectedAxis = null;\r\n        this.mouse = new window.THREE.Vector2();\r\n        this.lastMouse = new window.THREE.Vector2();\r\n        this.raycaster = new window.THREE.Raycaster();\r\n        this.originalScale = new window.THREE.Vector3(1, 1, 1);\r\n        this.originalPosition = new window.THREE.Vector3(0, 0, 0);\r\n        this.originalRotation = new window.THREE.Vector3(0, 0, 0);\r\n    }\r\n\r\n    init() {\r\n\r\n        const canvas = this.graphicsEditor.sceneRenderer.renderer.domElement;\r\n        canvas.addEventListener('mousedown', this.onMouseDown.bind(this));\r\n        canvas.addEventListener('mousemove', this.onDrag.bind(this));\r\n        canvas.addEventListener('mouseup', this.onMouseUp.bind(this));\r\n\r\n    }\r\n\r\n    destroyGizmo() {\r\n        if (this.gizmoGroup) {\r\n            this.gizmoGroup.children.forEach(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) child.material.dispose();\r\n            });\r\n            this.graphicsEditor.sceneRenderer.scene.remove(this.gizmoGroup);\r\n            this.gizmoGroup = null;\r\n        }\r\n    }\r\n\r\n    createGizmo() {\r\n        this.destroyGizmo();\r\n        this.gizmoGroup = new window.THREE.Group();\r\n        this.graphicsEditor.sceneRenderer.scene.add(this.gizmoGroup);\r\n    \r\n        let center = new window.THREE.Vector3();\r\n        let xOffset = 1, yOffset = 1, zOffset = 1;\r\n    \r\n        if (this.currentTransformTarget.children.length > 0) {\r\n            const boundingBox = new window.THREE.Box3().setFromObject(this.currentTransformTarget);\r\n            const size = new window.THREE.Vector3();\r\n            if (!boundingBox.isEmpty() && isFinite(boundingBox.min.x)) {\r\n                boundingBox.getSize(size);\r\n                boundingBox.getCenter(center);\r\n                xOffset = size.x / 2 + 1;\r\n                yOffset = size.y / 2 + 1;\r\n                zOffset = size.z / 2 + 1;\r\n            } else {\r\n                this.currentTransformTarget.getWorldPosition(center);\r\n                console.warn(\"Invalid bounding box; using group position.\");\r\n            }\r\n        } else {\r\n            const boundingBox = new window.THREE.Box3().setFromObject(this.currentTransformTarget);\r\n            const size = new window.THREE.Vector3();\r\n            if (!boundingBox.isEmpty() && isFinite(boundingBox.min.x)) {\r\n                boundingBox.getSize(size);\r\n                boundingBox.getCenter(center);\r\n                xOffset = size.x / 2 + 1;\r\n                yOffset = size.y / 2 + 1;\r\n                zOffset = size.z / 2 + 1;\r\n            } else {\r\n                this.currentTransformTarget.getWorldPosition(center);\r\n                console.warn(\"Invalid bounding box; using group position.\");\r\n            }\r\n        }\r\n    \r\n        this.gizmoGroup.position.copy(center);\r\n    \r\n        if (this.graphicsEditor.state.gizmoMode === \"translate\") {\r\n            const arrowLength = 5;\r\n            const arrowHeadLength = 2;\r\n            const arrowHeadWidth = 1;\r\n    \r\n            // X-axis (red)\r\n            const xCylinderGeometry = new window.THREE.CylinderGeometry(0.5, 0.5, arrowLength - arrowHeadLength, 8);\r\n            const xCylinderMaterial = new window.THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n            const xCylinder = new window.THREE.Mesh(xCylinderGeometry, xCylinderMaterial);\r\n            xCylinder.rotation.z = Math.PI / 2;\r\n            xCylinder.position.x = xOffset + (arrowLength - arrowHeadLength) / 2;\r\n            xCylinder.name = \"translate-x\";\r\n            this.gizmoGroup.add(xCylinder);\r\n    \r\n            const xConeGeometry = new window.THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);\r\n            const xConeMaterial = new window.THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n            const xCone = new window.THREE.Mesh(xConeGeometry, xConeMaterial);\r\n            xCone.rotation.z = 3 * Math.PI / 2;\r\n            xCone.position.x = xOffset + arrowLength - arrowHeadLength / 2;\r\n            xCone.name = \"translate-x\";\r\n            this.gizmoGroup.add(xCone);\r\n    \r\n            // Y-axis (green)\r\n            const yCylinderGeometry = new window.THREE.CylinderGeometry(0.5, 0.5, arrowLength - arrowHeadLength, 8);\r\n            const yCylinderMaterial = new window.THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n            const yCylinder = new window.THREE.Mesh(yCylinderGeometry, yCylinderMaterial);\r\n            yCylinder.position.y = yOffset + (arrowLength - arrowHeadLength) / 2;\r\n            yCylinder.name = \"translate-y\";\r\n            this.gizmoGroup.add(yCylinder);\r\n    \r\n            const yConeGeometry = new window.THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);\r\n            const yConeMaterial = new window.THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n            const yCone = new window.THREE.Mesh(yConeGeometry, yConeMaterial);\r\n            yCone.position.y = yOffset + arrowLength - arrowHeadLength / 2;\r\n            yCone.name = \"translate-y\";\r\n            this.gizmoGroup.add(yCone);\r\n    \r\n            // Z-axis (blue)\r\n            const zCylinderGeometry = new window.THREE.CylinderGeometry(0.5, 0.5, arrowLength - arrowHeadLength, 8);\r\n            const zCylinderMaterial = new window.THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n            const zCylinder = new window.THREE.Mesh(zCylinderGeometry, zCylinderMaterial);\r\n            zCylinder.rotation.x = Math.PI / 2;\r\n            zCylinder.position.z = zOffset + (arrowLength - arrowHeadLength) / 2;\r\n            zCylinder.name = \"translate-z\";\r\n            this.gizmoGroup.add(zCylinder);\r\n    \r\n            const zConeGeometry = new window.THREE.ConeGeometry(arrowHeadWidth, arrowHeadLength, 8);\r\n            const zConeMaterial = new window.THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n            const zCone = new window.THREE.Mesh(zConeGeometry, zConeMaterial);\r\n            zCone.rotation.x = Math.PI / 2;\r\n            zCone.position.z = zOffset + arrowLength - arrowHeadLength / 2;\r\n            zCone.name = \"translate-z\";\r\n            this.gizmoGroup.add(zCone);\r\n        } else if (this.graphicsEditor.state.gizmoMode === \"rotate\") {\r\n            const ringRadius = 4;\r\n            const ringTube = 0.5;\r\n    \r\n            // X-axis (red)\r\n            const xRingGeometry = new window.THREE.TorusGeometry(ringRadius, ringTube, 16, 100);\r\n            const xRingMaterial = new window.THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n            const xRing = new window.THREE.Mesh(xRingGeometry, xRingMaterial);\r\n            xRing.rotation.y = Math.PI / 2;\r\n            xRing.position.x = xOffset;\r\n            xRing.name = \"rotate-x\";\r\n            this.gizmoGroup.add(xRing);\r\n    \r\n            // Y-axis (green)\r\n            const yRingGeometry = new window.THREE.TorusGeometry(ringRadius, ringTube, 16, 100);\r\n            const yRingMaterial = new window.THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n            const yRing = new window.THREE.Mesh(yRingGeometry, yRingMaterial);\r\n            yRing.rotation.x = Math.PI / 2;\r\n            yRing.position.y = yOffset;\r\n            yRing.name = \"rotate-y\";\r\n            this.gizmoGroup.add(yRing);\r\n    \r\n            // Z-axis (blue)\r\n            const zRingGeometry = new window.THREE.TorusGeometry(ringRadius, ringTube, 16, 100);\r\n            const zRingMaterial = new window.THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n            const zRing = new window.THREE.Mesh(zRingGeometry, zRingMaterial);\r\n            zRing.position.z = zOffset;\r\n            zRing.name = \"rotate-z\";\r\n            this.gizmoGroup.add(zRing);\r\n        } else if (this.graphicsEditor.state.gizmoMode === \"scale\") {\r\n            const boxSize = 2;\r\n    \r\n            // X-axis (red)\r\n            const xBoxGeometry = new window.THREE.BoxGeometry(boxSize, boxSize, boxSize);\r\n            const xBoxMaterial = new window.THREE.MeshBasicMaterial({ color: 0xff0000 });\r\n            const xBox = new window.THREE.Mesh(xBoxGeometry, xBoxMaterial);\r\n            xBox.position.set(xOffset, 0, 0);\r\n            xBox.name = \"scale-x\";\r\n            this.gizmoGroup.add(xBox);\r\n    \r\n            // Y-axis (green)\r\n            const yBoxGeometry = new window.THREE.BoxGeometry(boxSize, boxSize, boxSize);\r\n            const yBoxMaterial = new window.THREE.MeshBasicMaterial({ color: 0x00ff00 });\r\n            const yBox = new window.THREE.Mesh(yBoxGeometry, yBoxMaterial);\r\n            yBox.position.set(0, yOffset, 0);\r\n            yBox.name = \"scale-y\";\r\n            this.gizmoGroup.add(yBox);\r\n    \r\n            // Z-axis (blue)\r\n            const zBoxGeometry = new window.THREE.BoxGeometry(boxSize, boxSize, boxSize);\r\n            const zBoxMaterial = new window.THREE.MeshBasicMaterial({ color: 0x0000ff });\r\n            const zBox = new window.THREE.Mesh(zBoxGeometry, zBoxMaterial);\r\n            zBox.position.set(0, 0, zOffset);\r\n            zBox.name = \"scale-z\";\r\n            this.gizmoGroup.add(zBox);\r\n        }\r\n    }   \r\n\r\n    setGizmoMode(mode) {\r\n        this.graphicsEditor.state.gizmoMode = mode;\r\n        this.createGizmo();\r\n    }\r\n\r\n    updateGizmoPosition() {\r\n        if (!this.currentTransformTarget || !this.gizmoGroup) return;\r\n                \r\n        let center = new window.THREE.Vector3();\r\n        let xOffset = 1, yOffset = 1, zOffset = 1;\r\n    \r\n        if (this.currentTransformTarget.children.length > 0) {\r\n            const boundingBox = new window.THREE.Box3().setFromObject(this.currentTransformTarget);\r\n            const size = new window.THREE.Vector3();\r\n            if (!boundingBox.isEmpty() && isFinite(boundingBox.min.x)) {\r\n                boundingBox.getSize(size);\r\n                boundingBox.getCenter(center);\r\n                xOffset = size.x / 2 + 1;\r\n                yOffset = size.y / 2 + 1;\r\n                zOffset = size.z / 2 + 1;\r\n            } else {\r\n                this.currentTransformTarget.getWorldPosition(center);\r\n                console.warn(\"Invalid bounding box; using group position.\");\r\n            }\r\n        } else {\r\n            const boundingBox = new window.THREE.Box3().setFromObject(this.currentTransformTarget);\r\n            const size = new window.THREE.Vector3();\r\n            if (!boundingBox.isEmpty() && isFinite(boundingBox.min.x)) {\r\n                boundingBox.getSize(size);\r\n                boundingBox.getCenter(center);\r\n                xOffset = size.x / 2 + 1;\r\n                yOffset = size.y / 2 + 1;\r\n                zOffset = size.z / 2 + 1;\r\n            } else {\r\n                this.currentTransformTarget.getWorldPosition(center);\r\n                console.warn(\"Invalid bounding box; using group position.\");\r\n            }\r\n        }\r\n    \r\n        this.gizmoGroup.position.copy(center);\r\n    \r\n        this.gizmoGroup.children.forEach(child => {\r\n            const name = child.name;\r\n            if (!name) return;\r\n    \r\n            child.position.set(0, 0, 0);\r\n    \r\n            if (name.startsWith(\"translate-\")) {\r\n                const arrowLength = 5;\r\n                const arrowHeadLength = 2;\r\n                if (name === \"translate-x\") {\r\n                    child.position.x = xOffset + (child.geometry.type === \"CylinderGeometry\" ? (arrowLength - arrowHeadLength) / 2 : arrowLength - arrowHeadLength / 2);\r\n                } else if (name === \"translate-y\") {\r\n                    child.position.y = yOffset + (child.geometry.type === \"CylinderGeometry\" ? (arrowLength - arrowHeadLength) / 2 : arrowLength - arrowHeadLength / 2);\r\n                } else if (name === \"translate-z\") {\r\n                    child.position.z = zOffset + (child.geometry.type === \"CylinderGeometry\" ? (arrowLength - arrowHeadLength) / 2 : arrowLength - arrowHeadLength / 2);\r\n                }\r\n            } else if (name.startsWith(\"rotate-\")) {\r\n                if (name === \"rotate-x\") child.position.x = xOffset;\r\n                else if (name === \"rotate-y\") child.position.y = yOffset;\r\n                else if (name === \"rotate-z\") child.position.z = zOffset;\r\n            } else if (name.startsWith(\"scale-\")) {\r\n                if (name === \"scale-x\") child.position.x = xOffset;\r\n                else if (name === \"scale-y\") child.position.y = yOffset;\r\n                else if (name === \"scale-z\") child.position.z = zOffset;\r\n            }\r\n        });\r\n    \r\n        // Ensure gizmoGroup is in scene (not rootGroup, as its a UI overlay)\r\n        if (!this.graphicsEditor.sceneRenderer.scene.children.includes(this.gizmoGroup)) {\r\n            this.graphicsEditor.sceneRenderer.scene.add(this.gizmoGroup);\r\n            console.warn(\"Gizmo was removed from scene; re-added.\");\r\n        }\r\n    }\r\n\r\n          \r\n    onMouseDown(event) {\r\n        if (!this.gizmoGroup) {\r\n            return;\r\n        }\r\n    \r\n        const canvas = this.graphicsEditor.sceneRenderer.renderer.domElement;\r\n        const rect = canvas.getBoundingClientRect();\r\n        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n    \r\n        this.raycaster.setFromCamera(this.mouse, this.graphicsEditor.sceneRenderer.camera);\r\n        const intersects = this.raycaster.intersectObjects(this.gizmoGroup.children, true);\r\n    \r\n        if (intersects.length > 0) {\r\n            const object = intersects[0].object;\r\n            this.selectedAxis = object.name.split('-')[1];\r\n            this.isDragging = true;\r\n            if (this.graphicsEditor.sceneRenderer.controls) {\r\n                this.graphicsEditor.sceneRenderer.controls.enabled = false;\r\n            }\r\n    \r\n            this.lastMouse.copy(this.mouse);\r\n        } else {\r\n            console.log(\"No intersection with gizmo\");\r\n        }\r\n    }\r\n\r\n    onMouseUp() {\r\n        this.isDragging = false;\r\n        this.selectedAxis = null;\r\n\r\n        if (this.graphicsEditor.sceneRenderer.controls) {\r\n            this.graphicsEditor.sceneRenderer.controls.enabled = true;\r\n        }\r\n    }\r\n    onDrag(event) {\r\n        if (!this.isDragging || !this.selectedAxis || !this.currentTransformTarget) return;\r\n        \r\n        const canvas = this.graphicsEditor.sceneRenderer.renderer.domElement;\r\n        const rect = canvas.getBoundingClientRect();\r\n        this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        const deltaMouse = this.mouse.clone().sub(this.lastMouse);\r\n        \r\n        const camera = this.graphicsEditor.sceneRenderer.camera;\r\n        const cameraPosition = camera.position.clone();\r\n        const objectPosition = this.currentTransformTarget.position.clone();\r\n        \r\n        const cameraRight = new window.THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);\r\n        const cameraUp = new window.THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);\r\n        const cameraForward = new window.THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);\r\n        const cameraToObject = objectPosition.clone().sub(cameraPosition);\r\n        \r\n        if (this.graphicsEditor.state.gizmoMode === \"translate\") {\r\n            const moveSpeed = 100;\r\n            \r\n            if (this.selectedAxis === \"x\") {\r\n                const worldX = new window.THREE.Vector3(1, 0, 0);\r\n                const dotProduct = worldX.dot(cameraRight);\r\n                const moveFactor = Math.sign(dotProduct) * deltaMouse.x * moveSpeed;\r\n                this.currentTransformTarget.position.x += moveFactor;\r\n            } else if (this.selectedAxis === \"y\") {\r\n                const worldY = new window.THREE.Vector3(0, 1, 0);\r\n                const dotProduct = worldY.dot(cameraUp);\r\n                const moveFactor = Math.sign(dotProduct) * deltaMouse.y * moveSpeed;\r\n                this.currentTransformTarget.position.y += moveFactor;\r\n            } else if (this.selectedAxis === \"z\") {\r\n                const worldZ = new window.THREE.Vector3(0, 0, 1);\r\n                const cameraRightXZ = new window.THREE.Vector3(cameraRight.x, 0, cameraRight.z).normalize();\r\n                const dotProduct = worldZ.dot(cameraRightXZ);\r\n                const moveFactor = Math.sign(dotProduct) * deltaMouse.x * moveSpeed;\r\n                this.currentTransformTarget.position.z += moveFactor;\r\n            }\r\n        } else if (this.graphicsEditor.state.gizmoMode === \"rotate\") {\r\n            const rotateSpeed = 2 * Math.PI;\r\n            \r\n            if (this.selectedAxis === \"x\") {\r\n                const worldX = new window.THREE.Vector3(1, 0, 0);\r\n                const dotProduct = worldX.dot(cameraRight);\r\n                const rotateFactor = -Math.sign(dotProduct) * deltaMouse.x * rotateSpeed;\r\n                this.currentTransformTarget.rotation.x += rotateFactor;\r\n            } else if (this.selectedAxis === \"y\") {\r\n                const worldY = new window.THREE.Vector3(0, 1, 0);\r\n                const dotProduct = worldY.dot(cameraUp);\r\n                const rotateFactor = Math.sign(dotProduct) * deltaMouse.x * rotateSpeed;\r\n                this.currentTransformTarget.rotation.y += rotateFactor;\r\n            } else if (this.selectedAxis === \"z\") {\r\n                const worldZ = new window.THREE.Vector3(0, 0, 1);\r\n                const dotProduct = cameraToObject.normalize().dot(worldZ);\r\n                const rotateFactor = Math.sign(dotProduct) * deltaMouse.x * rotateSpeed;\r\n                this.currentTransformTarget.rotation.z += rotateFactor;\r\n            }\r\n        } else if (this.graphicsEditor.state.gizmoMode === \"scale\") {\r\n            const scaleSpeed = 2;\r\n            let scaleFactor = 0;\r\n            \r\n            if (this.selectedAxis === \"x\") {\r\n                const worldX = new window.THREE.Vector3(1, 0, 0);\r\n                const dotProduct = worldX.dot(cameraRight);\r\n                scaleFactor = Math.sign(dotProduct) * deltaMouse.x * scaleSpeed;\r\n            } else if (this.selectedAxis === \"y\") {\r\n                const worldY = new window.THREE.Vector3(0, 1, 0);\r\n                const dotProduct = worldY.dot(cameraUp);\r\n                scaleFactor = Math.sign(dotProduct) * deltaMouse.y * scaleSpeed;\r\n            } else if (this.selectedAxis === \"z\") {\r\n                const worldZ = new window.THREE.Vector3(0, 0, 1);\r\n                const cameraRightXZ = new window.THREE.Vector3(cameraRight.x, 0, cameraRight.z).normalize();\r\n                const dotProduct = worldZ.dot(cameraRightXZ);\r\n                scaleFactor = Math.sign(dotProduct) * deltaMouse.x * scaleSpeed;\r\n            }\r\n            \r\n            if (this.selectedAxis === \"x\") {\r\n                this.currentTransformTarget.scale.x += scaleFactor;\r\n                if (this.currentTransformTarget.scale.x < 0.1) this.currentTransformTarget.scale.x = 0.1;\r\n            } else if (this.selectedAxis === \"y\") {\r\n                this.currentTransformTarget.scale.y += scaleFactor;\r\n                if (this.currentTransformTarget.scale.y < 0.1) this.currentTransformTarget.scale.y = 0.1;\r\n            } else if (this.selectedAxis === \"z\") {\r\n                this.currentTransformTarget.scale.z += scaleFactor;\r\n                if (this.currentTransformTarget.scale.z < 0.1) this.currentTransformTarget.scale.z = 0.1;\r\n            }\r\n        }\r\n        this.updateGizmoPosition();\r\n        this.lastMouse.copy(this.mouse);\r\n        this.updateInspectorValues();\r\n        this.applyCurrentTransform(); \r\n    }\r\n\r\n    updateInspectorValues() {\r\n        if (!this.currentTransformTarget) return;\r\n        \r\n        // Update all relevant input fields\r\n        const updateInput = (property, value) => {\r\n            const input = document.querySelector(`[data-property=\"${property}\"]`);\r\n            if (input) input.value = value;\r\n        };\r\n        \r\n        // Position\r\n        updateInput('x', this.currentTransformTarget.position.x);\r\n        updateInput('y', this.currentTransformTarget.position.y);\r\n        updateInput('z', this.currentTransformTarget.position.z);\r\n        \r\n        // Rotation (convert to degrees)\r\n        updateInput('rotationX', this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.x));\r\n        updateInput('rotationY', this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.y));\r\n        updateInput('rotationZ', this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.z));\r\n        \r\n        // Scale\r\n        updateInput('scaleX', this.currentTransformTarget.scale.x);\r\n        updateInput('scaleY', this.currentTransformTarget.scale.y);\r\n        updateInput('scaleZ', this.currentTransformTarget.scale.z);\r\n    }\r\n \r\n    applyCurrentTransform() {\r\n        if (!this.currentTransformTarget) return;\r\n    \r\n        // For groups\r\n        if (this.currentTransformTarget.userData?.isGroup) {\r\n            const groupId = this.currentTransformTarget.name;\r\n            const groupData = this.graphicsEditor.groupManager.getGroupData(groupId);\r\n            \r\n            // Directly update group transform without full refresh\r\n            groupData.position = {\r\n                x: this.currentTransformTarget.position.x,\r\n                y: this.currentTransformTarget.position.y,\r\n                z: this.currentTransformTarget.position.z\r\n            };\r\n            groupData.rotation = {\r\n                x: this.currentTransformTarget.rotation.x,\r\n                y: this.currentTransformTarget.rotation.y,\r\n                z: this.currentTransformTarget.rotation.z\r\n            };\r\n            groupData.scale = {\r\n                x: this.currentTransformTarget.scale.x,\r\n                y: this.currentTransformTarget.scale.y,\r\n                z: this.currentTransformTarget.scale.z\r\n            };\r\n        }\r\n        // For individual shapes\r\n        else if (this.graphicsEditor.state.selectedShapeIndex >= 0) {\r\n            const shape = this.graphicsEditor.shapeManager.getShapeData(this.graphicsEditor.state.selectedShapeIndex);\r\n            if (shape) {\r\n                if(!shape.position) shape.position = {};\r\n                if(!shape.rotation) shape.rotation = {};\r\n                if(!shape.scale) shape.scale = {};\r\n                \r\n                shape.position.x = this.currentTransformTarget.position.x;\r\n                shape.position.y = this.currentTransformTarget.position.y;\r\n                shape.position.z = this.currentTransformTarget.position.z;\r\n                \r\n                shape.rotation.x = this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.x);\r\n                shape.rotation.y = this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.y);\r\n                shape.rotation.z = this.graphicsEditor.rotationUtils.radToDeg(this.currentTransformTarget.rotation.z);\r\n                \r\n                shape.scale.x = this.currentTransformTarget.scale.x;\r\n                shape.scale.y = this.currentTransformTarget.scale.y;\r\n                shape.scale.z = this.currentTransformTarget.scale.z;\r\n            }\r\n        }\r\n        this.graphicsEditor.renderShapes(false);\r\n        // Optional: Auto-save or trigger update\r\n    }\r\n\r\n\r\n    transformSelectedObject(targetObject) {\r\n        if(!targetObject){\r\n            targetObject = this.graphicsEditor.getSelectedObject();\r\n        }\r\n        console.log('transform', targetObject);\r\n        // Determine the target object - prioritize the passed target, then selected group, then rootGroup\r\n        let target;\r\n        if (targetObject) {\r\n            target = targetObject;\r\n        } else {\r\n            // Try to get the currently selected group\r\n            const currentGroup = this.graphicsEditor.state.currentGroup;\r\n            if (currentGroup) {\r\n                // Find the group in the scene\r\n                this.graphicsEditor.rootGroup.traverse(obj => {\r\n                    if (obj.isGroup && obj.name === currentGroup && obj.userData.isGroup) {\r\n                        target = obj;\r\n                    }\r\n                });\r\n            }\r\n            \r\n            // Fall back to rootGroup if no selected group found\r\n            if (!target) {\r\n                target = this.graphicsEditor.rootGroup;\r\n            }\r\n        }\r\n    \r\n        // If we still don't have a target, return\r\n        if (!target) return;\r\n    \r\n        this.currentTransformTarget = target;\r\n    \r\n        // If target is a group, ensure it's in rootGroup and populated\r\n        if (this.currentTransformTarget.userData?.isGroup) {\r\n            const groupId = this.currentTransformTarget.userData.groupId;\r\n            const group = this.graphicsEditor.groupManager.getGroupObject(groupId);\r\n            if (group) {\r\n                // Ensure group is in rootGroup\r\n                if (this.currentTransformTarget.parent !== this.graphicsEditor.rootGroup) {\r\n                    if (this.currentTransformTarget.parent) {\r\n                        this.currentTransformTarget.parent.remove(this.currentTransformTarget);\r\n                    }\r\n                    this.graphicsEditor.rootGroup.add(this.currentTransformTarget);\r\n                }    \r\n            }\r\n        }\r\n    \r\n        this.originalPosition.copy(this.currentTransformTarget.position);\r\n        this.originalRotation.copy(this.currentTransformTarget.rotation);\r\n        this.originalScale.copy(this.currentTransformTarget.scale);\r\n        \r\n        // Inject transform controls into inspector instead of creating separate UI\r\n        this.injectTransformControlsToInspector();\r\n        this.updateGizmoPosition();\r\n    }\r\n      \r\n    injectTransformControlsToInspector() {\r\n        const inspector = document.getElementById('inspector');\r\n        \r\n        // Create transform controls section\r\n        const transformSection = document.createElement('div');\r\n        transformSection.className = 'transform-controls-section';\r\n        transformSection.innerHTML = `\r\n            <h3>Transform ${this.currentTransformTarget.name || 'Current Frame'}</h3>\r\n            <div class=\"transform-buttons\">\r\n                <button id=\"translate-btn\" class=\"${this.gizmoMode === 'translate' ? 'active' : ''}\">Translate</button>\r\n                <button id=\"rotate-btn\" class=\"${this.gizmoMode === 'rotate' ? 'active' : ''}\">Rotate</button>\r\n                <button id=\"scale-btn\" class=\"${this.gizmoMode === 'scale' ? 'active' : ''}\">Scale</button>\r\n            </div>\r\n        `;\r\n        // Insert at the top of the inspector\r\n        if (inspector.firstChild) {\r\n            inspector.insertBefore(transformSection, inspector.firstChild);\r\n        } else {\r\n            inspector.appendChild(transformSection);\r\n        }      \r\n        // Add event listeners for transform mode buttons\r\n        document.getElementById('translate-btn').addEventListener('click', () => {\r\n            this.setGizmoMode('translate');\r\n            this.updateModeButtonsUI();\r\n        });\r\n        \r\n        document.getElementById('rotate-btn').addEventListener('click', () => {\r\n            this.setGizmoMode('rotate');\r\n            this.updateModeButtonsUI();\r\n        });\r\n        \r\n        document.getElementById('scale-btn').addEventListener('click', () => {\r\n            this.setGizmoMode('scale');\r\n            this.updateModeButtonsUI();\r\n        });\r\n        \r\n        this.updateInspectorValues();\r\n        this.setGizmoMode('translate');\r\n        this.updateModeButtonsUI();\r\n    }\r\n    \r\n    updateModeButtonsUI() {\r\n        const translateBtn = document.getElementById('translate-btn');\r\n        const rotateBtn = document.getElementById('rotate-btn');\r\n        const scaleBtn = document.getElementById('scale-btn');\r\n        \r\n        translateBtn.className = this.gizmoMode === 'translate' ? 'active' : '';\r\n        rotateBtn.className = this.gizmoMode === 'rotate' ? 'active' : '';\r\n        scaleBtn.className = this.gizmoMode === 'scale' ? 'active' : '';\r\n    }\r\n    \r\n}",
        "filePath": "/global/libraries/js/GE_GizmoManager.js"
      },
      "GLTFLoader": {
        "title": "GLTF Loader",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "GLTFLoader",
        "importName": "GLTFLoader",
        "fileName": "GLTFLoader",
        "filePath": "/global/libraries/js/GLTFLoader.js",
        "script": "import {\r\n\tAnimationClip,\r\n\tBone,\r\n\tBox3,\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tClampToEdgeWrapping,\r\n\tColor,\r\n\tColorManagement,\r\n\tDirectionalLight,\r\n\tDoubleSide,\r\n\tFileLoader,\r\n\tFrontSide,\r\n\tGroup,\r\n\tImageBitmapLoader,\r\n\tInstancedMesh,\r\n\tInterleavedBuffer,\r\n\tInterleavedBufferAttribute,\r\n\tInterpolant,\r\n\tInterpolateDiscrete,\r\n\tInterpolateLinear,\r\n\tLine,\r\n\tLineBasicMaterial,\r\n\tLineLoop,\r\n\tLineSegments,\r\n\tLinearFilter,\r\n\tLinearMipmapLinearFilter,\r\n\tLinearMipmapNearestFilter,\r\n\tLinearSRGBColorSpace,\r\n\tLoader,\r\n\tLoaderUtils,\r\n\tMaterial,\r\n\tMathUtils,\r\n\tMatrix4,\r\n\tMesh,\r\n\tMeshBasicMaterial,\r\n\tMeshPhysicalMaterial,\r\n\tMeshStandardMaterial,\r\n\tMirroredRepeatWrapping,\r\n\tNearestFilter,\r\n\tNearestMipmapLinearFilter,\r\n\tNearestMipmapNearestFilter,\r\n\tNumberKeyframeTrack,\r\n\tObject3D,\r\n\tOrthographicCamera,\r\n\tPerspectiveCamera,\r\n\tPointLight,\r\n\tPoints,\r\n\tPointsMaterial,\r\n\tPropertyBinding,\r\n\tQuaternion,\r\n\tQuaternionKeyframeTrack,\r\n\tRepeatWrapping,\r\n\tSkeleton,\r\n\tSkinnedMesh,\r\n\tSphere,\r\n\tSpotLight,\r\n\tTexture,\r\n\tTextureLoader,\r\n\tTriangleFanDrawMode,\r\n\tTriangleStripDrawMode,\r\n\tVector2,\r\n\tVector3,\r\n\tVectorKeyframeTrack,\r\n\tSRGBColorSpace,\r\n\tInstancedBufferAttribute\r\n} from 'three';\r\nimport { toTrianglesDrawMode } from './BufferGeometryUtils.js';\r\n\r\n/**\r\n * A loader for the glTF 2.0 format.\r\n *\r\n * [glTF]{@link https://www.khronos.org/gltf/} (GL Transmission Format) is an [open format specification]{@link https://github.com/KhronosGroup/glTF/tree/main/specification/2.0}\r\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf) or binary (.glb)\r\n * format. External files store textures (.jpg, .png) and additional binary data (.bin). A glTF asset may deliver\r\n * one or more scenes, including meshes, materials, textures, skins, skeletons, morph targets, animations, lights,\r\n * and/or cameras.\r\n *\r\n * `GLTFLoader` uses {@link ImageBitmapLoader} whenever possible. Be advised that image bitmaps are not\r\n * automatically GC-collected when they are no longer referenced, and they require special handling during\r\n * the disposal process.\r\n *\r\n * `GLTFLoader` supports the following glTF 2.0 extensions:\r\n * - KHR_draco_mesh_compression\r\n * - KHR_materials_clearcoat\r\n * - KHR_materials_dispersion\r\n * - KHR_materials_ior\r\n * - KHR_materials_specular\r\n * - KHR_materials_transmission\r\n * - KHR_materials_iridescence\r\n * - KHR_materials_unlit\r\n * - KHR_materials_volume\r\n * - KHR_mesh_quantization\r\n * - KHR_lights_punctual\r\n * - KHR_texture_basisu\r\n * - KHR_texture_transform\r\n * - EXT_texture_webp\r\n * - EXT_meshopt_compression\r\n * - EXT_mesh_gpu_instancing\r\n *\r\n * The following glTF 2.0 extension is supported by an external user plugin:\r\n * - [KHR_materials_variants]{@link https://github.com/takahirox/three-gltf-extensions}\r\n * - [MSFT_texture_dds]{@link https://github.com/takahirox/three-gltf-extensions}\r\n *\r\n * ```js\r\n * const loader = new GLTFLoader();\r\n *\r\n * // Optional: Provide a DRACOLoader instance to decode compressed mesh data\r\n * const dracoLoader = new DRACOLoader();\r\n * dracoLoader.setDecoderPath( '/examples/jsm/libs/draco/' );\r\n * loader.setDRACOLoader( dracoLoader );\r\n *\r\n * const gltf = await loader.loadAsync( 'models/gltf/duck/duck.gltf' );\r\n * scene.add( gltf.scene );\r\n * ```\r\n *\r\n * @augments Loader\r\n * @three_import import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';\r\n */\r\nclass GLTFLoader extends Loader {\r\n\r\n\t/**\r\n\t * Constructs a new glTF loader.\r\n\t *\r\n\t * @param {LoadingManager} [manager] - The loading manager.\r\n\t */\r\n\tconstructor( manager ) {\r\n\r\n\t\tsuper( manager );\r\n\r\n\t\tthis.dracoLoader = null;\r\n\t\tthis.ktx2Loader = null;\r\n\t\tthis.meshoptDecoder = null;\r\n\r\n\t\tthis.pluginCallbacks = [];\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsClearcoatExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsDispersionExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureBasisUExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureWebPExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFTextureAVIFExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSheenExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsTransmissionExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsVolumeExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsIorExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsSpecularExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsIridescenceExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMaterialsBumpExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFLightsExtension( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMeshoptCompression( parser );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.register( function ( parser ) {\r\n\r\n\t\t\treturn new GLTFMeshGpuInstancing( parser );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Starts loading from the given URL and passes the loaded glTF asset\r\n\t * to the `onLoad()` callback.\r\n\t *\r\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\r\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\r\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\r\n\t * @param {onErrorCallback} onError - Executed when errors occur.\r\n\t */\r\n\tload( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tlet resourcePath;\r\n\r\n\t\tif ( this.resourcePath !== '' ) {\r\n\r\n\t\t\tresourcePath = this.resourcePath;\r\n\r\n\t\t} else if ( this.path !== '' ) {\r\n\r\n\t\t\t// If a base path is set, resources will be relative paths from that plus the relative path of the gltf file\r\n\t\t\t// Example  path = 'https://my-cnd-server.com/', url = 'assets/models/model.gltf'\r\n\t\t\t// resourcePath = 'https://my-cnd-server.com/assets/models/'\r\n\t\t\t// referenced resource 'model.bin' will be loaded from 'https://my-cnd-server.com/assets/models/model.bin'\r\n\t\t\t// referenced resource '../textures/texture.png' will be loaded from 'https://my-cnd-server.com/assets/textures/texture.png'\r\n\t\t\tconst relativeUrl = LoaderUtils.extractUrlBase( url );\r\n\t\t\tresourcePath = LoaderUtils.resolveURL( relativeUrl, this.path );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresourcePath = LoaderUtils.extractUrlBase( url );\r\n\r\n\t\t}\r\n\r\n\t\t// Tells the LoadingManager to track an extra item, which resolves after\r\n\t\t// the model is fully loaded. This means the count of items loaded will\r\n\t\t// be incorrect, but ensures manager.onLoad() does not fire early.\r\n\t\tthis.manager.itemStart( url );\r\n\r\n\t\tconst _onError = function ( e ) {\r\n\r\n\t\t\tif ( onError ) {\r\n\r\n\t\t\t\tonError( e );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t};\r\n\r\n\t\tconst loader = new FileLoader( this.manager );\r\n\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.setRequestHeader( this.requestHeader );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\r\n\t\tloader.load( url, function ( data ) {\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tscope.parse( data, resourcePath, function ( gltf ) {\r\n\r\n\t\t\t\t\tonLoad( gltf );\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, _onError );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\t_onError( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, _onError );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the given Draco loader to this loader. Required for decoding assets\r\n\t * compressed with the `KHR_draco_mesh_compression` extension.\r\n\t *\r\n\t * @param {DRACOLoader} dracoLoader - The Draco loader to set.\r\n\t * @return {GLTFLoader} A reference to this loader.\r\n\t */\r\n\tsetDRACOLoader( dracoLoader ) {\r\n\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the given KTX2 loader to this loader. Required for loading KTX2\r\n\t * compressed textures.\r\n\t *\r\n\t * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.\r\n\t * @return {GLTFLoader} A reference to this loader.\r\n\t */\r\n\tsetKTX2Loader( ktx2Loader ) {\r\n\r\n\t\tthis.ktx2Loader = ktx2Loader;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the given meshopt decoder. Required for decoding assets\r\n\t * compressed with the `EXT_meshopt_compression` extension.\r\n\t *\r\n\t * @param {Object} meshoptDecoder - The meshopt decoder to set.\r\n\t * @return {GLTFLoader} A reference to this loader.\r\n\t */\r\n\tsetMeshoptDecoder( meshoptDecoder ) {\r\n\r\n\t\tthis.meshoptDecoder = meshoptDecoder;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a plugin callback. This API is internally used to implement the various\r\n\t * glTF extensions but can also used by third-party code to add additional logic\r\n\t * to the loader.\r\n\t *\r\n\t * @param {function(parser:GLTFParser)} callback - The callback function to register.\r\n\t * @return {GLTFLoader} A reference to this loader.\r\n\t */\r\n\tregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.push( callback );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Unregisters a plugin callback.\r\n\t *\r\n\t * @param {Function} callback - The callback function to unregister.\r\n\t * @return {GLTFLoader} A reference to this loader.\r\n\t */\r\n\tunregister( callback ) {\r\n\r\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\r\n\r\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Parses the given FBX data and returns the resulting group.\r\n\t *\r\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\r\n\t * @param {string} path - The URL base path.\r\n\t * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.\r\n\t * @param {onErrorCallback} onError - Executed when errors occur.\r\n\t */\r\n\tparse( data, path, onLoad, onError ) {\r\n\r\n\t\tlet json;\r\n\t\tconst extensions = {};\r\n\t\tconst plugins = {};\r\n\t\tconst textDecoder = new TextDecoder();\r\n\r\n\t\tif ( typeof data === 'string' ) {\r\n\r\n\t\t\tjson = JSON.parse( data );\r\n\r\n\t\t} else if ( data instanceof ArrayBuffer ) {\r\n\r\n\t\t\tconst magic = textDecoder.decode( new Uint8Array( data, 0, 4 ) );\r\n\r\n\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\t\ttry {\r\n\r\n\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\r\n\r\n\t\t\t\t} catch ( error ) {\r\n\r\n\t\t\t\t\tif ( onError ) onError( error );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tjson = JSON.parse( extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tjson = JSON.parse( textDecoder.decode( data ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tjson = data;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\r\n\r\n\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst parser = new GLTFParser( json, {\r\n\r\n\t\t\tpath: path || this.resourcePath || '',\r\n\t\t\tcrossOrigin: this.crossOrigin,\r\n\t\t\trequestHeader: this.requestHeader,\r\n\t\t\tmanager: this.manager,\r\n\t\t\tktx2Loader: this.ktx2Loader,\r\n\t\t\tmeshoptDecoder: this.meshoptDecoder\r\n\r\n\t\t} );\r\n\r\n\t\tparser.fileLoader.setRequestHeader( this.requestHeader );\r\n\r\n\t\tfor ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {\r\n\r\n\t\t\tconst plugin = this.pluginCallbacks[ i ]( parser );\r\n\r\n\t\t\tif ( ! plugin.name ) console.error( 'THREE.GLTFLoader: Invalid plugin found: missing name' );\r\n\r\n\t\t\tplugins[ plugin.name ] = plugin;\r\n\r\n\t\t\t// Workaround to avoid determining as unknown extension\r\n\t\t\t// in addUnknownExtensionsToUserData().\r\n\t\t\t// Remove this workaround if we move all the existing\r\n\t\t\t// extension handlers to plugin system\r\n\t\t\textensions[ plugin.name ] = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.extensionsUsed ) {\r\n\r\n\t\t\tfor ( let i = 0; i < json.extensionsUsed.length; ++ i ) {\r\n\r\n\t\t\t\tconst extensionName = json.extensionsUsed[ i ];\r\n\t\t\t\tconst extensionsRequired = json.extensionsRequired || [];\r\n\r\n\t\t\t\tswitch ( extensionName ) {\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFTextureTransformExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n\t\t\t\t\t\textensions[ extensionName ] = new GLTFMeshQuantizationExtension();\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tparser.setExtensions( extensions );\r\n\t\tparser.setPlugins( plugins );\r\n\t\tparser.parse( onLoad, onError );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Async version of {@link GLTFLoader#parse}.\r\n\t *\r\n\t * @async\r\n\t * @param {string|ArrayBuffer} data - The raw glTF data.\r\n\t * @param {string} path - The URL base path.\r\n\t * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.\r\n\t */\r\n\tparseAsync( data, path ) {\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tscope.parse( data, path, resolve, reject );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* GLTFREGISTRY */\r\n\r\nfunction GLTFRegistry() {\r\n\r\n\tlet objects = {};\r\n\r\n\treturn\t{\r\n\r\n\t\tget: function ( key ) {\r\n\r\n\t\t\treturn objects[ key ];\r\n\r\n\t\t},\r\n\r\n\t\tadd: function ( key, object ) {\r\n\r\n\t\t\tobjects[ key ] = object;\r\n\r\n\t\t},\r\n\r\n\t\tremove: function ( key ) {\r\n\r\n\t\t\tdelete objects[ key ];\r\n\r\n\t\t},\r\n\r\n\t\tremoveAll: function () {\r\n\r\n\t\t\tobjects = {};\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}\r\n\r\n/*********************************/\r\n/********** EXTENSIONS ***********/\r\n/*********************************/\r\n\r\nconst EXTENSIONS = {\r\n\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\r\n\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\r\n\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\r\n\tKHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',\r\n\tKHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',\r\n\tKHR_MATERIALS_IOR: 'KHR_materials_ior',\r\n\tKHR_MATERIALS_SHEEN: 'KHR_materials_sheen',\r\n\tKHR_MATERIALS_SPECULAR: 'KHR_materials_specular',\r\n\tKHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',\r\n\tKHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',\r\n\tKHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',\r\n\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\r\n\tKHR_MATERIALS_VOLUME: 'KHR_materials_volume',\r\n\tKHR_TEXTURE_BASISU: 'KHR_texture_basisu',\r\n\tKHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',\r\n\tKHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',\r\n\tKHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',\r\n\tEXT_MATERIALS_BUMP: 'EXT_materials_bump',\r\n\tEXT_TEXTURE_WEBP: 'EXT_texture_webp',\r\n\tEXT_TEXTURE_AVIF: 'EXT_texture_avif',\r\n\tEXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',\r\n\tEXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'\r\n};\r\n\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n *\r\n * @private\r\n */\r\nclass GLTFLightsExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.cache = { refs: {}, uses: {} };\r\n\r\n\t}\r\n\r\n\t_markDefs() {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst nodeDefs = this.parser.json.nodes || [];\r\n\r\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.extensions\r\n\t\t\t\t\t&& nodeDef.extensions[ this.name ]\r\n\t\t\t\t\t&& nodeDef.extensions[ this.name ].light !== undefined ) {\r\n\r\n\t\t\t\tparser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_loadLight( lightIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst cacheKey = 'light:' + lightIndex;\r\n\t\tlet dependency = parser.cache.get( cacheKey );\r\n\r\n\t\tif ( dependency ) return dependency;\r\n\r\n\t\tconst json = parser.json;\r\n\t\tconst extensions = ( json.extensions && json.extensions[ this.name ] ) || {};\r\n\t\tconst lightDefs = extensions.lights || [];\r\n\t\tconst lightDef = lightDefs[ lightIndex ];\r\n\t\tlet lightNode;\r\n\r\n\t\tconst color = new Color( 0xffffff );\r\n\r\n\t\tif ( lightDef.color !== undefined ) color.setRGB( lightDef.color[ 0 ], lightDef.color[ 1 ], lightDef.color[ 2 ], LinearSRGBColorSpace );\r\n\r\n\t\tconst range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n\t\tswitch ( lightDef.type ) {\r\n\r\n\t\t\tcase 'directional':\r\n\t\t\t\tlightNode = new DirectionalLight( color );\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'point':\r\n\t\t\t\tlightNode = new PointLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'spot':\r\n\t\t\t\tlightNode = new SpotLight( color );\r\n\t\t\t\tlightNode.distance = range;\r\n\t\t\t\t// Handle spotlight properties.\r\n\t\t\t\tlightDef.spot = lightDef.spot || {};\r\n\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\r\n\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\r\n\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n\t\t\t\tlightNode.target.position.set( 0, 0, - 1 );\r\n\t\t\t\tlightNode.add( lightNode.target );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );\r\n\r\n\t\t}\r\n\r\n\t\t// Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n\t\t// here, because node-level parsing will only override position if explicitly specified.\r\n\t\tlightNode.position.set( 0, 0, 0 );\r\n\r\n\t\tassignExtrasToUserData( lightNode, lightDef );\r\n\r\n\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\r\n\r\n\t\tlightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );\r\n\r\n\t\tdependency = Promise.resolve( lightNode );\r\n\r\n\t\tparser.cache.add( cacheKey, dependency );\r\n\r\n\t\treturn dependency;\r\n\r\n\t}\r\n\r\n\tgetDependency( type, index ) {\r\n\r\n\t\tif ( type !== 'light' ) return;\r\n\r\n\t\treturn this._loadLight( index );\r\n\r\n\t}\r\n\r\n\tcreateNodeAttachment( nodeIndex ) {\r\n\r\n\t\tconst self = this;\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\t\tconst lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};\r\n\t\tconst lightIndex = lightDef.light;\r\n\r\n\t\tif ( lightIndex === undefined ) return null;\r\n\r\n\t\treturn this._loadLight( lightIndex ).then( function ( light ) {\r\n\r\n\t\t\treturn parser._getNodeRef( self.cache, lightIndex, light );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsUnlitExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n\r\n\t}\r\n\r\n\tgetMaterialType() {\r\n\r\n\t\treturn MeshBasicMaterial;\r\n\r\n\t}\r\n\r\n\textendParams( materialParams, materialDef, parser ) {\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n\t\tif ( metallicRoughness ) {\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Emissive Strength Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsEmissiveStrengthExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;\r\n\r\n\t\tif ( emissiveStrength !== undefined ) {\r\n\r\n\t\t\tmaterialParams.emissiveIntensity = emissiveStrength;\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.resolve();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsClearcoatExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.clearcoatFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoat = extension.clearcoatFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.clearcoatNormalTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );\r\n\r\n\t\t\tif ( extension.clearcoatNormalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tconst scale = extension.clearcoatNormalTexture.scale;\r\n\r\n\t\t\t\tmaterialParams.clearcoatNormalScale = new Vector2( scale, scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials dispersion Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_dispersion\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsDispersionExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;\r\n\r\n\t\treturn Promise.resolve();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Iridescence Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsIridescenceExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.iridescenceFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.iridescence = extension.iridescenceFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.iridescenceTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.iridescenceIor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.iridescenceIOR = extension.iridescenceIor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialParams.iridescenceThicknessRange === undefined ) {\r\n\r\n\t\t\tmaterialParams.iridescenceThicknessRange = [ 100, 400 ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.iridescenceThicknessMinimum !== undefined ) {\r\n\r\n\t\t\tmaterialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.iridescenceThicknessMaximum !== undefined ) {\r\n\r\n\t\t\tmaterialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.iridescenceThicknessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Sheen Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsSheenExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SHEEN;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tmaterialParams.sheenColor = new Color( 0, 0, 0 );\r\n\t\tmaterialParams.sheenRoughness = 0;\r\n\t\tmaterialParams.sheen = 1;\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.sheenColorFactor !== undefined ) {\r\n\r\n\t\t\tconst colorFactor = extension.sheenColorFactor;\r\n\t\t\tmaterialParams.sheenColor.setRGB( colorFactor[ 0 ], colorFactor[ 1 ], colorFactor[ 2 ], LinearSRGBColorSpace );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenRoughnessFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.sheenRoughness = extension.sheenRoughnessFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenColorTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, SRGBColorSpace ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.sheenRoughnessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsTransmissionExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.transmissionFactor !== undefined ) {\r\n\r\n\t\t\tmaterialParams.transmission = extension.transmissionFactor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.transmissionTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsVolumeExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_VOLUME;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;\r\n\r\n\t\tif ( extension.thicknessTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tmaterialParams.attenuationDistance = extension.attenuationDistance || Infinity;\r\n\r\n\t\tconst colorArray = extension.attenuationColor || [ 1, 1, 1 ];\r\n\t\tmaterialParams.attenuationColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials ior Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsIorExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_IOR;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;\r\n\r\n\t\treturn Promise.resolve();\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials specular Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsSpecularExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;\r\n\r\n\t\tif ( extension.specularTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst colorArray = extension.specularColorFactor || [ 1, 1, 1 ];\r\n\t\tmaterialParams.specularColor = new Color().setRGB( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ], LinearSRGBColorSpace );\r\n\r\n\t\tif ( extension.specularColorTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, SRGBColorSpace ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * Materials bump Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsBumpExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_MATERIALS_BUMP;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tmaterialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;\r\n\r\n\t\tif ( extension.bumpTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'bumpMap', extension.bumpTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Materials anisotropy Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_anisotropy\r\n *\r\n * @private\r\n */\r\nclass GLTFMaterialsAnisotropyExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( materialIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;\r\n\r\n\t\treturn MeshPhysicalMaterial;\r\n\r\n\t}\r\n\r\n\textendMaterialParams( materialIndex, materialParams ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst materialDef = parser.json.materials[ materialIndex ];\r\n\r\n\t\tif ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn Promise.resolve();\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst extension = materialDef.extensions[ this.name ];\r\n\r\n\t\tif ( extension.anisotropyStrength !== undefined ) {\r\n\r\n\t\t\tmaterialParams.anisotropy = extension.anisotropyStrength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.anisotropyRotation !== undefined ) {\r\n\r\n\t\t\tmaterialParams.anisotropyRotation = extension.anisotropyRotation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension.anisotropyTexture !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'anisotropyMap', extension.anisotropyTexture ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * BasisU Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n *\r\n * @private\r\n */\r\nclass GLTFTextureBasisUExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n\r\n\t}\r\n\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = textureDef.extensions[ this.name ];\r\n\t\tconst loader = parser.options.ktx2Loader;\r\n\r\n\t\tif ( ! loader ) {\r\n\r\n\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Assumes that the extension is optional and that a fallback texture is present\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * WebP Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n *\r\n * @private\r\n */\r\nclass GLTFTextureWebPExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n\r\n\t}\r\n\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst name = this.name;\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = textureDef.extensions[ name ];\r\n\t\tconst source = json.images[ extension.source ];\r\n\r\n\t\tlet loader = parser.textureLoader;\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * AVIF Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif\r\n *\r\n * @private\r\n */\r\nclass GLTFTextureAVIFExtension {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.parser = parser;\r\n\t\tthis.name = EXTENSIONS.EXT_TEXTURE_AVIF;\r\n\r\n\t}\r\n\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst name = this.name;\r\n\t\tconst parser = this.parser;\r\n\t\tconst json = parser.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\r\n\t\tif ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst extension = textureDef.extensions[ name ];\r\n\t\tconst source = json.images[ extension.source ];\r\n\r\n\t\tlet loader = parser.textureLoader;\r\n\t\tif ( source.uri ) {\r\n\r\n\t\t\tconst handler = parser.options.manager.getHandler( source.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.loadTextureImage( textureIndex, extension.source, loader );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * meshopt BufferView Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n *\r\n * @private\r\n */\r\nclass GLTFMeshoptCompression {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n\t\tthis.parser = parser;\r\n\r\n\t}\r\n\r\n\tloadBufferView( index ) {\r\n\r\n\t\tconst json = this.parser.json;\r\n\t\tconst bufferView = json.bufferViews[ index ];\r\n\r\n\t\tif ( bufferView.extensions && bufferView.extensions[ this.name ] ) {\r\n\r\n\t\t\tconst extensionDef = bufferView.extensions[ this.name ];\r\n\r\n\t\t\tconst buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );\r\n\t\t\tconst decoder = this.parser.options.meshoptDecoder;\r\n\r\n\t\t\tif ( ! decoder || ! decoder.supported ) {\r\n\r\n\t\t\t\tif ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Assumes that the extension is optional and that fallback buffer data is present\r\n\t\t\t\t\treturn null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer.then( function ( res ) {\r\n\r\n\t\t\t\tconst byteOffset = extensionDef.byteOffset || 0;\r\n\t\t\t\tconst byteLength = extensionDef.byteLength || 0;\r\n\r\n\t\t\t\tconst count = extensionDef.count;\r\n\t\t\t\tconst stride = extensionDef.byteStride;\r\n\r\n\t\t\t\tconst source = new Uint8Array( res, byteOffset, byteLength );\r\n\r\n\t\t\t\tif ( decoder.decodeGltfBufferAsync ) {\r\n\r\n\t\t\t\t\treturn decoder.decodeGltfBufferAsync( count, stride, source, extensionDef.mode, extensionDef.filter ).then( function ( res ) {\r\n\r\n\t\t\t\t\t\treturn res.buffer;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Support for MeshoptDecoder 0.18 or earlier, without decodeGltfBufferAsync\r\n\t\t\t\t\treturn decoder.ready.then( function () {\r\n\r\n\t\t\t\t\t\tconst result = new ArrayBuffer( count * stride );\r\n\t\t\t\t\t\tdecoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );\r\n\t\t\t\t\t\treturn result;\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * GPU Instancing Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\r\n *\r\n * @private\r\n */\r\nclass GLTFMeshGpuInstancing {\r\n\r\n\tconstructor( parser ) {\r\n\r\n\t\tthis.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;\r\n\t\tthis.parser = parser;\r\n\r\n\t}\r\n\r\n\tcreateNodeMesh( nodeIndex ) {\r\n\r\n\t\tconst json = this.parser.json;\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\tif ( ! nodeDef.extensions || ! nodeDef.extensions[ this.name ] ||\r\n\t\t\tnodeDef.mesh === undefined ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tconst meshDef = json.meshes[ nodeDef.mesh ];\r\n\r\n\t\t// No Points or Lines + Instancing support yet\r\n\r\n\t\tfor ( const primitive of meshDef.primitives ) {\r\n\r\n\t\t\tif ( primitive.mode !== WEBGL_CONSTANTS.TRIANGLES &&\r\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&\r\n\t\t\t\t primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&\r\n\t\t\t\t primitive.mode !== undefined ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tconst extensionDef = nodeDef.extensions[ this.name ];\r\n\t\tconst attributesDef = extensionDef.attributes;\r\n\r\n\t\t// @TODO: Can we support InstancedMesh + SkinnedMesh?\r\n\r\n\t\tconst pending = [];\r\n\t\tconst attributes = {};\r\n\r\n\t\tfor ( const key in attributesDef ) {\r\n\r\n\t\t\tpending.push( this.parser.getDependency( 'accessor', attributesDef[ key ] ).then( accessor => {\r\n\r\n\t\t\t\tattributes[ key ] = accessor;\r\n\t\t\t\treturn attributes[ key ];\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( pending.length < 1 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tpending.push( this.parser.createNodeMesh( nodeIndex ) );\r\n\r\n\t\treturn Promise.all( pending ).then( results => {\r\n\r\n\t\t\tconst nodeObject = results.pop();\r\n\t\t\tconst meshes = nodeObject.isGroup ? nodeObject.children : [ nodeObject ];\r\n\t\t\tconst count = results[ 0 ].count; // All attribute counts should be same\r\n\t\t\tconst instancedMeshes = [];\r\n\r\n\t\t\tfor ( const mesh of meshes ) {\r\n\r\n\t\t\t\t// Temporal variables\r\n\t\t\t\tconst m = new Matrix4();\r\n\t\t\t\tconst p = new Vector3();\r\n\t\t\t\tconst q = new Quaternion();\r\n\t\t\t\tconst s = new Vector3( 1, 1, 1 );\r\n\r\n\t\t\t\tconst instancedMesh = new InstancedMesh( mesh.geometry, mesh.material, count );\r\n\r\n\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\t\t\tif ( attributes.TRANSLATION ) {\r\n\r\n\t\t\t\t\t\tp.fromBufferAttribute( attributes.TRANSLATION, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.ROTATION ) {\r\n\r\n\t\t\t\t\t\tq.fromBufferAttribute( attributes.ROTATION, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( attributes.SCALE ) {\r\n\r\n\t\t\t\t\t\ts.fromBufferAttribute( attributes.SCALE, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tinstancedMesh.setMatrixAt( i, m.compose( p, q, s ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Add instance attributes to the geometry, excluding TRS.\r\n\t\t\t\tfor ( const attributeName in attributes ) {\r\n\r\n\t\t\t\t\tif ( attributeName === '_COLOR_0' ) {\r\n\r\n\t\t\t\t\t\tconst attr = attributes[ attributeName ];\r\n\t\t\t\t\t\tinstancedMesh.instanceColor = new InstancedBufferAttribute( attr.array, attr.itemSize, attr.normalized );\r\n\r\n\t\t\t\t\t} else if ( attributeName !== 'TRANSLATION' &&\r\n\t\t\t\t\t\t attributeName !== 'ROTATION' &&\r\n\t\t\t\t\t\t attributeName !== 'SCALE' ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry.setAttribute( attributeName, attributes[ attributeName ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Just in case\r\n\t\t\t\tObject3D.prototype.copy.call( instancedMesh, mesh );\r\n\r\n\t\t\t\tthis.parser.assignFinalMaterial( instancedMesh );\r\n\r\n\t\t\t\tinstancedMeshes.push( instancedMesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeObject.isGroup ) {\r\n\r\n\t\t\t\tnodeObject.clear();\r\n\r\n\t\t\t\tnodeObject.add( ... instancedMeshes );\r\n\r\n\t\t\t\treturn nodeObject;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn instancedMeshes[ 0 ];\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/* BINARY EXTENSION */\r\nconst BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\r\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\r\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\r\n\r\nclass GLTFBinaryExtension {\r\n\r\n\tconstructor( data ) {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n\t\tthis.content = null;\r\n\t\tthis.body = null;\r\n\r\n\t\tconst headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tconst textDecoder = new TextDecoder();\r\n\r\n\t\tthis.header = {\r\n\t\t\tmagic: textDecoder.decode( new Uint8Array( data.slice( 0, 4 ) ) ),\r\n\t\t\tversion: headerView.getUint32( 4, true ),\r\n\t\t\tlength: headerView.getUint32( 8, true )\r\n\t\t};\r\n\r\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\r\n\r\n\t\t} else if ( this.header.version < 2.0 ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n\t\tconst chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\r\n\t\tlet chunkIndex = 0;\r\n\r\n\t\twhile ( chunkIndex < chunkContentsLength ) {\r\n\r\n\t\t\tconst chunkLength = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tconst chunkType = chunkView.getUint32( chunkIndex, true );\r\n\t\t\tchunkIndex += 4;\r\n\r\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\r\n\r\n\t\t\t\tconst contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\r\n\t\t\t\tthis.content = textDecoder.decode( contentArray );\r\n\r\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\r\n\r\n\t\t\t\tconst byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Clients must ignore chunks with unknown types.\r\n\r\n\t\t\tchunkIndex += chunkLength;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.content === null ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * DRACO Mesh Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n *\r\n * @private\r\n */\r\nclass GLTFDracoMeshCompressionExtension {\r\n\r\n\tconstructor( json, dracoLoader ) {\r\n\r\n\t\tif ( ! dracoLoader ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n\t\tthis.json = json;\r\n\t\tthis.dracoLoader = dracoLoader;\r\n\t\tthis.dracoLoader.preload();\r\n\r\n\t}\r\n\r\n\tdecodePrimitive( primitive, parser ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst dracoLoader = this.dracoLoader;\r\n\t\tconst bufferViewIndex = primitive.extensions[ this.name ].bufferView;\r\n\t\tconst gltfAttributeMap = primitive.extensions[ this.name ].attributes;\r\n\t\tconst threeAttributeMap = {};\r\n\t\tconst attributeNormalizedMap = {};\r\n\t\tconst attributeTypeMap = {};\r\n\r\n\t\tfor ( const attributeName in gltfAttributeMap ) {\r\n\r\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tthreeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const attributeName in primitive.attributes ) {\r\n\r\n\t\t\tconst threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();\r\n\r\n\t\t\tif ( gltfAttributeMap[ attributeName ] !== undefined ) {\r\n\r\n\t\t\t\tconst accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\r\n\t\t\t\tconst componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t\tattributeTypeMap[ threeAttributeName ] = componentType.name;\r\n\t\t\t\tattributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\r\n\r\n\t\t\t\t\tfor ( const attributeName in geometry.attributes ) {\r\n\r\n\t\t\t\t\t\tconst attribute = geometry.attributes[ attributeName ];\r\n\t\t\t\t\t\tconst normalized = attributeNormalizedMap[ attributeName ];\r\n\r\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresolve( geometry );\r\n\r\n\t\t\t\t}, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Texture Transform Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n *\r\n * @private\r\n */\r\nclass GLTFTextureTransformExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n\r\n\t}\r\n\r\n\textendTexture( texture, transform ) {\r\n\r\n\t\tif ( ( transform.texCoord === undefined || transform.texCoord === texture.channel )\r\n\t\t\t&& transform.offset === undefined\r\n\t\t\t&& transform.rotation === undefined\r\n\t\t\t&& transform.scale === undefined ) {\r\n\r\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21819.\r\n\t\t\treturn texture;\r\n\r\n\t\t}\r\n\r\n\t\ttexture = texture.clone();\r\n\r\n\t\tif ( transform.texCoord !== undefined ) {\r\n\r\n\t\t\ttexture.channel = transform.texCoord;\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.offset !== undefined ) {\r\n\r\n\t\t\ttexture.offset.fromArray( transform.offset );\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.rotation !== undefined ) {\r\n\r\n\t\t\ttexture.rotation = transform.rotation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( transform.scale !== undefined ) {\r\n\r\n\t\t\ttexture.repeat.fromArray( transform.scale );\r\n\r\n\t\t}\r\n\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Mesh Quantization Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n *\r\n * @private\r\n */\r\nclass GLTFMeshQuantizationExtension {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/*********************************/\r\n/********** INTERPOLATION ********/\r\n/*********************************/\r\n\r\n// Spline Interpolation\r\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\nclass GLTFCubicSplineInterpolant extends Interpolant {\r\n\r\n\tconstructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\t\tsuper( parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\t}\r\n\r\n\tcopySampleValue_( index ) {\r\n\r\n\t\t// Copies a sample value to the result buffer. See description of glTF\r\n\t\t// CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n\t\tconst result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tvalueSize = this.valueSize,\r\n\t\t\toffset = index * valueSize * 3 + valueSize;\r\n\r\n\t\tfor ( let i = 0; i !== valueSize; i ++ ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tinterpolate_( i1, t0, t, t1 ) {\r\n\r\n\t\tconst result = this.resultBuffer;\r\n\t\tconst values = this.sampleValues;\r\n\t\tconst stride = this.valueSize;\r\n\r\n\t\tconst stride2 = stride * 2;\r\n\t\tconst stride3 = stride * 3;\r\n\r\n\t\tconst td = t1 - t0;\r\n\r\n\t\tconst p = ( t - t0 ) / td;\r\n\t\tconst pp = p * p;\r\n\t\tconst ppp = pp * p;\r\n\r\n\t\tconst offset1 = i1 * stride3;\r\n\t\tconst offset0 = offset1 - stride3;\r\n\r\n\t\tconst s2 = - 2 * ppp + 3 * pp;\r\n\t\tconst s3 = ppp - pp;\r\n\t\tconst s0 = 1 - s2;\r\n\t\tconst s1 = s3 - pp + p;\r\n\r\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\r\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n\t\tfor ( let i = 0; i !== stride; i ++ ) {\r\n\r\n\t\t\tconst p0 = values[ offset0 + i + stride ]; // splineVertex_k\r\n\t\t\tconst m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\r\n\t\t\tconst p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\r\n\t\t\tconst m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst _quaternion = new Quaternion();\r\n\r\nclass GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {\r\n\r\n\tinterpolate_( i1, t0, t, t1 ) {\r\n\r\n\t\tconst result = super.interpolate_( i1, t0, t, t1 );\r\n\r\n\t\t_quaternion.fromArray( result ).normalize().toArray( result );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\n/*********************************/\r\n/********** INTERNALS ************/\r\n/*********************************/\r\n\r\n/* CONSTANTS */\r\n\r\nconst WEBGL_CONSTANTS = {\r\n\tFLOAT: 5126,\r\n\t//FLOAT_MAT2: 35674,\r\n\tFLOAT_MAT3: 35675,\r\n\tFLOAT_MAT4: 35676,\r\n\tFLOAT_VEC2: 35664,\r\n\tFLOAT_VEC3: 35665,\r\n\tFLOAT_VEC4: 35666,\r\n\tLINEAR: 9729,\r\n\tREPEAT: 10497,\r\n\tSAMPLER_2D: 35678,\r\n\tPOINTS: 0,\r\n\tLINES: 1,\r\n\tLINE_LOOP: 2,\r\n\tLINE_STRIP: 3,\r\n\tTRIANGLES: 4,\r\n\tTRIANGLE_STRIP: 5,\r\n\tTRIANGLE_FAN: 6,\r\n\tUNSIGNED_BYTE: 5121,\r\n\tUNSIGNED_SHORT: 5123\r\n};\r\n\r\nconst WEBGL_COMPONENT_TYPES = {\r\n\t5120: Int8Array,\r\n\t5121: Uint8Array,\r\n\t5122: Int16Array,\r\n\t5123: Uint16Array,\r\n\t5125: Uint32Array,\r\n\t5126: Float32Array\r\n};\r\n\r\nconst WEBGL_FILTERS = {\r\n\t9728: NearestFilter,\r\n\t9729: LinearFilter,\r\n\t9984: NearestMipmapNearestFilter,\r\n\t9985: LinearMipmapNearestFilter,\r\n\t9986: NearestMipmapLinearFilter,\r\n\t9987: LinearMipmapLinearFilter\r\n};\r\n\r\nconst WEBGL_WRAPPINGS = {\r\n\t33071: ClampToEdgeWrapping,\r\n\t33648: MirroredRepeatWrapping,\r\n\t10497: RepeatWrapping\r\n};\r\n\r\nconst WEBGL_TYPE_SIZES = {\r\n\t'SCALAR': 1,\r\n\t'VEC2': 2,\r\n\t'VEC3': 3,\r\n\t'VEC4': 4,\r\n\t'MAT2': 4,\r\n\t'MAT3': 9,\r\n\t'MAT4': 16\r\n};\r\n\r\nconst ATTRIBUTES = {\r\n\tPOSITION: 'position',\r\n\tNORMAL: 'normal',\r\n\tTANGENT: 'tangent',\r\n\tTEXCOORD_0: 'uv',\r\n\tTEXCOORD_1: 'uv1',\r\n\tTEXCOORD_2: 'uv2',\r\n\tTEXCOORD_3: 'uv3',\r\n\tCOLOR_0: 'color',\r\n\tWEIGHTS_0: 'skinWeight',\r\n\tJOINTS_0: 'skinIndex',\r\n};\r\n\r\nconst PATH_PROPERTIES = {\r\n\tscale: 'scale',\r\n\ttranslation: 'position',\r\n\trotation: 'quaternion',\r\n\tweights: 'morphTargetInfluences'\r\n};\r\n\r\nconst INTERPOLATION = {\r\n\tCUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n\t\t                        // keyframe track will be initialized with a default interpolation type, then modified.\r\n\tLINEAR: InterpolateLinear,\r\n\tSTEP: InterpolateDiscrete\r\n};\r\n\r\nconst ALPHA_MODES = {\r\n\tOPAQUE: 'OPAQUE',\r\n\tMASK: 'MASK',\r\n\tBLEND: 'BLEND'\r\n};\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n *\r\n * @private\r\n * @param {Object<string, Material>} cache\r\n * @return {Material}\r\n */\r\nfunction createDefaultMaterial( cache ) {\r\n\r\n\tif ( cache[ 'DefaultMaterial' ] === undefined ) {\r\n\r\n\t\tcache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {\r\n\t\t\tcolor: 0xFFFFFF,\r\n\t\t\temissive: 0x000000,\r\n\t\t\tmetalness: 1,\r\n\t\t\troughness: 1,\r\n\t\t\ttransparent: false,\r\n\t\t\tdepthTest: true,\r\n\t\t\tside: FrontSide\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn cache[ 'DefaultMaterial' ];\r\n\r\n}\r\n\r\nfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\r\n\r\n\t// Add unknown glTF extensions to an object's userData.\r\n\r\n\tfor ( const name in objectDef.extensions ) {\r\n\r\n\t\tif ( knownExtensions[ name ] === undefined ) {\r\n\r\n\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {Object3D|Material|BufferGeometry|Object} object\r\n * @param {GLTF.definition} gltfDef\r\n */\r\nfunction assignExtrasToUserData( object, gltfDef ) {\r\n\r\n\tif ( gltfDef.extras !== undefined ) {\r\n\r\n\t\tif ( typeof gltfDef.extras === 'object' ) {\r\n\r\n\t\t\tObject.assign( object.userData, gltfDef.extras );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n *\r\n * @private\r\n * @param {BufferGeometry} geometry\r\n * @param {Array<GLTF.Target>} targets\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addMorphTargets( geometry, targets, parser ) {\r\n\r\n\tlet hasMorphPosition = false;\r\n\tlet hasMorphNormal = false;\r\n\tlet hasMorphColor = false;\r\n\r\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\tconst target = targets[ i ];\r\n\r\n\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\r\n\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\r\n\t\tif ( target.COLOR_0 !== undefined ) hasMorphColor = true;\r\n\r\n\t\tif ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;\r\n\r\n\t}\r\n\r\n\tif ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );\r\n\r\n\tconst pendingPositionAccessors = [];\r\n\tconst pendingNormalAccessors = [];\r\n\tconst pendingColorAccessors = [];\r\n\r\n\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\tconst target = targets[ i ];\r\n\r\n\t\tif ( hasMorphPosition ) {\r\n\r\n\t\t\tconst pendingAccessor = target.POSITION !== undefined\r\n\t\t\t\t? parser.getDependency( 'accessor', target.POSITION )\r\n\t\t\t\t: geometry.attributes.position;\r\n\r\n\t\t\tpendingPositionAccessors.push( pendingAccessor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasMorphNormal ) {\r\n\r\n\t\t\tconst pendingAccessor = target.NORMAL !== undefined\r\n\t\t\t\t? parser.getDependency( 'accessor', target.NORMAL )\r\n\t\t\t\t: geometry.attributes.normal;\r\n\r\n\t\t\tpendingNormalAccessors.push( pendingAccessor );\r\n\r\n\t\t}\r\n\r\n\t\tif ( hasMorphColor ) {\r\n\r\n\t\t\tconst pendingAccessor = target.COLOR_0 !== undefined\r\n\t\t\t\t? parser.getDependency( 'accessor', target.COLOR_0 )\r\n\t\t\t\t: geometry.attributes.color;\r\n\r\n\t\t\tpendingColorAccessors.push( pendingAccessor );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Promise.all( [\r\n\t\tPromise.all( pendingPositionAccessors ),\r\n\t\tPromise.all( pendingNormalAccessors ),\r\n\t\tPromise.all( pendingColorAccessors )\r\n\t] ).then( function ( accessors ) {\r\n\r\n\t\tconst morphPositions = accessors[ 0 ];\r\n\t\tconst morphNormals = accessors[ 1 ];\r\n\t\tconst morphColors = accessors[ 2 ];\r\n\r\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\r\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\r\n\t\tif ( hasMorphColor ) geometry.morphAttributes.color = morphColors;\r\n\t\tgeometry.morphTargetsRelative = true;\r\n\r\n\t\treturn geometry;\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {Mesh} mesh\r\n * @param {GLTF.Mesh} meshDef\r\n */\r\nfunction updateMorphTargets( mesh, meshDef ) {\r\n\r\n\tmesh.updateMorphTargets();\r\n\r\n\tif ( meshDef.weights !== undefined ) {\r\n\r\n\t\tfor ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// .extras has user-defined data, so check that .extras.targetNames is an array.\r\n\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\r\n\r\n\t\tconst targetNames = meshDef.extras.targetNames;\r\n\r\n\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\r\n\r\n\t\t\tmesh.morphTargetDictionary = {};\r\n\r\n\t\t\tfor ( let i = 0, il = targetNames.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction createPrimitiveKey( primitiveDef ) {\r\n\r\n\tlet geometryKey;\r\n\r\n\tconst dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];\r\n\r\n\tif ( dracoExtension ) {\r\n\r\n\t\tgeometryKey = 'draco:' + dracoExtension.bufferView\r\n\t\t\t\t+ ':' + dracoExtension.indices\r\n\t\t\t\t+ ':' + createAttributesKey( dracoExtension.attributes );\r\n\r\n\t} else {\r\n\r\n\t\tgeometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;\r\n\r\n\t}\r\n\r\n\tif ( primitiveDef.targets !== undefined ) {\r\n\r\n\t\tfor ( let i = 0, il = primitiveDef.targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tgeometryKey += ':' + createAttributesKey( primitiveDef.targets[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometryKey;\r\n\r\n}\r\n\r\nfunction createAttributesKey( attributes ) {\r\n\r\n\tlet attributesKey = '';\r\n\r\n\tconst keys = Object.keys( attributes ).sort();\r\n\r\n\tfor ( let i = 0, il = keys.length; i < il; i ++ ) {\r\n\r\n\t\tattributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';\r\n\r\n\t}\r\n\r\n\treturn attributesKey;\r\n\r\n}\r\n\r\nfunction getNormalizedComponentScale( constructor ) {\r\n\r\n\t// Reference:\r\n\t// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\r\n\r\n\tswitch ( constructor ) {\r\n\r\n\t\tcase Int8Array:\r\n\t\t\treturn 1 / 127;\r\n\r\n\t\tcase Uint8Array:\r\n\t\t\treturn 1 / 255;\r\n\r\n\t\tcase Int16Array:\r\n\t\t\treturn 1 / 32767;\r\n\r\n\t\tcase Uint16Array:\r\n\t\t\treturn 1 / 65535;\r\n\r\n\t\tdefault:\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getImageURIMimeType( uri ) {\r\n\r\n\tif ( uri.search( /\\.jpe?g($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/jpeg/ ) === 0 ) return 'image/jpeg';\r\n\tif ( uri.search( /\\.webp($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/webp/ ) === 0 ) return 'image/webp';\r\n\tif ( uri.search( /\\.ktx2($|\\?)/i ) > 0 || uri.search( /^data\\:image\\/ktx2/ ) === 0 ) return 'image/ktx2';\r\n\r\n\treturn 'image/png';\r\n\r\n}\r\n\r\nconst _identityMatrix = new Matrix4();\r\n\r\n/* GLTF PARSER */\r\n\r\nclass GLTFParser {\r\n\r\n\tconstructor( json = {}, options = {} ) {\r\n\r\n\t\tthis.json = json;\r\n\t\tthis.extensions = {};\r\n\t\tthis.plugins = {};\r\n\t\tthis.options = options;\r\n\r\n\t\t// loader object cache\r\n\t\tthis.cache = new GLTFRegistry();\r\n\r\n\t\t// associations between Three.js objects and glTF elements\r\n\t\tthis.associations = new Map();\r\n\r\n\t\t// BufferGeometry caching\r\n\t\tthis.primitiveCache = {};\r\n\r\n\t\t// Node cache\r\n\t\tthis.nodeCache = {};\r\n\r\n\t\t// Object3D instance caches\r\n\t\tthis.meshCache = { refs: {}, uses: {} };\r\n\t\tthis.cameraCache = { refs: {}, uses: {} };\r\n\t\tthis.lightCache = { refs: {}, uses: {} };\r\n\r\n\t\tthis.sourceCache = {};\r\n\t\tthis.textureCache = {};\r\n\r\n\t\t// Track node names, to ensure no duplicates\r\n\t\tthis.nodeNamesUsed = {};\r\n\r\n\t\t// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n\t\t// expensive work of uploading a texture to the GPU off the main thread.\r\n\r\n\t\tlet isSafari = false;\r\n\t\tlet safariVersion = - 1;\r\n\t\tlet isFirefox = false;\r\n\t\tlet firefoxVersion = - 1;\r\n\r\n\t\tif ( typeof navigator !== 'undefined' ) {\r\n\r\n\t\t\tconst userAgent = navigator.userAgent;\r\n\r\n\t\t\tisSafari = /^((?!chrome|android).)*safari/i.test( userAgent ) === true;\r\n\t\t\tconst safariMatch = userAgent.match( /Version\\/(\\d+)/ );\r\n\t\t\tsafariVersion = isSafari && safariMatch ? parseInt( safariMatch[ 1 ], 10 ) : - 1;\r\n\r\n\t\t\tisFirefox = userAgent.indexOf( 'Firefox' ) > - 1;\r\n\t\t\tfirefoxVersion = isFirefox ? userAgent.match( /Firefox\\/([0-9]+)\\./ )[ 1 ] : - 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( typeof createImageBitmap === 'undefined' || ( isSafari && safariVersion < 17 ) || ( isFirefox && firefoxVersion < 98 ) ) {\r\n\r\n\t\t\tthis.textureLoader = new TextureLoader( this.options.manager );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.textureLoader = new ImageBitmapLoader( this.options.manager );\r\n\r\n\t\t}\r\n\r\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\r\n\t\tthis.textureLoader.setRequestHeader( this.options.requestHeader );\r\n\r\n\t\tthis.fileLoader = new FileLoader( this.options.manager );\r\n\t\tthis.fileLoader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tif ( this.options.crossOrigin === 'use-credentials' ) {\r\n\r\n\t\t\tthis.fileLoader.setWithCredentials( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetExtensions( extensions ) {\r\n\r\n\t\tthis.extensions = extensions;\r\n\r\n\t}\r\n\r\n\tsetPlugins( plugins ) {\r\n\r\n\t\tthis.plugins = plugins;\r\n\r\n\t}\r\n\r\n\tparse( onLoad, onError ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\r\n\t\t// Clear the loader cache\r\n\t\tthis.cache.removeAll();\r\n\t\tthis.nodeCache = {};\r\n\r\n\t\t// Mark the special nodes/meshes in json for efficient parse\r\n\t\tthis._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext._markDefs && ext._markDefs();\r\n\r\n\t\t} );\r\n\r\n\t\tPromise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext.beforeRoot && ext.beforeRoot();\r\n\r\n\t\t} ) ).then( function () {\r\n\r\n\t\t\treturn Promise.all( [\r\n\r\n\t\t\t\tparser.getDependencies( 'scene' ),\r\n\t\t\t\tparser.getDependencies( 'animation' ),\r\n\t\t\t\tparser.getDependencies( 'camera' ),\r\n\r\n\t\t\t] );\r\n\r\n\t\t} ).then( function ( dependencies ) {\r\n\r\n\t\t\tconst result = {\r\n\t\t\t\tscene: dependencies[ 0 ][ json.scene || 0 ],\r\n\t\t\t\tscenes: dependencies[ 0 ],\r\n\t\t\t\tanimations: dependencies[ 1 ],\r\n\t\t\t\tcameras: dependencies[ 2 ],\r\n\t\t\t\tasset: json.asset,\r\n\t\t\t\tparser: parser,\r\n\t\t\t\tuserData: {}\r\n\t\t\t};\r\n\r\n\t\t\taddUnknownExtensionsToUserData( extensions, result, json );\r\n\r\n\t\t\tassignExtrasToUserData( result, json );\r\n\r\n\t\t\treturn Promise.all( parser._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.afterRoot && ext.afterRoot( result );\r\n\r\n\t\t\t} ) ).then( function () {\r\n\r\n\t\t\t\tfor ( const scene of result.scenes ) {\r\n\r\n\t\t\t\t\tscene.updateMatrixWorld();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tonLoad( result );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).catch( onError );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Marks the special nodes/meshes in json for efficient parse.\r\n\t *\r\n\t * @private\r\n\t */\r\n\t_markDefs() {\r\n\r\n\t\tconst nodeDefs = this.json.nodes || [];\r\n\t\tconst skinDefs = this.json.skins || [];\r\n\t\tconst meshDefs = this.json.meshes || [];\r\n\r\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\r\n\t\t// Object3D. Use the skins' joint references to mark bones.\r\n\t\tfor ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\r\n\r\n\t\t\tconst joints = skinDefs[ skinIndex ].joints;\r\n\r\n\t\t\tfor ( let i = 0, il = joints.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Iterate over all nodes, marking references to shared resources,\r\n\t\t// as well as skeleton joints.\r\n\t\tfor ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\r\n\r\n\t\t\tconst nodeDef = nodeDefs[ nodeIndex ];\r\n\r\n\t\t\tif ( nodeDef.mesh !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.meshCache, nodeDef.mesh );\r\n\r\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\r\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\r\n\t\t\t\t// to mark SkinnedMesh if node has skin.\r\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\r\n\r\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\t\tthis._addNodeRef( this.cameraCache, nodeDef.camera );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Counts references to shared node / Object3D resources. These resources\r\n\t * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n\t * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n\t * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n\t * Textures) can be reused directly and are not marked here.\r\n\t *\r\n\t * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} cache\r\n\t * @param {Object3D} index\r\n\t */\r\n\t_addNodeRef( cache, index ) {\r\n\r\n\t\tif ( index === undefined ) return;\r\n\r\n\t\tif ( cache.refs[ index ] === undefined ) {\r\n\r\n\t\t\tcache.refs[ index ] = cache.uses[ index ] = 0;\r\n\r\n\t\t}\r\n\r\n\t\tcache.refs[ index ] ++;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a reference to a shared resource, cloning it if necessary.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} cache\r\n\t * @param {number} index\r\n\t * @param {Object} object\r\n\t * @return {Object}\r\n\t */\r\n\t_getNodeRef( cache, index, object ) {\r\n\r\n\t\tif ( cache.refs[ index ] <= 1 ) return object;\r\n\r\n\t\tconst ref = object.clone();\r\n\r\n\t\t// Propagates mappings to the cloned object, prevents mappings on the\r\n\t\t// original object from being lost.\r\n\t\tconst updateMappings = ( original, clone ) => {\r\n\r\n\t\t\tconst mappings = this.associations.get( original );\r\n\t\t\tif ( mappings != null ) {\r\n\r\n\t\t\t\tthis.associations.set( clone, mappings );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( const [ i, child ] of original.children.entries() ) {\r\n\r\n\t\t\t\tupdateMappings( child, clone.children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tupdateMappings( object, ref );\r\n\r\n\t\tref.name += '_instance_' + ( cache.uses[ index ] ++ );\r\n\r\n\t\treturn ref;\r\n\r\n\t}\r\n\r\n\t_invokeOne( func ) {\r\n\r\n\t\tconst extensions = Object.values( this.plugins );\r\n\t\textensions.push( this );\r\n\r\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tconst result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) return result;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n\t_invokeAll( func ) {\r\n\r\n\t\tconst extensions = Object.values( this.plugins );\r\n\t\textensions.unshift( this );\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0; i < extensions.length; i ++ ) {\r\n\r\n\t\t\tconst result = func( extensions[ i ] );\r\n\r\n\t\t\tif ( result ) pending.push( result );\r\n\r\n\t\t}\r\n\r\n\t\treturn pending;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Requests the specified dependency asynchronously, with caching.\r\n\t *\r\n\t * @private\r\n\t * @param {string} type\r\n\t * @param {number} index\r\n\t * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n\t */\r\n\tgetDependency( type, index ) {\r\n\r\n\t\tconst cacheKey = type + ':' + index;\r\n\t\tlet dependency = this.cache.get( cacheKey );\r\n\r\n\t\tif ( ! dependency ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 'scene':\r\n\t\t\t\t\tdependency = this.loadScene( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'node':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadNode && ext.loadNode( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'mesh':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMesh && ext.loadMesh( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'accessor':\r\n\t\t\t\t\tdependency = this.loadAccessor( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bufferView':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadBufferView && ext.loadBufferView( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'buffer':\r\n\t\t\t\t\tdependency = this.loadBuffer( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'material':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadMaterial && ext.loadMaterial( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'texture':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadTexture && ext.loadTexture( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'skin':\r\n\t\t\t\t\tdependency = this.loadSkin( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'animation':\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext.loadAnimation && ext.loadAnimation( index );\r\n\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'camera':\r\n\t\t\t\t\tdependency = this.loadCamera( index );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tdependency = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\t\t\treturn ext != this && ext.getDependency && ext.getDependency( type, index );\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t\tif ( ! dependency ) {\r\n\r\n\t\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cache.add( cacheKey, dependency );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependency;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Requests all dependencies of the specified type asynchronously, with caching.\r\n\t *\r\n\t * @private\r\n\t * @param {string} type\r\n\t * @return {Promise<Array<Object>>}\r\n\t */\r\n\tgetDependencies( type ) {\r\n\r\n\t\tlet dependencies = this.cache.get( type );\r\n\r\n\t\tif ( ! dependencies ) {\r\n\r\n\t\t\tconst parser = this;\r\n\t\t\tconst defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\r\n\r\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\r\n\r\n\t\t\t\treturn parser.getDependency( type, index );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t\tthis.cache.add( type, dependencies );\r\n\r\n\t\t}\r\n\r\n\t\treturn dependencies;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t *\r\n\t * @private\r\n\t * @param {number} bufferIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tloadBuffer( bufferIndex ) {\r\n\r\n\t\tconst bufferDef = this.json.buffers[ bufferIndex ];\r\n\t\tconst loader = this.fileLoader;\r\n\r\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\t// If present, GLB container is required to be the first buffer.\r\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\r\n\r\n\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\r\n\r\n\t\t}\r\n\r\n\t\tconst options = this.options;\r\n\r\n\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\tloader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\r\n\r\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n\t *\r\n\t * @private\r\n\t * @param {number} bufferViewIndex\r\n\t * @return {Promise<ArrayBuffer>}\r\n\t */\r\n\tloadBufferView( bufferViewIndex ) {\r\n\r\n\t\tconst bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\r\n\r\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\r\n\r\n\t\t\tconst byteLength = bufferViewDef.byteLength || 0;\r\n\t\t\tconst byteOffset = bufferViewDef.byteOffset || 0;\r\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n\t *\r\n\t * @private\r\n\t * @param {number} accessorIndex\r\n\t * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n\t */\r\n\tloadAccessor( accessorIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst accessorDef = this.json.accessors[ accessorIndex ];\r\n\r\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\r\n\r\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\t\t\tconst normalized = accessorDef.normalized === true;\r\n\r\n\t\t\tconst array = new TypedArray( accessorDef.count * itemSize );\r\n\t\t\treturn Promise.resolve( new BufferAttribute( array, itemSize, normalized ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst pendingBufferViews = [];\r\n\r\n\t\tif ( accessorDef.bufferView !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpendingBufferViews.push( null );\r\n\r\n\t\t}\r\n\r\n\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\r\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\r\n\r\n\t\t\tconst bufferView = bufferViews[ 0 ];\r\n\r\n\t\t\tconst itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\r\n\t\t\tconst TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\r\n\r\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n\t\t\tconst elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n\t\t\tconst itemBytes = elementBytes * itemSize;\r\n\t\t\tconst byteOffset = accessorDef.byteOffset || 0;\r\n\t\t\tconst byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;\r\n\t\t\tconst normalized = accessorDef.normalized === true;\r\n\t\t\tlet array, bufferAttribute;\r\n\r\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\r\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\r\n\r\n\t\t\t\t// Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n\t\t\t\t// This makes sure that IBA.count reflects accessor.count properly\r\n\t\t\t\tconst ibSlice = Math.floor( byteOffset / byteStride );\r\n\t\t\t\tconst ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;\r\n\t\t\t\tlet ib = parser.cache.get( ibCacheKey );\r\n\r\n\t\t\t\tif ( ! ib ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );\r\n\r\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\r\n\t\t\t\t\tib = new InterleavedBuffer( array, byteStride / elementBytes );\r\n\r\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( bufferView === null ) {\r\n\r\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute = new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n\t\t\tif ( accessorDef.sparse !== undefined ) {\r\n\r\n\t\t\t\tconst itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n\t\t\t\tconst TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\r\n\r\n\t\t\t\tconst byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n\t\t\t\tconst byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n\t\t\t\tconst sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\r\n\t\t\t\tconst sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\r\n\r\n\t\t\t\tif ( bufferView !== null ) {\r\n\r\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n\t\t\t\t\tbufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Ignore normalized since we copy from sparse\r\n\t\t\t\tbufferAttribute.normalized = false;\r\n\r\n\t\t\t\tfor ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = sparseIndices[ i ];\r\n\r\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\r\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\r\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\r\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\r\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbufferAttribute.normalized = normalized;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn bufferAttribute;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n\t *\r\n\t * @private\r\n\t * @param {number} textureIndex\r\n\t * @return {Promise<THREE.Texture|null>}\r\n\t */\r\n\tloadTexture( textureIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\t\tconst sourceIndex = textureDef.source;\r\n\t\tconst sourceDef = json.images[ sourceIndex ];\r\n\r\n\t\tlet loader = this.textureLoader;\r\n\r\n\t\tif ( sourceDef.uri ) {\r\n\r\n\t\t\tconst handler = options.manager.getHandler( sourceDef.uri );\r\n\t\t\tif ( handler !== null ) loader = handler;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.loadTextureImage( textureIndex, sourceIndex, loader );\r\n\r\n\t}\r\n\r\n\tloadTextureImage( textureIndex, sourceIndex, loader ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\r\n\t\tconst textureDef = json.textures[ textureIndex ];\r\n\t\tconst sourceDef = json.images[ sourceIndex ];\r\n\r\n\t\tconst cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;\r\n\r\n\t\tif ( this.textureCache[ cacheKey ] ) {\r\n\r\n\t\t\t// See https://github.com/mrdoob/three.js/issues/21559.\r\n\t\t\treturn this.textureCache[ cacheKey ];\r\n\r\n\t\t}\r\n\r\n\t\tconst promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {\r\n\r\n\t\t\ttexture.flipY = false;\r\n\r\n\t\t\ttexture.name = textureDef.name || sourceDef.name || '';\r\n\r\n\t\t\tif ( texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith( 'data:image/' ) === false ) {\r\n\r\n\t\t\t\ttexture.name = sourceDef.uri;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst samplers = json.samplers || {};\r\n\t\t\tconst sampler = samplers[ textureDef.sampler ] || {};\r\n\r\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;\r\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;\r\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;\r\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;\r\n\t\t\ttexture.generateMipmaps = ! texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\r\n\r\n\t\t\tparser.associations.set( texture, { textures: textureIndex } );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} ).catch( function () {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t} );\r\n\r\n\t\tthis.textureCache[ cacheKey ] = promise;\r\n\r\n\t\treturn promise;\r\n\r\n\t}\r\n\r\n\tloadImageSource( sourceIndex, loader ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst options = this.options;\r\n\r\n\t\tif ( this.sourceCache[ sourceIndex ] !== undefined ) {\r\n\r\n\t\t\treturn this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tconst sourceDef = json.images[ sourceIndex ];\r\n\r\n\t\tconst URL = self.URL || self.webkitURL;\r\n\r\n\t\tlet sourceURI = sourceDef.uri || '';\r\n\t\tlet isObjectURL = false;\r\n\r\n\t\tif ( sourceDef.bufferView !== undefined ) {\r\n\r\n\t\t\t// Load binary image data from bufferView, if provided.\r\n\r\n\t\t\tsourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {\r\n\r\n\t\t\t\tisObjectURL = true;\r\n\t\t\t\tconst blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );\r\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\r\n\t\t\t\treturn sourceURI;\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else if ( sourceDef.uri === undefined ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );\r\n\r\n\t\t}\r\n\r\n\t\tconst promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {\r\n\r\n\t\t\treturn new Promise( function ( resolve, reject ) {\r\n\r\n\t\t\t\tlet onLoad = resolve;\r\n\r\n\t\t\t\tif ( loader.isImageBitmapLoader === true ) {\r\n\r\n\t\t\t\t\tonLoad = function ( imageBitmap ) {\r\n\r\n\t\t\t\t\t\tconst texture = new Texture( imageBitmap );\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tresolve( texture );\r\n\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tloader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} ).then( function ( texture ) {\r\n\r\n\t\t\t// Clean up resources and configure Texture.\r\n\r\n\t\t\tif ( isObjectURL === true ) {\r\n\r\n\t\t\t\tURL.revokeObjectURL( sourceURI );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( texture, sourceDef );\r\n\r\n\t\t\ttexture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} ).catch( function ( error ) {\r\n\r\n\t\t\tconsole.error( 'THREE.GLTFLoader: Couldn\\'t load texture', sourceURI );\r\n\t\t\tthrow error;\r\n\r\n\t\t} );\r\n\r\n\t\tthis.sourceCache[ sourceIndex ] = promise;\r\n\t\treturn promise;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Asynchronously assigns a texture to the given material parameters.\r\n\t *\r\n\t * @private\r\n\t * @param {Object} materialParams\r\n\t * @param {string} mapName\r\n\t * @param {Object} mapDef\r\n\t * @param {string} [colorSpace]\r\n\t * @return {Promise<Texture>}\r\n\t */\r\n\tassignTexture( materialParams, mapName, mapDef, colorSpace ) {\r\n\r\n\t\tconst parser = this;\r\n\r\n\t\treturn this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {\r\n\r\n\t\t\tif ( ! texture ) return null;\r\n\r\n\t\t\tif ( mapDef.texCoord !== undefined && mapDef.texCoord > 0 ) {\r\n\r\n\t\t\t\ttexture = texture.clone();\r\n\t\t\t\ttexture.channel = mapDef.texCoord;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {\r\n\r\n\t\t\t\tconst transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;\r\n\r\n\t\t\t\tif ( transform ) {\r\n\r\n\t\t\t\t\tconst gltfReference = parser.associations.get( texture );\r\n\t\t\t\t\ttexture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );\r\n\t\t\t\t\tparser.associations.set( texture, gltfReference );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colorSpace !== undefined ) {\r\n\r\n\t\t\t\ttexture.colorSpace = colorSpace;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams[ mapName ] = texture;\r\n\r\n\t\t\treturn texture;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n\t * already has a material (generated from the glTF material options alone)\r\n\t * but reuse of the same glTF material may require multiple threejs materials\r\n\t * to accommodate different primitive types, defines, etc. New materials will\r\n\t * be created if necessary, and reused from a cache.\r\n\t *\r\n\t * @private\r\n\t * @param {Object3D} mesh Mesh, Line, or Points instance.\r\n\t */\r\n\tassignFinalMaterial( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tlet material = mesh.material;\r\n\r\n\t\tconst useDerivativeTangents = geometry.attributes.tangent === undefined;\r\n\t\tconst useVertexColors = geometry.attributes.color !== undefined;\r\n\t\tconst useFlatShading = geometry.attributes.normal === undefined;\r\n\r\n\t\tif ( mesh.isPoints ) {\r\n\r\n\t\t\tconst cacheKey = 'PointsMaterial:' + material.uuid;\r\n\r\n\t\t\tlet pointsMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! pointsMaterial ) {\r\n\r\n\t\t\t\tpointsMaterial = new PointsMaterial();\r\n\t\t\t\tMaterial.prototype.copy.call( pointsMaterial, material );\r\n\t\t\t\tpointsMaterial.color.copy( material.color );\r\n\t\t\t\tpointsMaterial.map = material.map;\r\n\t\t\t\tpointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, pointsMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = pointsMaterial;\r\n\r\n\t\t} else if ( mesh.isLine ) {\r\n\r\n\t\t\tconst cacheKey = 'LineBasicMaterial:' + material.uuid;\r\n\r\n\t\t\tlet lineMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! lineMaterial ) {\r\n\r\n\t\t\t\tlineMaterial = new LineBasicMaterial();\r\n\t\t\t\tMaterial.prototype.copy.call( lineMaterial, material );\r\n\t\t\t\tlineMaterial.color.copy( material.color );\r\n\t\t\t\tlineMaterial.map = material.map;\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, lineMaterial );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = lineMaterial;\r\n\r\n\t\t}\r\n\r\n\t\t// Clone the material if it will be modified\r\n\t\tif ( useDerivativeTangents || useVertexColors || useFlatShading ) {\r\n\r\n\t\t\tlet cacheKey = 'ClonedMaterial:' + material.uuid + ':';\r\n\r\n\t\t\tif ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';\r\n\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\r\n\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\r\n\r\n\t\t\tlet cachedMaterial = this.cache.get( cacheKey );\r\n\r\n\t\t\tif ( ! cachedMaterial ) {\r\n\r\n\t\t\t\tcachedMaterial = material.clone();\r\n\r\n\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = true;\r\n\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\r\n\r\n\t\t\t\tif ( useDerivativeTangents ) {\r\n\r\n\t\t\t\t\t// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n\t\t\t\t\tif ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;\r\n\t\t\t\t\tif ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.cache.add( cacheKey, cachedMaterial );\r\n\r\n\t\t\t\tthis.associations.set( cachedMaterial, this.associations.get( material ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.material = material;\r\n\r\n\t}\r\n\r\n\tgetMaterialType( /* materialIndex */ ) {\r\n\r\n\t\treturn MeshStandardMaterial;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n\t *\r\n\t * @private\r\n\t * @param {number} materialIndex\r\n\t * @return {Promise<Material>}\r\n\t */\r\n\tloadMaterial( materialIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst materialDef = json.materials[ materialIndex ];\r\n\r\n\t\tlet materialType;\r\n\t\tconst materialParams = {};\r\n\t\tconst materialExtensions = materialDef.extensions || {};\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\r\n\r\n\t\t\tconst kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\r\n\t\t\tmaterialType = kmuExtension.getMaterialType();\r\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Specification:\r\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n\t\t\tconst metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n\t\t\tmaterialParams.color = new Color( 1.0, 1.0, 1.0 );\r\n\t\t\tmaterialParams.opacity = 1.0;\r\n\r\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\r\n\r\n\t\t\t\tconst array = metallicRoughness.baseColorFactor;\r\n\r\n\t\t\t\tmaterialParams.color.setRGB( array[ 0 ], array[ 1 ], array[ 2 ], LinearSRGBColorSpace );\r\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, SRGBColorSpace ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\r\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\r\n\r\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\r\n\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialType = this._invokeOne( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.getMaterialType && ext.getMaterialType( materialIndex );\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tpending.push( Promise.all( this._invokeAll( function ( ext ) {\r\n\r\n\t\t\t\treturn ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );\r\n\r\n\t\t\t} ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.doubleSided === true ) {\r\n\r\n\t\t\tmaterialParams.side = DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tconst alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\r\n\r\n\t\t\tmaterialParams.transparent = true;\r\n\r\n\t\t\t// See: https://github.com/mrdoob/three.js/issues/17706\r\n\t\t\tmaterialParams.depthWrite = false;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterialParams.transparent = false;\r\n\r\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\r\n\r\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );\r\n\r\n\t\t\tmaterialParams.normalScale = new Vector2( 1, 1 );\r\n\r\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\r\n\r\n\t\t\t\tconst scale = materialDef.normalTexture.scale;\r\n\r\n\t\t\t\tmaterialParams.normalScale.set( scale, scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );\r\n\r\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\r\n\r\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tconst emissiveFactor = materialDef.emissiveFactor;\r\n\t\t\tmaterialParams.emissive = new Color().setRGB( emissiveFactor[ 0 ], emissiveFactor[ 1 ], emissiveFactor[ 2 ], LinearSRGBColorSpace );\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {\r\n\r\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, SRGBColorSpace ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\t\tconst material = new materialType( materialParams );\r\n\r\n\t\t\tif ( materialDef.name ) material.name = materialDef.name;\r\n\r\n\t\t\tassignExtrasToUserData( material, materialDef );\r\n\r\n\t\t\tparser.associations.set( material, { materials: materialIndex } );\r\n\r\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\r\n\r\n\t\t\treturn material;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * When Object3D instances are targeted by animation, they need unique names.\r\n\t *\r\n\t * @private\r\n\t * @param {string} originalName\r\n\t * @return {string}\r\n\t */\r\n\tcreateUniqueName( originalName ) {\r\n\r\n\t\tconst sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );\r\n\r\n\t\tif ( sanitizedName in this.nodeNamesUsed ) {\r\n\r\n\t\t\treturn sanitizedName + '_' + ( ++ this.nodeNamesUsed[ sanitizedName ] );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.nodeNamesUsed[ sanitizedName ] = 0;\r\n\r\n\t\t\treturn sanitizedName;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n\t *\r\n\t * Creates BufferGeometries from primitives.\r\n\t *\r\n\t * @private\r\n\t * @param {Array<GLTF.Primitive>} primitives\r\n\t * @return {Promise<Array<BufferGeometry>>}\r\n\t */\r\n\tloadGeometries( primitives ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst cache = this.primitiveCache;\r\n\r\n\t\tfunction createDracoPrimitive( primitive ) {\r\n\r\n\t\t\treturn extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\r\n\t\t\t\t.decodePrimitive( primitive, parser )\r\n\t\t\t\t.then( function ( geometry ) {\r\n\r\n\t\t\t\t\treturn addPrimitiveAttributes( geometry, primitive, parser );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst primitive = primitives[ i ];\r\n\t\t\tconst cacheKey = createPrimitiveKey( primitive );\r\n\r\n\t\t\t// See if we've already created this geometry\r\n\t\t\tconst cached = cache[ cacheKey ];\r\n\r\n\t\t\tif ( cached ) {\r\n\r\n\t\t\t\t// Use the cached geometry if it exists\r\n\t\t\t\tpending.push( cached.promise );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tlet geometryPromise;\r\n\r\n\t\t\t\tif ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\r\n\r\n\t\t\t\t\t// Use DRACO geometry if available\r\n\t\t\t\t\tgeometryPromise = createDracoPrimitive( primitive );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Otherwise create a new geometry\r\n\t\t\t\t\tgeometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cache this geometry\r\n\t\t\t\tcache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };\r\n\r\n\t\t\t\tpending.push( geometryPromise );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n\t *\r\n\t * @private\r\n\t * @param {number} meshIndex\r\n\t * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}\r\n\t */\r\n\tloadMesh( meshIndex ) {\r\n\r\n\t\tconst parser = this;\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\r\n\t\tconst meshDef = json.meshes[ meshIndex ];\r\n\t\tconst primitives = meshDef.primitives;\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = primitives.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst material = primitives[ i ].material === undefined\r\n\t\t\t\t? createDefaultMaterial( this.cache )\r\n\t\t\t\t: this.getDependency( 'material', primitives[ i ].material );\r\n\r\n\t\t\tpending.push( material );\r\n\r\n\t\t}\r\n\r\n\t\tpending.push( parser.loadGeometries( primitives ) );\r\n\r\n\t\treturn Promise.all( pending ).then( function ( results ) {\r\n\r\n\t\t\tconst materials = results.slice( 0, results.length - 1 );\r\n\t\t\tconst geometries = results[ results.length - 1 ];\r\n\r\n\t\t\tconst meshes = [];\r\n\r\n\t\t\tfor ( let i = 0, il = geometries.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst primitive = primitives[ i ];\r\n\r\n\t\t\t\t// 1. create Mesh\r\n\r\n\t\t\t\tlet mesh;\r\n\r\n\t\t\t\tconst material = materials[ i ];\r\n\r\n\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n\t\t\t\t\t\tprimitive.mode === undefined ) {\r\n\r\n\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\r\n\t\t\t\t\t\t? new SkinnedMesh( geometry, material )\r\n\t\t\t\t\t\t: new Mesh( geometry, material );\r\n\r\n\t\t\t\t\tif ( mesh.isSkinnedMesh === true ) {\r\n\r\n\t\t\t\t\t\t// normalize skin weights to fix malformed assets (see #15319)\r\n\t\t\t\t\t\tmesh.normalizeSkinWeights();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );\r\n\r\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\r\n\r\n\t\t\t\t\t\tmesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\r\n\r\n\t\t\t\t\tmesh = new LineSegments( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\r\n\r\n\t\t\t\t\tmesh = new Line( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\r\n\r\n\t\t\t\t\tmesh = new LineLoop( geometry, material );\r\n\r\n\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\r\n\r\n\t\t\t\t\tmesh = new Points( geometry, material );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\r\n\r\n\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );\r\n\r\n\t\t\t\tassignExtrasToUserData( mesh, meshDef );\r\n\r\n\t\t\t\tif ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );\r\n\r\n\t\t\t\tparser.assignFinalMaterial( mesh );\r\n\r\n\t\t\t\tmeshes.push( mesh );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tparser.associations.set( meshes[ i ], {\r\n\t\t\t\t\tmeshes: meshIndex,\r\n\t\t\t\t\tprimitives: i\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meshes.length === 1 ) {\r\n\r\n\t\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, meshes[ 0 ], meshDef );\r\n\r\n\t\t\t\treturn meshes[ 0 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst group = new Group();\r\n\r\n\t\t\tif ( meshDef.extensions ) addUnknownExtensionsToUserData( extensions, group, meshDef );\r\n\r\n\t\t\tparser.associations.set( group, { meshes: meshIndex } );\r\n\r\n\t\t\tfor ( let i = 0, il = meshes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup.add( meshes[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn group;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n\t *\r\n\t * @private\r\n\t * @param {number} cameraIndex\r\n\t * @return {Promise<THREE.Camera>}\r\n\t */\r\n\tloadCamera( cameraIndex ) {\r\n\r\n\t\tlet camera;\r\n\t\tconst cameraDef = this.json.cameras[ cameraIndex ];\r\n\t\tconst params = cameraDef[ cameraDef.type ];\r\n\r\n\t\tif ( ! params ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.type === 'perspective' ) {\r\n\r\n\t\t\tcamera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\r\n\r\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\r\n\r\n\t\t\tcamera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );\r\n\r\n\t\tassignExtrasToUserData( camera, cameraDef );\r\n\r\n\t\treturn Promise.resolve( camera );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n\t *\r\n\t * @private\r\n\t * @param {number} skinIndex\r\n\t * @return {Promise<Skeleton>}\r\n\t */\r\n\tloadSkin( skinIndex ) {\r\n\r\n\t\tconst skinDef = this.json.skins[ skinIndex ];\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = skinDef.joints.length; i < il; i ++ ) {\r\n\r\n\t\t\tpending.push( this._loadNodeShallow( skinDef.joints[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( skinDef.inverseBindMatrices !== undefined ) {\r\n\r\n\t\t\tpending.push( this.getDependency( 'accessor', skinDef.inverseBindMatrices ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tpending.push( null );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function ( results ) {\r\n\r\n\t\t\tconst inverseBindMatrices = results.pop();\r\n\t\t\tconst jointNodes = results;\r\n\r\n\t\t\t// Note that bones (joint nodes) may or may not be in the\r\n\t\t\t// scene graph at this time.\r\n\r\n\t\t\tconst bones = [];\r\n\t\t\tconst boneInverses = [];\r\n\r\n\t\t\tfor ( let i = 0, il = jointNodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst jointNode = jointNodes[ i ];\r\n\r\n\t\t\t\tif ( jointNode ) {\r\n\r\n\t\t\t\t\tbones.push( jointNode );\r\n\r\n\t\t\t\t\tconst mat = new Matrix4();\r\n\r\n\t\t\t\t\tif ( inverseBindMatrices !== null ) {\r\n\r\n\t\t\t\t\t\tmat.fromArray( inverseBindMatrices.array, i * 16 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tboneInverses.push( mat );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', skinDef.joints[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new Skeleton( bones, boneInverses );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\t *\r\n\t * @private\r\n\t * @param {number} animationIndex\r\n\t * @return {Promise<AnimationClip>}\r\n\t */\r\n\tloadAnimation( animationIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst parser = this;\r\n\r\n\t\tconst animationDef = json.animations[ animationIndex ];\r\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\r\n\r\n\t\tconst pendingNodes = [];\r\n\t\tconst pendingInputAccessors = [];\r\n\t\tconst pendingOutputAccessors = [];\r\n\t\tconst pendingSamplers = [];\r\n\t\tconst pendingTargets = [];\r\n\r\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst channel = animationDef.channels[ i ];\r\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\r\n\t\t\tconst target = channel.target;\r\n\t\t\tconst name = target.node;\r\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\r\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\r\n\r\n\t\t\tif ( target.node === undefined ) continue;\r\n\r\n\t\t\tpendingNodes.push( this.getDependency( 'node', name ) );\r\n\t\t\tpendingInputAccessors.push( this.getDependency( 'accessor', input ) );\r\n\t\t\tpendingOutputAccessors.push( this.getDependency( 'accessor', output ) );\r\n\t\t\tpendingSamplers.push( sampler );\r\n\t\t\tpendingTargets.push( target );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( [\r\n\r\n\t\t\tPromise.all( pendingNodes ),\r\n\t\t\tPromise.all( pendingInputAccessors ),\r\n\t\t\tPromise.all( pendingOutputAccessors ),\r\n\t\t\tPromise.all( pendingSamplers ),\r\n\t\t\tPromise.all( pendingTargets )\r\n\r\n\t\t] ).then( function ( dependencies ) {\r\n\r\n\t\t\tconst nodes = dependencies[ 0 ];\r\n\t\t\tconst inputAccessors = dependencies[ 1 ];\r\n\t\t\tconst outputAccessors = dependencies[ 2 ];\r\n\t\t\tconst samplers = dependencies[ 3 ];\r\n\t\t\tconst targets = dependencies[ 4 ];\r\n\r\n\t\t\tconst tracks = [];\r\n\r\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst node = nodes[ i ];\r\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\r\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\r\n\t\t\t\tconst sampler = samplers[ i ];\r\n\t\t\t\tconst target = targets[ i ];\r\n\r\n\t\t\t\tif ( node === undefined ) continue;\r\n\r\n\t\t\t\tif ( node.updateMatrix ) {\r\n\r\n\t\t\t\t\tnode.updateMatrix();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst createdTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\r\n\r\n\t\t\t\tif ( createdTracks ) {\r\n\r\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\r\n\r\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tcreateNodeMesh( nodeIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst parser = this;\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\tif ( nodeDef.mesh === undefined ) return null;\r\n\r\n\t\treturn parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {\r\n\r\n\t\t\tconst node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );\r\n\r\n\t\t\t// if weights are provided on the node, override weights on the mesh.\r\n\t\t\tif ( nodeDef.weights !== undefined ) {\r\n\r\n\t\t\t\tnode.traverse( function ( o ) {\r\n\r\n\t\t\t\t\tif ( ! o.isMesh ) return;\r\n\r\n\t\t\t\t\tfor ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\to.morphTargetInfluences[ i ] = nodeDef.weights[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n\t *\r\n\t * @private\r\n\t * @param {number} nodeIndex\r\n\t * @return {Promise<Object3D>}\r\n\t */\r\n\tloadNode( nodeIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst parser = this;\r\n\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\tconst nodePending = parser._loadNodeShallow( nodeIndex );\r\n\r\n\t\tconst childPending = [];\r\n\t\tconst childrenDef = nodeDef.children || [];\r\n\r\n\t\tfor ( let i = 0, il = childrenDef.length; i < il; i ++ ) {\r\n\r\n\t\t\tchildPending.push( parser.getDependency( 'node', childrenDef[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tconst skeletonPending = nodeDef.skin === undefined\r\n\t\t\t? Promise.resolve( null )\r\n\t\t\t: parser.getDependency( 'skin', nodeDef.skin );\r\n\r\n\t\treturn Promise.all( [\r\n\t\t\tnodePending,\r\n\t\t\tPromise.all( childPending ),\r\n\t\t\tskeletonPending\r\n\t\t] ).then( function ( results ) {\r\n\r\n\t\t\tconst node = results[ 0 ];\r\n\t\t\tconst children = results[ 1 ];\r\n\t\t\tconst skeleton = results[ 2 ];\r\n\r\n\t\t\tif ( skeleton !== null ) {\r\n\r\n\t\t\t\t// This full traverse should be fine because\r\n\t\t\t\t// child glTF nodes have not been added to this node yet.\r\n\t\t\t\tnode.traverse( function ( mesh ) {\r\n\r\n\t\t\t\t\tif ( ! mesh.isSkinnedMesh ) return;\r\n\r\n\t\t\t\t\tmesh.bind( skeleton, _identityMatrix );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( let i = 0, il = children.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tnode.add( children[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t// ._loadNodeShallow() parses a single node.\r\n\t// skin and child nodes are created and added in .loadNode() (no '_' prefix).\r\n\t_loadNodeShallow( nodeIndex ) {\r\n\r\n\t\tconst json = this.json;\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst parser = this;\r\n\r\n\t\t// This method is called from .loadNode() and .loadSkin().\r\n\t\t// Cache a node to avoid duplication.\r\n\r\n\t\tif ( this.nodeCache[ nodeIndex ] !== undefined ) {\r\n\r\n\t\t\treturn this.nodeCache[ nodeIndex ];\r\n\r\n\t\t}\r\n\r\n\t\tconst nodeDef = json.nodes[ nodeIndex ];\r\n\r\n\t\t// reserve node's name before its dependencies, so the root has the intended name.\r\n\t\tconst nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tconst meshPromise = parser._invokeOne( function ( ext ) {\r\n\r\n\t\t\treturn ext.createNodeMesh && ext.createNodeMesh( nodeIndex );\r\n\r\n\t\t} );\r\n\r\n\t\tif ( meshPromise ) {\r\n\r\n\t\t\tpending.push( meshPromise );\r\n\r\n\t\t}\r\n\r\n\t\tif ( nodeDef.camera !== undefined ) {\r\n\r\n\t\t\tpending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {\r\n\r\n\t\t\t\treturn parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );\r\n\r\n\t\t\t} ) );\r\n\r\n\t\t}\r\n\r\n\t\tparser._invokeAll( function ( ext ) {\r\n\r\n\t\t\treturn ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );\r\n\r\n\t\t} ).forEach( function ( promise ) {\r\n\r\n\t\t\tpending.push( promise );\r\n\r\n\t\t} );\r\n\r\n\t\tthis.nodeCache[ nodeIndex ] = Promise.all( pending ).then( function ( objects ) {\r\n\r\n\t\t\tlet node;\r\n\r\n\t\t\t// .isBone isn't in glTF spec. See ._markDefs\r\n\t\t\tif ( nodeDef.isBone === true ) {\r\n\r\n\t\t\t\tnode = new Bone();\r\n\r\n\t\t\t} else if ( objects.length > 1 ) {\r\n\r\n\t\t\t\tnode = new Group();\r\n\r\n\t\t\t} else if ( objects.length === 1 ) {\r\n\r\n\t\t\t\tnode = objects[ 0 ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnode = new Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( node !== objects[ 0 ] ) {\r\n\r\n\t\t\t\tfor ( let i = 0, il = objects.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tnode.add( objects[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nodeDef.name ) {\r\n\r\n\t\t\t\tnode.userData.name = nodeDef.name;\r\n\t\t\t\tnode.name = nodeName;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tassignExtrasToUserData( node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\r\n\r\n\t\t\tif ( nodeDef.matrix !== undefined ) {\r\n\r\n\t\t\t\tconst matrix = new Matrix4();\r\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\r\n\t\t\t\tnode.applyMatrix4( matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\r\n\r\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\r\n\r\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! parser.associations.has( node ) ) {\r\n\r\n\t\t\t\tparser.associations.set( node, {} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tparser.associations.get( node ).nodes = nodeIndex;\r\n\r\n\t\t\treturn node;\r\n\r\n\t\t} );\r\n\r\n\t\treturn this.nodeCache[ nodeIndex ];\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n\t *\r\n\t * @private\r\n\t * @param {number} sceneIndex\r\n\t * @return {Promise<Group>}\r\n\t */\r\n\tloadScene( sceneIndex ) {\r\n\r\n\t\tconst extensions = this.extensions;\r\n\t\tconst sceneDef = this.json.scenes[ sceneIndex ];\r\n\t\tconst parser = this;\r\n\r\n\t\t// Loader returns Group, not Scene.\r\n\t\t// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n\t\tconst scene = new Group();\r\n\t\tif ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );\r\n\r\n\t\tassignExtrasToUserData( scene, sceneDef );\r\n\r\n\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\r\n\r\n\t\tconst nodeIds = sceneDef.nodes || [];\r\n\r\n\t\tconst pending = [];\r\n\r\n\t\tfor ( let i = 0, il = nodeIds.length; i < il; i ++ ) {\r\n\r\n\t\t\tpending.push( parser.getDependency( 'node', nodeIds[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn Promise.all( pending ).then( function ( nodes ) {\r\n\r\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tscene.add( nodes[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Removes dangling associations, associations that reference a node that\r\n\t\t\t// didn't make it into the scene.\r\n\t\t\tconst reduceAssociations = ( node ) => {\r\n\r\n\t\t\t\tconst reducedAssociations = new Map();\r\n\r\n\t\t\t\tfor ( const [ key, value ] of parser.associations ) {\r\n\r\n\t\t\t\t\tif ( key instanceof Material || key instanceof Texture ) {\r\n\r\n\t\t\t\t\t\treducedAssociations.set( key, value );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnode.traverse( ( node ) => {\r\n\r\n\t\t\t\t\tconst mappings = parser.associations.get( node );\r\n\r\n\t\t\t\t\tif ( mappings != null ) {\r\n\r\n\t\t\t\t\t\treducedAssociations.set( node, mappings );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn reducedAssociations;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tparser.associations = reduceAssociations( scene );\r\n\r\n\t\t\treturn scene;\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\t_createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target ) {\r\n\r\n\t\tconst tracks = [];\r\n\r\n\t\tconst targetName = node.name ? node.name : node.uuid;\r\n\t\tconst targetNames = [];\r\n\r\n\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\r\n\r\n\t\t\tnode.traverse( function ( object ) {\r\n\r\n\t\t\t\tif ( object.morphTargetInfluences ) {\r\n\r\n\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetNames.push( targetName );\r\n\r\n\t\t}\r\n\r\n\t\tlet TypedKeyframeTrack;\r\n\r\n\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\r\n\r\n\t\t\tcase PATH_PROPERTIES.weights:\r\n\r\n\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PATH_PROPERTIES.rotation:\r\n\r\n\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase PATH_PROPERTIES.translation:\r\n\t\t\tcase PATH_PROPERTIES.scale:\r\n\r\n\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\r\n\t\t\t\tswitch ( outputAccessor.itemSize ) {\r\n\r\n\t\t\t\t\tcase 1:\r\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\tcase 3:\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\r\n\r\n\r\n\t\tconst outputArray = this._getArrayFromAccessor( outputAccessor );\r\n\r\n\t\tfor ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {\r\n\r\n\t\t\tconst track = new TypedKeyframeTrack(\r\n\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\r\n\t\t\t\tinputAccessor.array,\r\n\t\t\t\toutputArray,\r\n\t\t\t\tinterpolation\r\n\t\t\t);\r\n\r\n\t\t\t// Override interpolation with custom factory method.\r\n\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\r\n\r\n\t\t\t\tthis._createCubicSplineTrackInterpolant( track );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push( track );\r\n\r\n\t\t}\r\n\r\n\t\treturn tracks;\r\n\r\n\t}\r\n\r\n\t_getArrayFromAccessor( accessor ) {\r\n\r\n\t\tlet outputArray = accessor.array;\r\n\r\n\t\tif ( accessor.normalized ) {\r\n\r\n\t\t\tconst scale = getNormalizedComponentScale( outputArray.constructor );\r\n\t\t\tconst scaled = new Float32Array( outputArray.length );\r\n\r\n\t\t\tfor ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tscaled[ j ] = outputArray[ j ] * scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutputArray = scaled;\r\n\r\n\t\t}\r\n\r\n\t\treturn outputArray;\r\n\r\n\t}\r\n\r\n\t_createCubicSplineTrackInterpolant( track ) {\r\n\r\n\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\r\n\r\n\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n\t\t\tconst interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;\r\n\r\n\t\t\treturn new interpolantType( this.times, this.values, this.getValueSize() / 3, result );\r\n\r\n\t\t};\r\n\r\n\t\t// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n */\r\nfunction computeBounds( geometry, primitiveDef, parser ) {\r\n\r\n\tconst attributes = primitiveDef.attributes;\r\n\r\n\tconst box = new Box3();\r\n\r\n\tif ( attributes.POSITION !== undefined ) {\r\n\r\n\t\tconst accessor = parser.json.accessors[ attributes.POSITION ];\r\n\r\n\t\tconst min = accessor.min;\r\n\t\tconst max = accessor.max;\r\n\r\n\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\tbox.set(\r\n\t\t\t\tnew Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),\r\n\t\t\t\tnew Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )\r\n\t\t\t);\r\n\r\n\t\t\tif ( accessor.normalized ) {\r\n\r\n\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\r\n\t\t\t\tbox.min.multiplyScalar( boxScale );\r\n\t\t\t\tbox.max.multiplyScalar( boxScale );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tconst targets = primitiveDef.targets;\r\n\r\n\tif ( targets !== undefined ) {\r\n\r\n\t\tconst maxDisplacement = new Vector3();\r\n\t\tconst vector = new Vector3();\r\n\r\n\t\tfor ( let i = 0, il = targets.length; i < il; i ++ ) {\r\n\r\n\t\t\tconst target = targets[ i ];\r\n\r\n\t\t\tif ( target.POSITION !== undefined ) {\r\n\r\n\t\t\t\tconst accessor = parser.json.accessors[ target.POSITION ];\r\n\t\t\t\tconst min = accessor.min;\r\n\t\t\t\tconst max = accessor.max;\r\n\r\n\t\t\t\t// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n\t\t\t\tif ( min !== undefined && max !== undefined ) {\r\n\r\n\t\t\t\t\t// we need to get max of absolute components because target weight is [-1,1]\r\n\t\t\t\t\tvector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );\r\n\t\t\t\t\tvector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );\r\n\t\t\t\t\tvector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );\r\n\r\n\r\n\t\t\t\t\tif ( accessor.normalized ) {\r\n\r\n\t\t\t\t\t\tconst boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );\r\n\t\t\t\t\t\tvector.multiplyScalar( boxScale );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n\t\t\t\t\t// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n\t\t\t\t\t// are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n\t\t\t\t\t// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n\t\t\t\t\tmaxDisplacement.max( vector );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n\t\tbox.expandByVector( maxDisplacement );\r\n\r\n\t}\r\n\r\n\tgeometry.boundingBox = box;\r\n\r\n\tconst sphere = new Sphere();\r\n\r\n\tbox.getCenter( sphere.center );\r\n\tsphere.radius = box.min.distanceTo( box.max ) / 2;\r\n\r\n\tgeometry.boundingSphere = sphere;\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @private\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addPrimitiveAttributes( geometry, primitiveDef, parser ) {\r\n\r\n\tconst attributes = primitiveDef.attributes;\r\n\r\n\tconst pending = [];\r\n\r\n\tfunction assignAttributeAccessor( accessorIndex, attributeName ) {\r\n\r\n\t\treturn parser.getDependency( 'accessor', accessorIndex )\r\n\t\t\t.then( function ( accessor ) {\r\n\r\n\t\t\t\tgeometry.setAttribute( attributeName, accessor );\r\n\r\n\t\t\t} );\r\n\r\n\t}\r\n\r\n\tfor ( const gltfAttributeName in attributes ) {\r\n\r\n\t\tconst threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();\r\n\r\n\t\t// Skip attributes already provided by e.g. Draco extension.\r\n\t\tif ( threeAttributeName in geometry.attributes ) continue;\r\n\r\n\t\tpending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );\r\n\r\n\t}\r\n\r\n\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\r\n\r\n\t\tconst accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {\r\n\r\n\t\t\tgeometry.setIndex( accessor );\r\n\r\n\t\t} );\r\n\r\n\t\tpending.push( accessor );\r\n\r\n\t}\r\n\r\n\tif ( ColorManagement.workingColorSpace !== LinearSRGBColorSpace && 'COLOR_0' in attributes ) {\r\n\r\n\t\tconsole.warn( `THREE.GLTFLoader: Converting vertex colors from \"srgb-linear\" to \"${ColorManagement.workingColorSpace}\" not supported.` );\r\n\r\n\t}\r\n\r\n\tassignExtrasToUserData( geometry, primitiveDef );\r\n\r\n\tcomputeBounds( geometry, primitiveDef, parser );\r\n\r\n\treturn Promise.all( pending ).then( function () {\r\n\r\n\t\treturn primitiveDef.targets !== undefined\r\n\t\t\t? addMorphTargets( geometry, primitiveDef.targets, parser )\r\n\t\t\t: geometry;\r\n\r\n\t} );\r\n\r\n}\r\n\r\n/**\r\n * Loader result of `GLTFLoader`.\r\n *\r\n * @typedef {Object} GLTFLoader~LoadObject\r\n * @property {Array<AnimationClip>} animations - An array of animation clips.\r\n * @property {Object} asset - Meta data about the loaded asset.\r\n * @property {Array<Camera>} cameras - An array of cameras.\r\n * @property {GLTFParser} parser - A reference to the internal parser.\r\n * @property {Group} scene - The default scene.\r\n * @property {Array<Group>} scenes - glTF assets might define multiple scenes.\r\n * @property {Object} userData - Additional data.\r\n **/\r\n\r\nexport { GLTFLoader };\r\n"
      },
      "CoordinateTranslator": {
        "fileName": "CoordinateTranslator",
        "script": "class CoordinateTranslator {\r\n    constructor(config, mapSize, isometric = false) {\r\n        this.isometric = isometric;\r\n        this.tileWidth = config.gridSize;\r\n        this.tileHeight = config.gridSize * 0.5;\r\n        this.canvasWidth = config.canvasWidth;\r\n        this.canvasHeight = config.canvasHeight;\r\n        this.mapSize = mapSize;\r\n    }\r\n\r\n    // Pixel (top-down) to Grid\r\n    pixelToGrid(pixelX, pixelY) {\r\n        return {\r\n            x: pixelX / this.tileWidth,\r\n            y: pixelY / this.tileWidth\r\n        };\r\n    }\r\n\r\n    // Grid to Isometric (with vertical centering)\r\n    gridToIso(gridX, gridY) {\r\n        // If not isometric, return grid coordinates as-is\r\n        if (!this.isometric) {\r\n            return { x: gridX * this.tileWidth, y: gridY * this.tileWidth };\r\n        }\r\n\r\n        const isoX = (gridX - gridY) * (this.tileWidth / 2) + this.canvasWidth / 2;\r\n       \r\n        // Calculate the height the grid would occupy\r\n        const totalGridHeight = this.mapSize * this.tileHeight;\r\n       \r\n        // Center vertically by adding an offset\r\n        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;\r\n       \r\n        const isoY = (gridX + gridY) * (this.tileHeight / 2) + verticalOffset;\r\n       \r\n        return { x: isoX, y: isoY };\r\n    }\r\n\r\n    // Pixel (top-down) to Isometric\r\n    pixelToIso(pixelX, pixelY) {\r\n        if(!this.isometric){\r\n            return {\r\n                x: pixelX + ( this.canvasWidth - this.mapSize * this.tileWidth) / 2,\r\n                y: pixelY + ( this.canvasHeight - this.mapSize * this.tileWidth) / 2\r\n            }\r\n        }\r\n        const grid = this.pixelToGrid(pixelX, pixelY);\r\n        return this.gridToIso(grid.x, grid.y);\r\n    }\r\n\r\n    isoToGrid(isoX, isoY) {\r\n        // If not isometric, convert directly to grid\r\n        if (!this.isometric) {\r\n            return {\r\n                x: isoX / this.tileWidth,\r\n                y: isoY / this.tileWidth\r\n            };\r\n        }\r\n\r\n        const adjustedX = isoX - this.canvasWidth / 2;\r\n       \r\n        // Calculate the same vertical offset as in gridToIso\r\n        const totalGridHeight = this.mapSize * this.tileHeight;\r\n        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;\r\n       \r\n        // Subtract the offset before conversion\r\n        const adjustedY = isoY - verticalOffset;\r\n       \r\n        const gridX = (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2;\r\n        const gridY = (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2;\r\n       \r\n        return { x: gridX, y: gridY };\r\n    }\r\n\r\n    isoToPixel(isoX, isoY) {\r\n        const grid = this.isoToGrid(isoX, isoY);\r\n        return {\r\n            x: grid.x * this.tileWidth,\r\n            y: grid.y * this.tileWidth\r\n        };\r\n    }\r\n\r\n    // Snap grid coordinates to nearest integer\r\n    snapToGrid(gridX, gridY) {\r\n        return { x: Math.floor(gridX), y: Math.floor(gridY) };\r\n    }\r\n}",
        "filePath": "/global/libraries/js/CoordinateTranslator.js"
      },
      "ImageManager": {
        "fileName": "ImageManager",
        "script": "\r\nclass ImageManager {\r\n    constructor(app, {imageSize, palette, textures}) {\r\n        this.app = app;\r\n        this.images = {};\r\n        this.imageSize = imageSize || 128;\r\n        // Create a single reusable renderer\r\n        this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });\r\n        this.renderer.setSize(this.imageSize, this.imageSize);\r\n        this.renderer.shadowMap.enabled = true;\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        \r\n        this.renderTarget = new THREE.WebGLRenderTarget(this.imageSize, this.imageSize);\r\n        this.renderTarget.texture.flipY = true;\r\n        \r\n        // Create reusable scene\r\n        this.scene = new THREE.Scene();\r\n        \r\n        // Create reusable cameras for different views\r\n        const cameraDistance = 64;\r\n        const frustumSize = cameraDistance + 16;\r\n        const aspect = 1;\r\n\r\n        this.shapeFactory = new GUTS.ShapeFactory(this.app.getResourcesPath(), palette, textures);\r\n        if(location.hostname.indexOf('github') >= 0) {\r\n            this.shapeFactory.setURLRoot(\"/GUTS/\");\r\n        }\r\n        // Create 8 cameras for isometric views at 45-degree intervals\r\n        this.cameras = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            this.cameras.push(new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000));\r\n        }\r\n        \r\n        // Position cameras in a circle around the y-axis at isometric angle\r\n        // Standard isometric angle is about 35.264 degrees (arctan(1/sqrt(2)))\r\n        const isoAngle = Math.atan(1 / Math.sqrt(2));\r\n        const horizDistance = cameraDistance * Math.cos(isoAngle);\r\n        const vertDistance = cameraDistance * Math.sin(isoAngle);\r\n        \r\n        for (let i = 0; i < 8; i++) {\r\n            const angle = (i * Math.PI / 4); // 45-degree increments\r\n            const x = horizDistance * Math.sin(angle);\r\n            const z = horizDistance * Math.cos(angle);\r\n            \r\n            this.cameras[i].position.set(x, vertDistance, z);\r\n            this.cameras[i].lookAt(0, 0, 0);\r\n        }\r\n        \r\n        // Create reusable lights\r\n        this.ambientLight = new THREE.AmbientLight(0xffaaff, .25);\r\n        \r\n        // Create a light group that will rotate with each camera view\r\n        this.lightGroup = new THREE.Group();\r\n        \r\n        // Main directional light\r\n        this.directionalLight = new THREE.DirectionalLight(0xffffaa, .7);\r\n        this.directionalLight.position.set(75, 96, 75);\r\n        this.directionalLight.castShadow = true;\r\n        this.directionalLight.shadow.mapSize.width = 1024;\r\n        this.directionalLight.shadow.mapSize.height = 1024;\r\n        this.directionalLight.shadow.camera.near = 0.5;\r\n        this.directionalLight.shadow.camera.far = 500;\r\n        this.directionalLight.shadow.bias = -0.0005;\r\n        this.directionalLight.shadow.normalBias = 0.02;\r\n        this.directionalLight.shadow.radius = 1;\r\n        this.lightGroup.add(this.directionalLight);\r\n        \r\n        // Fill light\r\n        this.fillLight = new THREE.DirectionalLight(0xffaaff, .5);\r\n        this.fillLight.position.set(-20, 30, -20);\r\n        this.lightGroup.add(this.fillLight);\r\n        \r\n        // Create ground plane\r\n        const groundGeometry = new THREE.PlaneGeometry(200, 200);\r\n        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });\r\n        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n        this.ground.rotation.x = -Math.PI / 2;\r\n        this.ground.position.y = 0;\r\n        this.ground.receiveShadow = true;\r\n    }\r\n\r\n    clear() {\r\n        images = {};\r\n    }\r\n\r\n    dispose() {\r\n        // Proper cleanup when the manager is no longer needed\r\n        if (this.renderer) {\r\n            this.renderer.dispose();\r\n            this.renderer = null;\r\n        }\r\n        if (this.renderTarget) {\r\n            this.renderTarget.dispose();\r\n            this.renderTarget = null;\r\n        }\r\n        if (this.ground && this.ground.geometry) {\r\n            this.ground.geometry.dispose();\r\n            this.ground.material.dispose();\r\n        }\r\n        // Dispose of other reusable resources\r\n        this.cameras = [];\r\n        this.scene = null;\r\n        this.lightGroup = null;\r\n        this.ambientLight = null;\r\n    }\r\n\r\n    async loadImages(prefix, config, checkCache = true, cacheResult = true) {\r\n\r\n        if (!prefix || !config || typeof config !== 'object') {\r\n            throw new Error('Invalid prefix or config provided to loadImages');\r\n        }\r\n        if( checkCache ) {\r\n            const cachedImages = await this.checkCache(prefix);\r\n            if (cachedImages) {\r\n                this.images = { ...this.images, ...cachedImages };\r\n                return;\r\n            }\r\n        }\r\n        for (const [type, cfg] of Object.entries(config)) {\r\n            if (cfg.render && cfg.render.animations) {\r\n                this.images[`${prefix}_${type}`] = await this.createAnimatedPlaceholder(cfg);\r\n            } else if (cfg.tileMap && cfg.tileMap.terrainTypes) {\r\n                this.images[`${prefix}_${type}`] = await this.createTerrainImages(cfg);\r\n            }\r\n        }\r\n        if(cacheResult) {\r\n            await this.cacheImages(prefix);\r\n        }\r\n    }\r\n    \r\n    async checkCache(prefix) {\r\n        try {\r\n            const response = await fetch(`/cache/${prefix}.json`);\r\n            if (response.ok) {\r\n                const cacheData = await response.json();\r\n                // Convert base64 cached images back to canvases\r\n                return await this.convertBase64ToCanvases(cacheData.images);\r\n            }\r\n            return null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    async convertBase64ToCanvases(cachedImages) {\r\n        const convertedImages = {};\r\n        \r\n        for (const [key, value] of Object.entries(cachedImages)) {\r\n            if (Array.isArray(value)) {\r\n                // Handle terrain tiles\r\n                convertedImages[key] = await Promise.all(value.map(async (terrain) => {\r\n                    const sprites = await Promise.all(terrain.sprites.map(async (base64) => {\r\n                        const canvas = document.createElement('canvas');\r\n                        canvas.width = canvas.height = 24; // Match tileWidth from createTerrainImages\r\n                        const ctx = canvas.getContext('2d');\r\n                        const img = new Image();\r\n                        \r\n                        await new Promise((resolve, reject) => {\r\n                            img.onload = () => {\r\n                                ctx.drawImage(img, 0, 0);\r\n                                resolve();\r\n                            };\r\n                            img.onerror = reject;\r\n                            img.src = base64;\r\n                        });\r\n                        \r\n                        return canvas;\r\n                    }));\r\n                    \r\n                    return {\r\n                        type: terrain.type,\r\n                        sprites\r\n                    };\r\n                }));\r\n            } else if (typeof value === 'object') {\r\n                // Handle animations\r\n                const animations = {};\r\n                for (const [animType, frames] of Object.entries(value)) {\r\n                    animations[animType] = await Promise.all(frames.map(async (frameSet) => {\r\n                        return Promise.all(frameSet.map(async (base64) => {\r\n                            const canvas = document.createElement('canvas');\r\n                            canvas.width = canvas.height = this.imageSize;\r\n                            const ctx = canvas.getContext('2d');\r\n                            const img = new Image();\r\n                            \r\n                            await new Promise((resolve, reject) => {\r\n                                img.onload = () => {\r\n                                    ctx.drawImage(img, 0, 0);\r\n                                    resolve();\r\n                                };\r\n                                img.onerror = reject;\r\n                                img.src = base64;\r\n                            });\r\n                            \r\n                            return canvas;\r\n                        }));\r\n                    }));\r\n                }\r\n                convertedImages[key] = animations;\r\n            }\r\n        }\r\n        \r\n        return convertedImages;\r\n    }\r\n    async cacheImages(prefix) {\r\n        const base64Images = {};\r\n        \r\n        for (const [key, value] of Object.entries(this.images)) {\r\n            if (key.startsWith(prefix)) {\r\n                if (Array.isArray(value) && value[0]?.type && value[0]?.sprites) {\r\n                    // Handle terrain tiles\r\n                    base64Images[key] = value.map(terrain => ({\r\n                        type: terrain.type,\r\n                        sprites: terrain.sprites.map(canvas => canvas.toDataURL('image/png'))\r\n                    }));\r\n                } else if (typeof value === 'object' && value !== null) {\r\n                    // Handle animations\r\n                    const animationData = {};\r\n                    for (const [animType, frames] of Object.entries(value)) {\r\n                        animationData[animType] = frames.map(frameSet => \r\n                            frameSet.map(canvas => canvas.toDataURL('image/png'))\r\n                        );\r\n                    }\r\n                    base64Images[key] = animationData;\r\n                }\r\n            }\r\n        }\r\n\r\n        try {\r\n            await fetch('/api/cache', {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json',\r\n                },\r\n                body: JSON.stringify({\r\n                    prefix,\r\n                    images: base64Images\r\n                })\r\n            });\r\n        } catch (error) {\r\n            console.error('Error caching images:', error);\r\n        }\r\n    }\r\n    // In the ImageManager class\r\n    async createTerrainImages(config) {\r\n        let terrainTiles = [];\r\n        const tileWidth = 24;\r\n\r\n        // Create a map of terrain type to its image data first\r\n        const terrainMap = {};\r\n        await Promise.all(config.tileMap.terrainTypes.map(async (terrainType, terrainIndex) => {\r\n            const pixelData = terrainType.image;\r\n            if (pixelData && pixelData.length > 0) {\r\n                let sprites = new Array(8);\r\n                \r\n                await Promise.all(pixelData.map(async (imagePixelData, spriteIdx) => {\r\n                    const img = new Image();\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = tileWidth;\r\n                    const ctx = canvas.getContext('2d');\r\n\r\n                    if (!imagePixelData.startsWith('data:image/')) {\r\n                        imagePixelData = 'data:image/png;base64,' + imagePixelData;\r\n                    }\r\n                    img.src = imagePixelData;\r\n\r\n                    await new Promise((resolve, reject) => {\r\n                        img.onload = () => {\r\n                            ctx.drawImage(img, 0, 0);\r\n                            sprites[spriteIdx] = canvas;\r\n                            resolve();\r\n                        };\r\n                        img.onerror = () => {\r\n                            console.error(`Failed to load image for ${terrainType.type} at index ${spriteIdx}`);\r\n                            sprites[spriteIdx] = canvas; // Store empty canvas on error\r\n                            resolve(); // Don't reject, just move on\r\n                        };\r\n                    });\r\n                }));\r\n\r\n                // Store by index and type for more reliable lookup\r\n                terrainTiles[terrainIndex] = { \r\n                    type: terrainType.type,\r\n                    sprites: sprites \r\n                };\r\n            } else {\r\n                // Create transparent placeholder for types without images\r\n                // Don't use terrainType.color as it causes color bleed at tile edges\r\n                const sprites = new Array(8).fill().map(() => {\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = tileWidth;\r\n                    const ctx = canvas.getContext('2d');\r\n                    // Leave canvas transparent (don't fillRect)\r\n                    // This prevents layer colors from bleeding through at edges\r\n                    return canvas;\r\n                });\r\n                \r\n                terrainTiles[terrainIndex] = {\r\n                    type: terrainType.type,\r\n                    sprites: sprites\r\n                };\r\n            }\r\n        }));\r\n\r\n        // Make sure there are no gaps in the array\r\n        return terrainTiles.filter(Boolean);\r\n    }\r\n    async createAnimatedPlaceholder(config) {\r\n        const animations = {};\r\n        \r\n        if(config.shadows === false) {\r\n            this.ground.receiveShadow = false;\r\n        } else {\r\n            this.ground.receiveShadow = true;\r\n        }\r\n        for (const [animType, frames] of Object.entries(config.render.animations)) {\r\n            animations[animType] = [];\r\n            let i = 0;\r\n            for (const frame of frames) {\r\n                const frameImages = await this.captureObjectImagesFromJSON(config.render.model, frame);\r\n                const canvases = frameImages.map(img => {\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = canvas.height = this.imageSize;\r\n                    const ctx = canvas.getContext('2d');\r\n                    ctx.drawImage(img, 0, 0);\r\n                    return canvas;\r\n                });                \r\n                animations[animType].push(canvases); // Array of 8 canvases per frame\r\n            }\r\n        }\r\n        return animations; // { \"idle\": [[canvas0, canvas1, canvas2, canvas3, ...], ...], \"walk\": [...] }\r\n    }\r\n\r\n    getImages(prefix, type) {\r\n        return this.images[`${prefix}_${type}`]; // Returns animation object\r\n    }\r\n    async captureObjectImagesFromJSON(model, frameData) {\r\n        const size = this.imageSize;\r\n        // Clear the scene\r\n        while (this.scene.children.length > 0) {\r\n            const object = this.scene.children[0];\r\n            this.scene.remove(object);\r\n        }\r\n        \r\n        // Add reusable elements to scene\r\n        this.scene.add(this.ground);\r\n        this.scene.add(this.ambientLight);\r\n        this.scene.add(this.lightGroup);\r\n        \r\n        // Create objects from the JSON data\r\n        const objectGroup = await this.createObjectsFromJSON(model, frameData, this.scene);\r\n\r\n        \r\n        const images = [];\r\n        \r\n        // For each camera view, rotate the light group to match camera orientation\r\n        for (let i = 0; i < this.cameras.length; i++) {\r\n            const camera = this.cameras[i];\r\n            \r\n            // Reset light group rotation\r\n            this.lightGroup.rotation.set(0, 0, 0);\r\n            \r\n            // Rotate light group to match camera position\r\n            // Calculate angle based on camera index (8 positions at 45-degree intervals)\r\n            // Rotate 45 degrees CLOCKWISE (subtract /4 instead of adding)\r\n            const angle = (i * Math.PI / 4); \r\n            this.lightGroup.rotation.y = angle;\r\n            \r\n            // Before rendering with each camera, update shadow camera frustum\r\n            const d = 100;\r\n            this.directionalLight.shadow.camera.left = -d;\r\n            this.directionalLight.shadow.camera.right = d;\r\n            this.directionalLight.shadow.camera.top = d;\r\n            this.directionalLight.shadow.camera.bottom = -d;\r\n            // After rotating lightGroup in the camera loop\r\n            this.directionalLight.shadow.camera.updateProjectionMatrix();\r\n            this.directionalLight.shadow.camera.updateMatrixWorld();\r\n            this.directionalLight.target.position.set(0, 0, 0);\r\n            this.directionalLight.target.updateMatrixWorld();\r\n            // Render and capture the image\r\n            this.renderer.setRenderTarget(this.renderTarget);\r\n            this.renderer.render(this.scene, camera);\r\n            const buffer = new Uint8Array(size * size * 4);\r\n            this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, size, size, buffer);\r\n            \r\n            // Flip the buffer (y-axis)\r\n            const flippedBuffer = new Uint8Array(size * size * 4);\r\n            for (let y = 0; y < size; y++) {\r\n                const srcRowStart = y * size * 4;\r\n                const destRowStart = (size - 1 - y) * size * 4;\r\n                flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);\r\n            }\r\n            \r\n            const imageData = new ImageData(new Uint8ClampedArray(flippedBuffer), size, size);\r\n            const imageBitmap = await createImageBitmap(imageData);\r\n            images.push(imageBitmap);\r\n        }\r\n        if( this.renderer) this.renderer.setRenderTarget(null);\r\n        \r\n        // Cleanup object geometries and materials\r\n        this.shapeFactory.disposeObject(objectGroup);\r\n        \r\n        // Remove object group from scene\r\n        if( this.scene ) this.scene.remove(objectGroup);\r\n        \r\n        return images;\r\n    }\r\n\r\n    /**\r\n     * Creates 3D objects from shape data.\r\n     * @param {Object} frameData - The JSON object containing frame definitions.\r\n     * @returns {THREE.Group} - A group containing all 3D objects.\r\n     */\r\n  \r\n    async createObjectsFromJSON(model, frameData, scene) {\r\n        const rootGroup = new THREE.Group();\r\n        \r\n        for(const groupName in model) {\r\n            const group = await this.shapeFactory.createMergedGroupFromJSON(model, frameData, groupName);\r\n            if(group){\r\n                group.traverse((child) => {\r\n                    if (child.isMesh) {\r\n                        child.castShadow = true; // or set this selectively for objects that should cast shadows\r\n                        child.receiveShadow = true; // for objects that should receive shadows\r\n                    }\r\n                });\r\n                rootGroup.add(group);\r\n            }\r\n        }\r\n\r\n        scene.add(rootGroup);\r\n    \r\n        return rootGroup;\r\n    }\r\n   \r\n}\r\n",
        "filePath": "/global/libraries/js/ImageManager.js"
      },
      "GE_AnimationManager": {
        "title": "GE_AnimationManager",
        "fileName": "GE_AnimationManager",
        "script": "class GE_AnimationManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n\r\n        this.isPreviewingAnimation = false;\r\n    }    \r\n\r\n    init() {   \r\n        this.initEventListeners();\r\n    }\r\n    \r\n    initEventListeners() {\r\n        // Button event listeners\r\n        const buttonMappings = {\r\n            'preview-animation': this.togglePreview.bind(this),\r\n            'add-animation': this.addNewAnimation.bind(this),\r\n            'delete-animation': this.deleteAnimation.bind(this),\r\n            'add-frame': this.addFrame.bind(this),\r\n            'delete-frame': this.deleteFrame.bind(this)\r\n        };\r\n        Object.entries(buttonMappings).forEach(([id, handler]) => {\r\n            const button = document.getElementById(id);\r\n            if (button) button.addEventListener('click', handler);\r\n        });\r\n    }\r\n\r\n    setPreviewAnimationState(isPreviewing) {\r\n        this.isPreviewingAnimation = isPreviewing;\r\n        let btn = document.getElementById('preview-animation');\r\n        if (this.isPreviewingAnimation) {\r\n            btn.classList.add(\"active\");\r\n            this.graphicsEditor.gizmoManager.destroyGizmo();\r\n        } else {\r\n            this.graphicsEditor.state.currentFrame = 0;\r\n            btn.classList.remove(\"active\");\r\n        }\r\n    }\r\n\r\n    async animatePreview() {\r\n        if (!this.isPreviewingAnimation) return;\r\n        this.graphicsEditor.state.currentFrame = (this.graphicsEditor.state.currentFrame + 1) % this.graphicsEditor.getCurrentAnimation().length;\r\n        await this.graphicsEditor.renderShapes(false);\r\n        setTimeout(this.animatePreview.bind(this), 166); // ~6 FPS, adjust as needed\r\n    }\r\n    \r\n    async togglePreview(e) {\r\n        this.isPreviewingAnimation = !this.isPreviewingAnimation;\r\n        await this.animatePreview();\r\n        this.setPreviewAnimationState(this.isPreviewingAnimation);            \r\n    }\r\n\r\n    \r\n\r\n\r\n    addNewAnimation() {\r\n        const animName = prompt(\"Enter animation name:\", `anim${Object.keys(this.graphicsEditor.state.renderData.animations).length + 1}`);\r\n        if (animName && !this.graphicsEditor.state.renderData.animations[animName]) {\r\n            this.graphicsEditor.state.renderData.animations[animName] = [ ...this.graphicsEditor.state.renderData.animations[\"idle\"] ];\r\n            this.graphicsEditor.state.currentAnimation = animName;\r\n            this.graphicsEditor.state.currentFrame = 0;        \r\n            this.graphicsEditor.refreshShapes(true);\r\n        }\r\n    }\r\n\r\n    deleteAnimation() {\r\n        if (this.graphicsEditor.state.currentAnimation !== \"idle\") {\r\n            delete this.graphicsEditor.getCurrentAnimation();\r\n            this.graphicsEditor.state.currentAnimation = \"idle\";\r\n            this.graphicsEditor.state.currentFrame = 0;\r\n            this.graphicsEditor.state.selectedShapeIndex = -1;\r\n            this.graphicsEditor.refreshShapes(true);\r\n        }\r\n    }\r\n\r\n    addFrame() {\r\n\r\n        let currentFrame = this.graphicsEditor.getCurrentFrame();\r\n        if(!currentFrame){\r\n            currentFrame = {};\r\n        }\r\n        const newFrame = { shapes: JSON.parse(JSON.stringify(currentFrame.shapes || [])) };\r\n        this.graphicsEditor.getCurrentAnimation().splice(this.graphicsEditor.state.currentFrame + 1, 0, newFrame);                    \r\n        this.graphicsEditor.state.currentFrame++;\r\n        this.graphicsEditor.refreshShapes(true);\r\n    \r\n    }\r\n\r\n    deleteFrame() {\r\n        let currentAnimation = this.graphicsEditor.getCurrentAnimation();\r\n        if (currentAnimation.length > 1) {\r\n            currentAnimation.splice(this.graphicsEditor.state.currentFrame, 1);\r\n            \r\n            this.graphicsEditor.state.currentFrame = Math.min(this.graphicsEditor.state.currentFrame, currentAnimation.length - 1);\r\n            this.graphicsEditor.refreshShapes(true);\r\n        }\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GE_AnimationManager.js"
      },
      "BufferGeometryUtils": {
        "title": "THREE.BufferGeometryUtils",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "BufferGeometryUtils",
        "importName": "BufferGeometryUtils",
        "filePath": "/global/libraries/js/BufferGeometryUtils.js",
        "script": "import {\r\n\tBufferAttribute,\r\n\tBufferGeometry,\r\n\tFloat32BufferAttribute,\r\n\tInstancedBufferAttribute,\r\n\tInterleavedBuffer,\r\n\tInterleavedBufferAttribute,\r\n\tTriangleFanDrawMode,\r\n\tTriangleStripDrawMode,\r\n\tTrianglesDrawMode,\r\n\tVector3,\r\n} from 'three';\r\n\r\n/**\r\n * @module BufferGeometryUtils\r\n * @three_import import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';\r\n */\r\n\r\n/**\r\n * Computes vertex tangents using the MikkTSpace algorithm. MikkTSpace generates the same tangents consistently,\r\n * and is used in most modelling tools and normal map bakers. Use MikkTSpace for materials with normal maps,\r\n * because inconsistent tangents may lead to subtle visual issues in the normal map, particularly around mirrored\r\n * UV seams.\r\n *\r\n * In comparison to this method, {@link BufferGeometry#computeTangents} (a custom algorithm) generates tangents that\r\n * probably will not match the tangents in other software. The custom algorithm is sufficient for general use with a\r\n * custom material, and may be faster than MikkTSpace.\r\n *\r\n * Returns the original BufferGeometry. Indexed geometries will be de-indexed. Requires position, normal, and uv attributes.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to compute tangents for.\r\n * @param {Object} MikkTSpace - Instance of `examples/jsm/libs/mikktspace.module.js`, or `mikktspace` npm package.\r\n * Await `MikkTSpace.ready` before use.\r\n * @param {boolean} [negateSign=true] - Whether to negate the sign component (.w) of each tangent.\r\n * Required for normal map conventions in some formats, including glTF.\r\n * @return {BufferGeometry} The updated geometry.\r\n */\r\nfunction computeMikkTSpaceTangents( geometry, MikkTSpace, negateSign = true ) {\r\n\r\n\tif ( ! MikkTSpace || ! MikkTSpace.isReady ) {\r\n\r\n\t\tthrow new Error( 'BufferGeometryUtils: Initialized MikkTSpace library required.' );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.hasAttribute( 'position' ) || ! geometry.hasAttribute( 'normal' ) || ! geometry.hasAttribute( 'uv' ) ) {\r\n\r\n\t\tthrow new Error( 'BufferGeometryUtils: Tangents require \"position\", \"normal\", and \"uv\" attributes.' );\r\n\r\n\t}\r\n\r\n\tfunction getAttributeArray( attribute ) {\r\n\r\n\t\tif ( attribute.normalized || attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tconst dstArray = new Float32Array( attribute.count * attribute.itemSize );\r\n\r\n\t\t\tfor ( let i = 0, j = 0; i < attribute.count; i ++ ) {\r\n\r\n\t\t\t\tdstArray[ j ++ ] = attribute.getX( i );\r\n\t\t\t\tdstArray[ j ++ ] = attribute.getY( i );\r\n\r\n\t\t\t\tif ( attribute.itemSize > 2 ) {\r\n\r\n\t\t\t\t\tdstArray[ j ++ ] = attribute.getZ( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn dstArray;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attribute.array instanceof Float32Array ) {\r\n\r\n\t\t\treturn attribute.array;\r\n\r\n\t\t}\r\n\r\n\t\treturn new Float32Array( attribute.array );\r\n\r\n\t}\r\n\r\n\t// MikkTSpace algorithm requires non-indexed input.\r\n\r\n\tconst _geometry = geometry.index ? geometry.toNonIndexed() : geometry;\r\n\r\n\t// Compute vertex tangents.\r\n\r\n\tconst tangents = MikkTSpace.generateTangents(\r\n\r\n\t\tgetAttributeArray( _geometry.attributes.position ),\r\n\t\tgetAttributeArray( _geometry.attributes.normal ),\r\n\t\tgetAttributeArray( _geometry.attributes.uv )\r\n\r\n\t);\r\n\r\n\t// Texture coordinate convention of glTF differs from the apparent\r\n\t// default of the MikkTSpace library; .w component must be flipped.\r\n\r\n\tif ( negateSign ) {\r\n\r\n\t\tfor ( let i = 3; i < tangents.length; i += 4 ) {\r\n\r\n\t\t\ttangents[ i ] *= - 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\t_geometry.setAttribute( 'tangent', new BufferAttribute( tangents, 4 ) );\r\n\r\n\tif ( geometry !== _geometry ) {\r\n\r\n\t\tgeometry.copy( _geometry );\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\n/**\r\n * Merges a set of geometries into a single instance. All geometries must have compatible attributes.\r\n *\r\n * @param {Array<BufferGeometry>} geometries - The geometries to merge.\r\n * @param {boolean} [useGroups=false] - Whether to use groups or not.\r\n * @return {?BufferGeometry} The merged geometry. Returns `null` if the merge does not succeed.\r\n */\r\nfunction mergeGeometries( geometries, useGroups = false ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\r\n\r\n\tconst attributes = {};\r\n\tconst morphAttributes = {};\r\n\r\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\r\n\r\n\tconst mergedGeometry = new BufferGeometry();\r\n\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\r\n\r\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\r\n\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\t// gather morph attributes, exit early if they're different\r\n\r\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( const name in geometry.morphAttributes ) {\r\n\r\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\r\n\r\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( useGroups ) {\r\n\r\n\t\t\tlet count;\r\n\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tcount = geometry.index.count;\r\n\r\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\r\n\r\n\t\t\t\tcount = geometry.attributes.position.count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmergedGeometry.addGroup( offset, count, i );\r\n\r\n\t\t\toffset += count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// merge indices\r\n\r\n\tif ( isIndexed ) {\r\n\r\n\t\tlet indexOffset = 0;\r\n\t\tconst mergedIndex = [];\r\n\r\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\t\tconst index = geometries[ i ].index;\r\n\r\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\r\n\r\n\t\t}\r\n\r\n\t\tmergedGeometry.setIndex( mergedIndex );\r\n\r\n\t}\r\n\r\n\t// merge attributes\r\n\r\n\tfor ( const name in attributes ) {\r\n\r\n\t\tconst mergedAttribute = mergeAttributes( attributes[ name ] );\r\n\r\n\t\tif ( ! mergedAttribute ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\r\n\r\n\t}\r\n\r\n\t// merge morph attributes\r\n\r\n\tfor ( const name in morphAttributes ) {\r\n\r\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\r\n\r\n\t\tif ( numMorphTargets === 0 ) break;\r\n\r\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n\t\tmergedGeometry.morphAttributes[ name ] = [];\r\n\r\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\r\n\r\n\t\t\tconst morphAttributesToMerge = [];\r\n\r\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\r\n\r\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst mergedMorphAttribute = mergeAttributes( morphAttributesToMerge );\r\n\r\n\t\t\tif ( ! mergedMorphAttribute ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn mergedGeometry;\r\n\r\n}\r\n\r\n/**\r\n * Merges a set of attributes into a single instance. All attributes must have compatible properties and types.\r\n * Instances of {@link InterleavedBufferAttribute} are not supported.\r\n *\r\n * @param {Array<BufferAttribute>} attributes - The attributes to merge.\r\n * @return {?BufferAttribute} The merged attribute. Returns `null` if the merge does not succeed.\r\n */\r\nfunction mergeAttributes( attributes ) {\r\n\r\n\tlet TypedArray;\r\n\tlet itemSize;\r\n\tlet normalized;\r\n\tlet gpuType = - 1;\r\n\tlet arrayLength = 0;\r\n\r\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\r\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\r\n\t\tif ( TypedArray !== attribute.array.constructor ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\r\n\t\tif ( itemSize !== attribute.itemSize ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\r\n\t\tif ( normalized !== attribute.normalized ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tif ( gpuType === - 1 ) gpuType = attribute.gpuType;\r\n\t\tif ( gpuType !== attribute.gpuType ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tarrayLength += attribute.count * itemSize;\r\n\r\n\t}\r\n\r\n\tconst array = new TypedArray( arrayLength );\r\n\tconst result = new BufferAttribute( array, itemSize, normalized );\r\n\tlet offset = 0;\r\n\r\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tconst tupleOffset = offset / itemSize;\r\n\t\t\tfor ( let j = 0, l = attribute.count; j < l; j ++ ) {\r\n\r\n\t\t\t\tfor ( let c = 0; c < itemSize; c ++ ) {\r\n\r\n\t\t\t\t\tconst value = attribute.getComponent( j, c );\r\n\t\t\t\t\tresult.setComponent( j + tupleOffset, c, value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray.set( attribute.array, offset );\r\n\r\n\t\t}\r\n\r\n\t\toffset += attribute.count * itemSize;\r\n\r\n\t}\r\n\r\n\tif ( gpuType !== undefined ) {\r\n\r\n\t\tresult.gpuType = gpuType;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n/**\r\n * Performs a deep clone of the given buffer attribute.\r\n *\r\n * @param {BufferAttribute} attribute - The attribute to clone.\r\n * @return {BufferAttribute} The cloned attribute.\r\n */\r\nfunction deepCloneAttribute( attribute ) {\r\n\r\n\tif ( attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute ) {\r\n\r\n\t\treturn deinterleaveAttribute( attribute );\r\n\r\n\t}\r\n\r\n\tif ( attribute.isInstancedBufferAttribute ) {\r\n\r\n\t\treturn new InstancedBufferAttribute().copy( attribute );\r\n\r\n\t}\r\n\r\n\treturn new BufferAttribute().copy( attribute );\r\n\r\n}\r\n\r\n/**\r\n * Interleaves a set of attributes and returns a new array of corresponding attributes that share a\r\n * single {@link InterleavedBuffer} instance. All attributes must have compatible types.\r\n *\r\n * @param {Array<BufferAttribute>} attributes - The attributes to interleave.\r\n * @return {Array<InterleavedBufferAttribute>} An array of interleaved attributes. If interleave does not succeed, the method returns `null`.\r\n */\r\nfunction interleaveAttributes( attributes ) {\r\n\r\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\r\n\t// a set of InterleavedBufferAttributes for each attribute\r\n\tlet TypedArray;\r\n\tlet arrayLength = 0;\r\n\tlet stride = 0;\r\n\r\n\t// calculate the length and type of the interleavedBuffer\r\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\r\n\r\n\t\tconst attribute = attributes[ i ];\r\n\r\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\r\n\t\tif ( TypedArray !== attribute.array.constructor ) {\r\n\r\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tarrayLength += attribute.array.length;\r\n\t\tstride += attribute.itemSize;\r\n\r\n\t}\r\n\r\n\t// Create the set of buffer attributes\r\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\r\n\tlet offset = 0;\r\n\tconst res = [];\r\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\r\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\r\n\r\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\r\n\r\n\t\tconst attribute = attributes[ j ];\r\n\t\tconst itemSize = attribute.itemSize;\r\n\t\tconst count = attribute.count;\r\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\r\n\t\tres.push( iba );\r\n\r\n\t\toffset += itemSize;\r\n\r\n\t\t// Move the data for each attribute into the new interleavedBuffer\r\n\t\t// at the appropriate offset\r\n\t\tfor ( let c = 0; c < count; c ++ ) {\r\n\r\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn res;\r\n\r\n}\r\n\r\n/**\r\n * Returns a new, non-interleaved version of the given attribute.\r\n *\r\n * @param {InterleavedBufferAttribute} attribute - The interleaved attribute.\r\n * @return {BufferAttribute} The non-interleaved attribute.\r\n */\r\nfunction deinterleaveAttribute( attribute ) {\r\n\r\n\tconst cons = attribute.data.array.constructor;\r\n\tconst count = attribute.count;\r\n\tconst itemSize = attribute.itemSize;\r\n\tconst normalized = attribute.normalized;\r\n\r\n\tconst array = new cons( count * itemSize );\r\n\tlet newAttribute;\r\n\tif ( attribute.isInstancedInterleavedBufferAttribute ) {\r\n\r\n\t\tnewAttribute = new InstancedBufferAttribute( array, itemSize, normalized, attribute.meshPerAttribute );\r\n\r\n\t} else {\r\n\r\n\t\tnewAttribute = new BufferAttribute( array, itemSize, normalized );\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tnewAttribute.setX( i, attribute.getX( i ) );\r\n\r\n\t\tif ( itemSize >= 2 ) {\r\n\r\n\t\t\tnewAttribute.setY( i, attribute.getY( i ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize >= 3 ) {\r\n\r\n\t\t\tnewAttribute.setZ( i, attribute.getZ( i ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemSize >= 4 ) {\r\n\r\n\t\t\tnewAttribute.setW( i, attribute.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn newAttribute;\r\n\r\n}\r\n\r\n/**\r\n * Deinterleaves all attributes on the given geometry.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to deinterleave.\r\n */\r\nfunction deinterleaveGeometry( geometry ) {\r\n\r\n\tconst attributes = geometry.attributes;\r\n\tconst morphTargets = geometry.morphTargets;\r\n\tconst attrMap = new Map();\r\n\r\n\tfor ( const key in attributes ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tif ( ! attrMap.has( attr ) ) {\r\n\r\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributes[ key ] = attrMap.get( attr );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( const key in morphTargets ) {\r\n\r\n\t\tconst attr = morphTargets[ key ];\r\n\t\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tif ( ! attrMap.has( attr ) ) {\r\n\r\n\t\t\t\tattrMap.set( attr, deinterleaveAttribute( attr ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmorphTargets[ key ] = attrMap.get( attr );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Returns the amount of bytes used by all attributes to represent the geometry.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry.\r\n * @return {number} The estimate bytes used.\r\n */\r\nfunction estimateBytesUsed( geometry ) {\r\n\r\n\t// Return the estimated memory used by this geometry in bytes\r\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\r\n\t// for InterleavedBufferAttributes.\r\n\tlet mem = 0;\r\n\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\tconst attr = geometry.getAttribute( name );\r\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\r\n\r\n\t}\r\n\r\n\tconst indices = geometry.getIndex();\r\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\r\n\treturn mem;\r\n\r\n}\r\n\r\n/**\r\n * Returns a new geometry with vertices for which all similar vertex attributes (within tolerance) are merged.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to merge vertices for.\r\n * @param {number} [tolerance=1e-4] - The tolerance value.\r\n * @return {BufferGeometry} - The new geometry with merged vertices.\r\n */\r\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\r\n\r\n\ttolerance = Math.max( tolerance, Number.EPSILON );\r\n\r\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\r\n\t// if it's already available.\r\n\tconst hashToIndex = {};\r\n\tconst indices = geometry.getIndex();\r\n\tconst positions = geometry.getAttribute( 'position' );\r\n\tconst vertexCount = indices ? indices.count : positions.count;\r\n\r\n\t// next value for triangle indices\r\n\tlet nextIndex = 0;\r\n\r\n\t// attributes and new attribute arrays\r\n\tconst attributeNames = Object.keys( geometry.attributes );\r\n\tconst tmpAttributes = {};\r\n\tconst tmpMorphAttributes = {};\r\n\tconst newIndices = [];\r\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\r\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\r\n\r\n\t// Initialize the arrays, allocating space conservatively. Extra\r\n\t// space will be trimmed in the last step.\r\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\r\n\r\n\t\tconst name = attributeNames[ i ];\r\n\t\tconst attr = geometry.attributes[ name ];\r\n\r\n\t\ttmpAttributes[ name ] = new attr.constructor(\r\n\t\t\tnew attr.array.constructor( attr.count * attr.itemSize ),\r\n\t\t\tattr.itemSize,\r\n\t\t\tattr.normalized\r\n\t\t);\r\n\r\n\t\tconst morphAttributes = geometry.morphAttributes[ name ];\r\n\t\tif ( morphAttributes ) {\r\n\r\n\t\t\tif ( ! tmpMorphAttributes[ name ] ) tmpMorphAttributes[ name ] = [];\r\n\t\t\tmorphAttributes.forEach( ( morphAttr, i ) => {\r\n\r\n\t\t\t\tconst array = new morphAttr.array.constructor( morphAttr.count * morphAttr.itemSize );\r\n\t\t\t\ttmpMorphAttributes[ name ][ i ] = new morphAttr.constructor( array, morphAttr.itemSize, morphAttr.normalized );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// convert the error tolerance to an amount of decimal places to truncate to\r\n\tconst halfTolerance = tolerance * 0.5;\r\n\tconst exponent = Math.log10( 1 / tolerance );\r\n\tconst hashMultiplier = Math.pow( 10, exponent );\r\n\tconst hashAdditive = halfTolerance * hashMultiplier;\r\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\tconst index = indices ? indices.getX( i ) : i;\r\n\r\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\r\n\t\tlet hash = '';\r\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\r\n\r\n\t\t\tconst name = attributeNames[ j ];\r\n\t\t\tconst attribute = geometry.getAttribute( name );\r\n\t\t\tconst itemSize = attribute.itemSize;\r\n\r\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\t// double tilde truncates the decimal value\r\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Add another reference to the vertex if it's already\r\n\t\t// used by another index\r\n\t\tif ( hash in hashToIndex ) {\r\n\r\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// copy data to the new index in the temporary attributes\r\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\r\n\r\n\t\t\t\tconst name = attributeNames[ j ];\r\n\t\t\t\tconst attribute = geometry.getAttribute( name );\r\n\t\t\t\tconst morphAttributes = geometry.morphAttributes[ name ];\r\n\t\t\t\tconst itemSize = attribute.itemSize;\r\n\t\t\t\tconst newArray = tmpAttributes[ name ];\r\n\t\t\t\tconst newMorphArrays = tmpMorphAttributes[ name ];\r\n\r\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\r\n\r\n\t\t\t\t\tconst getterFunc = getters[ k ];\r\n\t\t\t\t\tconst setterFunc = setters[ k ];\r\n\t\t\t\t\tnewArray[ setterFunc ]( nextIndex, attribute[ getterFunc ]( index ) );\r\n\r\n\t\t\t\t\tif ( morphAttributes ) {\r\n\r\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttributes.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tnewMorphArrays[ m ][ setterFunc ]( nextIndex, morphAttributes[ m ][ getterFunc ]( index ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\thashToIndex[ hash ] = nextIndex;\r\n\t\t\tnewIndices.push( nextIndex );\r\n\t\t\tnextIndex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate result BufferGeometry\r\n\tconst result = geometry.clone();\r\n\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\tconst tmpAttribute = tmpAttributes[ name ];\r\n\r\n\t\tresult.setAttribute( name, new tmpAttribute.constructor(\r\n\t\t\ttmpAttribute.array.slice( 0, nextIndex * tmpAttribute.itemSize ),\r\n\t\t\ttmpAttribute.itemSize,\r\n\t\t\ttmpAttribute.normalized,\r\n\t\t) );\r\n\r\n\t\tif ( ! ( name in tmpMorphAttributes ) ) continue;\r\n\r\n\t\tfor ( let j = 0; j < tmpMorphAttributes[ name ].length; j ++ ) {\r\n\r\n\t\t\tconst tmpMorphAttribute = tmpMorphAttributes[ name ][ j ];\r\n\r\n\t\t\tresult.morphAttributes[ name ][ j ] = new tmpMorphAttribute.constructor(\r\n\t\t\t\ttmpMorphAttribute.array.slice( 0, nextIndex * tmpMorphAttribute.itemSize ),\r\n\t\t\t\ttmpMorphAttribute.itemSize,\r\n\t\t\t\ttmpMorphAttribute.normalized,\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// indices\r\n\r\n\tresult.setIndex( newIndices );\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\n/**\r\n * Returns a new indexed geometry based on `TrianglesDrawMode` draw mode.\r\n * This mode corresponds to the `gl.TRIANGLES` primitive in WebGL.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to convert.\r\n * @param {number} drawMode - The current draw mode.\r\n * @return {BufferGeometry} The new geometry using `TrianglesDrawMode`.\r\n */\r\nfunction toTrianglesDrawMode( geometry, drawMode ) {\r\n\r\n\tif ( drawMode === TrianglesDrawMode ) {\r\n\r\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\r\n\r\n\t\tlet index = geometry.getIndex();\r\n\r\n\t\t// generate index if not present\r\n\r\n\t\tif ( index === null ) {\r\n\r\n\t\t\tconst indices = [];\r\n\r\n\t\t\tconst position = geometry.getAttribute( 'position' );\r\n\r\n\t\t\tif ( position !== undefined ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\r\n\r\n\t\t\t\t\tindices.push( i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.setIndex( indices );\r\n\t\t\t\tindex = geometry.getIndex();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\r\n\t\t\t\treturn geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tconst numberOfTriangles = index.count - 2;\r\n\t\tconst newIndices = [];\r\n\r\n\t\tif ( drawMode === TriangleFanDrawMode ) {\r\n\r\n\t\t\t// gl.TRIANGLE_FAN\r\n\r\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\r\n\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// gl.TRIANGLE_STRIP\r\n\r\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\r\n\r\n\t\t\t\tif ( i % 2 === 0 ) {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\r\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\r\n\r\n\t\t}\r\n\r\n\t\t// build final geometry\r\n\r\n\t\tconst newGeometry = geometry.clone();\r\n\t\tnewGeometry.setIndex( newIndices );\r\n\t\tnewGeometry.clearGroups();\r\n\r\n\t\treturn newGeometry;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\r\n *\r\n * Helpful for Raytracing or Decals (i.e. a `DecalGeometry` applied to a morphed Object with a `BufferGeometry`\r\n * will use the original `BufferGeometry`, not the morphed/skinned one, generating an incorrect result.\r\n * Using this function to create a shadow `Object3`D the `DecalGeometry` can be correctly generated).\r\n *\r\n * @param {Mesh|Line|Points} object - The 3D object to compute morph attributes for.\r\n * @return {Object} An object with original position/normal attributes and morphed ones.\r\n */\r\nfunction computeMorphedAttributes( object ) {\r\n\r\n\tconst _vA = new Vector3();\r\n\tconst _vB = new Vector3();\r\n\tconst _vC = new Vector3();\r\n\r\n\tconst _tempA = new Vector3();\r\n\tconst _tempB = new Vector3();\r\n\tconst _tempC = new Vector3();\r\n\r\n\tconst _morphA = new Vector3();\r\n\tconst _morphB = new Vector3();\r\n\tconst _morphC = new Vector3();\r\n\r\n\tfunction _calculateMorphedAttributeData(\r\n\t\tobject,\r\n\t\tattribute,\r\n\t\tmorphAttribute,\r\n\t\tmorphTargetsRelative,\r\n\t\ta,\r\n\t\tb,\r\n\t\tc,\r\n\t\tmodifiedAttributeArray\r\n\t) {\r\n\r\n\t\t_vA.fromBufferAttribute( attribute, a );\r\n\t\t_vB.fromBufferAttribute( attribute, b );\r\n\t\t_vC.fromBufferAttribute( attribute, c );\r\n\r\n\t\tconst morphInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( morphAttribute && morphInfluences ) {\r\n\r\n\t\t\t_morphA.set( 0, 0, 0 );\r\n\t\t\t_morphB.set( 0, 0, 0 );\r\n\t\t\t_morphC.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tconst influence = morphInfluences[ i ];\r\n\t\t\t\tconst morph = morphAttribute[ i ];\r\n\r\n\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\r\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\r\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\r\n\r\n\t\t\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\r\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\r\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\r\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\r\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_vA.add( _morphA );\r\n\t\t\t_vB.add( _morphB );\r\n\t\t\t_vC.add( _morphC );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.isSkinnedMesh ) {\r\n\r\n\t\t\tobject.applyBoneTransform( a, _vA );\r\n\t\t\tobject.applyBoneTransform( b, _vB );\r\n\t\t\tobject.applyBoneTransform( c, _vC );\r\n\r\n\t\t}\r\n\r\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\r\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\r\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\r\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\r\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\r\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\r\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\r\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\r\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\r\n\r\n\t}\r\n\r\n\tconst geometry = object.geometry;\r\n\tconst material = object.material;\r\n\r\n\tlet a, b, c;\r\n\tconst index = geometry.index;\r\n\tconst positionAttribute = geometry.attributes.position;\r\n\tconst morphPosition = geometry.morphAttributes.position;\r\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\tconst normalAttribute = geometry.attributes.normal;\r\n\tconst morphNormal = geometry.morphAttributes.position;\r\n\r\n\tconst groups = geometry.groups;\r\n\tconst drawRange = geometry.drawRange;\r\n\tlet i, j, il, jl;\r\n\tlet group;\r\n\tlet start, end;\r\n\r\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\r\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\r\n\r\n\tif ( index !== null ) {\r\n\r\n\t\t// indexed buffer geometry\r\n\r\n\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup = groups[ i ];\r\n\r\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\ta = index.getX( j );\r\n\t\t\t\t\tb = index.getX( j + 1 );\r\n\t\t\t\t\tc = index.getX( j + 2 );\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\ta = index.getX( i );\r\n\t\t\t\tb = index.getX( i + 1 );\r\n\t\t\t\tc = index.getX( i + 2 );\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\t// non-indexed buffer geometry\r\n\r\n\t\tif ( Array.isArray( material ) ) {\r\n\r\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgroup = groups[ i ];\r\n\r\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\r\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\ta = j;\r\n\t\t\t\t\tb = j + 1;\r\n\t\t\t\t\tc = j + 2;\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\t\tobject,\r\n\t\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\t\ta, b, c,\r\n\t\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstart = Math.max( 0, drawRange.start );\r\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\r\n\r\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\r\n\r\n\t\t\t\ta = i;\r\n\t\t\t\tb = i + 1;\r\n\t\t\t\tc = i + 2;\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tpositionAttribute,\r\n\t\t\t\t\tmorphPosition,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedPosition\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_calculateMorphedAttributeData(\r\n\t\t\t\t\tobject,\r\n\t\t\t\t\tnormalAttribute,\r\n\t\t\t\t\tmorphNormal,\r\n\t\t\t\t\tmorphTargetsRelative,\r\n\t\t\t\t\ta, b, c,\r\n\t\t\t\t\tmodifiedNormal\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\r\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\r\n\r\n\treturn {\r\n\r\n\t\tpositionAttribute: positionAttribute,\r\n\t\tnormalAttribute: normalAttribute,\r\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\r\n\t\tmorphedNormalAttribute: morphedNormalAttribute\r\n\r\n\t};\r\n\r\n}\r\n\r\n/**\r\n * Merges the {@link BufferGeometry#groups} for the given geometry.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to modify.\r\n * @return {BufferGeometry} - The updated geometry\r\n */\r\nfunction mergeGroups( geometry ) {\r\n\r\n\tif ( geometry.groups.length === 0 ) {\r\n\r\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.' );\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tlet groups = geometry.groups;\r\n\r\n\t// sort groups by material index\r\n\r\n\tgroups = groups.sort( ( a, b ) => {\r\n\r\n\t\tif ( a.materialIndex !== b.materialIndex ) return a.materialIndex - b.materialIndex;\r\n\r\n\t\treturn a.start - b.start;\r\n\r\n\t} );\r\n\r\n\t// create index for non-indexed geometries\r\n\r\n\tif ( geometry.getIndex() === null ) {\r\n\r\n\t\tconst positionAttribute = geometry.getAttribute( 'position' );\r\n\t\tconst indices = [];\r\n\r\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\r\n\r\n\t\t\tindices.push( i, i + 1, i + 2 );\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.setIndex( indices );\r\n\r\n\t}\r\n\r\n\t// sort index\r\n\r\n\tconst index = geometry.getIndex();\r\n\r\n\tconst newIndices = [];\r\n\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tconst groupStart = group.start;\r\n\t\tconst groupLength = groupStart + group.count;\r\n\r\n\t\tfor ( let j = groupStart; j < groupLength; j ++ ) {\r\n\r\n\t\t\tnewIndices.push( index.getX( j ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.dispose(); // Required to force buffer recreation\r\n\tgeometry.setIndex( newIndices );\r\n\r\n\t// update groups indices\r\n\r\n\tlet start = 0;\r\n\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tgroup.start = start;\r\n\t\tstart += group.count;\r\n\r\n\t}\r\n\r\n\t// merge groups\r\n\r\n\tlet currentGroup = groups[ 0 ];\r\n\r\n\tgeometry.groups = [ currentGroup ];\r\n\r\n\tfor ( let i = 1; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\r\n\t\tif ( currentGroup.materialIndex === group.materialIndex ) {\r\n\r\n\t\t\tcurrentGroup.count += group.count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentGroup = group;\r\n\t\t\tgeometry.groups.push( currentGroup );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\n/**\r\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\r\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\r\n * faces that meet at an angle greater than the crease angle.\r\n *\r\n * @param {BufferGeometry} geometry - The geometry to modify.\r\n * @param {number} [creaseAngle=Math.PI/3] - The crease angle in radians.\r\n * @return {BufferGeometry} - The updated geometry\r\n */\r\nfunction toCreasedNormals( geometry, creaseAngle = Math.PI / 3 /* 60 degrees */ ) {\r\n\r\n\tconst creaseDot = Math.cos( creaseAngle );\r\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\r\n\r\n\t// reusable vectors\r\n\tconst verts = [ new Vector3(), new Vector3(), new Vector3() ];\r\n\tconst tempVec1 = new Vector3();\r\n\tconst tempVec2 = new Vector3();\r\n\tconst tempNorm = new Vector3();\r\n\tconst tempNorm2 = new Vector3();\r\n\r\n\t// hashes a vector\r\n\tfunction hashVertex( v ) {\r\n\r\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\r\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\r\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\r\n\t\treturn `${x},${y},${z}`;\r\n\r\n\t}\r\n\r\n\t// BufferGeometry.toNonIndexed() warns if the geometry is non-indexed\r\n\t// and returns the original geometry\r\n\tconst resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\r\n\tconst posAttr = resultGeometry.attributes.position;\r\n\tconst vertexMap = {};\r\n\r\n\t// find all the normals shared by commonly located vertices\r\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\r\n\r\n\t\tconst i3 = 3 * i;\r\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\r\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\r\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\r\n\r\n\t\ttempVec1.subVectors( c, b );\r\n\t\ttempVec2.subVectors( a, b );\r\n\r\n\t\t// add the normal to the map for all vertices\r\n\t\tconst normal = new Vector3().crossVectors( tempVec1, tempVec2 ).normalize();\r\n\t\tfor ( let n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\tconst vert = verts[ n ];\r\n\t\t\tconst hash = hashVertex( vert );\r\n\t\t\tif ( ! ( hash in vertexMap ) ) {\r\n\r\n\t\t\t\tvertexMap[ hash ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvertexMap[ hash ].push( normal );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// average normals from all vertices that share a common location if they are within the\r\n\t// provided crease threshold\r\n\tconst normalArray = new Float32Array( posAttr.count * 3 );\r\n\tconst normAttr = new BufferAttribute( normalArray, 3, false );\r\n\tfor ( let i = 0, l = posAttr.count / 3; i < l; i ++ ) {\r\n\r\n\t\t// get the face normal for this vertex\r\n\t\tconst i3 = 3 * i;\r\n\t\tconst a = verts[ 0 ].fromBufferAttribute( posAttr, i3 + 0 );\r\n\t\tconst b = verts[ 1 ].fromBufferAttribute( posAttr, i3 + 1 );\r\n\t\tconst c = verts[ 2 ].fromBufferAttribute( posAttr, i3 + 2 );\r\n\r\n\t\ttempVec1.subVectors( c, b );\r\n\t\ttempVec2.subVectors( a, b );\r\n\r\n\t\ttempNorm.crossVectors( tempVec1, tempVec2 ).normalize();\r\n\r\n\t\t// average all normals that meet the threshold and set the normal value\r\n\t\tfor ( let n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\tconst vert = verts[ n ];\r\n\t\t\tconst hash = hashVertex( vert );\r\n\t\t\tconst otherNormals = vertexMap[ hash ];\r\n\t\t\ttempNorm2.set( 0, 0, 0 );\r\n\r\n\t\t\tfor ( let k = 0, lk = otherNormals.length; k < lk; k ++ ) {\r\n\r\n\t\t\t\tconst otherNorm = otherNormals[ k ];\r\n\t\t\t\tif ( tempNorm.dot( otherNorm ) > creaseDot ) {\r\n\r\n\t\t\t\t\ttempNorm2.add( otherNorm );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttempNorm2.normalize();\r\n\t\t\tnormAttr.setXYZ( i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tresultGeometry.setAttribute( 'normal', normAttr );\r\n\treturn resultGeometry;\r\n\r\n}\r\n\r\nexport {\r\n\tcomputeMikkTSpaceTangents,\r\n\tmergeGeometries,\r\n\tmergeAttributes,\r\n\tdeepCloneAttribute,\r\n\tdeinterleaveAttribute,\r\n\tdeinterleaveGeometry,\r\n\tinterleaveAttributes,\r\n\testimateBytesUsed,\r\n\tmergeVertices,\r\n\ttoTrianglesDrawMode,\r\n\tcomputeMorphedAttributes,\r\n\tmergeGroups,\r\n\ttoCreasedNormals\r\n};\r\n",
        "fileName": "BufferGeometryUtils"
      },
      "Entity": {
        "fileName": "Entity",
        "script": "class Entity {\r\n    constructor(game, type) {\r\n        this.game = game;\r\n        this.children = [];        \r\n        this.components = [];\r\n        this.renderers = [];\r\n        this.destroyed = false;        \r\n        this.id = -1;\r\n        this.type = type;\r\n        this.collisionRadius = 5;   \r\n        this.entityHeight = 10;        \r\n    }\r\n\r\n    init(params) {\r\n        for(let c in this.components) {\r\n            this.components[c].init(params);               \r\n        }     \r\n    }\r\n    getAABB(position = this.transform.position) {\r\n        return {\r\n            min: {\r\n                x: position.x - this.collisionRadius,\r\n                y: position.y,\r\n                z: position.z - this.collisionRadius\r\n            },\r\n            max: {\r\n                x: position.x + this.collisionRadius,\r\n                y: position.y + this.entityHeight,\r\n                z: position.z + this.collisionRadius\r\n            }\r\n        };\r\n    }\r\n\r\n    getComponent(name) {\r\n        return this.components[name.toLowerCase()] || this.components[`${name.toLowerCase()}`];\r\n    }\r\n    addRenderer(RendererClassName, params) {\r\n        const RendererClass = this.game.moduleManager.getCompiledScript(RendererClassName, 'renderers');\r\n        const renderer = new RendererClass(this.game, this);\r\n        this.renderers[RendererClass.name.toLowerCase()] = renderer;\r\n        this.components[RendererClass.name.toLowerCase()] = renderer;\r\n        if(params){\r\n            renderer.init(params);\r\n        }\r\n        return renderer;\r\n    }\r\n    addComponent(ComponentClassName, params) {        \r\n        const ComponentClass = this.game.moduleManager.getCompiledScript(ComponentClassName, 'components');\r\n        const component = new ComponentClass(this.game, this);\r\n        this.components[ComponentClass.name.toLowerCase()] = component;\r\n        if(params){\r\n            component.init(params);\r\n        }\r\n        return component;\r\n    }\r\n    getNetworkComponentData(){\r\n        let data = {};\r\n        for(let c in this.components) {\r\n            let cData = this.components[c].getNetworkData(); \r\n            if(cData){\r\n                data[c] = cData;\r\n            }\r\n        }    \r\n        return data;\r\n    }\r\n    setNetworkComponentData(data, isRemote=false){            \r\n        if(data?.components){\r\n            for(let c in data.components) {\r\n                this.components[c]?.setNetworkData(data.components[c], isRemote); \r\n            }    \r\n        }\r\n    }\r\n    removeComponent(component) {\r\n        let index = this.components.indexOf(component);\r\n        if( index >= 0 ) {\r\n            this.components.splice(index, 1);\r\n        }\r\n    }\r\n    update() {    \r\n        for(let c in this.components) {\r\n            this.components[c].update(); \r\n            if(this.destroyed) break;\r\n        }                \r\n    }\r\n    postUpdate() {\r\n        for(let c in this.components) {\r\n            this.components[c].postUpdate();   \r\n            if(this.destroyed) break;\r\n        }     \r\n    }\r\n    draw() {\r\n        for(let r in this.renderers) {\r\n            this.renderers[r].draw();  \r\n        }\r\n\r\n    }\r\n    OnCollision(collidedWith){\r\n        for(let c in this.components) {\r\n            this.components[c].OnCollision(collidedWith);                           \r\n        }                \r\n    }\r\n    OnStaticCollision(){\r\n        for(let c in this.components) {\r\n            this.components[c].OnStaticCollision();                           \r\n        }                \r\n    }\r\n    OnGrounded(){\r\n        for(let c in this.components) {\r\n            this.components[c].OnGrounded();                           \r\n        }                \r\n    }\r\n    onPhysicsUpdate(timestamp, physicsStepMs)  {\r\n        for(let c in this.components) {\r\n            this.components[c].onPhysicsUpdate(timestamp, physicsStepMs);                           \r\n        }     \r\n    }\r\n    addChild(entity){\r\n        this.children.push(entity);\r\n        entity.parent = this;\r\n        return entity;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.children.forEach((c) => {\r\n            if(!c.destroyed){\r\n                c.destroy();\r\n            }\r\n        });\r\n        for(let c in this.components) {\r\n            this.components[c].destroy();   \r\n        }   \r\n        for(let r in this.renderers) {\r\n            this.renderers[r].destroy();   \r\n        }   \r\n    }\r\n}",
        "filePath": "/global/libraries/js/Entity.js"
      },
      "GraphicsEditor": {
        "fileName": "GraphicsEditor",
        "title": "GraphicsEditor",
        "script": "/**\r\n * @class GraphicsEditor\r\n * @description Manages 3D graphics editing functionality including shapes, animations, and UI\r\n */\r\nclass GraphicsEditor {\r\n    /**\r\n     * @param {Object} gameEditor - Main game editor instance\r\n     * @param {Object} config - Editor configuration\r\n     * @param {Object} managers - Required manager instances\r\n     * @param {Function} managers.ShapeFactory - Factory for creating shapes\r\n     * @param {Function} managers.GE_SceneRenderer - Handles scene rendering\r\n     * @param {Function} managers.GE_ShapeManager - Manages shape operations\r\n     * @param {Function} managers.GE_AnimationManager - Handles animations\r\n     * @param {Function} managers.GE_RotationUtils - Rotation utility functions\r\n     * @param {Function} managers.GE_UIManager - Manages UI interactions\r\n     * @param {Function} managers.GE_GroupManager - Handles shape grouping\r\n     * @param {Function} managers.GE_GizmoManager - Manages transformation gizmos\r\n     */\r\n    constructor(gameEditor, config, {}) {\r\n        this.gameEditor = gameEditor;\r\n        this.config = config;\r\n        this.shapeFactory = new GUTS.ShapeFactory(this.gameEditor.getResourcesPath(), this.gameEditor.getPalette(), this.gameEditor.getCollections().textures, null);\r\n        if(location.hostname.indexOf('github') >= 0) {\r\n            this.shapeFactory.setURLRoot(\"/GUTS/\");\r\n        }\r\n        this.canvas = document.getElementById('graphics-editor-canvas');\r\n        // Initialize sub-modules\r\n        this.sceneRenderer = new GUTS.GE_SceneRenderer(gameEditor, this);\r\n        this.shapeManager = new GUTS.GE_ShapeManager(gameEditor, this);\r\n        this.uiManager = new GUTS.GE_UIManager(gameEditor, this);\r\n        this.animationManager = new GUTS.GE_AnimationManager(gameEditor, this);\r\n        this.groupManager = new GUTS.GE_GroupManager(gameEditor, this);\r\n        this.gizmoManager = new GUTS.GE_GizmoManager(gameEditor, this);\r\n        this.equipmentEditor = new GUTS.GE_EquipmentEditor(gameEditor, this);\r\n        this.rotationUtils = GUTS.GE_RotationUtils;\r\n        // State management (simplified)\r\n        this.state = {\r\n            editingModel: true,\r\n            selectedShapeIndex: -1,\r\n            currentAnimation: \"\",\r\n            selectedGroup: \"main\",\r\n            currentFrame: 0,\r\n            renderData: { model: {}, animations: { idle: [{ main: { shapes: [], position: {x: 0, y: 0, z: 0}, rotation: {x:0,y:0,z:0}, scale: {x:1, y:1, z:1}} }] } }\r\n        };\r\n        \r\n        this.rootGroup = new window.THREE.Group(); // Main container for all shapes\r\n        this.rootGroup.name = \"rootGroup\";\r\n        this.init();\r\n    }\r\n    /**\r\n     * Initializes all manager components\r\n     * @private\r\n     */\r\n    init() {\r\n        this.sceneRenderer.init();\r\n        this.uiManager.init();\r\n        this.shapeManager.init();\r\n        this.animationManager.init();\r\n        this.groupManager.init();\r\n        this.gizmoManager.init();\r\n        this.equipmentEditor.init();\r\n        this.sceneRenderer.animate();    \r\n    }\r\n\r\n    /**\r\n     * Displays isometric sprite previews\r\n     * @param {Array<Object>} sprites - Array of sprite data\r\n     */\r\n    displayIsometricSprites(sprites){\r\n        this.uiManager.displayIsometricSprites(sprites);\r\n    }\r\n\r\n    /**\r\n     * Renders all shapes in the scene\r\n     * @param {boolean} [fireSave=true] - Whether to trigger a save after rendering\r\n     * @returns {Promise<void>}\r\n     */\r\n    async renderShapes(fireSave = true) {\r\n        // Store equipment models before clearing scene\r\n        const equipmentModels = new Map();\r\n        if (this.equipmentEditor.equipmentModels.size > 0) {\r\n            this.equipmentEditor.equipmentModels.forEach((data, index) => {\r\n                // Temporarily detach equipment from bones to preserve them\r\n                if (data.model.parent) {\r\n                    data.model.parent.remove(data.model);\r\n                }\r\n                equipmentModels.set(index, data);\r\n            });\r\n        }\r\n\r\n        await this.clearScene();\r\n        await this.setupLights();\r\n        \r\n        if (!this.validateCurrentFrame()) {\r\n            return;\r\n        }\r\n        \r\n        await this.renderGroups();\r\n        \r\n        // Re-attach equipment after character model is loaded\r\n        if (equipmentModels.size > 0) {\r\n            // Wait a bit for bones to be properly set up\r\n            setTimeout(() => {\r\n                this.equipmentEditor.findCharacterBones();\r\n                equipmentModels.forEach((data, index) => {\r\n                    const bone = this.equipmentEditor.findAttachmentBone(data.equipment);\r\n                    if (bone) {\r\n                        bone.add(data.model);\r\n                        data.bone = bone;\r\n                        this.equipmentEditor.equipmentModels.set(index, data);\r\n                        console.log(`Re-attached equipment ${data.equipment.item} to bone ${bone.name}`);\r\n                    } else {\r\n                        // Fallback to root group\r\n                        this.rootGroup.add(data.model);\r\n                        data.bone = null;\r\n                        this.equipmentEditor.equipmentModels.set(index, data);\r\n                        console.warn(`Could not find bone for equipment ${data.equipment.item}, added to root`);\r\n                    }\r\n                });\r\n                \r\n                // Emit scene updated event\r\n                document.body.dispatchEvent(new CustomEvent('sceneUpdated'));\r\n            }, 100);\r\n        }\r\n        \r\n        await this.updateUI(fireSave);\r\n        await this.updateSelection();\r\n    }\r\n\r\n    // Also add this helper method to GraphicsEditor\r\n    /**\r\n     * Get all bones in the current character model\r\n     */\r\n    getAllBones() {\r\n        const bones = new Map();\r\n        \r\n        this.rootGroup.traverse(object => {\r\n            if (object.isBone) {\r\n                bones.set(object.name, object);\r\n            }\r\n            \r\n            // Check for GLTF bones\r\n            if (object.userData && object.userData.isGLTFRoot && object.userData.skeleton) {\r\n                const skeleton = object.userData.skeleton;\r\n                skeleton.bones.forEach(bone => {\r\n                    bones.set(bone.name, bone);\r\n                });\r\n            }\r\n        });\r\n        \r\n        return bones;\r\n    }\r\n\r\n    /**\r\n     * Clears all objects from the scene\r\n     * @private\r\n     * @returns {Promise<void>}\r\n     */    \r\n    async clearScene() {\r\n        while (this.rootGroup.children.length > 0) {\r\n            const obj = this.rootGroup.children[0];\r\n            this.shapeFactory.disposeObject(obj);\r\n            this.shapeManager.originalMaterials.delete(obj);\r\n            this.rootGroup.remove(obj);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets up scene lighting\r\n     * @private\r\n     * @returns {Promise<void>}\r\n     */    \r\n    async setupLights() {\r\n        if (this.sceneRenderer.scene.getObjectByName('ambient-light')) {\r\n            return;\r\n        }\r\n    \r\n        const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.6);\r\n        ambientLight.name = 'ambient-light';\r\n        this.sceneRenderer.scene.add(ambientLight);\r\n    \r\n        const directionalLight = new window.THREE.DirectionalLight(0xffffff, 0.8);\r\n        directionalLight.position.set(5, 10, 7.5);\r\n        directionalLight.name = 'dir-light';\r\n        this.sceneRenderer.scene.add(directionalLight);\r\n    }    \r\n\r\n    /**\r\n     * Validates the current animation frame\r\n     * @private\r\n     * @returns {boolean} - Whether the current frame is valid\r\n     */\r\n    validateCurrentFrame() {\r\n        if (!this.state.editingModel && !this.getCurrentFrame()) {\r\n            console.warn(\r\n                \"Animation or frame doesn't exist:\", \r\n                this.state.currentAnimation, \r\n                this.state.currentFrame\r\n            );\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Renders all shapes in the scene\r\n     * @param {boolean} [fireSave=true] - Whether to trigger a save after rendering\r\n     * @returns {Promise<void>}\r\n     */\r\n    async renderGroups() {\r\n        const model = this.state.renderData.model;\r\n        for (const groupName in model) {     \r\n            const mergedGroup = this.getMergedGroup(groupName);\r\n            if (mergedGroup) {\r\n                let threeGroup = await this.shapeFactory.createGroupFromJSON(groupName, mergedGroup); \r\n    \r\n                threeGroup.name = groupName;\r\n                this.rootGroup.add(threeGroup);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Renders all shapes in the scene\r\n     * @param {boolean} [fireSave=true] - Whether to trigger a save after rendering\r\n     * @returns {Promise<void>}\r\n     */\r\n    async updateUI(fireSave) {\r\n        this.updateShapeCount();\r\n        await this.handleSave(fireSave);\r\n    }\r\n\r\n    /**\r\n     * Updates the shape count display in the UI\r\n     * @private\r\n     */\r\n    updateShapeCount() {\r\n        const model = this.state.renderData.model;\r\n        const totalShapes = Object.values(model).reduce((total, group) => {\r\n            return total + (Array.isArray(group.shapes) ? group.shapes.length : 0);\r\n        }, 0);\r\n        document.getElementById('shape-count').textContent = totalShapes;\r\n    }\r\n    \r\n    /**\r\n     * Handles saving the current state\r\n     * @param {boolean} fireSave - Whether to trigger a save event\r\n     * @returns {Promise<void>}\r\n     */\r\n    async handleSave(fireSave) {\r\n        if (fireSave) {\r\n            const saveEvent = new CustomEvent('saveGraphicsObject', {\r\n                detail: { \r\n                    data: this.state.renderData, \r\n                    propertyName: 'render' \r\n                },\r\n                bubbles: true,\r\n                cancelable: true\r\n            });\r\n            document.body.dispatchEvent(saveEvent);\r\n        } else {\r\n            const valueElement = this.gameEditor.elements.editor\r\n                .querySelector('#render-value');\r\n            if (valueElement) {\r\n                let renderDataCopy = JSON.parse(JSON.stringify(this.state.renderData));\r\n                Object.keys(renderDataCopy.animations).forEach(animationName => {\r\n                    const animation = renderDataCopy.animations[animationName];\r\n                    animation.forEach(frame => {\r\n                        Object.keys(frame).forEach(groupName => {\r\n                            const group = frame[groupName];\r\n                            if (group && group.shapes) {\r\n                                // Filter shapes with more than just ID\r\n                                group.shapes = group.shapes.filter(shape => \r\n                                    Object.keys(shape).length > 1\r\n                                );\r\n                                \r\n                                // Remove empty shapes array\r\n                                if (group.shapes.length === 0) {\r\n                                    delete group.shapes;\r\n                                }\r\n                \r\n                                // Remove empty group\r\n                                if (Object.keys(group).length === 0) {\r\n                                    delete frame[groupName];\r\n                                }\r\n                            }\r\n                        });               \r\n                    });\r\n                });\r\n                valueElement.value = JSON.stringify(renderDataCopy);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the selection highlight and gizmo positions\r\n     * @returns {Promise<void>}\r\n     */\r\n    async updateSelection() {\r\n        this.gizmoManager.updateGizmoPosition();\r\n    }\r\n\r\n    /**\r\n     * Gets the current animation data\r\n     * @returns {Object|null} Current animation or null if none exists\r\n     */\r\n    getCurrentAnimation() {\r\n     \r\n        return this.state.renderData.animations[this.state.currentAnimation] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame data\r\n     * @returns {Object|null} Current frame data or model data if in editing mode\r\n     */\r\n    getCurrentFrame() {\r\n        if(this.state.editingModel){\r\n            return this.state.renderData.model;\r\n        } else {\r\n            let currentAnimation = this.getCurrentAnimation();\r\n            return currentAnimation ? currentAnimation[this.state.currentFrame] : null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current group data\r\n     * @returns {Object|null} Current group data or null if none exists\r\n     */\r\n    getCurrentGroup() {\r\n        let currentFrame = this.getCurrentFrame();\r\n        return currentFrame ? currentFrame[this.state.currentGroup] : null;\r\n    }\r\n\r\n    /**\r\n     * Refreshes the shape list and renders the scene\r\n     * @param {boolean} param - Whether to trigger a save after refresh\r\n     */\r\n    refreshShapes(param) {\r\n        this.uiManager.updateList();\r\n        this.renderShapes(param);\r\n    }\r\n\r\n    /**\r\n     * Creates an inspector panel for the given shape\r\n     * @param {Object} shape - Shape to create inspector for\r\n     */\r\n    createInspector(shape) {\r\n        this.uiManager.createInspector(shape);\r\n    }\r\n\r\n    /**\r\n     * Sets the animation preview state\r\n     * @param {Object} state - New animation state\r\n     * @returns {Promise<void>}\r\n     */\r\n    setPreviewAnimationState(state) {\r\n        return this.animationManager.setPreviewAnimationState(state);\r\n    }\r\n\r\n    /**\r\n     * Selects a shape by index\r\n     * @param {number} index - Index of shape to select\r\n     * @returns {Promise<void>}\r\n     */\r\n    selectShape(index) {\r\n        return this.shapeManager.selectShape(index);\r\n    }\r\n\r\n    /**\r\n     * Gets a merged group by name\r\n     * @param {string} groupName - Name of group to get\r\n     * @returns {Object|null} Merged group data or null\r\n     */\r\n    getMergedGroup(groupName){\r\n        let model = this.state.renderData.model;\r\n        const modelGroup = model[groupName];\r\n        if(this.state.editingModel){\r\n            return modelGroup;\r\n        }\r\n        return this.shapeFactory.getMergedGroup(model, this.getCurrentAnimation()[this.state.currentFrame], groupName );\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame's shape data\r\n     * @returns {Object|null} Shape data or null if not found\r\n     */\r\n    getFrameShape() {\r\n        // If we're in model editing mode, return merged shape\r\n        if (this.state.editingModel) {\r\n            return this.getMergedShape();\r\n        }\r\n    \r\n        // Return null if no shape is selected\r\n        if (this.state.selectedShapeIndex < 0) {\r\n            return null;\r\n        }\r\n    \r\n        // Get or create group data\r\n        let groupData = this.getCurrentGroup() || \r\n            JSON.parse(JSON.stringify(this.state.renderData.model[this.state.currentGroup]));\r\n    \r\n        if (!groupData?.shapes) {\r\n            return null;\r\n        }\r\n    \r\n        // Find existing shape or create new one\r\n        let shape = groupData.shapes.find(s => s.id === this.state.selectedShapeIndex);\r\n        if (shape) {\r\n            return shape;\r\n        }\r\n    \r\n        // Create new shape if not found\r\n        return this.createBlankFrameShape();\r\n    }\r\n\r\n    /**\r\n     * Creates a new blank frame shape\r\n     * @private\r\n     * @returns {Object|null} New shape or null if frame doesn't exist\r\n     */\r\n    createBlankFrameShape() {\r\n        const shape = { id: this.state.selectedShapeIndex };\r\n        const currentFrame = this.getCurrentFrame();\r\n        \r\n        if (!currentFrame) {\r\n            return null;\r\n        }\r\n    \r\n        // Add shape to current group or create new group\r\n        if (!currentFrame[this.state.currentGroup]) {\r\n            currentFrame[this.state.currentGroup] = { shapes: [] };\r\n        }\r\n        \r\n        currentFrame[this.state.currentGroup].shapes.push(shape);\r\n        return shape;\r\n    }\r\n    /**\r\n     * Gets the currently selected shape merged with its group\r\n     * @returns {Object|null} - Merged shape or null if not found\r\n     */\r\n    getMergedShape() {\r\n        if (this.state.selectedShapeIndex < 0) {\r\n            return null;\r\n        }\r\n    \r\n        const selectedGroup = this.getMergedGroup(this.state.currentGroup);\r\n        const shapes = selectedGroup?.shapes || [];\r\n        const shape = shapes[this.state.selectedShapeIndex];\r\n    \r\n        if (!shape) {\r\n            return null;\r\n        }\r\n    \r\n        if (this.state.editingModel) {\r\n            return shape;\r\n        }\r\n    \r\n        return this.mergeShapeWithCurrentGroup(shape);\r\n    }\r\n    /**\r\n     * Merges a shape with its current group\r\n     * @param {Object} shape - Shape to merge\r\n     * @returns {Object} - Merged shape\r\n     */\r\n    mergeShapeWithCurrentGroup(shape) {\r\n        // Set shape ID\r\n        shape.id = this.state.selectedShapeIndex;\r\n    \r\n        // Get or create current group data\r\n        const currentGroupData = this.getCurrentGroup() || { shapes: [] };\r\n        if (!Array.isArray(currentGroupData.shapes)) {\r\n            currentGroupData.shapes = [];\r\n        }\r\n    \r\n        // Update shape in current group\r\n        this.updateShapeInGroup(shape, currentGroupData);\r\n    \r\n        // Update animation data\r\n        this.updateAnimationData(currentGroupData);\r\n    \r\n        return shape;\r\n    }\r\n    /**\r\n     * Updates a shape within its group\r\n     * @param {Object} shape - Shape to update\r\n     * @param {Object} groupData - Group containing the shape\r\n     */\r\n    updateShapeInGroup(shape, groupData) {\r\n        const shapeIndex = groupData.shapes.findIndex(s => s.id === shape.id);\r\n        \r\n        if (shapeIndex >= 0) {\r\n            groupData.shapes[shapeIndex] = shape; // Replace existing\r\n        } else {\r\n            groupData.shapes.push(shape); // Add new\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Updates animation data for the current group\r\n     * @param {Object} groupData - Group data to update\r\n     */\r\n    updateAnimationData(groupData) {\r\n        const path = [\r\n            this.state.currentAnimation,\r\n            this.state.currentFrame,\r\n            this.state.currentGroup\r\n        ];\r\n    \r\n        // Update nested property safely\r\n        let current = this.state.renderData.animations;\r\n        path.forEach((key, index) => {\r\n            if (index === path.length - 1) {\r\n                current[key] = groupData;\r\n            } else {\r\n                current = current[key];\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Gets the currently selected object from the scene\r\n     * @returns {THREE.Object3D} - Selected object or root group\r\n     */\r\n    getSelectedObject() {\r\n        const currentGroup = this.state.currentGroup;\r\n        \r\n        if (!currentGroup) {\r\n            return this.rootGroup;\r\n        }\r\n    \r\n        const foundGroup = this.findGroupByName(currentGroup);\r\n        if (!foundGroup) {\r\n            return this.rootGroup;\r\n        }\r\n    \r\n        const foundShape = this.findShapeInGroup(foundGroup);\r\n        return foundShape || foundGroup || this.rootGroup;\r\n    }\r\n        /**\r\n     * Finds a group by name in the scene\r\n     * @param {string} groupName - Name of the group to find\r\n     * @returns {THREE.Group|null} - Found group or null\r\n     */\r\n    findGroupByName(groupName) {\r\n        let found = null;\r\n        this.rootGroup.traverse(obj => {\r\n            if (obj.isGroup && obj.name === groupName && obj.userData.isGroup) {\r\n                found = obj;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n        /**\r\n     * Finds a shape within a group\r\n     * @param {THREE.Group} group - Group to search in\r\n     * @returns {THREE.Object3D|null} - Found shape or null\r\n     */\r\n    findShapeInGroup(group) {\r\n        let found = null;\r\n        group.traverse(obj => {\r\n            if (obj.userData.isShape && obj.userData.index === this.state.selectedShapeIndex) {\r\n                found = obj;\r\n            }\r\n        });\r\n        return found;\r\n    }\r\n}\r\n",
        "filePath": "/global/libraries/js/GraphicsEditor.js"
      },
      "GE_RotationUtils": {
        "title": "GE_RotationUtils",
        "fileName": "GE_RotationUtils",
        "script": "// RotationUtils.js\r\nclass GE_RotationUtils {\r\n    /**\r\n     * Convert degrees to radians\r\n     * @param {number} degrees - Angle in degrees\r\n     * @return {number} Angle in radians\r\n     */\r\n    static degToRad(degrees) {\r\n        return degrees * Math.PI / 180;\r\n    }\r\n    \r\n    /**\r\n     * Convert radians to degrees\r\n     * @param {number} radians - Angle in radians\r\n     * @return {number} Angle in degrees (rounded)\r\n     */\r\n    static radToDeg(radians) {\r\n        return Math.round(radians * 180 / Math.PI);\r\n    }\r\n    \r\n    /**\r\n     * Apply rotation to a position vector around a center point\r\n     * @param {Object} position - Position with x, y, z properties\r\n     * @param {Object} center - Center point with x, y, z properties\r\n     * @param {Object} rotation - Rotation with x, y, z properties in radians\r\n     * @return {Object} New position after rotation\r\n     */\r\n    static rotatePosition(position, center, rotation) {\r\n        const pos = new window.THREE.Vector3(\r\n            position.x || 0,\r\n            position.y || 0,\r\n            position.z || 0\r\n        );\r\n        \r\n        const centerVec = new window.THREE.Vector3(\r\n            center.x || 0,\r\n            center.y || 0,\r\n            center.z || 0\r\n        );\r\n        \r\n        // Create rotation matrix\r\n        const rotMatrix = new window.THREE.Matrix4();\r\n        rotMatrix.makeRotationFromEuler(new window.THREE.Euler(\r\n            rotation.x || 0,\r\n            rotation.y || 0,\r\n            rotation.z || 0\r\n        ));\r\n        \r\n        // Apply rotation\r\n        pos.sub(centerVec);\r\n        pos.applyMatrix4(rotMatrix);\r\n        pos.add(centerVec);\r\n        \r\n        return { x: pos.x, y: pos.y, z: pos.z };\r\n    }\r\n    \r\n    /**\r\n     * Combine two rotations (in Euler angles)\r\n     * @param {Object} rotation1 - First rotation with x, y, z in degrees\r\n     * @param {Object} rotation2 - Second rotation with x, y, z in degrees\r\n     * @return {Object} Combined rotation in degrees\r\n     */\r\n    static combineRotations(rotation1, rotation2) {\r\n        // Convert to radians\r\n        const rot1 = {\r\n            x: this.degToRad(rotation1.x || 0),\r\n            y: this.degToRad(rotation1.y || 0),\r\n            z: this.degToRad(rotation1.z || 0)\r\n        };\r\n        \r\n        const rot2 = {\r\n            x: this.degToRad(rotation2.x || 0),\r\n            y: this.degToRad(rotation2.y || 0),\r\n            z: this.degToRad(rotation2.z || 0)\r\n        };\r\n        \r\n        // Convert to quaternions and multiply\r\n        const quat1 = new window.THREE.Quaternion().setFromEuler(\r\n            new window.THREE.Euler(rot1.x, rot1.y, rot1.z)\r\n        );\r\n        \r\n        const quat2 = new window.THREE.Quaternion().setFromEuler(\r\n            new window.THREE.Euler(rot2.x, rot2.y, rot2.z)\r\n        );\r\n        \r\n        quat1.multiply(quat2);\r\n        \r\n        // Convert back to euler angles\r\n        const euler = new window.THREE.Euler().setFromQuaternion(quat1);\r\n        \r\n        // Return in degrees\r\n        return {\r\n            x: this.radToDeg(euler.x),\r\n            y: this.radToDeg(euler.y),\r\n            z: this.radToDeg(euler.z)\r\n        };\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GE_RotationUtils.js"
      },
      "ScriptEditor": {
        "fileName": "ScriptEditor",
        "script": "class ScriptEditor {\r\n    constructor(gameEditor, config) {\r\n      \r\n        this.gameEditor = gameEditor;\r\n        this.config = config;\r\n        let theme = \"\";\r\n        if( this.gameEditor.getCollections().configs.codeMirror ) {\r\n            theme = this.gameEditor.getCollections().themes[this.gameEditor.getCollections().configs.codeMirror.theme].css;\r\n            if( theme ) { \r\n              let styleTag = document.createElement('style');\r\n              styleTag.innerHTML = theme;\r\n              styleTag.setAttribute('id', 'codeMirrorTheme');\r\n              document.head.append(styleTag);\r\n            }\r\n        }\r\n        this.container = document.getElementById('script-editor-container'); \r\n        this.MIN_HEIGHT = 200;\r\n        this.isDragging = false;\r\n        this.start_y = 0;\r\n        this.start_h = 0;\r\n        this.DEFAULT_HEIGHT = () => document.body.clientHeight - 200;\r\n\t\t\t\tthis.savePropertyName = \"script\";\r\n        if (!this.container) {\r\n            console.error(\"ScriptEditor container not found\");\r\n            return;\r\n        }\r\n\r\n        const textArea = this.container.querySelector('#script-editor');\r\n        if (!textArea) {\r\n            console.error(\"Textarea #script-editor not found\");\r\n            return;\r\n        }\r\n\r\n        this.scriptEditor = CodeMirror.fromTextArea(textArea, {\r\n            mode: 'javascript',\r\n            lineNumbers: true,\r\n            tabSize: 2,\r\n            indentWithTabs: false,\r\n            extraKeys: { 'Ctrl-Space': 'autocomplete' },\r\n            hintOptions: { completeSingle: false }\r\n        });\r\n\r\n        this.scriptEditor.setSize(null, this.DEFAULT_HEIGHT());\r\n\r\n        this.setupEventListeners();\r\n        \r\n        \r\n    }\r\n   \r\n    setupEventListeners() {\r\n     \r\n        document.body.addEventListener('editScript', (event) => {\r\n            this.scriptValue = event.detail.data;\r\n            this.savePropertyName = event.detail.propertyName;\r\n            this.scriptEditor.setValue(this.scriptValue);\r\n            this.scriptEditor.setSize(null, this.DEFAULT_HEIGHT());\r\n            this.scriptEditor.refresh();\r\n            setTimeout(() => {\r\n                this.scriptEditor.refresh();\r\n            }, 100);\r\n        });\r\n        \r\n        const saveBtn = this.container.querySelector('#save-script-btn');\r\n        if (saveBtn) {\r\n            saveBtn.addEventListener('click', () => this.saveScript());\r\n        } else {\r\n            console.warn(\"Save button not found\");\r\n        }\r\n    }\r\n\r\n    saveScript() {\r\n\r\n        if (!this.gameEditor.getCurrentObject()) {\r\n            console.warn(\"No selected object to save script to\");\r\n            return;\r\n        }\r\n        const scriptText = this.scriptEditor.getValue();\r\n   \r\n        const myCustomEvent = new CustomEvent('saveScript', {\r\n            detail: { data: scriptText, propertyName: this.savePropertyName }, \r\n            bubbles: true, \r\n            cancelable: true \r\n        });\r\n\r\n      \r\n        document.body.dispatchEvent(myCustomEvent);\r\n    }\r\n\r\n    destroy() {\r\n        if (this.container && this.container.parentNode) {\r\n            this.container.parentNode.removeChild(this.container);\r\n        }\r\n    }\r\n}\r\n",
        "filePath": "/global/libraries/js/ScriptEditor.js"
      },
      "TerrainMapEditor": {
        "fileName": "TerrainMapEditor",
        "script": "class TerrainMapEditor {\r\n    constructor(gameEditor, config = {}, { TileMap, TerrainImageProcessor, CoordinateTranslator, ImageManager, ShapeFactory }) {\r\n        this.gameEditor = gameEditor;\r\n        this.engineClasses = { TileMap, TerrainImageProcessor, CoordinateTranslator, ImageManager, ShapeFactory };\r\n        this.defaultConfig = { gridSize: 48, imageSize: 128, canvasWidth: 1536, canvasHeight: 768 };\r\n        this.config = { ...this.defaultConfig, ...config };\r\n    \r\n        this.defaultMapSize = 16;\r\n        this.mapSize = this.defaultMapSize;\r\n        this.currentTerrainId = 3; // Default to grass (index 3)\r\n        this.currentHeightLevel = 0; // Default to height level 0\r\n        this.isMouseDown = false;\r\n        this.objectData = {};\r\n\r\n        // Performance optimization: track last painted tile and debounce operations\r\n        this.lastPaintedTile = null;\r\n        this.needsRender = false;\r\n        this.exportDebounceTimer = null;\r\n        this.renderAnimationFrame = null;\r\n        this.previewAnimationFrame = null;\r\n        this.pendingPreviewEvent = null;\r\n        this.isInitializing = false;\r\n        // Terrain map structure without explicit IDs\r\n        this.tileMap = {\r\n            size: 16,\r\n            terrainBGColor: \"#7aad7b\",\r\n            terrainTypes: [\r\n                { type: \"start\", color: \"#ffff00\", image: [] },\r\n                { type: \"end\", color: \"#ff0000\", image: [] },\r\n                { type: \"path\", color: \"#eeae9e\", image: [] },\r\n                { type: \"grass\", color: \"#7aad7b\", image: [] },\r\n                { type: \"water\", color: \"#64b5f6\", image: [] },\r\n                { type: \"rock\", color: \"#9e9e9e\", image: [] }\r\n            ],\r\n            terrainMap: [],\r\n            heightMap: [],  // Height levels independent of terrain types\r\n            extensionHeight: 0  // Height for extension area\r\n        };\r\n        this.environmentObjects = this.tileMap.environmentObjects || [];\r\n        this.selectedEnvironmentType = null;\r\n        this.selectedEnvironmentItem = null;\r\n        this.placementMode = 'terrain'; // can be 'terrain', 'environment', 'ramp', or 'height'\r\n        this.terrainTool = 'brush'; // can be 'brush' or 'fill'\r\n        this.brushSize = 1; // Default brush size (1x1)\r\n        this.worldObjects = [];\r\n        this.terrainTypesContainer = null;\r\n        this.draggedItem = null;\r\n        this.dragOverItem = null; // Track the item being dragged over\r\n\r\n        // DOM elements\r\n        this.canvasEl = document.getElementById('grid');\r\n        this.canvasEl.width = this.config.canvasWidth;\r\n        this.canvasEl.height = this.config.canvasHeight;\r\n\r\n        // Clear any inline styles to ensure CSS controls the display size\r\n        this.canvasEl.style.width = '';\r\n        this.canvasEl.style.height = '';\r\n\r\n        // Preview elements for cursor\r\n        this.previewCanvas = null;\r\n        this.currentPreviewImage = null;\r\n        this.hoverGridPosition = null; // Track mouse position for brush preview\r\n\r\n        // Managers and renderers\r\n        let palette = this.gameEditor.getPalette();\r\n        this.imageManager = new this.engineClasses.ImageManager(this.gameEditor,  { imageSize: this.config.imageSize, palette: palette}, {ShapeFactory: ShapeFactory});\r\n        this.mapRenderer = null;\r\n        this.mapManager = null;\r\n\r\n        this.translator = new this.engineClasses.CoordinateTranslator(this.config, this.tileMap.size, this.gameEditor.getCollections().configs.game.isIsometric);\r\n        this.terrainCanvasBuffer = document.createElement('canvas');\r\n        this.terrainCanvasBuffer.width = this.tileMap.size * this.gameEditor.getCollections().configs.game.gridSize;\r\n        this.terrainCanvasBuffer.height =  this.tileMap.size * this.gameEditor.getCollections().configs.game.gridSize;\r\n\r\n        console.log(this.tileMap.size, this.terrainCanvasBuffer.width, this.terrainCanvasBuffer.height);\r\n        this.modalId = 'modal-addTerrainType';\r\n        // Bind methods to maintain correct context\r\n        this.init();\r\n    }\r\n\r\n    init() {\r\n        this.setupTerrainTypesUI();\r\n        this.setupTerrainImageProcessor();\r\n        this.setupEnvironmentPanel();\r\n        this.createPreviewCanvas();\r\n        this.setupEventListeners();\r\n        this.updateTerrainStyles();\r\n    }\r\n\r\n    setupEventListeners() {\r\n\r\n        document.getElementById('terrainColor').addEventListener('change', (el) => {                    \r\n            document.getElementById('terrainColorText').value = el.target.value;\r\n        });\r\n        document.getElementById('terrainTexture').addEventListener('change', (ev) => {\r\n            const textureName = ev.target.value;\r\n            if (textureName) {\r\n                this.tileMap.terrainTypes[this.currentTerrainId].texture = textureName;\r\n                this.terrainImageProcessor.processImage(this.gameEditor.getCollections().textures[textureName].image);\r\n            }\r\n        });\r\n        document.getElementById('terrainMapSize').addEventListener('change', async (ev) => {    \r\n            const newGridSize = parseInt(ev.target.value);\r\n            const oldGridSize = this.tileMap.size;\r\n            \r\n            // Create a new map to hold the resized terrain\r\n            const newTerrainMap = [];\r\n            \r\n            // Default terrain for new tiles (grass = index 3, or extension terrain type)\r\n            const defaultTerrainId = this.tileMap.extensionTerrainType || 3;\r\n            \r\n            // Initialize with default terrain\r\n            for (let i = 0; i < newGridSize; i++) {\r\n                newTerrainMap.push(new Array(newGridSize).fill(defaultTerrainId));\r\n            }\r\n            \r\n            // Copy existing terrain data if it exists\r\n            if (this.tileMap.terrainMap && this.tileMap.terrainMap.length > 0) {\r\n                // Simple approach: copy from top-left, expanding to the right and down\r\n                for (let y = 0; y < Math.min(oldGridSize, newGridSize); y++) {\r\n                    for (let x = 0; x < Math.min(oldGridSize, newGridSize); x++) {\r\n                        if (this.tileMap.terrainMap[y] && this.tileMap.terrainMap[y][x] !== undefined) {\r\n                            newTerrainMap[y][x] = this.tileMap.terrainMap[y][x];\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Update tileMap with new terrain\r\n            this.tileMap.terrainMap = newTerrainMap;\r\n            this.tileMap.size = newGridSize;\r\n            this.mapSize = newGridSize;\r\n            this.translator = new this.engineClasses.CoordinateTranslator(this.config, newGridSize, this.gameEditor.getCollections().configs.game.isIsometric);\r\n            \r\n            // Resize canvas to fit new map size\r\n            this.updateCanvasSize();\r\n            \r\n            this.updateTerrainStyles();\r\n            this.setupTerrainTypesUI();\r\n            await this.initGridCanvas();\r\n            this.exportMap();\r\n        });\r\n        document.getElementById('extensionTerrainType').addEventListener('change', (ev) => {    \r\n            const newTerrainType = parseInt(ev.target.value);            \r\n            this.tileMap.extensionTerrainType = newTerrainType;\r\n            this.initGridCanvas();\r\n            this.exportMap();\r\n        });\r\n        \r\n        // Save button - manual save only\r\n        document.getElementById('saveMapBtn').addEventListener('click', () => {\r\n            this.exportMap();\r\n            // Show feedback\r\n            const btn = document.getElementById('saveMapBtn');\r\n            const originalText = btn.textContent;\r\n            btn.textContent = ' Saved!';\r\n            btn.style.backgroundColor = '#10b981';\r\n            setTimeout(() => {\r\n                btn.textContent = originalText;\r\n                btn.style.backgroundColor = 'var(--secondary)';\r\n            }, 1500);\r\n        });\r\n       \r\n        // Handle mouseup event (stop dragging)\r\n        document.addEventListener('mouseup', () => {\r\n            this.isMouseDown = false;\r\n            this.lastPaintedTile = null; // Reset for next paint operation\r\n            \r\n            // Ensure final render happens (no auto-save)\r\n            if (this.needsRender) {\r\n                this.updateCanvasWithData();\r\n                this.needsRender = false;\r\n            }\r\n        });\r\n\r\n        // Add mouse down event for canvas\r\n        this.canvasEl.addEventListener('mousedown', (e) => {\r\n            if (e.button === 0) { // Left click\r\n                if (this.deleteMode && this.tileMap.environmentObjects) {\r\n                    this.deleteEnvironmentObjectAt(e);\r\n                } else {\r\n                    this.isMouseDown = true;\r\n                    this.handleCanvasInteraction(e);\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Add mouse move event for drawing while dragging\r\n        this.canvasEl.addEventListener('mousemove', (e) => {\r\n            // Throttle preview position updates using requestAnimationFrame\r\n            this.pendingPreviewEvent = e;\r\n            if (!this.previewAnimationFrame) {\r\n                this.previewAnimationFrame = requestAnimationFrame(() => {\r\n                    this.updatePreviewPosition(this.pendingPreviewEvent);\r\n                    this.updateBrushPreview(this.pendingPreviewEvent);\r\n                    this.previewAnimationFrame = null;\r\n                });\r\n            }\r\n\r\n            if (this.isMouseDown) {\r\n                this.handleCanvasInteraction(e);\r\n            }\r\n        });\r\n\r\n        // Add mouse leave event to clear brush preview\r\n        this.canvasEl.addEventListener('mouseleave', () => {\r\n            this.hoverGridPosition = null;\r\n            if (this.placementMode === 'terrain' || this.placementMode === 'height') {\r\n                this.needsRender = true;\r\n                this.scheduleRender();\r\n            }\r\n        });\r\n\r\n        // Handle editTileMap event\r\n        document.body.addEventListener('editTileMap', async (event) => {\r\n            this.config = event.detail.config;\r\n            this.tileMap = event.detail.data;\r\n            this.objectData = event.detail.objectData;\r\n            this.savePropertyName = event.detail.propertyName;\r\n            const world = this.objectData.world ? this.gameEditor.getCollections().worlds[this.objectData.world] : null;\r\n            this.worldObjects = {};\r\n            if(world){\r\n                const worldObjectNames = world.worldObjects || [];\r\n                worldObjectNames.forEach((objectName) => {\r\n                    this.worldObjects[objectName] = this.gameEditor.getCollections().worldObjects[objectName];\r\n                });\r\n            }\r\n            this.canvasEl.width = this.config.canvasWidth;\r\n            this.canvasEl.height = this.config.canvasHeight;\r\n\r\n            // Clear any inline styles to ensure CSS controls the display size\r\n            this.canvasEl.style.width = '';\r\n            this.canvasEl.style.height = '';\r\n\r\n            //this.gameEditor.setColorValue(document.getElementById('terrainBGColorContainer'), this.tileMap.terrainBGColor || \"#7aad7b\");\r\n            if(this.tileMap.extensionTerrainType){\r\n                this.canvasEl.backgroundColor = this.tileMap.terrainTypes[this.tileMap.extensionTerrainType].color;\r\n            } else {\r\n                this.canvasEl.backgroundColor = this.tileMap.terrainTypes[4].color;\r\n                this.tileMap.extensionTerrainType = 4; // Default to grass if not set\r\n            }\r\n\r\n            if (!this.tileMap.environmentObjects) {\r\n                this.tileMap.environmentObjects = [];\r\n            }\r\n\r\n            // Load or initialize heightMap from objectData\r\n            if (this.objectData.heightMap) {\r\n                this.tileMap.heightMap = this.objectData.heightMap;\r\n                this.tileMap.extensionHeight = this.objectData.extensionHeight || 0;\r\n            } else if (!this.tileMap.heightMap) {\r\n                // Initialize heightMap if it doesn't exist\r\n                this.tileMap.heightMap = [];\r\n                this.tileMap.extensionHeight = this.tileMap.extensionTerrainType || 0;\r\n            }\r\n            const extensionTerrainTypeSelector = document.getElementById('extensionTerrainType');\r\n            // Strip id from terrainTypes if present, assume order is correct\r\n            this.tileMap.terrainTypes.forEach((terrain, index) => {\r\n                const newOption = document.createElement('option');\r\n                newOption.value = index;\r\n                newOption.textContent = terrain.type;\r\n                if (index === this.tileMap.extensionTerrainType) {\r\n                    newOption.selected = true;\r\n                }\r\n                extensionTerrainTypeSelector.appendChild(newOption);\r\n            });\r\n        \r\n            // No need to remap terrainMap; assume it already uses indices matching the order\r\n            // If terrainMap has invalid indices, clamp them to valid range\r\n            if (this.tileMap.terrainMap && this.tileMap.terrainMap.length > 0) {\r\n                const maxIndex = this.tileMap.terrainTypes.length - 1;\r\n                for (let y = 0; y < this.tileMap.terrainMap.length; y++) {\r\n                    for (let x = 0; x < this.tileMap.terrainMap[y].length; x++) {\r\n                        const currentValue = this.tileMap.terrainMap[y][x];\r\n                        if (currentValue > maxIndex || currentValue < 0) {\r\n                            this.tileMap.terrainMap[y][x] = 0; // Clamp invalid values to 0\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Update grid size from tilemap data\r\n            if (this.tileMap.size) {\r\n                this.mapSize = this.tileMap.size;\r\n            } else {\r\n                this.mapSize = this.defaultMapSize;\r\n            }\r\n\r\n            // Initialize heightMap data if empty\r\n            if (!this.tileMap.heightMap || this.tileMap.heightMap.length === 0) {\r\n                this.tileMap.heightMap = [];\r\n                for (let y = 0; y < this.mapSize; y++) {\r\n                    this.tileMap.heightMap[y] = [];\r\n                    for (let x = 0; x < this.mapSize; x++) {\r\n                        // Default to deriving height from terrain type (backwards compatibility)\r\n                        if (this.tileMap.terrainMap && this.tileMap.terrainMap[y] && this.tileMap.terrainMap[y][x] !== undefined) {\r\n                            this.tileMap.heightMap[y][x] = this.tileMap.terrainMap[y][x];\r\n                        } else {\r\n                            this.tileMap.heightMap[y][x] = 0;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Always recreate translator with current map size\r\n            this.translator = new this.engineClasses.CoordinateTranslator(this.config, this.mapSize, this.gameEditor.getCollections().configs.game.isIsometric);\r\n\r\n            document.getElementById('terrainMapSize').value = this.mapSize;\r\n            \r\n            // Resize canvas to fit map size\r\n            this.updateCanvasSize();\r\n            \r\n            // Load terrain types if provided\r\n            this.updateTerrainStyles();\r\n            this.setupTerrainTypesUI();\r\n            \r\n            // Wait for next frame to ensure DOM is updated, then initialize\r\n            await new Promise(resolve => requestAnimationFrame(resolve));\r\n            await this.initGridCanvas();\r\n        });\r\n\r\n        document.getElementById('terrainsBtn').addEventListener('click', () => {\r\n            document.getElementById('terrainsBtn').classList.add('active');\r\n            document.getElementById('heightsBtn').classList.remove('active');\r\n            document.getElementById('environmentBtn').classList.remove('active');\r\n            document.getElementById('rampsBtn').classList.remove('active');\r\n\r\n            document.getElementById('terrainsPanel').style.display = 'block';\r\n            document.getElementById('heightsPanel').style.display = 'none';\r\n            document.getElementById('environmentPanel').style.display = 'none';\r\n            document.getElementById('rampsPanel').style.display = 'none';\r\n            this.placementMode = 'terrain';\r\n            this.previewCanvas.style.display = 'none';\r\n\r\n            // Trigger re-render to hide height overlay\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n\r\n            // Update placement indicator\r\n            this.placementModeIndicator.textContent = 'Placement Mode: Terrain';\r\n            this.placementModeIndicator.style.opacity = '1';\r\n\r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 2000);\r\n        });\r\n\r\n        document.getElementById('heightsBtn').addEventListener('click', () => {\r\n            document.getElementById('terrainsBtn').classList.remove('active');\r\n            document.getElementById('heightsBtn').classList.add('active');\r\n            document.getElementById('environmentBtn').classList.remove('active');\r\n            document.getElementById('rampsBtn').classList.remove('active');\r\n\r\n            document.getElementById('terrainsPanel').style.display = 'none';\r\n            document.getElementById('heightsPanel').style.display = 'block';\r\n            document.getElementById('environmentPanel').style.display = 'none';\r\n            document.getElementById('rampsPanel').style.display = 'none';\r\n            this.placementMode = 'height';\r\n            this.previewCanvas.style.display = 'none';\r\n\r\n            // Setup height levels UI\r\n            this.setupHeightLevelsUI();\r\n\r\n            // Trigger re-render to show height overlay\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n\r\n            this.placementModeIndicator.textContent = 'Placement Mode: Heights';\r\n            this.placementModeIndicator.style.opacity = '1';\r\n\r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 2000);\r\n        });\r\n\r\n        document.getElementById('environmentBtn').addEventListener('click', () => {\r\n            document.getElementById('terrainsBtn').classList.remove('active');\r\n            document.getElementById('heightsBtn').classList.remove('active');\r\n            document.getElementById('environmentBtn').classList.add('active');\r\n            document.getElementById('rampsBtn').classList.remove('active');\r\n            document.getElementById('terrainsPanel').style.display = 'none';\r\n            document.getElementById('heightsPanel').style.display = 'none';\r\n            document.getElementById('environmentPanel').style.display = 'block';\r\n            document.getElementById('rampsPanel').style.display = 'none';\r\n            this.placementMode = 'environment';\r\n\r\n            // Make sure environment panel is set up\r\n            this.setupEnvironmentPanel();\r\n\r\n            // Trigger re-render to hide height overlay\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n\r\n            this.placementModeIndicator.textContent = 'Placement Mode: Environment';\r\n            this.placementModeIndicator.style.opacity = '1';\r\n\r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 2000);\r\n        });\r\n\r\n        document.getElementById('rampsBtn').addEventListener('click', () => {\r\n            document.getElementById('terrainsBtn').classList.remove('active');\r\n            document.getElementById('heightsBtn').classList.remove('active');\r\n            document.getElementById('environmentBtn').classList.remove('active');\r\n            document.getElementById('rampsBtn').classList.add('active');\r\n            document.getElementById('terrainsPanel').style.display = 'none';\r\n            document.getElementById('heightsPanel').style.display = 'none';\r\n            document.getElementById('environmentPanel').style.display = 'none';\r\n            document.getElementById('rampsPanel').style.display = 'block';\r\n            this.placementMode = 'ramp';\r\n            this.previewCanvas.style.display = 'none';\r\n\r\n            // Update ramp count display\r\n            this.updateRampCount();\r\n\r\n            // Trigger re-render to show height overlay\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n\r\n            this.placementModeIndicator.textContent = 'Placement Mode: Ramps';\r\n            this.placementModeIndicator.style.opacity = '1';\r\n\r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 2000);\r\n        });\r\n\r\n        // Clear all ramps button\r\n        document.getElementById('clear-all-ramps-btn').addEventListener('click', () => {\r\n            if (this.tileMap.ramps) {\r\n                this.tileMap.ramps = [];\r\n                this.updateRampCount();\r\n                this.needsRender = true;\r\n                this.scheduleRender();\r\n            }\r\n        });\r\n\r\n        // Height level input\r\n        document.getElementById('heightLevel').addEventListener('change', (e) => {\r\n            this.currentHeightLevel = parseInt(e.target.value);\r\n            this.placementModeIndicator.textContent = `Painting Height Level: ${this.currentHeightLevel}`;\r\n            this.placementModeIndicator.style.opacity = '1';\r\n\r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 2000);\r\n        });\r\n\r\n        // Terrain tool buttons\r\n        document.getElementById('terrainBrushBtn').addEventListener('click', () => {\r\n            this.terrainTool = 'brush';\r\n            document.getElementById('terrainBrushBtn').classList.add('editor-module__btn--active');\r\n            document.getElementById('terrainFillBtn').classList.remove('editor-module__btn--active');\r\n            document.getElementById('terrainBrushSizeRow').style.display = 'flex';\r\n        });\r\n\r\n        document.getElementById('terrainFillBtn').addEventListener('click', () => {\r\n            this.terrainTool = 'fill';\r\n            document.getElementById('terrainFillBtn').classList.add('editor-module__btn--active');\r\n            document.getElementById('terrainBrushBtn').classList.remove('editor-module__btn--active');\r\n            document.getElementById('terrainBrushSizeRow').style.display = 'none';\r\n        });\r\n\r\n        // Terrain brush size\r\n        document.getElementById('terrainBrushSize').addEventListener('input', (e) => {\r\n            this.brushSize = parseInt(e.target.value);\r\n            document.getElementById('terrainBrushSizeValue').textContent = this.brushSize;\r\n        });\r\n\r\n        // Height tool buttons\r\n        document.getElementById('heightBrushBtn').addEventListener('click', () => {\r\n            this.terrainTool = 'brush';\r\n            document.getElementById('heightBrushBtn').classList.add('editor-module__btn--active');\r\n            document.getElementById('heightFillBtn').classList.remove('editor-module__btn--active');\r\n            document.getElementById('heightBrushSizeRow').style.display = 'flex';\r\n        });\r\n\r\n        document.getElementById('heightFillBtn').addEventListener('click', () => {\r\n            this.terrainTool = 'fill';\r\n            document.getElementById('heightFillBtn').classList.add('editor-module__btn--active');\r\n            document.getElementById('heightBrushBtn').classList.remove('editor-module__btn--active');\r\n            document.getElementById('heightBrushSizeRow').style.display = 'none';\r\n        });\r\n\r\n        // Height brush size\r\n        document.getElementById('heightBrushSize').addEventListener('input', (e) => {\r\n            this.brushSize = parseInt(e.target.value);\r\n            document.getElementById('heightBrushSizeValue').textContent = this.brushSize;\r\n        });\r\n\r\n        this.canvasEl.addEventListener('contextmenu', (e) => {\r\n            e.preventDefault(); // Prevent default context menu\r\n\r\n            if (this.placementMode === 'environment' && this.tileMap.environmentObjects) {\r\n                this.deleteEnvironmentObjectAt(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    async initImageManager() {\r\n        let palette = this.gameEditor.getPalette();\r\n        this.imageManager = new this.engineClasses.ImageManager(this.gameEditor, { imageSize: this.config.imageSize, palette: palette}, {ShapeFactory: this.engineClasses.ShapeFactory});\r\n        await this.imageManager.loadImages(\"levels\", { level: this.objectData }, false, false);\r\n        if(this.worldObjects){\r\n            await this.imageManager.loadImages(\"environment\", this.worldObjects, false, false);\r\n        }\r\n        const terrainImages = this.imageManager.getImages(\"levels\", \"level\");\r\n\r\n        this.terrainTileMapper = this.gameEditor.editorModuleInstances.TileMap;\r\n        if(!this.terrainCanvasBuffer) {\r\n            this.terrainCanvasBuffer = document.createElement('canvas');\r\n        }\r\n        this.terrainCanvasBuffer.width = this.tileMap.size * this.gameEditor.getCollections().configs.game.gridSize;\r\n        this.terrainCanvasBuffer.height =  this.tileMap.size * this.gameEditor.getCollections().configs.game.gridSize;\r\n        if(!this.gameEditor.modelManager.assetsLoaded){\r\n            let collections = this.gameEditor.getCollections();\r\n            for(let objectType in collections) {            \r\n                await this.gameEditor.modelManager.loadModels(objectType, collections[objectType]);\r\n            }  \r\n        } \r\n        this.terrainTileMapper.init(this.terrainCanvasBuffer, this.gameEditor.getCollections().configs.game.gridSize, terrainImages, this.gameEditor.getCollections().configs.game.isIsometric);\r\n        \r\n        // Ensure translator is up to date before creating game object\r\n        this.translator = new this.engineClasses.CoordinateTranslator(this.config, this.tileMap.size, this.gameEditor.getCollections().configs.game.isIsometric);\r\n        \r\n        this.game = { \r\n            state: {}, \r\n            modelManager: this.gameEditor.modelManager, \r\n            imageManager: this.imageManager, \r\n            canvasBuffer: this.canvasEl, \r\n            terrainCanvasBuffer: this.terrainCanvasBuffer, \r\n            terrainTileMapper: this.terrainTileMapper, \r\n            getCollections: this.gameEditor.getCollections.bind(this.gameEditor), \r\n            translator: this.translator\r\n        };\r\n\r\n        this.mapRenderer = new (this.gameEditor.scriptContext.getRenderer(\"MapRenderer\"))(this.game, null);\r\n        this.mapRenderer.init({ \r\n                environment: this.worldObjects, \r\n                level: 'level', \r\n                levelData: this.objectData,\r\n                isEditor: true,\r\n                palette: palette,\r\n                canvas: this.canvasEl\r\n            });\r\n            \r\n        // Give the renderer a moment to fully initialize\r\n        await new Promise(resolve => setTimeout(resolve, 50));\r\n    }\r\n    updatePreviewImage() {\r\n        if (!this.selectedEnvironmentType || this.selectedEnvironmentItem === null) {\r\n            this.currentPreviewImage = null;\r\n            return;\r\n        }\r\n        \r\n        const images = this.imageManager.getImages(\"environment\", this.selectedEnvironmentType);\r\n        if (!images || !images.idle || !images.idle[0] || !images.idle[0][this.selectedEnvironmentItem]) {\r\n            this.currentPreviewImage = null;\r\n            return;\r\n        }\r\n        \r\n        const image = images.idle[0][this.selectedEnvironmentItem];\r\n        this.currentPreviewImage = image;\r\n        \r\n        // Resize preview canvas if needed\r\n        const maxDimension = Math.max(image.width, image.height);\r\n        const scale = this.config.imageSize / maxDimension;\r\n        \r\n        this.previewCanvas.width = image.width * scale;\r\n        this.previewCanvas.height = image.height * scale;\r\n        \r\n        const ctx = this.previewCanvas.getContext('2d');\r\n        ctx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);\r\n        ctx.drawImage(image, 0, 0, this.previewCanvas.width, this.previewCanvas.height);\r\n    }\r\n    updatePreviewPosition(e) {\r\n        if (this.placementMode !== 'environment' ||\r\n            !this.selectedEnvironmentType ||\r\n            this.selectedEnvironmentItem === null ||\r\n            this.deleteMode ||\r\n            !this.currentPreviewImage) {\r\n            this.previewCanvas.style.display = 'none';\r\n            return;\r\n        }\r\n\r\n        // Get mouse position relative to canvas\r\n        const rect = this.canvasEl.getBoundingClientRect();\r\n        // Account for CSS scaling of the canvas\r\n        const scaleX = this.canvasEl.width / rect.width;\r\n        const scaleY = this.canvasEl.height / rect.height;\r\n        let mouseX = (e.clientX - rect.left) * scaleX;\r\n        const mouseY = (e.clientY - rect.top) * scaleY;\r\n\r\n        if (!this.gameEditor.getCollections().configs.game.isIsometric) {\r\n            mouseX -= (this.canvasEl.width - this.mapSize * this.config.gridSize) / 2;\r\n        }\r\n\r\n        // For isometric view, we need to convert cursor position to actual object position\r\n        let posX, posY;\r\n        if (this.gameEditor.getCollections().configs.game.isIsometric) {\r\n            const isoPos = { x: mouseX, y: mouseY };\r\n            const pixelPos = this.translator.isoToPixel(isoPos.x, isoPos.y);\r\n\r\n            // Convert back to screen coordinates\r\n            const screenPos = this.translator.pixelToIso(pixelPos.x, pixelPos.y);\r\n            posX = screenPos.x + rect.left;\r\n            posY = screenPos.y + rect.top;\r\n        } else {\r\n            // For non-isometric, just use the mouse position\r\n            posX = e.clientX;\r\n            posY = e.clientY;\r\n        }\r\n        posX = e.clientX + window.scrollX;\r\n        posY = e.clientY + window.scrollY;\r\n        // Center the preview on the cursor\r\n        this.previewCanvas.style.transform = `translate(${posX - this.previewCanvas.width / 2}px, ${posY - this.previewCanvas.height / 2}px)`;\r\n        this.previewCanvas.style.display = 'block';\r\n    }\r\n\r\n    updateBrushPreview(e) {\r\n        // Only show preview in terrain or height mode\r\n        if (this.placementMode !== 'terrain' && this.placementMode !== 'height') {\r\n            if (this.hoverGridPosition !== null) {\r\n                this.hoverGridPosition = null;\r\n                this.needsRender = true;\r\n                this.scheduleRender();\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Get mouse position relative to canvas\r\n        const rect = this.canvasEl.getBoundingClientRect();\r\n        const scaleX = this.canvasEl.width / rect.width;\r\n        const scaleY = this.canvasEl.height / rect.height;\r\n        let mouseX = (e.clientX - rect.left) * scaleX;\r\n        let mouseY = (e.clientY - rect.top) * scaleY;\r\n\r\n        if (!this.gameEditor.getCollections().configs.game.isIsometric) {\r\n            mouseX -= (this.canvasEl.width - this.mapSize * this.config.gridSize) / 2;\r\n            mouseY -= (this.canvasEl.height - this.mapSize * this.config.gridSize) / 2;\r\n        }\r\n\r\n        // Convert to grid coordinates\r\n        const gridPos = this.translator.isoToGrid(mouseX, mouseY);\r\n        const snappedGrid = this.translator.snapToGrid(gridPos.x, gridPos.y);\r\n\r\n        // Update hover position if it changed\r\n        if (!this.hoverGridPosition ||\r\n            this.hoverGridPosition.x !== snappedGrid.x ||\r\n            this.hoverGridPosition.y !== snappedGrid.y) {\r\n            this.hoverGridPosition = { x: snappedGrid.x, y: snappedGrid.y };\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n        }\r\n    }\r\n    setupTerrainImageProcessor() {\r\n        this.terrainImageProcessor = new this.engineClasses.TerrainImageProcessor();\r\n        this.terrainImageProcessor.initialize(\r\n            document.getElementById('terrainImage'),\r\n            document.getElementById('terrain-image-display')\r\n        );\r\n    }\r\n\r\n    setupTerrainTypesUI() {\r\n        const terrainsPanel = document.getElementById('terrainsPanel');\r\n        const existingColorPicker = terrainsPanel.querySelector('.terrain-types-container');\r\n        if (existingColorPicker) {\r\n            terrainsPanel.removeChild(existingColorPicker);\r\n        }\r\n    \r\n        this.terrainTypesContainer = document.createElement('div');\r\n        this.terrainTypesContainer.className = 'terrain-types-container';\r\n        const addNewBtn = document.createElement('button');\r\n        addNewBtn.className = 'add-terrain-btn';\r\n        addNewBtn.innerHTML = '+ Add Layer';\r\n        addNewBtn.addEventListener('click', this.showAddTerrainForm.bind(this));\r\n        this.terrainTypesContainer.appendChild(addNewBtn);\r\n        this.tileMap.terrainTypes.forEach((terrain, index) => {\r\n            const terrainItem = document.createElement('div');\r\n            terrainItem.className = 'terrain-editor__terrain-item';\r\n            terrainItem.draggable = true;\r\n            terrainItem.dataset.index = index;\r\n    \r\n            terrainItem.addEventListener('dragstart', this.handleDragStart.bind(this));\r\n            terrainItem.addEventListener('dragover', this.handleDragOver.bind(this));\r\n            terrainItem.addEventListener('drop', this.handleDrop.bind(this));\r\n            terrainItem.addEventListener('dragend', this.handleDragEnd.bind(this));\r\n            terrainItem.addEventListener('dragenter', this.handleDragEnter.bind(this));\r\n            terrainItem.addEventListener('dragleave', this.handleDragLeave.bind(this));\r\n    \r\n            const option = document.createElement('div');\r\n            option.className = 'terrain-editor__color-option';\r\n            option.dataset.index = index;\r\n            option.dataset.type = terrain.type;\r\n            option.style.backgroundColor = terrain.color;\r\n    \r\n            if (index === this.currentTerrainId) {\r\n                option.classList.add('active');\r\n            }\r\n    \r\n            option.addEventListener('click', () => {\r\n                document.querySelectorAll('.terrain-editor__color-option').forEach(opt => opt.classList.remove('active'));\r\n                option.classList.add('active');\r\n                this.currentTerrainId = parseInt(option.dataset.index);\r\n            });\r\n    \r\n            const label = document.createElement('div');\r\n            label.className = 'terrain-label';\r\n            label.textContent = terrain.type;\r\n    \r\n            const buttonContainer = document.createElement('div');\r\n            buttonContainer.className = 'terrain-buttons';\r\n    \r\n            const editBtn = document.createElement('button');\r\n            editBtn.className = 'edit-terrain-btn';\r\n            editBtn.innerHTML = '';\r\n            editBtn.title = 'Edit terrain';\r\n            editBtn.addEventListener('click', () => this.showTerrainEditForm(index));\r\n            buttonContainer.appendChild(editBtn);\r\n    \r\n            const deleteBtn = document.createElement('button');\r\n            deleteBtn.className = 'delete-terrain-btn';\r\n            deleteBtn.innerHTML = '';\r\n            deleteBtn.title = 'Delete terrain';\r\n            deleteBtn.addEventListener('click', () => this.deleteTerrain(index));\r\n            buttonContainer.appendChild(deleteBtn);\r\n    \r\n            terrainItem.appendChild(option);\r\n            terrainItem.appendChild(label);\r\n            terrainItem.appendChild(buttonContainer);\r\n    \r\n            this.terrainTypesContainer.appendChild(terrainItem);\r\n        });\r\n    \r\n\r\n    \r\n        terrainsPanel.appendChild(this.terrainTypesContainer);\r\n    \r\n        document.getElementById('saveTerrainBtn').addEventListener('click', this.saveTerrainType.bind(this));\r\n        document.getElementById('cancelTerrainBtn').addEventListener('click', this.hideTerrainForm.bind(this));\r\n    }\r\n    \r\n    createPreviewCanvas() {\r\n        if (this.previewCanvas) {\r\n            document.body.removeChild(this.previewCanvas);\r\n        }\r\n        \r\n        this.previewCanvas = document.createElement('canvas');\r\n        this.previewCanvas.id = 'object-preview-canvas';\r\n        this.previewCanvas.width = this.config.imageSize;\r\n        this.previewCanvas.height = this.config.imageSize;\r\n        this.previewCanvas.style.display = 'none'; // Hidden by default\r\n        \r\n        document.body.prepend(this.previewCanvas);\r\n\r\n    }\r\n\r\n    setupEnvironmentPanel() {\r\n        const environmentPanel = document.getElementById('environmentPanel');\r\n        if (!environmentPanel) {\r\n            // Create the panel if it doesn't exist\r\n            const panel = document.createElement('div');\r\n            panel.id = 'environmentPanel';\r\n            panel.style.display = 'none'; // Hidden by default\r\n            document.querySelector('.editor-module__scroll-y').appendChild(panel);\r\n        } else {\r\n            // Clear existing content\r\n            environmentPanel.innerHTML = '';\r\n        }\r\n    \r\n        // Create object controls\r\n        const controlsDiv = document.createElement('div');\r\n        controlsDiv.className = 'object-controls';\r\n        \r\n        const deleteButton = document.createElement('button');\r\n        deleteButton.className = 'delete-btn';\r\n        deleteButton.innerHTML = '<svg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2\"/><path d=\"M10 11v6M14 11v6\"/></svg> Delete Mode';\r\n        deleteButton.addEventListener('click', () => {\r\n            deleteButton.classList.toggle('delete-mode');\r\n            document.body.classList.toggle('delete-mode-active');\r\n            this.deleteMode = deleteButton.classList.contains('delete-mode');\r\n            if (this.deleteMode) {\r\n                this.previewCanvas.style.display = 'none';\r\n            } else if (this.placementMode === 'environment' && \r\n                      this.selectedEnvironmentType && \r\n                      this.selectedEnvironmentItem !== null) {\r\n                this.updatePreviewImage();\r\n            }\r\n        });\r\n        \r\n        const clearButton = document.createElement('button');\r\n        clearButton.className = 'clear-all-btn';\r\n        clearButton.innerHTML = 'Clear All Objects';\r\n        clearButton.addEventListener('click', () => {\r\n            if (confirm('Are you sure you want to remove all environment objects?')) {\r\n                this.tileMap.environmentObjects = [];\r\n                this.updateCanvasWithData();\r\n                this.exportMap();\r\n                this.updateObjectCounts();\r\n            }\r\n        });\r\n        \r\n        controlsDiv.appendChild(deleteButton);\r\n        controlsDiv.appendChild(clearButton);\r\n        environmentPanel.appendChild(controlsDiv);\r\n        \r\n        // Create placement mode indicator (hidden by default)\r\n        const indicator = document.createElement('div');\r\n        indicator.className = 'placement-mode-indicator';\r\n        indicator.style.opacity = '0';\r\n        indicator.textContent = 'Placement Mode: Terrain';\r\n        document.querySelector('.editor-module__canvas-area').appendChild(indicator);\r\n        this.placementModeIndicator = indicator;\r\n    \r\n        // Create environment object selector\r\n        if (this.worldObjects) {\r\n            const container = document.createElement('div');\r\n            container.className = 'terrain-editor__environment-objects-container';\r\n\r\n            // Add header\r\n            const header = document.createElement('h3');\r\n            header.textContent = 'Environment Objects';\r\n            container.appendChild(header);\r\n\r\n            // Create object type list\r\n            for (const type in this.worldObjects) {\r\n                const typeContainer = document.createElement('div');\r\n                typeContainer.className = 'terrain-editor__environment-type';\r\n                \r\n                // Count objects of this type\r\n                const objectCount = (this.tileMap.environmentObjects || [])\r\n                    .filter(obj => obj.type === type).length;\r\n                \r\n                const typeHeader = document.createElement('div');\r\n                typeHeader.className = 'terrain-editor__environment-type-header';\r\n                typeHeader.textContent = type;\r\n\r\n                // Add count badge\r\n                const countBadgeContainer = document.createElement('span');\r\n                countBadgeContainer.className = 'terrain-editor__object-count-container';\r\n                const countBadge = document.createElement('span');\r\n                countBadge.className = 'terrain-editor__object-count';\r\n                countBadge.textContent = objectCount;\r\n                countBadgeContainer.appendChild(countBadge);\r\n                typeHeader.appendChild(countBadgeContainer);\r\n\r\n                typeHeader.addEventListener('click', () => {\r\n                    const content = typeContainer.querySelector('.terrain-editor__environment-items');\r\n                    const isOpen = content.style.display !== 'none';\r\n                    content.style.display = isOpen ? 'none' : 'flex';\r\n                    typeHeader.classList.toggle('open', !isOpen);\r\n                });\r\n                typeContainer.appendChild(typeHeader);\r\n\r\n                const itemsContainer = document.createElement('div');\r\n                itemsContainer.className = 'terrain-editor__environment-items';\r\n                itemsContainer.style.display = 'none';\r\n\r\n                // Get images for this type\r\n                const images = this.imageManager.getImages(\"environment\", type);\r\n                if (images && images.idle && images.idle[0] && images.idle[0].length > 0) {\r\n                    images.idle[0].forEach((image, imageIndex) => {\r\n                        const item = document.createElement('div');\r\n                        item.className = 'terrain-editor__environment-item';\r\n                        item.dataset.name = `${type} ${imageIndex + 1}`;\r\n                        \r\n                        const preview = document.createElement('canvas');\r\n                        preview.width = this.config.imageSize;\r\n                        preview.height = this.config.imageSize;\r\n                        const ctx = preview.getContext('2d');\r\n                        \r\n                        // Draw scaled down version of the image for preview with proper centering\r\n                        const scale = Math.min(this.config.imageSize / image.width, this.config.imageSize / image.height);\r\n                        ctx.drawImage(\r\n                            image, \r\n                            (this.config.imageSize - image.width * scale) / 2, \r\n                            (this.config.imageSize - image.height * scale) / 2, \r\n                            image.width * scale, \r\n                            image.height * scale\r\n                        );\r\n                        \r\n                        item.appendChild(preview);\r\n                        \r\n                        item.addEventListener('click', () => {\r\n                            // Deselect any previously selected items\r\n                            document.querySelectorAll('.terrain-editor__environment-item').forEach(i => i.classList.remove('active'));\r\n                            \r\n                            // Select this item\r\n                            item.classList.add('active');\r\n                            this.selectedEnvironmentType = type;\r\n                            this.selectedEnvironmentItem = imageIndex;\r\n                            this.placementMode = 'environment';\r\n                              // Update preview image for cursor\r\n                            this.updatePreviewImage();\r\n                            // Update placement indicator\r\n                            this.placementModeIndicator.textContent = `Placing: ${type} ${imageIndex + 1}`;\r\n                            this.placementModeIndicator.style.opacity = '1';\r\n                            \r\n                            // Auto-disable delete mode when selecting an object\r\n                            if (this.deleteMode) {\r\n                                deleteButton.classList.remove('delete-mode');\r\n                                document.body.classList.remove('delete-mode-active');\r\n                                this.deleteMode = false;\r\n                            }\r\n                            \r\n                            // Hide indicator after a delay\r\n                            clearTimeout(this.indicatorTimeout);\r\n                            this.indicatorTimeout = setTimeout(() => {\r\n                                this.placementModeIndicator.style.opacity = '0';\r\n                            }, 2000);\r\n                        });\r\n                        \r\n                        itemsContainer.appendChild(item);\r\n                    });\r\n                } else {\r\n                    // Empty state\r\n                    itemsContainer.classList.add('empty');\r\n                    const emptyMsg = document.createElement('div');\r\n                    emptyMsg.textContent = 'No objects available for this type';\r\n                    itemsContainer.appendChild(emptyMsg);\r\n                }\r\n                \r\n                typeContainer.appendChild(itemsContainer);\r\n                container.appendChild(typeContainer);\r\n            }\r\n            \r\n            environmentPanel.appendChild(container);\r\n        } else {\r\n            const message = document.createElement('p');\r\n            message.textContent = 'No environment objects available.';\r\n            environmentPanel.appendChild(message);\r\n        }\r\n    }\r\n\r\n    setupHeightLevelsUI() {\r\n        const buttonsContainer = document.getElementById('heightLevelButtons');\r\n        if (!buttonsContainer) return;\r\n\r\n        // Clear existing buttons\r\n        buttonsContainer.innerHTML = '';\r\n\r\n        // Create height level buttons (0-10)\r\n        for (let level = 0; level <= 10; level++) {\r\n            const button = document.createElement('button');\r\n            button.className = 'editor-module__btn editor-module__btn--small terrain-editor__height-btn';\r\n            button.textContent = `Level ${level}`;\r\n            button.dataset.heightLevel = level;\r\n\r\n            // Highlight current level\r\n            if (level === this.currentHeightLevel) {\r\n                button.classList.add('active');\r\n            }\r\n\r\n            button.addEventListener('click', () => {\r\n                this.currentHeightLevel = level;\r\n                document.getElementById('heightLevel').value = level;\r\n\r\n                // Update active states\r\n                buttonsContainer.querySelectorAll('.terrain-editor__height-btn').forEach(btn => {\r\n                    btn.classList.remove('active');\r\n                });\r\n                button.classList.add('active');\r\n\r\n                // Update indicator\r\n                this.placementModeIndicator.textContent = `Painting Height Level: ${level}`;\r\n                this.placementModeIndicator.style.opacity = '1';\r\n\r\n                // Hide indicator after a delay\r\n                clearTimeout(this.indicatorTimeout);\r\n                this.indicatorTimeout = setTimeout(() => {\r\n                    this.placementModeIndicator.style.opacity = '0';\r\n                }, 2000);\r\n            });\r\n\r\n            buttonsContainer.appendChild(button);\r\n        }\r\n    }\r\n\r\n    deleteEnvironmentObjectAt(e) {\r\n        // Get mouse position and convert to game coordinates\r\n        let offsetY = (this.canvasEl.height - this.mapSize * this.config.gridSize) / 2;//48*4;\r\n        const rect = this.canvasEl.getBoundingClientRect();\r\n        // Account for CSS scaling of the canvas\r\n        const scaleX = this.canvasEl.width / rect.width;\r\n        const scaleY = this.canvasEl.height / rect.height;\r\n        let mouseX = (e.clientX - rect.left) * scaleX;\r\n        const mouseY = (e.clientY - rect.top) * scaleY - offsetY;\r\n\r\n        if(!this.gameEditor.getCollections().configs.game.isIsometric) {\r\n            mouseX -= (this.canvasEl.width - this.mapSize * this.config.gridSize) / 2;\r\n        }\r\n        \r\n        const isoPos = { x: mouseX, y: mouseY };\r\n        const pixelPos = this.translator.isoToPixel(isoPos.x, isoPos.y);\r\n        \r\n        // Find and remove any environment object near the click position\r\n        const clickRadius = 30; // Radius for detecting objects to delete (in pixels)\r\n        let deletedObject = false;\r\n        \r\n        for (let i = this.tileMap.environmentObjects.length - 1; i >= 0; i--) {\r\n            const obj = this.tileMap.environmentObjects[i];\r\n            const dx = obj.x - pixelPos.x;\r\n            const dy = obj.y - pixelPos.y;\r\n            const distance = Math.sqrt(dx * dx + dy * dy);\r\n            \r\n            if (distance < clickRadius) {\r\n                // Remove this object\r\n                const deleted = this.tileMap.environmentObjects.splice(i, 1)[0];\r\n                deletedObject = true;\r\n                \r\n                // Show feedback\r\n                this.placementModeIndicator.textContent = `Deleted: ${deleted.type}`;\r\n                this.placementModeIndicator.style.opacity = '1';\r\n                \r\n                // Hide indicator after a delay\r\n                clearTimeout(this.indicatorTimeout);\r\n                this.indicatorTimeout = setTimeout(() => {\r\n                    this.placementModeIndicator.style.opacity = '0';\r\n                }, 1500);\r\n                \r\n                // Update the map rendering\r\n                this.updateCanvasWithData();\r\n                \r\n                // Update object counts\r\n                this.updateObjectCounts();\r\n                \r\n                // Export the updated map\r\n                this.exportMap();\r\n                break; // Only remove one object at a time\r\n            }\r\n        }\r\n        \r\n        // Show feedback if no object was found to delete\r\n        if (!deletedObject && this.deleteMode) {\r\n            this.placementModeIndicator.textContent = 'No object found at this location';\r\n            this.placementModeIndicator.style.opacity = '1';\r\n            \r\n            // Hide indicator after a delay\r\n            clearTimeout(this.indicatorTimeout);\r\n            this.indicatorTimeout = setTimeout(() => {\r\n                this.placementModeIndicator.style.opacity = '0';\r\n            }, 1500);\r\n        }\r\n    }\r\n    updateObjectCounts() {\r\n        if (!document.getElementById('environmentPanel')) return;\r\n        \r\n        // Update count badges\r\n        for (const type in this.worldObjects) {\r\n            const objectCount = (this.tileMap.environmentObjects || [])\r\n                .filter(obj => obj.type === type).length;\r\n\r\n            // Find all headers first\r\n            const headers = document.querySelectorAll('.terrain-editor__environment-type-header');\r\n            // Find the specific header containing the type name\r\n            for (const header of headers) {\r\n                if (header.textContent.includes(type)) {\r\n                    // Get the count badge within this header\r\n                    const countBadge = header.querySelector('.terrain-editor__object-count');\r\n                    if (countBadge) {\r\n                        countBadge.textContent = objectCount;\r\n                    }\r\n                    break; // Found the right header, no need to continue\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Improved drag and drop handlers\r\n    handleDragStart(e) {\r\n        this.draggedItem = e.currentTarget;\r\n        e.dataTransfer.effectAllowed = 'move';\r\n        e.dataTransfer.setData('text/html', this.draggedItem.outerHTML);\r\n        this.draggedItem.classList.add('dragging');\r\n        this.draggedTerrainId = parseInt(this.draggedItem.dataset.index);\r\n    }\r\n    \r\n    async handleDrop(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        const dropTarget = e.currentTarget;\r\n        dropTarget.classList.remove('drag-over');\r\n    \r\n        if (this.draggedItem !== dropTarget && dropTarget.classList.contains('terrain-editor__terrain-item')) {\r\n            const allItems = Array.from(this.terrainTypesContainer.querySelectorAll('.terrain-editor__terrain-item'));\r\n            const draggedIndex = allItems.indexOf(this.draggedItem);\r\n            const dropIndex = allItems.indexOf(dropTarget);\r\n    \r\n            if (draggedIndex !== -1 && dropIndex !== -1) {\r\n                // Store a copy of the original terrain types for reference\r\n                const oldTerrainTypes = [...this.tileMap.terrainTypes];\r\n                \r\n                // Reorder terrain types\r\n                const draggedTerrain = this.tileMap.terrainTypes[draggedIndex];\r\n                this.tileMap.terrainTypes.splice(draggedIndex, 1);\r\n                this.tileMap.terrainTypes.splice(dropIndex, 0, draggedTerrain);\r\n    \r\n                // Create mapping between old and new indices\r\n                const indexMap = {};\r\n                oldTerrainTypes.forEach((terrain, oldIndex) => {\r\n                    const newIndex = this.tileMap.terrainTypes.findIndex(t => t.type === terrain.type);\r\n                    indexMap[oldIndex] = newIndex;\r\n                });\r\n    \r\n                // Update terrain map with new indices\r\n                if (this.tileMap.terrainMap && this.tileMap.terrainMap.length > 0) {\r\n                    const maxIndex = this.tileMap.terrainTypes.length - 1;\r\n                    for (let y = 0; y < this.tileMap.terrainMap.length; y++) {\r\n                        for (let x = 0; x < this.tileMap.terrainMap[y].length; x++) {\r\n                            const oldIndex = this.tileMap.terrainMap[y][x];\r\n                            const newIndex = indexMap[oldIndex] !== undefined ? indexMap[oldIndex] : 0;\r\n                            this.tileMap.terrainMap[y][x] = Math.min(newIndex, maxIndex);\r\n                        }\r\n                    }\r\n                }\r\n    \r\n                // Update UI order\r\n                if (draggedIndex < dropIndex) {\r\n                    dropTarget.parentNode.insertBefore(this.draggedItem, dropTarget.nextSibling);\r\n                } else {\r\n                    dropTarget.parentNode.insertBefore(this.draggedItem, dropTarget);\r\n                }\r\n    \r\n                // Update current terrain ID if needed\r\n                if (this.currentTerrainId === draggedIndex) {\r\n                    this.currentTerrainId = dropIndex;\r\n                } else if (this.currentTerrainId === dropIndex) {\r\n                    this.currentTerrainId = draggedIndex;\r\n                }\r\n    \r\n                // Force a complete refresh of the rendering pipeline\r\n                // Clear any cached images or renderers\r\n                this.terrainTileMapper = null;\r\n                this.mapRenderer = null;\r\n                this.imageManager = null;\r\n                this.updateTerrainStyles();\r\n                this.setupTerrainTypesUI();\r\n\r\n                await this.initImageManager();\r\n                this.exportMap();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    handleDragOver(e) {\r\n        e.preventDefault();\r\n        e.dataTransfer.dropEffect = 'move';\r\n        return false;\r\n    }\r\n    \r\n    // Add visual feedback when dragging over items\r\n    handleDragEnter(e) {\r\n        e.preventDefault();\r\n        // Only add highlight if dragging over another terrain item (not itself)\r\n        if (e.currentTarget !== this.draggedItem) {\r\n            e.currentTarget.classList.add('drag-over');\r\n            this.dragOverItem = e.currentTarget;\r\n        }\r\n    }\r\n    \r\n    handleDragLeave(e) {\r\n        e.preventDefault();\r\n        e.currentTarget.classList.remove('drag-over');\r\n        if (this.dragOverItem === e.currentTarget) {\r\n            this.dragOverItem = null;\r\n        }\r\n    }\r\n   \r\n    \r\n    handleDragEnd(e) {\r\n        // Clean up all drag-related classes\r\n        this.draggedItem.classList.remove('dragging');\r\n        document.querySelectorAll('.terrain-editor__terrain-item').forEach(item => {\r\n            item.classList.remove('drag-over');\r\n        });\r\n        this.draggedItem = null;\r\n        this.dragOverItem = null;\r\n    }\r\n\r\n    showAddTerrainForm() {\r\n        const form = document.getElementById(this.modalId);\r\n        form.classList.add('show');\r\n        document.getElementById('formTitle').textContent = 'Add Terrain Type';\r\n        document.getElementById('editingId').value = ''; // New form field for ID\r\n        document.getElementById('terrainType').value = '';\r\n        document.getElementById('terrainColor').value = '#cccccc';\r\n        document.getElementById('terrainColorText').value = '#cccccc';  \r\n        document.getElementById('terrainImage').value = '[]';        \r\n        document.getElementById('terrainBuildable').checked = false;         \r\n    }\r\n\r\n    showTerrainEditForm(index) {\r\n        const terrain = this.tileMap.terrainTypes[index];\r\n        this.currentTerrainId = index; // Set current terrain ID for later use\r\n        const form = document.getElementById(this.modalId);\r\n        form.classList.add('show');\r\n        document.getElementById('formTitle').textContent = 'Edit Terrain Type';\r\n        document.getElementById('terrainType').value = terrain.type;\r\n        document.getElementById('terrainColor').value = terrain.color;\r\n        document.getElementById('terrainColorText').value = terrain.color;\r\n        document.getElementById('terrainImage').value = JSON.stringify(terrain.image || []);   \r\n        document.getElementById('terrainBuildable').checked = terrain.buildable;\r\n        const terrainTextureEl = document.getElementById('terrainTexture');\r\n        terrainTextureEl.innerHTML = ''; // Clear existing options\r\n\r\n        for(let textureName in this.gameEditor.getCollections().textures){\r\n            const texture = this.gameEditor.getCollections().textures[textureName];\r\n            const option = document.createElement('option');\r\n            option.value = textureName;\r\n            option.textContent = texture.title;\r\n\r\n            if( textureName === terrain.texture) {\r\n                option.selected = true; // Set the current terrain texture as selected\r\n            }\r\n            terrainTextureEl.appendChild(option);\r\n        }\r\n        // Create a custom event with data\r\n        const myCustomEvent = new CustomEvent('editTerrainImage', {\r\n            bubbles: true,\r\n            cancelable: true\r\n        });\r\n\r\n        // Dispatch the event\r\n        document.body.dispatchEvent(myCustomEvent);\r\n    }\r\n\r\n    hideTerrainForm() {\r\n        document.getElementById(this.modalId).classList.remove('show');\r\n    }\r\n\r\n    saveTerrainType() {\r\n        const newType = document.getElementById('terrainType').value.trim();\r\n        const newColor = document.getElementById('terrainColorText').value;\r\n        const newTexture = document.getElementById('terrainTexture').value;\r\n        const newImage = JSON.parse(document.getElementById('terrainImage').value);\r\n        const newBuildable = document.getElementById('terrainBuildable').checked;\r\n    \r\n        if (!newType) {\r\n            alert('Terrain type cannot be empty');\r\n            return;\r\n        }\r\n    \r\n        if (this.currentTerrainId !== '') {\r\n            // Editing existing terrain (using index as identifier)\r\n            const index = this.currentTerrainId;\r\n            if (index >= 0 && index < this.tileMap.terrainTypes.length) {\r\n                if (this.tileMap.terrainTypes.some((t, i) => t.type === newType && i !== index)) {\r\n                    alert('A terrain type with this name already exists');\r\n                    return;\r\n                }\r\n                this.tileMap.terrainTypes[index] = { type: newType, texture: newTexture, color: newColor, image: newImage, buildable: newBuildable };\r\n            }\r\n        } else {\r\n            // Adding new terrain\r\n            if (this.tileMap.terrainTypes.some(t => t.type === newType)) {\r\n                alert('A terrain type with this name already exists');\r\n                return;\r\n            }\r\n            this.tileMap.terrainTypes.push({ type: newType, texture: newTexture, color: newColor, image: newImage, buildable: newBuildable });\r\n        }\r\n    \r\n        this.updateTerrainStyles();\r\n        this.setupTerrainTypesUI();\r\n        this.hideTerrainForm();\r\n        this.initGridCanvas();\r\n        this.exportMap();\r\n    }\r\n\r\n    deleteTerrain(indexToDelete) {\r\n        if (this.tileMap.terrainTypes.length <= 1) {\r\n            alert('Cannot delete the last terrain type');\r\n            return;\r\n        }\r\n    \r\n        const terrainToDelete = this.tileMap.terrainTypes[indexToDelete];\r\n        if (!terrainToDelete) return;\r\n    \r\n        if (!confirm(`Are you sure you want to delete the \"${terrainToDelete.type}\" terrain type? All instances will be converted to the default terrain.`)) {\r\n            return;\r\n        }\r\n    \r\n        const defaultTerrainIndex = this.tileMap.terrainTypes.findIndex(t => t.type === 'grass') || 0;\r\n    \r\n        // Remove from terrainTypes array\r\n        this.tileMap.terrainTypes.splice(indexToDelete, 1);\r\n    \r\n        // Update terrainMap - replace all instances with defaultTerrainIndex\r\n        for (let y = 0; y < this.tileMap.terrainMap.length; y++) {\r\n            for (let x = 0; x < this.tileMap.terrainMap[y].length; x++) {\r\n                if (this.tileMap.terrainMap[y][x] === indexToDelete) {\r\n                    this.tileMap.terrainMap[y][x] = defaultTerrainIndex;\r\n                } else if (this.tileMap.terrainMap[y][x] > indexToDelete) {\r\n                    this.tileMap.terrainMap[y][x]--; // Adjust indices after deleted item\r\n                }\r\n            }\r\n        }\r\n    \r\n        if (this.currentTerrainId === indexToDelete) {\r\n            this.currentTerrainId = defaultTerrainIndex;\r\n        } else if (this.currentTerrainId > indexToDelete) {\r\n            this.currentTerrainId--;\r\n        }\r\n    \r\n        this.updateTerrainStyles();\r\n        this.setupTerrainTypesUI();\r\n        this.initGridCanvas();\r\n        this.exportMap();\r\n    }\r\n\r\n\r\n    updateCanvasSize() {\r\n        const isIsometric = this.gameEditor.getCollections().configs.game.isIsometric;\r\n        const gridSize = this.config.gridSize;\r\n\r\n        if (isIsometric) {\r\n            // For isometric: width needs to accommodate the diamond shape\r\n            // Height is roughly half the width for isometric projection\r\n            const requiredWidth = (this.mapSize * gridSize) + gridSize;\r\n            const requiredHeight = (this.mapSize * gridSize * 0.5) + (gridSize * 0.5);\r\n\r\n            // Add some padding\r\n            this.config.canvasWidth = Math.max(1536, requiredWidth + 200);\r\n            this.config.canvasHeight = Math.max(768, requiredHeight + 200);\r\n        } else {\r\n            // For non-isometric: simple square grid\r\n            const requiredSize = this.mapSize * gridSize;\r\n\r\n            // Add padding for centering\r\n            this.config.canvasWidth = Math.max(1536, requiredSize + 400);\r\n            this.config.canvasHeight = Math.max(768, requiredSize + 400);\r\n        }\r\n\r\n        // Set canvas internal resolution (bitmap size)\r\n        this.canvasEl.width = this.config.canvasWidth;\r\n        this.canvasEl.height = this.config.canvasHeight;\r\n\r\n        // Clear any inline styles to ensure CSS controls the display size\r\n        this.canvasEl.style.width = '';\r\n        this.canvasEl.style.height = '';\r\n    }\r\n    updateTerrainStyles() {\r\n        let styleElem = document.getElementById('terrainStyles');\r\n        if (!styleElem) {\r\n            styleElem = document.createElement('style');\r\n            styleElem.id = 'terrainStyles';\r\n            document.head.appendChild(styleElem);\r\n        }\r\n    \r\n        let css = '';\r\n        this.tileMap.terrainTypes.forEach((terrain, index) => {\r\n            css += `#level-editor-container .terrain-editor__color-option[data-index=\"${index}\"] { background-color: ${terrain.color}; }\\n`;\r\n        });\r\n    \r\n        css += `\r\n            .terrain-editor__terrain-item.dragging { opacity: 0.4; }\r\n            .terrain-editor__terrain-item.drag-over { border: 2px dashed #666; background-color: rgba(0,0,0,0.1); }\r\n        `;\r\n    \r\n        styleElem.textContent = css;\r\n    }\r\n\r\n    async initGridCanvas() {\r\n        // Load environment images but keep fast tile rendering\r\n        this.isInitializing = true;\r\n        \r\n        try {\r\n            // Load environment images if we have environment objects\r\n            if (this.worldObjects && Object.keys(this.worldObjects).length > 0) {\r\n                let palette = this.gameEditor.getPalette();\r\n                this.imageManager = new this.engineClasses.ImageManager(\r\n                    this.gameEditor, \r\n                    { imageSize: this.config.imageSize, palette: palette}, \r\n                    {ShapeFactory: this.engineClasses.ShapeFactory}\r\n                );\r\n                await this.imageManager.loadImages(\"environment\", this.worldObjects, false, false);\r\n            }\r\n            \r\n            // Render with fast renderer\r\n            this.updateCanvasWithData();\r\n        } finally {\r\n            this.isInitializing = false;\r\n        }\r\n    }\r\n\r\n\r\n    // Performance optimization: schedule render with requestAnimationFrame\r\n    scheduleRender() {\r\n        if (this.renderAnimationFrame) {\r\n            return; // Already scheduled\r\n        }\r\n        \r\n        this.renderAnimationFrame = requestAnimationFrame(() => {\r\n            this.renderAnimationFrame = null;\r\n            if (this.needsRender) {\r\n                this.updateCanvasWithData(); // Now synchronous and fast\r\n                this.needsRender = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    // Performance optimization: debounce export to reduce save frequency\r\n    debouncedExport() {\r\n        if (this.exportDebounceTimer) {\r\n            clearTimeout(this.exportDebounceTimer);\r\n        }\r\n        \r\n        this.exportDebounceTimer = setTimeout(() => {\r\n            this.exportMap();\r\n            this.exportDebounceTimer = null;\r\n        }, 300); // Export 300ms after last change\r\n    }\r\n\r\n    // Paint with brush on terrain map\r\n    paintBrushTerrain(centerX, centerY, terrainId) {\r\n        const radius = Math.floor(this.brushSize / 2);\r\n        let painted = false;\r\n\r\n        for (let dy = -radius; dy <= radius; dy++) {\r\n            for (let dx = -radius; dx <= radius; dx++) {\r\n                const x = centerX + dx;\r\n                const y = centerY + dy;\r\n\r\n                // Check bounds\r\n                if (x >= 0 && x < this.mapSize && y >= 0 && y < this.mapSize) {\r\n                    // Check if within brush radius (circular brush)\r\n                    const distance = Math.sqrt(dx * dx + dy * dy);\r\n                    if (distance <= radius + 0.5) {\r\n                        if (this.tileMap.terrainMap[y][x] !== terrainId) {\r\n                            this.tileMap.terrainMap[y][x] = terrainId;\r\n                            painted = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return painted;\r\n    }\r\n\r\n    // Paint with brush on height map\r\n    paintBrushHeight(centerX, centerY, heightLevel) {\r\n        const radius = Math.floor(this.brushSize / 2);\r\n        let painted = false;\r\n\r\n        for (let dy = -radius; dy <= radius; dy++) {\r\n            for (let dx = -radius; dx <= radius; dx++) {\r\n                const x = centerX + dx;\r\n                const y = centerY + dy;\r\n\r\n                // Check bounds\r\n                if (x >= 0 && x < this.mapSize && y >= 0 && y < this.mapSize) {\r\n                    // Check if within brush radius (circular brush)\r\n                    const distance = Math.sqrt(dx * dx + dy * dy);\r\n                    if (distance <= radius + 0.5) {\r\n                        if (this.tileMap.heightMap[y][x] !== heightLevel) {\r\n                            this.tileMap.heightMap[y][x] = heightLevel;\r\n                            painted = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return painted;\r\n    }\r\n\r\n    // Flood fill terrain map\r\n    floodFillTerrain(startX, startY, newTerrainId) {\r\n        if (startX < 0 || startX >= this.mapSize || startY < 0 || startY >= this.mapSize) {\r\n            return false;\r\n        }\r\n\r\n        const oldTerrainId = this.tileMap.terrainMap[startY][startX];\r\n\r\n        // If the target color is the same as the replacement, nothing to do\r\n        if (oldTerrainId === newTerrainId) {\r\n            return false;\r\n        }\r\n\r\n        // Use a queue-based flood fill to avoid stack overflow\r\n        const queue = [[startX, startY]];\r\n        const visited = new Set();\r\n\r\n        while (queue.length > 0) {\r\n            const [x, y] = queue.shift();\r\n            const key = `${x},${y}`;\r\n\r\n            // Skip if already visited or out of bounds\r\n            if (visited.has(key) || x < 0 || x >= this.mapSize || y < 0 || y >= this.mapSize) {\r\n                continue;\r\n            }\r\n\r\n            // Skip if not the target terrain\r\n            if (this.tileMap.terrainMap[y][x] !== oldTerrainId) {\r\n                continue;\r\n            }\r\n\r\n            // Mark as visited and paint\r\n            visited.add(key);\r\n            this.tileMap.terrainMap[y][x] = newTerrainId;\r\n\r\n            // Add neighbors to queue\r\n            queue.push([x + 1, y]);\r\n            queue.push([x - 1, y]);\r\n            queue.push([x, y + 1]);\r\n            queue.push([x, y - 1]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Flood fill height map\r\n    floodFillHeight(startX, startY, newHeightLevel) {\r\n        if (startX < 0 || startX >= this.mapSize || startY < 0 || startY >= this.mapSize) {\r\n            return false;\r\n        }\r\n\r\n        const oldHeightLevel = this.tileMap.heightMap[startY][startX];\r\n\r\n        // If the target height is the same as the replacement, nothing to do\r\n        if (oldHeightLevel === newHeightLevel) {\r\n            return false;\r\n        }\r\n\r\n        // Use a queue-based flood fill to avoid stack overflow\r\n        const queue = [[startX, startY]];\r\n        const visited = new Set();\r\n\r\n        while (queue.length > 0) {\r\n            const [x, y] = queue.shift();\r\n            const key = `${x},${y}`;\r\n\r\n            // Skip if already visited or out of bounds\r\n            if (visited.has(key) || x < 0 || x >= this.mapSize || y < 0 || y >= this.mapSize) {\r\n                continue;\r\n            }\r\n\r\n            // Skip if not the target height\r\n            if (this.tileMap.heightMap[y][x] !== oldHeightLevel) {\r\n                continue;\r\n            }\r\n\r\n            // Mark as visited and paint\r\n            visited.add(key);\r\n            this.tileMap.heightMap[y][x] = newHeightLevel;\r\n\r\n            // Add neighbors to queue\r\n            queue.push([x + 1, y]);\r\n            queue.push([x - 1, y]);\r\n            queue.push([x, y + 1]);\r\n            queue.push([x, y - 1]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    handleCanvasInteraction(event) {\r\n        // Get mouse position relative to canvas\r\n        const offsetY = (this.canvasEl.height - this.mapSize * this.config.gridSize) / 2;\r\n        const rect = this.canvasEl.getBoundingClientRect();\r\n        // Account for CSS scaling of the canvas\r\n        const scaleX = this.canvasEl.width / rect.width;\r\n        const scaleY = this.canvasEl.height / rect.height;\r\n        let mouseX = (event.clientX - rect.left) * scaleX;\r\n        let mouseY = (event.clientY - rect.top) * scaleY;\r\n\r\n\r\n        if(!this.gameEditor.getCollections().configs.game.isIsometric) {\r\n            mouseX -= (this.canvasEl.width - this.mapSize * this.config.gridSize) / 2;\r\n            mouseY -= (this.canvasEl.height - this.mapSize * this.config.gridSize) / 2;\r\n        }\r\n        \r\n        if (this.placementMode === 'terrain') {\r\n            const gridPos = this.translator.isoToGrid(mouseX, mouseY);\r\n            const snappedGrid = this.translator.snapToGrid(gridPos.x, gridPos.y);\r\n\r\n            // Check if coordinates are within bounds\r\n            if (snappedGrid.x >= 0 && snappedGrid.x < this.mapSize &&\r\n                snappedGrid.y >= 0 && snappedGrid.y < this.mapSize) {\r\n\r\n                let painted = false;\r\n\r\n                if (this.terrainTool === 'brush') {\r\n                    // Brush tool: paint with variable size\r\n                    const tileKey = `${snappedGrid.x},${snappedGrid.y}`;\r\n\r\n                    // Only paint if we're on a new tile or haven't painted here yet\r\n                    if (this.lastPaintedTile !== tileKey || this.brushSize > 1) {\r\n                        painted = this.paintBrushTerrain(snappedGrid.x, snappedGrid.y, this.currentTerrainId);\r\n                        this.lastPaintedTile = tileKey;\r\n                    }\r\n                } else if (this.terrainTool === 'fill') {\r\n                    // Flood fill tool: fill contiguous area (only on click, not drag)\r\n                    if (!this.isMouseDown || this.lastPaintedTile === null) {\r\n                        painted = this.floodFillTerrain(snappedGrid.x, snappedGrid.y, this.currentTerrainId);\r\n                        this.lastPaintedTile = `${snappedGrid.x},${snappedGrid.y}`;\r\n                    }\r\n                }\r\n\r\n                if (painted) {\r\n                    // Schedule render instead of immediate render\r\n                    this.needsRender = true;\r\n                    this.scheduleRender();\r\n                }\r\n            }\r\n        } else if (this.placementMode === 'environment' && this.selectedEnvironmentType &&\r\n                   this.selectedEnvironmentItem !== null) {\r\n            // Environment object placement logic\r\n            const isoPos = { x: mouseX, y: mouseY };\r\n            const pixelPos = this.translator.isoToPixel(isoPos.x, isoPos.y);\r\n\r\n            // Get the image to calculate its size\r\n            const images = this.imageManager.getImages(\"environment\", this.selectedEnvironmentType);\r\n            const image = images.idle[0][this.selectedEnvironmentItem];\r\n\r\n            // Create new environment object\r\n            const newObject = {\r\n                type: this.selectedEnvironmentType,\r\n                imageIndex: this.selectedEnvironmentItem,\r\n                x: pixelPos.x,\r\n                y: pixelPos.y\r\n            };\r\n\r\n            // Add to environment objects array\r\n            if (!this.tileMap.environmentObjects) {\r\n                this.tileMap.environmentObjects = [];\r\n            }\r\n            this.tileMap.environmentObjects.push(newObject);\r\n\r\n            // Schedule render instead of immediate render\r\n            this.needsRender = true;\r\n            this.scheduleRender();\r\n\r\n            // Debounce export to reduce frequency\r\n        } else if (this.placementMode === 'ramp') {\r\n            // Ramp placement logic\r\n            const gridPos = this.translator.isoToGrid(mouseX, mouseY);\r\n            const snappedGrid = this.translator.snapToGrid(gridPos.x, gridPos.y);\r\n            console.log('clicked');\r\n            // Check if coordinates are within bounds\r\n            if (snappedGrid.x >= 0 && snappedGrid.x < this.mapSize &&\r\n                snappedGrid.y >= 0 && snappedGrid.y < this.mapSize) {\r\n\r\n                // Initialize ramps array if needed\r\n                if (!this.tileMap.ramps) {\r\n                    this.tileMap.ramps = [];\r\n                }\r\n\r\n                // Check if ramp already exists at this position\r\n                const rampIndex = this.tileMap.ramps.findIndex(r => r.x === snappedGrid.x && r.z === snappedGrid.y);\r\n\r\n                if (rampIndex >= 0) {\r\n                    // Remove existing ramp (toggle off)\r\n                    this.tileMap.ramps.splice(rampIndex, 1);\r\n                } else {\r\n                    // Add new ramp (toggle on)\r\n                    this.tileMap.ramps.push({ x: snappedGrid.x, z: snappedGrid.y });\r\n                }\r\n\r\n                // Update ramp count display\r\n                this.updateRampCount();\r\n\r\n                // Schedule render to show ramps\r\n                this.needsRender = true;\r\n                this.scheduleRender();\r\n            }\r\n        } else if (this.placementMode === 'height') {\r\n            // Height map editing logic\r\n            const gridPos = this.translator.isoToGrid(mouseX, mouseY);\r\n            const snappedGrid = this.translator.snapToGrid(gridPos.x, gridPos.y);\r\n\r\n            // Check if coordinates are within bounds\r\n            if (snappedGrid.x >= 0 && snappedGrid.x < this.mapSize &&\r\n                snappedGrid.y >= 0 && snappedGrid.y < this.mapSize) {\r\n\r\n                let painted = false;\r\n\r\n                if (this.terrainTool === 'brush') {\r\n                    // Brush tool: paint with variable size\r\n                    const tileKey = `${snappedGrid.x},${snappedGrid.y}`;\r\n\r\n                    // Only paint if we're on a new tile or haven't painted here yet\r\n                    if (this.lastPaintedTile !== tileKey || this.brushSize > 1) {\r\n                        painted = this.paintBrushHeight(snappedGrid.x, snappedGrid.y, this.currentHeightLevel);\r\n                        this.lastPaintedTile = tileKey;\r\n\r\n                        // Apply terrain type 0 / height 0 coupling rule for brush strokes\r\n                        if (painted && this.currentHeightLevel === 0) {\r\n                            const radius = Math.floor(this.brushSize / 2);\r\n                            for (let dy = -radius; dy <= radius; dy++) {\r\n                                for (let dx = -radius; dx <= radius; dx++) {\r\n                                    const x = snappedGrid.x + dx;\r\n                                    const y = snappedGrid.y + dy;\r\n                                    if (x >= 0 && x < this.mapSize && y >= 0 && y < this.mapSize) {\r\n                                        const distance = Math.sqrt(dx * dx + dy * dy);\r\n                                        if (distance <= radius + 0.5 && this.tileMap.heightMap[y][x] === 0) {\r\n                                            this.tileMap.terrainMap[y][x] = 0;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (this.terrainTool === 'fill') {\r\n                    // Flood fill tool: fill contiguous area (only on click, not drag)\r\n                    if (!this.isMouseDown || this.lastPaintedTile === null) {\r\n                        painted = this.floodFillHeight(snappedGrid.x, snappedGrid.y, this.currentHeightLevel);\r\n                        this.lastPaintedTile = `${snappedGrid.x},${snappedGrid.y}`;\r\n\r\n                        // Apply terrain type 0 / height 0 coupling rule for filled area\r\n                        if (painted && this.currentHeightLevel === 0) {\r\n                            for (let y = 0; y < this.mapSize; y++) {\r\n                                for (let x = 0; x < this.mapSize; x++) {\r\n                                    if (this.tileMap.heightMap[y][x] === 0) {\r\n                                        this.tileMap.terrainMap[y][x] = 0;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (painted) {\r\n                    // Schedule render instead of immediate render\r\n                    this.needsRender = true;\r\n                    this.scheduleRender();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Fast rendering method - draws simple colored squares\r\n    renderMap() {\r\n        if (!this.tileMap.terrainMap || this.tileMap.terrainMap.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const ctx = this.canvasEl.getContext('2d');\r\n        const gridSize = this.config.gridSize;\r\n        const isIsometric = this.gameEditor.getCollections().configs.game.isIsometric;\r\n        \r\n        // Clear canvas\r\n        ctx.fillStyle = this.tileMap.terrainTypes[this.tileMap.extensionTerrainType || 3].color;\r\n        ctx.fillRect(0, 0, this.canvasEl.width, this.canvasEl.height);\r\n        \r\n        if (isIsometric) {\r\n            // Isometric rendering\r\n            for (let y = 0; y < this.tileMap.terrainMap.length; y++) {\r\n                for (let x = 0; x < this.tileMap.terrainMap[y].length; x++) {\r\n                    const terrainId = this.tileMap.terrainMap[y][x];\r\n                    const terrain = this.tileMap.terrainTypes[terrainId];\r\n                    \r\n                    if (!terrain) continue;\r\n                    \r\n                    const isoCoords = this.translator.gridToIso(x, y);\r\n                    const tileWidth = gridSize;\r\n                    const tileHeight = gridSize * 0.5;\r\n                    \r\n                    ctx.fillStyle = terrain.color;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(isoCoords.x, isoCoords.y);\r\n                    ctx.lineTo(isoCoords.x + tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                    ctx.lineTo(isoCoords.x, isoCoords.y + tileHeight);\r\n                    ctx.lineTo(isoCoords.x - tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                    \r\n                    // Optional: draw borders\r\n                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\r\n                    ctx.lineWidth = 1;\r\n                    ctx.stroke();\r\n                }\r\n            }\r\n        } else {\r\n            // Non-isometric rendering (simple squares)\r\n            const offsetX = (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n            const offsetY = (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n\r\n            for (let y = 0; y < this.tileMap.terrainMap.length; y++) {\r\n                for (let x = 0; x < this.tileMap.terrainMap[y].length; x++) {\r\n                    const terrainId = this.tileMap.terrainMap[y][x];\r\n                    const terrain = this.tileMap.terrainTypes[terrainId];\r\n\r\n                    if (!terrain) continue;\r\n\r\n                    const drawX = offsetX + x * gridSize;\r\n                    const drawY = offsetY + y * gridSize;\r\n\r\n                    ctx.fillStyle = terrain.color;\r\n                    ctx.fillRect(drawX, drawY, gridSize, gridSize);\r\n\r\n                    // Optional: draw grid lines\r\n                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';\r\n                    ctx.lineWidth = 1;\r\n                    ctx.strokeRect(drawX, drawY, gridSize, gridSize);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Height mode overlay - show height levels in both height and ramp modes\r\n        if ((this.placementMode === 'height' || this.placementMode === 'ramp') && this.tileMap.heightMap && this.tileMap.heightMap.length > 0) {\r\n            const offsetX = isIsometric ? 0 : (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n            const offsetY = isIsometric ? 0 : (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n\r\n            for (let y = 0; y < this.tileMap.heightMap.length; y++) {\r\n                for (let x = 0; x < this.tileMap.heightMap[y].length; x++) {\r\n                    const heightLevel = this.tileMap.heightMap[y][x];\r\n\r\n                    if (isIsometric) {\r\n                        const isoCoords = this.translator.gridToIso(x, y);\r\n                        const tileWidth = gridSize;\r\n                        const tileHeight = gridSize * 0.5;\r\n\r\n                        // Semi-transparent height overlay\r\n                        const alpha = 0.6;\r\n                        const intensity = Math.min(heightLevel / 10, 1);\r\n                        ctx.fillStyle = `rgba(${255 * intensity}, ${100}, ${255 * (1 - intensity)}, ${alpha})`;\r\n\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(isoCoords.x, isoCoords.y);\r\n                        ctx.lineTo(isoCoords.x + tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                        ctx.lineTo(isoCoords.x, isoCoords.y + tileHeight);\r\n                        ctx.lineTo(isoCoords.x - tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n\r\n                        // Draw height number\r\n                        ctx.fillStyle = 'white';\r\n                        ctx.font = 'bold 12px monospace';\r\n                        ctx.textAlign = 'center';\r\n                        ctx.textBaseline = 'middle';\r\n                        ctx.fillText(heightLevel, isoCoords.x, isoCoords.y + tileHeight / 2);\r\n                    } else {\r\n                        const drawX = offsetX + x * gridSize;\r\n                        const drawY = offsetY + y * gridSize;\r\n\r\n                        // Color gradient from blue (low) to red (high)\r\n                        const alpha = 0.6;\r\n                        const intensity = Math.min(heightLevel / 10, 1);\r\n                        ctx.fillStyle = `rgba(${255 * intensity}, ${100}, ${255 * (1 - intensity)}, ${alpha})`;\r\n                        ctx.fillRect(drawX, drawY, gridSize, gridSize);\r\n\r\n                        // Draw height number\r\n                        ctx.fillStyle = 'white';\r\n                        ctx.font = 'bold 14px monospace';\r\n                        ctx.textAlign = 'center';\r\n                        ctx.textBaseline = 'middle';\r\n                        ctx.strokeStyle = 'black';\r\n                        ctx.lineWidth = 3;\r\n                        ctx.strokeText(heightLevel, drawX + gridSize / 2, drawY + gridSize / 2);\r\n                        ctx.fillText(heightLevel, drawX + gridSize / 2, drawY + gridSize / 2);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render environment objects with their actual images\r\n        if (this.tileMap.environmentObjects && this.tileMap.environmentObjects.length > 0 && this.imageManager) {\r\n            for (const obj of this.tileMap.environmentObjects) {\r\n                if (!obj || obj.x === undefined || obj.y === undefined) continue;\r\n                \r\n                // Get the image for this object\r\n                const images = this.imageManager.getImages(\"environment\", obj.type);\r\n                if (!images || !images.idle || !images.idle[0] || !images.idle[0][obj.imageIndex]) {\r\n                    continue;\r\n                }\r\n                \r\n                const image = images.idle[0][obj.imageIndex];\r\n                if (!image) continue;\r\n                \r\n                let screenX, screenY;\r\n                \r\n                if (isIsometric) {\r\n                    // Convert pixel coordinates to isometric screen coordinates\r\n                    const isoPos = this.translator.pixelToIso(obj.x, obj.y);\r\n                    screenX = isoPos.x;\r\n                    screenY = isoPos.y;\r\n                } else {\r\n                    // Convert pixel coordinates to screen coordinates\r\n                    const offsetX = (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n                    const offsetY = (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n                    screenX = offsetX + obj.x;\r\n                    screenY = offsetY + obj.y;\r\n                }\r\n                \r\n                // Draw the image centered at the position\r\n                ctx.drawImage(\r\n                    image,\r\n                    screenX - image.width / 2,\r\n                    screenY - image.height / 2,\r\n                    image.width,\r\n                    image.height\r\n                );\r\n            }\r\n        }\r\n\r\n        // Render ramps as visual indicators\r\n        if (this.tileMap.ramps && this.tileMap.ramps.length > 0) {\r\n            for (const ramp of this.tileMap.ramps) {\r\n                if (isIsometric) {\r\n                    // Isometric rendering for ramps\r\n                    const isoCoords = this.translator.gridToIso(ramp.x, ramp.z);\r\n                    const tileWidth = gridSize;\r\n                    const tileHeight = gridSize * 0.5;\r\n\r\n                    // Draw ramp indicator (triangle pointing up)\r\n                    ctx.fillStyle = 'rgba(139, 115, 85, 0.7)'; // Semi-transparent brown\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(isoCoords.x, isoCoords.y + tileHeight / 4);\r\n                    ctx.lineTo(isoCoords.x + tileWidth / 4, isoCoords.y + tileHeight / 2);\r\n                    ctx.lineTo(isoCoords.x - tileWidth / 4, isoCoords.y + tileHeight / 2);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n\r\n                    // Add border\r\n                    ctx.strokeStyle = 'rgba(101, 84, 63, 1)'; // Darker brown\r\n                    ctx.lineWidth = 2;\r\n                    ctx.stroke();\r\n                } else {\r\n                    // Non-isometric rendering for ramps\r\n                    const offsetX = (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n                    const offsetY = (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n\r\n                    const drawX = offsetX + ramp.x * gridSize;\r\n                    const drawY = offsetY + ramp.z * gridSize;\r\n\r\n                    // Draw ramp indicator (triangle or arrow)\r\n                    ctx.fillStyle = 'rgba(139, 115, 85, 0.7)'; // Semi-transparent brown\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(drawX + gridSize / 2, drawY + gridSize / 4);\r\n                    ctx.lineTo(drawX + 3 * gridSize / 4, drawY + 3 * gridSize / 4);\r\n                    ctx.lineTo(drawX + gridSize / 4, drawY + 3 * gridSize / 4);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n\r\n                    // Add border\r\n                    ctx.strokeStyle = 'rgba(101, 84, 63, 1)'; // Darker brown\r\n                    ctx.lineWidth = 2;\r\n                    ctx.stroke();\r\n\r\n                    // Optional: Add \"R\" text to clearly mark it as a ramp\r\n                    ctx.fillStyle = 'white';\r\n                    ctx.font = `${gridSize / 3}px Arial`;\r\n                    ctx.textAlign = 'center';\r\n                    ctx.textBaseline = 'middle';\r\n                    ctx.fillText('R', drawX + gridSize / 2, drawY + gridSize / 2);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Render brush/fill preview overlay\r\n        if (this.hoverGridPosition &&\r\n            (this.placementMode === 'terrain' || this.placementMode === 'height')) {\r\n\r\n            if (this.terrainTool === 'brush') {\r\n                // Brush tool preview - show all affected tiles\r\n                const centerX = this.hoverGridPosition.x;\r\n                const centerY = this.hoverGridPosition.y;\r\n                const radius = Math.floor(this.brushSize / 2);\r\n\r\n                // Render each tile in the brush area\r\n                for (let dy = -radius; dy <= radius; dy++) {\r\n                    for (let dx = -radius; dx <= radius; dx++) {\r\n                        const x = centerX + dx;\r\n                        const y = centerY + dy;\r\n\r\n                        // Check bounds\r\n                        if (x >= 0 && x < this.mapSize && y >= 0 && y < this.mapSize) {\r\n                            // Check if within brush radius (circular brush)\r\n                            const distance = Math.sqrt(dx * dx + dy * dy);\r\n                            if (distance <= radius + 0.5) {\r\n                                if (isIsometric) {\r\n                                    // Isometric preview\r\n                                    const isoCoords = this.translator.gridToIso(x, y);\r\n                                    const tileWidth = gridSize;\r\n                                    const tileHeight = gridSize * 0.5;\r\n\r\n                                    // Draw semi-transparent overlay\r\n                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\r\n                                    ctx.beginPath();\r\n                                    ctx.moveTo(isoCoords.x, isoCoords.y);\r\n                                    ctx.lineTo(isoCoords.x + tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                                    ctx.lineTo(isoCoords.x, isoCoords.y + tileHeight);\r\n                                    ctx.lineTo(isoCoords.x - tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                                    ctx.closePath();\r\n                                    ctx.fill();\r\n\r\n                                    // Draw border\r\n                                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\r\n                                    ctx.lineWidth = 2;\r\n                                    ctx.stroke();\r\n                                } else {\r\n                                    // Non-isometric preview\r\n                                    const offsetX = (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n                                    const offsetY = (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n\r\n                                    const drawX = offsetX + x * gridSize;\r\n                                    const drawY = offsetY + y * gridSize;\r\n\r\n                                    // Draw semi-transparent overlay\r\n                                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\r\n                                    ctx.fillRect(drawX, drawY, gridSize, gridSize);\r\n\r\n                                    // Draw border\r\n                                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\r\n                                    ctx.lineWidth = 2;\r\n                                    ctx.strokeRect(drawX, drawY, gridSize, gridSize);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else if (this.terrainTool === 'fill') {\r\n                // Fill tool preview - show single tile with different color\r\n                const x = this.hoverGridPosition.x;\r\n                const y = this.hoverGridPosition.y;\r\n\r\n                if (x >= 0 && x < this.mapSize && y >= 0 && y < this.mapSize) {\r\n                    if (isIsometric) {\r\n                        // Isometric preview\r\n                        const isoCoords = this.translator.gridToIso(x, y);\r\n                        const tileWidth = gridSize;\r\n                        const tileHeight = gridSize * 0.5;\r\n\r\n                        // Draw semi-transparent overlay with blue tint for fill\r\n                        ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(isoCoords.x, isoCoords.y);\r\n                        ctx.lineTo(isoCoords.x + tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                        ctx.lineTo(isoCoords.x, isoCoords.y + tileHeight);\r\n                        ctx.lineTo(isoCoords.x - tileWidth / 2, isoCoords.y + tileHeight / 2);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n\r\n                        // Draw border\r\n                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.9)';\r\n                        ctx.lineWidth = 3;\r\n                        ctx.stroke();\r\n                    } else {\r\n                        // Non-isometric preview\r\n                        const offsetX = (this.canvasEl.width - this.mapSize * gridSize) / 2;\r\n                        const offsetY = (this.canvasEl.height - this.mapSize * gridSize) / 2;\r\n\r\n                        const drawX = offsetX + x * gridSize;\r\n                        const drawY = offsetY + y * gridSize;\r\n\r\n                        // Draw semi-transparent overlay with blue tint for fill\r\n                        ctx.fillStyle = 'rgba(100, 200, 255, 0.4)';\r\n                        ctx.fillRect(drawX, drawY, gridSize, gridSize);\r\n\r\n                        // Draw border\r\n                        ctx.strokeStyle = 'rgba(100, 200, 255, 0.9)';\r\n                        ctx.lineWidth = 3;\r\n                        ctx.strokeRect(drawX, drawY, gridSize, gridSize);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async updateCanvasWithData() {\r\n        // Use fast rendering for instant feedback\r\n        this.renderMap();\r\n    }\r\n\r\n    updateRampCount() {\r\n        const rampCountEl = document.getElementById('rampCount');\r\n        if (rampCountEl) {\r\n            const count = this.tileMap.ramps ? this.tileMap.ramps.length : 0;\r\n            rampCountEl.textContent = count;\r\n        }\r\n    }\r\n\r\n    exportMap() {\r\n        // Create a custom event with data\r\n        const myCustomEvent = new CustomEvent('saveTileMap', {\r\n            detail: {\r\n                data: this.tileMap,  // tileMap now includes heightMap array\r\n                propertyName: this.savePropertyName,\r\n                refresh: false\r\n            },\r\n            bubbles: true,\r\n            cancelable: true\r\n        });\r\n\r\n        // Dispatch the event\r\n        document.body.dispatchEvent(myCustomEvent);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/TerrainMapEditor.js"
      },
      "GE_EquipmentEditor": {
        "title": "GE_EquipmentEditor",
        "fileName": "GE_EquipmentEditor",
        "script": "/**\r\n * @class GE_EquipmentEditor\r\n * @description Equipment panel extension for GraphicsEditor\r\n */\r\nclass GE_EquipmentEditor {\r\n    /**\r\n     * @param {Object} gameEditor - Main game editor instance\r\n     * @param {Object} graphicsEditor - Graphics editor instance\r\n     */\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        \r\n        // Equipment-specific state\r\n        this.equipmentData = [];\r\n        this.renderData = null;\r\n        this.selectedEquipmentIndex = -1;\r\n        this.equipmentModels = new Map();\r\n        this.attachmentBones = new Map();\r\n        this.characterBones = new Map(); // Cache for character bones\r\n        this.bonePrefix = 'mixamorig'\r\n    }\r\n    \r\n    /**\r\n     * Initialize equipment editor capabilities\r\n     */\r\n    init() {\r\n        this.setupEventListeners();\r\n    }\r\n    \r\n    /**\r\n     * Set up event listeners for equipment functionality\r\n     */\r\n    setupEventListeners() {\r\n        // Listen for render data loading\r\n        document.body.addEventListener('renderGraphicsObject', this.handleLoadEvent.bind(this));\r\n        \r\n        // Listen for scene updates to maintain bone attachments\r\n        document.body.addEventListener('sceneUpdated', this.maintainBoneAttachments.bind(this));\r\n        \r\n        // Equipment panel toggle\r\n        document.getElementById('equipment-toggle-btn')?.addEventListener('click', this.toggleEquipmentPanel.bind(this));\r\n        \r\n        // Equipment action buttons\r\n        document.getElementById('equipment-add-btn')?.addEventListener('click', this.addEquipment.bind(this));\r\n        document.getElementById('equipment-remove-btn')?.addEventListener('click', this.removeSelectedEquipment.bind(this));\r\n        \r\n        // Equipment list selection\r\n        document.getElementById('equipment-list')?.addEventListener('click', this.handleEquipmentSelection.bind(this));\r\n        \r\n        // Attachment controls\r\n        this.setupAttachmentControls();\r\n    }\r\n    \r\n    /**\r\n     * Handle load event to detect equipment data\r\n     */\r\n    handleLoadEvent(event) {\r\n        const { data, propertyName, objectData } = event.detail;\r\n        \r\n        // Handle render data loading\r\n        if (propertyName === 'render' && data) {\r\n            this.renderData = data;\r\n            this.equipmentData = data.equipment || [];\r\n            \r\n            // Wait for scene to be fully rendered before loading equipment\r\n            setTimeout(() => {\r\n                this.findCharacterBones();\r\n                \r\n                if (this.equipmentData.length > 0) {\r\n                    console.log('Equipment data found, showing equipment panel');\r\n                    this.showEquipmentPanel();\r\n                    this.loadEquipmentModels();\r\n                } else {\r\n                    console.log('No equipment data, hiding equipment panel');\r\n                    this.hideEquipmentPanel();\r\n                }\r\n                \r\n                this.updateEquipmentList();\r\n                this.updateBoneSelector();\r\n            }, 100);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Find and cache all bones in the character model\r\n     */\r\n    findCharacterBones() {\r\n        this.characterBones.clear();\r\n        this.attachmentBones.clear();\r\n        \r\n        if (!this.graphicsEditor.rootGroup) {\r\n            console.warn('No root group found for bone detection');\r\n            return;\r\n        }\r\n        \r\n        // Traverse the entire scene to find all bones\r\n        this.graphicsEditor.rootGroup.traverse(object => {\r\n            if (object.isBone) {\r\n                this.characterBones.set(object.name.replace(this.bonePrefix, ''), object);\r\n                this.attachmentBones.set(object.name.replace(this.bonePrefix, ''), object);\r\n            }\r\n            \r\n            // Also check for bones in GLTF models\r\n            if (object.userData && object.userData.isGLTFRoot && object.userData.skeleton) {\r\n                const skeleton = object.userData.skeleton;\r\n                skeleton.bones.forEach(bone => {\r\n                    this.characterBones.set(bone.name.replace(this.bonePrefix, ''), bone);\r\n                    this.attachmentBones.set(bone.name.replace(this.bonePrefix, ''), bone);\r\n                });\r\n            }\r\n        });\r\n        \r\n        console.log(`Total bones found: ${this.characterBones.size}`);\r\n    }\r\n    \r\n    /**\r\n     * Show equipment panel\r\n     */\r\n    showEquipmentPanel() {\r\n        const panel = document.getElementById('equipment-panel');\r\n        const container = document.getElementById('graphics-editor-container');\r\n        \r\n        if (panel) {\r\n            panel.style.display = 'block';\r\n        }\r\n        \r\n        if (container) {\r\n            container.classList.add('has-equipment');\r\n        }\r\n        \r\n        this.populateItemSelector();\r\n    }\r\n    \r\n    /**\r\n     * Hide equipment panel\r\n     */\r\n    hideEquipmentPanel() {\r\n        const panel = document.getElementById('equipment-panel');\r\n        const container = document.getElementById('graphics-editor-container');\r\n        \r\n        if (panel) {\r\n            panel.style.display = 'none';\r\n        }\r\n        \r\n        if (container) {\r\n            container.classList.remove('has-equipment');\r\n            container.classList.remove('equipment-selected');\r\n        }\r\n        \r\n        this.selectedEquipmentIndex = -1;\r\n    }\r\n    \r\n    /**\r\n     * Toggle equipment panel collapsed state\r\n     */\r\n    toggleEquipmentPanel() {\r\n        const panel = document.getElementById('equipment-panel');\r\n        if (panel) {\r\n            panel.classList.toggle('collapsed');\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Load equipment models\r\n     */\r\n    async loadEquipmentModels() {\r\n        this.equipmentModels.clear();\r\n        \r\n        // Ensure bones are found before loading equipment\r\n        this.findCharacterBones();\r\n        \r\n        for (let i = 0; i < this.equipmentData.length; i++) {\r\n            const equipment = this.equipmentData[i];\r\n            await this.loadSingleEquipmentModel(equipment, i);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Load a single equipment model\r\n     */\r\n    async loadSingleEquipmentModel(equipment, index) {\r\n        try {\r\n            const itemData = this.gameEditor.getCollections().items?.[equipment.item];\r\n            if (!itemData?.render?.model) {\r\n                console.warn(`No render data found for item: ${equipment.item}`);\r\n                return;\r\n            }\r\n            \r\n            // Create equipment model using ShapeFactory\r\n            const equipmentGroup = await this.graphicsEditor.shapeFactory.createGroupFromJSON(\r\n                `equipment_${index}`, \r\n                itemData.render.model.main\r\n            );\r\n            \r\n            if (equipmentGroup) {\r\n                // Mark as equipment for identification\r\n                equipmentGroup.userData.isEquipment = true;\r\n                equipmentGroup.userData.equipmentIndex = index;\r\n                equipmentGroup.userData.equipmentItem = equipment.item;\r\n                \r\n                // Apply attachment data BEFORE attaching to bone\r\n                this.applyAttachmentData(equipmentGroup, equipment.attachmentData);\r\n                \r\n                // Find and attach to bone\r\n                const bone = this.findAttachmentBone(equipment);\r\n                if (bone) {\r\n                    console.log(`Attaching equipment ${equipment.item} to bone: ${bone.name}`);\r\n                    bone.add(equipmentGroup);\r\n                    \r\n                    // Ensure the bone hierarchy is properly maintained\r\n                    this.ensureBoneHierarchy(bone);\r\n                } else {\r\n                    console.warn(`No suitable bone found for equipment ${equipment.item}, adding to root`);\r\n                    // As fallback, add to root group but this shouldn't happen with proper bone detection\r\n                    this.graphicsEditor.rootGroup.add(equipmentGroup);\r\n                }\r\n                \r\n                this.equipmentModels.set(index, {\r\n                    model: equipmentGroup,\r\n                    equipment: equipment,\r\n                    bone: bone\r\n                });\r\n                \r\n                console.log(`Equipment model loaded and attached: ${equipment.item}`);\r\n            }\r\n        } catch (error) {\r\n            console.error(`Error loading equipment model for ${equipment.item}:`, error);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Ensure bone hierarchy is properly maintained in the scene\r\n     */\r\n    ensureBoneHierarchy(bone) {\r\n        // Make sure the bone and its ancestors are properly connected to the scene\r\n        let currentBone = bone;\r\n        while (currentBone && currentBone.parent) {\r\n            // If we find a parent that's in the root group, we're good\r\n            if (currentBone.parent === this.graphicsEditor.rootGroup || \r\n                this.isInSceneHierarchy(currentBone.parent)) {\r\n                break;\r\n            }\r\n            currentBone = currentBone.parent;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Check if an object is properly connected to the scene hierarchy\r\n     */\r\n    isInSceneHierarchy(object) {\r\n        let current = object;\r\n        while (current.parent) {\r\n            if (current.parent === this.graphicsEditor.sceneRenderer.scene || \r\n                current.parent === this.graphicsEditor.rootGroup) {\r\n                return true;\r\n            }\r\n            current = current.parent;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Find attachment bone for equipment with improved fallback logic\r\n     */\r\n    findAttachmentBone(equipment) {\r\n        // First try the explicitly specified bone\r\n        const specifiedBone = equipment.attachmentData?.bone;\r\n        if (specifiedBone && this.characterBones.has(specifiedBone)) {\r\n            return this.characterBones.get(specifiedBone);\r\n        }\r\n        \r\n        // Enhanced fallback bone detection with more comprehensive mappings\r\n        const fallbackBones = {\r\n            'mainHand': [\r\n                'RightHand', 'Hand_R', 'hand_R', 'R_Hand', 'hand.R', \r\n                'RightHand_End', 'RHand', 'right_hand', 'HandR'\r\n            ],\r\n            'offHand': [\r\n                'LeftHand', 'Hand_L', 'hand_L', 'L_Hand', 'hand.L',\r\n                'LeftHand_End', 'LHand', 'left_hand', 'HandL'\r\n            ],\r\n            'head': [\r\n                'Head', 'head', 'Head_M', 'head_end', 'Head_End',\r\n                'HeadTop_End', 'neck_01', 'Neck', 'neck'\r\n            ],\r\n            'chest': [\r\n                'Spine2', 'spine2', 'Chest', 'chest', 'spine_02',\r\n                'Spine_02', 'UpperChest', 'upper_chest', 'Spine1'\r\n            ],\r\n            'back': [\r\n                'Spine2', 'spine2', 'Chest', 'chest', 'spine_02',\r\n                'Spine_02', 'UpperChest', 'upper_chest', 'Spine1'\r\n            ],\r\n            'waist': [\r\n                'Spine', 'spine', 'Hips', 'hips', 'pelvis', 'Pelvis',\r\n                'spine_01', 'Spine_01', 'Root', 'root'\r\n            ]\r\n        };\r\n        \r\n        const possibleBones = fallbackBones[equipment.slot] || [];\r\n        \r\n        // Try each possible bone name\r\n        for (const boneName of possibleBones) {\r\n            if (this.characterBones.has(boneName)) {\r\n                console.log(`Found fallback bone ${boneName} for slot ${equipment.slot}`);\r\n                return this.characterBones.get(boneName);\r\n            }\r\n        }\r\n        \r\n        // If no specific bone found, try to find any bone that contains the slot name\r\n        for (const [boneName, bone] of this.characterBones) {\r\n            const lowerBoneName = boneName.toLowerCase();\r\n            const lowerSlot = equipment.slot.toLowerCase();\r\n            \r\n            if (lowerBoneName.includes(lowerSlot) || \r\n                lowerSlot.includes(lowerBoneName.replace(/[_\\-\\.]/g, ''))) {\r\n                console.log(`Found partial match bone ${boneName} for slot ${equipment.slot}`);\r\n                return bone;\r\n            }\r\n        }\r\n        \r\n        console.warn(`No suitable bone found for equipment slot: ${equipment.slot}`);\r\n        console.log('Available bones:', Array.from(this.characterBones.keys()));\r\n        \r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Apply attachment data to equipment model\r\n     */\r\n    applyAttachmentData(equipmentModel, attachmentData) {\r\n        if (!attachmentData) return;\r\n        \r\n        // Apply position offset\r\n        if (attachmentData.offset) {\r\n            equipmentModel.position.set(\r\n                attachmentData.offset.x || 0,\r\n                attachmentData.offset.y || 0,\r\n                attachmentData.offset.z || 0\r\n            );\r\n        }\r\n        \r\n        // Apply rotation\r\n        if (attachmentData.rotation) {\r\n            equipmentModel.rotation.set(\r\n                (attachmentData.rotation.x || 0) * Math.PI / 180,\r\n                (attachmentData.rotation.y || 0) * Math.PI / 180,\r\n                (attachmentData.rotation.z || 0) * Math.PI / 180\r\n            );\r\n        }\r\n        \r\n        // Apply scale if specified\r\n        if (attachmentData.scale) {\r\n            equipmentModel.scale.set(\r\n                attachmentData.scale.x || 1,\r\n                attachmentData.scale.y || 1,\r\n                attachmentData.scale.z || 1\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Maintain bone attachments after scene updates\r\n     */\r\n    maintainBoneAttachments() {\r\n        // Re-find bones in case the character model was reloaded\r\n        this.findCharacterBones();\r\n        \r\n        // Check all equipment models and ensure they're still properly attached\r\n        this.equipmentModels.forEach((equipmentData, index) => {\r\n            const { model, equipment } = equipmentData;\r\n            \r\n            // Check if model is still properly attached to a bone\r\n            const expectedBone = this.findAttachmentBone(equipment);\r\n            \r\n            if (expectedBone && model.parent !== expectedBone) {\r\n                console.log(`Re-attaching equipment ${equipment.item} to bone ${expectedBone.name}`);\r\n                \r\n                // Remove from current parent\r\n                if (model.parent) {\r\n                    model.parent.remove(model);\r\n                }\r\n                \r\n                // Re-attach to correct bone\r\n                expectedBone.add(model);\r\n                equipmentData.bone = expectedBone;\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Update equipment list display\r\n     */\r\n    updateEquipmentList() {\r\n        const listContainer = document.getElementById('equipment-list');\r\n        if (!listContainer) return;\r\n        \r\n        listContainer.innerHTML = '';\r\n        \r\n        if (this.equipmentData.length === 0) {\r\n            listContainer.innerHTML = '<div class=\"no-equipment\">No equipment loaded</div>';\r\n            this.updateEquipmentCount();\r\n            return;\r\n        }\r\n        \r\n        this.equipmentData.forEach((equipment, index) => {\r\n            const listItem = document.createElement('div');\r\n            listItem.className = `equipment-item ${index === this.selectedEquipmentIndex ? 'selected' : ''}`;\r\n            listItem.dataset.index = index;\r\n            \r\n            // Show attachment status\r\n            const bone = this.findAttachmentBone(equipment);\r\n            const attachmentStatus = bone ? ` ${bone.name}` : ' No bone';\r\n            \r\n            listItem.innerHTML = `\r\n                <div class=\"equipment-info\">\r\n                    <div class=\"item-name\">${equipment.item}</div>\r\n                    <div class=\"slot-name\">${equipment.slot}</div>\r\n                    <div class=\"bone-info\" title=\"${attachmentStatus}\">\r\n                        ${bone ? bone.name : 'No bone found'}\r\n                    </div>\r\n                </div>\r\n            `;\r\n            \r\n            listContainer.appendChild(listItem);\r\n        });\r\n        \r\n        this.updateEquipmentCount();\r\n    }\r\n    \r\n    /**\r\n     * Update equipment count display\r\n     */\r\n    updateEquipmentCount() {\r\n        const countElement = document.getElementById('equipment-count');\r\n        if (countElement) {\r\n            countElement.textContent = this.equipmentData.length;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update bone selector dropdown\r\n     */\r\n    updateBoneSelector() {\r\n        const boneSelector = document.getElementById('equipment-bone-selector');\r\n        if (!boneSelector) return;\r\n        \r\n        boneSelector.innerHTML = '<option value=\"\">Auto-detect</option>';\r\n        \r\n        // Sort bones alphabetically for easier navigation\r\n        const sortedBones = Array.from(this.characterBones.keys()).sort();\r\n        \r\n        sortedBones.forEach(boneName => {\r\n            const option = document.createElement('option');\r\n            option.value = boneName;\r\n            option.textContent = boneName;\r\n            boneSelector.appendChild(option);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Populate item selector dropdown\r\n     */\r\n    populateItemSelector() {\r\n        const itemSelector = document.getElementById('equipment-item-selector');\r\n        if (!itemSelector) return;\r\n        \r\n        // Clear existing options except first\r\n        while (itemSelector.children.length > 1) {\r\n            itemSelector.removeChild(itemSelector.lastChild);\r\n        }\r\n        \r\n        const collections = this.gameEditor.getCollections();\r\n        if (collections.items) {\r\n            Object.keys(collections.items).forEach(itemId => {\r\n                const item = collections.items[itemId];\r\n                const option = document.createElement('option');\r\n                option.value = itemId;\r\n                option.textContent = item.title || itemId;\r\n                itemSelector.appendChild(option);\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle equipment selection\r\n     */\r\n    handleEquipmentSelection(event) {\r\n        const equipmentItem = event.target.closest('.equipment-item');\r\n        if (equipmentItem) {\r\n            const index = parseInt(equipmentItem.dataset.index);\r\n            this.selectEquipment(index);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Select equipment by index\r\n     */\r\n    selectEquipment(index) {\r\n        this.selectedEquipmentIndex = index;\r\n        this.updateEquipmentList();\r\n        this.updateAttachmentControls();\r\n        this.updateSelectedEquipmentDisplay();\r\n        this.highlightSelectedEquipment();\r\n        \r\n        // Show equipment inspector\r\n        const container = document.getElementById('graphics-editor-container');\r\n        if (container) {\r\n            if (index >= 0) {\r\n                container.classList.add('equipment-selected');\r\n            } else {\r\n                container.classList.remove('equipment-selected');\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update selected equipment display\r\n     */\r\n    updateSelectedEquipmentDisplay() {\r\n        const selectedElement = document.getElementById('selected-equipment');\r\n        if (selectedElement) {\r\n            if (this.selectedEquipmentIndex >= 0) {\r\n                const equipment = this.equipmentData[this.selectedEquipmentIndex];\r\n                selectedElement.textContent = equipment ? equipment.item : 'None';\r\n            } else {\r\n                selectedElement.textContent = 'None';\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update attachment controls with selected equipment data\r\n     */\r\n    updateAttachmentControls() {\r\n        if (this.selectedEquipmentIndex < 0) return;\r\n        \r\n        const equipment = this.equipmentData[this.selectedEquipmentIndex];\r\n        const attachmentData = equipment.attachmentData || {};\r\n        \r\n        document.getElementById('equipment-offset-x').value = attachmentData.offset?.x || 0;\r\n        document.getElementById('equipment-offset-y').value = attachmentData.offset?.y || 0;\r\n        document.getElementById('equipment-offset-z').value = attachmentData.offset?.z || 0;\r\n        \r\n        document.getElementById('equipment-rotation-x').value = attachmentData.rotation?.x || 0;\r\n        document.getElementById('equipment-rotation-y').value = attachmentData.rotation?.y || 0;\r\n        document.getElementById('equipment-rotation-z').value = attachmentData.rotation?.z || 0;\r\n        \r\n        document.getElementById('equipment-bone-selector').value = attachmentData.bone || '';\r\n        \r\n        this.updateEquipmentProperties();\r\n    }\r\n    \r\n    /**\r\n     * Set up attachment control event listeners\r\n     */\r\n    setupAttachmentControls() {\r\n        const controls = [\r\n            'equipment-offset-x', 'equipment-offset-y', 'equipment-offset-z',\r\n            'equipment-rotation-x', 'equipment-rotation-y', 'equipment-rotation-z'\r\n        ];\r\n        \r\n        controls.forEach(controlId => {\r\n            const input = document.getElementById(controlId);\r\n            if (input) {\r\n                input.addEventListener('input', this.updateSelectedEquipmentTransform.bind(this));\r\n            }\r\n        });\r\n        \r\n        const boneSelect = document.getElementById('equipment-bone-selector');\r\n        if (boneSelect) {\r\n            boneSelect.addEventListener('change', this.updateSelectedEquipmentBone.bind(this));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update selected equipment transform\r\n     */\r\n    updateSelectedEquipmentTransform() {\r\n        if (this.selectedEquipmentIndex < 0) return;\r\n        \r\n        const equipment = this.equipmentData[this.selectedEquipmentIndex];\r\n        if (!equipment.attachmentData) {\r\n            equipment.attachmentData = {};\r\n        }\r\n        \r\n        // Update offset\r\n        if (!equipment.attachmentData.offset) {\r\n            equipment.attachmentData.offset = {};\r\n        }\r\n        equipment.attachmentData.offset.x = parseFloat(document.getElementById('equipment-offset-x').value) || 0;\r\n        equipment.attachmentData.offset.y = parseFloat(document.getElementById('equipment-offset-y').value) || 0;\r\n        equipment.attachmentData.offset.z = parseFloat(document.getElementById('equipment-offset-z').value) || 0;\r\n        \r\n        // Update rotation\r\n        if (!equipment.attachmentData.rotation) {\r\n            equipment.attachmentData.rotation = {};\r\n        }\r\n        equipment.attachmentData.rotation.x = parseFloat(document.getElementById('equipment-rotation-x').value) || 0;\r\n        equipment.attachmentData.rotation.y = parseFloat(document.getElementById('equipment-rotation-y').value) || 0;\r\n        equipment.attachmentData.rotation.z = parseFloat(document.getElementById('equipment-rotation-z').value) || 0;\r\n        \r\n        // Apply changes to model\r\n        const equipmentData = this.equipmentModels.get(this.selectedEquipmentIndex);\r\n        if (equipmentData) {\r\n            this.applyAttachmentData(equipmentData.model, equipment.attachmentData);\r\n        }        \r\n        this.saveEquipmentData();\r\n    }\r\n    \r\n    /**\r\n     * Update selected equipment bone\r\n     */\r\n    updateSelectedEquipmentBone() {\r\n        if (this.selectedEquipmentIndex < 0) return;\r\n        \r\n        const equipment = this.equipmentData[this.selectedEquipmentIndex];\r\n        const newBoneName = document.getElementById('equipment-bone-selector').value;\r\n        \r\n        if (!equipment.attachmentData) {\r\n            equipment.attachmentData = {};\r\n        }\r\n        equipment.attachmentData.bone = newBoneName;\r\n        \r\n        // Re-attach equipment to new bone\r\n        const equipmentData = this.equipmentModels.get(this.selectedEquipmentIndex);\r\n        if (equipmentData) {\r\n            // Remove from current parent\r\n            if (equipmentData.model.parent) {\r\n                equipmentData.model.parent.remove(equipmentData.model);\r\n            }\r\n            \r\n            // Attach to new bone\r\n            const newBone = this.findAttachmentBone(equipment);\r\n            if (newBone) {\r\n                console.log(`Re-attaching equipment to bone: ${newBone.name}`);\r\n                newBone.add(equipmentData.model);\r\n                equipmentData.bone = newBone;\r\n            } else {\r\n                console.warn('No bone found, adding to root group');\r\n                this.graphicsEditor.rootGroup.add(equipmentData.model);\r\n                equipmentData.bone = null;\r\n            }\r\n        }\r\n        \r\n        this.updateEquipmentList();\r\n        this.saveEquipmentData();\r\n    }\r\n    \r\n    /**\r\n     * Highlight selected equipment in scene\r\n     */\r\n    highlightSelectedEquipment() {\r\n        // Reset all equipment materials\r\n        this.equipmentModels.forEach((equipmentData) => {\r\n            equipmentData.model.traverse(child => {\r\n                if (child.isMesh && child.material) {\r\n                    child.material.emissive.setHex(0x000000);\r\n                }\r\n            });\r\n        });\r\n        \r\n        // Highlight selected equipment\r\n        if (this.selectedEquipmentIndex >= 0) {\r\n            const selectedEquipment = this.equipmentModels.get(this.selectedEquipmentIndex);\r\n            if (selectedEquipment) {\r\n                selectedEquipment.model.traverse(child => {\r\n                    if (child.isMesh && child.material) {\r\n                        child.material.emissive.setHex(0x444444);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update equipment properties panel\r\n     */\r\n    updateEquipmentProperties() {\r\n        const propertiesContainer = document.getElementById('equipment-property-list');\r\n        if (!propertiesContainer) return;\r\n        \r\n        if (this.selectedEquipmentIndex < 0) {\r\n            propertiesContainer.innerHTML = `\r\n                <div style=\"font-size: 0.8em; color: #95a5a6; text-align: center; padding: 20px;\">\r\n                    Select equipment to view properties\r\n                </div>\r\n            `;\r\n            return;\r\n        }\r\n        \r\n        const equipment = this.equipmentData[this.selectedEquipmentIndex];\r\n        const itemData = this.gameEditor.getCollections().items?.[equipment.item];\r\n        const bone = this.findAttachmentBone(equipment);\r\n        \r\n        let propertiesHtml = `\r\n            <div style=\"display: flex; gap: 5px; margin-bottom: 8px; align-items: center;\">\r\n                <label style=\"min-width: 40px; font-size: 0.8em; color: #95a5a6;\">Item:</label>\r\n                <input type=\"text\" value=\"${equipment.item}\" readonly style=\"flex: 1; padding: 4px; background: #1a252f; border: 1px solid #34495e; border-radius: 3px; color: #ecf0f1; font-size: 0.8em;\">\r\n            </div>\r\n            <div style=\"display: flex; gap: 5px; margin-bottom: 8px; align-items: center;\">\r\n                <label style=\"min-width: 40px; font-size: 0.8em; color: #95a5a6;\">Slot:</label>\r\n                <input type=\"text\" value=\"${equipment.slot}\" readonly style=\"flex: 1; padding: 4px; background: #1a252f; border: 1px solid #34495e; border-radius: 3px; color: #ecf0f1; font-size: 0.8em;\">\r\n            </div>\r\n            <div style=\"display: flex; gap: 5px; margin-bottom: 8px; align-items: center;\">\r\n                <label style=\"min-width: 40px; font-size: 0.8em; color: #95a5a6;\">Bone:</label>\r\n                <input type=\"text\" value=\"${bone ? bone.name : 'Not found'}\" readonly style=\"flex: 1; padding: 4px; background: #1a252f; border: 1px solid ${bone ? '#27ae60' : '#e74c3c'}; border-radius: 3px; color: ${bone ? '#27ae60' : '#e74c3c'}; font-size: 0.8em;\">\r\n            </div>\r\n        `;\r\n        \r\n        if (itemData) {\r\n            propertiesHtml += `\r\n                <div style=\"display: flex; gap: 5px; margin-bottom: 8px; align-items: center;\">\r\n                    <label style=\"min-width: 40px; font-size: 0.8em; color: #95a5a6;\">Title:</label>\r\n                    <input type=\"text\" value=\"${itemData.title || equipment.item}\" readonly style=\"flex: 1; padding: 4px; background: #1a252f; border: 1px solid #34495e; border-radius: 3px; color: #ecf0f1; font-size: 0.8em;\">\r\n                </div>\r\n            `;\r\n        }\r\n        \r\n        propertiesHtml += `\r\n            <div style=\"font-size: 0.7em; color: #95a5a6; margin-top: 10px; line-height: 1.3;\">\r\n                Equipment is cosmetic only. Stats are managed on the unit level.\r\n                ${bone ? '' : '<br><span style=\"color: #e74c3c;\"> No attachment bone found</span>'}\r\n            </div>\r\n        `;\r\n        \r\n        propertiesContainer.innerHTML = propertiesHtml;\r\n    }\r\n    \r\n    /**\r\n     * Add new equipment\r\n     */\r\n    addEquipment() {\r\n        const itemSelector = document.getElementById('equipment-item-selector');\r\n        const slotSelector = document.getElementById('equipment-slot-selector');\r\n        \r\n        if (!itemSelector.value || !slotSelector.value) {\r\n            alert('Please select both an item and a slot');\r\n            return;\r\n        }\r\n        \r\n        const newEquipment = {\r\n            slot: slotSelector.value,\r\n            item: itemSelector.value,\r\n            attachmentData: {\r\n                bone: '',\r\n                offset: { x: 0, y: 0, z: 0 },\r\n                rotation: { x: 0, y: 0, z: 0 }\r\n            }\r\n        };\r\n        \r\n        // Initialize equipment array if it doesn't exist\r\n        if (!this.renderData.equipment) {\r\n            this.renderData.equipment = [];\r\n        }\r\n        \r\n        this.equipmentData.push(newEquipment);\r\n        this.renderData.equipment = this.equipmentData;\r\n        \r\n        this.loadSingleEquipmentModel(newEquipment, this.equipmentData.length - 1);\r\n        this.updateEquipmentList();\r\n        this.selectEquipment(this.equipmentData.length - 1);\r\n        this.showEquipmentPanel();\r\n        this.saveEquipmentData();\r\n        \r\n        // Reset selectors\r\n        itemSelector.value = '';\r\n        slotSelector.value = '';\r\n    }\r\n    \r\n    /**\r\n     * Remove selected equipment\r\n     */\r\n    removeSelectedEquipment() {\r\n        if (this.selectedEquipmentIndex < 0) return;\r\n        \r\n        // Remove from 3D scene\r\n        const equipmentData = this.equipmentModels.get(this.selectedEquipmentIndex);\r\n        if (equipmentData && equipmentData.model.parent) {\r\n            equipmentData.model.parent.remove(equipmentData.model);\r\n        }\r\n        \r\n        // Remove from data\r\n        this.equipmentData.splice(this.selectedEquipmentIndex, 1);\r\n        this.renderData.equipment = this.equipmentData;\r\n        this.equipmentModels.delete(this.selectedEquipmentIndex);\r\n        \r\n        // Update models map indices\r\n        const newModelsMap = new Map();\r\n        this.equipmentModels.forEach((data, index) => {\r\n            const newIndex = index > this.selectedEquipmentIndex ? index - 1 : index;\r\n            newModelsMap.set(newIndex, data);\r\n        });\r\n        this.equipmentModels = newModelsMap;\r\n        \r\n        this.selectedEquipmentIndex = -1;\r\n        this.updateEquipmentList();\r\n        this.saveEquipmentData();\r\n        \r\n        // Hide panel if no equipment left\r\n        if (this.equipmentData.length === 0) {\r\n            this.hideEquipmentPanel();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Save equipment data back to the render object\r\n     */\r\n    saveEquipmentData() {\r\n        if (!this.renderData) return;\r\n        this.renderData.equipment = this.equipmentData;\r\n   \r\n        this.graphicsEditor.renderShapes(false);\r\n    }\r\n    clearAllEquipment() {\r\n        // Remove all models from the scene\r\n        this.equipmentModels.forEach((equipmentData) => {\r\n            const { model } = equipmentData;\r\n            if (model && model.parent) {\r\n                model.parent.remove(model);\r\n            }\r\n        });\r\n\r\n        // Reset equipment state\r\n        this.equipmentModels.clear();\r\n        this.equipmentData = [];\r\n        this.selectedEquipmentIndex = -1;\r\n\r\n        // Update UI\r\n        this.updateEquipmentList();\r\n        this.updateEquipmentCount();\r\n        this.updateSelectedEquipmentDisplay();\r\n\r\n        console.log(\"All equipment has been cleared from the scene.\");\r\n    }\r\n    /**\r\n     * Debug method to log bone hierarchy\r\n     */\r\n    debugBoneHierarchy() {\r\n        console.log('=== Bone Hierarchy Debug ===');\r\n        this.characterBones.forEach((bone, name) => {\r\n            console.log(`Bone: ${name}`);\r\n            console.log(`  Position:`, bone.position);\r\n            console.log(`  Parent:`, bone.parent ? bone.parent.name : 'None');\r\n            console.log(`  Children:`, bone.children.length);\r\n            console.log(`  World Position:`, bone.getWorldPosition(new THREE.Vector3()));\r\n        });\r\n        \r\n        console.log('=== Equipment Attachment Status ===');\r\n        this.equipmentModels.forEach((equipmentData, index) => {\r\n            const { model, equipment, bone } = equipmentData;\r\n            console.log(`Equipment ${index}: ${equipment.item}`);\r\n            console.log(`  Slot: ${equipment.slot}`);\r\n            console.log(`  Attached to: ${bone ? bone.name : 'None'}`);\r\n            console.log(`  Model parent: ${model.parent ? model.parent.name : 'None'}`);\r\n            console.log(`  Model position:`, model.position);\r\n            if (bone) {\r\n                console.log(`  Bone world position:`, bone.getWorldPosition(new THREE.Vector3()));\r\n            }\r\n        });\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GE_EquipmentEditor.js"
      },
      "ShapeFactory": {
        "fileName": "ShapeFactory",
        "script": "class ShapeFactory {\r\n    constructor(resourcesPath, palette, textures, libraryClasses, gltfModelScale = 32) {\r\n        this.gltfCache = new Map();\r\n        this.gltfLoader = new THREE_.GLTFLoader();\r\n        this.palette = palette;\r\n        this.textures = textures;\r\n        this.skeleUtils = THREE_.SkeletonUtils;   \r\n        this.urlRoot = \"/\";\r\n        this.resourcesPath = resourcesPath;\r\n        this.gltfModelScale = gltfModelScale; // Add GLTF scale parameter\r\n    }\r\n    \r\n    setURLRoot(root){\r\n        this.urlRoot = root;\r\n    }\r\n\r\n    getResourcesPath(shapeUrl){\r\n        return `${this.urlRoot}${this.resourcesPath}${shapeUrl.replace(this.resourcesPath,'')}`;\r\n    }\r\n    \r\n    setGLTFScale(scale) {\r\n        this.gltfModelScale = scale;\r\n    }\r\n    \r\n    async createMergedGroupFromJSON(model, frameData, groupName) {\r\n        let mergedGroup = this.getMergedGroup(model, frameData, groupName);\r\n        if( mergedGroup){\r\n            return await this.createGroupFromJSON(groupName, mergedGroup);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    async createGroupFromJSON(groupName, groupData) {\r\n        const group = new THREE.Group();\r\n        group.name = groupName;\r\n        group.userData = { isGroup: true };\r\n        // Use Promise.all with map instead of forEach to properly await all shapes\r\n  \r\n        await Promise.all(groupData.shapes.map(async (shape, index) => {\r\n            if (shape.type === 'gltf') {\r\n                await this.handleGLTFShape(shape, index, group);\r\n            } else {\r\n                await this.handlePrimitiveShape(shape, index, group);\r\n            }\r\n        }));\r\n        \r\n        if(groupData.position){            \r\n            group.position.x = groupData.position.x || 0;\r\n            group.position.y = groupData.position.y || 0;\r\n            group.position.z = groupData.position.z || 0;\r\n        }\r\n\r\n        if(groupData.rotation){\r\n            group.rotation.x = groupData.rotation.x || 0;\r\n            group.rotation.y = groupData.rotation.y || 0;\r\n            group.rotation.z = groupData.rotation.z || 0;\r\n        }\r\n\r\n        if(groupData.scale){\r\n            group.scale.x = groupData.scale.x || 1;\r\n            group.scale.y = groupData.scale.y || 1;\r\n            group.scale.z = groupData.scale.z || 1;\r\n        } \r\n        return group;\r\n    }\r\n\r\n    async handleGLTFShape(shape, index, group) {\r\n        const applyTransformations = async (model, gltf) => {\r\n            // Extract animations\r\n            const animations = gltf.animations;\r\n            \r\n            // Apply individual shape transformations first\r\n            model.position.set(\r\n                (shape.position ? shape.position.x : shape.x) || 0, \r\n                (shape.position ? shape.position.y : shape.y) || 0, \r\n                (shape.position ? shape.position.z : shape.z) || 0\r\n            );\r\n            \r\n            // Apply shape-specific scale first, then multiply by global GLTF scale\r\n            const shapeScaleX = (shape.scale ? shape.scale.x : shape.scaleX) || 1;\r\n            const shapeScaleY = (shape.scale ? shape.scale.y : shape.scaleY) || 1;\r\n            const shapeScaleZ = (shape.scale ? shape.scale.z : shape.scaleZ) || 1;\r\n            \r\n            model.scale.set(\r\n                shapeScaleX * this.gltfModelScale,\r\n                shapeScaleY * this.gltfModelScale,\r\n                shapeScaleZ * this.gltfModelScale\r\n            );\r\n            \r\n            model.rotation.set(\r\n                ((shape.rotation ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,\r\n                ((shape.rotation ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,\r\n                ((shape.rotation ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180\r\n            );\r\n\r\n            // Store reference to all bones for equipment attachment\r\n            const modelBones = new Map();\r\n            let skinnedMesh = null;\r\n            let skeleton = null;\r\n\r\n            model.traverse(child => {\r\n                if (child.isMesh) {\r\n                    // Override material with skinning enabled\r\n                    let map = child.material.map;\r\n                    child.material = new THREE.MeshStandardMaterial({\r\n                        color: 0xffffff,\r\n                        metalness: shape.metalness || 0.5,\r\n                        roughness: shape.roughness || 0.5,\r\n                        map: map\r\n                    });                           \r\n                    child.material.alphaTest = 0.1;\r\n                    child.material.needsUpdate = true;\r\n                    child.castShadow = true;\r\n                    child.receiveShadow = true;\r\n                    child.userData = {\r\n                        isShape: true,\r\n                        index: index,\r\n                        isGLTFChild: true\r\n                    };\r\n                    \r\n                    // Check if this is a skinned mesh\r\n                    if (child.isSkinnedMesh) {\r\n                        skinnedMesh = child;\r\n                        skeleton = child.skeleton;\r\n                    }\r\n                }\r\n                \r\n                // Collect all bones for equipment attachment\r\n                if (child.isBone) {\r\n                    modelBones.set(child.name, child);\r\n                    // Mark bone with special userData for identification\r\n                    child.userData.isCharacterBone = true;\r\n                    child.userData.modelIndex = index;\r\n                }\r\n            });\r\n\r\n            // Store skeleton and bone information in model userData\r\n            model.userData = {\r\n                isShape: true,\r\n                index: index,\r\n                isGLTFRoot: true,\r\n                castShadow: true,\r\n                animations: animations,\r\n                bones: modelBones,\r\n                skeleton: skeleton,\r\n                skinnedMesh: skinnedMesh\r\n            };\r\n            group.add(model);\r\n\r\n            if (animations && animations.length > 0) {\r\n                const mixer = new THREE.AnimationMixer(model);\r\n                const action = mixer.clipAction(animations[0]);\r\n                action.play();\r\n\r\n                model.userData.mixer = mixer;\r\n                \r\n                if (skeleton) {\r\n                    model.userData.skeleton = skeleton;\r\n                    // Ensure bones are accessible for equipment attachment\r\n                    skeleton.bones.forEach(bone => {\r\n                        if (!modelBones.has(bone.name)) {\r\n                            modelBones.set(bone.name, bone);\r\n                            bone.userData.isCharacterBone = true;\r\n                            bone.userData.modelIndex = index;\r\n                        }\r\n                    });\r\n                    if (skeleton && animations && animations.length > 0) {\r\n                        const baked = await this.bakeGpuAnimFromModel(model, animations, skeleton, { fps: 30 });\r\n                        model.userData.gpuAnim = baked; // stash VAT + meta on the GLTF root\r\n                    }\r\n                    \r\n                    // Update bones map in userData\r\n                    model.userData.bones = modelBones;\r\n                }\r\n            }         \r\n        };\r\n    \r\n        if (shape.url) {\r\n            const cached = this.gltfCache.get(shape.url);\r\n            if (cached) {\r\n                const clonedScene = this.skeleUtils.clone(cached.scene);\r\n                await applyTransformations(clonedScene, cached);\r\n            } else if (shape.url && location.hostname !== \"\") {\r\n                await new Promise((resolve, reject) => {\r\n                    this.gltfLoader.load(\r\n                        this.getResourcesPath(shape.url),\r\n                        async (gltf) => {\r\n                            const clonedScene = this.skeleUtils.clone(gltf.scene);\r\n                            this.gltfCache.set(shape.url, gltf);\r\n                            await applyTransformations(clonedScene, gltf);\r\n                            resolve();\r\n                        },\r\n                        undefined,\r\n                        (error) => {\r\n                            console.error(`Failed to load GLTF model at ${shape.url}:`, error);\r\n                            reject(error);\r\n                        }\r\n                    );\r\n                });\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    async handlePrimitiveShape(shape, index, group) {\r\n        let geometry, material;\r\n\r\n        let colorToUse = shape.color;\r\n        if(shape.color.paletteColor){\r\n            colorToUse = \"#ffffff\";\r\n            if(this.palette && this.palette[shape.color.paletteColor]){\r\n                colorToUse = this.palette[shape.color.paletteColor];\r\n            }\r\n        }\r\n        if(shape.texture){\r\n            // If a texture is specified, use it instead of the color\r\n            // If a texture is specified, use it instead of the color\r\n            const textureLoader = new THREE.TextureLoader();\r\n                \r\n            const textureData = this.textures[shape.texture];\r\n            \r\n            if( textureData ) {\r\n                const texture = await new Promise((resolve, reject) => {\r\n                    textureLoader.load(\r\n                        textureData.image,\r\n                        (loadedTexture) => {\r\n                            loadedTexture.wrapS = THREE.RepeatWrapping; // Use ClampToEdge instead of RepeatWrapping\r\n                            loadedTexture.wrapT = THREE.RepeatWrapping; // Use RepeatWrapping for vertical repeat\r\n                            loadedTexture.magFilter = THREE.NearestFilter;\r\n                            loadedTexture.minFilter = THREE.NearestFilter;\r\n                            loadedTexture.generateMipmaps = false;\r\n                            loadedTexture.anisotropy = 1;\r\n                            loadedTexture.needsUpdate = true;\r\n\r\n                            const meshWidth = shape.width || 1; // Mesh width in world units\r\n                            const meshHeight = shape.height || 1; // Mesh height in world units\r\n            \r\n                            const textureWidth = loadedTexture.image.width;\r\n                            const textureHeight = loadedTexture.image.height;\r\n                            const pixelsPerUnit = 2;\r\n                            const repeatX = Math.ceil((meshWidth * pixelsPerUnit) / textureWidth);\r\n                            const repeatY = Math.ceil((meshHeight * pixelsPerUnit) / textureHeight);\r\n                            loadedTexture.repeat.set(repeatX, repeatY);\r\n \r\n                            resolve(loadedTexture);\r\n                        },\r\n                        undefined,\r\n                        (error) => reject(error)\r\n                    );\r\n                });\r\n                material = new THREE.MeshStandardMaterial({ map: texture, color: colorToUse });\r\n            } else {                \r\n                material = new THREE.MeshStandardMaterial({ color: colorToUse });\r\n            }\r\n        } else {            \r\n            // Create material with specified color\r\n            material = new THREE.MeshStandardMaterial({ color: colorToUse });\r\n        }\r\n        const shapeSize = shape.size / 32;\r\n        switch (shape.type) {\r\n            case 'sphere':\r\n                geometry = new THREE.SphereGeometry(shapeSize / 2, 32, 32);\r\n                break;\r\n            case 'cube':\r\n                geometry = new THREE.BoxGeometry(shapeSize, shapeSize, shapeSize);\r\n                break;\r\n            case 'box':\r\n                geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);\r\n                break;\r\n            case 'cylinder':\r\n                geometry = new THREE.CylinderGeometry(shapeSize / 2, shapeSize / 2, shape.height, 32);\r\n                break;\r\n            case 'cone':\r\n                geometry = new THREE.ConeGeometry(shapeSize / 2, shape.height, 32);\r\n                break;\r\n            case 'torus':\r\n                geometry = new THREE.TorusGeometry(shapeSize / 2, shape.tubeSize || shapeSize / 6, 16, 100);\r\n                break;\r\n            case 'tetrahedron':\r\n                geometry = new THREE.TetrahedronGeometry(shapeSize / 2);\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n        mesh.userData = { isShape: true, castShadow: true, index: index };\r\n        \r\n        // Position and rotation for primitive shapes (no global scale applied)\r\n        mesh.position.set(\r\n            (shape.position && shape.position.x ? shape.position.x : shape.x) || 0, \r\n            (shape.position && shape.position.y ? shape.position.y : shape.y) || 0, \r\n            (shape.position && shape.position.z ? shape.position.z : shape.z) || 0\r\n        );\r\n        mesh.rotation.set(\r\n            ((shape.rotation && shape.rotation.x ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,\r\n            ((shape.rotation && shape.rotation.y ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,\r\n            ((shape.rotation && shape.rotation.z ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180\r\n        );\r\n        mesh.scale.set(\r\n            (shape.scale && shape.scale.x ? shape.scale.x : shape.scaleX) || 1,\r\n            (shape.scale && shape.scale.y ? shape.scale.y : shape.scaleY) || 1,\r\n            (shape.scale && shape.scale.z ? shape.scale.z : shape.scaleZ) || 1\r\n        );\r\n        \r\n        group.add(mesh);\r\n    }\r\n\r\n    disposeObject(object) {\r\n        object.traverse(child => {\r\n            if (child.geometry) child.geometry.dispose();\r\n            if (child.material) {\r\n                if (Array.isArray(child.material)) {\r\n                    child.material.forEach(m => m.dispose());\r\n                } else {\r\n                    child.material.dispose();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    getMergedGroup(model, frameData, groupName) {\r\n        const modelGroup = model[groupName];\r\n        if (!modelGroup) {\r\n            delete frameData?.[groupName];\r\n            return null;\r\n        }\r\n    \r\n        frameData = frameData || {};\r\n        let frameGroup = this.initializeFrameGroup(frameData, modelGroup, groupName);\r\n        \r\n        this.cleanupMatchingTransforms(modelGroup, frameGroup);\r\n        const mergedShapes = this.mergeShapes(modelGroup, frameGroup);\r\n        \r\n        this.cleanupEmptyShapes(frameGroup);\r\n        \r\n        const mergedGroup = {\r\n            ...modelGroup,\r\n            ...frameGroup,\r\n            shapes: mergedShapes\r\n        };\r\n    \r\n        if (modelGroup.shapes.length === 0) {\r\n            frameGroup.shapes = [];\r\n        }\r\n    \r\n        const returnVal = JSON.parse(JSON.stringify(mergedGroup));\r\n        this.cleanupFrameData(frameData, frameGroup, groupName);\r\n        \r\n        return returnVal;\r\n    }\r\n    \r\n    initializeFrameGroup(frameData, modelGroup, groupName) {\r\n        if (!frameData[groupName]) {\r\n            frameData[groupName] = JSON.parse(JSON.stringify(modelGroup));\r\n            const frameGroup = frameData[groupName];\r\n            frameGroup.shapes.forEach((shape, index) => {\r\n                shape.id = index;\r\n            });\r\n            return frameGroup;\r\n        }\r\n        return frameData[groupName];\r\n    }\r\n    \r\n    cleanupMatchingTransforms(modelGroup, frameGroup) {\r\n        const properties = ['position', 'rotation', 'scale'];\r\n        properties.forEach(prop => {\r\n            if (JSON.stringify(modelGroup[prop]) === JSON.stringify(frameGroup[prop])) {\r\n                delete frameGroup[prop];\r\n            }\r\n        });\r\n    }\r\n    \r\n    mergeShapes(modelGroup, frameGroup) {\r\n        return modelGroup.shapes.map((modelShape, i) => {\r\n            if (!frameGroup.shapes) {\r\n                return JSON.parse(JSON.stringify(modelShape));\r\n            }\r\n    \r\n            let frameShape = frameGroup.shapes.find(shape => shape.id === i) || { id: i };\r\n            if (!frameGroup.shapes.includes(frameShape)) {\r\n                frameGroup.shapes.push(frameShape);\r\n            }\r\n    \r\n            const mergedShape = this.mergeShapeProperties(modelShape, frameShape);\r\n            this.cleanupMatchingShapeTransforms(modelShape, frameShape);\r\n            \r\n            return JSON.parse(JSON.stringify(mergedShape));\r\n        });\r\n    }\r\n    \r\n    mergeShapeProperties(modelShape, frameShape) {\r\n        const mergedShape = {};\r\n        \r\n        for (const key in modelShape) {\r\n            if (key === 'id') continue;\r\n            \r\n            if (frameShape && frameShape[key] !== undefined && modelShape[key] === frameShape[key]) {\r\n                delete frameShape[key];\r\n                mergedShape[key] = modelShape[key];\r\n            } else if (!frameShape || frameShape[key] === undefined) {\r\n                mergedShape[key] = modelShape[key];\r\n            } else {\r\n                mergedShape[key] = frameShape[key];\r\n            }\r\n        }\r\n    \r\n        return { ...mergedShape, ...frameShape };\r\n    }\r\n    \r\n    cleanupMatchingShapeTransforms(modelShape, frameShape) {\r\n        const transforms = [\r\n            { prop: 'scale', defaultVal: 1, axes: ['X', 'Y', 'Z'] },\r\n            { prop: 'rotation', defaultVal: 0, axes: ['X', 'Y', 'Z'] }\r\n        ];\r\n    \r\n        transforms.forEach(({ prop, defaultVal, axes }) => {\r\n            axes.forEach(axis => {\r\n                const propName = `${prop}${axis}`;\r\n                if (frameShape[propName] === modelShape[propName] || \r\n                   (frameShape[propName] === defaultVal && modelShape[propName] === undefined)) {\r\n                    delete frameShape[propName];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    \r\n    cleanupEmptyShapes(frameGroup) {\r\n        if (frameGroup.shapes) {\r\n            frameGroup.shapes = frameGroup.shapes.filter(shape => \r\n                Object.keys(shape).length > 0\r\n            );\r\n            \r\n            if (frameGroup.shapes.length === 0) {\r\n                delete frameGroup.shapes;\r\n            }\r\n        }\r\n    }\r\n    \r\n    cleanupFrameData(frameData, frameGroup, groupName) {\r\n        if (Object.keys(frameGroup).length === 0) {\r\n            delete frameData[groupName];\r\n        }\r\n    }\r\n        // ---- GPU Animation Bake (VAT) ----\r\n    async bakeGpuAnimFromModel(model, animations, skeleton, opts = {}) {\r\n        // opts: { fps=30, useDualQuat=false }  // keep simple: matrices\r\n        const fps = opts.fps ?? 30;\r\n        if (!skeleton || !animations || animations.length === 0) return null;\r\n\r\n        const clips = animations; // THREE.AnimationClip[]\r\n        const bones = skeleton.bones;\r\n        const boneCount = bones.length;\r\n\r\n        // Build meta per clip: {name, frames, duration}\r\n        const perClipMeta = clips.map(clip => {\r\n            const frames = Math.max(1, Math.ceil((clip.duration || 0) * fps));\r\n            return { name: clip.name, duration: clip.duration, frames };\r\n        });\r\n\r\n        // Layout: one big atlas: rows = sum(frames over clips), columns = boneCount * 4 (mat4)\r\n        const totalFrames = perClipMeta.reduce((a, c) => a + c.frames, 0);\r\n        const cols = boneCount * 4;   // 4 texels per bone (mat4 rows)\r\n        const rows = totalFrames;\r\n\r\n        // R32F/RGBA32F: well pack mat4 rows into RGBA floats per texel\r\n        const floatCount = rows * cols * 4; // 4 channels per texel\r\n        const data = new Float32Array(floatCount);\r\n\r\n        const mixer = new THREE.AnimationMixer(model);\r\n        const tmpQuat = new THREE.Quaternion();\r\n        const tmpPos = new THREE.Vector3();\r\n        const tmpScl = new THREE.Vector3();\r\n        const boneM = new THREE.Matrix4();\r\n        const bindI = skeleton.boneInverses;\r\n\r\n        let rowOffset = 0;\r\n        for (let c = 0; c < clips.length; c++) {\r\n            const clip = clips[c];\r\n            const { frames } = perClipMeta[c];\r\n            const action = mixer.clipAction(clip);\r\n            action.play();\r\n\r\n            for (let f = 0; f < frames; f++) {\r\n                const t = (f / Math.max(1, frames - 1)) * (clip.duration || 0);\r\n                mixer.setTime(t);\r\n\r\n                // ensure world/bone matrices are fresh\r\n                model.updateMatrixWorld(true);\r\n                bones.forEach((b) => b.updateMatrixWorld(true));\r\n\r\n                // For each bone: final palette matrix = world * bindInverse (classic skinning)\r\n                for (let b = 0; b < boneCount; b++) {\r\n                    boneM.copy(bones[b].matrixWorld).multiply(bindI[b]);\r\n\r\n                    // write 4 rows (vec4 each) into data\r\n                    // column-major three.js Matrix4 elements\r\n                    const e = boneM.elements; // [n11,n12, ... n44], column-major\r\n                    const baseTexel = ((rowOffset + f) * cols + (b * 4)) * 4;\r\n                    // Row0\r\n                    data[baseTexel + 0] = e[0]; data[baseTexel + 1] = e[4]; data[baseTexel + 2] = e[8];  data[baseTexel + 3] = e[12];\r\n                    // Row1\r\n                    data[baseTexel + 4] = e[1]; data[baseTexel + 5] = e[5]; data[baseTexel + 6] = e[9];  data[baseTexel + 7] = e[13];\r\n                    // Row2\r\n                    data[baseTexel + 8] = e[2]; data[baseTexel + 9] = e[6]; data[baseTexel +10] = e[10]; data[baseTexel +11] = e[14];\r\n                    // Row3\r\n                    data[baseTexel +12] = e[3]; data[baseTexel +13] = e[7]; data[baseTexel +14] = e[11]; data[baseTexel +15] = e[15];\r\n                }\r\n            }\r\n\r\n            rowOffset += frames;\r\n            action.stop();\r\n        }\r\n\r\n        const tex = new THREE.DataTexture(\r\n            data, cols, rows, THREE.RGBAFormat, THREE.FloatType\r\n        );\r\n        tex.needsUpdate = true;\r\n        tex.flipY = false;\r\n\r\n        // clip row ranges\r\n        let acc = 0;\r\n        const clipRows = perClipMeta.map(m => {\r\n            const start = acc;\r\n            const end = acc + m.frames; // exclusive\r\n            acc = end;\r\n            return { name: m.name, start, end, frames: m.frames, duration: m.duration };\r\n        });\r\n\r\n        return {\r\n            texture: tex,\r\n            bones: boneCount,\r\n            rows, cols,\r\n            fps,\r\n            clips: clipRows\r\n        };\r\n    }\r\n\r\n}",
        "filePath": "/global/libraries/js/ShapeFactory.js"
      },
      "TileMap": {
        "fileName": "TileMap",
        "script": "class TileMap {\r\n\r\n  constructor(app, config, { CanvasUtility }) {\r\n   \tthis.app = app;\r\n    this.config = config;\r\n    this.engineClasses = {\r\n \t\t\t\"CanvasUtility\": CanvasUtility\r\n    } \r\n  }\r\n\tinit(canvas, tileSize, layerSpriteSheets, isometric) {\r\n\t\tthis.isometric = isometric;\r\n\t\tthis.canvas = canvas;\r\n\t\tthis.tileSize = tileSize;\r\n\t\tthis.numColumns = 0;\r\n\t\tthis.layerSpriteSheets = layerSpriteSheets;\r\n\t\tthis.tileMap = [];\r\n\t\tthis.layerTextures = [];\r\n\t\tthis.baseAtoms = []; // Store base atoms per terrain type\r\n\t\tthis.canvasUtility = new (this.engineClasses.CanvasUtility)();\r\n\r\n\t\t// Initialize height map canvas\r\n\t\tthis.heightMapCanvas = null;\r\n\t\tthis.heightMapCtx = null;\r\n\t\t\r\n\t\tthis.TileAnalysis = class {\r\n\t\t\tconstructor() {\r\n\t\t\t  this.heightIndex = 0;\r\n\t\t\t  this.neighborLowerCount = 0;\r\n\t\t\t  this.cornerLowerCount = 0;\r\n\t\t\t  this.topHeight = 0;\r\n\t\t\t  this.leftHeight = 0;\r\n\t\t\t  this.rightHeight = 0;\r\n\t\t\t  this.botHeight = 0;\r\n\t\t\t  this.topLeftHeight = 0;\r\n\t\t\t  this.topRightHeight = 0;\r\n\t\t\t  this.botLeftHeight = 0;\r\n\t\t\t  this.botRightHeight = 0;\r\n\t\t\t  this.topLess = false;\r\n\t\t\t  this.leftLess = false;\r\n\t\t\t  this.rightLess = false;\r\n\t\t\t  this.botLess = false;\r\n\t\t\t  this.cornerTopLeftLess = false;\r\n\t\t\t  this.cornerTopRightLess = false;\r\n\t\t\t  this.cornerBottomLeftLess = false;\r\n\t\t\t  this.cornerBottomRightLess = false;\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tthis.TileTransforms = {\r\n\t\t\tNone: 0,\r\n\t\t\tClockWise90: 1,\r\n\t\t\tCounterClockWise90: 2,\r\n\t\t\tRotate180: 3,\r\n\t\t\tFlipHorizontal: 4,\r\n\t\t\tFlipVertical: 5,\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileAtom = {\r\n\t\t\tFull: 0,\r\n\t\t\tOneCorner: 1,\r\n\t\t\tTwoCorner: 2,\r\n\t\t\tThreeCorner: 3,\r\n\t\t\tFullVariation: 4,\r\n\t\t\tOneCornerBot: 5,\r\n\t\t\tTwoCornerBot: 6,\r\n\t\t\tThreeCornerBot: 7\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileMolecule = {\r\n\t\t\tFull: 0,\r\n\t\t\tCorner: 1,\r\n\t\t\tEdge: 2,\r\n\t\t\tTunnel: 3,\r\n\t\t\tTwoSides: 4,\r\n\t\t\tPenninsula: 5,\r\n\t\t\tIsland: 6,\r\n\t\t};\r\n\t\t\r\n\t\tthis.TileCliffMolecules = {\r\n\t\t\tFull: 0,\r\n\t\t\tCornerTL: 1,\r\n\t\t\tCornerTR: 2,\r\n\t\t\tCornerBL: 3,\r\n\t\t\tCornerBR: 4,\r\n\t\t\tEdgeT: 5,\r\n\t\t\tEdgeL: 6,\r\n\t\t\tEdgeR: 7,\r\n\t\t\tEdgeB: 8,\r\n\t\t\tTunnelH: 9,\r\n\t\t\tTunnelV: 10,\r\n\t\t\tTwoSidesTL: 11,\r\n\t\t\tTwoSidesTR: 12,\r\n\t\t\tTwoSidesBL: 13,\r\n\t\t\tTwoSidesBR: 14,    \r\n\t\t\tPenninsulaT: 15,\r\n\t\t\tPenninsulaL: 16,\r\n\t\t\tPenninsulaR: 17,\r\n\t\t\tPenninsulaB: 18,\r\n\t\t\tIsland: 19,\r\n\t\t\tFullVariation: 20, // Added for random full tile variation\r\n\t\t};\r\n\t}\r\n\r\n\tinitializeHeightMapCanvas() {\r\n\t\t// Create height map canvas with same dimensions as main canvas\r\n\t\tthis.heightMapCanvas = document.createElement('canvas');\r\n\t\tthis.heightMapCanvas.width = this.canvas.width;\r\n\t\tthis.heightMapCanvas.height = this.canvas.height;\r\n\t\tthis.heightMapCtx = this.heightMapCanvas.getContext('2d');\r\n\t\t\r\n\t\t// Set properties for better performance when reading pixel data\r\n\t\tthis.heightMapCanvas.setAttribute('willReadFrequently', true);\r\n\t\tthis.heightMapCtx = this.heightMapCanvas.getContext('2d', { willReadFrequently: true });\r\n\t\t\r\n\t\t// Initialize with black (height 0)\r\n\t\tthis.heightMapCtx.fillStyle = 'black';\r\n\t\tthis.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);\r\n\t}\r\n\r\n\tupdateHeightMapForTile(x, y, heightIndex) {\r\n\t\tif (!this.heightMapCtx) return;\r\n\t\t\r\n\t\t// Convert height index to grayscale value (0-255)\r\n\t\t// Assuming we have up to 256 different height levels\r\n\t\tconst heightValue = Math.min(255, Math.max(0, heightIndex * 32)); // Scale as needed\r\n\t\tconst heightColor = `rgb(${heightValue}, ${heightValue}, ${heightValue})`;\r\n\t\t\r\n\t\tthis.heightMapCtx.fillStyle = heightColor;\r\n\t\tthis.heightMapCtx.fillRect(x, y, this.tileSize, this.tileSize);\r\n\t}\r\n\r\n\tgetHeightAtPixel(x, y) {\r\n\t\tif (!this.heightMapCtx) return 0;\r\n\t\t\r\n\t\t// Clamp coordinates to canvas bounds\r\n\t\tx = Math.max(0, Math.min(this.heightMapCanvas.width - 1, Math.floor(x)));\r\n\t\ty = Math.max(0, Math.min(this.heightMapCanvas.height - 1, Math.floor(y)));\r\n\t\t\r\n\t\tconst imageData = this.heightMapCtx.getImageData(x, y, 1, 1);\r\n\t\tconst heightValue = imageData.data[0]; // Red channel (same as green and blue in grayscale)\r\n\t\t\r\n\t\t// Convert back to height index\r\n\t\treturn Math.floor(heightValue / 32); // Inverse of the scaling used in updateHeightMapForTile\r\n\t}\r\n\r\n\tgetHeightMapImageData() {\r\n\t\tif (!this.heightMapCtx) return null;\r\n\t\treturn this.heightMapCtx.getImageData(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);\r\n\t}\r\n\r\n    draw(map, heightMap = null){\r\n\t\tthis.tileMap = map;\r\n\t\tthis.heightMap = heightMap; // NEW: Store heightMap separately\r\n\t\tthis.numColumns = this.tileMap.length;\r\n\r\n\t\t// Initialize height map canvas if not already done\r\n\t\tif (!this.heightMapCanvas) {\r\n\t\t\tthis.initializeHeightMapCanvas();\r\n\t\t}\r\n\r\n\t\t// Clear height map canvas\r\n\t\tthis.heightMapCtx.fillStyle = 'black';\r\n\t\tthis.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);\r\n\r\n\t\t// Load all textures\r\n\t\tif(this.layerTextures.length == 0 && this.layerSpriteSheets) {\r\n\t\t\tthis.layerSpriteSheets.forEach((layerSprites, index) => {\r\n\t\t\t\tconst result = this.buildBaseMolecules(layerSprites.sprites);\r\n\t\t\t\tthis.layerTextures[index] = result.molecules;\r\n\t\t\t\tthis.baseAtoms[index] = result.baseAtoms;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tlet analyzedMap = this.analyzeMap();\r\n\t\tthis.drawMap(analyzedMap);\r\n        if(this.isometric){\r\n          //  this.drawIsometric();\r\n        }\r\n    }\r\n\r\n    drawIsometric() {\r\n        let ctx = this.canvas.getContext('2d');\r\n        // Save the original state\r\n        ctx.save();\r\n        \r\n        // Create an off-screen canvas to hold original drawing\r\n        const offscreen = document.createElement('canvas');\r\n        offscreen.width = this.canvas.width;\r\n        offscreen.height = this.canvas.height;\r\n        const offCtx = offscreen.getContext('2d');\r\n        offCtx.drawImage(this.canvas, 0, 0);\r\n        \r\n        // Clear the main canvas\r\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Move to center for rotation\r\n        ctx.translate(this.canvas.width / 2, this.canvas.height / 2);\r\n        \r\n        // Apply isometric transformation\r\n        const scale = .56;    // Adjust overall size\r\n        const isoAngle = Math.atan(1 / 2); //  26.565 (classic isometric angle)\r\n        const cosA = Math.cos(isoAngle);   //  0.8944\r\n        const sinA = Math.sin(isoAngle);   //  0.4472\r\n        \r\n        ctx.transform(\r\n            cosA * scale,    // scaleX\r\n            sinA * scale,    // skewY\r\n            -cosA * scale,   // skewX\r\n            sinA * scale,    // scaleY\r\n            0,               // translateX\r\n            0                // translateY\r\n        );\r\n        \r\n        // Draw the transformed image centered\r\n        ctx.drawImage(offscreen, -this.canvas.width / 2, -this.canvas.height / 2);\r\n        \r\n        // Restore original state\r\n        ctx.restore();\r\n    }\r\n\r\n    drawTexture(texture, x, y) {\r\n\t\tctx.drawImage(texture, x, y, this.tileSize / 2, this.tileSize / 2); // Assuming each atom is 256x256\r\n    }\r\n\r\n    // Function to generate a molecule texture for various molecule ty\r\n\tbuildBaseMolecules(sprites) {\r\n\t\t// Define texture objects\r\n\t\tconst fullTexture = document.createElement(\"canvas\");\r\n\r\n\t\tconst oneCornerTexture = document.createElement(\"canvas\");\r\n\t\tconst twoCornerTexture = document.createElement(\"canvas\");\r\n\t\tconst threeCornerTexture = document.createElement(\"canvas\");\r\n\r\n\t\tconst oneCornerBotTexture = document.createElement(\"canvas\");\r\n\t\tconst twoCornerBotTexture = document.createElement(\"canvas\");\r\n\t\tconst threeCornerBotTexture = document.createElement(\"canvas\");\r\n\r\n\t\tfullTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\toneCornerTexture.setAttribute('willReadFrequently', true); \r\n\t\ttwoCornerTexture.setAttribute('willReadFrequently', true); \r\n\t\tthreeCornerTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\toneCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\t\ttwoCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\t\tthreeCornerBotTexture.setAttribute('willReadFrequently', true); \r\n\r\n\t\t// Set the texture sizes\r\n\t\tconst spriteResolution = this.tileSize / 2;\r\n\t\tconst finalTileBaseResolution = spriteResolution * 2;\r\n\r\n\t\tfullTexture.width = spriteResolution;\r\n\t\tfullTexture.height = spriteResolution;\r\n\r\n\t\toneCornerTexture.width = spriteResolution;\r\n\t\toneCornerTexture.height = spriteResolution;\r\n\r\n\t\ttwoCornerTexture.width = spriteResolution;\r\n\t\ttwoCornerTexture.height = spriteResolution;\r\n\r\n\t\tthreeCornerTexture.width = spriteResolution;\r\n\t\tthreeCornerTexture.height = spriteResolution;\t\r\n\r\n\t\toneCornerBotTexture.width = spriteResolution;\r\n\t\toneCornerBotTexture.height = spriteResolution;\t\r\n\r\n\t\ttwoCornerBotTexture.width = spriteResolution;\r\n\t\ttwoCornerBotTexture.height = spriteResolution;\t\r\n\r\n\t\tthreeCornerBotTexture.width = spriteResolution;\r\n\t\tthreeCornerBotTexture.height = spriteResolution;\t\r\n\t\t\r\n\t\t// Get sprite textures\r\n\t\tconst fullSprite = sprites[this.TileAtom.Full];\r\n\t\tconst fullVariationSprite = sprites[this.TileAtom.FullVariation]; // Sprite 4\r\n\r\n\t\tconst oneCornerSprite = sprites[this.TileAtom.OneCorner];\r\n\t\tconst twoCornerSprite = sprites[this.TileAtom.TwoCorner];\r\n\t\tconst threeCornerSprite = sprites[this.TileAtom.ThreeCorner];\r\n\r\n\t\tconst oneCornerBotSprite = sprites[this.TileAtom.OneCornerBot];\r\n\t\tconst twoCornerBotSprite = sprites[this.TileAtom.TwoCornerBot];\r\n\t\tconst threeCornerBotSprite = sprites[this.TileAtom.ThreeCornerBot];\r\n\r\n\t\t// Create CanvasRenderingContext2D objects for each texture\r\n\t\tconst fullCtx = fullTexture.getContext(\"2d\");\r\n\t\tconst fullVariationTexture = document.createElement(\"canvas\");\r\n\t\tfullVariationTexture.width = spriteResolution;\r\n\t\tfullVariationTexture.height = spriteResolution;\r\n\t\tfullVariationTexture.setAttribute('willReadFrequently', true);\r\n\t\tconst fullVariationCtx = fullVariationTexture.getContext(\"2d\");\r\n\r\n\t\tconst oneCornerCtx = oneCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst twoCornerCtx = twoCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst threeCornerCtx = threeCornerTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\r\n\t\tconst oneCornerBotCtx = oneCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst twoCornerBotCtx = twoCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\tconst threeCornerBotCtx = threeCornerBotTexture.getContext(\"2d\", { willReadFrequently: true });\r\n\t\t\r\n\t\t// Copy pixels from sprites to texture canvases\r\n\t\tfullCtx.drawImage(fullSprite,0,0);\r\n\t\tfullVariationCtx.drawImage(fullVariationSprite,0,0);\r\n\r\n\t\toneCornerCtx.drawImage(oneCornerSprite,0,0);\r\n\t\ttwoCornerCtx.drawImage(twoCornerSprite,0,0);\r\n\t\tthreeCornerCtx.drawImage(threeCornerSprite,0,0);\r\n\r\n\t\toneCornerBotCtx.drawImage(oneCornerBotSprite,0,0);\r\n\t\ttwoCornerBotCtx.drawImage(twoCornerBotSprite,0,0);\r\n\t\tthreeCornerBotCtx.drawImage(threeCornerBotSprite,0,0);\r\n\r\n\t\t// Get pixel data from the canvases\r\n\t\tconst fullImageData = fullCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst fullVariationImageData = fullVariationCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerTopRightImageData = oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerTopLeftImageData = this.flipTextureHorizontal(oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));\t\r\n\r\n\t\tconst oneCornerBotRightImageData = oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst oneCornerBotLeftImageData = this.flipTextureHorizontal(oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));\t\r\n\t\t\r\n\t\tconst twoCornerTopImageData = twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst twoCornerLeftImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), -Math.PI / 2);\r\n\t\tconst twoCornerRightImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), Math.PI / 2);\r\n\t\tconst twoCornerBottomImageData = twoCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\t\r\n\t\tconst threeCornerTopRightImageData = threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst threeCornerTopLeftImageData = this.flipTextureHorizontal(threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));\r\n\t\tconst threeCornerBottomRightImageData = threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);\r\n\t\tconst threeCornerBottomLeftImageData = this.flipTextureHorizontal(threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));\r\n\r\n\t\t// Store base atoms for acute corner handling (will be returned, not stored here)\r\n\t\tconst baseAtoms = {\r\n\t\t\tfull: fullImageData,\r\n\t\t\tfullVariation: fullVariationImageData,\r\n\t\t\toneCornerTL: oneCornerTopLeftImageData,\r\n\t\t\toneCornerTR: oneCornerTopRightImageData,\r\n\t\t\toneCornerBL: oneCornerBotLeftImageData,\r\n\t\t\toneCornerBR: oneCornerBotRightImageData,\r\n\t\t\ttwoCornerTop: twoCornerTopImageData,\r\n\t\t\ttwoCornerLeft: twoCornerLeftImageData,\r\n\t\t\ttwoCornerRight: twoCornerRightImageData,\r\n\t\t\ttwoCornerBottom: twoCornerBottomImageData,\r\n\t\t\tthreeCornerTL: threeCornerTopLeftImageData,\r\n\t\t\tthreeCornerTR: threeCornerTopRightImageData,\r\n\t\t\tthreeCornerBL: threeCornerBottomLeftImageData,\r\n\t\t\tthreeCornerBR: threeCornerBottomRightImageData\r\n\t\t};\r\n\r\n\t\t// Define molecule objects\r\n\t\tconst moleculeCanvas = document.createElement(\"canvas\");\r\n\r\n\t\tmoleculeCanvas.width = finalTileBaseResolution;\r\n\t\tmoleculeCanvas.height = finalTileBaseResolution;\r\n\t\t\r\n\t\tconst moleculeCtx = moleculeCanvas.getContext('2d', { willReadFrequently: true });\r\n\r\n\t\tconst cornerCanvas = document.createElement(\"canvas\");\r\n\r\n\t\tcornerCanvas.width = finalTileBaseResolution / 2;\r\n\t\tcornerCanvas.height = finalTileBaseResolution / 2;\r\n\t\t\r\n\t\tconst cornerCtx = cornerCanvas.getContext('2d', { willReadFrequently: true });\r\n\r\n\t\tvar imageDataList = [\r\n\t\t\t//FULL\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, fullImageData, fullImageData, fullImageData),\r\n\r\n\t\t\t//CORNERS\r\n\t\t\toneCornerTopLeftImageData, \r\n\t\t\toneCornerTopRightImageData,\r\n\t\t\toneCornerBotLeftImageData,\r\n\t\t\toneCornerBotRightImageData,\r\n\t\t\t//EDGES\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, fullImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, twoCornerLeftImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, fullImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, fullImageData, twoCornerBottomImageData, twoCornerBottomImageData),\r\n\r\n\t\t\t//TUNNELS\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, twoCornerBottomImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, twoCornerLeftImageData, twoCornerRightImageData),\r\n\r\n\t\t\t//TWO SIDES\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, twoCornerLeftImageData, fullImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, fullImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),\r\n\r\n\t\t\t//PENNINSULAS\t\t\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, twoCornerLeftImageData, twoCornerRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),\r\n\t\t\tthis.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),\r\n\r\n\t\t\t//ISLAND\r\n\t\t\tthis.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),\r\n\r\n\t\t\t//FULL VARIATION (sprite 4)\r\n\t\t\tthis.createMolecule(moleculeCtx, fullVariationImageData, fullVariationImageData, fullVariationImageData, fullVariationImageData),\r\n\t\t];\r\n\r\n\t\treturn { molecules: imageDataList, baseAtoms: baseAtoms };\r\n\t}\r\n\r\n\tcreateMolecule(context, TLImageData, TRImageData, BLImageData, BRImageData) {\r\n\t\tlet size = context.canvas.width;\r\n\t\tlet spriteResolution = size / 2;\r\n\t\tcontext.fillStyle = 'black';\r\n\t\tcontext.fillRect(0, 0, size, size);\r\n\t\tcontext.putImageData(TLImageData, 0, 0);\r\n\t\tcontext.putImageData(TRImageData, spriteResolution, 0);\r\n\t\tcontext.putImageData(BLImageData, 0, spriteResolution);\r\n\t\tcontext.putImageData(BRImageData, spriteResolution, spriteResolution);\r\n\t\treturn context.getImageData(0, 0, size, size);\r\n\t}\r\n\r\n\t// Extract individual atoms from a molecule ImageData\r\n\textractAtomsFromMolecule(moleculeImageData) {\r\n\t\tconst atomSize = this.tileSize / 2;\r\n\t\tconst canvas = document.createElement('canvas');\r\n\t\tcanvas.width = this.tileSize;\r\n\t\tcanvas.height = this.tileSize;\r\n\t\tconst ctx = canvas.getContext('2d');\r\n\r\n\t\t// Draw the molecule onto canvas\r\n\t\tctx.putImageData(moleculeImageData, 0, 0);\r\n\r\n\t\t// Extract each atom\r\n\t\treturn {\r\n\t\t\tTL: ctx.getImageData(0, 0, atomSize, atomSize),\r\n\t\t\tTR: ctx.getImageData(atomSize, 0, atomSize, atomSize),\r\n\t\t\tBL: ctx.getImageData(0, atomSize, atomSize, atomSize),\r\n\t\t\tBR: ctx.getImageData(atomSize, atomSize, atomSize, atomSize)\r\n\t\t};\r\n\t}\r\n\r\n\t// Select the correct atom for a specific position based on neighbor analysis\r\n\tselectAtomForPosition(tile, position, terrainIndex) {\r\n\t\tconst analysis = tile.terrainAnalysis;\r\n\t\tconst atoms = this.baseAtoms[terrainIndex];\r\n\r\n\t\tif (!atoms) return null;\r\n\r\n\t\t// For each position, check diagonal and adjacent cardinals to determine atom type\r\n\t\tswitch(position) {\r\n\t\t\tcase 'TL': {\r\n\t\t\t\t// Top-left atom: check top, left, and top-left diagonal\r\n\t\t\t\tconst diagonalLess = analysis.cornerTopLeftLess;\r\n\t\t\t\tconst topLess = analysis.topLess;\r\n\t\t\t\tconst leftLess = analysis.leftLess;\r\n\r\n\t\t\t\tif (diagonalLess && !topLess && !leftLess) {\r\n\t\t\t\t\t// Only diagonal is lower: use oneCorner with TL corner cut\r\n\t\t\t\t\treturn atoms.oneCornerTL;\r\n\t\t\t\t} else if (!topLess && !leftLess) {\r\n\t\t\t\t\t// No neighbors lower: use full atom\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Cardinal neighbors are lower: handled by molecule logic\r\n\t\t\t\t\treturn null; // Will use molecule-based atom\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'TR': {\r\n\t\t\t\t// Top-right atom: check top, right, and top-right diagonal\r\n\t\t\t\tconst diagonalLess = analysis.cornerTopRightLess;\r\n\t\t\t\tconst topLess = analysis.topLess;\r\n\t\t\t\tconst rightLess = analysis.rightLess;\r\n\r\n\t\t\t\tif (diagonalLess && !topLess && !rightLess) {\r\n\t\t\t\t\t// Only diagonal is lower: use oneCorner with TR corner cut\r\n\t\t\t\t\treturn atoms.oneCornerTR;\r\n\t\t\t\t} else if (!topLess && !rightLess) {\r\n\t\t\t\t\t// No neighbors lower: use full atom\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null; // Will use molecule-based atom\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'BL': {\r\n\t\t\t\t// Bottom-left atom: check bottom, left, and bottom-left diagonal\r\n\t\t\t\tconst diagonalLess = analysis.cornerBottomLeftLess;\r\n\t\t\t\tconst botLess = analysis.botLess;\r\n\t\t\t\tconst leftLess = analysis.leftLess;\r\n\r\n\t\t\t\tif (diagonalLess && !botLess && !leftLess) {\r\n\t\t\t\t\t// Only diagonal is lower: use oneCorner with BL corner cut\r\n\t\t\t\t\treturn atoms.oneCornerBL;\r\n\t\t\t\t} else if (!botLess && !leftLess) {\r\n\t\t\t\t\t// No neighbors lower: use full atom\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null; // Will use molecule-based atom\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'BR': {\r\n\t\t\t\t// Bottom-right atom: check bottom, right, and bottom-right diagonal\r\n\t\t\t\tconst diagonalLess = analysis.cornerBottomRightLess;\r\n\t\t\t\tconst botLess = analysis.botLess;\r\n\t\t\t\tconst rightLess = analysis.rightLess;\r\n\r\n\t\t\t\tif (diagonalLess && !botLess && !rightLess) {\r\n\t\t\t\t\t// Only diagonal is lower: use oneCorner with BR corner cut\r\n\t\t\t\t\treturn atoms.oneCornerBR;\r\n\t\t\t\t} else if (!botLess && !rightLess) {\r\n\t\t\t\t\t// No neighbors lower: use full atom\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn null; // Will use molecule-based atom\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// Select base layer atom based on which neighbors are even lower\r\n\tselectBaseLayerAtom(atoms, position, miniAnalysis) {\r\n\t\tif (!atoms) return null;\r\n\r\n\t\tswitch(position) {\r\n\t\t\tcase 'TL': {\r\n\t\t\t\tconst diagonal = miniAnalysis.cornerTopLeftLess;\r\n\t\t\t\tconst top = miniAnalysis.topLess;\r\n\t\t\t\tconst left = miniAnalysis.leftLess;\r\n\r\n\t\t\t\t// Check how many neighbors are lower\r\n\t\t\t\tif (top && left) {\r\n\t\t\t\t\treturn atoms.threeCornerTL; // Both cardinals lower: 3 corners cut\r\n\t\t\t\t} else if (top && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerTop; // Top edge + corner\r\n\t\t\t\t} else if (left && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerLeft; // Left edge + corner\r\n\t\t\t\t} else if (top) {\r\n\t\t\t\t\treturn atoms.twoCornerTop; // Just top edge (no diagonal)\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\treturn atoms.twoCornerLeft; // Just left edge (no diagonal)\r\n\t\t\t\t} else if (diagonal) {\r\n\t\t\t\t\treturn atoms.oneCornerTL; // Just corner\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn atoms.full; // No neighbors lower\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'TR': {\r\n\t\t\t\tconst diagonal = miniAnalysis.cornerTopRightLess;\r\n\t\t\t\tconst top = miniAnalysis.topLess;\r\n\t\t\t\tconst right = miniAnalysis.rightLess;\r\n\r\n\t\t\t\tif (top && right) {\r\n\t\t\t\t\treturn atoms.threeCornerTR;\r\n\t\t\t\t} else if (top && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerTop;\r\n\t\t\t\t} else if (right && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerRight;\r\n\t\t\t\t} else if (top) {\r\n\t\t\t\t\treturn atoms.twoCornerTop; // Just top edge\r\n\t\t\t\t} else if (right) {\r\n\t\t\t\t\treturn atoms.twoCornerRight; // Just right edge\r\n\t\t\t\t} else if (diagonal) {\r\n\t\t\t\t\treturn atoms.oneCornerTR;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'BL': {\r\n\t\t\t\tconst diagonal = miniAnalysis.cornerBottomLeftLess;\r\n\t\t\t\tconst bot = miniAnalysis.botLess;\r\n\t\t\t\tconst left = miniAnalysis.leftLess;\r\n\r\n\t\t\t\tif (bot && left) {\r\n\t\t\t\t\treturn atoms.threeCornerBL;\r\n\t\t\t\t} else if (bot && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerBottom;\r\n\t\t\t\t} else if (left && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerLeft;\r\n\t\t\t\t} else if (bot) {\r\n\t\t\t\t\treturn atoms.twoCornerBottom; // Just bottom edge\r\n\t\t\t\t} else if (left) {\r\n\t\t\t\t\treturn atoms.twoCornerLeft; // Just left edge\r\n\t\t\t\t} else if (diagonal) {\r\n\t\t\t\t\treturn atoms.oneCornerBL;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcase 'BR': {\r\n\t\t\t\tconst diagonal = miniAnalysis.cornerBottomRightLess;\r\n\t\t\t\tconst bot = miniAnalysis.botLess;\r\n\t\t\t\tconst right = miniAnalysis.rightLess;\r\n\r\n\t\t\t\tif (bot && right) {\r\n\t\t\t\t\treturn atoms.threeCornerBR;\r\n\t\t\t\t} else if (bot && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerBottom;\r\n\t\t\t\t} else if (right && diagonal) {\r\n\t\t\t\t\treturn atoms.twoCornerRight;\r\n\t\t\t\t} else if (bot) {\r\n\t\t\t\t\treturn atoms.twoCornerBottom; // Just bottom edge\r\n\t\t\t\t} else if (right) {\r\n\t\t\t\t\treturn atoms.twoCornerRight; // Just right edge\r\n\t\t\t\t} else if (diagonal) {\r\n\t\t\t\t\treturn atoms.oneCornerBR;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn atoms.full;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn atoms.full;\r\n\t}\r\n\r\n\t// Paint base layer with lower neighbor textures to fill gaps\r\n\tpaintBaseLowerLayer(ctx, analyzedMap, tile, row, col) {\r\n\t\tconst atomSize = this.tileSize / 2;\r\n\r\n\t\t// For each atom position, check neighboring tile terrains and build appropriate base\r\n\t\tconst positions = [\r\n\t\t\t{\r\n\t\t\t\tname: 'TL', x: 0, y: 0,\r\n\t\t\t\t// Tiles that affect TL atom\r\n\t\t\t\ttileNeighbors: [\r\n\t\t\t\t\t{ dir: 'topLeft', row: row - 1, col: col - 1 },\r\n\t\t\t\t\t{ dir: 'top', row: row - 1, col: col },\r\n\t\t\t\t\t{ dir: 'left', row: row, col: col - 1 }\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tname: 'TR', x: atomSize, y: 0,\r\n\t\t\t\t// Tiles that affect TR atom\r\n\t\t\t\ttileNeighbors: [\r\n\t\t\t\t\t{ dir: 'topRight', row: row - 1, col: col + 1 },\r\n\t\t\t\t\t{ dir: 'top', row: row - 1, col: col },\r\n\t\t\t\t\t{ dir: 'right', row: row, col: col + 1 }\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tname: 'BL', x: 0, y: atomSize,\r\n\t\t\t\t// Tiles that affect BL atom\r\n\t\t\t\ttileNeighbors: [\r\n\t\t\t\t\t{ dir: 'botLeft', row: row + 1, col: col - 1 },\r\n\t\t\t\t\t{ dir: 'bot', row: row + 1, col: col },\r\n\t\t\t\t\t{ dir: 'left', row: row, col: col - 1 }\r\n\t\t\t\t]\r\n\t\t\t},\r\n\t\t\t{\r\n\t\t\t\tname: 'BR', x: atomSize, y: atomSize,\r\n\t\t\t\t// Tiles that affect BR atom\r\n\t\t\t\ttileNeighbors: [\r\n\t\t\t\t\t{ dir: 'botRight', row: row + 1, col: col + 1 },\r\n\t\t\t\t\t{ dir: 'bot', row: row + 1, col: col },\r\n\t\t\t\t\t{ dir: 'right', row: row, col: col + 1 }\r\n\t\t\t\t]\r\n\t\t\t}\r\n\t\t];\r\n\r\n\t\t// Paint base layer for each atom position\r\n\t\tfor (const pos of positions) {\r\n\t\t\t// Get terrain indices of neighboring tiles\r\n\t\t\tconst neighborTerrains = {};\r\n\t\t\tfor (const neighbor of pos.tileNeighbors) {\r\n\t\t\t\tconst nRow = neighbor.row;\r\n\t\t\t\tconst nCol = neighbor.col;\r\n\r\n\t\t\t\tif (nRow >= 0 && nRow < this.numColumns && nCol >= 0 && nCol < this.numColumns) {\r\n\t\t\t\t\tconst nIndex = nRow * this.numColumns + nCol;\r\n\t\t\t\t\tconst nTile = analyzedMap[nIndex];\r\n\t\t\t\t\tif (nTile && nTile.terrainIndex >= 0) {\r\n\t\t\t\t\t\tneighborTerrains[neighbor.dir] = nTile.terrainIndex;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Find ALL unique terrain indices that are lower than current\r\n\t\t\tconst lowerTerrains = new Set();\r\n\t\t\tfor (const dir in neighborTerrains) {\r\n\t\t\t\tconst terrain = neighborTerrains[dir];\r\n\t\t\t\tif (terrain < tile.terrainIndex) {\r\n\t\t\t\t\tlowerTerrains.add(terrain);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Sort terrains from lowest to highest for proper layering\r\n\t\t\tconst sortedTerrains = Array.from(lowerTerrains).sort((a, b) => a - b);\r\n\r\n\t\t\t// Map position-specific neighbors to analysis flags\r\n\t\t\tconst neighborMapping = {\r\n\t\t\t\t'TL': {\r\n\t\t\t\t\ttopLeft: 'cornerTopLeftLess',\r\n\t\t\t\t\ttop: 'topLess',\r\n\t\t\t\t\tleft: 'leftLess'\r\n\t\t\t\t},\r\n\t\t\t\t'TR': {\r\n\t\t\t\t\ttopRight: 'cornerTopRightLess',\r\n\t\t\t\t\ttop: 'topLess',\r\n\t\t\t\t\tright: 'rightLess'\r\n\t\t\t\t},\r\n\t\t\t\t'BL': {\r\n\t\t\t\t\tbotLeft: 'cornerBottomLeftLess',\r\n\t\t\t\t\tbot: 'botLess',\r\n\t\t\t\t\tleft: 'leftLess'\r\n\t\t\t\t},\r\n\t\t\t\t'BR': {\r\n\t\t\t\t\tbotRight: 'cornerBottomRightLess',\r\n\t\t\t\t\tbot: 'botLess',\r\n\t\t\t\t\tright: 'rightLess'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\t// Paint each terrain layer from lowest to highest\r\n\t\t\tfor (let i = 0; i < sortedTerrains.length; i++) {\r\n\t\t\t\tconst currentLayerTerrain = sortedTerrains[i];\r\n\r\n\t\t\t\tif (!this.baseAtoms[currentLayerTerrain]) continue;\r\n\r\n\t\t\t\t// Build mini-analysis: check which neighbors are lower than THIS layer\r\n\t\t\t\tconst miniAnalysis = {\r\n\t\t\t\t\ttopLess: false,\r\n\t\t\t\t\tleftLess: false,\r\n\t\t\t\t\trightLess: false,\r\n\t\t\t\t\tbotLess: false,\r\n\t\t\t\t\tcornerTopLeftLess: false,\r\n\t\t\t\t\tcornerTopRightLess: false,\r\n\t\t\t\t\tcornerBottomLeftLess: false,\r\n\t\t\t\t\tcornerBottomRightLess: false\r\n\t\t\t\t};\r\n\r\n\t\t\t\tconst mapping = neighborMapping[pos.name];\r\n\t\t\t\tfor (const dir in neighborTerrains) {\r\n\t\t\t\t\tif (mapping[dir] && neighborTerrains[dir] < currentLayerTerrain) {\r\n\t\t\t\t\t\tminiAnalysis[mapping[dir]] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Select appropriate atom for this layer\r\n\t\t\t\tconst layerAtom = this.selectBaseLayerAtom(\r\n\t\t\t\t\tthis.baseAtoms[currentLayerTerrain],\r\n\t\t\t\t\tpos.name,\r\n\t\t\t\t\tminiAnalysis\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif (layerAtom) {\r\n\t\t\t\t\tif (i === 0) {\r\n\t\t\t\t\t\t// First layer: use putImageData (on black background)\r\n\t\t\t\t\t\tctx.putImageData(layerAtom, pos.x, pos.y);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Subsequent layers: use drawImage for alpha blending\r\n\t\t\t\t\t\tconst atomCanvas = this.imageDataToCanvas(layerAtom);\r\n\t\t\t\t\t\tctx.drawImage(atomCanvas, pos.x, pos.y);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Convert ImageData to a canvas for proper alpha blending\r\n\timageDataToCanvas(imageData) {\r\n\t\tconst canvas = document.createElement('canvas');\r\n\t\tcanvas.width = imageData.width;\r\n\t\tcanvas.height = imageData.height;\r\n\t\tconst ctx = canvas.getContext('2d');\r\n\t\tctx.putImageData(imageData, 0, 0);\r\n\t\treturn canvas;\r\n\t}\r\n\r\n\t// Draw a single tile with proper atom layering for smooth transitions\r\n\tdrawTileWithLayering(analyzedMap, tile, row, col) {\r\n\t\tconst atomSize = this.tileSize / 2;\r\n\t\tconst canvas = document.createElement('canvas');\r\n\t\tcanvas.width = this.tileSize;\r\n\t\tcanvas.height = this.tileSize;\r\n\t\tconst ctx = canvas.getContext('2d');\r\n\r\n\t\t// Fill with black background\r\n\t\tctx.fillStyle = 'black';\r\n\t\tctx.fillRect(0, 0, this.tileSize, this.tileSize);\r\n\r\n\t\t// Paint base layer with lower neighbor textures first\r\n\t\tthis.paintBaseLowerLayer(ctx, analyzedMap, tile, row, col);\r\n\r\n\t\t// Build custom molecule based on diagonal-aware atom selection\r\n\t\tconst atoms = {\r\n\t\t\tTL: this.selectAtomForPosition(tile, 'TL', tile.terrainIndex),\r\n\t\t\tTR: this.selectAtomForPosition(tile, 'TR', tile.terrainIndex),\r\n\t\t\tBL: this.selectAtomForPosition(tile, 'BL', tile.terrainIndex),\r\n\t\t\tBR: this.selectAtomForPosition(tile, 'BR', tile.terrainIndex)\r\n\t\t};\r\n\r\n\t\t// If any atom is null, fall back to molecule-based extraction\r\n\t\tconst molecule = this.getMoleculeByTileAnalysis(tile.terrainAnalysis);\r\n\t\tconst moleculeImageData = this.layerTextures[tile.terrainIndex][molecule];\r\n\t\tconst moleculeAtoms = this.extractAtomsFromMolecule(moleculeImageData);\r\n\r\n\t\t// Use custom atoms where available, otherwise use molecule atoms\r\n\t\tconst currentAtoms = {\r\n\t\t\tTL: atoms.TL || moleculeAtoms.TL,\r\n\t\t\tTR: atoms.TR || moleculeAtoms.TR,\r\n\t\t\tBL: atoms.BL || moleculeAtoms.BL,\r\n\t\t\tBR: atoms.BR || moleculeAtoms.BR\r\n\t\t};\r\n\r\n\t\t// Convert atoms to canvases and use drawImage for proper alpha blending\r\n\t\tconst atomCanvases = {\r\n\t\t\tTL: this.imageDataToCanvas(currentAtoms.TL),\r\n\t\t\tTR: this.imageDataToCanvas(currentAtoms.TR),\r\n\t\t\tBL: this.imageDataToCanvas(currentAtoms.BL),\r\n\t\t\tBR: this.imageDataToCanvas(currentAtoms.BR)\r\n\t\t};\r\n\r\n\t\t// Draw each atom using drawImage (respects alpha blending)\r\n\t\tctx.drawImage(atomCanvases.TL, 0, 0);\r\n\t\tctx.drawImage(atomCanvases.TR, atomSize, 0);\r\n\t\tctx.drawImage(atomCanvases.BL, 0, atomSize);\r\n\t\tctx.drawImage(atomCanvases.BR, atomSize, atomSize);\r\n\r\n\t\t// Apply coloring and corner graphics\r\n\t\tlet imageData = ctx.getImageData(0, 0, this.tileSize, this.tileSize);\r\n\t\timageData = this.colorImageData(imageData, tile.terrainAnalysis, tile.terrainIndex);\r\n\t\timageData = this.addCornerGraphics(imageData, tile.heightAnalysis, tile.terrainIndex);\r\n\r\n\t\treturn imageData;\r\n\t}\r\n\r\n\textractSpritesFromSheet(spriteSheet, columns, rows) {\r\n\t\tlet sprites = [];\r\n\t\tlet spriteWidth = spriteSheet.width / columns;\r\n\t\tlet spriteHeight = spriteSheet.height / rows;\r\n\t\r\n\t\tfor (let y = 0; y < rows; y++) {\r\n\t\t\tfor (let x = 0; x < columns; x++) {\r\n\t\t\t\tlet canvas = document.createElement('canvas');\r\n\t\t\t\tcanvas.width = spriteWidth;\r\n\t\t\t\tcanvas.height = spriteHeight;\r\n\t\t\t\tlet context = canvas.getContext('2d');\r\n\t\t\t\tcontext.drawImage(spriteSheet, x * spriteWidth, y * spriteHeight, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);\r\n\t\t\t\tsprites.push(canvas);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\treturn sprites;\r\n\t}\r\n\t\r\n\tgetSpriteRotations(imageDataList) {\r\n\t\tlet rotationDict = {};\r\n\r\n\t\tlet requiredTransforms = {};\r\n\r\n\t\trequiredTransforms[this.TileMolecule.Full] = [];\r\n\t\trequiredTransforms[this.TileMolecule.Corner] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Edge] = [this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Tunnel] = [this.TileTransforms.CounterClockWise90];\r\n\t\trequiredTransforms[this.TileMolecule.TwoSides] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];\r\n\t\trequiredTransforms[this.TileMolecule.Penninsula] = [this.TileTransforms.FlipVertical, this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90];\r\n\t\trequiredTransforms[this.TileMolecule.Island] = [];\r\n\r\n\t\tObject.keys(imageDataList).forEach(moleculeType => {\r\n\t\t\tlet rotations = {};\r\n\t\t\tlet colors = imageDataList[moleculeType];\r\n\t\t\trotations[this.TileTransforms.None] = colors;\r\n\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.ClockWise90)) {\r\n\t\t\t\trotations[this.TileTransforms.ClockWise90] = this.rotateTexture(colors, Math.PI / 2);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.CounterClockWise90)) {\r\n\t\t\t\trotations[this.TileTransforms.CounterClockWise90] = this.rotateTexture(colors, -Math.PI / 2);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.Rotate180)) {\r\n\t\t\t\trotations[this.TileTransforms.Rotate180] = this.rotateTexture(colors, Math.PI);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipHorizontal)) {\r\n\t\t\t\trotations[this.TileTransforms.FlipHorizontal] = this.flipTextureHorizontal(colors);\r\n\t\t\t}\r\n\t\t\tif (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipVertical)) {\r\n\t\t\t\trotations[this.TileTransforms.FlipVertical] = this.flipTextureVertical(colors);\r\n\t\t\t}\r\n\r\n\t\t\trotationDict[moleculeType] = rotations;\r\n\t\t});\r\n\r\n\t\treturn rotationDict;\r\n\t}\r\n\r\n\trotateTexture(imageData, angle) {\r\n\t\treturn this.canvasUtility.rotateTexture(imageData, angle);\r\n\t}\r\n\r\n\tflipTextureVertical(imageData) {\r\n\t\treturn this.canvasUtility.flipTextureVertical(imageData);\r\n\t}\r\n\r\n\tflipTextureHorizontal(imageData) {\r\n\t\treturn this.canvasUtility.flipTextureHorizontal(imageData);\r\n\t}\r\n\r\n\tanalyzeTile(x, y) {\r\n\t\tlet row = y;\r\n\t\tlet col = x;\r\n\r\n\t\t// Create result object with both analyses\r\n\t\tlet result = {\r\n\t\t\tterrainIndex: 0,\r\n\t\t\theightAnalysis: new this.TileAnalysis(),\r\n\t\t\tterrainAnalysis: new this.TileAnalysis()\r\n\t\t};\r\n\r\n\t\tif (row < 0 || row >= this.numColumns || col < 0 || col >= this.numColumns) {\r\n\t\t\treturn result; // Out of bounds\r\n\t\t}\r\n\r\n\t\t// Get terrain type for this tile\r\n\t\tresult.terrainIndex = this.tileMap[row][col];\r\n\r\n\t\t// Helper function to check if a location is within bounds\r\n\t\tfunction isWithinBounds(r, c, n) {\r\n\t\t\treturn r >= 0 && r < n && c >= 0 && c < n;\r\n\t\t}\r\n\r\n\t\t// Analyze heights for cliff detection\r\n\t\tconst heightData = this.heightMap || this.tileMap;\r\n\t\tresult.heightAnalysis.heightIndex = heightData[row][col];\r\n\r\n\t\tvar analyzeHeight = ((r, c, n, direction, propertyLess) => {\r\n\t\t\tif (isWithinBounds(r, c, n)) {\r\n\t\t\t\tresult.heightAnalysis[direction] = heightData[r][c];\r\n\t\t\t\tif (heightData[r][c] < result.heightAnalysis.heightIndex) {\r\n\t\t\t\t\tresult.heightAnalysis[propertyLess] = true;\r\n\t\t\t\t\tif(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0) {\r\n\t\t\t\t\t\tresult.heightAnalysis.neighborLowerCount++;\r\n\t\t\t\t\t} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {\r\n\t\t\t\t\t\tresult.heightAnalysis.cornerLowerCount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tanalyzeHeight(row - 1, col, this.numColumns, 'topHeight', 'topLess');\r\n\t\tanalyzeHeight(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');\r\n\t\tanalyzeHeight(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');\r\n\t\tanalyzeHeight(row + 1, col, this.numColumns, 'botHeight', 'botLess');\r\n\t\tanalyzeHeight(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');\r\n\t\tanalyzeHeight(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');\r\n\t\tanalyzeHeight(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');\r\n\t\tanalyzeHeight(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');\r\n\r\n\t\t// Analyze terrain types for texture tiling\r\n\t\tresult.terrainAnalysis.heightIndex = this.tileMap[row][col];\r\n\r\n\t\tvar analyzeTerrain = ((r, c, n, direction, propertyLess) => {\r\n\t\t\tif (isWithinBounds(r, c, n)) {\r\n\t\t\t\tresult.terrainAnalysis[direction] = this.tileMap[r][c];\r\n\t\t\t\tif (this.tileMap[r][c] < result.terrainAnalysis.heightIndex) {\r\n\t\t\t\t\tresult.terrainAnalysis[propertyLess] = true;\r\n\t\t\t\t\tif(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0) {\r\n\t\t\t\t\t\tresult.terrainAnalysis.neighborLowerCount++;\r\n\t\t\t\t\t} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {\r\n\t\t\t\t\t\tresult.terrainAnalysis.cornerLowerCount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tanalyzeTerrain(row - 1, col, this.numColumns, 'topHeight', 'topLess');\r\n\t\tanalyzeTerrain(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');\r\n\t\tanalyzeTerrain(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');\r\n\t\tanalyzeTerrain(row + 1, col, this.numColumns, 'botHeight', 'botLess');\r\n\t\tanalyzeTerrain(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');\r\n\t\tanalyzeTerrain(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');\r\n\t\tanalyzeTerrain(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');\r\n\t\tanalyzeTerrain(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// Function to generate a random integer between min and max (inclusive)\r\n\tgetRandomInt(min, max) {\r\n\t\treturn Math.floor(Math.random() * (max - min + 1)) + min;\r\n\t}\r\n\r\n\t// Function to generate a random 10x10 map\r\n\tgenerateRandomMap(rows, columns) {\r\n\t\tlet map = [];\r\n\t\tfor (let i = 0; i < rows; i++) {\r\n\t\t\tlet row = [];\r\n\t\t\tfor (let j = 0; j < columns; j++) {\r\n\t\t\t\trow.push(getRandomInt(0, layers.length - 1)); // Random height between 0 and 10\r\n\t\t\t}\r\n\t\t\tmap.push(row);\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n\tanalyzeMap() {\r\n\t\tlet analyzedTiles = [];\r\n\r\n\t\tfor (let i = 0; i < this.numColumns; i++) {\r\n\t\t\tfor (let j = 0; j < this.numColumns; j++) {\r\n\t\t\t\tanalyzedTiles.push(this.analyzeTile(j, i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn analyzedTiles;\r\n\t}\r\n\r\n\tgetTransformedTexture(transformationDict, tileAnalysis, molecule){\r\n\t\tswitch(tileAnalysis.neighborLowerCount){\t\t\t\t\r\n\t\t\tcase 1:\r\n\t\t\t\tif(tileAnalysis.leftLess){                    \r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t} else if(tileAnalysis.rightLess){\r\n                    return transformationDict[molecule][this.TileTransforms.ClockWise90];\r\n\t\t\t\t} else if(tileAnalysis.botLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.Rotate180];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(tileAnalysis.topLess && tileAnalysis.leftLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipHorizontal];\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.leftLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.Rotate180];\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.rightLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipVertical];\r\n\t\t\t\t} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tif(!tileAnalysis.topLess){\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.FlipVertical];\r\n\t\t\t\t} else if(!tileAnalysis.leftLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.ClockWise90];\r\n\t\t\t\t} else if(!tileAnalysis.rightLess){\t\t\r\n\t\t\t\t\treturn transformationDict[molecule][this.TileTransforms.CounterClockWise90];\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 4:\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tbreak;\r\n\t\t}\t\t\r\n        return transformationDict[molecule][this.TileTransforms.None];\r\n\t}\r\n\r\n\tgetMoleculeByTileAnalysis(tileAnalysis){\r\n\t\tvar molecule = this.TileCliffMolecules.Full;\t\t\t\t\t\t\t\t\r\n\t\tswitch(tileAnalysis.neighborLowerCount){\r\n\t\t\tcase 0: \r\n\t\t\t\t// Randomly choose between Full (sprite 0) and FullVariation (sprite 4)\r\n\t\t\t\tmolecule = Math.random() < 0.5 ? this.TileCliffMolecules.Full : this.TileCliffMolecules.FullVariation;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 1:\r\n\t\t\t\tif(tileAnalysis.topLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeT;\r\n\t\t\t\t} else if(tileAnalysis.leftLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeL;\r\n\t\t\t\t} else if(tileAnalysis.rightLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeR;\r\n\t\t\t\t} else if(tileAnalysis.botLess) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.EdgeB;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tif(tileAnalysis.topLess && tileAnalysis.botLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TunnelH;\r\n\t\t\t\t} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TunnelV;\r\n\t\t\t\t} else if(tileAnalysis.topLess && tileAnalysis.leftLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesTL;\r\n\t\t\t\t} else if(tileAnalysis.topLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesTR;\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.leftLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesBL;\r\n\t\t\t\t} else if(tileAnalysis.botLess && tileAnalysis.rightLess){\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.TwoSidesBR;\r\n\t\t\t\t} \r\n\t\t\t\tbreak;\r\n\t\t\tcase 3:\r\n\t\t\t\tif( !tileAnalysis.topLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaB;\r\n\t\t\t\t} else if( !tileAnalysis.leftLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaR;\r\n\t\t\t\t} else if( !tileAnalysis.rightLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaL;\r\n\t\t\t\t} else if( !tileAnalysis.botLess ) {\r\n\t\t\t\t\tmolecule = this.TileCliffMolecules.PenninsulaT;\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\t\t\t\t\t\t\t\t\r\n\t\t\tcase 4:\r\n\t\t\t\tmolecule = this.TileCliffMolecules.Island;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\treturn molecule;\r\n\t}\r\n\r\n\tcolorImageData(imageData, terrainAnalysis, terrainIndex) {\r\n\r\n\t\tconst data = new Uint8ClampedArray(imageData.data);\r\n\t\tvar directions = ['topHeight', 'leftHeight', 'rightHeight', 'botHeight', 'topLeftHeight', 'topRightHeight', 'botLeftHeight', 'botRightHeight'];\r\n\t\tlet heightCounts = {};\r\n\t\tdirections.forEach((direction) => {\r\n\t\t\tlet height = terrainAnalysis[direction];\r\n\t\t\tif (height !== terrainAnalysis.heightIndex) {\r\n\t\t\t\tif (!heightCounts[height]) {\r\n\t\t\t\t\theightCounts[height] = 0;\r\n\t\t\t\t}\r\n\t\t\t\theightCounts[height]++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tlet lowerNeighborHeight = Math.max(0, terrainAnalysis.heightIndex - 1);\r\n\t\tlet maxCount = 0;\r\n\t\tObject.keys(heightCounts).forEach((height) => {\r\n\t\t\tif (heightCounts[height] > maxCount && height < terrainAnalysis.heightIndex) {\r\n\t\t\t\tlowerNeighborHeight = parseInt(height);\r\n\t\t\t\tmaxCount = heightCounts[height];\r\n\t\t\t}\r\n\t\t});\r\n\t\tconst numPixels = this.tileSize * this.tileSize;\r\n\t\tif(lowerNeighborHeight < 0){\r\n\t\t\tconst blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)\r\n\t\t\tblackData.fill(0); // Fill with black (0, 0, 0, 255)\r\n\t\t\treturn new ImageData(blackData, this.tileSize, this.tileSize);\r\n\t\t}\r\n\t\t// Use terrainIndex for texture selection\r\n\t\tlet baseColors = this.layerTextures[terrainIndex][this.TileMolecule.Full].data;\r\n\t\tlet neighborColors = this.layerTextures[terrainIndex][this.TileMolecule.Full].data;\r\n\r\n\t\t// Iterate over each pixel\r\n\t\tfor (let i = 0; i < numPixels; i++) {\r\n\t\t\tconst dataIndex = i * 4;\r\n\t\t\tlet pColor = { r: data[dataIndex], g: data[dataIndex + 1], b: data[dataIndex + 2], a: data[dataIndex + 3] };\r\n\t\t\tlet bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };\r\n\t\t\tlet tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };\r\n\r\n\t\t\tif (this.layerTextures.length > terrainIndex) {\r\n\t\t\t\tif (baseColors.length > i) {\r\n\t\t\t\t\tbColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (lowerNeighborHeight >= 0) {\r\n\t\t\t\tif (neighborColors.length > i) {\r\n\t\t\t\t\ttColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet fColor = pColor;\r\n\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 0 })) fColor = pColor;\r\n\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) fColor = bColor;\r\n\r\n\t\t\tdata.set([fColor.r, fColor.g, fColor.b, fColor.a], dataIndex);\r\n\t\t}\r\n\t\treturn new ImageData(data, this.tileSize, this.tileSize);\r\n\t}\r\n\r\n\tisEqualColor(color1, color2) {\r\n\t\treturn color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && color1.a === color2.a;\r\n\t}\r\n\r\n\taddCornerGraphics(imageData, heightAnalysis, terrainIndex) {\r\n\t\tlet cornerSize = this.tileSize / 2;\r\n\t\tlet cornerTexture;\r\n\r\n\t\tif (heightAnalysis.cornerLowerCount > 0) {\r\n\t\t\tif (heightAnalysis.cornerTopLeftLess && (!heightAnalysis.topLess && !heightAnalysis.leftLess)) {\r\n\t\t\t\tcornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerTL];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, 0, 0, cornerTexture, terrainIndex);\r\n\t\t\t}\r\n\t\t\t// Assuming heightAnalysis, textureDict, and other variables are already defined\r\n\t\t\tif (heightAnalysis.cornerTopRightLess && (!heightAnalysis.topLess && !heightAnalysis.rightLess)) {\r\n\t\t\t\tcornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerTR];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, cornerSize, 0, cornerTexture, terrainIndex);\r\n\t\t\t}\r\n\r\n\t\t\tif (heightAnalysis.cornerBottomLeftLess && (!heightAnalysis.botLess && !heightAnalysis.leftLess)) {\r\n\t\t\t\tcornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerBL];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, 0, cornerSize, cornerTexture, terrainIndex);\r\n\t\t\t}\r\n\r\n\t\t\tif (heightAnalysis.cornerBottomRightLess && (!heightAnalysis.botLess && !heightAnalysis.rightLess)) {\r\n\t\t\t\tcornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerBR];\r\n\t\t\t\timageData = this.colorCornerTextureRoutine(imageData, cornerSize, cornerSize, cornerTexture, terrainIndex);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn imageData;\r\n\t}\r\n\t\r\n\tcolorCornerTextureRoutine(outputImageData, x, y, cornerImageData, terrainIndex) {\r\n\t\tlet cornerSize = this.tileSize / 2;\r\n\t\t// Use terrainIndex for texture selection\r\n\t\tlet baseColors = this.layerTextures[terrainIndex][this.TileMolecule.Full];\r\n\t\tconst data = new Uint8ClampedArray(outputImageData.data);\r\n\t\tfor (let j = 0; j < cornerSize; j++) {\r\n\t\t\tfor (let i = 0; i < cornerSize; i++) {\r\n\t\t\t\t// Calculate the correct position in the output image data\r\n\t\t\t\tlet outputIndex = ((y + j) * this.tileSize + (x + i)) * 4;\r\n\t\r\n\t\t\t\tlet baseColor = this.getColorFromImageData(baseColors, outputIndex);\r\n\t\t\r\n\t\t\t\tlet sourceOriginX = i;\r\n\t\t\t\tlet sourceOriginY = j * cornerSize;\r\n\t\t\t\tlet sourcePixel = (sourceOriginY + sourceOriginX) * 4;\r\n\t\t\t\tlet pColor = this.getColorFromImageData(cornerImageData, sourcePixel);\r\n\t\t\t\tlet fColor = pColor;\r\n\t\t\t\tif (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) {\r\n\t\t\t\t\tfColor = baseColor;\t\t\t\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdata[outputIndex] = fColor.r;\r\n\t\t\t\tdata[outputIndex + 1] = fColor.g;\r\n\t\t\t\tdata[outputIndex + 2] = fColor.b;\r\n\t\t\t\tdata[outputIndex + 3] = fColor.a;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn new ImageData(data, this.tileSize, this.tileSize);\r\n\t}\r\n\t\r\n\tgetColorFromImageData(imageData, index) {\r\n\t\treturn {\r\n\t\t\tr: imageData.data[index],\r\n\t\t\tg: imageData.data[index + 1],\r\n\t\t\tb: imageData.data[index + 2],\r\n\t\t\ta: imageData.data[index + 3]\r\n\t\t};\r\n\t}\t\r\n\t\r\n\taddVariationImage(imageData, tileAnalysis) {\r\n\t\tconst img = this.layerSpriteSheets[tileAnalysis.heightIndex];\r\n\t\r\n\t\tif (img && Math.random() < .25) {\r\n\t\t\tthis.canvasUtility.setSize(imageData.width, imageData.height);\r\n\t\t\t\r\n\t\t\t\r\n\t\t\t// Paint the existing imageData onto the canvas\r\n\t\t\tthis.canvasUtility.paintTexture(imageData);\r\n\t\r\n\t\t\t// Assuming img is a loaded Image object and you want to draw it at (0,0)\r\n\t\t\t// Draw the img over the imageData\r\n\t\t\tthis.canvasUtility.ctx.drawImage(img, (imageData.width / 2) - img.width / 2,  (imageData.width / 2) - img.width / 2);\r\n\t\r\n\t\t\t// Get the updated imageData from the canvas\r\n\t\t\treturn this.canvasUtility.ctx.getImageData(0, 0, imageData.width, imageData.height);\r\n\t\t} else {\r\n\t\t\t// If img is not available, return the original imageData\r\n\t\t\treturn imageData;\r\n\t\t}\r\n\t}\r\n\t\r\n\tdrawMap(analyzedMap) {\r\n\t\tconst ctx = this.canvas.getContext('2d');\r\n\r\n\t\t// Clear the canvas with black background\r\n\t\tctx.fillStyle = 'black';\r\n\t\tctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\r\n\r\n\t\t// Draw each tile with atom-level layering for smooth transitions\r\n\t\tanalyzedMap.forEach((tile, index) => {\r\n\t\t\tconst col = index % this.numColumns;\r\n\t\t\tconst row = Math.floor(index / this.numColumns);\r\n\t\t\tconst x = col * this.tileSize;\r\n\t\t\tconst y = row * this.tileSize;\r\n\r\n\t\t\tlet imageData;\r\n\r\n\t\t\tif (tile.terrainIndex >= 0) {\r\n\t\t\t\t// Use the new atom-based layering system for smooth transitions\r\n\t\t\t\timageData = this.drawTileWithLayering(analyzedMap, tile, row, col);\r\n\t\t\t} else {\r\n\t\t\t\t// Create transparent/black tile for invalid terrain\r\n\t\t\t\tlet numPixels = this.tileSize * this.tileSize;\r\n\t\t\t\tconst blackData = new Uint8ClampedArray(numPixels * 4);\r\n\t\t\t\tblackData.fill(0);\r\n\t\t\t\timageData = new ImageData(blackData, this.tileSize, this.tileSize);\r\n\t\t\t}\r\n\r\n\t\t\t// Update height map for this tile\r\n\t\t\tthis.updateHeightMapForTile(x, y, tile.heightAnalysis.heightIndex);\r\n\r\n\t\t\t// Draw the tile to the main canvas\r\n\t\t\tctx.putImageData(imageData, x, y);\r\n\t\t});\r\n\r\n\t\t// Store terrain data for height mapping\r\n\t\tthis.terrainData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;\r\n\t}\r\n}\r\n",
        "filePath": "/global/libraries/js/TileMap.js"
      },
      "GE_SceneRenderer": {
        "title": "GE_SceneRenderer",
        "fileName": "GE_SceneRenderer",
        "script": "class GE_SceneRenderer {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        this.scene = null;\r\n        this.camera = null;\r\n        this.renderer = null;\r\n        this.controls = null;\r\n    }    \r\n\r\n    init() {        \r\n        this.initThreeJS();\r\n        this.initEventListeners();\r\n    }\r\n    initEventListeners() {\r\n        document.body.addEventListener('renderGraphicsObject', this.handleRenderObject.bind(this));\r\n        document.body.addEventListener('resizedEditor', () => {             \r\n            this.graphicsEditor.canvas.width = this.gameEditor.getCollections().configs.game.canvasWidth;\r\n            this.graphicsEditor.canvas.height = this.gameEditor.getCollections().configs.game.canvasHeight;\r\n            this.graphicsEditor.canvas.setAttribute('style','');\r\n            this.handleResize();  \r\n            this.graphicsEditor.refreshShapes(false); \r\n        });\r\n        document.getElementById('iso-generate').addEventListener('click', this.generateIsometricSprites.bind(this));\r\n    }\r\n    initThreeJS() {\r\n        // Scene setup\r\n        this.scene = new window.THREE.Scene();\r\n        \r\n        // Add the root group to the scene\r\n        this.scene.add(this.graphicsEditor.rootGroup);\r\n\r\n        // Camera setup\r\n        this.camera = new window.THREE.PerspectiveCamera(\r\n            75, \r\n            this.graphicsEditor.canvas.clientWidth / this.graphicsEditor.canvas.clientHeight, \r\n            0.1, \r\n            1000\r\n        );\r\n        this.camera.position.set(100, 100, 100);\r\n        this.camera.lookAt(0, 0, 0);\r\n\r\n        // Renderer setup\r\n        this.renderer = new window.THREE.WebGLRenderer({ \r\n            canvas: this.graphicsEditor.canvas, \r\n            antialias: false, \r\n            alpha: true \r\n        });\r\n        this.renderer.setSize(this.graphicsEditor.canvas.clientWidth, this.graphicsEditor.canvas.clientHeight);\r\n\r\n        // Add helpers\r\n        const gridHelper = new window.THREE.GridHelper(100, 10);\r\n        this.scene.add(gridHelper);\r\n\r\n        const axesHelper = new window.THREE.AxesHelper(10);\r\n        this.scene.add(axesHelper);\r\n\r\n        // Orbit controls\r\n        this.controls = new window.THREE_.OrbitControls(this.camera, this.renderer.domElement);\r\n        this.controls.enableDamping = true;\r\n        this.controls.dampingFactor = 0.25;\r\n\r\n        // Resize handling\r\n        window.addEventListener('resize', this.handleResize.bind(this));\r\n    }\r\n    \r\n    handleResize() {\r\n        this.camera.aspect = this.graphicsEditor.canvas.clientWidth / this.graphicsEditor.canvas.clientHeight;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(this.graphicsEditor.canvas.clientWidth, this.graphicsEditor.canvas.clientHeight);\r\n    }\r\n    \r\n    handleRenderObject(event) {\r\n        this.graphicsEditor.canvas.width = this.gameEditor.getCollections().configs.game.canvasWidth;\r\n        this.graphicsEditor.canvas.height = this.gameEditor.getCollections().configs.game.canvasHeight;\r\n        \r\n        this.graphicsEditor.equipmentEditor.clearAllEquipment();\r\n        this.graphicsEditor.canvas.setAttribute('style','');\r\n        this.graphicsEditor.setPreviewAnimationState(false);\r\n        this.graphicsEditor.state.renderData = event.detail.data;\r\n        document.getElementById('json-content').value = JSON.stringify(this.graphicsEditor.state.renderData, null, 2);\r\n        \r\n        // Safely get first animation name\r\n        let model = this.graphicsEditor.state.renderData.model;        \r\n        if(!model) {\r\n            this.graphicsEditor.state.renderData.model = JSON.parse(JSON.stringify(this.graphicsEditor.state.renderData.animations['idle'][0])); // Deep copy\r\n            model = this.graphicsEditor.state.renderData.model;\r\n        }\r\n        this.graphicsEditor.state.currentAnimation = \"\";\r\n        this.graphicsEditor.state.editingModel = true;\r\n        // Safely get first frame's shapes\r\n        const firstGroup = Object.keys(model)[0];\r\n        const shapes = model[firstGroup].shapes || [];\r\n        this.graphicsEditor.state.currentGroup = firstGroup;\r\n        this.handleResize();\r\n        this.graphicsEditor.refreshShapes(false);\r\n        this.clock = new window.THREE.Clock();\r\n        this.clock.start(); \r\n        requestAnimationFrame(() => {\r\n            this.graphicsEditor.state.selectedShapeIndex = -1;\r\n            this.graphicsEditor.shapeManager.selectShape(shapes.length > 0 ? 0 : -1);\r\n        });\r\n    }\r\n\r\n\r\n    animate() {\r\n        requestAnimationFrame(this.animate.bind(this));\r\n        this.controls.update();\r\n        \r\n        // Calculate delta once per frame\r\n        const delta = this.clock ? this.clock.getDelta() : 0;\r\n        \r\n        // Update all mixers with the same delta\r\n        this.scene.traverse(object => {\r\n            if (object.userData.mixer) {\r\n                object.userData.mixer.update(delta);\r\n            }\r\n            if (object.isSkinnedMesh) {\r\n                object.skeleton.update();\r\n            }\r\n        });\r\n    \r\n        this.renderer.render(this.scene, this.camera);\r\n    }\r\n    \r\n    async createObjectsFromJSON(frameData, scene) {\r\n        for(const groupName in frameData) {\r\n            const group = await this.graphicsEditor.shapeFactory.createGroupFromJSON(groupName, frameData[groupName]);\r\n            scene.add(group);\r\n        }\r\n    }\r\n    \r\n    async generateIsometricSprites() {\r\n        const frustumSize = parseFloat(document.getElementById('iso-frustum').value) || 48;\r\n        const cameraDistance = parseFloat(document.getElementById('iso-distance').value) || 100;\r\n        const size = parseFloat(document.getElementById('iso-size').value) || 64;\r\n        const aspect = 1;\r\n        const tempRenderer = new window.THREE.WebGLRenderer({ antialias: false, alpha: true });\r\n        tempRenderer.setSize(size, size);\r\n        document.getElementById('modal-generateIsoSprites').classList.remove('show');\r\n    \r\n        const renderTarget = new window.THREE.WebGLRenderTarget(size, size);\r\n        const cameras = [\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000),\r\n            new window.THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000)\r\n        ];\r\n    \r\n        // Position cameras at 8 angles (45 increments)\r\n        cameras[0].position.set(cameraDistance, cameraDistance, cameraDistance);           // NE up\r\n        cameras[1].position.set(0, cameraDistance, cameraDistance);                       // N up\r\n        cameras[2].position.set(-cameraDistance, cameraDistance, cameraDistance);         // NW up\r\n        cameras[3].position.set(-cameraDistance, cameraDistance, 0);                      // W up\r\n        cameras[4].position.set(-cameraDistance, cameraDistance, -cameraDistance);        // SW up\r\n        cameras[5].position.set(0, cameraDistance, -cameraDistance);                      // S up\r\n        cameras[6].position.set(cameraDistance, cameraDistance, -cameraDistance);         // SE up\r\n        cameras[7].position.set(cameraDistance, cameraDistance, 0);                       // E up\r\n        \r\n        cameras.forEach(camera => camera.lookAt(0, 0, 0));\r\n    \r\n        const sprites = {};     \r\n       \r\n        for (const animType in this.graphicsEditor.state.renderData.animations) {\r\n            sprites[animType] = [];\r\n            for (let frameIndex = 0; frameIndex < this.graphicsEditor.state.renderData.animations[animType].length; frameIndex++) {\r\n                const frame = this.graphicsEditor.state.renderData.animations[animType][frameIndex];\r\n                const scene = new window.THREE.Scene();\r\n                \r\n                // Add lights\r\n                const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.8);\r\n                scene.add(ambientLight);\r\n                const directionalLight = new window.THREE.DirectionalLight(0xffffff, 1.0);\r\n                directionalLight.position.set(5, 10, 7.5);\r\n                scene.add(directionalLight);\r\n\r\n                await this.createObjectsFromJSON(frame, scene);\r\n    \r\n                const frameSprites = [];\r\n                for (const camera of cameras) {\r\n                    tempRenderer.setRenderTarget(renderTarget);\r\n                    tempRenderer.render(scene, camera);\r\n                    const buffer = new Uint8Array(size * size * 4);\r\n                    tempRenderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, buffer);\r\n                    const flippedBuffer = new Uint8Array(size * size * 4);\r\n                    for (let y = 0; y < size; y++) {\r\n                        const srcRowStart = y * size * 4;\r\n                        const destRowStart = (size - 1 - y) * size * 4;\r\n                        flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);\r\n                    }\r\n                    const canvas = document.createElement('canvas');\r\n                    canvas.width = size;\r\n                    canvas.height = size;\r\n                    const ctx = canvas.getContext('2d');\r\n                    const imageData = ctx.createImageData(size, size);\r\n                    imageData.data.set(flippedBuffer);\r\n                    ctx.putImageData(imageData, 0, 0);\r\n                    frameSprites.push(canvas.toDataURL());\r\n                }\r\n                sprites[animType].push(frameSprites);\r\n            }\r\n        }\r\n        tempRenderer.setRenderTarget(null);\r\n        tempRenderer.dispose();\r\n        renderTarget.dispose();\r\n        this.graphicsEditor.displayIsometricSprites(sprites);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/GE_SceneRenderer.js"
      },
      "ExportScripts": {
        "fileName": "ExportScripts",
        "script": "class ExportScripts {\r\n  constructor(app) {\r\n     this.app = app;\r\n  }\r\n  export(project) {\r\n      // Initialize JSZip\r\n      const zip = new GUTS.JSZip();\r\n\r\n      // Iterate over each script type (e.g., \"renderers\", \"components\")\r\n      Object.keys(project).forEach(scriptType => {\r\n          const scripts = project[scriptType];\r\n\r\n          // Create a folder for the script type\r\n          const folder = zip.folder(`scripts/${scriptType}`);\r\n\r\n          // Iterate over each script key (e.g., \"renderer\", \"component\")\r\n          Object.keys(scripts).forEach(scriptKey => {\r\n              const scriptData = scripts[scriptKey];\r\n              const scriptContent = scriptData.script || ''; // Fallback to empty string if no script\r\n\r\n              // Add the script file to the folder\r\n              folder.file(`${scriptKey}.js`, scriptContent);\r\n          });\r\n      });\r\n\r\n      // Generate the zip file and trigger download\r\n      zip.generateAsync({ type: 'blob' }).then(blob => {\r\n          // Create a temporary URL for the blob\r\n          const url = window.URL.createObjectURL(blob);\r\n\r\n          // Create a temporary link element to trigger download\r\n          const link = document.createElement('a');\r\n          link.href = url;\r\n          link.download = 'scripts.zip'; // Name of the downloaded file\r\n          document.body.appendChild(link);\r\n          link.click();\r\n\r\n          // Clean up\r\n          document.body.removeChild(link);\r\n          window.URL.revokeObjectURL(url);\r\n      }).catch(error => {\r\n          console.error('Error generating zip file:', error);\r\n      });\r\n  }\r\n}",
        "filePath": "/global/libraries/js/ExportScripts.js"
      },
      "GE_EventManager": {
        "title": "GE_EventManager",
        "fileName": "GE_EventManager",
        "script": "class GE_EventManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.editor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n    }    \r\n    \r\n\r\n}",
        "filePath": "/global/libraries/js/GE_EventManager.js"
      },
      "AmmoWorker": {
        "fileName": "AmmoWorker",
        "script": "// Debug flag for worker\r\nconst debugWorker = false;\r\n\r\n// Initialize Ammo.js\r\nlet AmmoLib;\r\nlet physicsWorld, collisionConfiguration, dispatcher, broadphase, solver;\r\n\r\nconst gravity = -9.8*10;\r\n// Colliders and state\r\nconst colliders = new Map();\r\nconst collisionsThisFrame = new Map();\r\nconst minfo = new Map();\r\nlet fps = 0;\r\nconst f = [0, 0, 0];\r\n\r\n// Entity data for ground collision\r\nconst entityData = new Map();\r\n\r\n// Temporary objects pool to avoid creating/destroying every frame\r\nlet tempTransform = null;\r\nlet tempVec3 = null;\r\nlet tempQuat = null;\r\nlet physicsInterval = null;\r\n\r\nfunction initLib(data){\r\n    var config = {\r\n        locateFile: () => `http://${data.hostname || \"localhost:5000\"}/library/ammo.wasm.wasm`\r\n    }\r\n    // Wait for Ammo to load\r\n    Ammo(config).then((AmmoInstance) => {\r\n        AmmoLib = AmmoInstance;\r\n        collisionConfiguration = new AmmoLib.btDefaultCollisionConfiguration();\r\n        dispatcher = new AmmoLib.btCollisionDispatcher(collisionConfiguration);\r\n        broadphase = new AmmoLib.btDbvtBroadphase();\r\n        solver = new AmmoLib.btSequentialImpulseConstraintSolver();\r\n        physicsWorld = new AmmoLib.btDiscreteDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration);\r\n        physicsWorld.setGravity(new AmmoLib.btVector3(0, gravity, 0));\r\n\r\n        // Initialize temp objects\r\n        tempTransform = new AmmoLib.btTransform();\r\n        tempVec3 = new AmmoLib.btVector3(0, 0, 0);\r\n        tempQuat = new AmmoLib.btQuaternion(0, 0, 0, 1);\r\n\r\n        if (debugWorker) console.log(\"Physics initialized\");\r\n    });\r\n    \r\n}\r\n\r\nself.onmessage = function(e) {\r\n\r\n    const messageType = e.data.messageType;\r\n    const data = e.data;\r\n\r\n    if (messageType == 'setHostname') {                 \r\n        initLib(data);\r\n    } else if(AmmoLib && messageType == \"staticAABBs\"){\r\n        processStaticAABBs(data);\r\n    } else if(AmmoLib && messageType == \"updateEntities\"){\r\n        updateEntities(data);\r\n        update();\r\n    }\r\n};\r\n\r\nfunction processStaticAABBs(data){\r\n    const staticAABBs = data.staticAABBs;\r\n    // Process entities\r\n    if (staticAABBs && staticAABBs.length > 0) {\r\n\r\n        staticAABBs.forEach(aabb => {\r\n            if (!aabb.id || !aabb.min || !aabb.max) {\r\n                if (debugWorker) console.warn(\"Skipping invalid static AABB:\", aabb);\r\n                return;\r\n            }\r\n\r\n            // Validate AABB dimensions\r\n            if (aabb.max.x <= aabb.min.x || aabb.max.y <= aabb.min.y || aabb.max.z <= aabb.min.z) {\r\n                if (debugWorker) console.warn(\"Invalid AABB dimensions:\", aabb);\r\n                return;\r\n            }\r\n\r\n            // Skip if already created\r\n            if (colliders.has(aabb.id)) {\r\n                if (debugWorker) console.log(\"Static AABB already exists:\", aabb.id);\r\n                return;\r\n            }\r\n\r\n            // Calculate capsule dimensions\r\n            const height = aabb.max.y - aabb.min.y; // Full height of the trunk\r\n            // Use a provided radius or estimate from AABB (e.g., smaller of x/z dimensions)\r\n            const radius = aabb.radius || Math.min((aabb.max.x - aabb.min.x), (aabb.max.z - aabb.min.z)) / 2;\r\n            if (radius <= 0 || height <= 0) {\r\n                if (debugWorker) console.warn(\"Invalid capsule dimensions: radius=\", radius, \"height=\", height, aabb);\r\n                return;\r\n            }\r\n\r\n            // Create capsule shape\r\n            const shape = new AmmoLib.btCapsuleShape(radius, height);\r\n\r\n            // Set position (align bottom of capsule with aabb.min.y)\r\n            const centerX = (aabb.min.x + aabb.max.x) / 2;\r\n            const centerZ = (aabb.min.z + aabb.max.z) / 2;\r\n            const centerY = aabb.min.y + (height / 2 + radius); // Capsule center: bottom + height/2 + radius\r\n            tempTransform.setIdentity();\r\n            tempVec3.setValue(centerX, centerY, centerZ);\r\n            tempTransform.setOrigin(tempVec3);\r\n\r\n            // Static body (mass = 0)\r\n            const mass = 0;\r\n            tempVec3.setValue(0, 0, 0); // No inertia for static bodies\r\n            const motionState = new AmmoLib.btDefaultMotionState(tempTransform);\r\n            const bodyInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, tempVec3);\r\n            const body = new AmmoLib.btRigidBody(bodyInfo);\r\n\r\n            // Set as static object\r\n            body.setCollisionFlags(body.getCollisionFlags() | AmmoLib.btCollisionObject.CF_STATIC_OBJECT);\r\n\r\n            // Configure body\r\n            body.setRestitution(aabb.restitution || 0.5);\r\n            body.setFriction(aabb.friction || 0.5);\r\n            body.userData = { id: aabb.id, collider: { type: 'capsule', static: true }, reflected: false };\r\n\r\n            // Add to physics world\r\n            physicsWorld.addRigidBody(body);\r\n            colliders.set(aabb.id, body);\r\n            minfo.set(aabb.id, new Float32Array(8));\r\n\r\n            AmmoLib.destroy(bodyInfo);\r\n\r\n            if (debugWorker) console.log(\"Created static capsule collider:\", aabb.id, \"center:\", { x: centerX, y: centerY, z: centerZ }, \"radius:\", radius, \"height:\", height);\r\n        });\r\n    }\r\n}\r\n\r\nfunction updateEntities(data){\r\n    collisionsThisFrame.clear();\r\n    if (data.entities && data.entities.length > 0) {\r\n        data.entities.forEach(entity => {\r\n            if (!entity.id) {\r\n                if (debugWorker) console.warn(\"Skipping entity with missing ID or collider:\", entity);\r\n                return;\r\n            }\r\n            \r\n            // Store ground height for the entity\r\n            if (entity.groundHeight !== undefined) {\r\n                entityData.set(entity.id, {\r\n                    groundHeight: entity.groundHeight\r\n                });\r\n            }\r\n\r\n            if (!colliders.has(entity.id)) {\r\n                // Create new rigid body\r\n                let shape;\r\n                if (entity.type === 'sphere') {\r\n                    const radius = Array.isArray(entity.size) ? entity.size[0] || 0.5 : entity.size || 0.5;\r\n                    shape = new AmmoLib.btSphereShape(radius);\r\n                } else if (entity.type === 'box') {\r\n                    const size = Array.isArray(entity.size) ? entity.size : [1, 1, 1];\r\n                    tempVec3.setValue(size[0] || 1, size[1] || 1, size[2] || 1);\r\n                    shape = new AmmoLib.btBoxShape(tempVec3);\r\n                } else {\r\n                    if (debugWorker) console.warn(\"Unsupported collider type:\", entity.type);\r\n                    return;\r\n                }\r\n\r\n                tempTransform.setIdentity();\r\n                tempVec3.setValue(\r\n                    entity.positionX || 0,\r\n                    entity.positionY || 0,\r\n                    entity.positionZ || 0\r\n                );\r\n                tempTransform.setOrigin(tempVec3);\r\n                \r\n                if (entity.quaternion) {\r\n                    tempQuat.setValue(\r\n                        entity.quaternionX || 0,\r\n                        entity.quaternionY || 0,\r\n                        entity.quaternionZ || 0,\r\n                        entity.quaternionW || 1\r\n                    );\r\n                    tempTransform.setRotation(tempQuat);\r\n                }\r\n\r\n                const mass = entity.mass || 1;\r\n                tempVec3.setValue(0, 0, 0); // Reuse for inertia\r\n                if (mass > 0) {\r\n                    shape.calculateLocalInertia(mass, tempVec3);\r\n                }\r\n\r\n                const motionState = new AmmoLib.btDefaultMotionState(tempTransform);\r\n                const bodyInfo = new AmmoLib.btRigidBodyConstructionInfo(mass, motionState, shape, tempVec3);\r\n                const body = new AmmoLib.btRigidBody(bodyInfo);\r\n                body.setCcdMotionThreshold(1); // Trigger CCD at small motion\r\n                body.setCcdSweptSphereRadius(entity.size / 2); // Sphere radius for CCD\r\n          \r\n                body.setRestitution(entity.restitution || 0.5);\r\n                body.setFriction(0.5);\r\n                tempVec3.setValue(\r\n                    entity.velocityX,\r\n                    entity.velocityY,\r\n                    entity.velocityZ\r\n                );\r\n                body.setLinearVelocity(tempVec3);\r\n                \r\n                body.setCollisionFlags(0);\r\n                physicsWorld.addRigidBody(body);\r\n                body.userData = { id: entity.id, collider: entity, reflected: false };\r\n\r\n                colliders.set(entity.id, body);\r\n                minfo.set(entity.id, new Float32Array(8));\r\n\r\n                AmmoLib.destroy(bodyInfo);\r\n\r\n                if (debugWorker) console.log(\"Created collider:\", entity.id, entity.type);\r\n            } else {\r\n                // Update existing rigid body\r\n                const body = colliders.get(entity.id);\r\n                body.userData.reflected = entity.reflected;\r\n\r\n\r\n                if (entity.reflected) {\r\n\r\n                        // Set the body collision flag to kinematic\r\n             //       body.setCollisionFlags(2); // 2 is kinematic\r\n\r\n\r\n                                       // Teleport the body to the new position\r\n                    // tempTransform.setIdentity();\r\n                    // tempVec3.setValue(\r\n                    //     entity.positionX,\r\n                    //     entity.positionY,\r\n                    //     entity.positionZ\r\n                    // );\r\n                    // tempTransform.setOrigin(tempVec3);\r\n\r\n                    // Set the velocity (optional: you can keep the existing velocity or set a new one)\r\n                    tempVec3.setValue(\r\n                        entity.velocityX,\r\n                        entity.velocityY,\r\n                        entity.velocityZ\r\n                    );\r\n                    body.setLinearVelocity(tempVec3);\r\n                    //body.setCollisionFlags(0);\r\n                \r\n\r\n                    // // Update motion state to teleport the body\r\n                    // const motionState = body.getMotionState();\r\n                    // motionState.setWorldTransform(tempTransform);\r\n                    // body.setMotionState(motionState);\r\n                }           \r\n            }\r\n        });\r\n    }\r\n\r\n    if (data.removeColliders && data.removeColliders.length > 0) {\r\n        data.removeColliders.forEach(id => {\r\n            const body = colliders.get(id);\r\n            if (body) {\r\n                physicsWorld.removeRigidBody(body);\r\n                AmmoLib.destroy(body.getCollisionShape());\r\n                AmmoLib.destroy(body.getMotionState());\r\n                AmmoLib.destroy(body);\r\n                colliders.delete(id);\r\n                minfo.delete(id);\r\n                entityData.delete(id); // Also remove entity data\r\n                if (debugWorker) console.log(\"Removed collider:\", id);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n  \r\n}\r\n\r\n\r\nfunction update() {\r\n    if(physicsWorld){\r\n        physicsWorld.stepSimulation(1/60, 5);\r\n\r\n        const numManifolds = dispatcher.getNumManifolds();\r\n        for (let i = 0; i < numManifolds; i++) {\r\n            const manifold = dispatcher.getManifoldByIndexInternal(i);\r\n            const body0 = manifold.getBody0();\r\n            const body1 = manifold.getBody1();\r\n            const numContacts = manifold.getNumContacts();\r\n            if (numContacts > 0) {\r\n                const id0 = body0.userData?.id;\r\n                const id1 = body1.userData?.id;\r\n\r\n                if (id0 && id1) {\r\n                    if (!collisionsThisFrame.has(id0)) collisionsThisFrame.set(id0, []);\r\n                    if (!collisionsThisFrame.has(id1)) collisionsThisFrame.set(id1, []);\r\n                    collisionsThisFrame.get(id0).push(id1);\r\n                    collisionsThisFrame.get(id1).push(id0);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const updatedEntities = [];\r\n    const tempTransform = new AmmoLib.btTransform(); // Temp transform for getting world transforms\r\n\r\n    colliders.forEach((body, id) => {\r\n        if(body.userData.collider.static) return;\r\n        const info = minfo.get(id);\r\n        body.getMotionState().getWorldTransform(tempTransform);\r\n        const origin = tempTransform.getOrigin();\r\n        const rotation = tempTransform.getRotation();\r\n\r\n        info[0] = origin.x();\r\n        info[1] = origin.y();\r\n        info[2] = origin.z();\r\n        info[3] = rotation.x();\r\n        info[4] = rotation.y();\r\n        info[5] = rotation.z();\r\n        info[6] = rotation.w();\r\n        info[7] = body.isActive() ? 0 : 1;\r\n\r\n        const velocity = body.getLinearVelocity();\r\n        const collisions = collisionsThisFrame.get(id) || [];\r\n        const collidedWithTerrain = collisions.includes('terrain');\r\n        const entityCollisions = collisions.filter(cid => cid !== 'terrain');\r\n        if(!isNaN(info[0])){\r\n          updatedEntities.push({\r\n              id,\r\n              positionX: info[0], \r\n              positionY: info[1], \r\n              positionZ: info[2],\r\n              quaternionX: info[3], \r\n              quaternionY: info[4], \r\n              quaternionZ: info[5], \r\n              quaternionW: info[6],\r\n              velocityX: velocity.x(),\r\n              velocityY: velocity.y(),\r\n              velocityZ: velocity.z(),\r\n              sleeping: info[7] === 1,\r\n              collisions: entityCollisions,\r\n              collidedWithTerrain: collidedWithTerrain\r\n          });\r\n        }\r\n    });\r\n\r\n    // Clean up temporary transform\r\n    AmmoLib.destroy(tempTransform);\r\n\r\n    // Calculate FPS\r\n    f[1] = Date.now();\r\n    if (f[1] - 1000 > f[0]) {\r\n        f[0] = f[1];\r\n        fps = f[2];\r\n        f[2] = 0;\r\n    }\r\n    f[2]++;\r\n\r\n    self.postMessage({\r\n        perf: fps,\r\n        entities: updatedEntities\r\n    });\r\n}\r\n\r\n// Clean up function - call this when terminating the worker\r\nfunction cleanup() {\r\n    if (!AmmoLib) return;\r\n    \r\n    // Clean up all colliders\r\n    colliders.forEach((body, id) => {\r\n        physicsWorld.removeRigidBody(body);\r\n        AmmoLib.destroy(body.getCollisionShape());\r\n        AmmoLib.destroy(body.getMotionState());\r\n        AmmoLib.destroy(body);\r\n    });\r\n    colliders.clear();\r\n    entityData.clear();\r\n    \r\n    // Clean up temporary objects\r\n    AmmoLib.destroy(tempTransform);\r\n    AmmoLib.destroy(tempVec3);\r\n    AmmoLib.destroy(tempQuat);\r\n    \r\n    // Clean up physics world\r\n    AmmoLib.destroy(physicsWorld);\r\n    AmmoLib.destroy(solver);\r\n    AmmoLib.destroy(broadphase);\r\n    AmmoLib.destroy(dispatcher);\r\n    AmmoLib.destroy(collisionConfiguration);\r\n}\r\n\r\n// Handle worker termination\r\nself.addEventListener('close', () => {\r\n    cleanup();\r\n});",
        "filePath": "/global/libraries/js/AmmoWorker.js"
      },
      "TextureEditor": {
        "title": "TextureEditor",
        "fileName": "TextureEditor",
        "script": "class TextureEditor {\r\n    constructor(gameEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.canvas = null;\r\n        this.ctx = null;\r\n        this.currentColor = '#000000FF'; // Added alpha component (FF = fully opaque)\r\n        this.brushSize = 1;\r\n        this.isDrawing = false;\r\n        this.history = [];\r\n        this.historyIndex = -1;\r\n        this.colorPalette = [];\r\n        if (this.gameEditor.getCollections().palettes && this.gameEditor.getCollections().configs.game.palette) {\r\n            const palette = this.gameEditor.getCollections().palettes[this.gameEditor.getCollections().configs.game.palette];\r\n\r\n            if (palette) {\r\n                for(let key in palette) {\r\n                    if(key.toLowerCase().endsWith('color')){\r\n                        this.colorPalette.push(palette[key]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.activeTool = 'brush'; // Default active tool\r\n        \r\n        // Transparency checker pattern properties\r\n        this.transparencyCheckerSize = 10;\r\n        this.transparencyCheckerColors = ['#DDDDDD', '#FFFFFF'];\r\n        \r\n        // Zoom related properties\r\n        this.zoomLevel = 1;\r\n        this.maxZoomLevel = 16;\r\n        this.minZoomLevel = 0.25;\r\n        this.imageWidth = 0;\r\n        this.imageHeight = 0;\r\n        \r\n        this.setupUI();\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    setupUI() {\r\n        const container = document.getElementById('texture-editor-container');\r\n        if (!container) return;\r\n        \r\n        // Setup color palette\r\n        const paletteEl = container.querySelector('#color-palette');\r\n        this.colorPalette.forEach(color => {\r\n            const colorBtn = document.createElement('div');\r\n            colorBtn.className = 'texture-editor__color-btn';\r\n            colorBtn.style.backgroundColor = this.hexToRgbaString(color);\r\n            colorBtn.dataset.color = color;\r\n            paletteEl.appendChild(colorBtn);\r\n        });\r\n\r\n        // Initialize canvas\r\n        this.canvas = document.getElementById('texture-canvas');\r\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\r\n        \r\n        // Set initial UI state\r\n        document.getElementById('noTextureMessage').style.display = 'block';\r\n        this.canvas.style.display = 'none';\r\n\r\n        // Create a container for the canvas if it doesn't exist\r\n        let canvasContainer = this.canvas.parentElement;\r\n\r\n        // Add zoom controls to the canvas area\r\n        if (canvasContainer) {\r\n            this.addZoomControls(canvasContainer);\r\n        }\r\n\r\n        if (canvasContainer) {\r\n            \r\n            // Add transparency checker pattern background to container\r\n            this.setupTransparencyChecker(canvasContainer);\r\n\r\n        }\r\n    }\r\n    \r\n    addZoomControls(container) {\r\n        // Create zoom controls container\r\n        const zoomControlsContainer = document.createElement('div');\r\n        zoomControlsContainer.className = 'texture-editor__zoom-controls editor-module__status-bar';\r\n        zoomControlsContainer.style.display = 'flex';\r\n        zoomControlsContainer.style.alignItems = 'center';\r\n        zoomControlsContainer.style.gap = '12px';\r\n        zoomControlsContainer.style.position = 'absolute';\r\n        zoomControlsContainer.style.bottom = '0';\r\n        zoomControlsContainer.style.left = '0';\r\n        zoomControlsContainer.style.right = '0';\r\n        \r\n        // Zoom out button\r\n        const zoomOutBtn = document.createElement('button');\r\n        zoomOutBtn.id = 'zoom-out-btn';\r\n        zoomOutBtn.innerText = '-';\r\n        zoomOutBtn.className = 'editor-module__btn editor-module__btn--small';\r\n        zoomOutBtn.title = 'Zoom Out';\r\n\r\n        // Zoom display\r\n        const zoomDisplay = document.createElement('span');\r\n        zoomDisplay.id = 'zoom-display';\r\n        zoomDisplay.innerText = '100%';\r\n\r\n        // Zoom in button\r\n        const zoomInBtn = document.createElement('button');\r\n        zoomInBtn.id = 'zoom-in-btn';\r\n        zoomInBtn.innerText = '+';\r\n        zoomInBtn.className = 'editor-module__btn editor-module__btn--small';\r\n        zoomInBtn.title = 'Zoom In';\r\n\r\n        // Reset zoom button\r\n        const resetZoomBtn = document.createElement('button');\r\n        resetZoomBtn.id = 'reset-zoom-btn';\r\n        resetZoomBtn.innerText = 'Reset';\r\n        resetZoomBtn.className = 'editor-module__btn editor-module__btn--small';\r\n        resetZoomBtn.title = 'Reset Zoom to 100%';\r\n\r\n        // Dimensions display\r\n        const dimensionsDisplay = document.createElement('span');\r\n        dimensionsDisplay.id = 'dimensions-display';\r\n        dimensionsDisplay.innerText = 'Dimensions: 0 x 0';\r\n        \r\n        // Add all controls to container\r\n        zoomControlsContainer.appendChild(zoomOutBtn);\r\n        zoomControlsContainer.appendChild(zoomDisplay);\r\n        zoomControlsContainer.appendChild(zoomInBtn);\r\n        zoomControlsContainer.appendChild(resetZoomBtn);\r\n        zoomControlsContainer.appendChild(dimensionsDisplay);\r\n        \r\n        // Add container to the editor UI\r\n        container.appendChild(zoomControlsContainer);\r\n    }\r\n\r\n    setupEventListeners() {\r\n        const container = document.getElementById('texture-editor-container');\r\n        if (!container) return;\r\n\r\n        // Global events\r\n        document.body.addEventListener('editTexture', (event) => {\r\n            this.updateUIFromSettings(event.detail.data);\r\n        });\r\n\r\n        // Tool selection\r\n        container.querySelectorAll('.editor-module__btn').forEach(btn => {\r\n            btn.addEventListener('click', (e) => {\r\n                container.querySelectorAll('.editor-module__btn').forEach(b => b.classList.remove('active'));\r\n                e.target.classList.add('active');\r\n                this.setActiveTool(e.target.id);\r\n            });\r\n        });\r\n\r\n        // Brush size\r\n        const brushSizeInput = container.querySelector('#brush-size');\r\n        const brushSizeDisplay = container.querySelector('#brush-size-display');\r\n        brushSizeInput.addEventListener('input', (e) => {\r\n            this.brushSize = parseInt(e.target.value);\r\n            brushSizeDisplay.textContent = `${this.brushSize}px`;\r\n        });\r\n\r\n        // Color palette\r\n        container.querySelectorAll('.texture-editor__color-btn').forEach(btn => {\r\n            btn.addEventListener('click', (e) => {\r\n                container.querySelectorAll('.texture-editor__color-btn').forEach(b => b.classList.remove('active'));\r\n                e.target.classList.add('active');\r\n                this.currentColor = e.target.dataset.color;\r\n                // Update both color and transparency inputs\r\n                const colorValue = this.currentColor.substring(0, 7);\r\n                const alphaValue = parseInt(this.currentColor.substring(7, 9), 16) || 255;\r\n                \r\n                container.querySelector('#custom-color-picker').value = colorValue;\r\n                const transparencySlider = container.querySelector('#transparency-slider');\r\n                if (transparencySlider) {\r\n                    transparencySlider.value = alphaValue;\r\n                    document.getElementById('transparency-display').textContent = \r\n                        `${Math.round((alphaValue / 255) * 100)}%`;\r\n                }\r\n            });\r\n        });\r\n\r\n        // Custom color picker\r\n        const customColorPicker = container.querySelector('#custom-color-picker');\r\n        customColorPicker.addEventListener('input', (e) => {\r\n            // Preserve alpha when changing color\r\n            const alpha = this.currentColor.substring(7, 9) || 'FF';\r\n            this.currentColor = e.target.value + alpha;\r\n            container.querySelectorAll('.texture-editor__color-btn').forEach(b => b.classList.remove('active'));\r\n        });\r\n        \r\n        // Transparency slider\r\n        const transparencySlider = container.querySelector('#transparency-slider');\r\n        transparencySlider.addEventListener('input', (e) => {\r\n            const alphaValue = parseInt(e.target.value);\r\n            const alphaHex = alphaValue.toString(16).padStart(2, '0').toUpperCase();\r\n            \r\n            // Update alpha in the current color\r\n            this.currentColor = this.currentColor.substring(0, 7) + alphaHex;\r\n            \r\n            // Update display\r\n            document.getElementById('transparency-display').textContent = \r\n                `${Math.round((alphaValue / 255) * 100)}%`;\r\n        });\r\n\r\n        // Canvas drawing events\r\n        this.canvas.addEventListener('mousedown', (e) => {\r\n            if (e.button === 0) { // Left click                \r\n                this.startDrawing(e);\r\n            }\r\n        });\r\n        \r\n        this.canvas.addEventListener('mousemove', (e) => {\r\n            if (this.isDrawing) {\r\n                this.draw(e);\r\n            }\r\n        });\r\n        \r\n        this.canvas.addEventListener('mouseup', (e) => {\r\n            if (e.button === 0) { // Left click\r\n                if (this.isDrawing) {\r\n                    this.stopDrawing();\r\n                }\r\n            } \r\n        });\r\n        \r\n        this.canvas.addEventListener('mouseleave', () => {\r\n            this.stopDrawing();\r\n        });\r\n        \r\n        // Zoom with mouse wheel\r\n        this.canvas.addEventListener('wheel', (e) => {\r\n            e.preventDefault();\r\n            \r\n            // Calculate zoom point relative to canvas\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            const mouseX = e.clientX - rect.left;\r\n            const mouseY = e.clientY - rect.top;\r\n            \r\n            // Calculate zoom direction\r\n            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;\r\n            \r\n            // Calculate new zoom level\r\n            let newZoom = this.zoomLevel * zoomFactor;\r\n            \r\n            // Constrain zoom level\r\n            newZoom = Math.max(this.minZoomLevel, Math.min(this.maxZoomLevel, newZoom));\r\n            \r\n            // Calculate zoom point in image coordinates\r\n            const imageX = mouseX / this.zoomLevel;\r\n            const imageY = mouseY / this.zoomLevel;\r\n            \r\n            // Update zoom level\r\n            this.zoomLevel = newZoom;            \r\n            \r\n            // Update display\r\n            this.updateZoomDisplay();\r\n            this.renderCanvas();\r\n        });\r\n        \r\n        // Zoom control buttons\r\n        container.querySelector('#zoom-in-btn').addEventListener('click', () => {\r\n            this.zoom(1.25);\r\n        });\r\n        \r\n        container.querySelector('#zoom-out-btn').addEventListener('click', () => {\r\n            this.zoom(0.8);\r\n        });\r\n        \r\n        container.querySelector('#reset-zoom-btn').addEventListener('click', () => {\r\n            this.resetZoom();\r\n        });\r\n\r\n        // Action buttons\r\n        container.querySelector('#new-btn').addEventListener('click', () => this.newImage());\r\n        container.querySelector('#undo-btn').addEventListener('click', () => this.undo());\r\n        container.querySelector('#redo-btn').addEventListener('click', () => this.redo());\r\n        container.querySelector('#clear-btn').addEventListener('click', () => this.clear());\r\n        container.querySelector('.export-btn').addEventListener('click', () => {\r\n            this.saveTexture(this.getCurrentTexture());\r\n        });\r\n\r\n        // File upload\r\n        container.querySelector('input[type=\"file\"]').addEventListener('change', (e) => {\r\n            this.handleImageUpload(e);\r\n        });\r\n    }\r\n\r\n    zoom(factor) {\r\n        // Calculate new zoom level\r\n        let newZoom = this.zoomLevel * factor;\r\n        \r\n        // Constrain zoom level\r\n        newZoom = Math.max(this.minZoomLevel, Math.min(this.maxZoomLevel, newZoom));\r\n        \r\n        // Calculate center point of the viewport\r\n        const viewportWidth = this.canvas.clientWidth;\r\n        const viewportHeight = this.canvas.clientHeight;\r\n        const centerX = viewportWidth / 2;\r\n        const centerY = viewportHeight / 2;\r\n        \r\n        // Calculate zoom point in image coordinates\r\n        const imageX = centerX / this.zoomLevel;\r\n        const imageY = centerY / this.zoomLevel;\r\n        \r\n        // Update zoom level\r\n        this.zoomLevel = newZoom;\r\n        \r\n        // Update display\r\n        this.updateZoomDisplay();\r\n        this.renderCanvas();\r\n        // Update canvas display size\r\n        this.updateCanvasDisplaySize();\r\n    }\r\n    \r\n    updateCanvasDisplaySize() {\r\n\r\n        \r\n        // Set the canvas display size based on zoom\r\n        const displayWidth = Math.ceil(this.imageWidth * this.zoomLevel);\r\n        const displayHeight = Math.ceil(this.imageHeight * this.zoomLevel);\r\n        \r\n        this.canvas.style.width = `${displayWidth}px`;\r\n        this.canvas.style.height = `${displayHeight}px`;\r\n        this.transparencyChecker.style.width = `${displayWidth}px`;\r\n        this.transparencyChecker.style.height = `${displayHeight}px`;\r\n        \r\n        // Update the cursor based on the active tool\r\n        this.canvas.style.cursor = this.getToolCursor();\r\n    }\r\n    \r\n    setupTransparencyChecker(container) {\r\n        const displayWidth = Math.ceil(this.imageWidth * this.zoomLevel);\r\n        const displayHeight = Math.ceil(this.imageHeight * this.zoomLevel);\r\n        // Create and add transparency checker background\r\n        this.transparencyChecker = document.createElement('div');\r\n        this.transparencyChecker.className = 'transparency-checker';\r\n        this.transparencyChecker.style.position = 'absolute';\r\n        this.transparencyChecker.style.top = '0';\r\n        this.transparencyChecker.style.left = '0';\r\n        this.transparencyChecker.style.bottom = '0';\r\n        this.transparencyChecker.style.right = '0';        \r\n        this.transparencyChecker.style.margin = 'auto';\r\n        this.transparencyChecker.style.width = `${displayWidth}px`;\r\n        this.transparencyChecker.style.height = `${displayHeight}px`;\r\n        this.transparencyChecker.style.backgroundImage = 'linear-gradient(45deg, #ffffff10 25%, transparent 25%), linear-gradient(-45deg, #ffffff10 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #ffffff10 75%), linear-gradient(-45deg, transparent 75%, #ffffff10 75%)';\r\n        this.transparencyChecker.style.backgroundSize = '10px 10px';\r\n        this.transparencyChecker.style.backgroundPosition = '0 0, 0 10px, 10px -10px, -10px 0px';\r\n        this.transparencyChecker.style.pointerEvents = 'none'; // Make it non-interactive\r\n        this.transparencyChecker.style.zIndex = '-1';\r\n        \r\n        container.appendChild(this.transparencyChecker);\r\n    }\r\n    \r\n    resetZoom() {\r\n        // Reset zoom level\r\n        this.zoomLevel = 1;\r\n\r\n        // Update display\r\n        this.updateZoomDisplay();\r\n        this.renderCanvas();\r\n\r\n        // Update canvas display size to match zoom\r\n        this.updateCanvasDisplaySize();\r\n    }\r\n    \r\n    updateZoomDisplay() {\r\n        const zoomDisplay = document.getElementById('zoom-display');\r\n        if (zoomDisplay) {\r\n            zoomDisplay.innerText = `${Math.round(this.zoomLevel * 100)}%`;\r\n        }\r\n    }\r\n    \r\n    getToolCursor() {\r\n        switch (this.activeTool) {\r\n            case 'brush': return 'crosshair';\r\n            case 'eraser': return 'cell';\r\n            case 'fill': return 'pointer';\r\n            case 'eyedropper': return 'copy';\r\n            default: return 'crosshair';\r\n        }\r\n    }\r\n\r\n    setActiveTool(toolId) {\r\n        switch (toolId) {\r\n            case 'brush-tool':\r\n                this.activeTool = 'brush';\r\n                this.canvas.style.cursor = 'crosshair';\r\n                break;\r\n            case 'eraser-tool':\r\n                this.activeTool = 'eraser';\r\n                this.canvas.style.cursor = 'cell';\r\n                break;\r\n            case 'fill-tool':\r\n                this.activeTool = 'fill';\r\n                this.canvas.style.cursor = 'pointer';\r\n                break;\r\n            case 'eyedropper-tool':\r\n                this.activeTool = 'eyedropper';\r\n                this.canvas.style.cursor = 'copy';\r\n                break;\r\n            default:\r\n                this.activeTool = 'brush';\r\n                this.canvas.style.cursor = 'crosshair';\r\n        }\r\n    }\r\n\r\n    updateUIFromSettings(imageSrc) {\r\n        if (!imageSrc) {\r\n            document.getElementById('noTextureMessage').style.display = 'block';\r\n            this.canvas.style.display = 'none';\r\n            return;\r\n        }\r\n\r\n        // Load image onto canvas\r\n        const img = new Image();\r\n        img.onload = () => {\r\n            // Set canvas dimensions to match image dimensions\r\n            this.imageWidth = img.width;\r\n            this.imageHeight = img.height;\r\n            \r\n            // Update canvas size to match image size\r\n            this.canvas.width = this.imageWidth;\r\n            this.canvas.height = this.imageHeight;\r\n            \r\n            // Update dimensions display\r\n            this.updateDimensionsDisplay();\r\n            \r\n            // Show canvas and hide message\r\n            document.getElementById('noTextureMessage').style.display = 'none';\r\n            this.canvas.style.display = 'block';\r\n            \r\n            // Draw image on canvas with proper alpha support\r\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n            this.ctx.drawImage(img, 0, 0, this.imageWidth, this.imageHeight);\r\n            \r\n            // Reset zoom\r\n            this.resetZoom();\r\n            \r\n            // Save initial state to history\r\n            this.saveToHistory();\r\n            \r\n            // Apply initial render\r\n            this.renderCanvas();\r\n        };\r\n        img.src = imageSrc;\r\n    }\r\n    \r\n    updateDimensionsDisplay() {\r\n        const dimensionsDisplay = document.getElementById('dimensions-display');\r\n        if (dimensionsDisplay) {\r\n            dimensionsDisplay.innerText = `Dimensions: ${this.imageWidth} x ${this.imageHeight}`;\r\n        }\r\n    }\r\n    \r\n    renderCanvas() {\r\n        // Store the current state\r\n        const currentState = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Clear the canvas\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Set up the transformation for zoom\r\n        this.ctx.setTransform(\r\n            this.zoomLevel, 0, \r\n            0, this.zoomLevel, \r\n            this.zoomLevel, \r\n            this.zoomLevel\r\n        );\r\n        \r\n        // Draw the image data\r\n        this.ctx.putImageData(currentState, 0, 0);\r\n        \r\n        // Reset the transformation for UI elements\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n    }\r\n\r\n    startDrawing(e) {\r\n        this.isDrawing = true;\r\n        \r\n        // Save state before drawing\r\n        this.saveToHistory();\r\n        \r\n        const pos = this.getCanvasCoordinates(e);\r\n        \r\n        switch (this.activeTool) {\r\n            case 'brush':\r\n                this.drawPixel(pos.x, pos.y);\r\n                break;\r\n            case 'eraser':\r\n                this.erasePixel(pos.x, pos.y);\r\n                break;\r\n            case 'fill':\r\n                this.fillArea(pos.x, pos.y);\r\n                break;\r\n            case 'eyedropper':\r\n                this.pickColor(pos.x, pos.y);\r\n                break;\r\n        }\r\n    }\r\n\r\n    draw(e) {\r\n        if (!this.isDrawing) return;\r\n        \r\n        const pos = this.getCanvasCoordinates(e);\r\n        \r\n        switch (this.activeTool) {\r\n            case 'brush':\r\n                this.drawPixel(pos.x, pos.y);\r\n                break;\r\n            case 'eraser':\r\n                this.erasePixel(pos.x, pos.y);\r\n                break;\r\n        }\r\n    }\r\n\r\n    stopDrawing() {\r\n        this.isDrawing = false;\r\n    }\r\n\r\n    getCanvasCoordinates(e) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        \r\n        // Calculate the mouse position relative to the canvas\r\n        const mouseX = e.clientX - rect.left;\r\n        const mouseY = e.clientY - rect.top;\r\n        \r\n        // Convert to image coordinates considering zoom\r\n        const x = Math.floor(mouseX / this.zoomLevel);\r\n        const y = Math.floor(mouseY / this.zoomLevel);\r\n        \r\n        return { x, y };\r\n    }\r\n\r\n    drawPixel(x, y) {\r\n        // Save current transform\r\n        this.ctx.save();\r\n        \r\n        // Reset transform for accurate drawing\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        // Use RGBA for colors with transparency\r\n        this.ctx.fillStyle = this.hexToRgbaString(this.currentColor);\r\n        \r\n        if (this.brushSize === 1) {\r\n            this.ctx.fillRect(x, y, 1, 1);\r\n        } else {\r\n            const offset = Math.floor(this.brushSize / 2);\r\n            for (let i = -offset; i < this.brushSize - offset; i++) {\r\n                for (let j = -offset; j < this.brushSize - offset; j++) {\r\n                    const posX = x + i;\r\n                    const posY = y + j;\r\n                    if (posX >= 0 && posX < this.canvas.width && posY >= 0 && posY < this.canvas.height) {\r\n                        this.ctx.fillRect(posX, posY, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Restore transform\r\n        this.ctx.restore();\r\n        \r\n        // Reapply zoom\r\n        this.renderCanvas();\r\n    }\r\n    erasePixel(x, y) {\r\n        // Save current transform\r\n        this.ctx.save();\r\n        \r\n        // Reset transform for accurate erasing\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        // Get current image data\r\n        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n        const data = imageData.data;\r\n        \r\n        // Apply eraser to pixels\r\n        if (this.brushSize === 1) {\r\n            const index = (y * this.canvas.width + x) * 4;\r\n            // Set all channels (RGB and Alpha) to 0 for full transparency\r\n            data[index] = 0;     // R\r\n            data[index + 1] = 0; // G\r\n            data[index + 2] = 0; // B\r\n            data[index + 3] = 0; // A\r\n        } else {\r\n            const offset = Math.floor(this.brushSize / 2);\r\n            for (let i = -offset; i < this.brushSize - offset; i++) {\r\n                for (let j = -offset; j < this.brushSize - offset; j++) {\r\n                    const posX = x + i;\r\n                    const posY = y + j;\r\n                    if (posX >= 0 && posX < this.canvas.width && posY >= 0 && posY < this.canvas.height) {\r\n                        const index = (posY * this.canvas.width + posX) * 4;\r\n                        // Set all channels to 0\r\n                        data[index] = 0;     // R\r\n                        data[index + 1] = 0; // G\r\n                        data[index + 2] = 0; // B\r\n                        data[index + 3] = 0; // A\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Put the modified image data back\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n        \r\n        // Restore transform\r\n        this.ctx.restore();\r\n        \r\n        // Reapply zoom\r\n        this.renderCanvas();\r\n    }\r\n\r\n    fillArea(x, y) {\r\n        if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageHeight) {\r\n            return; // Out of bounds\r\n        }\r\n        \r\n        // Save current transform\r\n        this.ctx.save();\r\n        \r\n        // Reset transform for accurate fill\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        // Get the pixel color at the clicked position\r\n        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n        const data = imageData.data;\r\n        \r\n        // Get the index of the clicked pixel\r\n        const index = (y * this.canvas.width + x) * 4;\r\n        const targetR = data[index];\r\n        const targetG = data[index + 1];\r\n        const targetB = data[index + 2];\r\n        const targetA = data[index + 3];\r\n        \r\n        // Don't fill if clicking on the same color\r\n        const fillColor = this.hexToRgba(this.currentColor);\r\n        if (targetR === fillColor.r && targetG === fillColor.g && targetB === fillColor.b && targetA === fillColor.a) {\r\n            this.ctx.restore();\r\n            return;\r\n        }\r\n        \r\n        // Flood fill algorithm\r\n        const stack = [{x, y}];\r\n        const visited = new Set();\r\n        \r\n        while (stack.length > 0) {\r\n            const pixel = stack.pop();\r\n            const px = pixel.x;\r\n            const py = pixel.y;\r\n            \r\n            // Skip if outside canvas or already visited\r\n            if (px < 0 || px >= this.canvas.width || py < 0 || py >= this.canvas.height ||\r\n                visited.has(`${px},${py}`)) {\r\n                continue;\r\n            }\r\n            \r\n            // Get current pixel index\r\n            const currentIndex = (py * this.canvas.width + px) * 4;\r\n            \r\n            // Check if the pixel has the target color\r\n            if (data[currentIndex] === targetR && \r\n                data[currentIndex + 1] === targetG && \r\n                data[currentIndex + 2] === targetB && \r\n                data[currentIndex + 3] === targetA) {\r\n                \r\n                // Set the new color\r\n                data[currentIndex] = fillColor.r;\r\n                data[currentIndex + 1] = fillColor.g;\r\n                data[currentIndex + 2] = fillColor.b;\r\n                data[currentIndex + 3] = fillColor.a;\r\n                \r\n                // Mark as visited\r\n                visited.add(`${px},${py}`);\r\n                \r\n                // Add neighbors to stack\r\n                stack.push({x: px + 1, y: py});\r\n                stack.push({x: px - 1, y: py});\r\n                stack.push({x: px, y: py + 1});\r\n                stack.push({x: px, y: py - 1});\r\n            }\r\n        }\r\n        \r\n        // Update the canvas with the new image data\r\n        this.ctx.putImageData(imageData, 0, 0);\r\n        \r\n        // Restore transform\r\n        this.ctx.restore();\r\n        \r\n        // Reapply zoom\r\n        this.renderCanvas();\r\n    }\r\n\r\n    pickColor(x, y) {\r\n        if (x < 0 || x >= this.imageWidth || y < 0 || y >= this.imageHeight) {\r\n            return; // Out of bounds\r\n        }\r\n        \r\n        // Save current transform\r\n        this.ctx.save();\r\n        \r\n        // Reset transform for accurate color picking\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        const pixel = this.ctx.getImageData(x, y, 1, 1).data;\r\n        \r\n        // Create hex color including alpha\r\n        const hexColor = `#${pixel[0].toString(16).padStart(2, '0')}${pixel[1].toString(16).padStart(2, '0')}${pixel[2].toString(16).padStart(2, '0')}${pixel[3].toString(16).padStart(2, '0')}`;\r\n        \r\n        this.currentColor = hexColor;\r\n        \r\n        // Update UI to show selected color\r\n        const customColorPicker = document.querySelector('#custom-color-picker');\r\n        if (customColorPicker) {\r\n            customColorPicker.value = hexColor.substring(0, 7);\r\n        }\r\n        \r\n        // Update transparency slider\r\n        const transparencySlider = document.querySelector('#transparency-slider');\r\n        if (transparencySlider) {\r\n            transparencySlider.value = pixel[3];\r\n            document.getElementById('transparency-display').textContent = \r\n                `${Math.round((pixel[3] / 255) * 100)}%`;\r\n        }\r\n        \r\n        // Deselect any color in the palette\r\n        document.querySelectorAll('.texture-editor__color-btn').forEach(btn => {\r\n            btn.classList.remove('active');\r\n            if (btn.dataset.color === hexColor) {\r\n                btn.classList.add('active');\r\n            }\r\n        });\r\n        \r\n        // Restore transform\r\n        this.ctx.restore();\r\n    }\r\n\r\n    hexToRgba(hex) {\r\n        const r = parseInt(hex.slice(1, 3), 16);\r\n        const g = parseInt(hex.slice(3, 5), 16);\r\n        const b = parseInt(hex.slice(5, 7), 16);\r\n        const a = parseInt(hex.slice(7, 9) || 'FF', 16);\r\n        return { r, g, b, a };\r\n    }\r\n    \r\n    hexToRgbaString(hex) {\r\n        const { r, g, b, a } = this.hexToRgba(hex);\r\n        return `rgba(${r}, ${g}, ${b}, ${a / 255})`;\r\n    }\r\n\r\n    saveToHistory() {\r\n        // Trim history if we're not at the end\r\n        if (this.historyIndex < this.history.length - 1) {\r\n            this.history = this.history.slice(0, this.historyIndex + 1);\r\n        }\r\n        \r\n        // Save current state - we need to reset transform to get the actual image data\r\n        this.ctx.save();\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\r\n        this.ctx.restore();\r\n        \r\n        // Save to history\r\n        this.history.push(imageData);\r\n        this.historyIndex = this.history.length - 1;\r\n        \r\n        // Update undo/redo buttons\r\n        this.updateUndoRedoButtons();\r\n    }\r\n\r\n    updateUndoRedoButtons() {\r\n        const undoBtn = document.getElementById('undo-btn');\r\n        const redoBtn = document.getElementById('redo-btn');\r\n        \r\n        if (undoBtn) {\r\n            undoBtn.disabled = this.historyIndex <= 0;\r\n        }\r\n        \r\n        if (redoBtn) {\r\n            redoBtn.disabled = this.historyIndex >= this.history.length - 1;\r\n        }\r\n    }\r\n\r\n    newImage() {\r\n        // Prompt user for dimensions\r\n        const width = prompt('Enter width for new texture (1-2048):', '64');\r\n        const height = prompt('Enter height for new texture (1-2048):', '64');\r\n    \r\n        // Validate input\r\n        const newWidth = parseInt(width);\r\n        const newHeight = parseInt(height);\r\n    \r\n        if (isNaN(newWidth) || isNaN(newHeight) || newWidth < 1 || newWidth > 2048 || newHeight < 1 || newHeight > 2048) {\r\n            alert('Invalid dimensions. Please enter values between 1 and 2048.');\r\n            return;\r\n        }\r\n    \r\n        // Save current state before creating a new texture\r\n        this.saveToHistory();\r\n    \r\n        // Set canvas dimensions\r\n        this.imageWidth = newWidth;\r\n        this.imageHeight = newHeight;\r\n        this.canvas.width = this.imageWidth;\r\n        this.canvas.height = this.imageHeight;\r\n    \r\n        // Clear canvas with full transparency\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    \r\n        // Update dimensions display\r\n        this.updateDimensionsDisplay();\r\n    \r\n        // Show canvas and hide no texture message\r\n        document.getElementById('noTextureMessage').style.display = 'none';\r\n        this.canvas.style.display = 'block';\r\n    \r\n        // Reset zoom\r\n        this.resetZoom();\r\n    \r\n        // Save initial state to history\r\n        this.saveToHistory();\r\n    \r\n        // Render canvas with zoom\r\n        this.renderCanvas();\r\n    }\r\n\r\n    undo() {\r\n        if (this.historyIndex > 0) {\r\n            this.historyIndex--;\r\n            \r\n            // Reset transform to apply image data\r\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            this.ctx.putImageData(this.history[this.historyIndex], 0, 0);\r\n            \r\n            // Update buttons and rerender\r\n            this.updateUndoRedoButtons();\r\n            this.renderCanvas();\r\n        }\r\n    }\r\n\r\n    redo() {\r\n        if (this.historyIndex < this.history.length - 1) {\r\n            this.historyIndex++;\r\n            \r\n            // Reset transform to apply image data\r\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n            this.ctx.putImageData(this.history[this.historyIndex], 0, 0);\r\n            \r\n            // Update buttons and rerender\r\n            this.updateUndoRedoButtons();\r\n            this.renderCanvas();\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        // Save state before clearing\r\n        this.saveToHistory();\r\n        \r\n        // Clear canvas with full transparency\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n        \r\n        // Reapply zoom\r\n        this.renderCanvas();\r\n    }\r\n\r\n    getCurrentTexture() {\r\n        // Save current state\r\n        this.ctx.save();\r\n        \r\n        // Reset transform to get the actual image data\r\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        \r\n        // Make sure to use PNG format to preserve transparency\r\n        const dataURL = this.canvas.toDataURL('image/png');\r\n        \r\n        // Restore transform\r\n        this.ctx.restore();\r\n        \r\n        return dataURL;\r\n    }\r\n\r\n    saveTexture(data) {\r\n        document.body.dispatchEvent(new CustomEvent('saveTexture', {\r\n            detail: { data: data, propertyName: 'image' },\r\n        }));\r\n    }\r\n\r\n    handleImageUpload(event) {\r\n        const file = event.target.files[0];\r\n        if (!file) return;\r\n        \r\n        const reader = new FileReader();\r\n        reader.onload = (e) => {\r\n            const img = new Image();\r\n            img.onload = () => {\r\n                // Set canvas dimensions to match image dimensions\r\n                this.imageWidth = img.width;\r\n                this.imageHeight = img.height;\r\n                this.canvas.width = this.imageWidth;\r\n                this.canvas.height = this.imageHeight;\r\n                \r\n                // Update dimensions display\r\n                this.updateDimensionsDisplay();\r\n                \r\n                // Clear canvas\r\n                this.ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n                \r\n                // Draw image on canvas - this will preserve transparency\r\n                this.ctx.drawImage(img, 0, 0, this.imageWidth, this.imageHeight);\r\n                \r\n                // Show canvas\r\n                document.getElementById('noTextureMessage').style.display = 'none';\r\n                this.canvas.style.display = 'block';\r\n                \r\n                // Reset zoom\r\n                this.resetZoom();\r\n                \r\n                // Save state to history\r\n                this.saveToHistory();\r\n                \r\n                // Render canvas with zoom\r\n                this.renderCanvas();\r\n            };\r\n            img.src = e.target.result;\r\n        };\r\n        reader.readAsDataURL(file);\r\n    }\r\n}\r\n",
        "filePath": "/global/libraries/js/TextureEditor.js"
      },
      "SimplexNoise": {
        "title": "SimplexNoise",
        "fileName": "SimplexNoise",
        "script": "class SimplexNoise {\r\n    constructor(seed = 0) {\r\n        // Permutation table for randomization\r\n        this.perm = new Uint8Array(256);\r\n        this.seed = seed;\r\n        this.initPermutation();\r\n    }\r\n\r\n    // Initialize permutation table with a seed\r\n    initPermutation() {\r\n        for (let i = 0; i < 256; i++) {\r\n            this.perm[i] = i;\r\n        }\r\n        // Shuffle using a simple seeded random\r\n        let rand = this.seededRandom();\r\n        for (let i = 255; i > 0; i--) {\r\n            const j = Math.floor(rand() * (i + 1));\r\n            [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];\r\n        }\r\n    }\r\n\r\n    // Simple seeded random number generator\r\n    seededRandom() {\r\n        let x = Math.sin(this.seed++) * 10000;\r\n        return () => {\r\n            x = Math.sin(x + this.seed++) * 10000;\r\n            return x - Math.floor(x);\r\n        };\r\n    }\r\n\r\n    // 2D Simplex noise function\r\n    noise2D(x, y) {\r\n        // Skew input coordinates to simplex grid\r\n        const s = (x + y) * 0.366025403784; // F = (sqrt(3) - 1) / 2\r\n        const i = Math.floor(x + s);\r\n        const j = Math.floor(y + s);\r\n\r\n        // Unskew back to get simplex cell origin\r\n        const t = (i + j) * 0.211324865405; // G = (3 - sqrt(3)) / 6\r\n        const X0 = i - t;\r\n        const Y0 = j - t;\r\n        const x0 = x - X0;\r\n        const y0 = y - Y0;\r\n\r\n        // Determine which simplex we're in\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n\r\n        // Offsets for second and third corners\r\n        const x1 = x0 - i1 + 0.211324865405;\r\n        const y1 = y0 - j1 + 0.211324865405;\r\n        const x2 = x0 - 1 + 0.42264973081;\r\n        const y2 = y0 - 1 + 0.42264973081;\r\n\r\n        // Gradient indices\r\n        const gi0 = this.perm[(i + this.perm[j & 255]) & 255] % 4;\r\n        const gi1 = this.perm[(i + i1 + this.perm[(j + j1) & 255]) & 255] % 4;\r\n        const gi2 = this.perm[(i + 1 + this.perm[(j + 1) & 255]) & 255] % 4;\r\n\r\n        // Calculate contributions from each corner\r\n        const n0 = this.contribution(x0, y0, gi0);\r\n        const n1 = this.contribution(x1, y1, gi1);\r\n        const n2 = this.contribution(x2, y2, gi2);\r\n\r\n        // Sum contributions and normalize to [-1, 1]\r\n        return (n0 + n1 + n2) * 70; // Scale to approximate [-1, 1]\r\n    }\r\n\r\n    // Calculate contribution from a corner\r\n    contribution(x, y, gi) {\r\n        // Distance falloff\r\n        const t = 0.5 - x * x - y * y;\r\n        if (t < 0) return 0;\r\n\r\n        // Gradient vectors (simplified 2D)\r\n        const gradients = [\r\n            [1, 1], [-1, 1], [1, -1], [-1, -1]\r\n        ];\r\n        const grad = gradients[gi];\r\n        const t2 = t * t;\r\n        return t2 * t2 * (grad[0] * x + grad[1] * y);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/SimplexNoise.js"
      },
      "three-nebula": {
        "fileName": "three-nebula",
        "isModule": true,
        "importName": "Nebula",
        "requireName": "Nebula",
        "script": "class dummyNebula {}\r\n\r\n!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define([],e):\"object\"==typeof exports?exports.Nebula=e():t.Nebula=e()}(window,(function(){return(()=>{var t={705:(t,e,i)=>{var s=i(639).Symbol;t.exports=s},636:(t,e,i)=>{var s=i(545),r=i(694),n=i(469),o=i(144),a=i(776),h=i(719),c=Object.prototype.hasOwnProperty;t.exports=function(t,e){var i=n(t),u=!i&&r(t),l=!i&&!u&&o(t),d=!i&&!u&&!l&&h(t),p=i||u||l||d,y=p?s(t.length,String):[],f=y.length;for(var m in t)!e&&!c.call(t,m)||p&&(\"length\"==m||l&&(\"offset\"==m||\"parent\"==m)||d&&(\"buffer\"==m||\"byteLength\"==m||\"byteOffset\"==m)||a(m,f))||y.push(m);return y}},932:t=>{t.exports=function(t,e){for(var i=-1,s=null==t?0:t.length,r=Array(s);++i<s;)r[i]=e(t[i],i,t);return r}},311:(t,e,i)=>{var s=i(877);t.exports=function(t){var e=t.length;return e?t[s(0,e-1)]:void 0}},239:(t,e,i)=>{var s=i(705),r=i(607),n=i(333),o=s?s.toStringTag:void 0;t.exports=function(t){return null==t?void 0===t?\"[object Undefined]\":\"[object Null]\":o&&o in Object(t)?r(t):n(t)}},454:(t,e,i)=>{var s=i(239),r=i(5);t.exports=function(t){return r(t)&&\"[object Arguments]\"==s(t)}},749:(t,e,i)=>{var s=i(239),r=i(780),n=i(5),o={};o[\"[object Float32Array]\"]=o[\"[object Float64Array]\"]=o[\"[object Int8Array]\"]=o[\"[object Int16Array]\"]=o[\"[object Int32Array]\"]=o[\"[object Uint8Array]\"]=o[\"[object Uint8ClampedArray]\"]=o[\"[object Uint16Array]\"]=o[\"[object Uint32Array]\"]=!0,o[\"[object Arguments]\"]=o[\"[object Array]\"]=o[\"[object ArrayBuffer]\"]=o[\"[object Boolean]\"]=o[\"[object DataView]\"]=o[\"[object Date]\"]=o[\"[object Error]\"]=o[\"[object Function]\"]=o[\"[object Map]\"]=o[\"[object Number]\"]=o[\"[object Object]\"]=o[\"[object RegExp]\"]=o[\"[object Set]\"]=o[\"[object String]\"]=o[\"[object WeakMap]\"]=!1,t.exports=function(t){return n(t)&&r(t.length)&&!!o[s(t)]}},280:(t,e,i)=>{var s=i(726),r=i(916),n=Object.prototype.hasOwnProperty;t.exports=function(t){if(!s(t))return r(t);var e=[];for(var i in Object(t))n.call(t,i)&&\"constructor\"!=i&&e.push(i);return e}},877:t=>{var e=Math.floor,i=Math.random;t.exports=function(t,s){return t+e(i()*(s-t+1))}},992:(t,e,i)=>{var s=i(311),r=i(628);t.exports=function(t){return s(r(t))}},545:t=>{t.exports=function(t,e){for(var i=-1,s=Array(t);++i<t;)s[i]=e(i);return s}},518:t=>{t.exports=function(t){return function(e){return t(e)}}},415:(t,e,i)=>{var s=i(932);t.exports=function(t,e){return s(e,(function(e){return t[e]}))}},957:(t,e,i)=>{var s=\"object\"==typeof i.g&&i.g&&i.g.Object===Object&&i.g;t.exports=s},607:(t,e,i)=>{var s=i(705),r=Object.prototype,n=r.hasOwnProperty,o=r.toString,a=s?s.toStringTag:void 0;t.exports=function(t){var e=n.call(t,a),i=t[a];try{t[a]=void 0;var s=!0}catch(t){}var r=o.call(t);return s&&(e?t[a]=i:delete t[a]),r}},776:t=>{var e=/^(?:0|[1-9]\\d*)$/;t.exports=function(t,i){var s=typeof t;return!!(i=null==i?9007199254740991:i)&&(\"number\"==s||\"symbol\"!=s&&e.test(t))&&t>-1&&t%1==0&&t<i}},726:t=>{var e=Object.prototype;t.exports=function(t){var i=t&&t.constructor;return t===(\"function\"==typeof i&&i.prototype||e)}},916:(t,e,i)=>{var s=i(569)(Object.keys,Object);t.exports=s},167:(t,e,i)=>{t=i.nmd(t);var s=i(957),r=e&&!e.nodeType&&e,n=r&&t&&!t.nodeType&&t,o=n&&n.exports===r&&s.process,a=function(){try{return n&&n.require&&n.require(\"util\").types||o&&o.binding&&o.binding(\"util\")}catch(t){}}();t.exports=a},333:t=>{var e=Object.prototype.toString;t.exports=function(t){return e.call(t)}},569:t=>{t.exports=function(t,e){return function(i){return t(e(i))}}},639:(t,e,i)=>{var s=i(957),r=\"object\"==typeof self&&self&&self.Object===Object&&self,n=s||r||Function(\"return this\")();t.exports=n},694:(t,e,i)=>{var s=i(454),r=i(5),n=Object.prototype,o=n.hasOwnProperty,a=n.propertyIsEnumerable,h=s(function(){return arguments}())?s:function(t){return r(t)&&o.call(t,\"callee\")&&!a.call(t,\"callee\")};t.exports=h},469:t=>{var e=Array.isArray;t.exports=e},612:(t,e,i)=>{var s=i(560),r=i(780);t.exports=function(t){return null!=t&&r(t.length)&&!s(t)}},144:(t,e,i)=>{t=i.nmd(t);var s=i(639),r=i(62),n=e&&!e.nodeType&&e,o=n&&t&&!t.nodeType&&t,a=o&&o.exports===n?s.Buffer:void 0,h=(a?a.isBuffer:void 0)||r;t.exports=h},560:(t,e,i)=>{var s=i(239),r=i(218);t.exports=function(t){if(!r(t))return!1;var e=s(t);return\"[object Function]\"==e||\"[object GeneratorFunction]\"==e||\"[object AsyncFunction]\"==e||\"[object Proxy]\"==e}},780:t=>{t.exports=function(t){return\"number\"==typeof t&&t>-1&&t%1==0&&t<=9007199254740991}},763:(t,e,i)=>{var s=i(239),r=i(5);t.exports=function(t){return\"number\"==typeof t||r(t)&&\"[object Number]\"==s(t)}},218:t=>{t.exports=function(t){var e=typeof t;return null!=t&&(\"object\"==e||\"function\"==e)}},5:t=>{t.exports=function(t){return null!=t&&\"object\"==typeof t}},719:(t,e,i)=>{var s=i(749),r=i(518),n=i(167),o=n&&n.isTypedArray,a=o?r(o):s;t.exports=a},674:(t,e,i)=>{var s=i(636),r=i(280),n=i(612);t.exports=function(t){return n(t)?s(t):r(t)}},534:(t,e,i)=>{var s=i(311),r=i(992),n=i(469);t.exports=function(t){return(n(t)?s:r)(t)}},62:t=>{t.exports=function(){return!1}},628:(t,e,i)=>{var s=i(415),r=i(674);t.exports=function(t){return null==t?[]:s(t,r(t))}},327:t=>{for(var e=[],i=0;i<256;++i)e[i]=(i+256).toString(16).substr(1);t.exports=function(t,i){var s=i||0,r=e;return[r[t[s++]],r[t[s++]],r[t[s++]],r[t[s++]],\"-\",r[t[s++]],r[t[s++]],\"-\",r[t[s++]],r[t[s++]],\"-\",r[t[s++]],r[t[s++]],\"-\",r[t[s++]],r[t[s++]],r[t[s++]],r[t[s++]],r[t[s++]],r[t[s++]]].join(\"\")}},217:t=>{var e=\"undefined\"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||\"undefined\"!=typeof msCrypto&&\"function\"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(e){var i=new Uint8Array(16);t.exports=function(){return e(i),i}}else{var s=new Array(16);t.exports=function(){for(var t,e=0;e<16;e++)0==(3&e)&&(t=4294967296*Math.random()),s[e]=t>>>((3&e)<<3)&255;return s}}},570:(t,e,i)=>{var s,r,n=i(217),o=i(327),a=0,h=0;t.exports=function(t,e,i){var c=e&&i||0,u=e||[],l=(t=t||{}).node||s,d=void 0!==t.clockseq?t.clockseq:r;if(null==l||null==d){var p=n();null==l&&(l=s=[1|p[0],p[1],p[2],p[3],p[4],p[5]]),null==d&&(d=r=16383&(p[6]<<8|p[7]))}var y=void 0!==t.msecs?t.msecs:(new Date).getTime(),f=void 0!==t.nsecs?t.nsecs:h+1,m=y-a+(f-h)/1e4;if(m<0&&void 0===t.clockseq&&(d=d+1&16383),(m<0||y>a)&&void 0===t.nsecs&&(f=0),f>=1e4)throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");a=y,h=f,r=d;var g=(1e4*(268435455&(y+=122192928e5))+f)%4294967296;u[c++]=g>>>24&255,u[c++]=g>>>16&255,u[c++]=g>>>8&255,u[c++]=255&g;var x=y/4294967296*1e4&268435455;u[c++]=x>>>8&255,u[c++]=255&x,u[c++]=x>>>24&15|16,u[c++]=x>>>16&255,u[c++]=d>>>8|128,u[c++]=255&d;for(var v=0;v<6;++v)u[c+v]=l[v];return e||o(u)}}},e={};function i(s){var r=e[s];if(void 0!==r)return r.exports;var n=e[s]={id:s,loaded:!1,exports:{}};return t[s](n,n.exports,i),n.loaded=!0,n.exports}i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},i.nmd=t=>(t.paths=[],t.children||(t.children=[]),t);var s={};return(()=>{\"use strict\";i.r(s),i.d(s,{Alpha:()=>ii,ArraySpan:()=>Yt,Attraction:()=>si,Behaviour:()=>ei,Body:()=>le,BodySprite:()=>ve,Box:()=>Qt,BoxZone:()=>Pe,Collision:()=>ri,Color:()=>ni,ColorSpan:()=>Xt,ColorUtil:()=>gt,CrossZone:()=>oi,CustomRenderer:()=>Oi,Debug:()=>wi,Emitter:()=>Ke,FollowEmitter:()=>Mi,Force:()=>ai,GPURenderer:()=>Hi,Gravity:()=>hi,INTEGRATION_TYPE_EULER:()=>Ht,INTEGRATION_TYPE_RK2:()=>$t,INTEGRATION_TYPE_RK4:()=>Wt,INTEGRATION_TYPE_VERLET:()=>Kt,InitializerUtil:()=>_e,Life:()=>we,LineZone:()=>Oe,Mass:()=>ze,MathUtils:()=>Zt,MeshRenderer:()=>Ei,MeshZone:()=>Ee,PUID:()=>xt,Particle:()=>se,PointZone:()=>Te,Polar3D:()=>ie,PolarVelocity:()=>Xe,Pool:()=>re,Position:()=>Ze,RadialVelocity:()=>Je,Radius:()=>Ue,RandomDrift:()=>ci,Rate:()=>Ne,Repulsion:()=>ui,Rotate:()=>li,Scale:()=>di,ScreenZone:()=>Se,Span:()=>Ut,SphereZone:()=>Fe,Spring:()=>pi,SpriteRenderer:()=>Ti,System:()=>vi,THREEUtil:()=>It,Texture:()=>Ye,Util:()=>Rt,Vector3D:()=>ee,VectorVelocity:()=>Qe,createArraySpan:()=>Gt,createColorSpan:()=>Jt,createSpan:()=>Nt,default:()=>$i,ease:()=>k,easeInBack:()=>nt,easeInCirc:()=>it,easeInCubic:()=>q,easeInExpo:()=>K,easeInOutBack:()=>at,easeInOutCirc:()=>rt,easeInOutCubic:()=>G,easeInOutExpo:()=>et,easeInOutQuad:()=>L,easeInOutQuart:()=>Q,easeInOutSine:()=>W,easeInQuad:()=>U,easeInQuart:()=>X,easeInSine:()=>H,easeLinear:()=>Z,easeOutBack:()=>ot,easeOutCirc:()=>st,easeOutCubic:()=>Y,easeOutExpo:()=>tt,easeOutQuad:()=>N,easeOutQuart:()=>J,easeOutSine:()=>$,getEasingByName:()=>ct,integrate:()=>te,log:()=>zi,setEasingByName:()=>ht,uid:()=>Dt,withDefaults:()=>kt});var t={};i.r(t),i.d(t,{BoxZone:()=>Pe,LineZone:()=>Oe,MeshZone:()=>Ee,PointZone:()=>Te,ScreenZone:()=>Se,SphereZone:()=>Fe});var e={};i.r(e),i.d(e,{Body:()=>le,BodySprite:()=>ve,InitializerUtil:()=>_e,Life:()=>we,Mass:()=>ze,PolarVelocity:()=>Xe,Position:()=>Ze,RadialVelocity:()=>Je,Radius:()=>Ue,Rate:()=>Ne,Texture:()=>Ye,VectorVelocity:()=>Qe});var r={};i.r(r),i.d(r,{Alpha:()=>ii,Attraction:()=>si,Behaviour:()=>ei,Collision:()=>ri,Color:()=>ni,CrossZone:()=>oi,Force:()=>ai,Gravity:()=>hi,RandomDrift:()=>ci,Repulsion:()=>ui,Rotate:()=>li,Scale:()=>di,Spring:()=>pi});const n=\"Alpha\",o=\"Attraction\",a=\"Color\",h=\"CrossZone\",c=\"Force\",u=\"Gravity\",l=\"RandomDrift\",d=\"Repulsion\",p=\"Rotate\",y=\"Scale\",f=\"Spring\",m=\"Body\",g=\"BodySprite\",x=\"Texture\",v=\"Life\",b=\"Mass\",_=\"Position\",w=\"Radius\",z=\"VectorVelocity\",M=\"PolarVelocity\",P=\"RadialVelocity\",O=[g,x],E=\"BoxZone\",T=\"LineZone\",S=\"MeshZone\",C=\"PointZone\",A=\"SphereZone\",j=\"MobileGPURenderer\",I=\"DesktopGPURenderer\",R=3.142,B=500,D=R/180,V=\"euler\",F=()=>!!process&&(process.env,!1),k={easeLinear:function(t){return t},easeInQuad:function(t){return Math.pow(t,2)},easeOutQuad:function(t){return-(Math.pow(t-1,2)-1)},easeInOutQuad:function(t){return(t/=.5)<1?.5*Math.pow(t,2):-.5*((t-=2)*t-2)},easeInCubic:function(t){return Math.pow(t,3)},easeOutCubic:function(t){return Math.pow(t-1,3)+1},easeInOutCubic:function(t){return(t/=.5)<1?.5*Math.pow(t,3):.5*(Math.pow(t-2,3)+2)},easeInQuart:function(t){return Math.pow(t,4)},easeOutQuart:function(t){return-(Math.pow(t-1,4)-1)},easeInOutQuart:function(t){return(t/=.5)<1?.5*Math.pow(t,4):-.5*((t-=2)*Math.pow(t,3)-2)},easeInSine:function(t){return 1-Math.cos(t*(R/2))},easeOutSine:function(t){return Math.sin(t*(R/2))},easeInOutSine:function(t){return-.5*(Math.cos(R*t)-1)},easeInExpo:function(t){return 0===t?0:Math.pow(2,10*(t-1))},easeOutExpo:function(t){return 1===t?1:1-Math.pow(2,-10*t)},easeInOutExpo:function(t){return 0===t?0:1===t?1:(t/=.5)<1?.5*Math.pow(2,10*(t-1)):.5*(2-Math.pow(2,-10*--t))},easeInCirc:function(t){return-(Math.sqrt(1-t*t)-1)},easeOutCirc:function(t){return Math.sqrt(1-Math.pow(t-1,2))},easeInOutCirc:function(t){return(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)},easeInBack:function(t){var e=1.70158;return t*t*((e+1)*t-e)},easeOutBack:function(t){var e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack:function(t){var e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)}},{easeLinear:Z,easeInQuad:U,easeOutQuad:N,easeInOutQuad:L,easeInCubic:q,easeOutCubic:Y,easeInOutCubic:G,easeInQuart:X,easeOutQuart:J,easeInOutQuart:Q,easeInSine:H,easeOutSine:$,easeInOutSine:W,easeInExpo:K,easeOutExpo:tt,easeInOutExpo:et,easeInCirc:it,easeOutCirc:st,easeInOutCirc:rt,easeInBack:nt,easeOutBack:ot,easeInOutBack:at}=k,ht=t=>k[t]?k[t]:k.easeLinear,ct=t=>k[t]?k[t]:k.easeLinear,ut=1/0,lt=Z,dt=.0167,pt=[_,v,w,b,m,g,x,M,P,z],yt=[n,o,a,h,c,u,l,d,p,y,f],ft=[E,T,S,C,A];function mt(t,e,i){return e in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}const gt={getRGB:function(t){var e={};if(\"number\"==typeof t)s=Math.floor(t),e.r=(t>>16&255)/255,e.g=(t>>8&255)/255,e.b=(255&t)/255;else if(\"string\"==typeof t){var i;if(i=/^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(t))e.r=Math.min(255,parseInt(i[1],10))/255,e.g=Math.min(255,parseInt(i[2],10))/255,e.b=Math.min(255,parseInt(i[3],10))/255;else if(i=/^\\#([A-Fa-f0-9]+)$/.exec(t)){var s=i[1];e.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,e.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,e.b=parseInt(s.charAt(4)+s.charAt(5),16)/255}}else e.r=t.r,e.g=t.g,e.b=t.b;return e}},xt={_id:0,_uids:new Map,getNewId:function(){return\"PUID_\"+ ++this._id},id:function(t){if(this._uids.has(t))return this._uids.get(t);const e=this.getNewId();return this._uids.set(t,e),e}};var vt,bt,_t,wt,zt,Mt,Pt,Ot,Et,Tt={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){for(var t=[],e=0;e<256;e++)t[e]=(e<16?\"0\":\"\")+e.toString(16);return function(){var e=4294967295*Math.random()|0,i=4294967295*Math.random()|0,s=4294967295*Math.random()|0,r=4294967295*Math.random()|0;return(t[255&e]+t[e>>8&255]+t[e>>16&255]+t[e>>24&255]+\"-\"+t[255&i]+t[i>>8&255]+\"-\"+t[i>>16&15|64]+t[i>>24&255]+\"-\"+t[63&s|128]+t[s>>8&255]+\"-\"+t[s>>16&255]+t[s>>24&255]+t[255&r]+t[r>>8&255]+t[r>>16&255]+t[r>>24&255]).toUpperCase()}}(),clamp:function(t,e,i){return Math.max(e,Math.min(i,t))},euclideanModulo:function(t,e){return(t%e+e)%e},mapLinear:function(t,e,i,s,r){return s+(t-e)*(r-s)/(i-e)},lerp:function(t,e,i){return(1-i)*t+i*e},smoothstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*(3-2*t)},smootherstep:function(t,e,i){return t<=e?0:t>=i?1:(t=(t-e)/(i-e))*t*t*(t*(6*t-15)+10)},randInt:function(t,e){return t+Math.floor(Math.random()*(e-t+1))},randFloat:function(t,e){return t+Math.random()*(e-t)},randFloatSpread:function(t){return t*(.5-Math.random())},degToRad:function(t){return t*Tt.DEG2RAD},radToDeg:function(t){return t*Tt.RAD2DEG},isPowerOfTwo:function(t){return 0==(t&t-1)&&0!==t},ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:function(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}};function St(t,e,i,s){this._x=t||0,this._y=e||0,this._z=i||0,this._w=void 0!==s?s:1}function Ct(t,e,i){this.x=t||0,this.y=e||0,this.z=i||0}function At(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error(\"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\")}function jt(t,e,i,s){this._x=t||0,this._y=e||0,this._z=i||0,this._order=s||jt.DefaultOrder}Object.assign(St,{slerp:function(t,e,i,s){return i.copy(t).slerp(e,s)},slerpFlat:function(t,e,i,s,r,n,o){var a=i[s+0],h=i[s+1],c=i[s+2],u=i[s+3],l=r[n+0],d=r[n+1],p=r[n+2],y=r[n+3];if(u!==y||a!==l||h!==d||c!==p){var f=1-o,m=a*l+h*d+c*p+u*y,g=m>=0?1:-1,x=1-m*m;if(x>Number.EPSILON){var v=Math.sqrt(x),b=Math.atan2(v,m*g);f=Math.sin(f*b)/v,o=Math.sin(o*b)/v}var _=o*g;if(a=a*f+l*_,h=h*f+d*_,c=c*f+p*_,u=u*f+y*_,f===1-o){var w=1/Math.sqrt(a*a+h*h+c*c+u*u);a*=w,h*=w,c*=w,u*=w}}t[e]=a,t[e+1]=h,t[e+2]=c,t[e+3]=u}}),Object.defineProperties(St.prototype,{x:{get:function(){return this._x},set:function(t){this._x=t,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(t){this._y=t,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(t){this._z=t,this._onChangeCallback()}},w:{get:function(){return this._w},set:function(t){this._w=t,this._onChangeCallback()}}}),Object.assign(St.prototype,{isQuaternion:!0,set:function(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},copy:function(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this},setFromEuler:function(t,e){if(!t||!t.isEuler)throw new Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");var i=t._x,s=t._y,r=t._z,n=t.order,o=Math.cos,a=Math.sin,h=o(i/2),c=o(s/2),u=o(r/2),l=a(i/2),d=a(s/2),p=a(r/2);return\"XYZ\"===n?(this._x=l*c*u+h*d*p,this._y=h*d*u-l*c*p,this._z=h*c*p+l*d*u,this._w=h*c*u-l*d*p):\"YXZ\"===n?(this._x=l*c*u+h*d*p,this._y=h*d*u-l*c*p,this._z=h*c*p-l*d*u,this._w=h*c*u+l*d*p):\"ZXY\"===n?(this._x=l*c*u-h*d*p,this._y=h*d*u+l*c*p,this._z=h*c*p+l*d*u,this._w=h*c*u-l*d*p):\"ZYX\"===n?(this._x=l*c*u-h*d*p,this._y=h*d*u+l*c*p,this._z=h*c*p-l*d*u,this._w=h*c*u+l*d*p):\"YZX\"===n?(this._x=l*c*u+h*d*p,this._y=h*d*u+l*c*p,this._z=h*c*p-l*d*u,this._w=h*c*u-l*d*p):\"XZY\"===n&&(this._x=l*c*u-h*d*p,this._y=h*d*u-l*c*p,this._z=h*c*p+l*d*u,this._w=h*c*u+l*d*p),!1!==e&&this._onChangeCallback(),this},setFromAxisAngle:function(t,e){var i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this},setFromRotationMatrix:function(t){var e,i=t.elements,s=i[0],r=i[4],n=i[8],o=i[1],a=i[5],h=i[9],c=i[2],u=i[6],l=i[10],d=s+a+l;return d>0?(e=.5/Math.sqrt(d+1),this._w=.25/e,this._x=(u-h)*e,this._y=(n-c)*e,this._z=(o-r)*e):s>a&&s>l?(e=2*Math.sqrt(1+s-a-l),this._w=(u-h)/e,this._x=.25*e,this._y=(r+o)/e,this._z=(n+c)/e):a>l?(e=2*Math.sqrt(1+a-s-l),this._w=(n-c)/e,this._x=(r+o)/e,this._y=.25*e,this._z=(h+u)/e):(e=2*Math.sqrt(1+l-s-a),this._w=(o-r)/e,this._x=(n+c)/e,this._y=(h+u)/e,this._z=.25*e),this._onChangeCallback(),this},setFromUnitVectors:function(t,e){var i=t.dot(e)+1;return i<1e-6?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()},angleTo:function(t){return 2*Math.acos(Math.abs(Tt.clamp(this.dot(t),-1,1)))},rotateTowards:function(t,e){var i=this.angleTo(t);if(0===i)return this;var s=Math.min(1,e/i);return this.slerp(t,s),this},inverse:function(){return this.conjugate()},conjugate:function(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this},dot:function(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var t=this.length();return 0===t?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this},multiply:function(t,e){return void 0!==e?(console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)},premultiply:function(t){return this.multiplyQuaternions(t,this)},multiplyQuaternions:function(t,e){var i=t._x,s=t._y,r=t._z,n=t._w,o=e._x,a=e._y,h=e._z,c=e._w;return this._x=i*c+n*o+s*h-r*a,this._y=s*c+n*a+r*o-i*h,this._z=r*c+n*h+i*a-s*o,this._w=n*c-i*o-s*a-r*h,this._onChangeCallback(),this},slerp:function(t,e){if(0===e)return this;if(1===e)return this.copy(t);var i=this._x,s=this._y,r=this._z,n=this._w,o=n*t._w+i*t._x+s*t._y+r*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=n,this._x=i,this._y=s,this._z=r,this;var a=1-o*o;if(a<=Number.EPSILON){var h=1-e;return this._w=h*n+e*this._w,this._x=h*i+e*this._x,this._y=h*s+e*this._y,this._z=h*r+e*this._z,this.normalize(),this._onChangeCallback(),this}var c=Math.sqrt(a),u=Math.atan2(c,o),l=Math.sin((1-e)*u)/c,d=Math.sin(e*u)/c;return this._w=n*l+this._w*d,this._x=i*l+this._x*d,this._y=s*l+this._y*d,this._z=r*l+this._z*d,this._onChangeCallback(),this},equals:function(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w},fromArray:function(t,e){return void 0===e&&(e=0),this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t},_onChange:function(t){return this._onChangeCallback=t,this},_onChangeCallback:function(){}}),Object.assign(Ct.prototype,{isVector3:!0,set:function(t,e,i){return this.x=t,this.y=e,this.z=i,this},setScalar:function(t){return this.x=t,this.y=t,this.z=t,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setZ:function(t){return this.z=t,this},setComponent:function(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error(\"index is out of range: \"+t)}return this},getComponent:function(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error(\"index is out of range: \"+t)}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(t){return this.x=t.x,this.y=t.y,this.z=t.z,this},add:function(t,e){return void 0!==e?(console.warn(\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)},addScalar:function(t){return this.x+=t,this.y+=t,this.z+=t,this},addVectors:function(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this},addScaledVector:function(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this},sub:function(t,e){return void 0!==e?(console.warn(\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)},subScalar:function(t){return this.x-=t,this.y-=t,this.z-=t,this},subVectors:function(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this},multiply:function(t,e){return void 0!==e?(console.warn(\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)},multiplyScalar:function(t){return this.x*=t,this.y*=t,this.z*=t,this},multiplyVectors:function(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this},applyEuler:(vt=new St,function(t){return t&&t.isEuler||console.error(\"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\"),this.applyQuaternion(vt.setFromEuler(t))}),applyAxisAngle:function(){var t=new St;return function(e,i){return this.applyQuaternion(t.setFromAxisAngle(e,i))}}(),applyMatrix3:function(t){var e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*s,this.y=r[1]*e+r[4]*i+r[7]*s,this.z=r[2]*e+r[5]*i+r[8]*s,this},applyMatrix4:function(t){var e=this.x,i=this.y,s=this.z,r=t.elements,n=1/(r[3]*e+r[7]*i+r[11]*s+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*s+r[12])*n,this.y=(r[1]*e+r[5]*i+r[9]*s+r[13])*n,this.z=(r[2]*e+r[6]*i+r[10]*s+r[14])*n,this},applyQuaternion:function(t){var e=this.x,i=this.y,s=this.z,r=t.x,n=t.y,o=t.z,a=t.w,h=a*e+n*s-o*i,c=a*i+o*e-r*s,u=a*s+r*i-n*e,l=-r*e-n*i-o*s;return this.x=h*a+l*-r+c*-o-u*-n,this.y=c*a+l*-n+u*-r-h*-o,this.z=u*a+l*-o+h*-n-c*-r,this},project:function(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)},unproject:function(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)},transformDirection:function(t){var e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s,this.y=r[1]*e+r[5]*i+r[9]*s,this.z=r[2]*e+r[6]*i+r[10]*s,this.normalize()},divide:function(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this},divideScalar:function(t){return this.multiplyScalar(1/t)},min:function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this},max:function(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this},clamp:function(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this},clampScalar:function(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this},clampLength:function(t,e){var i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))},floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this},ceil:function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this},round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this},roundToZero:function(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this},negate:function(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this},dot:function(t){return this.x*t.x+this.y*t.y+this.z*t.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},manhattanLength:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length()||1)},setLength:function(t){return this.normalize().multiplyScalar(t)},lerp:function(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this},lerpVectors:function(t,e,i){return this.subVectors(e,t).multiplyScalar(i).add(t)},cross:function(t,e){return void 0!==e?(console.warn(\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"),this.crossVectors(t,e)):this.crossVectors(this,t)},crossVectors:function(t,e){var i=t.x,s=t.y,r=t.z,n=e.x,o=e.y,a=e.z;return this.x=s*a-r*o,this.y=r*n-i*a,this.z=i*o-s*n,this},projectOnVector:function(t){var e=t.dot(this)/t.lengthSq();return this.copy(t).multiplyScalar(e)},projectOnPlane:function(){var t=new Ct;return function(e){return t.copy(this).projectOnVector(e),this.sub(t)}}(),reflect:function(){var t=new Ct;return function(e){return this.sub(t.copy(e).multiplyScalar(2*this.dot(e)))}}(),angleTo:function(t){var e=this.dot(t)/Math.sqrt(this.lengthSq()*t.lengthSq());return Math.acos(Tt.clamp(e,-1,1))},distanceTo:function(t){return Math.sqrt(this.distanceToSquared(t))},distanceToSquared:function(t){var e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s},manhattanDistanceTo:function(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)},setFromSpherical:function(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)},setFromSphericalCoords:function(t,e,i){var s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this},setFromCylindrical:function(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)},setFromCylindricalCoords:function(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this},setFromMatrixPosition:function(t){var e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this},setFromMatrixScale:function(t){var e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this},setFromMatrixColumn:function(t,e){return this.fromArray(t.elements,4*e)},equals:function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z},fromArray:function(t,e){return void 0===e&&(e=0),this.x=t[e],this.y=t[e+1],this.z=t[e+2],this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t},fromBufferAttribute:function(t,e,i){return void 0!==i&&console.warn(\"THREE.Vector3: offset has been removed from .fromBufferAttribute().\"),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}}),Object.assign(At.prototype,{isMatrix4:!0,set:function(t,e,i,s,r,n,o,a,h,c,u,l,d,p,y,f){var m=this.elements;return m[0]=t,m[4]=e,m[8]=i,m[12]=s,m[1]=r,m[5]=n,m[9]=o,m[13]=a,m[2]=h,m[6]=c,m[10]=u,m[14]=l,m[3]=d,m[7]=p,m[11]=y,m[15]=f,this},identity:function(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this},clone:function(){return(new At).fromArray(this.elements)},copy:function(t){var e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this},copyPosition:function(t){var e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this},extractBasis:function(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this},makeBasis:function(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this},extractRotation:function(){var t=new Ct;return function(e){var i=this.elements,s=e.elements,r=1/t.setFromMatrixColumn(e,0).length(),n=1/t.setFromMatrixColumn(e,1).length(),o=1/t.setFromMatrixColumn(e,2).length();return i[0]=s[0]*r,i[1]=s[1]*r,i[2]=s[2]*r,i[3]=0,i[4]=s[4]*n,i[5]=s[5]*n,i[6]=s[6]*n,i[7]=0,i[8]=s[8]*o,i[9]=s[9]*o,i[10]=s[10]*o,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1,this}}(),makeRotationFromEuler:function(t){t&&t.isEuler||console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");var e=this.elements,i=t.x,s=t.y,r=t.z,n=Math.cos(i),o=Math.sin(i),a=Math.cos(s),h=Math.sin(s),c=Math.cos(r),u=Math.sin(r);if(\"XYZ\"===t.order){var l=n*c,d=n*u,p=o*c,y=o*u;e[0]=a*c,e[4]=-a*u,e[8]=h,e[1]=d+p*h,e[5]=l-y*h,e[9]=-o*a,e[2]=y-l*h,e[6]=p+d*h,e[10]=n*a}else if(\"YXZ\"===t.order){var f=a*c,m=a*u,g=h*c,x=h*u;e[0]=f+x*o,e[4]=g*o-m,e[8]=n*h,e[1]=n*u,e[5]=n*c,e[9]=-o,e[2]=m*o-g,e[6]=x+f*o,e[10]=n*a}else if(\"ZXY\"===t.order)f=a*c,m=a*u,g=h*c,x=h*u,e[0]=f-x*o,e[4]=-n*u,e[8]=g+m*o,e[1]=m+g*o,e[5]=n*c,e[9]=x-f*o,e[2]=-n*h,e[6]=o,e[10]=n*a;else if(\"ZYX\"===t.order)l=n*c,d=n*u,p=o*c,y=o*u,e[0]=a*c,e[4]=p*h-d,e[8]=l*h+y,e[1]=a*u,e[5]=y*h+l,e[9]=d*h-p,e[2]=-h,e[6]=o*a,e[10]=n*a;else if(\"YZX\"===t.order){var v=n*a,b=n*h,_=o*a,w=o*h;e[0]=a*c,e[4]=w-v*u,e[8]=_*u+b,e[1]=u,e[5]=n*c,e[9]=-o*c,e[2]=-h*c,e[6]=b*u+_,e[10]=v-w*u}else\"XZY\"===t.order&&(v=n*a,b=n*h,_=o*a,w=o*h,e[0]=a*c,e[4]=-u,e[8]=h*c,e[1]=v*u+w,e[5]=n*c,e[9]=b*u-_,e[2]=_*u-b,e[6]=o*c,e[10]=w*u+v);return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this},makeRotationFromQuaternion:(Pt=new Ct(0,0,0),Ot=new Ct(1,1,1),function(t){return this.compose(Pt,t,Ot)}),lookAt:(wt=new Ct,zt=new Ct,Mt=new Ct,function(t,e,i){var s=this.elements;return Mt.subVectors(t,e),0===Mt.lengthSq()&&(Mt.z=1),Mt.normalize(),wt.crossVectors(i,Mt),0===wt.lengthSq()&&(1===Math.abs(i.z)?Mt.x+=1e-4:Mt.z+=1e-4,Mt.normalize(),wt.crossVectors(i,Mt)),wt.normalize(),zt.crossVectors(Mt,wt),s[0]=wt.x,s[4]=zt.x,s[8]=Mt.x,s[1]=wt.y,s[5]=zt.y,s[9]=Mt.y,s[2]=wt.z,s[6]=zt.z,s[10]=Mt.z,this}),multiply:function(t,e){return void 0!==e?(console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)},premultiply:function(t){return this.multiplyMatrices(t,this)},multiplyMatrices:function(t,e){var i=t.elements,s=e.elements,r=this.elements,n=i[0],o=i[4],a=i[8],h=i[12],c=i[1],u=i[5],l=i[9],d=i[13],p=i[2],y=i[6],f=i[10],m=i[14],g=i[3],x=i[7],v=i[11],b=i[15],_=s[0],w=s[4],z=s[8],M=s[12],P=s[1],O=s[5],E=s[9],T=s[13],S=s[2],C=s[6],A=s[10],j=s[14],I=s[3],R=s[7],B=s[11],D=s[15];return r[0]=n*_+o*P+a*S+h*I,r[4]=n*w+o*O+a*C+h*R,r[8]=n*z+o*E+a*A+h*B,r[12]=n*M+o*T+a*j+h*D,r[1]=c*_+u*P+l*S+d*I,r[5]=c*w+u*O+l*C+d*R,r[9]=c*z+u*E+l*A+d*B,r[13]=c*M+u*T+l*j+d*D,r[2]=p*_+y*P+f*S+m*I,r[6]=p*w+y*O+f*C+m*R,r[10]=p*z+y*E+f*A+m*B,r[14]=p*M+y*T+f*j+m*D,r[3]=g*_+x*P+v*S+b*I,r[7]=g*w+x*O+v*C+b*R,r[11]=g*z+x*E+v*A+b*B,r[15]=g*M+x*T+v*j+b*D,this},multiplyScalar:function(t){var e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this},applyToBufferAttribute:function(){var t=new Ct;return function(e){for(var i=0,s=e.count;i<s;i++)t.x=e.getX(i),t.y=e.getY(i),t.z=e.getZ(i),t.applyMatrix4(this),e.setXYZ(i,t.x,t.y,t.z);return e}}(),determinant:function(){var t=this.elements,e=t[0],i=t[4],s=t[8],r=t[12],n=t[1],o=t[5],a=t[9],h=t[13],c=t[2],u=t[6],l=t[10],d=t[14];return t[3]*(+r*a*u-s*h*u-r*o*l+i*h*l+s*o*d-i*a*d)+t[7]*(+e*a*d-e*h*l+r*n*l-s*n*d+s*h*c-r*a*c)+t[11]*(+e*h*u-e*o*d-r*n*u+i*n*d+r*o*c-i*h*c)+t[15]*(-s*o*c-e*a*u+e*o*l+s*n*u-i*n*l+i*a*c)},transpose:function(){var t,e=this.elements;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this},setPosition:function(t,e,i){var s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this},getInverse:function(t,e){var i=this.elements,s=t.elements,r=s[0],n=s[1],o=s[2],a=s[3],h=s[4],c=s[5],u=s[6],l=s[7],d=s[8],p=s[9],y=s[10],f=s[11],m=s[12],g=s[13],x=s[14],v=s[15],b=p*x*l-g*y*l+g*u*f-c*x*f-p*u*v+c*y*v,_=m*y*l-d*x*l-m*u*f+h*x*f+d*u*v-h*y*v,w=d*g*l-m*p*l+m*c*f-h*g*f-d*c*v+h*p*v,z=m*p*u-d*g*u-m*c*y+h*g*y+d*c*x-h*p*x,M=r*b+n*_+o*w+a*z;if(0===M){var P=\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\";if(!0===e)throw new Error(P);return console.warn(P),this.identity()}var O=1/M;return i[0]=b*O,i[1]=(g*y*a-p*x*a-g*o*f+n*x*f+p*o*v-n*y*v)*O,i[2]=(c*x*a-g*u*a+g*o*l-n*x*l-c*o*v+n*u*v)*O,i[3]=(p*u*a-c*y*a-p*o*l+n*y*l+c*o*f-n*u*f)*O,i[4]=_*O,i[5]=(d*x*a-m*y*a+m*o*f-r*x*f-d*o*v+r*y*v)*O,i[6]=(m*u*a-h*x*a-m*o*l+r*x*l+h*o*v-r*u*v)*O,i[7]=(h*y*a-d*u*a+d*o*l-r*y*l-h*o*f+r*u*f)*O,i[8]=w*O,i[9]=(m*p*a-d*g*a-m*n*f+r*g*f+d*n*v-r*p*v)*O,i[10]=(h*g*a-m*c*a+m*n*l-r*g*l-h*n*v+r*c*v)*O,i[11]=(d*c*a-h*p*a-d*n*l+r*p*l+h*n*f-r*c*f)*O,i[12]=z*O,i[13]=(d*g*o-m*p*o+m*n*y-r*g*y-d*n*x+r*p*x)*O,i[14]=(m*c*o-h*g*o-m*n*u+r*g*u+h*n*x-r*c*x)*O,i[15]=(h*p*o-d*c*o+d*n*u-r*p*u-h*n*y+r*c*y)*O,this},scale:function(t){var e=this.elements,i=t.x,s=t.y,r=t.z;return e[0]*=i,e[4]*=s,e[8]*=r,e[1]*=i,e[5]*=s,e[9]*=r,e[2]*=i,e[6]*=s,e[10]*=r,e[3]*=i,e[7]*=s,e[11]*=r,this},getMaxScaleOnAxis:function(){var t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))},makeTranslation:function(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this},makeRotationX:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this},makeRotationY:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this},makeRotationZ:function(t){var e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this},makeRotationAxis:function(t,e){var i=Math.cos(e),s=Math.sin(e),r=1-i,n=t.x,o=t.y,a=t.z,h=r*n,c=r*o;return this.set(h*n+i,h*o-s*a,h*a+s*o,0,h*o+s*a,c*o+i,c*a-s*n,0,h*a-s*o,c*a+s*n,r*a*a+i,0,0,0,0,1),this},makeScale:function(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this},makeShear:function(t,e,i){return this.set(1,e,i,0,t,1,i,0,t,e,1,0,0,0,0,1),this},compose:function(t,e,i){var s=this.elements,r=e._x,n=e._y,o=e._z,a=e._w,h=r+r,c=n+n,u=o+o,l=r*h,d=r*c,p=r*u,y=n*c,f=n*u,m=o*u,g=a*h,x=a*c,v=a*u,b=i.x,_=i.y,w=i.z;return s[0]=(1-(y+m))*b,s[1]=(d+v)*b,s[2]=(p-x)*b,s[3]=0,s[4]=(d-v)*_,s[5]=(1-(l+m))*_,s[6]=(f+g)*_,s[7]=0,s[8]=(p+x)*w,s[9]=(f-g)*w,s[10]=(1-(l+y))*w,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this},decompose:(bt=new Ct,_t=new At,function(t,e,i){var s=this.elements,r=bt.set(s[0],s[1],s[2]).length(),n=bt.set(s[4],s[5],s[6]).length(),o=bt.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),t.x=s[12],t.y=s[13],t.z=s[14],_t.copy(this);var a=1/r,h=1/n,c=1/o;return _t.elements[0]*=a,_t.elements[1]*=a,_t.elements[2]*=a,_t.elements[4]*=h,_t.elements[5]*=h,_t.elements[6]*=h,_t.elements[8]*=c,_t.elements[9]*=c,_t.elements[10]*=c,e.setFromRotationMatrix(_t),i.x=r,i.y=n,i.z=o,this}),makePerspective:function(t,e,i,s,r,n){void 0===n&&console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");var o=this.elements,a=2*r/(e-t),h=2*r/(i-s),c=(e+t)/(e-t),u=(i+s)/(i-s),l=-(n+r)/(n-r),d=-2*n*r/(n-r);return o[0]=a,o[4]=0,o[8]=c,o[12]=0,o[1]=0,o[5]=h,o[9]=u,o[13]=0,o[2]=0,o[6]=0,o[10]=l,o[14]=d,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this},makeOrthographic:function(t,e,i,s,r,n){var o=this.elements,a=1/(e-t),h=1/(i-s),c=1/(n-r),u=(e+t)*a,l=(i+s)*h,d=(n+r)*c;return o[0]=2*a,o[4]=0,o[8]=0,o[12]=-u,o[1]=0,o[5]=2*h,o[9]=0,o[13]=-l,o[2]=0,o[6]=0,o[10]=-2*c,o[14]=-d,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this},equals:function(t){for(var e=this.elements,i=t.elements,s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0},fromArray:function(t,e){void 0===e&&(e=0);for(var i=0;i<16;i++)this.elements[i]=t[i+e];return this},toArray:function(t,e){void 0===t&&(t=[]),void 0===e&&(e=0);var i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}),jt.RotationOrders=[\"XYZ\",\"YZX\",\"ZXY\",\"XZY\",\"YXZ\",\"ZYX\"],jt.DefaultOrder=\"XYZ\",Object.defineProperties(jt.prototype,{x:{get:function(){return this._x},set:function(t){this._x=t,this._onChangeCallback()}},y:{get:function(){return this._y},set:function(t){this._y=t,this._onChangeCallback()}},z:{get:function(){return this._z},set:function(t){this._z=t,this._onChangeCallback()}},order:{get:function(){return this._order},set:function(t){this._order=t,this._onChangeCallback()}}}),Object.assign(jt.prototype,{isEuler:!0,set:function(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._order=s||this._order,this._onChangeCallback(),this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._order)},copy:function(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this},setFromRotationMatrix:function(t,e,i){var s=Tt.clamp,r=t.elements,n=r[0],o=r[4],a=r[8],h=r[1],c=r[5],u=r[9],l=r[2],d=r[6],p=r[10];return\"XYZ\"===(e=e||this._order)?(this._y=Math.asin(s(a,-1,1)),Math.abs(a)<.99999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,n)):(this._x=Math.atan2(d,c),this._z=0)):\"YXZ\"===e?(this._x=Math.asin(-s(u,-1,1)),Math.abs(u)<.99999?(this._y=Math.atan2(a,p),this._z=Math.atan2(h,c)):(this._y=Math.atan2(-l,n),this._z=0)):\"ZXY\"===e?(this._x=Math.asin(s(d,-1,1)),Math.abs(d)<.99999?(this._y=Math.atan2(-l,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(h,n))):\"ZYX\"===e?(this._y=Math.asin(-s(l,-1,1)),Math.abs(l)<.99999?(this._x=Math.atan2(d,p),this._z=Math.atan2(h,n)):(this._x=0,this._z=Math.atan2(-o,c))):\"YZX\"===e?(this._z=Math.asin(s(h,-1,1)),Math.abs(h)<.99999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-l,n)):(this._x=0,this._y=Math.atan2(a,p))):\"XZY\"===e?(this._z=Math.asin(-s(o,-1,1)),Math.abs(o)<.99999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,n)):(this._x=Math.atan2(-u,p),this._y=0)):console.warn(\"THREE.Euler: .setFromRotationMatrix() given unsupported order: \"+e),this._order=e,!1!==i&&this._onChangeCallback(),this},setFromQuaternion:function(){var t=new At;return function(e,i,s){return t.makeRotationFromQuaternion(e),this.setFromRotationMatrix(t,i,s)}}(),setFromVector3:function(t,e){return this.set(t.x,t.y,t.z,e||this._order)},reorder:(Et=new St,function(t){return Et.setFromEuler(this),this.setFromQuaternion(Et,t)}),equals:function(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order},fromArray:function(t){return this._x=t[0],this._y=t[1],this._z=t[2],void 0!==t[3]&&(this._order=t[3]),this._onChangeCallback(),this},toArray:function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t},toVector3:function(t){return t?t.set(this._x,this._y,this._z):new Ct(this._x,this._y,this._z)},_onChange:function(t){return this._onChangeCallback=t,this},_onChangeCallback:function(){}});const It={toScreenPos:function(){var t=new Ct;return function(e,i,s){return t.copy(e),t.project(i),t.x=Math.round((t.x+1)*s.width/2),t.y=Math.round((1-t.y)*s.height/2),t.z=0,t}}(),toSpacePos:function(){var t,e=new Ct,i=new Ct;return function(s,r,n){return e.set(s.x/n.width*2-1,-s.y/n.height*2+1,.5),e.unproject(r),i.copy(e.sub(r.position).normalize()),t=-r.position.z/i.z,e.copy(r.position),e.add(i.multiplyScalar(t)),e}}()},Rt={initValue:function(t,e){return null!=t&&null!=t?t:e},isArray:function(t){return\"[object Array]\"===Object.prototype.toString.call(t)},destroyArray:function(t){t.length=0},destroyObject:function(t){for(var e in t)delete t[e]},isUndefined:function(){for(var t in arguments){var e=arguments[t];if(void 0!==e)return!1}return!0},setVectorByObj:function(t,e){void 0!==e.x&&(t.position.x=e.x),void 0!==e.y&&(t.position.y=e.y),void 0!==e.z&&(t.position.z=e.z),void 0!==e.vx&&(t.velocity.x=e.vx),void 0!==e.vy&&(t.velocity.y=e.vy),void 0!==e.vz&&(t.velocity.z=e.vz),void 0!==e.ax&&(t.acceleration.x=e.ax),void 0!==e.ay&&(t.acceleration.y=e.ay),void 0!==e.az&&(t.acceleration.z=e.az),void 0!==e.p&&t.position.copy(e.p),void 0!==e.v&&t.velocity.copy(e.v),void 0!==e.a&&t.acceleration.copy(e.a),void 0!==e.position&&t.position.copy(e.position),void 0!==e.velocity&&t.velocity.copy(e.velocity),void 0!==e.accelerate&&t.acceleration.copy(e.accelerate)},setPrototypeByObj:function(t,e,i){for(var s in e)t.hasOwnProperty(s)&&(i?i.indexOf(s)<0&&(t[s]=this._getValue(e[s])):t[s]=this._getValue(e[s]));return t},_getValue:function(t){return\"Span\"===t.constructor.type?t.getValue():t}};var Bt=i(570);const Dt=i.n(Bt)();function Vt(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function Ft(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?Vt(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):Vt(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}const kt=(t,e)=>Ft(Ft({},t),e),Zt={randomAToB:function(t,e,i){return i?(Math.random()*(e-t)>>0)+t:t+Math.random()*(e-t)},randomFloating:function(t,e,i){return this.randomAToB(t-e,t+e,i)},randomZone:function(t){},degreeTransform:function(t){return t*R/180},toColor16:function(t){return\"#\"+t.toString(16)},randomColor:function(){return\"#\"+(\"00000\"+(16777216*Math.random()<<0).toString(16)).slice(-6)},lerp:function(t,e,i){return e+(t-e)*i},getNormal:function(t,e){return 0==t.x&&0==t.y?0==t.z?e.set(1,0,1):e.set(1,1,-t.y/t.z):0==t.x?e.set(1,0,1):e.set(-t.y/t.x,1,1),e.normalize()},axisRotate:function(t,e,i,s){var r=Math.cos(s),n=Math.sin(s),o=i.dot(e)*(1-r);t.copy(i),t.cross(e).scalar(n),t.addValue(e.x*r,e.y*r,e.z*r),t.addValue(i.x*o,i.y*o,i.z*o)}};class Ut{constructor(t,e,i){this._isArray=!1,this.type=\"Span\",Rt.isArray(t)?(this._isArray=!0,this.a=t):(this.a=Rt.initValue(t,1),this.b=Rt.initValue(e,this.a),this._center=Rt.initValue(i,!1))}getValue(t){return this._isArray?this.a[this.a.length*Math.random()>>0]:this._center?Zt.randomFloating(this.a,this.b,t):Zt.randomAToB(this.a,this.b,t)}}const Nt=(t,e,i)=>t instanceof Ut?t:void 0===e?new Ut(t):void 0===i?new Ut(t,e):new Ut(t,e,i);var Lt=i(534),qt=i.n(Lt);class Yt extends Ut{constructor(t){super(),this.type=\"ArraySpan\",this.items=Array.isArray(t)?t:[t]}getValue(){return qt()(this.items)}}const Gt=t=>t?t instanceof Yt?t:new Yt(t):null;class Xt extends Ut{constructor(t){super(),this.type=\"ColorSpan\",this.shouldRandomize=\"random\"===t,this.colors=Array.isArray(t)?t:[t]}getValue(){return this.shouldRandomize?Zt.randomColor():qt()(this.colors)}}const Jt=t=>(t||(console.warn(`Invalid colors argument ${t} passed to createColorSpan. Defaulting to 'random'.`),t=\"random\"),t instanceof Xt?t:new Xt(t));class Qt{constructor(t,e,i,s,r,n){this.type=\"Box\",this.x=t,this.y=e,this.z=i,this.width=s,this.height=r,this.depth=n,this.bottom=this.y+this.height,this.right=this.x+this.width,this.right=this.x+this.width}contains(t,e,i){return t<=this.right&&t>=this.x&&e<=this.bottom&&e>=this.y&&i<=this.depth&&i>=this.z}}const Ht=\"EULER\",$t=\"RUNGE_KUTTA_2\",Wt=\"RUNGE_KUTTA_4\",Kt=\"VERLET\",te=(t,e,i,s=Ht)=>{((t,e,i)=>{t.sleep||(t.old.position.copy(t.position),t.old.velocity.copy(t.velocity),t.acceleration.scalar(1/t.mass),t.velocity.add(t.acceleration.scalar(e)),t.position.add(t.old.velocity.scalar(e)),i&&t.velocity.scalar(Math.pow(i,e/dt)),t.acceleration.clear())})(t,e,i)};class ee extends Ct{clear(){return this.x=0,this.y=0,this.z=0,this}scalar(t){return this.x*=t,this.y*=t,this.z*=t,this}addValue(t,e,i){return this.x+=t,this.y+=e,this.z+=i,this}toString(){return\"x:\"+this.x+\"y:\"+this.y+\"z:\"+this.z}eulerFromDir(t){return(new jt).setFromVector3(t)}}class ie{constructor(t,e,i){this.type=\"Polar3D\",this.radius=t||1,this.phi=i||0,this.theta=e||0}set(t,e,i){return this.radius=t||1,this.phi=i||0,this.theta=e||0,this}setRadius(t){return this.radius=t,this}setPhi(t){return this.phi=t,this}setTheta(t){return this.theta=t,this}copy(t){return this.radius=t.radius,this.phi=t.phi,this.theta=t.theta,this}toVector3D(){return new ee(this.getX(),this.getY(),this.getZ())}getX(){return this.radius*Math.sin(this.theta)*Math.cos(this.phi)}getY(){return-this.radius*Math.sin(this.theta)*Math.sin(this.phi)}getZ(){return this.radius*Math.cos(this.theta)}normalize(){return this.radius=1,this}equals(t){return t.radius===this.radius&&t.phi===this.phi&&t.theta===this.theta}clear(){return this.radius=0,this.phi=0,this.theta=0,this}clone(){return new ie(this.radius,this.phi,this.theta)}}class se{constructor(t){this.id=`particle-${Dt()}`,this.type=\"Particle\",this.life=ut,this.age=0,this.energy=1,this.dead=!1,this.sleep=!1,this.body=null,this.parent=null,this.mass=1,this.radius=10,this.alpha=1,this.scale=1,this.useColor=!1,this.useAlpha=!1,this.easing=lt,this.position=new ee,this.velocity=new ee,this.acceleration=new ee,this.old={},this.old.position=this.position.clone(),this.old.velocity=this.velocity.clone(),this.old.acceleration=this.acceleration.clone(),this.behaviours=[],this.transform={},this.color={r:0,g:0,b:0},this.rotation=new ee,this.distanceToCamera=0,Rt.setPrototypeByObj(this,t)}getDirection(){return Math.atan2(this.velocity.x,-this.velocity.y)*(180/R)}reset(){return this.life=ut,this.age=0,this.energy=1,this.dead=!1,this.sleep=!1,this.body=null,this.parent=null,this.mass=1,this.radius=10,this.alpha=1,this.scale=1,this.useColor=!1,this.useAlpha=!1,this.easing=lt,this.position.set(0,0,0),this.velocity.set(0,0,0),this.acceleration.set(0,0,0),this.old.position.set(0,0,0),this.old.velocity.set(0,0,0),this.old.acceleration.set(0,0,0),this.color.r=0,this.color.g=0,this.color.b=0,this.rotation.clear(),Rt.destroyObject(this.transform),this.removeAllBehaviours(),this}update(t,e){if(!this.sleep){this.age+=t;let i=this.behaviours.length;for(;i--;)this.behaviours[i].applyBehaviour(this,t,e)}if(this.age>=this.life)this.destroy();else{const t=this.easing(this.age/this.life);this.energy=Math.max(1-t,0)}}addBehaviour(t){this.behaviours.push(t),t.initialize(this)}addBehaviours(t){let e=t.length;for(;e--;)this.addBehaviour(t[e])}removeBehaviour(t){const e=this.behaviours.indexOf(t);e>-1&&this.behaviours.splice(e,1)}removeAllBehaviours(){Rt.destroyArray(this.behaviours)}destroy(){this.removeAllBehaviours(),this.energy=0,this.dead=!0,this.parent=null}}class re{constructor(){this.type=\"Pool\",this.cID=0,this.list={}}create(t,...e){if(!this.canCreateNewObject(t))throw new Error(\"The pool is unable to create or clone the object supplied\");return this.cID++,this.canInstantiateObject(t)?new t(...e):this.canCloneObject(t)?t.clone():void 0}canInstantiateObject(t){return\"function\"==typeof t}canCloneObject(t){return t.clone&&\"function\"==typeof t.clone}canCreateNewObject(t){return!(!this.canInstantiateObject(t)&&!this.canCloneObject(t))}getCount(){var t=0;for(var e in this.list)t+=this.list[e].length;return t++}get(t,...e){var i,s=t.__puid||xt.id(t);return(i=this.list[s]&&this.list[s].length>0?this.list[s].pop():this.create(t,...e)).__puid=t.__puid||s,i}expire(t){return this._getList(t.__puid).push(t)}destroy(){for(var t in this.list)this.list[t].length=0,delete this.list[t]}_getList(t){return t=t||\"default\",this.list[t]||(this.list[t]=[]),this.list[t]}}const ne=class{constructor(){this.listeners=null}set listeners(t){this._listeners=t}get listeners(){return this._listeners}addEventListener(t,e){return this.listeners?this.removeEventListener(t,e):this.listeners={},this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e),e}removeEventListener(t,e){if(this.listeners&&this.listeners[t])for(var i=this.listeners[t],s=0,r=i.length;s<r;s++)if(i[s]==e){1==r?delete this.listeners[t]:i.splice(s,1);break}}removeAllEventListeners(t){t?this.listeners&&delete this.listeners[t]:this.listeners=null}dispatchEvent(t,e){var i=!1,s=this.listeners;if(t&&s){var r=s[t];if(!r)return i;for(var n,o=(r=r.slice()).length;o--;)n=r[o],i=i||n(e)}return!!i}hasEventListener(t){var e=this.listeners;return!(!e||!e[t])}},oe=\"SYSTEM_UPDATE\",ae=\"PARTICLE_CREATED\",he=\"PARTICLE_UPDATE\",ce=\"PARTICLE_DEAD\";class ue{constructor(t=\"Initializer\",e=!0){this.type=t,this.isEnabled=e}init(t,e){this.isEnabled&&(e?(this.initialize(e),e.hasBeenInitialized=!0):(this.initialize(t),t.hasBeenInitialized=!0))}reset(){}initialize(t){}static requiresWebGlApi(){return!1}static fromJSON(t){}}class le extends ue{constructor(t,e,i,s=!0){super(m,s),this.body=Gt(t),this.w=e,this.h=i||e}initialize(t){var e=this.body.getValue();this.w?t.body={width:this.w,height:this.h,body:e}:t.body=e}static fromJSON(t){const{body:e,width:i,height:s,isEnabled:r=!0}=t;return new le(e,i,s,r)}}function de(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function pe(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?de(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):de(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}const ye={AdditiveBlending:2,CustomBlending:5,MultiplyBlending:4,NoBlending:0,NormalBlending:1,SubtractiveBlending:3},fe={color:16711680,blending:2,fog:!0},me=pe(pe({},fe),{},{blending:\"AdditiveBlending\"});function ge(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function xe(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?ge(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):ge(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}class ve extends ue{constructor(t,e,i=fe,s=!0){super(g,s);const{Sprite:r,SpriteMaterial:n,TextureLoader:o}=t;this.materialProperties=kt(fe,i),(new o).load(e,(t=>{this.texture=t,this.material=new n(xe(xe({},{map:t}),this.materialProperties)),this.sprite=new r(this.material)}),void 0,(t=>{throw new Error(t)}))}initialize(t){t.body=this.sprite}static fromJSON(t,e){const{texture:i,materialProperties:s=me,isEnabled:r=!0}=t;return new ve(e,i,kt(me,(t=>{const{blending:e}=t;return xe(xe({},t),{},{blending:e?ye[e]:ye[me.blending]})})(s)),r)}}const be=new jt,_e={particleEuler:null,initialize:function(t,e,i){let s=i.length;for(;s--;)i[s].init(t,e);t.bindEmitter&&this.bindEmitter(t,e)},bindEmitter:function(t,e){const{rotation:{x:i,y:s,z:r}}=t;e.position.add(t.position),e.velocity.add(t.velocity),e.acceleration.add(t.acceleration),e.velocity.applyEuler(be.set(i,s,r))}};class we extends ue{constructor(t,e,i,s=!0){super(v,s),this.lifePan=Nt(t,e,i)}initialize(t){this.lifePan.a==1/0||\"infi\"==this.lifePan.a?t.life=1/0:t.life=this.lifePan.getValue()}static fromJSON(t){const{min:e,max:i,center:s=!1,isEnabled:r=!0}=t;return new we(e,i,s,r)}}class ze extends ue{constructor(t,e,i=!1,s=!0){super(b,s),this.massPan=Nt(t,e,i)}initialize(t){t.mass=this.massPan.getValue()}static fromJSON(t){const{min:e,max:i,center:s=!1,isEnabled:r=!0}=t;return new ze(e,i,s,r)}}class Me{constructor(t=\"Zone\"){this.type=t,this.vector=new ee(0,0,0),this.random=0,this.crossType=\"dead\",this.log=!0,this.supportsCrossing=!0}getPosition(){return null}crossing(t){if(!this.supportsCrossing)return console.warn(`${this.constructor.name} does not support the crossing method`);switch(this.crossType){case\"bound\":this._bound(t);break;case\"cross\":this._cross(t);break;case\"dead\":this._dead(t)}}isBoxZone(){return!1}isLineZone(){return!1}isMeshZone(){return!1}isPointZone(){return!1}isScreenZone(){return!1}isSphereZone(){return!1}_dead(t){}_bound(t){}_cross(t){}}class Pe extends Me{constructor(t,e,i,s,r,n){var o,a,h,c,u;super(E),Rt.isUndefined(e,i,s,r,n)?(o=a=h=0,c=u=s=t||100):Rt.isUndefined(s,r,n)?(o=a=h=0,c=t,u=e,s=i):(o=t,a=e,h=i,c=s,u=r,s=n),this.x=o,this.y=a,this.z=h,this.width=c,this.height=u,this.depth=s,this.friction=.85,this.max=6}isBoxZone(){return!0}getPosition(){return this.vector.x=this.x+Zt.randomAToB(-.5,.5)*this.width,this.vector.y=this.y+Zt.randomAToB(-.5,.5)*this.height,this.vector.z=this.z+Zt.randomAToB(-.5,.5)*this.depth,this.vector}_dead(t){(t.position.x+t.radius<this.x-this.width/2||t.position.x-t.radius>this.x+this.width/2)&&(t.dead=!0),(t.position.y+t.radius<this.y-this.height/2||t.position.y-t.radius>this.y+this.height/2)&&(t.dead=!0),(t.position.z+t.radius<this.z-this.depth/2||t.position.z-t.radius>this.z+this.depth/2)&&(t.dead=!0)}_bound(t){t.position.x-t.radius<this.x-this.width/2?(t.position.x=this.x-this.width/2+t.radius,t.velocity.x*=-this.friction,this._static(t,\"x\")):t.position.x+t.radius>this.x+this.width/2&&(t.position.x=this.x+this.width/2-t.radius,t.velocity.x*=-this.friction,this._static(t,\"x\")),t.position.y-t.radius<this.y-this.height/2?(t.position.y=this.y-this.height/2+t.radius,t.velocity.y*=-this.friction,this._static(t,\"y\")):t.position.y+t.radius>this.y+this.height/2&&(t.position.y=this.y+this.height/2-t.radius,t.velocity.y*=-this.friction,this._static(t,\"y\")),t.position.z-t.radius<this.z-this.depth/2?(t.position.z=this.z-this.depth/2+t.radius,t.velocity.z*=-this.friction,this._static(t,\"z\")):t.position.z+t.radius>this.z+this.depth/2&&(t.position.z=this.z+this.depth/2-t.radius,t.velocity.z*=-this.friction,this._static(t,\"z\"))}_static(t,e){t.velocity[e]*t.acceleration[e]>0||Math.abs(t.velocity[e])<.0167*Math.abs(t.acceleration[e])*this.max&&(t.velocity[e]=0,t.acceleration[e]=0)}_cross(t){t.position.x+t.radius<this.x-this.width/2&&t.velocity.x<=0?t.position.x=this.x+this.width/2+t.radius:t.position.x-t.radius>this.x+this.width/2&&t.velocity.x>=0&&(t.position.x=this.x-this.width/2-t.radius),t.position.y+t.radius<this.y-this.height/2&&t.velocity.y<=0?t.position.y=this.y+this.height/2+t.radius:t.position.y-t.radius>this.y+this.height/2&&t.velocity.y>=0&&(t.position.y=this.y-this.height/2-t.radius),t.position.z+t.radius<this.z-this.depth/2&&t.velocity.z<=0?t.position.z=this.z+this.depth/2+t.radius:t.position.z-t.radius>this.z+this.depth/2&&t.velocity.z>=0&&(t.position.z=this.z-this.depth/2-t.radius)}}class Oe extends Me{constructor(t,e,i,s,r,n){super(T),t instanceof ee?(this.x1=t.x,this.y1=t.y,this.z1=t.z,this.x2=s.x,this.y2=s.y,this.z2=s.z):(this.x1=t,this.y1=e,this.z1=i,this.x2=s,this.y2=r,this.z2=n),this.supportsCrossing=!1}isLineZone(){return!0}getPosition(){return this.random=Math.random(),this.vector.x=this.x1+this.random*(this.x2-this.x1),this.vector.y=this.y1+this.random*(this.y2-this.y1),this.vector.z=this.z1+this.random*(this.z2-this.z1),this.vector}}class Ee extends Me{constructor(t,e=1,i){if(super(S),this.geometry=null,this.scale=e,this.supportsCrossing=!1,t.type&&\"Geometry\"===t.type&&(this.geometry=t),t.geometry&&(this.geometry=t.geometry),!this.geometry)throw new Error(\"MeshZone unable to set geometry from the supplied bounds\");this.geometry.isBufferGeometry&&(this.geometry=(new i).fromBufferGeometry(this.geometry))}isMeshZone(){return!0}getPosition(){const t=this.geometry.vertices,e=t[t.length*Math.random()>>0];return this.vector.x=e.x*this.scale,this.vector.y=e.y*this.scale,this.vector.z=e.z*this.scale,this.vector}}class Te extends Me{constructor(t,e,i){var s;super(C),s=Rt.isUndefined(t,e,i)?0:t,this.x=s,this.y=s,this.z=s,this.supportsCrossing=!1}isPointZone(){return!0}getPosition(){return this.vector.x=this.x,this.vector.y=this.y,this.vector.z=this.z,this.vector}}class Se extends Me{constructor(t,e,i,s){super(\"ScreenZone\"),this.camera=t,this.renderer=e,this.dis=i||20,s=s||\"1234\";for(var r=1;r<5;r++)this[\"d\"+r]=s.indexOf(r+\"\")>=0}isScreenZone(){return!0}_dead(t){var e=It.toScreenPos(t.position,this.camera,this.renderer.domElement),i=this.renderer.domElement;(e.y+t.radius<-this.dis&&this.d1||e.y-t.radius>i.height+this.dis&&this.d3)&&(t.dead=!0),(e.x+t.radius<-this.dis&&this.d4||e.x-t.radius>i.width+this.dis&&this.d2)&&(t.dead=!0)}_bound(t){var e=It.toScreenPos(t.position,this.camera,this.renderer.domElement),i=this.renderer.domElement;(e.y+t.radius<-this.dis||e.y-t.radius>i.height+this.dis)&&(t.velocity.y*=-1),(e.x+t.radius<-this.dis||e.x-t.radius>i.width+this.dis)&&(t.velocity.y*=-1)}}var Ce,Ae,je,Ie,Re,Be,De,Ve;Se.prototype.getPosition=(Ae=new ee,function(){return Ce=this.renderer.domElement,Ae.x=Math.random()*Ce.width,Ae.y=Math.random()*Ce.height,this.vector.copy(It.toSpacePos(Ae,this.camera,Ce)),this.vector}),Se.prototype._cross=function(){var t=new ee;return function(e){var i=It.toScreenPos(e.position,this.camera,this.renderer.domElement),s=this.renderer.domElement;i.y+e.radius<-this.dis?(t.x=i.x,t.y=s.height+this.dis+e.radius,e.position.y=It.toSpacePos(t,this.camera,s).y):i.y-e.radius>s.height+this.dis&&(t.x=i.x,t.y=-this.dis-e.radius,e.position.y=It.toSpacePos(t,this.camera,s).y),i.x+e.radius<-this.dis?(t.y=i.y,t.x=s.width+this.dis+e.radius,e.position.x=It.toSpacePos(t,this.camera,s).x):i.x-e.radius>s.width+this.dis&&(t.y=i.y,t.x=-this.dis-e.radius,e.position.x=It.toSpacePos(t,this.camera,s).x)}}();class Fe extends Me{constructor(t,e,i,s){let r,n,o,a;super(A),Rt.isUndefined(e,i,s)?(r=n=o=0,a=t||100):(r=t,n=e,o=i,a=s),this.x=r,this.y=r,this.z=r,this.radius=a,this.the=this.phi=0}isSphereZone(){return!0}_dead(t){t.position.distanceTo(this)-t.radius>this.radius&&(t.dead=!0)}_cross(){console.warn(`${this.constructor.name} does not support the _cross method`)}}Fe.prototype.getPosition=function(){return this.random=Math.random(),Re=this.random*this.radius,je=R*Math.random(),Ie=2*R*Math.random(),this.vector.x=this.x+Re*Math.sin(je)*Math.cos(Ie),this.vector.y=this.y+Re*Math.sin(Ie)*Math.sin(je),this.vector.z=this.z+Re*Math.cos(je),this.vector},Fe.prototype._bound=(De=new ee,Ve=new ee,function(t){t.position.distanceTo(this)+t.radius>=this.radius&&(De.copy(t.position).sub(this).normalize(),Ve.copy(t.velocity),Be=2*Ve.dot(De),t.velocity.sub(De.scalar(Be)))});const ke=[\"zoneType\"];class Ze extends ue{constructor(){super(_),this.reset.apply(this,arguments)}reset(){this.zones?this.zones.length=0:this.zones=[],this.zones=this.zones.concat(Array.prototype.slice.call(arguments))}addZone(){this.zones=this.zones.concat(Array.prototype.slice.call(arguments))}static fromJSON(e){const{zoneType:i}=e,s=function(t,e){if(null==t)return{};var i,s,r=function(t,e){if(null==t)return{};var i,s,r={},n=Object.keys(t);for(s=0;s<n.length;s++)i=n[s],e.indexOf(i)>=0||(r[i]=t[i]);return r}(t,e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);for(s=0;s<n.length;s++)i=n[s],e.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(t,i)&&(r[i]=t[i])}return r}(e,ke);if(!ft.includes(i))throw new Error(`The zone type ${i} is invalid or not yet supported`);return new Ze(new t[i](...Object.values(s)))}}Ze.prototype.initialize=function(){let t;return function(e){t=this.zones[Math.random()*this.zones.length>>0],t.getPosition(),e.position.x=t.vector.x,e.position.y=t.vector.y,e.position.z=t.vector.z}}();class Ue extends ue{constructor(t,e,i=!1,s=!0){super(w,s),this.radius=Nt(t,e,i)}reset(t,e,i=!1){this.radius=Nt(t,e,i)}initialize(t){t.radius=this.radius.getValue(),t.transform.oldRadius=t.radius}static fromJSON(t){const{width:e,height:i,center:s=!1,isEnabled:r=!0}=t;return new Ue(e,i,s,r)}}class Ne extends ue{constructor(t=1,e=1){super(\"Rate\"),this.numPan=Nt(t),this.timePan=Nt(e),this.startTime=0,this.nextTime=0,this.init()}init(){this.startTime=0,this.nextTime=this.timePan.getValue()}getValue(t){return this.startTime+=t,this.startTime>=this.nextTime?(this.init(),1==this.numPan.b?this.numPan.getValue(\"Float\")>.5?1:0:this.numPan.getValue(\"Int\")):0}static fromJSON(t){const{particlesMin:e,particlesMax:i,perSecondMin:s,perSecondMax:r}=t;return new Ne(new Ut(e,i),new Ut(s,r))}}function Le(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function qe(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?Le(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):Le(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}class Ye extends ue{constructor(t,e,i=fe,s=!0){super(x,s);const{Sprite:r,SpriteMaterial:n}=t;this.materialProperties=kt(fe,i),this.texture=e,this.material=new n(qe(qe({},{map:e}),this.materialProperties)),this.sprite=new r(this.material)}initialize(t){t.body=this.sprite}static fromJSON(t,e){const{loadedTexture:i,materialProperties:s=me,isEnabled:r=!0}=t;return new Ye(e,i,kt(me,(t=>{const{blending:e}=t;return qe(qe({},t),{},{blending:e?ye[e]:ye[me.blending]})})(s)),r)}}class Ge extends ue{constructor(t,e=!0){super(t,e),this.dirVec=new ee(0,0,0)}normalize(t){return 100*t}}Ge.prototype.initialize=function(){var t,e=new ee(0,0,1),i=new ee(0,0,0);return function(s){return t=this.tha*Math.random(),this._useV&&this.dirVec.copy(this.dir).scalar(this.radiusPan.getValue()),Zt.getNormal(this.dirVec,e),i.copy(this.dirVec).applyAxisAngle(e,t),i.applyAxisAngle(this.dirVec.normalize(),Math.random()*R*2),s.velocity.copy(i),this}}();class Xe extends Ge{constructor(t,e,i=!0){super(M,i),this.tha=e*D,this.dirVec=t.toVector3D(),this._useV=!1}static fromJSON(t){const{polarRadius:e,polarTheta:i,polarPhi:s,velocityTheta:r,isEnabled:n=!0}=t;return new Xe(new ie(e,i,s),r,n)}}class Je extends Ge{constructor(t,e,i,s=!0){super(P,s),this.radiusPan=Nt(t),this.dir=e.clone().normalize(),this.tha=i*D,this._useV=!0}static fromJSON(t){const{radius:e,x:i,y:s,z:r,theta:n,isEnabled:o=!0}=t;return new Je(e,new ee(i,s,r),n,o)}}class Qe extends Ge{constructor(t,e,i=!0){super(z,i),this.radiusPan=Nt(1),this.dir=t.clone(),this.tha=e*D,this._useV=!0}static fromJSON(t){const{x:e,y:i,z:s,theta:r,isEnabled:n=!0}=t;return new Qe(new ee(e,i,s),r,n)}}const He=new Ne(1,.1);var $e=i(763),We=i.n($e);class Ke extends se{constructor(t){super(t),this.type=\"Emitter\",this.particles=[],this.initializers=[],this.behaviours=[],this.emitterBehaviours=[],this.currentEmitTime=0,this.totalEmitTimes=-1,this.damping=.006,this.bindEmitter=!0,this.bindEmitterEvent=!1,this.rate=He,this.isEmitting=!1,this.id=`emitter-${Dt()}`,this.cID=0,this.name=\"Emitter\",this.index=void 0,this.eventDispatcher=new ne}dispatch(t,e=this){this.eventDispatcher.dispatchEvent(t,e)}setRate(t){return this.rate=t,this}setPosition(t={}){const{position:e}=this,{x:i=e.x,y:s=e.y,z:r=e.z}=t;return this.position.set(i,s,r),this}setRotation(t={}){const{rotation:e}=this,{x:i=e.x,y:s=e.y,z:r=e.z}=t;return this.rotation.set(i,s,r),this}emit(t=1/0,e=1/0){return this.currentEmitTime=0,this.totalEmitTimes=We()(t)?t:1/0,this.life=1===t?t:We()(e)?e:1/0,this.rate.init(),this.isEmitting=!0,this}experimental_emit(){const{isEmitting:t,totalEmitTimes:e,life:i}=this;return t||(this.currentEmitTime=0,e||this.setTotalEmitTimes(1/0),i||this.setLife(1/0),this.rate.init(),this.isEmitting=!0),this}setTotalEmitTimes(t=1/0){return this.totalEmitTimes=We()(t)?t:1/0,this}setLife(t=1/0){return 1===this.totalEmitTimes?this.life=this.totalEmitTimes:this.life=We()(t)?t:1/0,this}stopEmit(){this.totalEmitTimes=-1,this.currentEmitTime=0,this.isEmitting=!1}removeAllParticles(){let t=this.particles.length;for(;t--;)this.particles[t].dead=!0}addInitializer(t){return this.initializers.push(t),this}addInitializers(t){let e=t.length;for(;e--;)this.addInitializer(t[e]);return this}setInitializers(t){return this.initializers=t,this}removeInitializer(t){const e=this.initializers.indexOf(t);return e>-1&&this.initializers.splice(e,1),this}removeAllInitializers(){return Rt.destroyArray(this.initializers),this}addBehaviour(t){return this.behaviours.push(t),this}addBehaviours(t){let e=t.length;for(;e--;)this.addBehaviour(t[e]);return this}setBehaviours(t){return this.behaviours=t,this}removeBehaviour(t){const e=this.behaviours.indexOf(t);return e>-1&&this.behaviours.splice(e,1),this}removeAllBehaviours(){return Rt.destroyArray(this.behaviours),this}addEmitterBehaviour(t){return this.emitterBehaviours.push(t),t.initialize(this),this}addEmitterBehaviours(t){let e=t.length;for(;e--;)this.addEmitterBehaviour(t[e]);return this}setEmitterBehaviours(t){const e=t.length;this.emitterBehaviours=t;for(let t=0;t<e;t++)this.emitterBehaviours[t].initialize(this);return this}removeEmitterBehaviour(t){const e=this.emitterBehaviours.indexOf(t);return e>-1&&this.emitterBehaviours.splice(e,1),this}removeAllEmitterBehaviours(){return Rt.destroyArray(this.emitterBehaviours),this}addOnEmitterDeadEventListener(t){return this.eventDispatcher.addEventListener(`${this.id}_EMITTER_DEAD`,(()=>t())),this}createParticle(){const t=this.parent.pool.get(se),e=this.particles.length;return this.setupParticle(t,e),this.parent&&this.parent.dispatch(ae,t),this.bindEmitterEvent&&this.dispatch(ae,t),t}setupParticle(t,e){const{initializers:i,behaviours:s}=this;_e.initialize(this,t,i),t.addBehaviours(s),t.parent=this,t.index=e,this.particles.push(t)}update(t){if(!this.isEmitting)return;this.age+=t,(this.dead||this.age>=this.life)&&this.destroy(),this.generate(t),this.integrate(t);let e=this.particles.length;for(;e--;){const t=this.particles[e];t.dead&&(this.parent&&this.parent.dispatch(ce,t),this.bindEmitterEvent&&this.dispatch(ce,t),this.parent.pool.expire(t.reset()),this.particles.splice(e,1))}this.updateEmitterBehaviours(t)}updateEmitterBehaviours(t){if(this.sleep)return;const e=this.emitterBehaviours.length;for(let i=0;i<e;i++)this.emitterBehaviours[i].applyBehaviour(this,t,i)}integrate(t){const e=this.parent?this.parent.integrationType:Ht,i=1-this.damping;te(this,t,i,e);let s=this.particles.length;for(;s--;){const r=this.particles[s];r.update(t,s),te(r,t,i,e),this.parent&&this.parent.dispatch(he,r),this.bindEmitterEvent&&this.dispatch(he,r)}}generate(t){if(1!==this.totalEmitTimes){if(this.currentEmitTime+=t,this.currentEmitTime<this.totalEmitTimes){let e=this.rate.getValue(t);for(e>0&&(this.cID=e);e--;)this.createParticle()}}else{let t=this.rate.getValue(99999);for(t>0&&(this.cID=t);t--;)this.createParticle();this.totalEmitTimes=0}}destroy(){this.dead=!0,this.energy=0,this.totalEmitTimes=-1,0==this.particles.length&&(this.isEmitting=!1,this.removeAllInitializers(),this.removeAllBehaviours(),this.dispatch(`${this.id}_EMITTER_DEAD`),this.parent&&this.parent.removeEmitter(this))}}const ti=Z;class ei{constructor(t=1/0,e=ti,i=\"Behaviour\",s=!0){this.type=i,this.isEnabled=s,this.id=`behaviour-${Dt()}`,this.life=t,this.easing=e,this.age=0,this.energy=1,this.dead=!1}reset(t=1/0,e=ti){this.life=t,this.easing=e||ti}set life(t){this._life=We()(t)?t:Infinity}get life(){return this._life}normalizeForce(t){return t.scalar(100)}normalizeValue(t){return 100*t}initialize(t){}applyBehaviour(t,e,i){this.isEnabled&&this.mutate(t,e,i)}mutate(t,e,i){}energize(t,e){if(this.dead)return;if(this.age+=e,this.age>=this.life)return this.energy=0,void(this.dead=!0);const i=this.easing(t.age/t.life);this.energy=Math.max(1-i,0)}destroy(){}fromJSON(t){}}class ii extends ei{constructor(t=1,e=null,i,s,r=!0){super(i,s,n,r),this.alphaA=t,this.alphaB=e,this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t=1,e=null,i,s){this.same=null==e,this.alphaA=Nt(t),this.alphaB=Nt(e),i&&super.reset(i,s)}initialize(t){t.useAlpha=!0,t.transform.alphaA=this.alphaA.getValue(),t.transform.alphaB=this.same?t.transform.alphaA:this.alphaB.getValue()}mutate(t,e,i){this.energize(t,e,i),t.alpha=Zt.lerp(t.transform.alphaA,t.transform.alphaB,this.energy),t.alpha<.002&&(t.alpha=0)}static fromJSON(t){const{alphaA:e,alphaB:i,life:s,easing:r,isEnabled:n=!0}=t;return new ii(e,i,s,ct(r),n)}}class si extends ei{constructor(t=new ee,e=100,i=1e3,s=1/0,r=ti,n=!0){super(s,r,o,n),this.targetPosition=t,this.radius=i,this.force=this.normalizeValue(e),this.radiusSq=this.radius*this.radius,this.attractionForce=new ee,this.lengthSq=0}reset(t=new ee,e=100,i=1e3,s,r){this.targetPosition=t,this.radius=i,this.force=this.normalizeValue(e),this.radiusSq=this.radius*this.radius,this.attractionForce=new ee,this.lengthSq=0,s&&super.reset(s,r)}mutate(t,e,i){this.energize(t,e,i),this.attractionForce.copy(this.targetPosition),this.attractionForce.sub(t.position),this.lengthSq=this.attractionForce.lengthSq(),this.lengthSq>4e-6&&this.lengthSq<this.radiusSq&&(this.attractionForce.normalize(),this.attractionForce.scalar(1-this.lengthSq/this.radiusSq),this.attractionForce.scalar(this.force),t.acceleration.add(this.attractionForce))}static fromJSON(t){const{x:e,y:i,z:s,force:r,radius:n,life:o,easing:a,isEnabled:h=!0}=t;return new si(new ee(e,i,s),r,n,o,ct(a),h)}}class ri extends ei{constructor(t,e,i,s,r,n=!0){super(s,r,\"Collision\",n),this.reset(t,e,i)}reset(t,e,i,s,r){this.emitter=t,this.useMass=e,this.onCollide=i,this.particles=[],this.delta=new ee,s&&super.reset(s,r)}mutate(t,e,i){const s=this.emitter?this.emitter.particles.slice(i):this.particles.slice(i);let r,n,o,a,h,c,u=s.length;for(;u--;)r=s[u],r!=t&&(this.delta.copy(r.position).sub(t.position),n=this.delta.lengthSq(),a=t.radius+r.radius,n<=a*a&&(o=a-Math.sqrt(n),o+=.5,h=this._getAverageMass(t,r),c=this._getAverageMass(r,t),t.position.add(this.delta.clone().normalize().scalar(o*-h)),r.position.add(this.delta.normalize().scalar(o*c)),this.onCollide&&this.onCollide(t,r)))}_getAverageMass(t,e){return this.useMass?e.mass/(t.mass+e.mass):.5}fromJSON(t){}}class ni extends ei{constructor(t,e,i,s,r=!0){super(i,s,a,r),this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t,e,i,s){this.same=null==e,this.colorA=Jt(t),this.colorB=Jt(e),i&&super.reset(i,s)}initialize(t){t.transform.colorA=gt.getRGB(this.colorA.getValue()),t.useColor=!0,t.transform.colorB=this.same?t.transform.colorA:gt.getRGB(this.colorB.getValue())}mutate(t,e,i){this.energize(t,e,i),this._same?(t.color.r=t.transform.colorA.r,t.color.g=t.transform.colorA.g,t.color.b=t.transform.colorA.b):(t.color.r=Zt.lerp(t.transform.colorA.r,t.transform.colorB.r,this.energy),t.color.g=Zt.lerp(t.transform.colorA.g,t.transform.colorB.g,this.energy),t.color.b=Zt.lerp(t.transform.colorA.b,t.transform.colorB.b,this.energy))}static fromJSON(t){const{colorA:e,colorB:i,life:s,easing:r,isEnabled:n=!0}=t;return new ni(e,i,s,ct(r),n)}}class oi extends ei{constructor(t,e,i,s,r){super(i,s,h,r),this.reset(t,e)}reset(t,e=\"dead\",i,s){this.zone=t,this.zone.crossType=e,i&&super.reset(i,s)}mutate(t,e,i){this.energize(t,e,i),this.zone.crossing.call(this.zone,t)}static fromJSON(e){const{zoneType:i,zoneParams:s,crossType:r,life:n,easing:o,isEnabled:a=!0}=e,h=new t[i](...Object.values(s));return new oi(h,r,n,ct(o),a)}}class ai extends ei{constructor(t,e,i,s,r,n=!0){super(s,r,c,n),this.reset(t,e,i)}reset(t,e,i){this.force=this.normalizeForce(new ee(t,e,i)),this.force.id=Math.random()}mutate(t,e,i){this.energize(t,e,i),t.acceleration.add(this.force)}static fromJSON(t){const{fx:e,fy:i,fz:s,life:r,easing:n,isEnabled:o=!0}=t;return new ai(e,i,s,r,ct(n),o)}}class hi extends ai{constructor(t,e,i,s=!0){super(0,-t,0,e,i,s),this.type=u}static fromJSON(t){const{gravity:e,life:i,easing:s,isEnabled:r=!0}=t;return new hi(e,i,ct(s),r)}}class ci extends ei{constructor(t,e,i,s=.03,r,n,o=!0){super(r,n,l,o),this.reset(t,e,i,s),this.time=0}reset(t,e,i,s=.03,r,n){this.randomForce=this.normalizeForce(new ee(t,e,i)),this.delayPan=Nt(s),this.time=0,r&&super.reset(r,n)}mutate(t,e,i){if(this.energize(t,e,i),this.time+=e,this.time>=this.delayPan.getValue()){const e=Zt.randomAToB(-this.randomForce.x,this.randomForce.x),i=Zt.randomAToB(-this.randomForce.y,this.randomForce.y),s=Zt.randomAToB(-this.randomForce.z,this.randomForce.z);t.acceleration.addValue(e,i,s),this.time=0}}static fromJSON(t){const{x:e,y:i,z:s,delay:r,life:n,easing:o,isEnabled:a=!0}=t;return new ci(e,i,s,r,n,ct(o),a)}}class ui extends si{constructor(t,e,i,s,r,n=!0){super(t,e,i,s,r,n),this.force*=-1,this.type=d}reset(t,e,i,s,r){super.reset(t,e,i,s,r),this.force*=-1}static fromJSON(t){const{x:e,y:i,z:s,force:r,radius:n,life:o,easing:a,isEnabled:h=!0}=t;return new ui(new ee(e,i,s),r,n,o,ct(a),h)}}class li extends ei{constructor(t,e,i,s,r,n=!0){super(s,r,p,n),this.reset(t,e,i)}get rotationType(){return this._rotationType}set rotationType(t){this._rotationType=t}reset(t,e,i,s,r){this.x=t||0,this.y=e||0,this.z=i||0,void 0===t||\"same\"==t?this.rotationType=\"same\":null==e?this.rotationType=\"set\":void 0===i?this.rotationType=\"to\":(this.rotationType=\"add\",this.x=Nt(this.x*D),this.y=Nt(this.y*D),this.z=Nt(this.z*D)),s&&super.reset(s,r)}initialize(t){switch(this.rotationType){case\"same\":break;case\"set\":this._setRotation(t.rotation,this.x);break;case\"to\":t.transform.fR=t.transform.fR||new ee,t.transform.tR=t.transform.tR||new ee,this._setRotation(t.transform.fR,this.x),this._setRotation(t.transform.tR,this.y);break;case\"add\":t.transform.addR=new ee(this.x.getValue(),this.y.getValue(),this.z.getValue())}}_setRotation(t,e){if(t=t||new ee,\"random\"==e){var i=Zt.randomAToB(-R,R),s=Zt.randomAToB(-R,R),r=Zt.randomAToB(-R,R);t.set(i,s,r)}else e instanceof ee&&t.copy(e)}mutate(t,e,i){switch(this.energize(t,e,i),this.rotationType){case\"same\":t.rotation||(t.rotation=new ee),t.rotation.eulerFromDir(t.velocity);break;case\"set\":break;case\"to\":t.rotation.x=Zt.lerp(t.transform.fR.x,t.transform.tR.x,this.energy),t.rotation.y=Zt.lerp(t.transform.fR.y,t.transform.tR.y,this.energy),t.rotation.z=Zt.lerp(t.transform.fR.z,t.transform.tR.z,this.energy);break;case\"add\":t.rotation.add(t.transform.addR)}}static fromJSON(t){const{x:e,y:i,z:s,life:r,easing:n,isEnabled:o=!0}=t;return new li(e,i,s,r,ct(n),o)}}class di extends ei{constructor(t,e,i,s,r=!0){super(i,s,y,r),this.reset(t,e)}get same(){return this._same}set same(t){this._same=t}reset(t,e,i,s){this.same=null==e,this.scaleA=Nt(t||1),this.scaleB=Nt(e),i&&super.reset(i,s)}initialize(t){t.transform.scaleA=this.scaleA.getValue(),t.transform.oldRadius=t.radius,t.transform.scaleB=this.same?t.transform.scaleA:this.scaleB.getValue()}mutate(t,e,i){this.energize(t,e,i),t.scale=Zt.lerp(t.transform.scaleA,t.transform.scaleB,this.energy),t.scale<5e-4&&(t.scale=0),t.radius=t.transform.oldRadius*t.scale}static fromJSON(t){const{scaleA:e,scaleB:i,life:s,easing:r,isEnabled:n=!0}=t;return new di(e,i,s,ct(r),n)}}class pi extends ei{constructor(t,e,i,s,r,n,o,a=!0){super(n,o,f,a),this.reset(t,e,i,s,r)}reset(t,e,i,s,r){this.pos?this.pos.set(t,e,i):this.pos=new ee(t,e,i),this.spring=s||.1,this.friction=r||.98}mutate(t,e,i){this.energize(t,e,i),t.velocity.x+=(this.pos.x-t.position.x)*this.spring,t.velocity.y+=(this.pos.y-t.position.y)*this.spring,t.velocity.z+=(this.pos.z-t.position.z)*this.spring}static fromJSON(t){const{x:e,y:i,z:s,spring:r,friction:n,life:o,easing:a,isEnabled:h=!0}=t;return new pi(e,i,s,r,n,o,ct(a),h)}}const yi=t=>{const e=[];return t.forEach((t=>{const{type:i,properties:s}=t;if(!yt.includes(i))throw new Error(`The behaviour type ${i} is invalid or not yet supported`);e.push(r[i].fromJSON(s))})),e};function fi(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function mi(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?fi(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):fi(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}const gi={shouldAutoEmit:!0},xi=t=>new Promise(((e,i)=>{if(!t.length)return e([]);const s=t.length,n=[];t.forEach((t=>{const{type:o,properties:a}=t;return yt.includes(o)?(n.push(r[o].fromJSON(a)),n.length===s?e(n):void 0):i(`The behaviour type ${o} is invalid or not yet supported`)}))}));class vi{constructor(t=B,e=Ht){this.type=\"System\",this.canUpdate=!0,this.preParticles=t,this.integrationType=e,this.emitters=[],this.renderers=[],this.pool=new re,this.eventDispatcher=new ne}static fromJSON(t,i){return((t,i,s,r)=>{const{preParticles:n=B,integrationType:o=V,emitters:a=[]}=t,h=new s(i,n,o);return a.forEach((t=>{const s=new r,{rate:n,rotation:o,initializers:a,behaviours:c,emitterBehaviours:u=[],position:l,totalEmitTimes:d=1/0,life:p=1/0}=t;s.setRate((t=>Ne.fromJSON(t))(n)).setRotation(o).setInitializers(((t,i)=>{const s=[];return t.forEach((t=>{const{type:r,properties:n}=t;if(!pt.includes(r))throw new Error(`The initializer type ${r} is invalid or not yet supported`);O.includes(r)?s.push(e[r].fromJSON(n,i)):s.push(e[r].fromJSON(n))})),s})(a,i)).setBehaviours(yi(c)).setEmitterBehaviours(yi(u)).setPosition(l).emit(d,p),h.addEmitter(s)})),h})(t,i,vi,Ke)}static fromJSONAsync(t,i,s){return((t,i,s,r,n={})=>new Promise(((o,a)=>{const{preParticles:h=B,integrationType:c=V,emitters:u=[]}=t,l=new s(h,c),{shouldAutoEmit:d}=mi(mi({},gi),n);((t,i,s,r)=>new Promise(((n,o)=>{if(!t.length)return n([]);const a=[],h=t.length;if(!h)return n(a);t.forEach((t=>{const c=new i,{rate:u,rotation:l,initializers:d,behaviours:p,emitterBehaviours:y=[],position:f,totalEmitTimes:m=1/0,life:g=1/0}=t;var x;c.setRate((x=u,Ne.fromJSON(x))).setRotation(l).setPosition(f),((t,i)=>new Promise(((s,r)=>{if(!t.length)return s([]);const n=t.length,o=[],a=t.filter((({properties:t})=>!t.texture)),h=t.filter((({properties:t})=>t.texture));a.forEach((t=>{const{type:a,properties:h}=t;return pt.includes(a)?(O.includes(a)?o.push(e[a].fromJSON(h,i)):o.push(e[a].fromJSON(h)),o.length===n?s(o):void 0):r(`The initializer type ${a} is invalid or not yet supported`)})),h.forEach((t=>{const{type:e,properties:a,properties:{texture:h}}=t,c=new i.TextureLoader;if(!pt.includes(e))return r(`The initializer type ${e} is invalid or not yet supported`);c.load(h,(t=>{if(o.push(Ye.fromJSON(mi(mi({},a),{},{loadedTexture:t}),i)),o.length===n)return s(o)}),void 0,r)}))})))(d,s).then((t=>(c.setInitializers(t),xi(p)))).then((t=>(c.setBehaviours(t),xi(y)))).then((t=>(c.setEmitterBehaviours(t),Promise.resolve(c)))).then((t=>{if(a.push(r?t.emit(m,g):t.setTotalEmitTimes(m).setLife(g)),a.length===h)return n(a)})).catch(o)}))})))(u,r,i,d).then((t=>{const e=t.length;if(!e)return o(l);t.forEach((t=>{l.addEmitter(t),l.emitters.length===e&&o(l)}))})).catch(a)})))(t,i,vi,Ke,s)}dispatch(t,e=this){this.eventDispatcher.dispatchEvent(t,e)}addRenderer(t){return this.renderers.push(t),t.init(this),this}removeRenderer(t){return this.renderers.splice(this.renderers.indexOf(t),1),t.remove(this),this}addEmitter(t){const e=this.emitters.length;return t.parent=this,t.index=e,this.emitters.push(t),this.dispatch(\"EMITTER_ADDED\",t),this}removeEmitter(t){return t.parent!==this||(t.parent=null,t.index=void 0,this.emitters.splice(this.emitters.indexOf(t),1),this.dispatch(\"EMITTER_REMOVED\",t)),this}emit({onStart:t,onUpdate:e,onEnd:i}){t&&t(),e&&this.eventDispatcher.addEventListener(oe,e);const s=this.emitters.map((t=>{const{life:e}=t;return e===1/0?(i&&i(),t.experimental_emit(),Promise.resolve()):new Promise((e=>{t.addOnEmitterDeadEventListener((()=>{i&&i(),e()})),t.experimental_emit()}))}));try{return Promise.all(s)}catch(t){console.warn(t)}}update(t=.0167){const e=t||dt;if(this.canUpdate){if(e>0){let t=this.emitters.length;for(;t--;){const i=this.emitters[t];i.update(e),i.isEmitting&&this.dispatch(oe)}}this.dispatch(\"SYSTEM_UPDATE_AFTER\")}return Promise.resolve()}getCount(){const t=this.emitters.length;let e,i=0;for(e=0;e<t;e++)i+=this.emitters[e].particles.length;return i}destroy(){const t=this.emitters.length;this.canUpdate=!1;for(let e=0;e<t;e++)this.emitters[e]&&this.emitters[e].destroy(),delete this.emitters[e];for(let e=0;e<t;e++)this.renderers[e]&&this.renderers[e].destroy&&(this.renderers[e].destroy(),delete this.renderers[e]);this.emitters.length=0,this.pool.destroy(),this.canUpdate=!0}}const bi=15,_i=0,wi={addEventListener:function(t,e){return t.eventDispatcher.addEventListener(\"SYSTEM_UPDATE\",e),this},drawZone:function(t,e,i,s={}){const{width:r=bi,height:n=bi,depth:o=bi,radius:a=bi,x:h=_i,y:c=_i,z:u=_i}=s;let l;s.isPointZone()&&(l=new t.SphereGeometry(15)),s.isLineZone(),s.isBoxZone()&&(l=new t.BoxGeometry(r,n,o)),s.isSphereZone()&&(l=new t.SphereGeometry(a,bi,bi)),s.isMeshZone()&&(l=s.geometry.geometry?s.geometry.geometry.clone():s.geometry.clone()),l||(l=new t.BoxGeometry(r,n,o));const d=new t.MeshBasicMaterial({color:\"#2194ce\",wireframe:!0}),p=new t.Mesh(l.clone(),d);i.add(p),this.addEventListener(e,(function(){p.position.set(h,c,u)}))},drawEmitter:function(t,e,i,s,r){const n=new t.OctahedronGeometry(bi),o=new t.MeshBasicMaterial({color:r||\"#aaa\",wireframe:!0}),a=new t.Mesh(n.clone(),o);i.add(a),this.addEventListener(e,(function(){a.position.copy(s.position),a.rotation.set(s.rotation.x,s.rotation.y,s.rotation.z)}))},renderInfo:function(){function t(t,e){var i=\"material\"==t?\"_materialPool\":\"_targetPool\";return e.renderers[0][i].cID}return function(e,i){this.addInfo(i);var s=\"\";switch(this._infoType){case 2:s+=\"emitter:\"+e.emitters.length+\"<br>\",s+=\"em speed:\"+e.emitters[0].cID+\"<br>\",s+=\"pos:\"+function(t){var e=t.emitters[0];return Math.round(e.p.x)+\",\"+Math.round(e.p.y)+\",\"+Math.round(e.p.z)}(e);break;case 3:s+=e.renderers[0].name+\"<br>\",s+=\"target:\"+t(\"target\")+\"<br>\",s+=\"material:\"+t(\"material\");break;default:s+=\"particles:\"+e.getCount()+\"<br>\",s+=\"pool:\"+e.pool.getCount()+\"<br>\",s+=\"total:\"+(e.getCount()+e.pool.getCount())}this._infoCon.innerHTML=s}}(),addInfo:function(t){var e=this;if(!this._infoCon){var i,s;switch(this._infoCon=document.createElement(\"div\"),this._infoCon.style.cssText=[\"position:fixed;bottom:0px;left:0;cursor:pointer;\",\"opacity:0.9;z-index:10000;padding:10px;font-size:12px;\",\"width:120px;height:50px;background-color:#002;color:#0ff;\"].join(\"\"),this._infoType=1,this._infoCon.addEventListener(\"click\",(function(){e._infoType++,e._infoType>3&&(e._infoType=1)}),!1),t){case 2:i=\"#201\",s=\"#f08\";break;case 3:i=\"#020\",s=\"#0f0\";break;default:i=\"#002\",s=\"#0ff\"}this._infoCon.style[\"background-color\"]=i,this._infoCon.style.color=s}this._infoCon.parentNode||document.body.appendChild(this._infoCon)}};function zi(){let t=0;if(window.console&&window.console.trace){var e=Array.prototype.slice.call(arguments),i=arguments[0]+\"\";if(0==i.indexOf(\"+\")){var s=parseInt(arguments[0]);t<s&&(e.shift(),console.trace.apply(console,e),t++)}else e.unshift(\"+15\"),this.apply(console,e)}}class Mi extends Ke{constructor(t,e,i){super(i),this.type=\"FollowEmitter\",this.mouseTarget=Rt.initValue(t,window),this.ease=Rt.initValue(e,.7),this._allowEmitting=!1,this.initEventHandler()}initEventHandler(){var t=this;this.mousemoveHandler=function(e){t.mousemove.call(t,e)},this.mousedownHandler=function(e){t.mousedown.call(t,e)},this.mouseupHandler=function(e){t.mouseup.call(t,e)},this.mouseTarget.addEventListener(\"mousemove\",this.mousemoveHandler,!1)}emit(){this._allowEmitting=!0}stopEmit(){this._allowEmitting=!1}setCameraAndCanvas(t,e){this.camera=t,this.canvas=e}mousemove(t){t.layerX||0==t.layerX?(this.position.x+=(t.layerX-this.position.x)*this.ease,this.position.y+=(t.layerY-this.position.y)*this.ease):(t.offsetX||0==t.offsetX)&&(this.position.x+=(t.offsetX-this.position.x)*this.ease,this.position.y+=(t.offsetY-this.position.y)*this.ease),this.position.copy(It.toSpacePos(this.position,this.camera,this.canvas)),this._allowEmitting&&super.emit(\"once\")}destroy(){super.destroy(),this.mouseTarget.removeEventListener(\"mousemove\",this.mousemoveHandler,!1)}}class Pi{constructor(t=\"BaseRenderer\"){this.type=t}init(t){var e=this;this.system=t,this.system.eventDispatcher.addEventListener(oe,(function(t){e.onSystemUpdate.call(e,t)})),this.system.eventDispatcher.addEventListener(ae,(function(t){e.onParticleCreated.call(e,t)})),this.system.eventDispatcher.addEventListener(he,(function(t){e.onParticleUpdate.call(e,t)})),this.system.eventDispatcher.addEventListener(ce,(function(t){e.onParticleDead.call(e,t)})),this.logRendererType()}remove(){this.system=null}onParticleCreated(t){}onParticleUpdate(t){}onParticleDead(t){}onSystemUpdate(t){}logRendererType(){F&&console.log(`${this.type}`)}}class Oi extends Pi{constructor(){super(\"CustomRenderer\"),this.targetPool=new re,this.materialPool=new re}onSystemUpdate(){}onParticleCreated(t){}onParticleUpdate(t){}onParticleDead(t){}}class Ei extends Pi{constructor(t,e){super(\"MeshRenderer\"),this.container=t,this._targetPool=new re,this._materialPool=new re,this._body=new e.Mesh(new e.BoxGeometry(50,50,50),new e.MeshLambertMaterial({color:\"#ff0000\"}))}isThreeSprite(t){return t.target.isSprite}onSystemUpdate(){}onParticleCreated(t){t.target||(t.body||(t.body=this._body),t.target=this._targetPool.get(t.body),(t.useAlpha||t.useColor)&&(t.target.material.__puid=xt.id(t.body.material),t.target.material=this._materialPool.get(t.target.material))),t.target&&(t.target.position.copy(t.position),this.container.add(t.target))}onParticleUpdate(t){const{target:e,useAlpha:i,useColor:s,rotation:r}=t;e&&(e.position.copy(t.position),this.isThreeSprite(t)||e.rotation.set(r.x,r.y,r.z),this.scale(t),i&&(e.material.opacity=t.alpha,e.material.transparent=!0),s&&e.material.color.copy(t.color))}scale(t){t.target.scale.set(t.scale,t.scale,t.scale)}onParticleDead(t){t.target&&((t.useAlpha||t.useColor)&&this._materialPool.expire(t.target.material),this._targetPool.expire(t.target),this.container.remove(t.target),t.target=null)}}class Ti extends Ei{constructor(t,e){super(t,e),this.type=\"SpriteRenderer\",this._body=new e.Sprite(new e.SpriteMaterial({color:16777215}))}scale(t){t.target.scale.set(t.scale*t.radius,t.scale*t.radius,1)}}const Si=[\"x\",\"y\",\"z\"].length,Ci=[\"r\",\"g\",\"b\",\"a\"].length,Ai=[4*Si,4,4*Ci].reduce(((t,e)=>t+e)),ji=1,Ii=1,Ri=2,Bi={position:Si,size:ji,color:Ci,alpha:Ii,texID:Ri},Di=([Si,ji,Ci,Ii,Ri].reduce(((t,e)=>t+e)),{blending:\"AdditiveBlending\",baseColor:16777215,depthTest:!0,depthWrite:!1,transparent:!0,maxParticles:1e4,shouldDebugTextureAtlas:!1,shouldForceDesktopRenderer:!1,shouldForceMobileRenderer:!1});class Vi{constructor(t){this.position=new t.Vector3,this.size=0,this.color=new t.Color,this.alpha=0,this.texture=null,this.index=0}reset(){this.position.set(0,0,0),this.size=0,this.color.setRGB(0,0,0),this.alpha=0,this.texture=null}}class Fi{constructor(t=1/0){this.max=t,this.count=0,this._items={}}add(t){void 0===this._items[t]&&(this._items[t]=this.count++)}find(t){return this._items[t]}destroy(){this._items={},this.count=0}}let ki;class Zi{constructor(t=1e4,e){ki=e,this.maxParticles=t,this.createInterleavedBuffer().createBufferGeometry()}createInterleavedBuffer(){const t=new ArrayBuffer(this.maxParticles*Ai);return this.interleavedBuffer=new ki.InterleavedBuffer(new Float32Array(t),Ai),this}createBufferGeometry(){this.geometry=new ki.BufferGeometry;const{interleavedBuffer:t,geometry:e}=this;return Object.keys(Bi).reduce(((i,s)=>{const r=Bi[s];return e.setAttribute(s,new ki.InterleavedBufferAttribute(t,r,i)),i+r}),0),this}get buffer(){return this.interleavedBuffer}get stride(){return Ai}}class Ui{constructor(t,e){const{three:i,type:s}=t,r=new Float32Array(1024),n=this.ctx=document.createElement(\"canvas\").getContext(\"2d\"),{canvas:o}=n;this.shouldDebug=e,this.rendererType=s,this.indexData=r,this.canvas=o,this.entries=[],s===I&&(this.atlasIndex=new i.DataTexture(r,256,1,i.RGBAFormat,i.FloatType)),o.width=o.height=256,e&&this.debug(o,n),this.atlasTexture=new i.CanvasTexture(o),this.atlasTexture.flipY=!1,t.material.uniforms.uTexture.value=this.atlasTexture,s===I&&(t.material.uniforms.atlasIndex.value=this.atlasIndex),t.material.uniformsNeedUpdate=!0}log(...t){F&&console.log(...t)}debug(){const{canvas:t,ctx:e}=this,i=t.width;e.fillStyle=\"purple\",e.fillRect(0,0,i,i),e.fillStyle=\"green\",e.fillRect(0,i,i,i),e.fillStyle=\"blue\",e.fillRect(i,0,i,i),e.fillStyle=\"orange\",e.fillRect(i,i,i,i),e.fillStyle=\"yellow\",e.font=t.width+\"px Verdana\",e.fillText(\"top row\",100,500),e.fillStyle=\"pink\",e.fillText(\"bottom row\",100,1500),t.style.position=\"absolute\",t.style.width=t.style.height=\"300px\",t.style.left=t.style.top=\"0px\",t.style.zIndex=100,document.body.appendChild(t)}addTexture(t){this.log(\"Adding texture to atlas:\",t.uuid),t.textureIndex=this.entries.length,this.entries.push({texture:t}),this.needsUpdate=!0}update(){if(!this.needsUpdate)return;const{entries:t,canvas:e,indexData:i,ctx:s,atlasIndex:r,atlasTexture:n,rendererType:o}=this;for(let e=0;e<t.length;e++)if(!t[e].texture.image)return;this.needsUpdate=!1;for(let e=0;e<t.length;e++){const i=t[e],{texture:s}=i,{width:r,height:n}=s.image;i.w=r,i.h=n}const a=function(t){let e=0,i=0;for(const s of t)e+=s.w*s.h,i=Math.max(i,s.w);t.sort(((t,e)=>e.h-t.h));const s=[{x:0,y:0,w:Math.max(Math.ceil(Math.sqrt(e/.95)),i),h:1/0}];let r=0,n=0;for(const e of t)for(let t=s.length-1;t>=0;t--){const i=s[t];if(!(e.w>i.w||e.h>i.h)){if(e.x=i.x,e.y=i.y,n=Math.max(n,e.y+e.h),r=Math.max(r,e.x+e.w),e.w===i.w&&e.h===i.h){const e=s.pop();t<s.length&&(s[t]=e)}else e.h===i.h?(i.x+=e.w,i.w-=e.w):e.w===i.w?(i.y+=e.h,i.h-=e.h):(s.push({x:i.x+e.w,y:i.y,w:i.w-e.w,h:e.h}),i.y+=e.h,i.h-=e.h);break}}return{w:r,h:n,fill:e/(r*n)||0}}(t);this.log(\"Rebuilt atlas:\",a),e.width==a.w&&e.height==a.h||(e.width=a.w,e.height=a.h);for(let r=0;r<t.length;r++){const t=this.entries[r],n=4*t.texture.textureIndex;o===I&&(i[n+0]=t.x/e.width,i[n+1]=t.y/e.height,i[n+2]=(t.x+t.w)/e.width,i[n+3]=(t.y+t.h)/e.height),o===j&&(i[n+0]=t.x/(e.width+1),i[n+1]=t.y/(e.height+1),i[n+2]=(t.x+t.w)/(e.width+1),i[n+3]=(t.y+t.h)/(e.height+1)),s.drawImage(t.texture.image,t.x,t.y,t.w,t.h)}o===I&&(r.needsUpdate=!0),n.needsUpdate=!0}destroy(){const{atlasIndex:t,atlasTexture:e,canvas:i}=this;e.dispose(),t&&t.dispose(),this.shouldDebug&&i.remove(),this.entries=[]}}function Ni(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function Li(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?Ni(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):Ni(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}let qi,Yi;class Gi extends Pi{constructor(t,e,i=Di){super(I),qi=this.three=e;const s=Li(Li({},Di),i),{camera:r,maxParticles:n,baseColor:o,blending:a,depthTest:h,depthWrite:c,transparent:u,shouldDebugTextureAtlas:l}=s,d=new Zi(n,qi),p=new qi.ShaderMaterial({uniforms:{baseColor:{value:new qi.Color(o)},uTexture:{value:null},atlasIndex:{value:null}},vertexShader:\"\\n    uniform sampler2D uTexture;\\n    //atlasIndex is a 256x1 float texture of tile rectangles as r=minx g=miny b=maxx a=maxy\\n    uniform sampler2D atlasIndex;\\n\\n    attribute float size;\\n    attribute vec3 color;\\n    attribute float alpha;\\n    attribute float texID;\\n\\n    varying vec3 targetColor;\\n    varying float targetAlpha;\\n    varying vec4 tileRect;\\n    varying float tileID;\\n\\n    void main() {\\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n      targetColor = color;\\n      targetAlpha = alpha;\\n\\n      tileID = texID;\\n      //get the tile rectangle from the atlasIndex texture..\\n      tileRect = texture2D(atlasIndex, vec2((tileID + 0.5) / 256.0, 0.5));\\n\\n      gl_PointSize = ((size * 600.0) / -mvPosition.z);\\n      gl_Position = projectionMatrix * mvPosition;\\n    }\\n\",fragmentShader:\"\\n    uniform vec3 baseColor;\\n    uniform sampler2D uTexture;\\n    uniform sampler2D atlasIndex;\\n\\n    varying vec3 targetColor;\\n    varying float targetAlpha;\\n    varying vec4 tileRect;\\n    varying float tileID;\\n\\n    void main() {\\n      gl_FragColor = vec4(baseColor * targetColor, targetAlpha);\\n\\n      vec2 uv = gl_PointCoord;\\n      uv = mix(tileRect.xy, tileRect.zw, gl_PointCoord);\\n\\n      gl_FragColor = gl_FragColor * texture2D(uTexture, uv);\\n\\n    }\\n\",blending:qi[a],depthTest:h,depthWrite:c,transparent:u});this.container=t,this.camera=r,this.targetPool=new re,this.uniqueList=new Fi(n),this.particleBuffer=d,this.buffer=d.buffer,this.stride=d.stride,this.geometry=d.geometry,this.material=p,this.points=new qi.Points(this.geometry,this.material),this.points.frustumCulled=!1,this.shouldDebugTextureAtlas=l,this.container.add(this.points)}onSystemUpdate(t){super.onSystemUpdate(t),this.buffer.needsUpdate=!0,this.textureAtlas&&this.textureAtlas.update()}onParticleCreated(t){t.target||(t.target=this.targetPool.get(Vi,qi),this.uniqueList.add(t.id)),this.updateTarget(t).mapParticleTargetPropsToPoint(t)}onParticleUpdate(t){t.target&&this.updateTarget(t).mapParticleTargetPropsToPoint(t)}onParticleDead(t){t.target&&(t.target.reset(),this.mapParticleTargetPropsToPoint(t),t.target=null)}updateTarget(t){const{position:e,scale:i,radius:s,color:r,alpha:n,body:o,id:a}=t,{r:h,g:c,b:u}=r;if(t.target.position.copy(e),t.target.size=i*s,t.target.color.setRGB(h,c,u),t.target.alpha=n,t.target.index=this.uniqueList.find(a),o&&o instanceof qi.Sprite){const{map:e}=o.material;t.target.texture=e,t.target.textureIndex=this.getTextureID(e,this.shouldDebugTextureAtlas)}return this}mapParticleTargetPropsToPoint(t){return this.updatePointPosition(t).updatePointSize(t).updatePointColor(t).updatePointAlpha(t).updatePointTextureIndex(t),this}updatePointPosition(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.position;return s.array[r.index*i+n+0]=r.position.x,s.array[r.index*i+n+1]=r.position.y,s.array[r.index*i+n+2]=r.position.z,this}updatePointSize(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.size;return s.array[r.index*i+n+0]=r.size,this}updatePointColor(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.color;return s.array[r.index*i+n+0]=r.color.r,s.array[r.index*i+n+1]=r.color.g,s.array[r.index*i+n+2]=r.color.b,this}updatePointAlpha(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.alpha;return s.array[r.index*i+n+0]=r.alpha,this}updatePointTextureIndex(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.texID;return s.array[r.index*i+n+0]=r.textureIndex,this}getTextureID(t,e){return void 0===t.textureIndex&&(this.textureAtlas||(this.textureAtlas=new Ui(this,e)),this.textureAtlas.addTexture(t)),t.textureIndex}destroy(){const{container:t,points:e,textureAtlas:i,uniqueList:s}=this;t.remove(e),s.destroy(),i&&i.destroy()}}function Xi(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);e&&(s=s.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,s)}return i}function Ji(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?Xi(Object(i),!0).forEach((function(e){mt(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):Xi(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}class Qi extends Pi{constructor(t,e,i=Di){super(j),Yi=this.three=e;const s=Ji(Ji({},Di),i),{camera:r,maxParticles:n,baseColor:o,blending:a,depthTest:h,depthWrite:c,transparent:u,shouldDebugTextureAtlas:l}=s,d=new Zi(n,Yi),p=new Yi.ShaderMaterial({uniforms:{baseColor:{value:new Yi.Color(o)},uTexture:{value:null},FFatlasIndex:{value:null},atlasDim:{value:new Yi.Vector2}},vertexShader:\"\\n    uniform sampler2D uTexture;\\n    uniform vec2 atlasDim;\\n\\n    attribute float size;\\n    attribute vec3 color;\\n    attribute float alpha;\\n    attribute vec2 texID;\\n\\n    varying vec3 targetColor;\\n    varying float targetAlpha;\\n    varying vec4 tileRect;\\n\\n    void main() {\\n      vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n      targetColor = color;\\n      targetAlpha = alpha;\\n\\n      vec2 tmin = floor(texID) / atlasDim;\\n      vec2 tmax = fract(texID);\\n      tileRect = vec4(tmin,tmax);\\n\\n      gl_PointSize = ((size * 600.0) / -mvPosition.z);\\n      gl_Position = projectionMatrix * mvPosition;\\n    }\\n\",fragmentShader:\"\\n    uniform vec3 baseColor;\\n    uniform sampler2D uTexture;\\n\\n    varying vec3 targetColor;\\n    varying float targetAlpha;\\n    varying vec4 tileRect;\\n\\n    void main() {\\n      gl_FragColor = vec4(baseColor * targetColor, targetAlpha);\\n\\n      vec2 uv = gl_PointCoord;\\n      uv = mix(tileRect.xy, tileRect.zw, gl_PointCoord);\\n\\n      gl_FragColor = gl_FragColor * texture2D(uTexture, uv);\\n    }\\n\",blending:Yi[a],depthTest:h,depthWrite:c,transparent:u});this.camera=r,this.targetPool=new re,this.uniqueList=new Fi(n),this.particleBuffer=d,this.buffer=d.buffer,this.stride=d.stride,this.geometry=d.geometry,this.material=p,this.points=new Yi.Points(this.geometry,this.material),this.points.frustumCulled=!1,this.shouldDebugTextureAtlas=l,t.add(this.points)}onSystemUpdate(t){super.onSystemUpdate(t),this.buffer.needsUpdate=!0;const{textureAtlas:e}=this;e&&(e.update(),this.material.uniforms.atlasDim.value.set(e.atlasTexture.image.width,e.atlasTexture.image.height))}onParticleCreated(t){t.target||(t.target=this.targetPool.get(Vi,Yi),this.uniqueList.add(t.id)),this.updateTarget(t).mapParticleTargetPropsToPoint(t)}onParticleUpdate(t){t.target&&this.updateTarget(t).mapParticleTargetPropsToPoint(t)}onParticleDead(t){t.target&&(t.target.reset(),this.mapParticleTargetPropsToPoint(t),t.target=null)}updateTarget(t){const{position:e,scale:i,radius:s,color:r,alpha:n,body:o,id:a}=t,{r:h,g:c,b:u}=r;if(t.target.position.copy(e),t.target.size=i*s,t.target.color.setRGB(h,c,u),t.target.alpha=n,t.target.index=this.uniqueList.find(a),o&&o instanceof Yi.Sprite){const{map:e}=o.material;t.target.texture=e,t.target.textureIndex=this.getTextureID(e,this.shouldDebugTextureAtlas)}return this}mapParticleTargetPropsToPoint(t){return this.updatePointPosition(t).updatePointSize(t).updatePointColor(t).updatePointAlpha(t).updatePointTextureIndex(t),this}updatePointPosition(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.position;return s.array[r.index*i+n+0]=r.position.x,s.array[r.index*i+n+1]=r.position.y,s.array[r.index*i+n+2]=r.position.z,this}updatePointSize(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.size;return s.array[r.index*i+n+0]=r.size,this}updatePointColor(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.color;return s.array[r.index*i+n+0]=r.color.r,s.array[r.index*i+n+1]=r.color.g,s.array[r.index*i+n+2]=r.color.b,this}updatePointAlpha(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.alpha;return s.array[r.index*i+n+0]=r.alpha,this}updatePointTextureIndex(t){const{geometry:e,stride:i,buffer:s}=this,{target:r}=t,{offset:n}=e.attributes.texID,o=r.index*i+n+0;{let t=4*r.textureIndex;const e=this.textureAtlas,i=e.indexData,n=i[t++],a=i[t++],h=i[t++],c=i[t++];s.array[o]=(n*e.atlasTexture.image.width|0)+h,s.array[o+1]=(a*e.atlasTexture.image.height|0)+c}return this}getTextureID(t,e){return void 0===t.textureIndex&&(this.textureAtlas||(this.textureAtlas=new Ui(this,e)),this.textureAtlas.addTexture(t)),t.textureIndex}destroy(){const{container:t,points:e,textureAtlas:i,uniqueList:s}=this;t.remove(e),s.destroy(),i&&i.destroy()}}class Hi extends Pi{constructor(t,e,i=Di){super(\"GPURenderer\");const{shouldForceDesktopRenderer:s,shouldForceMobileRenderer:r}=i,n=[t,e,i];return s?new Gi(...n):r?new Qi(...n):this.isFloatingPointTextureSupported()?new Gi(...n):new Qi(...n)}isFloatingPointTextureSupported(){const t=document.createElement(\"canvas\");if(window.WebGL2RenderingContext&&t.getContext(\"webgl2\"))return!0;const e=!!t.getContext(\"webgl\").getExtension(\"OES_texture_float\");return t.remove(),e}}const $i=vi})(),s})()}));\r\n",
        "filePath": "/global/libraries/js/three-nebula.js"
      },
      "ModelManager": {
        "title": "ModelManager",
        "fileName": "ModelManager",
        "script": "class ModelManager {\r\n    constructor(app, config, { ShapeFactory, palette, textures }) {\r\n        this.app = app;\r\n        this.config = config;\r\n        this.shapeFactory = new ShapeFactory(this.app.getResourcesPath(), palette, textures, null, 1);\r\n\r\n        if (location.hostname.indexOf('github') >= 0) {\r\n            this.shapeFactory.setURLRoot(\"/GUTS/\");\r\n        }\r\n\r\n        // VAT-focused storage\r\n        this.masterModels = new Map();           // objectType_spawnType -> THREE.Group (master models)\r\n        this.animationModels = new Map();        // objectType_spawnType_animName -> THREE.Group\r\n        this.vatBundles = new Map();             // objectType_spawnType -> { geometry, material, vatTexture, meta }\r\n        this.vatBundlePromises = new Map();      // objectType_spawnType -> Promise\r\n\r\n        this.assetsLoaded = false;\r\n        this.app.modelManager = this;\r\n    }\r\n\r\n    clear() {\r\n        this.masterModels.clear();\r\n        this.animationModels.clear();\r\n        this.vatBundles.clear();\r\n        this.vatBundlePromises.clear();\r\n    }\r\n\r\n    dispose() {\r\n        // Dispose VAT bundles\r\n        for (const [key, bundle] of this.vatBundles) {\r\n            if (bundle.geometry) bundle.geometry.dispose();\r\n            if (bundle.material) bundle.material.dispose();\r\n            if (bundle.vatTexture) bundle.vatTexture.dispose();\r\n        }\r\n        this.clear();\r\n    }\r\n\r\n    async loadModels(prefix, config) {\r\n\r\n        // Load all models first (master + animations)\r\n        for (const [type, cfg] of Object.entries(config)) {\r\n            if (!cfg.render?.model) continue;\r\n\r\n            const modelKey = `${prefix}_${type}`;\r\n\r\n            // Load master model\r\n            this.masterModels.set(modelKey, await this.createModel(cfg.render.model));\r\n\r\n            // Load animation variants\r\n            if (cfg.render.animations) {\r\n                for (const [animName, variants] of Object.entries(cfg.render.animations)) {\r\n                    for (let variantIndex = 0; variantIndex < variants.length; variantIndex++) {\r\n                        const animVariant = variants[variantIndex];\r\n                        const animKey = variantIndex === 0\r\n                            ? `${modelKey}_${animName}`\r\n                            : `${modelKey}_${animName}_${variantIndex}`;\r\n\r\n                        // Merge animation model data\r\n                        let mergedModel = JSON.parse(JSON.stringify(cfg.render.model));\r\n                        if (animVariant && Object.keys(animVariant).length > 0) {\r\n                            const mainGroupName = Object.keys(mergedModel)[0];\r\n                            const animGroupName = Object.keys(animVariant)[0];\r\n                            if (animVariant[animGroupName]?.shapes?.[0]?.url) {\r\n                                mergedModel[mainGroupName].shapes[0].url = animVariant[animGroupName].shapes[0].url;\r\n                            }\r\n                        }\r\n\r\n                        this.animationModels.set(animKey, await this.createModel(mergedModel));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.assetsLoaded = true;\r\n    }\r\n\r\n    async createModel(modelData) {\r\n        const rootGroup = new THREE.Group();\r\n        for (const groupName in modelData) {\r\n            const group = await this.shapeFactory.createMergedGroupFromJSON(\r\n                modelData, {}, groupName, null, null\r\n            );\r\n            if (group) {\r\n                rootGroup.add(group);\r\n            }\r\n        }\r\n        return rootGroup;\r\n    }\r\n\r\n    // Main VAT bundle creation - called by RenderSystem\r\n    async requestVATBundle(objectType, spawnType, unitDef) {\r\n        const key = `${objectType}_${spawnType}`;\r\n\r\n        // Return existing bundle\r\n        if (this.vatBundles.has(key)) {\r\n            return { ready: true, bundle: this.vatBundles.get(key) };\r\n        }\r\n\r\n        // Return in-progress promise\r\n        if (this.vatBundlePromises.has(key)) {\r\n            return { ready: false, promise: this.vatBundlePromises.get(key) };\r\n        }\r\n\r\n        // Start building VAT bundle\r\n        const promise = this._buildVATBundle(key, objectType, spawnType, unitDef);\r\n        this.vatBundlePromises.set(key, promise);\r\n\r\n        try {\r\n            const bundle = await promise;\r\n            if (bundle) {\r\n                this.vatBundles.set(key, bundle);\r\n                return { ready: true, bundle };\r\n            }\r\n        } catch (error) {\r\n            console.error(`[ModelManager] VAT bundle failed: ${key}`, error);\r\n        } finally {\r\n            this.vatBundlePromises.delete(key);\r\n        }\r\n\r\n        return { ready: false, error: 'VAT bundle creation failed' };\r\n    }\r\n\r\n    async _buildVATBundle(key, objectType, spawnType, unitDef) {\r\n\r\n        // Get master model\r\n        const masterModel = this.masterModels.get(key);\r\n        if (!masterModel) {\r\n            throw new Error(`Master model not found: ${key}`);\r\n        }\r\n\r\n        // Find any mesh - prefer skinned mesh but fallback to any mesh\r\n        let targetMesh = null;\r\n        let skeleton = null;\r\n        \r\n        masterModel.traverse(obj => {\r\n            if (obj.isSkinnedMesh && obj.skeleton && !targetMesh) {\r\n                targetMesh = obj;\r\n                skeleton = obj.skeleton;\r\n            } else if (obj.isMesh && !targetMesh) {\r\n                targetMesh = obj;\r\n            }\r\n        });\r\n\r\n        if (!targetMesh) {\r\n            throw new Error(`No mesh found in: ${key}`);\r\n        }\r\n\r\n        // Collect animation clips (may be empty for static meshes)\r\n        const clips = await this._collectAnimationClips(key, objectType, spawnType, unitDef);\r\n        \r\n        // If no skeleton or no clips, create a static \"animation\" \r\n        if (!skeleton || clips.length === 0) {\r\n            return this._buildStaticVATBundle(key, masterModel, targetMesh);\r\n        }\r\n\r\n        // Standard VAT bundle with animations\r\n        const vatData = await this._bakeVATTexture(masterModel, skeleton, clips);\r\n        if (!vatData) {\r\n            throw new Error(`VAT baking failed for: ${key}`);\r\n        }\r\n\r\n        vatData.clipIndexByName = this._buildClipIndexMap(vatData.clips);\r\n        const material = this._createVATMaterial(targetMesh, vatData, key);\r\n        const geometry = targetMesh.geometry.clone();\r\n\r\n        // Copy bone data\r\n        const skinIndexAttr = targetMesh.geometry.getAttribute('skinIndex');\r\n        const skinWeightAttr = targetMesh.geometry.getAttribute('skinWeight');\r\n        if (!skinIndexAttr || !skinWeightAttr) {\r\n            throw new Error('Skinned geometry missing skinIndex/skinWeight attributes.');\r\n        }\r\n        \r\n        geometry.setAttribute('aBoneIndex', skinIndexAttr.clone());\r\n        geometry.setAttribute('aBoneWeight', skinWeightAttr.clone());\r\n\r\n        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);\r\n        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);\r\n        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);\r\n\r\n        return {\r\n            geometry,\r\n            material,\r\n            vatTexture: vatData.texture,\r\n            meta: {\r\n                fps: vatData.fps,\r\n                cols: vatData.cols,\r\n                rows: vatData.rows,\r\n                clips: vatData.clips,\r\n                clipIndexByName: vatData.clipIndexByName,\r\n                skeleton: skeleton,\r\n                attachmentTexture: vatData.attachmentTexture,\r\n                attachmentBones: vatData.attachmentBones\r\n            }\r\n        };\r\n    }\r\n\r\n    // Add method for static meshes without skeletons:\r\n    _buildStaticVATBundle(key, masterModel, mesh) {\r\n            console.log('build static', key);\r\n        const clips = [{ name: 'idle', startRow: 0, frames: 1 }];\r\n        const clipIndexByName = { 'idle': 0 };\r\n        \r\n        // Now use clips in the material creation\r\n        const identityData = new Float32Array([\r\n            1, 0, 0, 0,  // identity matrix column 0\r\n            0, 1, 0, 0,  // identity matrix column 1  \r\n            0, 0, 1, 0,  // identity matrix column 2\r\n            0, 0, 0, 1   // identity matrix column 3\r\n        ]);\r\n\r\n        const identityTexture = new THREE.DataTexture(\r\n            identityData, 4, 1, THREE.RGBAFormat, THREE.FloatType\r\n        );\r\n        identityTexture.needsUpdate = true;\r\n        identityTexture.flipY = false;\r\n\r\n        // Then use this instead of null:\r\n        const material = this._createVATMaterial(mesh, {\r\n            texture: identityTexture,  // Instead of null\r\n            clips: clips,\r\n            clipIndexByName: clipIndexByName,\r\n            fps: 30,\r\n            cols: 4,\r\n            rows: 1\r\n        }, key);\r\n\r\n        material.userData.batchKey = key;\r\n        material.customProgramCacheKey = () => key;\r\n        material.needsUpdate = true;\r\n\r\n        const geometry = mesh.geometry.clone();\r\n        const positionCount = geometry.getAttribute('position').count;\r\n        \r\n        // Create identity bone data (all vertices use bone 0 with weight 1)\r\n        const boneIndices = new Float32Array(positionCount * 4);\r\n        const boneWeights = new Float32Array(positionCount * 4);\r\n        \r\n        for (let i = 0; i < positionCount; i++) {\r\n            boneIndices[i * 4] = 0;     // bone index 0\r\n            boneWeights[i * 4] = 1;     // full weight\r\n            // other indices/weights remain 0\r\n        }\r\n        \r\n        geometry.setAttribute('aBoneIndex', new THREE.BufferAttribute(boneIndices, 4));\r\n        geometry.setAttribute('aBoneWeight', new THREE.BufferAttribute(boneWeights, 4));\r\n\r\n        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);\r\n        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);\r\n        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);\r\n        const baseScale = (masterModel && masterModel.children[0]?.scale) ? masterModel.children[0].scale : new THREE.Vector3(1, 1, 1);\r\n        const basePos = (masterModel && masterModel.children[0]?.position) ? masterModel.children[0].position : new THREE.Vector3(0, 0, 0);\r\n\r\n        return {\r\n            geometry,\r\n            material,\r\n            vatTexture: null, // No animation texture needed\r\n            meta: {\r\n                fps: 30,\r\n                cols: 4,   // Identity matrix\r\n                rows: 1,   // Single frame\r\n                clips: clips,\r\n                clipIndexByName: clipIndexByName,\r\n                baseScale: baseScale,\r\n                basePos: basePos\r\n            }\r\n        };\r\n    }\r\n    \r\n    _ensureFloatAttribute(geometry, name, itemSize, fillValue = 0.0) {\r\n        if (!geometry.getAttribute(name)) {\r\n            const pos = geometry.getAttribute('position');\r\n            const count = pos ? pos.count : 0;\r\n            const arr = new Float32Array(count * itemSize);\r\n            if (fillValue !== 0.0) arr.fill(fillValue);\r\n            geometry.setAttribute(name, new THREE.BufferAttribute(arr, itemSize));\r\n        }\r\n    }\r\n\r\n    async _collectAnimationClips(key, objectType, spawnType, unitDef) {\r\n        const clips = [];\r\n\r\n        // Define standard animation names in order\r\n        const animNames = ['idle', 'walk', 'attack', 'cast', 'death', 'celebrate'];\r\n\r\n        for (const animName of animNames) {\r\n            // Skip if not defined in unit config\r\n            if (!unitDef?.render?.animations?.[animName]) continue;\r\n\r\n            try {\r\n                // Try to get animation model\r\n                const animKey = `${key}_${animName}`;\r\n                const animModel = this.animationModels.get(animKey);\r\n\r\n                if (animModel) {\r\n                    // Extract clip from animation model\r\n                    let clip = null;\r\n                    animModel.traverse(obj => {\r\n                        if (obj.userData?.animations?.[0]) {\r\n                            clip = obj.userData.animations[0];\r\n                        }\r\n                    });\r\n\r\n                    if (clip) {\r\n                        clips.push({ name: animName, clip });\r\n                    }\r\n                } else {\r\n                    console.warn(`[ModelManager] Animation model not found: ${animKey}`);\r\n                }\r\n            } catch (error) {\r\n                console.warn(`[ModelManager] Failed to load animation '${animName}' for ${key}:`, error);\r\n            }\r\n        }\r\n\r\n        // Ensure we have at least idle\r\n        if (clips.length === 0 || !clips.some(c => c.name === 'idle')) {\r\n            // Create a default idle clip\r\n            const defaultClip = new THREE.AnimationClip('idle', 1.0, []);\r\n            clips.unshift({ name: 'idle', clip: defaultClip });\r\n        }\r\n\r\n        return clips;\r\n    }\r\n\r\n    async _bakeVATTexture(masterModel, skeleton, clipData, fps = 30) {\r\n\r\n        const bones = skeleton.bones;\r\n        const boneCount = bones.length;\r\n        const bindMatrices = skeleton.boneInverses;\r\n\r\n        // Calculate texture dimensions\r\n        const cols = boneCount * 4; // 4 columns per bone (matrix rows)\r\n        let totalFrames = 0;\r\n\r\n        const clipMeta = clipData.map(({ name, clip }) => {\r\n            const duration = clip.duration || 1.0;\r\n            const frames = Math.max(1, Math.ceil(duration * fps));\r\n            totalFrames += frames;\r\n            return { name, clip, duration, frames };\r\n        });\r\n\r\n        const rows = totalFrames;\r\n\r\n        // Create texture data\r\n        const textureData = new Float32Array(rows * cols * 4); // RGBA\r\n        const mixer = new THREE.AnimationMixer(masterModel);\r\n        const tempMatrix = new THREE.Matrix4();\r\n\r\n        let currentRow = 0;\r\n\r\n        // Bake each clip\r\n        for (const clipInfo of clipMeta) {\r\n            const action = mixer.clipAction(clipInfo.clip);\r\n            action.play();\r\n\r\n\r\n            // Bake frames for this clip\r\n            for (let frame = 0; frame < clipInfo.frames; frame++) {\r\n                // Calculate time for this frame\r\n                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;\r\n                mixer.setTime(t);\r\n                masterModel.updateMatrixWorld(true);\r\n\r\n                // Bake bone matrices for this frame\r\n                for (let boneIndex = 0; boneIndex < boneCount; boneIndex++) {\r\n                    // Calculate final bone matrix (world * inverse bind)\r\n                    tempMatrix.copy(bones[boneIndex].matrixWorld);\r\n                    tempMatrix.multiply(bindMatrices[boneIndex]);\r\n\r\n                    // Store matrix as 4 columns (transposed for shader)\r\n                    const elements = tempMatrix.elements; // column-major\r\n                    const textureRowIndex = currentRow + frame;\r\n                    const boneColumnStart = boneIndex * 4;\r\n\r\n                    for (let col = 0; col < 4; col++) {\r\n                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;\r\n                        // Store column of matrix as RGBA\r\n                        textureData[pixelIndex + 0] = elements[col * 4 + 0]; // x\r\n                        textureData[pixelIndex + 1] = elements[col * 4 + 1]; // y\r\n                        textureData[pixelIndex + 2] = elements[col * 4 + 2]; // z\r\n                        textureData[pixelIndex + 3] = elements[col * 4 + 3]; // w\r\n                    }\r\n                }\r\n            }\r\n\r\n            action.stop();\r\n            currentRow += clipInfo.frames;\r\n        }\r\n\r\n        // Create texture\r\n        const texture = new THREE.DataTexture(\r\n            textureData,\r\n            cols,\r\n            rows,\r\n            THREE.RGBAFormat,\r\n            THREE.FloatType\r\n        );\r\n        texture.needsUpdate = true;\r\n        texture.flipY = false;\r\n        texture.wrapS = THREE.ClampToEdgeWrapping;\r\n        texture.wrapT = THREE.ClampToEdgeWrapping;\r\n\r\n        // Build clip info with row ranges\r\n        let rowOffset = 0;\r\n        const clips = clipMeta.map(info => {\r\n            const clipData = {\r\n                name: info.name,\r\n                startRow: rowOffset,\r\n                endRow: rowOffset + info.frames,\r\n                frames: info.frames,\r\n                duration: info.duration\r\n            };\r\n            rowOffset += info.frames;\r\n            return clipData;\r\n        });\r\n\r\n        const attachmentData = await this._bakeBoneAttachmentTexture(\r\n            masterModel, bones, bindMatrices, mixer, clipMeta, fps\r\n        );\r\n\r\n        return {\r\n            texture,\r\n            cols,\r\n            rows,\r\n            fps,\r\n            clips,\r\n            boneCount,\r\n            attachmentTexture: attachmentData.texture,\r\n            attachmentBones: attachmentData.bones\r\n        };\r\n\r\n  \r\n    }\r\n\r\n    _createVATMaterial(baseMesh, vatData, batchKey = 'unknown') {\r\n        // Get base material properties\r\n        const sourceMaterial = Array.isArray(baseMesh.material)\r\n            ? baseMesh.material[0]\r\n            : baseMesh.material;\r\n\r\n        // Create VAT material (do NOT enable skinning; we aren't using Three's path)\r\n        const material = new THREE.MeshStandardMaterial({\r\n            map: sourceMaterial?.map || null,\r\n            color: sourceMaterial?.color?.clone() || new THREE.Color(0xffffff),\r\n            metalness: sourceMaterial?.metalness ?? 0.5,\r\n            roughness: sourceMaterial?.roughness ?? 0.5,\r\n            transparent: false\r\n        });\r\n\r\n        // Add VAT shader modifications\r\n        material.side = THREE.DoubleSide;           // helps if any frames flip winding\r\n        material.metalness = sourceMaterial?.metalness ?? 0.05; // less metal, easier to see\r\n        material.roughness = sourceMaterial?.roughness ?? 0.9;  // more diffuse light\r\n        // Make VAT lookups crisp (optional but recommended)\r\n        if(vatData.texture){\r\n            vatData.texture.magFilter = THREE.NearestFilter;\r\n            vatData.texture.minFilter = THREE.NearestFilter;\r\n        }\r\n        // Force unique shader compilation per batch\r\n        material.userData.batchKey = batchKey;\r\n        material.customProgramCacheKey = () => batchKey;\r\n\r\n        material.onBeforeCompile = (shader) => {\r\n            shader.uniforms.uVATTexture = { value: vatData.texture };\r\n            shader.uniforms.uVATCols    = { value: vatData.cols };\r\n            shader.uniforms.uVATRows    = { value: vatData.rows };\r\n            shader.uniforms.uVATFPS     = { value: vatData.fps };\r\n\r\n            // FIXED: Generate unique defines per batch to prevent cross-batch contamination\r\n            const batchPrefix = batchKey.toUpperCase().replace(/[^A-Z0-9]/g, '_');\r\n            const clipDefines = vatData.clips.map((clip, index) => `\r\n                #define ${batchPrefix}_CLIP_${index}_START ${clip.startRow}.0\r\n                #define ${batchPrefix}_CLIP_${index}_FRAMES ${clip.frames}.0\r\n            `).join('\\n');\r\n\r\n\r\n            const clipHelpers = `\r\n                float getClipStartRow(float clipIndex) {\r\n                    ${vatData.clips.map((clip, i) => \r\n                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_START;`\r\n                    ).join('\\n                    ')}\r\n                    return ${batchPrefix}_CLIP_0_START;\r\n                }\r\n                float getClipFrames(float clipIndex) {\r\n                    ${vatData.clips.map((clip, i) => \r\n                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_FRAMES;`\r\n                    ).join('\\n                    ')}\r\n                    return ${batchPrefix}_CLIP_0_FRAMES;\r\n                }\r\n                mat4 sampleVATMatrix(float row, float boneIndex) {\r\n                    float boneColStart = boneIndex * 4.0;\r\n                    float v = (row + 0.5) / uVATRows;\r\n                    vec4 c0 = texture2D(uVATTexture, vec2((boneColStart + 0.5) / uVATCols, v));\r\n                    vec4 c1 = texture2D(uVATTexture, vec2((boneColStart + 1.5) / uVATCols, v));\r\n                    vec4 c2 = texture2D(uVATTexture, vec2((boneColStart + 2.5) / uVATCols, v));\r\n                    vec4 c3 = texture2D(uVATTexture, vec2((boneColStart + 3.5) / uVATCols, v));\r\n                    return mat4(c0, c1, c2, c3);  // columns\r\n                }\r\n            `;\r\n\r\n            // strip three's skinning prelude (we supply our own attributes)\r\n            shader.vertexShader = shader.vertexShader.replace('#include <skinning_pars_vertex>', '');\r\n\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                'void main() {',\r\n                `\r\n                // Custom VAT attributes\r\n                attribute vec4 aBoneIndex;\r\n                attribute vec4 aBoneWeight;\r\n                attribute float aClipIndex;\r\n                attribute float aAnimTime;\r\n                attribute float aAnimSpeed;\r\n\r\n                uniform sampler2D uVATTexture;\r\n                uniform float uVATCols;\r\n                uniform float uVATRows;\r\n                uniform float uVATFPS;\r\n\r\n                ${clipDefines}\r\n                ${clipHelpers}\r\n\r\n                // Shared temporaries\r\n                float _vat_currentRow;\r\n                mat4 _vat_bm0, _vat_bm1, _vat_bm2, _vat_bm3;\r\n\r\n                void main() {\r\n                `\r\n            );\r\n\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n            '#include <beginnormal_vertex>',\r\n            `\r\n            // Determine current frame\r\n            float _clipStart  = getClipStartRow(aClipIndex);\r\n            float _clipFrames = getClipFrames(aClipIndex);\r\n            float _frame      = floor(mod(aAnimTime * uVATFPS, _clipFrames));\r\n            _vat_currentRow   = _clipStart + _frame;\r\n\r\n            // Normalize bone weights (must be available here)\r\n            float wsum_bn = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;\r\n            vec4 w = (wsum_bn > 0.0) ? (aBoneWeight / wsum_bn) : vec4(1.0, 0.0, 0.0, 0.0);\r\n\r\n            // Sample bone matrices for this frame (needed for normals too)\r\n            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);\r\n            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);\r\n            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);\r\n            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);\r\n\r\n            // Skin the normal and renormalize\r\n            vec3 n = normal;\r\n            vec3 skinnedN =\r\n                    mat3(_vat_bm0) * n * w.x +\r\n                    mat3(_vat_bm1) * n * w.y +\r\n                    mat3(_vat_bm2) * n * w.z +\r\n                    mat3(_vat_bm3) * n * w.w;\r\n\r\n            vec3 objectNormal = normalize(skinnedN);\r\n            `\r\n            );\r\n\r\n            // --- begin_vertex: (re)compute weights & use same matrices to skin position\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n            '#include <begin_vertex>',\r\n            `\r\n            // Recompute (safe if driver reorders chunks)\r\n            float wsum_bv = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;\r\n            vec4 w2 = (wsum_bv > 0.0) ? (aBoneWeight / wsum_bv) : vec4(1.0, 0.0, 0.0, 0.0);\r\n\r\n            // Ensure matrices are available (cheap duplicates; keeps things robust)\r\n            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);\r\n            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);\r\n            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);\r\n            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);\r\n\r\n            // Skin the position\r\n            vec4 _pos = vec4(position, 1.0);\r\n            vec4 _skinnedPos =\r\n                    (_vat_bm0 * _pos) * w2.x +\r\n                    (_vat_bm1 * _pos) * w2.y +\r\n                    (_vat_bm2 * _pos) * w2.z +\r\n                    (_vat_bm3 * _pos) * w2.w;\r\n\r\n            vec3 transformed = _skinnedPos.xyz;\r\n            `\r\n            );\r\n        };\r\n        material.needsUpdate = true;\r\n        return material;\r\n    }\r\n\r\n    _buildClipIndexMap(clips) {\r\n        const map = {};\r\n        clips.forEach((clip, index) => {\r\n            map[clip.name] = index;\r\n        });\r\n        return map;\r\n    }\r\n\r\n    // Legacy compatibility for non-unit objects (buildings, environment objects, etc.)\r\n    getModel(objectType, spawnType) {\r\n        const key = `${objectType}_${spawnType}`;\r\n\r\n        // For units, redirect to VAT system\r\n        if (objectType === 'units') {\r\n            console.warn(`[ModelManager] Unit '${spawnType}' should use VAT batching, not getModel()`);\r\n            // Return master model clone for emergency compatibility\r\n            const master = this.masterModels.get(key);\r\n            return master ? master.clone() : null;\r\n        }\r\n\r\n        // For environment objects, buildings, etc. - return master model clone\r\n        const masterModel = this.masterModels.get(key);\r\n        if (masterModel) {\r\n            const clone = masterModel.clone();\r\n            // Apply basic material setup\r\n            clone.traverse(child => {\r\n                if (child.isMesh) {\r\n                    child.castShadow = true;\r\n                    child.receiveShadow = true;\r\n                }\r\n            });\r\n            return clone;\r\n        }\r\n\r\n        console.warn(`[ModelManager] No model found for ${objectType}_${spawnType}`);\r\n        return null;\r\n    }\r\n\r\n    // Legacy compatibility for animations\r\n    async getAnimation(objectType, spawnType, animName, variantIndex = 0) {\r\n        const key = variantIndex === 0\r\n            ? `${objectType}_${spawnType}_${animName}`\r\n            : `${objectType}_${spawnType}_${animName}_${variantIndex}`;\r\n\r\n        const animModel = this.animationModels.get(key);\r\n        if (animModel) {\r\n            const clone = animModel.clone();\r\n            clone.traverse(child => {\r\n                if (child.isMesh) {\r\n                    child.castShadow = true;\r\n                    child.receiveShadow = true;\r\n                }\r\n            });\r\n            return clone;\r\n        }\r\n\r\n        console.warn(`[ModelManager] No animation model found for ${key}`);\r\n        return null;\r\n    }\r\n\r\n    // Public API\r\n    hasVATBundle(objectType, spawnType) {\r\n        return this.vatBundles.has(`${objectType}_${spawnType}`);\r\n    }\r\n\r\n    getVATBundle(objectType, spawnType) {\r\n        return this.vatBundles.get(`${objectType}_${spawnType}`);\r\n    }\r\n    async _bakeBoneAttachmentTexture(masterModel, bones, bindMatrices, mixer, clipMeta, fps) {\r\n        const attachmentBoneNames = [\r\n            'RightHand', 'LeftHand', 'Head', 'Spine2', 'Spine'\r\n        ];\r\n        const bonePrefix = 'mixamorig';\r\n        \r\n        const attachmentBones = [];\r\n        for (const boneName of attachmentBoneNames) {\r\n            let foundIndex = -1;\r\n            for (let i = 0; i < bones.length; i++) {\r\n                const bone = bones[i];\r\n                const cleanName = bone.name.replace(bonePrefix, '');\r\n                if (bone.name === boneName || cleanName === boneName || bone.name.includes(boneName)) {\r\n                    foundIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n            attachmentBones.push({ name: boneName, index: foundIndex });\r\n        }\r\n\r\n        const validBones = attachmentBones.filter(b => b.index >= 0);\r\n        const cols = validBones.length * 4;\r\n        const totalFrames = clipMeta.reduce((sum, info) => sum + info.frames, 0);\r\n        const rows = totalFrames;\r\n\r\n        const textureData = new Float32Array(rows * cols * 4);\r\n        const tempMatrix = new THREE.Matrix4();\r\n        const worldMatrix = new THREE.Matrix4();\r\n\r\n        let currentRow = 0;\r\n\r\n        for (const clipInfo of clipMeta) {\r\n            const action = mixer.clipAction(clipInfo.clip);\r\n            action.play();\r\n\r\n            for (let frame = 0; frame < clipInfo.frames; frame++) {\r\n                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;\r\n                mixer.setTime(t);\r\n                masterModel.updateMatrixWorld(true);\r\n\r\n                for (let i = 0; i < validBones.length; i++) {\r\n                    const boneIndex = validBones[i].index;\r\n                    const bone = bones[boneIndex];\r\n                    \r\n                    worldMatrix.copy(bone.matrixWorld);\r\n                    tempMatrix.copy(worldMatrix).multiply(bindMatrices[boneIndex]);\r\n\r\n                    const elements = tempMatrix.elements;\r\n                    const textureRowIndex = currentRow + frame;\r\n                    const boneColumnStart = i * 4;\r\n\r\n                    for (let col = 0; col < 4; col++) {\r\n                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;\r\n                        textureData[pixelIndex + 0] = elements[col * 4 + 0];\r\n                        textureData[pixelIndex + 1] = elements[col * 4 + 1];\r\n                        textureData[pixelIndex + 2] = elements[col * 4 + 2];\r\n                        textureData[pixelIndex + 3] = elements[col * 4 + 3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            action.stop();\r\n            currentRow += clipInfo.frames;\r\n        }\r\n\r\n        const texture = new THREE.DataTexture(\r\n            textureData,\r\n            cols,\r\n            rows,\r\n            THREE.RGBAFormat,\r\n            THREE.FloatType\r\n        );\r\n        texture.needsUpdate = true;\r\n        texture.flipY = false;\r\n        texture.wrapS = THREE.ClampToEdgeWrapping;\r\n        texture.wrapT = THREE.ClampToEdgeWrapping;\r\n\r\n        console.log(`[ModelManager] Baked attachment texture: ${cols}x${rows} for ${validBones.length} bones`);\r\n\r\n        return {\r\n            texture,\r\n            bones: attachmentBones,\r\n            validBones\r\n        };\r\n    }\r\n}",
        "filePath": "/global/libraries/js/ModelManager.js"
      },
      "PhysicsEngine": {
        "title": "PhysicsEngine",
        "fileName": "PhysicsEngine",
        "script": "/**\r\n * PhysicsEngine: Handles all physics calculations and collision detection\r\n * for a 3D environment with entities, terrain, and static objects.\r\n * Enhanced with continuous collision detection to prevent tunneling.\r\n */\r\nclass PhysicsEngine {\r\n      \r\n    /**\r\n     * Initialize the physics engine with configuration\r\n     * @param {Object} config - Configuration object\r\n     * @param {number} config.gravity - Gravity constant\r\n     * @param {Object} config.biomeConfig - Terrain biome configuration\r\n     * @param {number} config.chunkSize - Size of terrain chunks\r\n     * @param {number} config.chunkResolution - Resolution of terrain chunks\r\n     * @param {number} config.maxSubsteps - Maximum substeps for CCD (default: 5)\r\n     * @param {number} config.speedThreshold - Speed threshold for CCD (default: 10)\r\n     */\r\n    init(config = {}) {\r\n      this.gravity = config.gravity || -9.8;\r\n      this.handleTerrainCollision = config.handleTerrainCollision;    \r\n      this.getTerrainHeight = config.getTerrainHeight;\r\n      \r\n      // Anti-tunneling configuration\r\n      this.maxSubsteps = config.maxSubsteps || 5;\r\n      this.speedThreshold = config.speedThreshold || 10;\r\n      this.minTimeStep = 1/120; // Minimum time step for high precision\r\n    }\r\n  \r\n    /**\r\n     * Update physics for all entities\r\n     * @param {Array} entities - List of entities to update\r\n     * @param {Array} collisionData - Static collision data\r\n     * @param {number} deltaTime - Time step for physics calculation\r\n     * @returns {Array} Updated entities\r\n     */\r\n    update(entities, collisionData, deltaTime) {\r\n      // Reset collision flags\r\n      entities.forEach(entity => {\r\n        if (entity.collider) {\r\n          entity.collidedWithEntity = false;\r\n          entity.collidedWithStatic = false;\r\n          entity.collidedWith = null;\r\n          entity.grounded = false;\r\n        }\r\n      });\r\n      \r\n      // Use sub-steps for fast-moving objects to prevent tunneling\r\n      this.updateWithSubsteps(entities, collisionData, deltaTime);\r\n      \r\n      return entities;\r\n    }\r\n    \r\n    /**\r\n     * Update physics using substeps for continuous collision detection\r\n     * @param {Array} entities - List of entities to update\r\n     * @param {Array} collisionData - Static collision data\r\n     * @param {number} deltaTime - Time step for physics calculation\r\n     */\r\n    updateWithSubsteps(entities, collisionData, deltaTime) {\r\n      // With threshold of 0, all entities use substeps, so no need to filter\r\n      const numSubsteps = Math.min(\r\n        this.maxSubsteps, \r\n        Math.max(1, Math.ceil(this.getMaxEntitySpeed(entities) / (this.speedThreshold || 0.001)))\r\n      );\r\n      \r\n      // Use at least 3 substeps when maxSubsteps is very high\r\n      const actualSubsteps = Math.max(3, Math.min(numSubsteps, 10));\r\n      const subDeltaTime = deltaTime / actualSubsteps;\r\n      \r\n      // Process all entities together with substeps\r\n      for (let i = 0; i < actualSubsteps; i++) {\r\n        this.processPhysicsStep(entities, collisionData, subDeltaTime);\r\n      }\r\n    }\r\n        \r\n    /**\r\n     * Process a single physics step\r\n     * @private\r\n     */\r\n    processPhysicsStep(entities, collisionData, deltaTime) {\r\n      // Apply gravity and update positions\r\n      this.updateEntitiesPosition(entities, deltaTime);\r\n      \r\n      // Update AABBs after position update but before collision detection\r\n      entities.forEach(entity => {\r\n        if (entity.collider) {\r\n          this.updateEntityAABB(entity);\r\n        }\r\n      });\r\n      \r\n      // Handle entity-entity collisions\r\n      const collisionPairs = this.detectEntityCollisions(entities, deltaTime);\r\n      this.resolveEntityCollisions(collisionPairs);\r\n      \r\n      // Handle terrain and static collisions\r\n      this.resolveTerrainAndStaticCollisions(entities, collisionData, deltaTime);\r\n      \r\n      // Final AABB update after all collision resolution\r\n      entities.forEach(entity => {\r\n        if (entity.collider) {\r\n          this.updateEntityAABB(entity);\r\n        }\r\n      });\r\n    }\r\n  \r\n    /**\r\n     * Update entity positions and AABBs\r\n     * @private\r\n     */\r\n    updateEntitiesPosition(entities, deltaTime) {\r\n      entities.forEach(entity => {\r\n        if (!entity.collider) return;\r\n        \r\n        // Apply gravity\r\n        entity.velocity.y += (entity.collider.gravity ? this.gravity : 0) * 10 * deltaTime;\r\n\r\n        // Store previous position for swept collision detection\r\n        entity.previousPosition = { \r\n          x: entity.position.x, \r\n          y: entity.position.y, \r\n          z: entity.position.z \r\n        };\r\n\r\n        // Update position\r\n        entity.position.x += entity.velocity.x * deltaTime;\r\n        entity.position.y += entity.velocity.y * deltaTime;\r\n        entity.position.z += entity.velocity.z * deltaTime;\r\n  \r\n        // Update AABB\r\n        this.updateEntityAABB(entity);\r\n      });\r\n    }\r\n  \r\n    /**\r\n     * Update entity's Axis-Aligned Bounding Box\r\n     * @private\r\n     */\r\n    updateEntityAABB(entity) {\r\n      if (!entity.collider) return;\r\n      \r\n      const pos = {\r\n        x: entity.position.x + entity.collider.offset.x,\r\n        y: entity.position.y + entity.collider.offset.y,\r\n        z: entity.position.z + entity.collider.offset.z\r\n      };\r\n      \r\n      if (entity.collider.type === 'sphere') {\r\n        const r = entity.collider.size;\r\n        entity.aabb = {\r\n          min: { x: pos.x - r, y: pos.y - r, z: pos.z - r },\r\n          max: { x: pos.x + r, y: pos.y + r, z: pos.z + r }\r\n        };\r\n      } else if (entity.collider.type === 'box') {\r\n        const s = entity.collider.size;\r\n        entity.aabb = {\r\n          min: { x: pos.x - s.x / 2, y: pos.y - s.y / 2, z: pos.z - s.z / 2 },\r\n          max: { x: pos.x + s.x / 2, y: pos.y + s.y / 2, z: pos.z + s.z / 2 }\r\n        };\r\n      }\r\n      \r\n      // Create a swept AABB if previous position exists\r\n      if (entity.previousPosition) {\r\n        entity.sweptAABB = this.createSweptAABB(entity);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * Create a swept AABB that encompasses the entity's movement path\r\n     * @private\r\n     */\r\n    createSweptAABB(entity) {\r\n      if (!entity.collider || !entity.previousPosition) return null;\r\n      \r\n      // Expand the AABB slightly to avoid precision issues\r\n      const EPSILON = 0.001;\r\n      \r\n      const prevPos = {\r\n        x: entity.previousPosition.x + entity.collider.offset.x,\r\n        y: entity.previousPosition.y + entity.collider.offset.y,\r\n        z: entity.previousPosition.z + entity.collider.offset.z\r\n      };\r\n      \r\n      const currPos = {\r\n        x: entity.position.x + entity.collider.offset.x,\r\n        y: entity.position.y + entity.collider.offset.y,\r\n        z: entity.position.z + entity.collider.offset.z\r\n      };\r\n      \r\n      let minX = Math.min(prevPos.x, currPos.x) - EPSILON;\r\n      let minY = Math.min(prevPos.y, currPos.y) - EPSILON;\r\n      let minZ = Math.min(prevPos.z, currPos.z) - EPSILON;\r\n      let maxX = Math.max(prevPos.x, currPos.x) + EPSILON;\r\n      let maxY = Math.max(prevPos.y, currPos.y) + EPSILON;\r\n      let maxZ = Math.max(prevPos.z, currPos.z) + EPSILON;\r\n      \r\n      if (entity.collider.type === 'sphere') {\r\n        const r = entity.collider.size;\r\n        return {\r\n          min: { x: minX - r, y: minY - r, z: minZ - r },\r\n          max: { x: maxX + r, y: maxY + r, z: maxZ + r }\r\n        };\r\n      } else if (entity.collider.type === 'box') {\r\n        const s = entity.collider.size;\r\n        return {\r\n          min: { x: minX - s.x / 2, y: minY - s.y / 2, z: minZ - s.z / 2 },\r\n          max: { x: maxX + s.x / 2, y: maxY + s.y / 2, z: maxZ + s.z / 2 }\r\n        };\r\n      }\r\n      \r\n      return null;\r\n    }\r\n  \r\n    /**\r\n     * Detect collisions between entities using swept AABBs for fast moving objects\r\n     * @private\r\n     * @returns {Array} List of collision pairs\r\n     */\r\n    detectEntityCollisions(entities, deltaTime) {\r\n      const collisionPairs = [];\r\n      \r\n      // Add collision debugging\r\n      const DEBUG = false; // Set to true to see debug info\r\n      \r\n      for (let i = 0; i < entities.length; i++) {\r\n        for (let j = i + 1; j < entities.length; j++) {\r\n          const e1 = entities[i];\r\n          const e2 = entities[j];\r\n          \r\n          if (!e1.collider || !e2.collider) continue;\r\n          \r\n          if (DEBUG) {\r\n            console.log(`Checking collision: ${e1.id || i} vs ${e2.id || j}`);\r\n          }\r\n\r\n          let collision = null;\r\n          \r\n          // Always use swept collision detection since threshold is 0\r\n          if (e1.sweptAABB && e2.sweptAABB) {\r\n            // First do a broad phase check with swept AABBs\r\n            if (this.aabbIntersects(e1.sweptAABB, e2.sweptAABB)) {\r\n              // Now do precise CCD for potential collisions\r\n              if (e1.collider.type === 'sphere' && e2.collider.type === 'sphere') {\r\n                collision = this.continuousSphereSphereCollision(e1, e2, deltaTime);\r\n              } else {\r\n                collision = this.continuousBoxBoxCollision(e1, e2, deltaTime);\r\n              }\r\n              \r\n              if (DEBUG && collision) {\r\n                console.log(`  - CCD detected collision! TOI: ${collision.timeOfImpact}`);\r\n              }\r\n            } else if (DEBUG) {\r\n              console.log(`  - Swept AABBs don't intersect`);\r\n            }\r\n          } else {\r\n            // Fallback to standard collision detection\r\n            if (e1.collider.type === 'sphere' && e2.collider.type === 'sphere') {\r\n              collision = this.sphereSphereCollision(e1, e2, deltaTime);\r\n            } else {\r\n              collision = this.boxBoxCollision(e1, e2, deltaTime);\r\n            }\r\n            \r\n            if (DEBUG && collision) {\r\n              console.log(`  - Standard collision detected!`);\r\n            }\r\n          }\r\n\r\n          if (collision) {\r\n            collisionPairs.push({ e1, e2, ...collision });\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (DEBUG) {\r\n        console.log(`Detected ${collisionPairs.length} collisions`);\r\n      }\r\n      \r\n      return collisionPairs;\r\n    }\r\n    \r\n    /**\r\n     * Continuous collision detection between two entities\r\n     * @private\r\n     */\r\n    continuousCollisionDetection(e1, e2, deltaTime) {\r\n      // Determine collision type based on collider types\r\n      if (e1.collider.type === 'sphere' && e2.collider.type === 'sphere') {\r\n        return this.continuousSphereSphereCollision(e1, e2, deltaTime);\r\n      } else {\r\n        return this.continuousBoxBoxCollision(e1, e2, deltaTime);\r\n      }\r\n    }\r\n    \r\n    /**\r\n     * Continuous collision detection for spheres\r\n     * @private\r\n     */\r\n    continuousSphereSphereCollision(e1, e2, deltaTime) {\r\n      const r1 = e1.collider.size;\r\n      const r2 = e2.collider.size;\r\n      const combinedRadius = r1 + r2;\r\n      \r\n      // Get positions with offset\r\n      const p1Start = {\r\n        x: e1.previousPosition.x + e1.collider.offset.x,\r\n        y: e1.previousPosition.y + e1.collider.offset.y,\r\n        z: e1.previousPosition.z + e1.collider.offset.z\r\n      };\r\n      \r\n      const p2Start = {\r\n        x: e2.previousPosition.x + e2.collider.offset.x,\r\n        y: e2.previousPosition.y + e2.collider.offset.y,\r\n        z: e2.previousPosition.z + e2.collider.offset.z\r\n      };\r\n      \r\n      const p1End = {\r\n        x: e1.position.x + e1.collider.offset.x,\r\n        y: e1.position.y + e1.collider.offset.y,\r\n        z: e1.position.z + e1.collider.offset.z\r\n      };\r\n      \r\n      const p2End = {\r\n        x: e2.position.x + e2.collider.offset.x,\r\n        y: e2.position.y + e2.collider.offset.y,\r\n        z: e2.position.z + e2.collider.offset.z\r\n      };\r\n      \r\n      // Relative movement vectors\r\n      const move1 = {\r\n        x: p1End.x - p1Start.x,\r\n        y: p1End.y - p1Start.y,\r\n        z: p1End.z - p1Start.z\r\n      };\r\n      \r\n      const move2 = {\r\n        x: p2End.x - p2Start.x,\r\n        y: p2End.y - p2Start.y,\r\n        z: p2End.z - p2Start.z\r\n      };\r\n      \r\n      // Relative velocity\r\n      const relVelocity = {\r\n        x: move1.x - move2.x,\r\n        y: move1.y - move2.y,\r\n        z: move1.z - move2.z\r\n      };\r\n      \r\n      // Relative position\r\n      const relPosition = {\r\n        x: p1Start.x - p2Start.x,\r\n        y: p1Start.y - p2Start.y,\r\n        z: p1Start.z - p2Start.z\r\n      };\r\n      \r\n      // Solving quadratic equation for time of impact\r\n      // We're finding when distance^2 = combinedRadius^2\r\n      const a = relVelocity.x * relVelocity.x + \r\n                relVelocity.y * relVelocity.y + \r\n                relVelocity.z * relVelocity.z;\r\n                \r\n      // If there's no relative movement, use regular collision check\r\n      if (Math.abs(a) < 0.0001) {\r\n        return this.sphereSphereCollision(e1, e2, deltaTime);\r\n      }\r\n      \r\n      const b = 2 * (relPosition.x * relVelocity.x + \r\n                    relPosition.y * relVelocity.y + \r\n                    relPosition.z * relVelocity.z);\r\n                    \r\n      const c = relPosition.x * relPosition.x + \r\n                relPosition.y * relPosition.y + \r\n                relPosition.z * relPosition.z - \r\n                combinedRadius * combinedRadius;\r\n      \r\n      // Check if spheres are already intersecting\r\n      if (c <= 0) {\r\n        // Spheres already intersecting, use regular collision detection\r\n        return this.sphereSphereCollision(e1, e2, deltaTime);\r\n      }\r\n      \r\n      // Check if collision is possible\r\n      const discriminant = b * b - 4 * a * c;\r\n      \r\n      if (discriminant < 0) {\r\n        return null; // No collision possible\r\n      }\r\n      \r\n      // Find time of impact (TOI)\r\n      const toi = (-b - Math.sqrt(discriminant)) / (2 * a);\r\n      \r\n      // Check if collision happens within this time step\r\n      if (toi < 0 || toi > 1) {\r\n        return null; // Collision outside time step\r\n      }\r\n      \r\n      // Interpolate positions at time of impact (FIXED - now interpolates both objects)\r\n      const p1AtToi = {\r\n        x: p1Start.x + toi * move1.x,\r\n        y: p1Start.y + toi * move1.y,\r\n        z: p1Start.z + toi * move1.z\r\n      };\r\n      \r\n      const p2AtToi = {\r\n        x: p2Start.x + toi * move2.x,\r\n        y: p2Start.y + toi * move2.y,\r\n        z: p2Start.z + toi * move2.z\r\n      };\r\n      \r\n      // Calculate normal at impact\r\n      const dx = p2AtToi.x - p1AtToi.x;\r\n      const dy = p2AtToi.y - p1AtToi.y;\r\n      const dz = p2AtToi.z - p1AtToi.z;\r\n      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n      \r\n      if (distance < 0.0001) {\r\n        // Objects are too close, use a default normal direction\r\n        // This prevents division by zero\r\n        return {\r\n          normal: { x: 0, y: 1, z: 0 },\r\n          penetration: combinedRadius,\r\n          impulse: { x: 0, y: 0, z: 0 },\r\n          timeOfImpact: toi\r\n        };\r\n      }\r\n      \r\n      const normal = { \r\n        x: dx / distance, \r\n        y: dy / distance, \r\n        z: dz / distance \r\n      };\r\n      \r\n      const penetration = combinedRadius - distance;\r\n      \r\n      // Calculate velocity along normal at time of impact\r\n      const relVelAtImpact = {\r\n        x: (e1.velocity.x - e2.velocity.x),\r\n        y: (e1.velocity.y - e2.velocity.y),\r\n        z: (e1.velocity.z - e2.velocity.z)\r\n      };\r\n      \r\n      const velAlongNormal = \r\n        relVelAtImpact.x * normal.x + \r\n        relVelAtImpact.y * normal.y + \r\n        relVelAtImpact.z * normal.z;\r\n        \r\n      // Only respond to objects moving toward each other\r\n      if (velAlongNormal > 0) return null;\r\n      \r\n      const restitution = Math.min(e1.collider.restitution || 0.2, e2.collider.restitution || 0.2);\r\n      const impulseScalar = -(1 + restitution) * velAlongNormal / \r\n                            ((e1.collider.mass ? 1/e1.collider.mass : 0) + \r\n                            (e2.collider.mass ? 1/e2.collider.mass : 0));\r\n      \r\n      return {\r\n        normal,\r\n        penetration,\r\n        impulse: {\r\n          x: impulseScalar * normal.x,\r\n          y: impulseScalar * normal.y,\r\n          z: impulseScalar * normal.z\r\n        },\r\n        timeOfImpact: toi\r\n      };\r\n    }\r\n    \r\n    /**\r\n     * Continuous collision detection for boxes\r\n     * @private\r\n     */\r\n    continuousBoxBoxCollision(e1, e2, deltaTime) {\r\n      // For box-box continuous collision, we'll use a simplified approach with swept AABBs\r\n      // This is more complex to implement with full accuracy, so we'll use a conservative approach\r\n      \r\n      // First check if they're currently intersecting\r\n      if (this.aabbIntersects(e1.aabb, e2.aabb)) {\r\n        return this.boxBoxCollision(e1, e2, deltaTime);\r\n      }\r\n      \r\n      // Calculate relative velocity\r\n      const relVelocity = {\r\n        x: e1.velocity.x - e2.velocity.x,\r\n        y: e1.velocity.y - e2.velocity.y,\r\n        z: e1.velocity.z - e2.velocity.z\r\n      };\r\n      \r\n      // Entry and exit times for each axis\r\n      let tEnter = -Infinity;\r\n      let tExit = Infinity;\r\n      \r\n      // Check each axis (x, y, z)\r\n      for (const axis of ['x', 'y', 'z']) {\r\n        if (relVelocity[axis] === 0) {\r\n          // Parallel movement, check if there's overlap\r\n          if (e1.aabb.max[axis] < e2.aabb.min[axis] || e1.aabb.min[axis] > e2.aabb.max[axis]) {\r\n            return null; // No collision possible on this axis\r\n          }\r\n        } else {\r\n          // Calculate entry and exit times for this axis\r\n          const v = relVelocity[axis];\r\n          const invV = 1 / v;\r\n          \r\n          let t1, t2;\r\n          if (v < 0) {\r\n            t1 = (e2.aabb.max[axis] - e1.aabb.min[axis]) * invV;\r\n            t2 = (e2.aabb.min[axis] - e1.aabb.max[axis]) * invV;\r\n          } else {\r\n            t1 = (e2.aabb.min[axis] - e1.aabb.max[axis]) * invV;\r\n            t2 = (e2.aabb.max[axis] - e1.aabb.min[axis]) * invV;\r\n          }\r\n          \r\n          // Update enter/exit times\r\n          tEnter = Math.max(tEnter, t1);\r\n          tExit = Math.min(tExit, t2);\r\n          \r\n          if (tEnter > tExit || tExit < 0 || tEnter > deltaTime) {\r\n            return null; // No collision in this time step\r\n          }\r\n        }\r\n      }\r\n      \r\n      // If we got here, there's a collision within the time step\r\n      if (tEnter >= 0 && tEnter <= deltaTime) {\r\n        // Calculate collision normal based on entry axis\r\n        const normal = { x: 0, y: 0, z: 0 };\r\n        let minTime = Infinity;\r\n        let collisionAxis = 'x';\r\n        \r\n        for (const axis of ['x', 'y', 'z']) {\r\n          if (relVelocity[axis] !== 0) {\r\n            const t = relVelocity[axis] < 0 ? \r\n              (e2.aabb.max[axis] - e1.aabb.min[axis]) / relVelocity[axis] : \r\n              (e2.aabb.min[axis] - e1.aabb.max[axis]) / relVelocity[axis];\r\n            \r\n            if (t <= tEnter && t < minTime) {\r\n              minTime = t;\r\n              collisionAxis = axis;\r\n            }\r\n          }\r\n        }\r\n        \r\n        normal[collisionAxis] = relVelocity[collisionAxis] < 0 ? -1 : 1;\r\n        \r\n        // Calculate penetration\r\n        const penetration = tExit - tEnter;\r\n        \r\n        // Calculate impulse\r\n        const velAlongNormal = \r\n          relVelocity.x * normal.x + \r\n          relVelocity.y * normal.y + \r\n          relVelocity.z * normal.z;\r\n          \r\n        const restitution = Math.min(e1.collider.restitution, e2.collider.restitution);\r\n        const impulseScalar = -(1 + restitution) * velAlongNormal / (1 / e1.collider.mass + 1 / e2.collider.mass);\r\n        \r\n        return {\r\n          normal,\r\n          penetration,\r\n          impulse: {\r\n            x: impulseScalar * normal.x,\r\n            y: impulseScalar * normal.y,\r\n            z: impulseScalar * normal.z\r\n          },\r\n          timeOfImpact: tEnter\r\n        };\r\n      }\r\n      \r\n      return null;\r\n    }\r\n  \r\n    /**\r\n     * Apply collision responses to entity pairs\r\n     * @private\r\n     */\r\n    resolveEntityCollisions(collisionPairs) {\r\n      // Apply impulses for entity-entity collisions\r\n      collisionPairs.forEach(({ e1, e2, impulse }) => {        \r\n        // Set collision flags\r\n        e1.collidedWithEntity = true;\r\n        e2.collidedWithEntity = true;\r\n        e1.collidedWith = e2.id;\r\n        e2.collidedWith = e1.id;\r\n\r\n        if (e1.collider.mass > 0) {\r\n          e1.velocity.x += impulse.x / e1.collider.mass;\r\n          e1.velocity.y += impulse.y / e1.collider.mass;\r\n          e1.velocity.z += impulse.z / e1.collider.mass;\r\n        }\r\n        \r\n        if (e2.collider.mass > 0) {\r\n          e2.velocity.x -= impulse.x / e2.collider.mass;\r\n          e2.velocity.y -= impulse.y / e2.collider.mass;\r\n          e2.velocity.z -= impulse.z / e2.collider.mass;\r\n        }\r\n      });\r\n  \r\n      // Resolve penetrations (move entities apart)\r\n      collisionPairs.forEach(({ e1, e2, normal, penetration }) => {\r\n        const totalMass = e1.collider.mass + e2.collider.mass;\r\n        if (totalMass === 0) return;\r\n        \r\n        const move1 = e1.collider.mass > 0 ? penetration * (e2.collider.mass / totalMass) : 0;\r\n        const move2 = e2.collider.mass > 0 ? penetration * (e1.collider.mass / totalMass) : 0;\r\n        \r\n        if (e1.collider.mass > 0) {\r\n          e1.position.x -= normal.x * move1;\r\n          e1.position.y -= normal.y * move1;\r\n          e1.position.z -= normal.z * move1;\r\n        }\r\n        \r\n        if (e2.collider.mass > 0) {\r\n          e2.position.x += normal.x * move2;\r\n          e2.position.y += normal.y * move2;\r\n          e2.position.z += normal.z * move2;\r\n        }\r\n      });\r\n    }\r\n  \r\n    /**\r\n     * Handle terrain and static collisions for all entities\r\n     * @private\r\n     */\r\n    resolveTerrainAndStaticCollisions(entities, collisionData, deltaTime) {\r\n      entities.forEach(entity => {\r\n        if (!entity.collider) return;\r\n        \r\n        // Handle terrain collision using the terrain generator\r\n       // if (this.getTerrainHeight && this.handleTerrainCollision) {\r\n        //  this.handleTerrainCollision(entity, deltaTime);\r\n       // }\r\n  \r\n        // Handle static object collisions\r\n        const entityCollisions = collisionData.find(c => c.entityId === entity.id);\r\n        if (entityCollisions) {\r\n          entityCollisions.collisions.forEach(aabb => {\r\n            // Use swept collision detection for fast moving entities\r\n            if (this.getEntitySpeed(entity) > this.speedThreshold) {\r\n              this.resolveSweptStaticCollision(entity, aabb, deltaTime);\r\n            } else {\r\n              this.resolveStaticCollision(entity, aabb, deltaTime);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  \r\n    /**\r\n     * Check if two AABBs intersect\r\n     * @private\r\n     */\r\n    aabbIntersects(aabb1, aabb2) {\r\n      return (\r\n        aabb1.min.x <= aabb2.max.x &&\r\n        aabb1.max.x >= aabb2.min.x &&\r\n        aabb1.min.y <= aabb2.max.y &&\r\n        aabb1.max.y >= aabb2.min.y &&\r\n        aabb1.min.z <= aabb2.max.z &&\r\n        aabb1.max.z >= aabb2.min.z\r\n      );\r\n    }\r\n  \r\n    /**\r\n     * Get entity speed (magnitude of velocity)\r\n     * @private\r\n     */\r\n    getEntitySpeed(entity) {\r\n      if (!entity.velocity) return 0;\r\n      return this.vector3Length(entity.velocity);\r\n    }\r\n    \r\n    /**\r\n     * Get maximum entity speed from a list\r\n     * @private\r\n     */\r\n    getMaxEntitySpeed(entities) {\r\n      let maxSpeed = 0;\r\n      entities.forEach(entity => {\r\n        const speed = this.getEntitySpeed(entity);\r\n        if (speed > maxSpeed) maxSpeed = speed;\r\n      });\r\n      return maxSpeed;\r\n    }\r\n\r\n    /**\r\n     * Calculate vector3 length\r\n     * @private\r\n     */\r\n    vector3Length(v){\r\n      return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\r\n    }\r\n    \r\n    /**\r\n     * Handle sphere-sphere collision detection\r\n     * @private\r\n     * @returns {Object|null} Collision data or null if no collision\r\n     */\r\n    sphereSphereCollision(e1, e2, deltaTime) {\r\n      const r1 = e1.collider.size;\r\n      const r2 = e2.collider.size;\r\n      const p1 = { \r\n        x: e1.position.x + e1.collider.offset.x, \r\n        y: e1.position.y + e1.collider.offset.y, \r\n        z: e1.position.z + e1.collider.offset.z \r\n      };\r\n      const p2 = { \r\n        x: e2.position.x + e2.collider.offset.x, \r\n        y: e2.position.y + e2.collider.offset.y, \r\n        z: e2.position.z + e2.collider.offset.z \r\n      };\r\n      \r\n      const dx = p2.x - p1.x;\r\n      const dy = p2.y - p1.y;\r\n      const dz = p2.z - p1.z;\r\n      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n      const minDistance = r1 + r2;\r\n      \r\n      if (distance < minDistance && distance > 0) {\r\n        const normal = { \r\n          x: dx / distance, \r\n          y: dy / distance, \r\n          z: dz / distance \r\n        };\r\n        const penetration = minDistance - distance;\r\n        const relativeVelocity = {\r\n          x: e1.velocity.x - e2.velocity.x,\r\n          y: e1.velocity.y - e2.velocity.y,\r\n          z: e1.velocity.z - e2.velocity.z\r\n        };\r\n        const velocityAlongNormal = \r\n          relativeVelocity.x * normal.x + \r\n          relativeVelocity.y * normal.y + \r\n          relativeVelocity.z * normal.z;\r\n  \r\n        if (velocityAlongNormal > 0) return null; // Moving apart\r\n  \r\n        const restitution = Math.min(e1.collider.restitution, e2.collider.restitution);\r\n        const impulseScalar = -(1 + restitution) * velocityAlongNormal / (1 / e1.collider.mass + 1 / e2.collider.mass);\r\n        \r\n        return {\r\n          normal,\r\n          penetration,\r\n          impulse: {\r\n            x: impulseScalar * normal.x,\r\n            y: impulseScalar * normal.y,\r\n            z: impulseScalar * normal.z\r\n          }\r\n        };\r\n      }\r\n      \r\n      return null;\r\n    }\r\n  \r\n    /**\r\n     * Handle box-box collision detection\r\n     * @private\r\n     * @returns {Object|null} Collision data or null if no collision\r\n     */\r\n    boxBoxCollision(e1, e2, deltaTime) {\r\n      const aabb1 = e1.aabb;\r\n      const aabb2 = e2.aabb;\r\n      \r\n      if (!this.aabbIntersects(aabb1, aabb2)) return null;\r\n  \r\n      const overlaps = [\r\n        { axis: 'x', overlap: Math.min(aabb1.max.x - aabb2.min.x, aabb2.max.x - aabb1.min.x) },\r\n        { axis: 'y', overlap: Math.min(aabb1.max.y - aabb2.min.y, aabb2.max.y - aabb1.min.y) },\r\n        { axis: 'z', overlap: Math.min(aabb1.max.z - aabb2.min.z, aabb2.max.z - aabb1.min.z) }\r\n      ];\r\n      const minOverlap = overlaps.reduce((min, curr) => curr.overlap < min.overlap ? curr : min, overlaps[0]);\r\n  \r\n      const normal = { x: 0, y: 0, z: 0 };\r\n      const sign = aabb1.min[minOverlap.axis] < aabb2.min[minOverlap.axis] ? -1 : 1;\r\n      normal[minOverlap.axis] = sign;\r\n  \r\n      const relativeVelocity = {\r\n        x: e1.velocity.x - e2.velocity.x,\r\n        y: e1.velocity.y - e2.velocity.y,\r\n        z: e1.velocity.z - e2.velocity.z\r\n      };\r\n      const velocityAlongNormal = \r\n        relativeVelocity.x * normal.x + \r\n        relativeVelocity.y * normal.y + \r\n        relativeVelocity.z * normal.z;\r\n  \r\n      if (velocityAlongNormal > 0) return null; // Moving apart\r\n  \r\n      const restitution = Math.min(e1.collider.restitution, e2.collider.restitution);\r\n      const impulseScalar = -(1 + restitution) * velocityAlongNormal / (1 / e1.collider.mass + 1 / e2.collider.mass);\r\n      \r\n      return {\r\n        normal,\r\n        penetration: minOverlap.overlap,\r\n        impulse: {\r\n          x: impulseScalar * normal.x,\r\n          y: impulseScalar * normal.y,\r\n          z: impulseScalar * normal.z\r\n        }\r\n      };\r\n    }\r\n  }",
        "filePath": "/global/libraries/js/PhysicsEngine.js"
      },
      "GE_UIManager": {
        "title": "GE_UIManager",
        "fileName": "GE_UIManager",
        "script": "class GE_UIManager {\r\n    constructor(gameEditor, graphicsEditor) {\r\n        this.gameEditor = gameEditor;\r\n        this.graphicsEditor = graphicsEditor;\r\n        this.mouse = new window.THREE.Vector2();\r\n        this.raycaster = new window.THREE.Raycaster();\r\n        this.isDragging = false;\r\n        this.clickStartTime = 0;\r\n    }    \r\n     \r\n\r\n    init() {   \r\n        this.initEventListeners();\r\n    }\r\n    \r\n    \r\n    \r\n    initEventListeners() {\r\n        // Button event listeners\r\n        const buttonMappings = {\r\n            'generate-isometric': this.showIsometricModal.bind(this),\r\n        };\r\n        Object.entries(buttonMappings).forEach(([id, handler]) => {\r\n            const button = document.getElementById(id);\r\n            if (button) button.addEventListener('click', handler);\r\n        });\r\n\r\n        // Canvas interaction\r\n        this.graphicsEditor.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\r\n        this.graphicsEditor.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\r\n        this.graphicsEditor.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\r\n\r\n        // Additional event listeners\r\n\r\n        \r\n        // Move modal listeners\r\n\r\n        // Isometric modal listeners\r\n        document.getElementById('iso-cancel').addEventListener('click', () => {\r\n            document.getElementById('modal-generateIsoSprites').classList.remove('show');\r\n        });\r\n    }\r\n    handleMouseDown(event) {\r\n        this.isDragging = false;\r\n        this.clickStartTime = Date.now();\r\n    }\r\n\r\n    handleMouseMove() {\r\n        if (Date.now() - this.clickStartTime > 100) {\r\n            this.isDragging = true;\r\n        }\r\n    }\r\n\r\n    handleMouseUp(event) {\r\n        if (this.isDragging) return;\r\n    \r\n        const rect = this.graphicsEditor.canvas.getBoundingClientRect();\r\n        this.mouse.x = ((event.clientX - rect.left) / this.graphicsEditor.canvas.clientWidth) * 2 - 1;\r\n        this.mouse.y = -((event.clientY - rect.top) / this.graphicsEditor.canvas.clientHeight) * 2 + 1;\r\n    \r\n        this.raycaster.setFromCamera(this.mouse, this.graphicsEditor.sceneRenderer.camera);\r\n    \r\n        // Instead of looking only at scene.children, search through all descendant meshes\r\n        const meshes = [];\r\n        this.graphicsEditor.rootGroup.traverse(obj => {\r\n            if (obj.isMesh && obj.userData.isShape) {\r\n                meshes.push(obj);\r\n            }\r\n        });\r\n    \r\n        const intersects = this.raycaster.intersectObjects(meshes, true);\r\n    \r\n        if (intersects.length > 0) {\r\n            // Find the parent mesh with the isShape flag if we've hit a child mesh\r\n            let hitObject = intersects[0].object;\r\n            while (hitObject && !hitObject.userData.isShape) {\r\n                hitObject = hitObject.parent;\r\n            }\r\n            \r\n            if (hitObject && hitObject.userData.index !== undefined) {\r\n                this.graphicsEditor.selectShape(hitObject.userData.index);\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    showIsometricModal() {\r\n        document.getElementById('modal-generateIsoSprites').classList.add('show');\r\n    }\r\n    displayIsometricSprites(sprites) {\r\n        const modal = document.createElement('div');\r\n        modal.style.cssText = `\r\n            position: fixed; top: 0; left: 0; width: 100%; height: 100%; \r\n            background-color: rgba(0, 0, 0, 0.7); z-index: 1000; \r\n            display: flex; align-items: center; justify-content: center;\r\n        `;\r\n        const content = document.createElement('div');\r\n        content.style.cssText = `\r\n            background: #333; padding: 20px; border-radius: 8px; \r\n            max-width: 80%; max-height: 80%; overflow: auto;\r\n        `;\r\n    \r\n        const angleLabels = ['NE', 'N', 'NW', 'W', 'SW', 'S', 'SE', 'E']; // Labels for 8 angles\r\n    \r\n        for (const animType in sprites) {\r\n            const animSection = document.createElement('div');\r\n            const title = document.createElement('h3');\r\n            title.textContent = `${animType} Animation`;\r\n            title.style.color = '#e0e0e0';\r\n            animSection.appendChild(title);\r\n    \r\n            // Create a container for all angles\r\n            const anglesContainer = document.createElement('div');\r\n            anglesContainer.style.cssText = `margin: 10px 0;`;\r\n    \r\n            // For each angle (0-7)\r\n            for (let angle = 0; angle < 8; angle++) {\r\n                const angleSection = document.createElement('div');\r\n    \r\n                const grid = document.createElement('div');\r\n                grid.style.cssText = `\r\n                    display: grid; \r\n                    grid-template-columns: repeat(${Math.min(sprites[animType].length, 4)}, 1fr); \r\n                    gap: 5px; \r\n                    margin-bottom: 15px;\r\n                `;\r\n    \r\n                // Add all frames for this specific angle\r\n                sprites[animType].forEach(frame => {\r\n                    const img = document.createElement('img');\r\n                    img.src = frame[angle]; // Get the specific angle's sprite\r\n                    img.style.maxWidth = '100%';\r\n                    grid.appendChild(img);\r\n                });\r\n    \r\n                angleSection.appendChild(grid);\r\n                anglesContainer.appendChild(angleSection);\r\n            }\r\n    \r\n            animSection.appendChild(anglesContainer);\r\n            content.appendChild(animSection);\r\n        }\r\n    \r\n        const closeButton = document.createElement('button');\r\n        closeButton.textContent = 'Close';\r\n        closeButton.style.cssText = `\r\n            margin-top: 20px; padding: 8px 16px; background-color: #4CAF50; \r\n            color: #fff; border: none; border-radius: 6px; cursor: pointer;\r\n        `;\r\n        closeButton.addEventListener('click', () => document.body.removeChild(modal));\r\n        content.appendChild(closeButton);\r\n        modal.appendChild(content);\r\n        document.body.appendChild(modal);\r\n    }\r\n    \r\n    createGroupInspector(group) {\r\n        console.log('create group inspector', group);\r\n        const inspector = document.getElementById('inspector');\r\n        inspector.innerHTML = \"\";\r\n        inspector.className = 'inspector editor-module__scroll-y';\r\n\r\n        \r\n        this.addFormRow(inspector, 'X Scale', 'number', 'scaleX', group.scale?.x || 1, { min: 0.1, step: 0.1 });\r\n        this.addFormRow(inspector, 'Y Scale', 'number', 'scaleY', group.scale?.y || 1, { min: 0.1, step: 0.1 });\r\n        this.addFormRow(inspector, 'Z Scale', 'number', 'scaleZ', group.scale?.z || 1, { min: 0.1, step: 0.1 });\r\n        // Position inputs\r\n        this.addFormRow(inspector, 'X Position', 'number', 'x', group.position?.x || 0, { step: 0.1 });\r\n        this.addFormRow(inspector, 'Y Position', 'number', 'y', group.position?.y || 0, { step: 0.1 });\r\n        this.addFormRow(inspector, 'Z Position', 'number', 'z', group.position?.z || 0, { step: 0.1 });\r\n        \r\n        // Rotation inputs\r\n        this.addFormRow(inspector, 'X Rotation', 'number', 'rotationX', group.rotation?.x || 0, { step: 1 });\r\n        this.addFormRow(inspector, 'Y Rotation', 'number', 'rotationY', group.rotation?.y || 0, { step: 1 });\r\n        this.addFormRow(inspector, 'Z Rotation', 'number', 'rotationZ', group.rotation?.z || 0, { step: 1 });\r\n        \r\n    }\r\n\r\n    createInspector(shape) {\r\n        const inspector = document.getElementById('inspector');\r\n        inspector.innerHTML = \"\";\r\n        inspector.className = 'inspector editor-module__scroll-y';\r\n\r\n        this.addFormRow(inspector, 'Name', 'text', 'name', shape.name || \"\");\r\n        \r\n        // Type selector\r\n        this.addFormRow(inspector, 'Type', 'select', 'type', shape.type, {\r\n            options: ['cube', 'sphere', 'box', 'cylinder', 'cone', 'torus', 'tetrahedron', 'gltf'],\r\n            change: (e) => {\r\n                let currentShape = this.graphicsEditor.getFrameShape();\r\n                let newValue = e.target.value;\r\n                if (newValue != 'gltf') {\r\n                    delete currentShape.url\r\n                }                 \r\n                currentShape.type = newValue;\r\n                this.graphicsEditor.refreshShapes(false);\r\n            }\r\n        });\r\n        \r\n        if (shape.type === 'gltf') {            \r\n            let input = this.addFormRow(inspector, 'Model', 'file', 'url', shape.url, { 'change' :  async (e) => {\r\n                e.preventDefault();\r\n\r\n                // Get the file from the input element\r\n                const file = e.target.files[0]; // Access the file object\r\n                if (!file) {\r\n                    console.error('No file selected');\r\n                    return;\r\n                }\r\n                // // Create FormData and append the file\r\n                 const formData = new FormData();\r\n                 formData.append('gltfFile', file); // 'gltfFile' matches the multer.single('gltfFile') on the server\r\n                 formData.append('projectName', this.gameEditor.getCurrentProject());\r\n                try {\r\n                     const response = await fetch('/upload-model', {\r\n                         method: 'POST',\r\n                         body: formData // Send the FormData with the file\r\n                     });\r\n\r\n                     const result = await response.json();\r\n                     // Strip project resources path - only keep path from models directory onwards\r\n                     let shapePath = result.filePath;\r\n                     const resourcesIndex = shapePath.indexOf('resources/');\r\n                     if (resourcesIndex !== -1) {\r\n                         shapePath = shapePath.substring(resourcesIndex + 'resources/'.length);\r\n                     }\r\n                     this.graphicsEditor.getFrameShape().url = shapePath;\r\n                     this.graphicsEditor.refreshShapes(false);\r\n                } catch (error) {\r\n                     console.error('Error uploading file:', error);\r\n                }\r\n            }});\r\n            input.setAttribute(\"accept\",\".gltf,.glb\");\r\n        }\r\n        // Color picker\r\n        this.addFormRow(inspector, 'Color', 'color', 'color', shape.color);\r\n        this.addFormRow(inspector, 'Texture', 'texture', 'texture', shape.texture);\r\n        this.addFormRow(inspector, 'Metalness', 'metalness', 'metalness', shape.metalness || 0.5);\r\n        this.addFormRow(inspector, 'Roughness', 'roughness', 'roughness', shape.roughness || 0.5);\r\n        \r\n        this.addFormRow(inspector, 'X Scale', 'number', 'scaleX', shape.scaleX || 1, { min: 0.1, step: 0.1 });\r\n        this.addFormRow(inspector, 'Y Scale', 'number', 'scaleY', shape.scaleY || 1, { min: 0.1, step: 0.1 });\r\n        this.addFormRow(inspector, 'Z Scale', 'number', 'scaleZ', shape.scaleZ || 1, { min: 0.1, step: 0.1 });\r\n        // Position inputs\r\n        this.addFormRow(inspector, 'X Position', 'number', 'x', shape.x || 0, { step: 0.1 });\r\n        this.addFormRow(inspector, 'Y Position', 'number', 'y', shape.y || 0, { step: 0.1 });\r\n        this.addFormRow(inspector, 'Z Position', 'number', 'z', shape.z || 0, { step: 0.1 });\r\n        \r\n        // Rotation inputs\r\n        this.addFormRow(inspector, 'X Rotation', 'number', 'rotationX', shape.rotationX || 0, { step: 1 });\r\n        this.addFormRow(inspector, 'Y Rotation', 'number', 'rotationY', shape.rotationY || 0, { step: 1 });\r\n        this.addFormRow(inspector, 'Z Rotation', 'number', 'rotationZ', shape.rotationZ || 0, { step: 1 });\r\n        \r\n        // Size inputs\r\n        if (['cube', 'sphere', 'tetrahedron', 'torus'].includes(shape.type)) {\r\n            this.addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });\r\n        }\r\n        \r\n        if (shape.type === 'box') {\r\n            this.addFormRow(inspector, 'Width', 'number', 'width', shape.width || 2, { min: 0.1, step: 0.1 });\r\n            this.addFormRow(inspector, 'Height', 'number', 'height', shape.height || 2, { min: 0.1, step: 0.1 });\r\n            this.addFormRow(inspector, 'Depth', 'number', 'depth', shape.depth || 2, { min: 0.1, step: 0.1 });\r\n        }\r\n        \r\n        if (['cylinder', 'cone'].includes(shape.type)) {\r\n            this.addFormRow(inspector, 'Size', 'number', 'size', shape.size || 2, { min: 0.1, step: 0.1 });\r\n            this.addFormRow(inspector, 'Height', 'number', 'height', shape.height || 3, { min: 0.1, step: 0.1 });\r\n        }\r\n        \r\n        if (shape.type === 'torus') {\r\n            this.addFormRow(inspector, 'Tube Size', 'number', 'tubeSize', shape.tubeSize || shape.size / 6, { min: 0.1, step: 0.1 });\r\n        }\r\n    }\r\n\r\n\r\n    addFormRow(container, label, type, property, value, options = {}) {\r\n        const row = document.createElement('div');\r\n        row.className = 'form-row';\r\n        \r\n        const labelElement = document.createElement('label');\r\n        labelElement.textContent = label;\r\n        row.appendChild(labelElement);\r\n        \r\n        let input;\r\n        \r\n        if (type === 'select') {\r\n            input = document.createElement('select');\r\n            input.setAttribute('data-property', property);\r\n            (options.options || []).forEach(optionValue => {\r\n                const option = document.createElement('option');\r\n                option.value = optionValue;\r\n                option.textContent = optionValue;\r\n                if (value === optionValue) {\r\n                    option.selected = true;\r\n                }\r\n                input.appendChild(option);\r\n            });\r\n        } else if(type === \"color\") {\r\n            input = this.gameEditor.createColorInputGroup(value, 'data-property', property, row, (val, colorName) => {\r\n                if(colorName){\r\n                    this.graphicsEditor.getFrameShape()[property] = { paletteColor: colorName };\r\n                } else {\r\n                    this.graphicsEditor.getFrameShape()[property] = val;\r\n                }\r\n                this.graphicsEditor.refreshShapes(false);\r\n            });            \r\n        } else if(type === \"texture\") {\r\n            input = this.gameEditor.createTextureInputGroup(value, 'data-property', property, row, (val) => {\r\n                if(val){\r\n                    this.graphicsEditor.getFrameShape()[property] = val;\r\n                }\r\n                this.graphicsEditor.refreshShapes(false);\r\n            });            \r\n        } else if(type === \"file\") {\r\n            let inputContainer = document.createElement('div');\r\n            inputContainer.style = \"flex: 1; display: flex; flex-direction: column; font-size: .75em;\";\r\n            input = document.createElement('input');\r\n            input.style = \"width: calc(100% - 18px);\"\r\n            input.type = type;\r\n            input.setAttribute('data-property', property);\r\n            inputContainer.appendChild(input);\r\n            if( value ) {\r\n                let urlName = document.createElement('span');\r\n                urlName.innerText = value;            \r\n                inputContainer.appendChild(urlName);\r\n            }\r\n            row.appendChild(inputContainer);\r\n            container.appendChild(row);\r\n            input.addEventListener('change', options.change );\r\n            return input;\r\n        } else {\r\n            input = document.createElement('input');\r\n            input.type = type;\r\n            input.value = value;\r\n            input.setAttribute('data-property', property);\r\n            \r\n            if (type === 'number') {\r\n                if(options.min != undefined) input.min = options.min;\r\n                if(options.max != undefined) input.max = options.max;\r\n                input.step = options.step || 1;\r\n            }\r\n        }\r\n        \r\n        input.addEventListener('change', options.change || ((e) => {\r\n            let newValue = e.target.value;\r\n            if (type === 'number') {\r\n                newValue = parseFloat(newValue);\r\n                // If we're editing a transform property, also update the transform target\r\n                if (this.graphicsEditor.shapeManager.currentTransformTarget && ['x', 'y', 'z', 'rotationX', 'rotationY', 'rotationZ', 'scaleX', 'scaleY', 'scaleZ'].includes(property)) {\r\n                    if (property === 'x') this.graphicsEditor.shapeManager.currentTransformTarget.position.x = newValue;\r\n                    if (property === 'y') this.graphicsEditor.shapeManager.currentTransformTarget.position.y = newValue;\r\n                    if (property === 'z') this.graphicsEditor.shapeManager.currentTransformTarget.position.z = newValue;\r\n                    \r\n                    if (property === 'rotationX') this.graphicsEditor.shapeManager.currentTransformTarget.rotation.x = newValue;\r\n                    if (property === 'rotationY') this.graphicsEditor.shapeManager.currentTransformTarget.rotation.y = newValue;\r\n                    if (property === 'rotationZ') this.graphicsEditor.shapeManager.currentTransformTarget.rotation.z = newValue;\r\n                    \r\n                    if (property === 'scaleX') this.graphicsEditor.shapeManager.currentTransformTarget.scale.x = newValue;\r\n                    if (property === 'scaleY') this.graphicsEditor.shapeManager.currentTransformTarget.scale.y = newValue;\r\n                    if (property === 'scaleZ') this.graphicsEditor.shapeManager.currentTransformTarget.scale.z = newValue;\r\n                    \r\n                    // Update gizmo position after directly changing values\r\n                }\r\n            } else if(type === 'file') {\r\n                return;\r\n            }\r\n            \r\n            this.updatePropertyValue(property, newValue);\r\n            this.graphicsEditor.refreshShapes(false);\r\n        }));\r\n        \r\n        row.appendChild(input);\r\n        container.appendChild(row);\r\n        return input;\r\n    }\r\n\r\n    readTransformData(objData, property, value){\r\n        // Handle transform properties\r\n        if (property.startsWith('scale')) {\r\n            if(!objData.scale) objData.scale = {};\r\n            const axis = property.charAt(property.length - 1).toLowerCase();\r\n            if(Number(value) != 1){\r\n                objData.scale[axis] = value;\r\n            } else {\r\n                delete objData.scale[axis];\r\n                if(Object.keys(objData.scale).length == 0) delete objData.scale;\r\n            }\r\n        } else if (property.startsWith('rotation')) {\r\n            if(!objData.rotation) objData.rotation = {};\r\n            const axis = property.charAt(property.length - 1).toLowerCase();\r\n            if(Number(value) != 0){\r\n                objData.rotation[axis] = value;\r\n            } else {\r\n                delete objData.rotation[axis];\r\n                if(Object.keys(objData.rotation).length == 0) delete objData.rotation;\r\n            }            \r\n        } else if (['x', 'y', 'z'].includes(property)) {\r\n            if(!objData.position) objData.position = {};\r\n            const axis = property;\r\n            if(Number(value) != 0){\r\n                objData.position[axis] = value;\r\n            } else {\r\n                delete objData.position[axis];\r\n                if(Object.keys(objData.position).length == 0) delete objData.position;\r\n            }\r\n        }\r\n        delete objData[property];\r\n    }\r\n\r\n    updatePropertyValue(property, value) {\r\n        const shapeData = this.graphicsEditor.getFrameShape();\r\n        if (shapeData) {\r\n            // Handle transform properties            \r\n            this.readTransformData(shapeData, property, value);\r\n        } else {\r\n            let groupData = this.graphicsEditor.getCurrentGroup();\r\n            if(!groupData){\r\n                groupData = {};\r\n                let currentFrame = this.graphicsEditor.getCurrentFrame();\r\n                if(currentFrame) {\r\n                    currentFrame[this.graphicsEditor.state.currentGroup] = groupData;\r\n                }\r\n            }                    \r\n            this.readTransformData(groupData, property, value);\r\n        }\r\n    }\r\n\r\n    updateList() {\r\n        const frameList = document.getElementById('frame-list');\r\n        frameList.innerHTML = '';\r\n        const groupList = document.getElementById('group-list');\r\n        groupList.innerHTML = '';\r\n        const shapeList = document.getElementById('shape-list');\r\n        shapeList.innerHTML = '';\r\n        this.updateFrameList();\r\n        this.graphicsEditor.groupManager.updateGroupList();\r\n        this.updateShapeList();\r\n    }\r\n\r\n    updateFrameList() {\r\n        const list = document.getElementById('frame-list');\r\n        // Animation selector\r\n        const animSelector = document.createElement('select');\r\n        animSelector.style.marginBottom = '10px';\r\n\r\n        const option = document.createElement('option');\r\n        option.value = '__model__';\r\n        option.textContent = 'model';\r\n        if (this.graphicsEditor.state.editingModel) option.selected = true;\r\n        animSelector.appendChild(option);\r\n\r\n\r\n        Object.keys(this.graphicsEditor.state.renderData.animations).forEach(anim => {\r\n            const option = document.createElement('option');\r\n            option.value = anim;\r\n            option.textContent = anim;\r\n            if (anim === this.graphicsEditor.state.currentAnimation) option.selected = true;\r\n            animSelector.appendChild(option);\r\n        });\r\n        animSelector.addEventListener('change', (e) => {\r\n            this.graphicsEditor.setPreviewAnimationState(false);\r\n            if(e.target.value == '__model__'){\r\n                this.graphicsEditor.state.editingModel = true;\r\n                this.graphicsEditor.state.currentAnimation = \"\";                \r\n            } else {\r\n                this.graphicsEditor.state.editingModel = false;\r\n                this.graphicsEditor.state.currentAnimation = animSelector.value;                \r\n            }\r\n            this.graphicsEditor.state.currentFrame = 0;\r\n            this.graphicsEditor.refreshShapes(false);\r\n            requestAnimationFrame(() => {\r\n                this.graphicsEditor.state.selectedShapeIndex = -1;\r\n                this.graphicsEditor.shapeManager.selectShape(0);\r\n            })\r\n        });\r\n        list.appendChild(animSelector);\r\n        if(this.graphicsEditor.state.editingModel) return;\r\n        // Frame list\r\n        const frameList = document.createElement('div');\r\n        frameList.style.marginBottom = '10px';\r\n        this.graphicsEditor.getCurrentAnimation().forEach((frame, index) => {\r\n            const frameItem = document.createElement('div');\r\n            frameItem.textContent = `Frame ${index + 1}`;\r\n            frameItem.style.padding = '5px';\r\n            frameItem.style.cursor = 'pointer';\r\n            if (index === this.graphicsEditor.state.currentFrame) frameItem.style.backgroundColor = '#555';\r\n            frameItem.addEventListener('click', () => {\r\n                this.graphicsEditor.setPreviewAnimationState(false);\r\n                this.graphicsEditor.state.currentFrame = index;  \r\n                this.graphicsEditor.refreshShapes(false);\r\n                requestAnimationFrame(() => {  \r\n                    this.graphicsEditor.state.selectedShapeIndex = -1;\r\n                    this.graphicsEditor.shapeManager.selectShape(0);\r\n                })\r\n            });\r\n            frameList.appendChild(frameItem);\r\n        });\r\n        list.appendChild(frameList);\r\n    }\r\n\r\n\r\n    updateShapeList() {\r\n        const list = document.getElementById('shape-list');\r\n        if (!list) return;\r\n        \r\n\r\n        // Get shapes from the currently selected group\r\n        const currentGroup = this.graphicsEditor.state.currentGroup;\r\n        const selectedGroup = this.graphicsEditor.getMergedGroup(currentGroup);\r\n        const shapes = selectedGroup && selectedGroup.shapes ? selectedGroup.shapes : selectedGroup || [];\r\n       \r\n        // Create shape list items\r\n        for (let i = 0; i < shapes.length; i++) {\r\n            const shape = shapes[i];\r\n            if (!shape) continue;\r\n           \r\n            const shapeItem = document.createElement('div');\r\n            shapeItem.classList.add('shape-item');\r\n           \r\n            // Mark as selected if this shape is the selected one and we're in the right group\r\n            if (i === this.graphicsEditor.state.selectedShapeIndex) {\r\n                shapeItem.classList.add('selected');\r\n            }\r\n           \r\n            shapeItem.textContent = `${shape.name} - ${shape.type || 'Shape'}`;\r\n            shapeItem.addEventListener('click', (e) => {               \r\n                this.graphicsEditor.shapeManager.selectShape(parseInt(e.target.dataset.index));\r\n            });\r\n           \r\n            // Make the shape draggable\r\n            shapeItem.draggable = true;\r\n            shapeItem.dataset.index = i;\r\n            shapeItem.dataset.group = currentGroup;\r\n            \r\n            // Add dragstart event to set the drag data\r\n            shapeItem.addEventListener('dragstart', (e) => {\r\n                // Store only the selected shape's index and source group\r\n                const data = {\r\n                    shapeIndex: i,\r\n                    sourceGroup: currentGroup\r\n                };\r\n                \r\n                // Set the drag data\r\n                e.dataTransfer.setData('text/plain', JSON.stringify(data));\r\n                \r\n                // Add a visual indicator\r\n                shapeItem.classList.add('dragging');\r\n                \r\n                // Set drag effect\r\n                e.dataTransfer.effectAllowed = 'move';\r\n            });\r\n            \r\n            // Add dragend event to clean up\r\n            shapeItem.addEventListener('dragend', () => {\r\n                shapeItem.classList.remove('dragging');\r\n            });\r\n           \r\n            list.appendChild(shapeItem);\r\n        }\r\n        \r\n        // Set up the shape list container as a drop target\r\n        list.addEventListener('dragover', (e) => {\r\n            // Only respond if we're dragging over the shape list itself, not an individual shape\r\n            if (e.target === list) {\r\n                e.preventDefault();\r\n                e.dataTransfer.dropEffect = 'move';\r\n                list.classList.add('drag-over');\r\n            }\r\n        });\r\n        \r\n        list.addEventListener('dragleave', (e) => {\r\n            // Only respond if we're leaving the shape list\r\n            if (e.target === list) {\r\n                list.classList.remove('drag-over');\r\n            }\r\n        });\r\n        \r\n        list.addEventListener('drop', (e) => {\r\n            e.preventDefault();\r\n            list.classList.remove('drag-over');\r\n            \r\n            const data = e.dataTransfer.getData('text/plain');\r\n            if (!data) return;\r\n            \r\n            try {\r\n                const dragData = JSON.parse(data);\r\n                const { shapeIndex, sourceGroup } = dragData;\r\n                \r\n                // Only process if this is a different group\r\n                if (sourceGroup && sourceGroup !== currentGroup) {\r\n                    this.graphicsEditor.groupManager.moveToGroup(\r\n                        parseInt(shapeIndex),\r\n                        sourceGroup,\r\n                        currentGroup\r\n                    );\r\n                }\r\n            } catch (err) {\r\n                console.error('Error processing drop in shape list:', err);\r\n            }\r\n        });\r\n    }\r\n\r\n}",
        "filePath": "/global/libraries/js/GE_UIManager.js"
      },
      "TerrainImageProcessor": {
        "fileName": "TerrainImageProcessor",
        "script": "class TerrainImageProcessor {\r\n  //Utility function to convert terrain tile spritesheets to and from base64 encoding\r\n    constructor(app, options = {}) {\r\n        this.app = app;\r\n        // Configurable tile dimensions with defaults\r\n        this.tileWidth = options.tileWidth || 24;\r\n        this.tileHeight = options.tileHeight || 24;\r\n        this.tilesX = options.tilesX || 4;\r\n        this.tilesY = options.tilesY || 1; // Will be auto-detected\r\n\r\n        // Bind methods to ensure correct context\r\n        this.convertCanvasToBase64Tiles = this.convertCanvasToBase64Tiles.bind(this);\r\n        this.displayStoredBase64Tiles = this.displayStoredBase64Tiles.bind(this);\r\n\r\n        // Element references\r\n        this.output = null;\r\n        this.displayImage = null;\r\n    }\r\n\r\n    // Initialize the processor with DOM elements\r\n    initialize(outputElement, displayImageElement) {\r\n        this.output = outputElement;\r\n        this.displayImage = displayImageElement;\r\n\r\n        // Optional: Add custom event listener\r\n        document.body.addEventListener('editTerrainImage', this.displayStoredBase64Tiles);\r\n    }\r\n\r\n    // Detect if the image is 4x1 or 4x2 based on aspect ratio\r\n    detectSpriteSheetLayout(img) {\r\n        const aspectRatio = img.width / img.height;\r\n        \r\n        // For 4x1 layout: width should be 4x tile width, height should be 1x tile height\r\n        // For 4x2 layout: width should be 4x tile width, height should be 2x tile height\r\n        \r\n        // Calculate expected dimensions\r\n        const expectedWidth4x1 = this.tileWidth * 4;\r\n        const expectedHeight4x1 = this.tileHeight * 1;\r\n        const expectedWidth4x2 = this.tileWidth * 4;\r\n        const expectedHeight4x2 = this.tileHeight * 2;\r\n        \r\n        // Check if dimensions match 4x2 layout\r\n        if (img.width === expectedWidth4x2 && img.height === expectedHeight4x2) {\r\n            return { tilesX: 4, tilesY: 2, layout: '4x2' };\r\n        }\r\n        \r\n        // Check if dimensions match 4x1 layout\r\n        if (img.width === expectedWidth4x1 && img.height === expectedHeight4x1) {\r\n            return { tilesX: 4, tilesY: 1, layout: '4x1' };\r\n        }\r\n        \r\n        // Fallback: determine based on aspect ratio\r\n        // 4x1 should have aspect ratio of 4:1\r\n        // 4x2 should have aspect ratio of 2:1\r\n        if (Math.abs(aspectRatio - 4.0) < Math.abs(aspectRatio - 2.0)) {\r\n            return { tilesX: 4, tilesY: 1, layout: '4x1' };\r\n        } else {\r\n            return { tilesX: 4, tilesY: 2, layout: '4x2' };\r\n        }\r\n    }\r\n\r\n    processImage(imageUrl) {\r\n        const img = new Image();\r\n        img.onload = () => {\r\n            // Detect the sprite sheet layout\r\n            const layout = this.detectSpriteSheetLayout(img);\r\n            console.log(`Detected sprite sheet layout: ${layout.layout}`);\r\n            \r\n            // Update internal properties\r\n            this.tilesX = layout.tilesX;\r\n            this.tilesY = layout.tilesY;\r\n            \r\n            // Create a temporary canvas to process the image\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = img.width;\r\n            canvas.height = img.height;\r\n\r\n            const ctx = canvas.getContext('2d');\r\n            \r\n            // Set transparent background\r\n            ctx.globalCompositeOperation = 'source-over';\r\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n            \r\n            // Draw the uploaded image at original size\r\n            ctx.drawImage(img, 0, 0);\r\n\r\n            // Convert to base64 tiles based on detected layout\r\n            const base64Tiles = this.convertCanvasToBase64Tiles(canvas, layout);\r\n            \r\n            // Save base64 tiles to output\r\n            this.output.value = JSON.stringify(base64Tiles);\r\n\r\n            // Display the original uploaded image\r\n            this.displayImage.src = imageUrl;\r\n        };\r\n        img.src = imageUrl;\r\n    }\r\n\r\n    // Convert canvas to array of base64 tiles with layout detection\r\n    convertCanvasToBase64Tiles(canvas, layout, format = 'png', quality = 1.0) {\r\n        const base64Tiles = [];\r\n\r\n        if (layout.layout === '4x2') {\r\n            // Process 4x2 layout: use both provided rows\r\n            \r\n            // First row (top tiles)\r\n            for (let x = 0; x < 4; x++) {\r\n                const tileCanvas = document.createElement('canvas');\r\n                tileCanvas.width = this.tileWidth;\r\n                tileCanvas.height = this.tileHeight;\r\n                const tileCtx = tileCanvas.getContext('2d');\r\n\r\n                const srcX = x * this.tileWidth;\r\n                const srcY = 0;\r\n\r\n                const imageData = canvas.getContext('2d').getImageData(\r\n                    srcX, srcY, this.tileWidth, this.tileHeight\r\n                );\r\n\r\n                tileCtx.putImageData(imageData, 0, 0);\r\n                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n                const base64String = dataUrl.split(',')[1];\r\n                base64Tiles.push(base64String);\r\n            }\r\n\r\n            // Second row (bottom tiles)\r\n            for (let x = 0; x < 4; x++) {\r\n                const tileCanvas = document.createElement('canvas');\r\n                tileCanvas.width = this.tileWidth;\r\n                tileCanvas.height = this.tileHeight;\r\n                const tileCtx = tileCanvas.getContext('2d');\r\n\r\n                const srcX = x * this.tileWidth;\r\n                const srcY = this.tileHeight; // Second row\r\n\r\n                const imageData = canvas.getContext('2d').getImageData(\r\n                    srcX, srcY, this.tileWidth, this.tileHeight\r\n                );\r\n\r\n                tileCtx.putImageData(imageData, 0, 0);\r\n                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n                const base64String = dataUrl.split(',')[1];\r\n                base64Tiles.push(base64String);\r\n            }\r\n\r\n        } else {\r\n            // Process 4x1 layout: use first row and create flipped versions\r\n            \r\n            // First row of tiles (normal)\r\n            for (let x = 0; x < 4; x++) {\r\n                const tileCanvas = document.createElement('canvas');\r\n                tileCanvas.width = this.tileWidth;\r\n                tileCanvas.height = this.tileHeight;\r\n                const tileCtx = tileCanvas.getContext('2d');\r\n\r\n                const srcX = x * this.tileWidth;\r\n                const srcY = 0;\r\n\r\n                const imageData = canvas.getContext('2d').getImageData(\r\n                    srcX, srcY, this.tileWidth, this.tileHeight\r\n                );\r\n\r\n                tileCtx.putImageData(imageData, 0, 0);\r\n                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n                const base64String = dataUrl.split(',')[1];\r\n                base64Tiles.push(base64String);\r\n            }\r\n\r\n            // Create vertically flipped versions of the first row\r\n            for (let x = 0; x < 4; x++) {\r\n                const tileCanvas = document.createElement('canvas');\r\n                tileCanvas.width = this.tileWidth;\r\n                tileCanvas.height = this.tileHeight;\r\n                const tileCtx = tileCanvas.getContext('2d');\r\n\r\n                const srcX = x * this.tileWidth;\r\n                const srcY = 0;\r\n\r\n                const imageData = canvas.getContext('2d').getImageData(\r\n                    srcX, srcY, this.tileWidth, this.tileHeight\r\n                );\r\n\r\n                // Create flipped image data\r\n                const flippedImageData = this.verticallyFlipImageData(imageData);\r\n\r\n                tileCtx.putImageData(flippedImageData, 0, 0);\r\n                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);\r\n                const base64String = dataUrl.split(',')[1];\r\n                base64Tiles.push(base64String);\r\n            }\r\n        }\r\n\r\n        return base64Tiles;\r\n    }\r\n\r\n    // Helper method to vertically flip ImageData\r\n    verticallyFlipImageData(imageData) {\r\n        const flippedImageData = new ImageData(this.tileWidth, this.tileHeight);\r\n        \r\n        for (let y = 0; y < this.tileHeight; y++) {\r\n            for (let x = 0; x < this.tileWidth; x++) {\r\n                const srcIndex = (y * this.tileWidth + x) * 4;\r\n                const destIndex = ((this.tileHeight - 1 - y) * this.tileWidth + x) * 4;\r\n                \r\n                flippedImageData.data[destIndex] = imageData.data[srcIndex];         // R\r\n                flippedImageData.data[destIndex + 1] = imageData.data[srcIndex + 1]; // G\r\n                flippedImageData.data[destIndex + 2] = imageData.data[srcIndex + 2]; // B\r\n                flippedImageData.data[destIndex + 3] = imageData.data[srcIndex + 3]; // A\r\n            }\r\n        }\r\n        \r\n        return flippedImageData;\r\n    }\r\n\r\n    // Display stored base64 tiles\r\n    displayStoredBase64Tiles() {\r\n        // Check if there are stored base64 tiles\r\n        if (!this.output.value) return;\r\n\r\n        try {\r\n            // Parse the stored base64 tiles\r\n            const base64Tiles = JSON.parse(this.output.value);\r\n\r\n            // Validate the number of tiles\r\n            if (!Array.isArray(base64Tiles) || base64Tiles.length !== 8) {\r\n                console.error('Invalid base64 tiles array - expected 8 tiles, got:', base64Tiles.length);\r\n                return;\r\n            }\r\n\r\n            // Create canvas for display - always show as 4x2 for consistency\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = this.tileWidth * 4;\r\n            canvas.height = this.tileHeight * 2;\r\n            const ctx = canvas.getContext('2d');\r\n\r\n            let loadedImages = 0;\r\n            const tileImages = new Array(8).fill(null);\r\n\r\n            base64Tiles.forEach((base64String, index) => {\r\n                const tileImg = new Image();\r\n                tileImg.onload = () => {\r\n                    tileImages[index] = tileImg;\r\n                    loadedImages++;\r\n\r\n                    // Once all images are loaded, draw them in 4x2 layout\r\n                    if (loadedImages === base64Tiles.length) {\r\n                        // Draw first row of tiles (indices 0-3)\r\n                        for (let x = 0; x < 4; x++) {\r\n                            ctx.drawImage(tileImages[x], x * this.tileWidth, 0);\r\n                        }\r\n\r\n                        // Draw second row of tiles (indices 4-7)\r\n                        for (let x = 0; x < 4; x++) {\r\n                            ctx.drawImage(tileImages[x + 4], x * this.tileWidth, this.tileHeight);\r\n                        }\r\n\r\n                        // Set the final image\r\n                        this.displayImage.src = canvas.toDataURL('image/png');\r\n                    }\r\n                };\r\n\r\n                // Ensure the base64 string has the correct data URL prefix\r\n                let dataUrl = base64String;\r\n                if (!base64String.startsWith('data:image/')) {\r\n                    dataUrl = 'data:image/png;base64,' + base64String;\r\n                }\r\n                tileImg.src = dataUrl;\r\n            });\r\n        } catch (error) {\r\n            console.error('Error parsing stored base64 tiles:', error);\r\n        }\r\n    }\r\n\r\n    // Helper method to get layout info for external use\r\n    getLayoutInfo() {\r\n        return {\r\n            tilesX: this.tilesX,\r\n            tilesY: this.tilesY,\r\n            tileWidth: this.tileWidth,\r\n            tileHeight: this.tileHeight\r\n        };\r\n    }\r\n\r\n    // Method to manually set layout (useful for testing or specific requirements)\r\n    setLayout(tilesX, tilesY) {\r\n        this.tilesX = tilesX;\r\n        this.tilesY = tilesY;\r\n    }\r\n\r\n    // Method to clean up event listeners if needed\r\n    destroy() {\r\n        document.body.removeEventListener('editTerrainImage', this.displayStoredBase64Tiles);\r\n    }\r\n}",
        "filePath": "/global/libraries/js/TerrainImageProcessor.js"
      },
      "three_SkeletonUtils": {
        "title": "THREE SkeletonUtils",
        "isModule": true,
        "windowContext": "THREE_",
        "requireName": "SkeletonUtils",
        "importName": "SkeletonUtils",
        "fileName": "three_SkeletonUtils",
        "filePath": "/global/libraries/js/three_SkeletonUtils.js",
        "script": "import {\r\n\tAnimationClip,\r\n\tAnimationMixer,\r\n\tMatrix4,\r\n\tQuaternion,\r\n\tQuaternionKeyframeTrack,\r\n\tSkeletonHelper,\r\n\tVector3,\r\n\tVectorKeyframeTrack\r\n} from 'three';\r\n\r\n/**\r\n * @module SkeletonUtils\r\n * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';\r\n */\r\n\r\nfunction getBoneName( bone, options ) {\r\n\r\n\tif ( options.getBoneName !== undefined ) {\r\n\r\n\t\treturn options.getBoneName( bone );\r\n\r\n\t}\r\n\r\n\treturn options.names[ bone.name ];\r\n\r\n}\r\n\r\n/**\r\n * Retargets the skeleton from the given source 3D object to the\r\n * target 3D object.\r\n *\r\n * @param {Object3D} target - The target 3D object.\r\n * @param {Object3D} source - The source 3D object.\r\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\r\n */\r\nfunction retarget( target, source, options = {} ) {\r\n\r\n\tconst quat = new Quaternion(),\r\n\t\tscale = new Vector3(),\r\n\t\trelativeMatrix = new Matrix4(),\r\n\t\tglobalMatrix = new Matrix4();\r\n\r\n\toptions.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;\r\n\toptions.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;\r\n\toptions.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\r\n\toptions.hip = options.hip !== undefined ? options.hip : 'hip';\r\n\toptions.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );\r\n\toptions.scale = options.scale !== undefined ? options.scale : 1;\r\n\toptions.names = options.names || {};\r\n\r\n\tconst sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),\r\n\t\tbones = target.isObject3D ? target.skeleton.bones : getBones( target );\r\n\r\n\tlet bone, name, boneTo,\r\n\t\tbonesPosition;\r\n\r\n\t// reset bones\r\n\r\n\tif ( target.isObject3D ) {\r\n\r\n\t\ttarget.skeleton.pose();\r\n\r\n\t} else {\r\n\r\n\t\toptions.useTargetMatrix = true;\r\n\t\toptions.preserveBoneMatrix = false;\r\n\r\n\t}\r\n\r\n\tif ( options.preserveBonePositions ) {\r\n\r\n\t\tbonesPosition = [];\r\n\r\n\t\tfor ( let i = 0; i < bones.length; i ++ ) {\r\n\r\n\t\t\tbonesPosition.push( bones[ i ].position.clone() );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( options.preserveBoneMatrix ) {\r\n\r\n\t\t// reset matrix\r\n\r\n\t\ttarget.updateMatrixWorld();\r\n\r\n\t\ttarget.matrixWorld.identity();\r\n\r\n\t\t// reset children matrix\r\n\r\n\t\tfor ( let i = 0; i < target.children.length; ++ i ) {\r\n\r\n\t\t\ttarget.children[ i ].updateMatrixWorld( true );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\tbone = bones[ i ];\r\n\t\tname = getBoneName( bone, options );\r\n\r\n\t\tboneTo = getBoneByName( name, sourceBones );\r\n\r\n\t\tglobalMatrix.copy( bone.matrixWorld );\r\n\r\n\t\tif ( boneTo ) {\r\n\r\n\t\t\tboneTo.updateMatrixWorld();\r\n\r\n\t\t\tif ( options.useTargetMatrix ) {\r\n\r\n\t\t\t\trelativeMatrix.copy( boneTo.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trelativeMatrix.copy( target.matrixWorld ).invert();\r\n\t\t\t\trelativeMatrix.multiply( boneTo.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// ignore scale to extract rotation\r\n\r\n\t\t\tscale.setFromMatrixScale( relativeMatrix );\r\n\t\t\trelativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );\r\n\r\n\t\t\t// apply to global matrix\r\n\r\n\t\t\tglobalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );\r\n\r\n\t\t\tif ( target.isObject3D ) {\r\n\r\n\t\t\t\tif ( options.localOffsets ) {\r\n\r\n\t\t\t\t\tif ( options.localOffsets[ bone.name ] ) {\r\n\r\n\t\t\t\t\t\tglobalMatrix.multiply( options.localOffsets[ bone.name ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tglobalMatrix.copyPosition( relativeMatrix );\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === options.hip ) {\r\n\r\n\t\t\tglobalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;\r\n\t\t\tglobalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;\r\n\t\t\tglobalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;\r\n\r\n\t\t\tif ( options.hipPosition !== undefined ) {\r\n\r\n\t\t\t\tglobalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;\r\n\t\t\t\tglobalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;\r\n\t\t\t\tglobalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( bone.parent ) {\r\n\r\n\t\t\tbone.matrix.copy( bone.parent.matrixWorld ).invert();\r\n\t\t\tbone.matrix.multiply( globalMatrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tbone.matrix.copy( globalMatrix );\r\n\r\n\t\t}\r\n\r\n\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\tbone.updateMatrixWorld();\r\n\r\n\t}\r\n\r\n\tif ( options.preserveBonePositions ) {\r\n\r\n\t\tfor ( let i = 0; i < bones.length; ++ i ) {\r\n\r\n\t\t\tbone = bones[ i ];\r\n\t\t\tname = getBoneName( bone, options ) || bone.name;\r\n\r\n\t\t\tif ( name !== options.hip ) {\r\n\r\n\t\t\t\tbone.position.copy( bonesPosition[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( options.preserveBoneMatrix ) {\r\n\r\n\t\t// restore matrix\r\n\r\n\t\ttarget.updateMatrixWorld( true );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Retargets the animation clip of the source object to the\r\n * target 3D object.\r\n *\r\n * @param {Object3D} target - The target 3D object.\r\n * @param {Object3D} source - The source 3D object.\r\n * @param {AnimationClip} clip - The animation clip.\r\n * @param {module:SkeletonUtils~RetargetOptions} options - The options.\r\n * @return {AnimationClip} The retargeted animation clip.\r\n */\r\nfunction retargetClip( target, source, clip, options = {} ) {\r\n\r\n\toptions.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\r\n\r\n\t// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.\r\n\toptions.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );\r\n\toptions.names = options.names || [];\r\n\r\n\tif ( ! source.isObject3D ) {\r\n\r\n\t\tsource = getHelperFromSkeleton( source );\r\n\r\n\t}\r\n\r\n\tconst numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),\r\n\t\tdelta = clip.duration / ( numFrames - 1 ),\r\n\t\tconvertedTracks = [],\r\n\t\tmixer = new AnimationMixer( source ),\r\n\t\tbones = getBones( target.skeleton ),\r\n\t\tboneDatas = [];\r\n\r\n\tlet positionOffset,\r\n\t\tbone, boneTo, boneData,\r\n\t\tname;\r\n\r\n\tmixer.clipAction( clip ).play();\r\n\r\n\t// trim\r\n\r\n\tlet start = 0, end = numFrames;\r\n\r\n\tif ( options.trim !== undefined ) {\r\n\r\n\t\tstart = Math.round( options.trim[ 0 ] * options.fps );\r\n\t\tend = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;\r\n\r\n\t\tmixer.update( options.trim[ 0 ] );\r\n\r\n\t} else {\r\n\r\n\t\tmixer.update( 0 );\r\n\r\n\t}\r\n\r\n\tsource.updateMatrixWorld();\r\n\r\n\t//\r\n\r\n\tfor ( let frame = 0; frame < end; ++ frame ) {\r\n\r\n\t\tconst time = frame * delta;\r\n\r\n\t\tretarget( target, source, options );\r\n\r\n\t\tfor ( let j = 0; j < bones.length; ++ j ) {\r\n\r\n\t\t\tbone = bones[ j ];\r\n\t\t\tname = getBoneName( bone, options ) || bone.name;\r\n\t\t\tboneTo = getBoneByName( name, source.skeleton );\r\n\r\n\t\t\tif ( boneTo ) {\r\n\r\n\t\t\t\tboneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };\r\n\r\n\t\t\t\tif ( options.hip === name ) {\r\n\r\n\t\t\t\t\tif ( ! boneData.pos ) {\r\n\r\n\t\t\t\t\t\tboneData.pos = {\r\n\t\t\t\t\t\t\ttimes: new Float32Array( end ),\r\n\t\t\t\t\t\t\tvalues: new Float32Array( end * 3 )\r\n\t\t\t\t\t\t};\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( options.useFirstFramePosition ) {\r\n\r\n\t\t\t\t\t\tif ( frame === 0 ) {\r\n\r\n\t\t\t\t\t\t\tpositionOffset = bone.position.clone();\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tbone.position.sub( positionOffset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tboneData.pos.times[ frame ] = time;\r\n\r\n\t\t\t\t\tbone.position.toArray( boneData.pos.values, frame * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! boneData.quat ) {\r\n\r\n\t\t\t\t\tboneData.quat = {\r\n\t\t\t\t\t\ttimes: new Float32Array( end ),\r\n\t\t\t\t\t\tvalues: new Float32Array( end * 4 )\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tboneData.quat.times[ frame ] = time;\r\n\r\n\t\t\t\tbone.quaternion.toArray( boneData.quat.values, frame * 4 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( frame === end - 2 ) {\r\n\r\n\t\t\t// last mixer update before final loop iteration\r\n\t\t\t// make sure we do not go over or equal to clip duration\r\n\t\t\tmixer.update( delta - 0.0000001 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmixer.update( delta );\r\n\r\n\t\t}\r\n\r\n\t\tsource.updateMatrixWorld();\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < boneDatas.length; ++ i ) {\r\n\r\n\t\tboneData = boneDatas[ i ];\r\n\r\n\t\tif ( boneData ) {\r\n\r\n\t\t\tif ( boneData.pos ) {\r\n\r\n\t\t\t\tconvertedTracks.push( new VectorKeyframeTrack(\r\n\t\t\t\t\t'.bones[' + boneData.bone.name + '].position',\r\n\t\t\t\t\tboneData.pos.times,\r\n\t\t\t\t\tboneData.pos.values\r\n\t\t\t\t) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconvertedTracks.push( new QuaternionKeyframeTrack(\r\n\t\t\t\t'.bones[' + boneData.bone.name + '].quaternion',\r\n\t\t\t\tboneData.quat.times,\r\n\t\t\t\tboneData.quat.values\r\n\t\t\t) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tmixer.uncacheAction( clip );\r\n\r\n\treturn new AnimationClip( clip.name, - 1, convertedTracks );\r\n\r\n}\r\n\r\n/**\r\n * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are\r\n * correctly associated with their bones. Bones are also cloned, and must be descendants of the\r\n * object passed to this method. Other data, like geometries and materials, are reused by reference.\r\n *\r\n * @param {Object3D} source - The 3D object to clone.\r\n * @return {Object3D} The cloned 3D object.\r\n */\r\nfunction clone( source ) {\r\n\r\n\tconst sourceLookup = new Map();\r\n\tconst cloneLookup = new Map();\r\n\r\n\tconst clone = source.clone();\r\n\r\n\tparallelTraverse( source, clone, function ( sourceNode, clonedNode ) {\r\n\r\n\t\tsourceLookup.set( clonedNode, sourceNode );\r\n\t\tcloneLookup.set( sourceNode, clonedNode );\r\n\r\n\t} );\r\n\r\n\tclone.traverse( function ( node ) {\r\n\r\n\t\tif ( ! node.isSkinnedMesh ) return;\r\n\r\n\t\tconst clonedMesh = node;\r\n\t\tconst sourceMesh = sourceLookup.get( node );\r\n\t\tconst sourceBones = sourceMesh.skeleton.bones;\r\n\r\n\t\tclonedMesh.skeleton = sourceMesh.skeleton.clone();\r\n\t\tclonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );\r\n\r\n\t\tclonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {\r\n\r\n\t\t\treturn cloneLookup.get( bone );\r\n\r\n\t\t} );\r\n\r\n\t\tclonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );\r\n\r\n\t} );\r\n\r\n\treturn clone;\r\n\r\n}\r\n\r\n// internal helper\r\n\r\nfunction getBoneByName( name, skeleton ) {\r\n\r\n\tfor ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {\r\n\r\n\t\tif ( name === bones[ i ].name )\r\n\r\n\t\t\treturn bones[ i ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getBones( skeleton ) {\r\n\r\n\treturn Array.isArray( skeleton ) ? skeleton : skeleton.bones;\r\n\r\n}\r\n\r\n\r\nfunction getHelperFromSkeleton( skeleton ) {\r\n\r\n\tconst source = new SkeletonHelper( skeleton.bones[ 0 ] );\r\n\tsource.skeleton = skeleton;\r\n\r\n\treturn source;\r\n\r\n}\r\n\r\nfunction parallelTraverse( a, b, callback ) {\r\n\r\n\tcallback( a, b );\r\n\r\n\tfor ( let i = 0; i < a.children.length; i ++ ) {\r\n\r\n\t\tparallelTraverse( a.children[ i ], b.children[ i ], callback );\r\n\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Retarget options of `SkeletonUtils`.\r\n *\r\n * @typedef {Object} module:SkeletonUtils~RetargetOptions\r\n * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.\r\n * @property {number} [fps] - The FPS of the clip.\r\n * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.\r\n * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.\r\n * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.\r\n * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.\r\n * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.\r\n * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.\r\n * @property {string} [hip='hip'] - The name of the source's hip bone.\r\n * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.\r\n * @property {number} [scale=1] - The scale.\r\n **/\r\n\r\nexport {\r\n\tretarget,\r\n\tretargetClip,\r\n\tclone,\r\n};\r\n"
      },
      "RapierWorker": {
        "fileName": "RapierWorker",
        "script": "",
        "filePath": "/global/libraries/js/RapierWorker.js"
      },
      "Component": {
        "fileName": "Component",
        "script": "class Component {\r\n    constructor(game, parent) { \r\n        this.game = game;\r\n        this.parent = parent;\r\n    }\r\n    init(params) {}\r\n    getComponent(type) {\r\n        return this.parent.getComponent(type);\r\n    }\r\n    update() {}\r\n    postUpdate() {}\r\n    getNetworkData(){ return null }\r\n    setNetworkData(data){ }\r\n    onPhysicsUpdate(timestamp, physicsStepMs){}\r\n    destroy() {}\r\n}\r\n",
        "filePath": "/global/libraries/js/Component.js"
      },
      "FantasyUIEnhancements": {
        "script": "class FantasyUIEnhancements {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.initializeEnhancements();\r\n    }\r\n\r\n    initializeEnhancements() {\r\n        this.setupButtonAnimations();\r\n        this.setupModeCardSelection();\r\n        this.setupNotificationSystem();\r\n        this.setupBattleLogAnimations();\r\n        this.addParticleEffects();\r\n    }\r\n\r\n    /**\r\n     * Enhanced button interactions with ripple effects\r\n     */\r\n    setupButtonAnimations() {\r\n        document.addEventListener('DOMContentLoaded', () => {\r\n            const buttons = document.querySelectorAll('.btn, .ready-btn, .level-up-button, .undo-button');\r\n            buttons.forEach(button => {\r\n                // Hover effects\r\n                button.addEventListener('mouseenter', () => {\r\n                    if (!button.disabled) {\r\n                        button.style.transform = 'translateY(-2px) scale(1.02)';\r\n                    }\r\n                });\r\n                \r\n                button.addEventListener('mouseleave', () => {\r\n                    if (!button.disabled) {\r\n                        button.style.transform = 'translateY(0) scale(1)';\r\n                    }\r\n                });\r\n\r\n                // Ripple effect on click\r\n                button.addEventListener('click', (e) => {\r\n                    this.createRippleEffect(e.target, e);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates ripple effect on button click\r\n     */\r\n    createRippleEffect(button, event) {\r\n        const ripple = document.createElement('span');\r\n        ripple.style.cssText = `\r\n            position: absolute;\r\n            border-radius: 50%;\r\n            background: rgba(212, 175, 55, 0.6);\r\n            transform: scale(0);\r\n            animation: ripple 0.6s linear;\r\n            pointer-events: none;\r\n            z-index: 1;\r\n        `;\r\n        \r\n        const rect = button.getBoundingClientRect();\r\n        const size = Math.max(rect.width, rect.height);\r\n        ripple.style.width = ripple.style.height = size + 'px';\r\n        ripple.style.left = (event.clientX - rect.left - size / 2) + 'px';\r\n        ripple.style.top = (event.clientY - rect.top - size / 2) + 'px';\r\n        \r\n        button.style.position = 'relative';\r\n        button.style.overflow = 'hidden';\r\n        button.appendChild(ripple);\r\n        \r\n        setTimeout(() => {\r\n            if (ripple.parentNode) {\r\n                ripple.remove();\r\n            }\r\n        }, 600);\r\n    }\r\n\r\n    /**\r\n     * Enhanced mode card selection with animations\r\n     */\r\n    setupModeCardSelection() {\r\n        document.addEventListener('click', (e) => {\r\n            const modeCard = e.target.closest('.mode-card');\r\n            if (modeCard) {\r\n                // Remove selected class from all cards\r\n                const allCards = document.querySelectorAll('.mode-card');\r\n                allCards.forEach(card => {\r\n                    card.classList.remove('selected');\r\n                    card.style.animation = 'cardDeselect 0.3s ease-out';\r\n                });\r\n                \r\n                // Add selected class to clicked card\r\n                modeCard.classList.add('selected');\r\n                modeCard.style.animation = 'cardSelect 0.4s ease-out';\r\n                \r\n                // Create selection sound effect (visual feedback)\r\n                this.createSelectionEffect(modeCard);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates visual selection effect for mode cards\r\n     */\r\n    createSelectionEffect(card) {\r\n        const effect = document.createElement('div');\r\n        effect.style.cssText = `\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            width: 20px;\r\n            height: 20px;\r\n            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);\r\n            border-radius: 50%;\r\n            transform: translate(-50%, -50%) scale(0);\r\n            animation: selectionPulse 0.8s ease-out;\r\n            pointer-events: none;\r\n            z-index: 10;\r\n        `;\r\n        \r\n        card.style.position = 'relative';\r\n        card.appendChild(effect);\r\n        \r\n        setTimeout(() => {\r\n            if (effect.parentNode) {\r\n                effect.remove();\r\n            }\r\n        }, 800);\r\n    }\r\n\r\n    /**\r\n     * Enhanced notification system\r\n     */\r\n    setupNotificationSystem() {\r\n        this.notificationContainer = document.createElement('div');\r\n        this.notificationContainer.id = 'notificationContainer';\r\n        this.notificationContainer.style.cssText = `\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            z-index: 3000;\r\n            display: flex;\r\n            flex-direction: column;\r\n            gap: 10px;\r\n        `;\r\n        document.body.appendChild(this.notificationContainer);\r\n    }\r\n\r\n    /**\r\n     * Show enhanced notification with fantasy styling\r\n     */\r\n    showNotification(message, type = 'info', duration = 5000) {\r\n        const notification = document.createElement('div');\r\n        notification.className = `fantasy-notification ${type}`;\r\n        notification.style.cssText = `\r\n            background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n            border: 2px solid var(--primary-gold);\r\n            border-radius: 8px;\r\n            padding: 1rem 1.5rem;\r\n            color: var(--parchment);\r\n            font-family: var(--font-title);\r\n            min-width: 250px;\r\n            max-width: 400px;\r\n            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);\r\n            animation: notificationSlideIn 0.3s ease-out;\r\n            backdrop-filter: blur(10px);\r\n        `;\r\n\r\n        // Set border color based on type\r\n        switch (type) {\r\n            case 'success':\r\n                notification.style.borderColor = 'var(--forest-green)';\r\n                message = ` ${message}`;\r\n                break;\r\n            case 'error':\r\n                notification.style.borderColor = 'var(--blood-red)';\r\n                message = ` ${message}`;\r\n                break;\r\n            case 'warning':\r\n                notification.style.borderColor = 'var(--accent-amber)';\r\n                message = ` ${message}`;\r\n                break;\r\n            default:\r\n                message = ` ${message}`;\r\n        }\r\n\r\n        notification.innerHTML = `\r\n            <div style=\"display: flex; justify-content: space-between; align-items: center;\">\r\n                <span>${message}</span>\r\n                <button onclick=\"this.parentElement.parentElement.remove()\" \r\n                        style=\"background: none; border: none; color: var(--stone-gray); cursor: pointer; font-size: 1.2rem; margin-left: 1rem;\"></button>\r\n            </div>\r\n        `;\r\n\r\n        this.notificationContainer.appendChild(notification);\r\n\r\n        // Auto-hide after duration\r\n        setTimeout(() => {\r\n            if (notification.parentNode) {\r\n                notification.style.animation = 'notificationSlideOut 0.3s ease-in';\r\n                setTimeout(() => {\r\n                    if (notification.parentNode) {\r\n                        notification.remove();\r\n                    }\r\n                }, 300);\r\n            }\r\n        }, duration);\r\n\r\n        return notification;\r\n    }\r\n\r\n    /**\r\n     * Enhanced battle log with smooth animations\r\n     */\r\n    setupBattleLogAnimations() {\r\n        this.battleLogQueue = [];\r\n        this.isProcessingLog = false;\r\n    }\r\n\r\n    /**\r\n     * Add battle log entry with animation\r\n     */\r\n    addBattleLogEntry(message, type = 'default') {\r\n        this.battleLogQueue.push({ message, type });\r\n        if (!this.isProcessingLog) {\r\n            this.processBattleLogQueue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process battle log queue with animations\r\n     */\r\n    processBattleLogQueue() {\r\n        if (this.battleLogQueue.length === 0) {\r\n            this.isProcessingLog = false;\r\n            return;\r\n        }\r\n\r\n        this.isProcessingLog = true;\r\n        const { message, type } = this.battleLogQueue.shift();\r\n        \r\n        const battleLog = document.getElementById('battleLog');\r\n        if (!battleLog) {\r\n            this.processBattleLogQueue();\r\n            return;\r\n        }\r\n\r\n        const entry = document.createElement('div');\r\n        entry.classList.add('log-entry');\r\n        if (type !== 'default') {\r\n            entry.classList.add(`log-${type}`);\r\n        }\r\n        \r\n        entry.textContent = message;\r\n        entry.style.cssText = `\r\n            opacity: 0;\r\n            transform: translateX(-20px);\r\n            transition: all 0.4s ease;\r\n        `;\r\n\r\n        battleLog.appendChild(entry);\r\n\r\n        // Animate in\r\n        setTimeout(() => {\r\n            entry.style.opacity = '1';\r\n            entry.style.transform = 'translateX(0)';\r\n        }, 10);\r\n\r\n        // Auto-scroll to bottom\r\n        battleLog.scrollTop = battleLog.scrollHeight;\r\n\r\n        // Remove old entries if too many\r\n        const entries = battleLog.querySelectorAll('.log-entry');\r\n        if (entries.length > 50) {\r\n            const oldEntry = entries[0];\r\n            oldEntry.style.opacity = '0';\r\n            oldEntry.style.transform = 'translateX(-20px)';\r\n            setTimeout(() => {\r\n                if (oldEntry.parentNode) {\r\n                    oldEntry.remove();\r\n                }\r\n            }, 400);\r\n        }\r\n\r\n        // Process next entry after delay\r\n        setTimeout(() => {\r\n            this.processBattleLogQueue();\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * Add floating particle effects\r\n     */\r\n    addParticleEffects() {\r\n        // Add particles to main menu\r\n        const mainMenu = document.getElementById('mainMenu');\r\n        if (mainMenu && !mainMenu.querySelector('.particle-container')) {\r\n            this.createParticleSystem(mainMenu);\r\n        }\r\n\r\n        // Add subtle particles to game screen\r\n        const gameScreen = document.getElementById('gameScreen');\r\n        if (gameScreen && !gameScreen.querySelector('.particle-container')) {\r\n            this.createParticleSystem(gameScreen, 'subtle');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create particle system for backgrounds\r\n     */\r\n    createParticleSystem(container, intensity = 'normal') {\r\n        const particleContainer = document.createElement('div');\r\n        particleContainer.className = 'particle-container';\r\n        particleContainer.style.cssText = `\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            width: 100%;\r\n            height: 100%;\r\n            pointer-events: none;\r\n            z-index: 0;\r\n            overflow: hidden;\r\n        `;\r\n\r\n        const particleCount = intensity === 'subtle' ? 15 : 30;\r\n        const particleSize = intensity === 'subtle' ? 2 : 3;\r\n        const particleOpacity = intensity === 'subtle' ? 0.3 : 0.6;\r\n\r\n        for (let i = 0; i < particleCount; i++) {\r\n            const particle = document.createElement('div');\r\n            particle.style.cssText = `\r\n                position: absolute;\r\n                width: ${particleSize}px;\r\n                height: ${particleSize}px;\r\n                background: radial-gradient(circle, rgba(212, 175, 55, ${particleOpacity}), transparent);\r\n                border-radius: 50%;\r\n                animation: particleFloat ${15 + Math.random() * 20}s linear infinite;\r\n                animation-delay: ${Math.random() * 10}s;\r\n                left: ${Math.random() * 100}%;\r\n                top: ${Math.random() * 100}%;\r\n            `;\r\n            particleContainer.appendChild(particle);\r\n        }\r\n\r\n        container.style.position = 'relative';\r\n        container.appendChild(particleContainer);\r\n    }\r\n\r\n    /**\r\n     * Enhanced screen transitions\r\n     */\r\n    switchScreen(fromScreenId, toScreenId) {\r\n        const fromScreen = document.getElementById(fromScreenId);\r\n        const toScreen = document.getElementById(toScreenId);\r\n\r\n        if (fromScreen) {\r\n            fromScreen.style.animation = 'screenFadeOut 0.4s ease-in forwards';\r\n            setTimeout(() => {\r\n                fromScreen.classList.remove('active');\r\n                fromScreen.style.animation = '';\r\n            }, 400);\r\n        }\r\n\r\n        setTimeout(() => {\r\n            if (toScreen) {\r\n                toScreen.classList.add('active');\r\n                toScreen.style.animation = 'screenFadeIn 0.6s ease-out';\r\n                \r\n                // Add particles if it's main menu\r\n                if (toScreenId === 'mainMenu') {\r\n                    this.addParticleEffects();\r\n                }\r\n            }\r\n        }, fromScreen ? 200 : 0);\r\n    }\r\n\r\n    /**\r\n     * Create enhanced unit card with animations\r\n     */\r\n    createEnhancedUnitCard(unitData) {\r\n        const card = document.createElement('div');\r\n        card.className = 'unit-card';\r\n        card.dataset.unitId = unitData.id;\r\n        card.style.animation = 'cardSlideIn 0.3s ease-out';\r\n\r\n        // Add shimmer effect for rare/special units\r\n        if (unitData.rarity && unitData.rarity !== 'common') {\r\n            card.classList.add('rare-unit');\r\n            this.addShimmerEffect(card, unitData.rarity);\r\n        }\r\n\r\n        card.innerHTML = `\r\n            <div class=\"unit-name\">${unitData.name || unitData.title}</div>\r\n            <div class=\"unit-cost\"> ${unitData.value || unitData.cost}g</div>\r\n            <div class=\"unit-stats\"> ${unitData.damage} |  ${unitData.hp}</div>\r\n        `;\r\n\r\n        // Add tooltip\r\n        if (unitData.description) {\r\n            card.title = unitData.description;\r\n        }\r\n\r\n        // Add selection animation\r\n        card.addEventListener('click', () => {\r\n            this.animateUnitSelection(card);\r\n        });\r\n\r\n        return card;\r\n    }\r\n\r\n    /**\r\n     * Add shimmer effect for rare units\r\n     */\r\n    addShimmerEffect(card, rarity) {\r\n        const shimmer = document.createElement('div');\r\n        shimmer.style.cssText = `\r\n            position: absolute;\r\n            top: 0;\r\n            left: -100%;\r\n            width: 100%;\r\n            height: 100%;\r\n            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);\r\n            animation: shimmer 3s ease-in-out infinite;\r\n            pointer-events: none;\r\n            z-index: 1;\r\n        `;\r\n        \r\n        card.style.position = 'relative';\r\n        card.style.overflow = 'hidden';\r\n        card.appendChild(shimmer);\r\n    }\r\n\r\n    /**\r\n     * Animate unit card selection\r\n     */\r\n    animateUnitSelection(card) {\r\n        // Remove selection from other cards\r\n        document.querySelectorAll('.unit-card.selected').forEach(c => {\r\n            c.classList.remove('selected');\r\n        });\r\n\r\n        // Add selection to this card\r\n        card.classList.add('selected');\r\n        \r\n        // Create selection burst effect\r\n        const burst = document.createElement('div');\r\n        burst.style.cssText = `\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            width: 10px;\r\n            height: 10px;\r\n            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);\r\n            border-radius: 50%;\r\n            transform: translate(-50%, -50%) scale(0);\r\n            animation: selectionBurst 0.6s ease-out;\r\n            pointer-events: none;\r\n            z-index: 10;\r\n        `;\r\n        \r\n        card.appendChild(burst);\r\n        setTimeout(() => burst.remove(), 600);\r\n    }\r\n\r\n    /**\r\n     * Enhanced experience panel creation\r\n     */\r\n    createEnhancedExperiencePanel(squadData) {\r\n        const panel = document.createElement('div');\r\n        panel.className = 'experience-panel';\r\n        panel.style.animation = 'experienceGlow 2s ease-in-out infinite alternate';\r\n\r\n        panel.innerHTML = `\r\n            <div style=\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;\">\r\n                <span style=\"color: var(--stone-gray); font-size: 14px; font-weight: bold;\">\r\n                    ${squadData.displayName} (Lvl ${squadData.level})\r\n                </span>\r\n                <span style=\"color: var(--accent-amber); font-size: 12px;\">\r\n                     ${squadData.nextLevelName}\r\n                </span>\r\n            </div>\r\n            <div class=\"experience-bar\">\r\n                <div class=\"experience-fill\" style=\"width: 100%;\"></div>\r\n            </div>\r\n            <div style=\"display: flex; justify-content: space-between; font-size: 11px; color: var(--stone-gray); margin-bottom: 8px;\">\r\n                <span>Ready to level up!</span>\r\n                <span>${squadData.levelUpCost}g cost</span>\r\n            </div>\r\n        `;\r\n\r\n        const levelUpButton = document.createElement('button');\r\n        levelUpButton.className = 'level-up-button';\r\n        levelUpButton.textContent = `Level Up (-${squadData.levelUpCost}g)`;\r\n        levelUpButton.addEventListener('click', () => {\r\n            this.animateLevelUp(panel);\r\n        });\r\n\r\n        panel.appendChild(levelUpButton);\r\n        return panel;\r\n    }\r\n\r\n    /**\r\n     * Animate level up effect\r\n     */\r\n    animateLevelUp(panel) {\r\n        // Create level up burst effect\r\n        const burst = document.createElement('div');\r\n        burst.style.cssText = `\r\n            position: absolute;\r\n            top: 50%;\r\n            left: 50%;\r\n            width: 20px;\r\n            height: 20px;\r\n            background: radial-gradient(circle, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.5), transparent);\r\n            border-radius: 50%;\r\n            transform: translate(-50%, -50%) scale(0);\r\n            animation: levelUpBurst 1s ease-out;\r\n            pointer-events: none;\r\n            z-index: 10;\r\n        `;\r\n        \r\n        panel.style.position = 'relative';\r\n        panel.appendChild(burst);\r\n        \r\n        setTimeout(() => burst.remove(), 1000);\r\n        \r\n        // Show success notification\r\n        this.showNotification(' Squad leveled up successfully!', 'success');\r\n    }\r\n\r\n    /**\r\n     * Copy room ID with enhanced feedback\r\n     */\r\n    copyRoomId() {\r\n        const roomId = document.getElementById('lobbyRoomId').textContent;\r\n        if (navigator.clipboard) {\r\n            navigator.clipboard.writeText(roomId).then(() => {\r\n                this.showNotification(` Room ID \"${roomId}\" copied to clipboard!`, 'success');\r\n                \r\n                // Visual feedback on the room ID element\r\n                const roomIdEl = document.getElementById('lobbyRoomId');\r\n                roomIdEl.style.animation = 'copyPulse 0.6s ease-out';\r\n                setTimeout(() => {\r\n                    roomIdEl.style.animation = '';\r\n                }, 600);\r\n            });\r\n        } else {\r\n            this.showNotification(' Copy feature not available in this browser', 'warning');\r\n        }\r\n    }\r\n}\r\n\r\nif(typeof FantasyUIEnhancements != 'undefined'){\r\n        \r\n    // Export for use in your game systems\r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = FantasyUIEnhancements;\r\n    } else if (typeof window !== 'undefined') {\r\n        window.FantasyUIEnhancements = FantasyUIEnhancements;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/FantasyUIEnhancements.js",
        "fileName": "FantasyUIEnhancements"
      },
      "DesyncDebugger": {
        "script": "class DesyncDebugger {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.desyncDebugger = this;\r\n        this.frameHashes = [];\r\n        this.lastDisplayTime = 0;\r\n        this.logInterval = 0; // Log every 1 sec\r\n        this.detailedLogging = true;\r\n        this.enabled = false;\r\n    }\r\n    displaySync(detailed) {    \r\n        if(this.enabled){\r\n            const entities = this.game.getEntitiesWith(\r\n                this.game.componentManager.getComponentTypes().POSITION,\r\n                this.game.componentManager.getComponentTypes().COMBAT\r\n            );\r\n            // Create deterministic state snapshot\r\n            const stateData = this.createStateSnapshot(entities);\r\n            const hash = this.hash(stateData);\r\n            \r\n            this.frameHashes.push({\r\n                hash: hash,\r\n                entityCount: entities.length,\r\n                stateData: stateData,\r\n                time: this.game.state.now\r\n            });   \r\n            if(this.game.isServer){\r\n                console.log(this.game.state.now, hash);                    \r\n            } else {\r\n                console.log(this.game.state.now, hash, stateData);                    \r\n            }\r\n        }\r\n    }\r\n\r\n    createStateSnapshot(entities) {\r\n        const CT = this.game.componentManager.getComponentTypes();\r\n        \r\n        const snapshot = {\r\n            gameTime: parseFloat(this.game.state.now.toFixed(6)), // Round to avoid float precision issues\r\n            entities: []\r\n        };\r\n\r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, CT.POSITION);\r\n            const vel = this.game.getComponent(entityId, CT.VELOCITY);\r\n            const combat = this.game.getComponent(entityId, CT.COMBAT);\r\n            const health = this.game.getComponent(entityId, CT.HEALTH);\r\n            const aiState = this.game.getComponent(entityId, CT.AI_STATE);\r\n\r\n            const entityData = {\r\n                id: String(entityId),\r\n                pos: `${this.hash(pos ? {\r\n                    x: parseFloat(pos.x.toFixed(3)),\r\n                    y: parseFloat(pos.y.toFixed(3)),\r\n                    z: parseFloat(pos.z.toFixed(3))\r\n                } : null)} ${pos.x}, ${pos.y}, ${pos.z}`,\r\n                vel: `${this.hash(vel ? {\r\n                    vx: parseFloat(vel.vx.toFixed(3)),\r\n                    vy: parseFloat(vel.vy.toFixed(3)),\r\n                    vz: parseFloat(vel.vz.toFixed(3))\r\n                } : null)} ${vel?.vx || 0}, ${vel?.vy || 0}, ${vel?.vz || 0}`,\r\n                healthHash: this.hash(health ? {\r\n                    current: health.current,\r\n                    max: health.max\r\n                } : null),\r\n                combatHash: this.hash(combat ? {\r\n                    lastAttack: parseFloat(combat.lastAttack.toFixed(6)),\r\n                    damage: combat.damage,\r\n                    attackSpeed: combat.attackSpeed\r\n                } : null),\r\n                aiStateHash: this.hash(aiState ? {\r\n                    state: aiState.state,\r\n                    controller: aiState.aiControllerId,\r\n                    targetPosition: aiState.targetPosition || 'null',\r\n                    target: aiState.target || 'null'\r\n                } : null),\r\n                aiState: JSON.stringify(aiState)\r\n            };\r\n\r\n            snapshot.entities.push(entityData);\r\n        });\r\n\r\n        return snapshot;\r\n    }\r\n\r\n    hash(data) {\r\n        // Simple hash function for state comparison\r\n        const str = JSON.stringify(data);\r\n        let hash = 0;\r\n        for (let i = 0; i < str.length; i++) {\r\n            const char = str.charCodeAt(i);\r\n            hash = ((hash << 5) - hash) + char;\r\n            hash = hash & hash; // Convert to 32-bit integer\r\n        }\r\n        return hash;\r\n    }\r\n\r\n    // Compare with another client's hashes\r\n    compareHashes(otherClientHashes) {\r\n        const mismatches = [];\r\n        \r\n        for (let i = 0; i < Math.min(this.frameHashes.length, otherClientHashes.length); i++) {\r\n            const myFrame = this.frameHashes[i];\r\n            const otherFrame = otherClientHashes[i];\r\n            \r\n            if (myFrame.hash !== otherFrame.hash) {\r\n                mismatches.push({\r\n                    frame: myFrame.frame,\r\n                    myHash: myFrame.hash,\r\n                    otherHash: otherFrame.hash,\r\n                    myTime: myFrame.time,\r\n                    otherTime: otherFrame.time,\r\n                    myEntities: myFrame.entityCount,\r\n                    otherEntities: otherFrame.entityCount\r\n                });\r\n            }\r\n        }\r\n        \r\n        return mismatches;\r\n    }\r\n\r\n    enableDetailedLogging() {\r\n        this.detailedLogging = true;\r\n        console.log(\"Detailed desync logging enabled\");\r\n    }\r\n\r\n    disableDetailedLogging() {\r\n        this.detailedLogging = false;\r\n        console.log(\"Detailed desync logging disabled\");\r\n    }\r\n\r\n    // Get the last N frame hashes for comparison\r\n    getRecentHashes(count = 10) {\r\n        return this.frameHashes.slice(-count);\r\n    }\r\n\r\n    // Check for common desync patterns\r\n    analyzeDesyncPatterns() {\r\n        if (this.frameHashes.length < 10) return;\r\n\r\n        const recent = this.frameHashes.slice(-10);\r\n        const patterns = {\r\n            stableHashes: new Set(recent.map(f => f.hash)).size === 1,\r\n            increasingEntityCount: recent[recent.length - 1].entityCount > recent[0].entityCount,\r\n            decreasingEntityCount: recent[recent.length - 1].entityCount < recent[0].entityCount,\r\n            timeIncreasingMonotonically: recent.every((frame, i) => i === 0 || frame.time > recent[i-1].time)\r\n        };\r\n\r\n        console.log(\"Desync Analysis:\", patterns);\r\n        return patterns;\r\n    }\r\n}\r\n\r\nif(typeof DesyncDebugger != 'undefined'){\r\n\r\n    if (typeof window !== 'undefined') {\r\n        window.DesyncDebugger = DesyncDebugger;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = DesyncDebugger;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = DesyncDebugger;\r\n        exports.DesyncDebugger = DesyncDebugger;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/DesyncDebugger.js",
        "fileName": "DesyncDebugger"
      },
      "GameUtils": {
        "script": "class GameUtils {\r\n    static DEFAULT_UNIT_RADIUS = 25;\r\n    static MIN_MOVEMENT_THRESHOLD = 0.1;\r\n    \r\n    static getUnitRadius(collision) {\r\n        return collision?.radius ? Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius) : this.DEFAULT_UNIT_RADIUS;\r\n    }\r\n    \r\n    static calculateDistance(pos1, pos2, collision1 = null, collision2 = null) {\r\n        const dx = pos2.x - pos1.x;\r\n        const dz = pos2.z - pos2.z;\r\n        const centerDistance = Math.sqrt(dx * dx + dz * dz);\r\n        \r\n        if (!collision1 || !collision2) return centerDistance;\r\n        \r\n        const radius1 = this.getUnitRadius(collision1);\r\n        const radius2 = this.getUnitRadius(collision2);\r\n        \r\n        return {\r\n            center: centerDistance,\r\n            edge: Math.max(0, centerDistance - radius1 - radius2),\r\n            toTargetEdge: Math.max(0, centerDistance - radius2)\r\n        };\r\n    }\r\n    \r\n    static lerp(a, b, t) {\r\n        return a + (b - a) * t;\r\n    }    \r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameUtils.js",
        "fileName": "GameUtils"
      },
      "UIComponents": {
        "script": "class UIComponents {\r\n    static createStatCard(label, value, className = '') {\r\n        const card = document.createElement('div');\r\n        card.className = `enhanced-ui-stat ${className}`;\r\n        card.innerHTML = `\r\n            <div class=\"stat-label\">${label}</div>\r\n            <div class=\"stat-value\">${value}</div>\r\n        `;\r\n        return card;\r\n    }\r\n\r\n    static createProgressBar(current, max, label = '') {\r\n        const container = document.createElement('div');\r\n        container.className = 'progress-container';\r\n        \r\n        const percentage = max > 0 ? (current / max) * 100 : 0;\r\n        \r\n        container.innerHTML = `\r\n            <div class=\"progress-label\">${label}</div>\r\n            <div class=\"progress-bar\">\r\n                <div class=\"progress-fill\" style=\"width: ${percentage}%\"></div>\r\n            </div>\r\n            <div class=\"progress-text\">${current}/${max}</div>\r\n        `;\r\n        \r\n        return container;\r\n    }\r\n\r\n    static createNotification(message, type = 'info', duration = 3000) {\r\n        const notification = document.createElement('div');\r\n        notification.className = `notification notification-${type}`;\r\n        notification.textContent = message;\r\n        \r\n        // Style the notification\r\n        notification.style.cssText = `\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            padding: 1rem;\r\n            border-radius: 5px;\r\n            color: white;\r\n            font-family: 'Courier New', monospace;\r\n            z-index: 1000;\r\n            animation: slideIn 0.3s ease-out;\r\n            max-width: 300px;\r\n        `;\r\n        \r\n        const colors = {\r\n            info: '#0088ff',\r\n            success: '#00ff00',\r\n            warning: '#ffaa00',\r\n            error: '#ff4444'\r\n        };\r\n        \r\n        notification.style.backgroundColor = colors[type] || colors.info;\r\n        \r\n        document.body.appendChild(notification);\r\n        \r\n        setTimeout(() => {\r\n            notification.style.animation = 'slideOut 0.3s ease-in';\r\n            setTimeout(() => {\r\n                if (notification.parentNode) {\r\n                    document.body.removeChild(notification);\r\n                }\r\n            }, 300);\r\n        }, duration);\r\n        \r\n        return notification;\r\n    }\r\n\r\n    static addProgressBarCSS() {\r\n        const style = document.createElement('style');\r\n        style.textContent = `\r\n            .progress-container {\r\n                margin: 0.5rem 0;\r\n            }\r\n            \r\n            .progress-label {\r\n                font-size: 0.8rem;\r\n                color: #aaa;\r\n                margin-bottom: 0.2rem;\r\n            }\r\n            \r\n            .progress-bar {\r\n                width: 100%;\r\n                height: 1rem;\r\n                background: #333;\r\n                border: 1px solid #555;\r\n                border-radius: 3px;\r\n                overflow: hidden;\r\n            }\r\n            \r\n            .progress-fill {\r\n                height: 100%;\r\n                background: linear-gradient(90deg, #00ff00, #88ff88);\r\n                transition: width 0.3s ease;\r\n            }\r\n            \r\n            .progress-text {\r\n                font-size: 0.7rem;\r\n                color: #ccc;\r\n                margin-top: 0.2rem;\r\n                text-align: center;\r\n            }\r\n            \r\n            @keyframes slideIn {\r\n                from { transform: translateX(100%); opacity: 0; }\r\n                to { transform: translateX(0); opacity: 1; }\r\n            }\r\n            \r\n            @keyframes slideOut {\r\n                from { transform: translateX(0); opacity: 1; }\r\n                to { transform: translateX(100%); opacity: 0; }\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n}\r\n\r\n// Initialize CSS when the script loads\r\nif (typeof document !== 'undefined') {\r\n    window.engine.UIComponents = UIComponents;\r\n    document.addEventListener('DOMContentLoaded', () => {\r\n        window.engine.UIComponents.addProgressBarCSS();\r\n    });\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/UIComponents.js",
        "fileName": "UIComponents"
      },
      "NotificationSystem": {
        "script": "// ================================\r\n// FILE: js/ui/NotificationSystem.js - User Notifications\r\n// ================================\r\n\r\nclass NotificationSystem {\r\n    static notifications = [];\r\n    static maxNotifications = 5;\r\n    static defaultDuration = 3000;\r\n    static container = null;\r\n    \r\n    static initialize() {\r\n        this.createContainer();\r\n        this.addNotificationCSS();\r\n    }\r\n    \r\n    static createContainer() {\r\n        if (this.container) return;\r\n        \r\n        this.container = document.createElement('div');\r\n        this.container.id = 'notification-container';\r\n        this.container.className = 'notification-container';\r\n        document.body.appendChild(this.container);\r\n    }\r\n    \r\n    static show(message, type = 'info', duration = null, options = {}) {\r\n        this.createContainer();\r\n        \r\n        const notification = this.createNotification(message, type, duration || this.defaultDuration, options);\r\n        this.addNotification(notification);\r\n        \r\n        return notification;\r\n    }\r\n    \r\n    static createNotification(message, type, duration, options) {\r\n        const notification = document.createElement('div');\r\n        const id = 'notification-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);\r\n        \r\n        notification.id = id;\r\n        notification.className = `notification notification-${type}`;\r\n        notification.setAttribute('data-type', type);\r\n        \r\n        // Create notification content\r\n        const content = document.createElement('div');\r\n        content.className = 'notification-content';\r\n        \r\n        // Add icon based on type\r\n        const icon = this.getTypeIcon(type);\r\n        const iconElement = document.createElement('span');\r\n        iconElement.className = 'notification-icon';\r\n        iconElement.textContent = icon;\r\n        \r\n        // Add message\r\n        const messageElement = document.createElement('span');\r\n        messageElement.className = 'notification-message';\r\n        messageElement.textContent = message;\r\n        \r\n        // Add close button if closable\r\n        let closeButton = null;\r\n        if (options.closable !== false) {\r\n            closeButton = document.createElement('button');\r\n            closeButton.className = 'notification-close';\r\n            closeButton.innerHTML = '&times;';\r\n            closeButton.type = 'button';\r\n            closeButton.addEventListener('click', () => {\r\n                this.remove(id);\r\n            });\r\n        }\r\n        \r\n        // Add progress bar for timed notifications\r\n        let progressBar = null;\r\n        if (duration > 0) {\r\n            progressBar = document.createElement('div');\r\n            progressBar.className = 'notification-progress';\r\n            progressBar.innerHTML = '<div class=\"notification-progress-fill\"></div>';\r\n        }\r\n        \r\n        // Assemble notification\r\n        content.appendChild(iconElement);\r\n        content.appendChild(messageElement);\r\n        if (closeButton) content.appendChild(closeButton);\r\n        \r\n        notification.appendChild(content);\r\n        if (progressBar) notification.appendChild(progressBar);\r\n        \r\n        // Add click handler for the entire notification if specified\r\n        if (options.onClick) {\r\n            notification.style.cursor = 'pointer';\r\n            notification.addEventListener('click', (e) => {\r\n                if (e.target !== closeButton) {\r\n                    options.onClick();\r\n                    if (options.closeOnClick !== false) {\r\n                        this.remove(id);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Store notification data\r\n        notification._notificationData = {\r\n            id,\r\n            type,\r\n            duration,\r\n            createdAt: Date.now(),\r\n            progressBar,\r\n            options\r\n        };\r\n        \r\n        return notification;\r\n    }\r\n    \r\n    static addNotification(notification) {\r\n        // Remove excess notifications\r\n        while (this.notifications.length >= this.maxNotifications) {\r\n            const oldest = this.notifications.shift();\r\n            if (oldest && oldest.parentElement) {\r\n                oldest.parentElement.removeChild(oldest);\r\n            }\r\n        }\r\n        \r\n        // Add to container and tracking array\r\n        this.container.appendChild(notification);\r\n        this.notifications.push(notification);\r\n        \r\n        // Animate in\r\n        setTimeout(() => {\r\n            notification.classList.add('notification-show');\r\n        }, 10);\r\n        \r\n        // Setup auto-removal timer\r\n        const data = notification._notificationData;\r\n        if (data.duration > 0) {\r\n            this.setupAutoRemoval(notification);\r\n        }\r\n        \r\n        // Setup progress bar animation\r\n        if (data.progressBar) {\r\n            this.animateProgressBar(notification);\r\n        }\r\n    }\r\n    \r\n    static setupAutoRemoval(notification) {\r\n        const data = notification._notificationData;\r\n        \r\n        setTimeout(() => {\r\n            this.remove(data.id);\r\n        }, data.duration);\r\n    }\r\n    \r\n    static animateProgressBar(notification) {\r\n        const data = notification._notificationData;\r\n        const progressFill = notification.querySelector('.notification-progress-fill');\r\n        \r\n        if (progressFill) {\r\n            progressFill.style.transition = `width ${data.duration}ms linear`;\r\n            setTimeout(() => {\r\n                progressFill.style.width = '0%';\r\n            }, 10);\r\n        }\r\n    }\r\n    \r\n    static remove(id) {\r\n        const notification = document.getElementById(id);\r\n        if (!notification) return;\r\n        \r\n        // Animate out\r\n        notification.classList.add('notification-hide');\r\n        \r\n        setTimeout(() => {\r\n            if (notification.parentElement) {\r\n                notification.parentElement.removeChild(notification);\r\n            }\r\n            \r\n            // Remove from tracking array\r\n            this.notifications = this.notifications.filter(n => n.id !== id);\r\n        }, 300);\r\n    }\r\n    \r\n    static clear(type = null) {\r\n        const notificationsToRemove = type \r\n            ? this.notifications.filter(n => n._notificationData.type === type)\r\n            : [...this.notifications];\r\n        \r\n        notificationsToRemove.forEach(notification => {\r\n            this.remove(notification._notificationData.id);\r\n        });\r\n    }\r\n    \r\n    static getTypeIcon(type) {\r\n        const icons = {\r\n            info: '',\r\n            success: '',\r\n            warning: '',\r\n            error: '',\r\n            achievement: '',\r\n            gold: '',\r\n            battle: '',\r\n            victory: '',\r\n            defeat: ''\r\n        };\r\n        \r\n        return icons[type] || icons.info;\r\n    }\r\n    \r\n    // Convenience methods for common notification types\r\n    static success(message, duration = null, options = {}) {\r\n        return this.show(message, 'success', duration, options);\r\n    }\r\n    \r\n    static error(message, duration = 5000, options = {}) {\r\n        return this.show(message, 'error', duration, options);\r\n    }\r\n    \r\n    static warning(message, duration = 4000, options = {}) {\r\n        return this.show(message, 'warning', duration, options);\r\n    }\r\n    \r\n    static info(message, duration = null, options = {}) {\r\n        return this.show(message, 'info', duration, options);\r\n    }\r\n    \r\n    static achievement(message, duration = 5000, options = {}) {\r\n        return this.show(message, 'achievement', duration, options);\r\n    }\r\n    \r\n    static gold(message, duration = 3000, options = {}) {\r\n        return this.show(message, 'gold', duration, options);\r\n    }\r\n    \r\n    static battle(message, duration = 2000, options = {}) {\r\n        return this.show(message, 'battle', duration, options);\r\n    }\r\n    \r\n    static victory(message, duration = 4000, options = {}) {\r\n        return this.show(message, 'victory', duration, options);\r\n    }\r\n    \r\n    static defeat(message, duration = 4000, options = {}) {\r\n        return this.show(message, 'defeat', duration, options);\r\n    }\r\n    \r\n    // Persistent notification (no auto-removal)\r\n    static persistent(message, type = 'info', options = {}) {\r\n        return this.show(message, type, 0, { closable: true, ...options });\r\n    }\r\n    \r\n    static addNotificationCSS() {\r\n        if (document.querySelector('#notification-styles')) return;\r\n        \r\n        const style = document.createElement('style');\r\n        style.id = 'notification-styles';\r\n        style.textContent = `\r\n            .notification-container {\r\n                position: fixed;\r\n                top: 20px;\r\n                right: 20px;\r\n                z-index: 1500;\r\n                pointer-events: none;\r\n                max-width: 400px;\r\n            }\r\n            \r\n            .notification {\r\n                background: #1a1a2e;\r\n                border: 2px solid;\r\n                border-radius: 8px;\r\n                margin-bottom: 10px;\r\n                min-height: 60px;\r\n                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\r\n                overflow: hidden;\r\n                opacity: 0;\r\n                transform: translateX(100%);\r\n                transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);\r\n                pointer-events: auto;\r\n                font-family: 'Courier New', monospace;\r\n                position: relative;\r\n            }\r\n            \r\n            .notification-show {\r\n                opacity: 1;\r\n                transform: translateX(0);\r\n            }\r\n            \r\n            .notification-hide {\r\n                opacity: 0;\r\n                transform: translateX(100%);\r\n                margin-bottom: 0;\r\n                min-height: 0;\r\n            }\r\n            \r\n            .notification-content {\r\n                display: flex;\r\n                align-items: center;\r\n                padding: 1rem;\r\n                position: relative;\r\n                z-index: 1;\r\n            }\r\n            \r\n            .notification-icon {\r\n                font-size: 1.2rem;\r\n                margin-right: 0.8rem;\r\n                flex-shrink: 0;\r\n            }\r\n            \r\n            .notification-message {\r\n                flex: 1;\r\n                color: #fff;\r\n                font-size: 0.9rem;\r\n                line-height: 1.4;\r\n            }\r\n            \r\n            .notification-close {\r\n                background: none;\r\n                border: none;\r\n                color: rgba(255, 255, 255, 0.6);\r\n                font-size: 1.2rem;\r\n                cursor: pointer;\r\n                padding: 0;\r\n                margin-left: 0.5rem;\r\n                width: 24px;\r\n                height: 24px;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                border-radius: 50%;\r\n                transition: all 0.2s;\r\n                flex-shrink: 0;\r\n            }\r\n            \r\n            .notification-close:hover {\r\n                background: rgba(255, 255, 255, 0.1);\r\n                color: #fff;\r\n            }\r\n            \r\n            .notification-progress {\r\n                position: absolute;\r\n                bottom: 0;\r\n                left: 0;\r\n                width: 100%;\r\n                height: 3px;\r\n                background: rgba(255, 255, 255, 0.1);\r\n            }\r\n            \r\n            .notification-progress-fill {\r\n                width: 100%;\r\n                height: 100%;\r\n                background: currentColor;\r\n                transition: none;\r\n            }\r\n            \r\n            /* Type-specific styles */\r\n            .notification-info {\r\n                border-color: #0088ff;\r\n                background: linear-gradient(135deg, #001133 0%, #002244 100%);\r\n                color: #4dc3ff;\r\n            }\r\n            \r\n            .notification-success {\r\n                border-color: #00ff00;\r\n                background: linear-gradient(135deg, #001100 0%, #003300 100%);\r\n                color: #88ff88;\r\n            }\r\n            \r\n            .notification-warning {\r\n                border-color: #ffaa00;\r\n                background: linear-gradient(135deg, #331100 0%, #442200 100%);\r\n                color: #ffcc66;\r\n            }\r\n            \r\n            .notification-error {\r\n                border-color: #ff4444;\r\n                background: linear-gradient(135deg, #330000 0%, #442222 100%);\r\n                color: #ff8888;\r\n            }\r\n            \r\n            .notification-achievement {\r\n                border-color: #ffd700;\r\n                background: linear-gradient(135deg, #332200 0%, #443300 100%);\r\n                color: #ffee88;\r\n                box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2);\r\n            }\r\n            \r\n            .notification-gold {\r\n                border-color: #ffd700;\r\n                background: linear-gradient(135deg, #2d2200 0%, #443300 100%);\r\n                color: #ffe066;\r\n            }\r\n            \r\n            .notification-battle {\r\n                border-color: #ff6600;\r\n                background: linear-gradient(135deg, #330000 0%, #441100 100%);\r\n                color: #ff9966;\r\n            }\r\n            \r\n            .notification-victory {\r\n                border-color: #00ff88;\r\n                background: linear-gradient(135deg, #001122 0%, #003344 100%);\r\n                color: #66ffaa;\r\n                animation: victoryGlow 2s ease-in-out infinite;\r\n            }\r\n            \r\n            @keyframes victoryGlow {\r\n                0%, 100% { box-shadow: 0 4px 12px rgba(0, 255, 136, 0.2); }\r\n                50% { box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4); }\r\n            }\r\n            \r\n            .notification-defeat {\r\n                border-color: #ff0000;\r\n                background: linear-gradient(135deg, #220000 0%, #330000 100%);\r\n                color: #ff6666;\r\n            }\r\n            \r\n            /* Hover effects for clickable notifications */\r\n            .notification[style*=\"cursor: pointer\"]:hover {\r\n                transform: scale(1.02);\r\n                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);\r\n            }\r\n            \r\n            /* Mobile responsiveness */\r\n            @media (max-width: 768px) {\r\n                .notification-container {\r\n                    top: 10px;\r\n                    right: 10px;\r\n                    left: 10px;\r\n                    max-width: none;\r\n                }\r\n                \r\n                .notification {\r\n                    margin-bottom: 8px;\r\n                }\r\n                \r\n                .notification-content {\r\n                    padding: 0.8rem;\r\n                }\r\n                \r\n                .notification-message {\r\n                    font-size: 0.85rem;\r\n                }\r\n            }\r\n            \r\n            /* Animation for notification entrance */\r\n            @keyframes notificationSlide {\r\n                from {\r\n                    opacity: 0;\r\n                    transform: translateX(100%);\r\n                }\r\n                to {\r\n                    opacity: 1;\r\n                    transform: translateX(0);\r\n                }\r\n            }\r\n            \r\n            /* Special effects for achievement notifications */\r\n            .notification-achievement {\r\n                position: relative;\r\n                overflow: visible;\r\n            }\r\n            \r\n            .notification-achievement::before {\r\n                content: '';\r\n                position: absolute;\r\n                top: -5px;\r\n                right: -5px;\r\n                font-size: 1.5rem;\r\n                animation: sparkle 1.5s ease-in-out infinite;\r\n            }\r\n            \r\n            @keyframes sparkle {\r\n                0%, 100% { opacity: 0.5; transform: scale(1) rotate(0deg); }\r\n                50% { opacity: 1; transform: scale(1.2) rotate(180deg); }\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/NotificationSystem.js",
        "fileName": "NotificationSystem"
      },
      "GameModeConfigs": {
        "script": "class GameModeConfigs {\r\n    static getDefaultConfigs() {\r\n        return {\r\n            campaign: {\r\n                name: 'Campaign',\r\n                rounds: 10,\r\n                goldProgression: (round) => 100 + (round * 50),\r\n                enemyScaling: (round) => Math.floor(1 + round * 0.5),\r\n                specialRules: ['story_mode', 'progressive_unlock']\r\n            },\r\n            \r\n            survival: {\r\n                name: 'Survival',\r\n                rounds: Infinity,\r\n                goldProgression: (round) => Math.max(50, 150 - (round * 5)),\r\n                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.2)),\r\n                specialRules: ['limited_gold', 'exponential_enemies']\r\n            },\r\n            \r\n            arena: {\r\n                name: 'Arena',\r\n                rounds: 1,\r\n                goldProgression: () => 200,\r\n                enemyScaling: () => 3,\r\n                specialRules: ['balanced_armies', 'quick_battle']\r\n            },\r\n            \r\n            challenge: {\r\n                name: 'Challenge',\r\n                rounds: 1,\r\n                goldProgression: (challenge) => challenge.startingGold || 100,\r\n                enemyScaling: (challenge) => challenge.enemyCount || 3,\r\n                specialRules: ['preset_enemies', 'special_constraints']\r\n            },\r\n            \r\n            endless: {\r\n                name: 'Endless',\r\n                rounds: Infinity,\r\n                goldProgression: (round) => 100 + (round * 25),\r\n                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.5)),\r\n                specialRules: ['infinite_scaling', 'leaderboards']\r\n            },\r\n            \r\n            tournament: {\r\n                name: 'Tournament',\r\n                rounds: 8,\r\n                goldProgression: (round) => 120 + (round * 30),\r\n                enemyScaling: (round) => 2 + Math.floor(round / 2),\r\n                specialRules: ['bracket_progression', 'ai_personalities']\r\n            }\r\n        };\r\n    }\r\n\r\n    static applyModeRules(gameInstance, mode, round) {\r\n        const config = this.getDefaultConfigs()[mode];\r\n        if (!config) return;\r\n\r\n        // Apply gold progression\r\n        if (gameInstance.state) {\r\n            gameInstance.state.playerGold = config.goldProgression(round);\r\n            console.log('set player gold 1', gameInstance.state.playerGold);\r\n        }\r\n\r\n        // Apply special rules\r\n        config.specialRules.forEach(rule => {\r\n            this.applySpecialRule(gameInstance, rule, round);\r\n        });\r\n    }\r\n\r\n    static applySpecialRule(gameInstance, rule, round) {\r\n        switch (rule) {\r\n            case 'limited_gold':\r\n                // Reduce gold income over time in survival\r\n                break;\r\n                \r\n            case 'exponential_enemies':\r\n                // Increase enemy difficulty exponentially\r\n                break;\r\n                \r\n            case 'balanced_armies':\r\n                // Ensure fair army compositions\r\n                break;\r\n                \r\n            case 'infinite_scaling':\r\n                // Allow unlimited round progression\r\n                break;\r\n                \r\n            default:\r\n                console.log(`Applying special rule: ${rule}`);\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameModeConfigs.js",
        "fileName": "GameModeConfigs"
      },
      "PlacementPreview": {
        "script": "class PlacementPreview {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.placementPreview = this;\r\n        \r\n        this.isActive = false;\r\n        \r\n        this.previewGroup = new THREE.Group();\r\n        this.previewGroup.name = 'PlacementPreview';\r\n        this.previewGroup.visible = false;\r\n        this.game.uiScene.add(this.previewGroup);\r\n        \r\n        const configs = game.getCollections().configs.game;\r\n        this.config = {\r\n            cellOpacity: 0.4,\r\n            borderOpacity: 0.8,\r\n            unitIndicatorRadius: 3,\r\n            unitIndicatorSegments: 8,\r\n            elevationOffset: -48,\r\n            unitElevationOffset: -12,\r\n            cellSizeMultiplier: 0.9,\r\n            maxCells: 50,\r\n            updateThrottle: 16,\r\n            placementGridSize: configs.gridSize / 2, // Placement grid is always half the terrain grid\r\n            terrainGridSize: configs.gridSize // Terrain grid size for building footprints\r\n        };\r\n\r\n        this.geometryPool = this.createGeometryPool();\r\n        this.materials = this.createMaterials();\r\n        \r\n        this.placementCellMeshPool = [];\r\n        this.placementBorderMeshPool = [];\r\n        this.footprintCellMeshPool = [];\r\n        this.footprintBorderMeshPool = [];\r\n        this.unitMeshPool = [];\r\n        this.activeMeshes = [];\r\n\r\n        this.animationId = null;\r\n        this.lastUpdateTime = 0;\r\n\r\n        this.initializeObjectPools();\r\n    }\r\n    \r\n    createGeometryPool() {\r\n        const placementCellSize = this.game.gridSystem.dimensions.cellSize * this.config.cellSizeMultiplier;\r\n        const footprintCellSize = this.config.terrainGridSize * this.config.cellSizeMultiplier;\r\n\r\n        return {\r\n            placementCellPlane: new THREE.PlaneGeometry(placementCellSize, placementCellSize), // For units\r\n            footprintCellPlane: new THREE.PlaneGeometry(footprintCellSize, footprintCellSize), // For buildings\r\n            unitCircle: new THREE.CircleGeometry(\r\n                this.config.unitIndicatorRadius,\r\n                this.config.unitIndicatorSegments\r\n            )\r\n        };\r\n    }\r\n    \r\n    createMaterials() {\r\n        return {\r\n            validCell: new THREE.MeshBasicMaterial({\r\n                color: 0x00ff00,\r\n                transparent: true,\r\n                opacity: this.config.cellOpacity,\r\n                side: THREE.DoubleSide\r\n            }),\r\n            invalidCell: new THREE.MeshBasicMaterial({\r\n                color: 0xff0000,\r\n                transparent: true,\r\n                opacity: this.config.cellOpacity,\r\n                side: THREE.DoubleSide\r\n            }),\r\n            validBorder: new THREE.LineBasicMaterial({\r\n                color: 0x00ff00,\r\n                transparent: true,\r\n                opacity: this.config.borderOpacity\r\n            }),\r\n            invalidBorder: new THREE.LineBasicMaterial({\r\n                color: 0xff0000,\r\n                transparent: true,\r\n                opacity: this.config.borderOpacity\r\n            }),\r\n            validUnit: new THREE.MeshBasicMaterial({\r\n                color: 0x00aa00,\r\n                transparent: true,\r\n                opacity: 0.6\r\n            }),\r\n            invalidUnit: new THREE.MeshBasicMaterial({\r\n                color: 0xaa0000,\r\n                transparent: true,\r\n                opacity: 0.6\r\n            })\r\n        };\r\n    }\r\n    \r\n    initializeObjectPools() {\r\n        const maxObjects = this.config.maxCells;\r\n\r\n        for (let i = 0; i < maxObjects; i++) {\r\n            // Placement cell meshes (for units)\r\n            const placementCellMesh = new THREE.Mesh(this.geometryPool.placementCellPlane, this.materials.validCell);\r\n            placementCellMesh.rotation.x = -Math.PI / 2;\r\n            placementCellMesh.visible = false;\r\n            this.placementCellMeshPool.push(placementCellMesh);\r\n            this.previewGroup.add(placementCellMesh);\r\n\r\n            const placementBorderGeometry = new THREE.EdgesGeometry(this.geometryPool.placementCellPlane);\r\n            const placementBorderMesh = new THREE.LineSegments(placementBorderGeometry, this.materials.validBorder);\r\n            placementBorderMesh.rotation.x = -Math.PI / 2;\r\n            placementBorderMesh.visible = false;\r\n            this.placementBorderMeshPool.push(placementBorderMesh);\r\n            this.previewGroup.add(placementBorderMesh);\r\n\r\n            // Footprint cell meshes (for buildings)\r\n            const footprintCellMesh = new THREE.Mesh(this.geometryPool.footprintCellPlane, this.materials.validCell);\r\n            footprintCellMesh.rotation.x = -Math.PI / 2;\r\n            footprintCellMesh.visible = false;\r\n            this.footprintCellMeshPool.push(footprintCellMesh);\r\n            this.previewGroup.add(footprintCellMesh);\r\n\r\n            const footprintBorderGeometry = new THREE.EdgesGeometry(this.geometryPool.footprintCellPlane);\r\n            const footprintBorderMesh = new THREE.LineSegments(footprintBorderGeometry, this.materials.validBorder);\r\n            footprintBorderMesh.rotation.x = -Math.PI / 2;\r\n            footprintBorderMesh.visible = false;\r\n            this.footprintBorderMeshPool.push(footprintBorderMesh);\r\n            this.previewGroup.add(footprintBorderMesh);\r\n\r\n            // Unit indicator meshes\r\n            const unitMesh = new THREE.Mesh(this.geometryPool.unitCircle, this.materials.validUnit);\r\n            unitMesh.rotation.x = -Math.PI / 2;\r\n            unitMesh.visible = false;\r\n            this.unitMeshPool.push(unitMesh);\r\n            this.previewGroup.add(unitMesh);\r\n        }\r\n    }\r\n    \r\n    showAtWorldPositions(worldPositions, isValid = true, isBuilding = false) {\r\n        const now = performance.now();\r\n        if (now - this.lastUpdateTime < this.config.updateThrottle) {\r\n            return;\r\n        }\r\n        this.lastUpdateTime = now;\r\n\r\n        if (!worldPositions || worldPositions.length === 0) {\r\n            this.hide();\r\n            return;\r\n        }\r\n\r\n        this.isActive = true;\r\n        this.hideAllMeshes();\r\n\r\n        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;\r\n        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;\r\n\r\n        // Choose appropriate mesh pools based on whether it's a building or unit\r\n        const cellMeshPool = isBuilding ? this.footprintCellMeshPool : this.placementCellMeshPool;\r\n        const borderMeshPool = isBuilding ? this.footprintBorderMeshPool : this.placementBorderMeshPool;\r\n        const gridSize = isBuilding ? this.config.terrainGridSize : this.config.placementGridSize;\r\n        // Center the mesh on the cell (gridToWorld returns corner positions)\r\n        const halfSize = gridSize / 2;\r\n\r\n        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {\r\n            if (index >= cellMeshPool.length) return;\r\n\r\n            // Get terrain height at the center of the cell\r\n            const centerX = pos.x + halfSize;\r\n            const centerZ = pos.z - halfSize;\r\n            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', centerX, centerZ);\r\n            const yPosition = (terrainHeight || 0) + this.config.elevationOffset;\r\n\r\n            const cellMesh = cellMeshPool[index];\r\n            cellMesh.material = cellMaterial;\r\n            cellMesh.position.set(centerX, yPosition, centerZ);\r\n            cellMesh.visible = true;\r\n            this.activeMeshes.push(cellMesh);\r\n\r\n            const borderMesh = borderMeshPool[index];\r\n            borderMesh.material = borderMaterial;\r\n            borderMesh.position.set(centerX, yPosition, centerZ);\r\n            borderMesh.visible = true;\r\n            this.activeMeshes.push(borderMesh);\r\n        });\r\n\r\n        this.previewGroup.visible = true;\r\n        this.startAnimation();\r\n    }\r\n    \r\n    showAtGridPositions(gridPositions, isValid = true, isBuilding = false) {\r\n        const worldPositions = gridPositions.map(gridPos =>\r\n            this.game.gridSystem.gridToWorld(gridPos.x, gridPos.z)\r\n        );\r\n        this.showAtWorldPositions(worldPositions, isValid, isBuilding);\r\n    }\r\n\r\n    showWithUnitMarkers(worldPositions, unitPositions, isValid = true, isBuilding = false) {\r\n        const now = performance.now();\r\n        if (now - this.lastUpdateTime < this.config.updateThrottle) {\r\n            return;\r\n        }\r\n        this.lastUpdateTime = now;\r\n\r\n        if (!worldPositions || worldPositions.length === 0) {\r\n            this.hide();\r\n            return;\r\n        }\r\n\r\n        this.isActive = true;\r\n        this.hideAllMeshes();\r\n\r\n        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;\r\n        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;\r\n        const unitMaterial = isValid ? this.materials.validUnit : this.materials.invalidUnit;\r\n\r\n        // Choose appropriate mesh pools based on whether it's a building or unit\r\n        const cellMeshPool = isBuilding ? this.footprintCellMeshPool : this.placementCellMeshPool;\r\n        const borderMeshPool = isBuilding ? this.footprintBorderMeshPool : this.placementBorderMeshPool;\r\n        const gridSize = isBuilding ? this.config.terrainGridSize : this.config.placementGridSize;\r\n        // Center the mesh on the cell (gridToWorld returns corner positions)\r\n        const halfSize = gridSize / 2;\r\n\r\n        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {\r\n            if (index >= cellMeshPool.length) return;\r\n\r\n            // Get terrain height at the center of the cell\r\n            const centerX = pos.x + halfSize;\r\n            const centerZ = pos.z + halfSize;\r\n            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', centerX, centerZ);\r\n            const yPosition = (terrainHeight || 0) + this.config.elevationOffset;\r\n\r\n            const cellMesh = cellMeshPool[index];\r\n            cellMesh.material = cellMaterial;\r\n            cellMesh.position.set(centerX, yPosition, centerZ);\r\n            cellMesh.visible = true;\r\n            this.activeMeshes.push(cellMesh);\r\n\r\n            const borderMesh = borderMeshPool[index];\r\n            borderMesh.material = borderMaterial;\r\n            borderMesh.position.set(centerX, yPosition, centerZ);\r\n            borderMesh.visible = true;\r\n            this.activeMeshes.push(borderMesh);\r\n        });\r\n\r\n        if (unitPositions && unitPositions.length > 0) {\r\n            unitPositions.slice(0, this.config.maxCells).forEach((pos, index) => {\r\n                if (index >= this.unitMeshPool.length) return;\r\n\r\n                // Get terrain height at the unit position\r\n                const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);\r\n                const yPosition = (terrainHeight || 0) + this.config.unitElevationOffset;\r\n\r\n                const unitMesh = this.unitMeshPool[index];\r\n                unitMesh.material = unitMaterial;\r\n                unitMesh.position.set(pos.x, yPosition, pos.z);\r\n                unitMesh.visible = true;\r\n                this.activeMeshes.push(unitMesh);\r\n            });\r\n        }\r\n\r\n        this.previewGroup.visible = true;\r\n        this.startAnimation();\r\n    }\r\n    \r\n    hideAllMeshes() {\r\n        this.activeMeshes.length = 0;\r\n        \r\n        [...this.placementCellMeshPool, ...this.placementBorderMeshPool, ...this.footprintCellMeshPool, ...this.footprintBorderMeshPool, ...this.unitMeshPool].forEach(mesh => {\r\n            mesh.visible = false;\r\n        });\r\n    }\r\n    \r\n    startAnimation() {\r\n        if (this.animationId) {\r\n            cancelAnimationFrame(this.animationId);\r\n        }\r\n        \r\n        const startTime = performance.now();\r\n        const animate = () => {\r\n            if (!this.previewGroup.visible) {\r\n                this.animationId = null;\r\n                return;\r\n            }\r\n            \r\n            const elapsed = (performance.now() - startTime) / 1000;\r\n            const scale = 1 + Math.sin(elapsed * 2) * 0.05;\r\n            \r\n            this.activeMeshes.forEach(mesh => {\r\n                if (mesh.visible) {\r\n                    mesh.scale.setScalar(scale);\r\n                }\r\n            });\r\n            \r\n            this.animationId = requestAnimationFrame(animate);\r\n        };\r\n        \r\n        this.animationId = requestAnimationFrame(animate);\r\n    }\r\n    \r\n    hide() {\r\n        this.previewGroup.visible = false;\r\n        this.hideAllMeshes();\r\n        \r\n        if (this.animationId) {\r\n            cancelAnimationFrame(this.animationId);\r\n            this.animationId = null;\r\n        }\r\n    }\r\n    \r\n    clear() {\r\n        this.hide();\r\n        this.isActive = false;\r\n    }\r\n    \r\n    updateConfig(newConfig) {\r\n        Object.assign(this.config, newConfig);\r\n        \r\n        if (newConfig.cellOpacity !== undefined) {\r\n            this.materials.validCell.opacity = newConfig.cellOpacity;\r\n            this.materials.invalidCell.opacity = newConfig.cellOpacity;\r\n        }\r\n        \r\n        if (newConfig.borderOpacity !== undefined) {\r\n            this.materials.validBorder.opacity = newConfig.borderOpacity;\r\n            this.materials.invalidBorder.opacity = newConfig.borderOpacity;\r\n        }\r\n    }\r\n    \r\n    dispose() {\r\n        this.clear();\r\n        \r\n        if (this.animationId) {\r\n            cancelAnimationFrame(this.animationId);\r\n        }\r\n        \r\n        if (this.previewGroup.parent) {\r\n            this.previewGroup.parent.remove(this.previewGroup);\r\n        }\r\n        \r\n        Object.values(this.geometryPool).forEach(geometry => {\r\n            if (geometry.dispose) {\r\n                geometry.dispose();\r\n            }\r\n        });\r\n        \r\n        Object.values(this.materials).forEach(material => {\r\n            if (material.dispose) {\r\n                material.dispose();\r\n            }\r\n        });\r\n        \r\n        this.cellMeshPool = [];\r\n        this.borderMeshPool = [];\r\n        this.unitMeshPool = [];\r\n        this.activeMeshes = [];\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/PlacementPreview.js",
        "fileName": "PlacementPreview"
      },
      "EnemyStrategy": {
        "script": "class EnemyStrategy {\r\n    constructor() {\r\n        this.current = null;\r\n        this.history = [];\r\n        this.playerCounters = new Map();\r\n        \r\n        // Strategy definitions with weights and preferences\r\n        this.strategies = {\r\n            balanced: {\r\n                name: 'Balanced',\r\n                weights: { \r\n                    hp: 0.3, \r\n                    damage: 0.4, \r\n                    range: 0.2, \r\n                    speed: 0.1,\r\n                    armor: 0.0,\r\n                    elemental: 0.0,\r\n                    poison: 0.0\r\n                },\r\n                unitTypePreferences: {},\r\n                description: 'Well-rounded army composition',\r\n                maxUnitsMultiplier: 1.0,\r\n                valueThreshold: null\r\n            },\r\n            counter: {\r\n                name: 'Counter Strategy',\r\n                weights: {},\r\n                unitTypePreferences: {},\r\n                description: 'Counters player\\'s last strategy',\r\n                maxUnitsMultiplier: 1.2,\r\n                valueThreshold: null\r\n            },\r\n            starter: {\r\n                name: 'Opening Gambit',\r\n                weights: { \r\n                    hp: 0.2, \r\n                    damage: 0.3, \r\n                    range: 0.3, \r\n                    speed: 0.2,\r\n                    armor: 0.0,\r\n                    elemental: 0.0,\r\n                    poison: 0.0\r\n                },\r\n                unitTypePreferences: {},\r\n                maxUnitsToPlace: 2,\r\n                description: 'Simple opening with 2 random units',\r\n                maxUnitsMultiplier: 0.5,\r\n                valueThreshold: 0.4\r\n            },\r\n            aggressive: {\r\n                name: 'All-Out Attack',\r\n                weights: {\r\n                    hp: 0.1,\r\n                    damage: 0.6,\r\n                    range: 0.2,\r\n                    speed: 0.1,\r\n                    armor: 0.0,\r\n                    elemental: 0.0,\r\n                    poison: 0.0\r\n                },\r\n                unitTypePreferences: { archer: 1.5, mage: 1.3 },\r\n                description: 'Focus on high damage output',\r\n                maxUnitsMultiplier: 1.3,\r\n                valueThreshold: null\r\n            },\r\n            defensive: {\r\n                name: 'Fortress Defense',\r\n                weights: {\r\n                    hp: 0.5,\r\n                    damage: 0.2,\r\n                    range: 0.1,\r\n                    speed: 0.0,\r\n                    armor: 0.2,\r\n                    elemental: 0.0,\r\n                    poison: 0.0\r\n                },\r\n                unitTypePreferences: { tank: 2.0 },\r\n                description: 'Focus on survivability and armor',\r\n                maxUnitsMultiplier: 0.8,\r\n                valueThreshold: null\r\n            },\r\n            elemental: {\r\n                name: 'Elemental Mastery',\r\n                weights: {\r\n                    hp: 0.2,\r\n                    damage: 0.3,\r\n                    range: 0.2,\r\n                    speed: 0.1,\r\n                    armor: 0.0,\r\n                    elemental: 0.2,\r\n                    poison: 0.0\r\n                },\r\n                unitTypePreferences: { mage: 2.5 },\r\n                description: 'Focus on elemental damage',\r\n                maxUnitsMultiplier: 1.1,\r\n                valueThreshold: null\r\n            }\r\n        };\r\n        \r\n        // Unit categorization patterns\r\n        this.unitPatterns = {\r\n            tank: {\r\n                idPatterns: ['_s_'],\r\n                statRequirements: { hp: 200, armor: 5 },\r\n                tags: ['heavy', 'shield', 'guard', 'knight']\r\n            },\r\n            archer: {\r\n                idPatterns: ['_d_'],\r\n                statRequirements: { range: 50 },\r\n                tags: ['bow', 'archer', 'ranger', 'marksman']\r\n            },\r\n            mage: {\r\n                idPatterns: ['_i_'],\r\n                statRequirements: {},\r\n                elementalUnits: true,\r\n                tags: ['mage', 'wizard', 'sorcerer', 'elemental']\r\n            },\r\n            fast: {\r\n                idPatterns: [],\r\n                statRequirements: { speed: 55 },\r\n                tags: ['scout', 'cavalry', 'runner']\r\n            },\r\n            ranged: {\r\n                idPatterns: [],\r\n                statRequirements: { range: 50 },\r\n                tags: ['ranged', 'projectile']\r\n            }\r\n        };\r\n        \r\n        // Strategy selection weights based on game state\r\n        this.selectionWeights = {\r\n            round1: { starter: 1.0 },\r\n            earlyGame: { balanced: 0.4, aggressive: 0.3, counter: 0.3 },\r\n            midGame: { counter: 0.5, balanced: 0.2, aggressive: 0.2, defensive: 0.1 },\r\n            lateGame: { counter: 0.6, elemental: 0.2, aggressive: 0.1, defensive: 0.1 }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Select the best strategy for the current game state\r\n     * @param {number} round - Current round number\r\n     * @param {Array} playerPlacements - Player's unit placements\r\n     * @param {Object} gameState - Additional game state information\r\n     * @returns {string} Selected strategy key\r\n     */\r\n    selectStrategy(round, playerPlacements, gameState = {}) {\r\n        // Always use starter strategy for round 1\r\n        if (round === 1) {\r\n            return 'starter';\r\n        }\r\n        \r\n        // Try counter strategy if we have player data\r\n        if (round > 1 && playerPlacements.length > 0) {\r\n            const counterStrategy = this.getCounterStrategy(playerPlacements);\r\n            if (counterStrategy) {\r\n                return 'counter';\r\n            }\r\n        }\r\n        \r\n        // Select based on game phase and weighted probabilities\r\n        const gamePhase = this.determineGamePhase(round, gameState);\r\n        const weights = this.selectionWeights[gamePhase] || this.selectionWeights.midGame;\r\n        \r\n        return this.weightedRandomSelection(weights);\r\n    }\r\n    \r\n    /**\r\n     * Determine current game phase based on round and state\r\n     * @param {number} round - Current round number\r\n     * @param {Object} gameState - Game state information\r\n     * @returns {string} Game phase identifier\r\n     */\r\n    determineGamePhase(round, gameState) {\r\n        if (round <= 2) return 'earlyGame';\r\n        if (round <= 5) return 'midGame';\r\n        return 'lateGame';\r\n    }\r\n    \r\n    /**\r\n     * Select strategy using weighted random selection\r\n     * @param {Object} weights - Strategy weights\r\n     * @returns {string} Selected strategy key\r\n     */\r\n    weightedRandomSelection(weights) {\r\n        const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);\r\n        let random = Math.random() * totalWeight;\r\n        \r\n        for (const [strategy, weight] of Object.entries(weights)) {\r\n            random -= weight;\r\n            if (random <= 0) {\r\n                return strategy;\r\n            }\r\n        }\r\n        \r\n        return 'balanced'; // Fallback\r\n    }\r\n    \r\n    /**\r\n     * Generate counter strategy based on player army analysis\r\n     * @param {Array} playerPlacements - Player's unit placements\r\n     * @returns {string|null} Counter strategy or null if no clear counter\r\n     */\r\n    getCounterStrategy(playerPlacements) {\r\n        const playerStats = this.analyzePlayerArmy(playerPlacements);\r\n        \r\n        if (playerPlacements.length === 0) {\r\n            return null;\r\n        }\r\n        \r\n        // Store player analysis for learning\r\n        this.playerCounters.set('lastAnalysis', playerStats);\r\n        \r\n        // Tank-heavy counter: Use mages and elemental damage\r\n        if (playerStats.tankHeavy) {\r\n            this.strategies.counter.unitTypePreferences = { mage: 2.5 };\r\n            this.strategies.counter.weights = { \r\n                elemental: 0.4, \r\n                damage: 0.4,\r\n                range: 0.2,\r\n                hp: 0.0,\r\n                speed: 0.0,\r\n                armor: 0.0,\r\n                poison: 0.0\r\n            };\r\n            this.strategies.counter.description = 'Countering player tanks with elemental mages';\r\n            return 'counter';\r\n        }\r\n        \r\n        // Archer-heavy counter: Use fast tanks and cavalry\r\n        if (playerStats.archerHeavy) {\r\n            this.strategies.counter.unitTypePreferences = { tank: 2.0, fast: 1.5 };\r\n            this.strategies.counter.weights = { \r\n                hp: 0.4, \r\n                armor: 0.3,\r\n                speed: 0.3,\r\n                damage: 0.0,\r\n                range: 0.0,\r\n                elemental: 0.0,\r\n                poison: 0.0\r\n            };\r\n            this.strategies.counter.description = 'Countering player archers with armored units';\r\n            return 'counter';\r\n        }\r\n        \r\n        // Mage-heavy counter: Use fast archers and anti-magic\r\n        if (playerStats.mageHeavy) {\r\n            this.strategies.counter.unitTypePreferences = { archer: 2.0, fast: 1.3 };\r\n            this.strategies.counter.weights = { \r\n                damage: 0.4, \r\n                range: 0.3,\r\n                speed: 0.3,\r\n                hp: 0.0,\r\n                armor: 0.0,\r\n                elemental: 0.0,\r\n                poison: 0.0\r\n            };\r\n            this.strategies.counter.description = 'Countering player mages with fast archers';\r\n            return 'counter';\r\n        }\r\n        \r\n        // Elemental-heavy counter: Use physical damage\r\n        if (playerStats.elementalHeavy) {\r\n            this.strategies.counter.unitTypePreferences = { tank: 1.5, archer: 1.5 };\r\n            this.strategies.counter.weights = {\r\n                hp: 0.3,\r\n                damage: 0.4,\r\n                armor: 0.2,\r\n                speed: 0.1,\r\n                range: 0.0,\r\n                elemental: 0.0,\r\n                poison: 0.0\r\n            };\r\n            this.strategies.counter.description = 'Countering elemental units with physical damage';\r\n            return 'counter';\r\n        }\r\n        \r\n        // Balanced army counter: Focus on superior positioning and damage\r\n        this.strategies.counter.unitTypePreferences = { \r\n            mage: 1.4, \r\n            archer: 1.3,\r\n            tank: 1.2\r\n        };\r\n        this.strategies.counter.weights = { \r\n            damage: 0.4,\r\n            hp: 0.2, \r\n            range: 0.2, \r\n            speed: 0.1,\r\n            armor: 0.1,\r\n            elemental: 0.0,\r\n            poison: 0.0\r\n        };\r\n        this.strategies.counter.description = 'Countering balanced army with damage focus';\r\n        return 'counter';\r\n    }\r\n    \r\n    /**\r\n     * Analyze player army composition and characteristics\r\n     * @param {Array} playerPlacements - Player's unit placements\r\n     * @returns {Object} Analysis results\r\n     */\r\n    analyzePlayerArmy(playerPlacements) {\r\n        const totalUnits = playerPlacements.reduce((sum, placement) => {\r\n            return sum + (placement.isSquad ? placement.squadUnits.length : 1);\r\n        }, 0);\r\n        \r\n        if (totalUnits === 0) return {};\r\n        \r\n        let tankCount = 0;\r\n        let mageCount = 0;\r\n        let archerCount = 0;\r\n        let fastCount = 0;\r\n        let elementalCount = 0;\r\n        let totalValue = 0;\r\n        let totalHP = 0;\r\n        let totalDamage = 0;\r\n        \r\n        playerPlacements.forEach(placement => {\r\n            const unit = placement.unitType;\r\n            const squadSize = placement.isSquad ? placement.squadUnits.length : 1;\r\n            \r\n            const category = this.categorizeUnit(unit);\r\n            switch (category) {\r\n                case 'tank': tankCount += squadSize; break;\r\n                case 'archer': archerCount += squadSize; break;\r\n                case 'mage': mageCount += squadSize; break;\r\n                case 'fast': fastCount += squadSize; break;\r\n            }\r\n            \r\n            if (this.isElementalUnit(unit)) {\r\n                elementalCount += squadSize;\r\n            }\r\n            \r\n            totalValue += (unit.value || 0) * squadSize;\r\n            totalHP += (unit.hp || 0) * squadSize;\r\n            totalDamage += (unit.damage || 0) * squadSize;\r\n        });\r\n        \r\n        const analysis = {\r\n            totalUnits,\r\n            tankCount,\r\n            mageCount,\r\n            archerCount,\r\n            fastCount,\r\n            elementalCount,\r\n            totalValue,\r\n            averageValue: totalValue / totalUnits,\r\n            averageHP: totalHP / totalUnits,\r\n            averageDamage: totalDamage / totalUnits,\r\n            \r\n            // Composition flags\r\n            tankHeavy: tankCount / totalUnits > 0.5,\r\n            mageHeavy: mageCount / totalUnits > 0.5,\r\n            archerHeavy: archerCount / totalUnits > 0.5,\r\n            fastHeavy: fastCount / totalUnits > 0.4,\r\n            elementalHeavy: elementalCount / totalUnits > 0.6,\r\n            balanced: Math.max(tankCount, mageCount, archerCount) / totalUnits < 0.6,\r\n            \r\n            // Army characteristics\r\n            highValue: totalValue / totalUnits > 100,\r\n            tanky: totalHP / totalUnits > 150,\r\n            glassCannon: totalDamage / totalHP > 0.5\r\n        };\r\n        \r\n        return analysis;\r\n    }\r\n    \r\n    /**\r\n     * Categorize a unit based on its properties\r\n     * @param {Object} unit - Unit definition\r\n     * @returns {string} Unit category\r\n     */\r\n    categorizeUnit(unit) {\r\n        const id = (unit.id || '').toLowerCase();\r\n        const title = (unit.title || '').toLowerCase();\r\n        \r\n        // Check ID patterns first\r\n        for (const [category, pattern] of Object.entries(this.unitPatterns)) {\r\n            if (pattern.idPatterns.some(p => id.includes(p))) {\r\n                return category;\r\n            }\r\n        }\r\n        \r\n        // Check stat requirements\r\n        if (this.unitPatterns.tank.statRequirements.hp <= (unit.hp || 0) &&\r\n            this.unitPatterns.tank.statRequirements.armor <= (unit.armor || 0)) {\r\n            return 'tank';\r\n        }\r\n        \r\n        if (this.unitPatterns.archer.statRequirements.range <= (unit.range || 0)) {\r\n            return 'archer';\r\n        }\r\n        \r\n        if (this.unitPatterns.fast.statRequirements.speed <= (unit.speed || 0)) {\r\n            return 'fast';\r\n        }\r\n        \r\n        // Check for elemental units (mages)\r\n        if (this.isElementalUnit(unit)) {\r\n            return 'mage';\r\n        }\r\n        \r\n        // Check title/name tags\r\n        for (const [category, pattern] of Object.entries(this.unitPatterns)) {\r\n            if (pattern.tags && pattern.tags.some(tag => title.includes(tag))) {\r\n                return category;\r\n            }\r\n        }\r\n        \r\n        // Default categorization based on primary stats\r\n        if (unit.range > 30) return 'ranged';\r\n        if (unit.speed > 50) return 'fast';\r\n        if (unit.hp > 120) return 'tank';\r\n        \r\n        return 'melee';\r\n    }\r\n    \r\n    /**\r\n     * Check if a unit uses elemental damage\r\n     * @param {Object} unit - Unit definition\r\n     * @returns {boolean} True if unit is elemental\r\n     */\r\n    isElementalUnit(unit) {\r\n        const element = (unit.element || 'physical').toLowerCase();\r\n        return element !== 'physical' && element !== '';\r\n    }\r\n    \r\n    /**\r\n     * Calculate unit efficiency score based on strategy weights\r\n     * @param {Object} unit - Unit definition\r\n     * @param {Object} strategyConfig - Strategy configuration\r\n     * @returns {number} Efficiency score\r\n     */\r\n    calculateUnitScore(unit, strategyConfig) {\r\n        let score = this.calculateEfficiency(unit, strategyConfig.weights);\r\n        \r\n        // Apply unit type preferences\r\n        if (strategyConfig.unitTypePreferences) {\r\n            const unitCategory = this.categorizeUnit(unit);\r\n            const multiplier = strategyConfig.unitTypePreferences[unitCategory] || 1.0;\r\n            score *= multiplier;\r\n        }\r\n        \r\n        // Apply strategy-specific bonuses\r\n        score *= this.getStrategyBonus(unit, strategyConfig);\r\n        \r\n        return score;\r\n    }\r\n    \r\n    /**\r\n     * Calculate base unit efficiency using weighted stats\r\n     * @param {Object} unit - Unit definition\r\n     * @param {Object} weights - Stat weights\r\n     * @returns {number} Base efficiency score\r\n     */\r\n    calculateEfficiency(unit, weights) {\r\n        const hp = unit.hp || 100;\r\n        const damage = unit.damage || 10;\r\n        const range = unit.range || 1;\r\n        const speed = unit.speed || 1;\r\n        const armor = unit.armor || 0;\r\n        const element = (unit.element || 'physical');        \r\n        const poison = element === 'poison' ? 1 : 0;\r\n        const physical = element === 'physical' ? 1 : 0;\r\n        const elemental = (physical + poison === 0) ? 1 : 0;\r\n\r\n        let combatValue = (hp * (weights.hp || 0)) + \r\n                         (damage * (weights.damage || 0)) + \r\n                         (range * (weights.range || 0)) + \r\n                         (speed * (weights.speed || 0)) + \r\n                         (armor * (weights.armor || 0)) + \r\n                         (elemental * (weights.elemental || 0)) + \r\n                         (poison * (weights.poison || 0));\r\n        \r\n        return combatValue / (unit.value || 1);\r\n    }\r\n    \r\n    /**\r\n     * Apply strategy-specific bonuses to unit score\r\n     * @param {Object} unit - Unit definition\r\n     * @param {Object} strategyConfig - Strategy configuration\r\n     * @returns {number} Bonus multiplier\r\n     */\r\n    getStrategyBonus(unit, strategyConfig) {\r\n        let bonus = 1.0;\r\n        \r\n        // Elemental strategy bonuses\r\n        if (strategyConfig.name === 'Elemental Mastery' && this.isElementalUnit(unit)) {\r\n            bonus *= 1.3;\r\n        }\r\n        \r\n        // Defensive strategy bonuses\r\n        if (strategyConfig.name === 'Fortress Defense' && (unit.hp || 0) > 150) {\r\n            bonus *= 1.2;\r\n        }\r\n        \r\n        // Aggressive strategy bonuses\r\n        if (strategyConfig.name === 'All-Out Attack' && (unit.damage || 0) > 30) {\r\n            bonus *= 1.2;\r\n        }\r\n        \r\n        return bonus;\r\n    }\r\n    \r\n    /**\r\n     * Get current strategy information\r\n     * @returns {Object} Strategy information\r\n     */\r\n    getCurrentStrategyInfo() {\r\n        const strategy = this.strategies[this.current];\r\n        return {\r\n            current: this.current,\r\n            name: strategy?.name || 'Unknown',\r\n            description: strategy?.description || 'No description',\r\n            weights: strategy?.weights || {},\r\n            preferences: strategy?.unitTypePreferences || {},\r\n            history: this.history.slice(-5)\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Update strategy history\r\n     * @param {number} round - Round number\r\n     * @param {string} strategy - Strategy used\r\n     * @param {Object} results - Battle results (optional)\r\n     */\r\n    updateHistory(round, strategy, results = {}) {\r\n        this.current = strategy;\r\n        this.history.push({\r\n            round,\r\n            strategy,\r\n            timestamp: Date.now(),\r\n            results\r\n        });\r\n        \r\n        // Keep history manageable\r\n        if (this.history.length > 10) {\r\n            this.history.shift();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Reset strategy state\r\n     */\r\n    reset() {\r\n        this.current = null;\r\n        this.history = [];\r\n        this.playerCounters.clear();\r\n    }\r\n    \r\n    /**\r\n     * Get strategy effectiveness analysis\r\n     * @returns {Object} Effectiveness data\r\n     */\r\n    getEffectivenessAnalysis() {\r\n        const strategyResults = new Map();\r\n        \r\n        this.history.forEach(entry => {\r\n            if (!strategyResults.has(entry.strategy)) {\r\n                strategyResults.set(entry.strategy, {\r\n                    uses: 0,\r\n                    wins: 0,\r\n                    effectiveness: 0\r\n                });\r\n            }\r\n            \r\n            const data = strategyResults.get(entry.strategy);\r\n            data.uses++;\r\n            \r\n            if (entry.results?.victory) {\r\n                data.wins++;\r\n            }\r\n            \r\n            data.effectiveness = data.wins / data.uses;\r\n        });\r\n        \r\n        return Object.fromEntries(strategyResults);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/EnemyStrategy.js",
        "fileName": "EnemyStrategy"
      },
      "MinHeap": {
        "script": "class MinHeap {\r\n    constructor() {\r\n        this.heap = [];\r\n    }\r\n    \r\n    push(item) {\r\n        this.heap.push(item);\r\n        this.bubbleUp(this.heap.length - 1);\r\n    }\r\n    \r\n    pop() {\r\n        if (this.heap.length === 0) return null;\r\n        if (this.heap.length === 1) return this.heap.pop();\r\n        \r\n        const min = this.heap[0];\r\n        this.heap[0] = this.heap.pop();\r\n        this.bubbleDown(0);\r\n        return min;\r\n    }\r\n    \r\n    bubbleUp(index) {\r\n        while (index > 0) {\r\n            const parentIndex = Math.floor((index - 1) / 2);\r\n            if (this.heap[index].f >= this.heap[parentIndex].f) break;\r\n            \r\n            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\r\n            index = parentIndex;\r\n        }\r\n    }\r\n    \r\n    bubbleDown(index) {\r\n        while (true) {\r\n            const leftChild = 2 * index + 1;\r\n            const rightChild = 2 * index + 2;\r\n            let smallest = index;\r\n            \r\n            if (leftChild < this.heap.length && this.heap[leftChild].f < this.heap[smallest].f) {\r\n                smallest = leftChild;\r\n            }\r\n            \r\n            if (rightChild < this.heap.length && this.heap[rightChild].f < this.heap[smallest].f) {\r\n                smallest = rightChild;\r\n            }\r\n            \r\n            if (smallest === index) break;\r\n            \r\n            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\r\n            index = smallest;\r\n        }\r\n    }\r\n    \r\n    isEmpty() {\r\n        return this.heap.length === 0;\r\n    }\r\n}\r\n\r\nif(typeof MinHeap != 'undefined'){\r\n        \r\n    if (typeof window !== 'undefined') {\r\n        window.MinHeap = MinHeap;\r\n    }\r\n\r\n    // Make available as ES module export (new for server)  \r\n    if (typeof module !== 'undefined' && module.exports) {\r\n        module.exports = MinHeap;\r\n    }\r\n\r\n    // Make available as ES6 export (also new for server)\r\n    if (typeof exports !== 'undefined') {\r\n        exports.default = MinHeap;\r\n        exports.MinHeap = MinHeap;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/MinHeap.js",
        "fileName": "MinHeap"
      }
    },
    "modals": {
      "aiPromptPanel": {
        "title": "AI Prompt Panel",
        "fileName": "aiPromptPanel",
        "html": "<h2>AI Object Generator</h2>\r\n                <div class=\"form-group\">\r\n                    <label for=\"ai-prompt-textarea\">Prompt:</label>\r\n                    <textarea id=\"ai-prompt-textarea\" rows=\"6\" placeholder=\"Enter your AI generation prompt\"></textarea>\r\n                    <textarea id=\"ai-pre-prompt-textarea\" rows=\"6\" placeholder=\"context\"></textarea>\r\n                </div>\r\n                <div class=\"actions\">\r\n                    <button id=\"send-ai-prompt-btn\" class=\"primary\">Send to AI</button>\r\n                    <button id=\"close-ai-prompt-modal\">Cancel</button>\r\n                </div>\r\n                <div class=\"preview-section\">\r\n                    <h3>AI Response Preview</h3>\r\n                    <textarea id=\"ai-response-preview\" rows=\"6\"></textarea>\r\n                    <div class=\"preview-actions\">\r\n                        <button id=\"apply-ai-response-btn\" class=\"primary\" style=\"display:none;\">Apply Response</button>\r\n                    </div>\r\n                </div>",
        "filePath": "/global/modals/html/aiPromptPanel.html"
      },
      "moveAllShapes": {
        "title": "Move All Shapes",
        "fileName": "moveAllShapes",
        "html": "\r\n<h3>Move All Shapes</h3>\r\n<div class=\"form-row\">\r\n    <label for=\"move-x\">X Offset:</label>\r\n    <input type=\"number\" id=\"move-x\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-y\">Y Offset:</label>\r\n    <input type=\"number\" id=\"move-y\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-z\">Z Offset:</label>\r\n    <input type=\"number\" id=\"move-z\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n    <button id=\"move-cancel\">Cancel</button>\r\n    <button id=\"move-apply\">Apply</button>\r\n</div>\r\n",
        "filePath": "/global/modals/html/moveAllShapes.html"
      },
      "compilerModal": {
        "title": "Compiler Modal",
        "fileName": "compilerModal",
        "filePath": "/global/modals/html/compilerModal.html",
        "html": "\n<div class=\"modal-header\">\n    <h2>Compile Game</h2>\n</div>\n<div class=\"modal-body\">\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileIncludeMetadata\" />\n            Include metadata file\n        </label>\n    </div>\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileCreateZip\" />\n            Download as zip file\n        </label>\n    </div>\n    <div class=\"compilation-output\" id=\"compilationOutput\" style=\"display: none;\">\n        <h3>Output:</h3>\n        <pre id=\"compilationLog\"></pre>\n    </div>\n</div>\n<div class=\"modal-footer\">\n    <button class=\"btn btn-primary\" onclick=\"window.compilerModule.compile()\">\n        Compile\n    </button>\n    <button class=\"btn btn-secondary\" onclick=\"this.closest('.modal').classList.remove('show')\">\n        Cancel\n    </button>\n</div>"
      },
      "generateIsometric": {
        "title": "Generate Isometric Sprites",
        "fileName": "generateIsometric",
        "html": " <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>                 <div class=\"form-row\">                     <label for=\"iso-frustum\">Frustum Size:</label>                     <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-distance\">Distance:</label>                     <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-size\">Sprite Size:</label>                     <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">                 </div>                 <div style=\"display: flex; gap: 10px; margin-top: 20px;\">                     <button id=\"iso-cancel\">Cancel</button>                     <button id=\"iso-generate\">Generate</button>                 </div>           ",
        "filePath": "/global/modals/html/generateIsometric.html"
      },
      "addTerrainType": {
        "title": "Add Terrain Type",
        "fileName": "addTerrainType",
        "html": "\r\n<h4 id=\"formTitle\">Add Terrain Type</h4>\r\n<input type=\"hidden\" id=\"editingType\" value=\"\">\r\n<div class=\"form-group\">\r\n    <label for=\"terrainType\">Type:</label>\r\n    <input type=\"text\" id=\"terrainType\" placeholder=\"grass, water, etc.\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainColor\">Color:</label>\r\n    <input type=\"text\" id=\"terrainColorText\">\r\n    <input type=\"color\" id=\"terrainColor\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainImage\">Sprite Sheet:</label>\r\n    <input type=\"textarea\" id=\"terrainImage\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainTexture\">Texture:</label>\r\n    <select id=\"terrainTexture\"></select>\r\n</div>\r\n<div class=\"form-group\">\r\n    <img id=\"terrain-image-display\" alt=\"Terrain Image\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainBuildable\">Buildable:</label>\r\n    <input type=\"checkbox\" id=\"terrainBuildable\">\r\n</div>\r\n<div class=\"form-actions\">\r\n    <button id=\"saveTerrainBtn\" class=\"primary\">Save</button>\r\n    <button id=\"cancelTerrainBtn\">Cancel</button>\r\n</div>\r\n<input type=\"hidden\" id=\"editingId\">\r\n",
        "filePath": "/global/modals/html/addTerrainType.html"
      },
      "rotateShapes": {
        "title": "Rotate Shapes",
        "fileName": "rotateShapes",
        "html": "\r\n                <h3>Rotate All Shapes</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-angle\">Angle (degrees):</label>\r\n                    <input type=\"number\" id=\"rotate-angle\" value=\"0\" step=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-axis\">Axis:</label>\r\n                    <select id=\"rotate-axis\">\r\n                        <option value=\"x\">X</option>\r\n                        <option value=\"y\" selected>Y</option>\r\n                        <option value=\"z\">Z</option>\r\n                    </select>\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"rotate-cancel\">Cancel</button>\r\n                    <button id=\"rotate-apply\">Apply</button>\r\n                </div>\r\n",
        "filePath": "/global/modals/html/rotateShapes.html"
      },
      "generateIsoSprites": {
        "title": "Generate Spritesheet",
        "fileName": "generateIsoSprites",
        "html": "\r\n                <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-frustum\">Frustum Size:</label>\r\n                    <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-distance\">Distance:</label>\r\n                    <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-size\">Sprite Size:</label>\r\n                    <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"iso-cancel\">Cancel</button>\r\n                    <button id=\"iso-generate\">Generate</button>\r\n                </div>\r\n",
        "filePath": "/global/modals/html/generateIsoSprites.html"
      }
    },
    "renderers": {
      "MapRenderer": {
        "script": "class MapRenderer extends engine.Component {\r\n   \r\n    init({worldObjects, level, levelData, isEditor, palette, canvas}) {   \r\n\r\n        this.config = this.game.getCollections().configs.game;\r\n        this.imageManager = this.game.imageManager;\r\n        this.worldObjects = worldObjects;\r\n        this.selectedTowerType = null;\r\n        this.hoverCell = { x: -1, y: -1 };\r\n        this.showRange = false;\r\n        this.isMapCached = false; // Flag to track if map needs redrawing\r\n        this.currentLevel = level;\r\n        if(levelData){\r\n            this.level = levelData;\r\n        } else {\r\n            this.level = this.game.getCollections().levels[this.currentLevel];\r\n        }\r\n        this.tileMap = this.level.tileMap;\r\n        this.palette = palette;\r\n\r\n        // Create off-screen canvas for caching\r\n        if(!this.config.is3D || isEditor) {\r\n            this.canvasBuffer = canvas;\r\n            this.ctx = this.canvasBuffer.getContext('2d');\r\n            this.mapCacheCanvas = document.createElement('canvas');\r\n            this.mapCacheCanvas.width = this.config.canvasWidth;\r\n            this.mapCacheCanvas.height = this.config.canvasHeight;\r\n            this.mapCacheCtx = this.mapCacheCanvas.getContext('2d');\r\n\r\n            \r\n            this.envCacheCanvasBG = document.createElement('canvas');\r\n            this.envCacheCanvasBG.width = this.config.canvasWidth;\r\n            this.envCacheCanvasBG.height = this.config.canvasHeight / 2;\r\n            this.envCacheCtxBG = this.envCacheCanvasBG.getContext('2d');\r\n\r\n            this.envCacheCanvasFG = document.createElement('canvas');\r\n            this.envCacheCanvasFG.width = this.config.canvasWidth;\r\n            this.envCacheCanvasFG.height = this.config.canvasHeight / 2;\r\n            this.envCacheCtxFG = this.envCacheCanvasFG.getContext('2d');\r\n        }\r\n        this.terrainCanvas = this.game.terrainTileMapper.canvas;\r\n        this.terrainCanvas.width = this.tileMap.size * this.config.gridSize;\r\n        this.terrainCanvas.height = this.tileMap.size * this.config.gridSize;\r\n        this.terrainCtx = this.terrainCanvas.getContext('2d');\r\n \r\n        this.terrainTileMapper = this.game.terrainTileMapper;\r\n        this.game.mapRenderer = this;\r\n        this.isometric = this.game.getCollections().configs.game.isIsometric;\r\n        this.render(this.level.tileMap, this.game.state.paths);\r\n    }\r\n\r\n    draw(){}\r\n    render(tileMapData) {\r\n        if(!this.isMapCached){\r\n            this.terrainCtx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);\r\n                \r\n            // Draw the map onto the cache canvas\r\n            this.drawTileMap(tileMapData);\r\n            this.renderEnvironment();\r\n            \r\n            //this.drawPaths(this.terrainCacheCtx, paths);\r\n        }\r\n        // Mark cache as valid\r\n        this.isMapCached = true;\r\n    }\r\n    renderEnvironment() {\r\n        if (!this.game.scene || this.tileMap.environmentObjects.length === 0) return;\r\n    \r\n        // Group environment objects by type\r\n        const objectsByType = {};\r\n        this.tileMap.environmentObjects.forEach(obj => {\r\n            if (!objectsByType[obj.type]) {\r\n                objectsByType[obj.type] = [];\r\n            }\r\n            objectsByType[obj.type].push(obj);\r\n        });\r\n    \r\n        // Process each type separately\r\n        Object.entries(objectsByType).forEach(([type, objects]) => {\r\n            // Load the model for this type\r\n            const referenceModel = this.game.modelManager.getModel(\"worldObjects\", type);\r\n            if (!referenceModel) return;\r\n    \r\n            // Find all meshes and store their complete transform data\r\n            const meshData = [];\r\n            referenceModel.updateMatrixWorld(true); // Ensure world matrices are up to date\r\n    \r\n            referenceModel.traverse(node => {\r\n                if (node.isMesh) {\r\n                    const parent = node.parent;\r\n                    const parentWorldMatrix = parent.matrixWorld.clone();\r\n                    const localMatrix = node.matrix.clone();\r\n    \r\n                    // Get transform relative to model root\r\n                    const relativeMatrix = new THREE.Matrix4();\r\n                    relativeMatrix.copy(parentWorldMatrix);\r\n                    relativeMatrix.multiply(localMatrix);\r\n    \r\n                    meshData.push({\r\n                        mesh: node,\r\n                        relativeMatrix: relativeMatrix\r\n                    });\r\n                }\r\n            });\r\n            if (meshData.length === 0) return;\r\n    \r\n            // Create instanced meshes for this type\r\n            const instancedMeshes = meshData.map(({ mesh, relativeMatrix }) => {\r\n                const instancedMesh = new THREE.InstancedMesh(\r\n                    mesh.geometry,\r\n                    mesh.material,\r\n                    objects.length // Number of instances for this type\r\n                );\r\n                instancedMesh.userData.relativeMatrix = relativeMatrix;\r\n                instancedMesh.castShadow = true;\r\n                instancedMesh.receiveShadow = true;\r\n                return instancedMesh;\r\n            });\r\n    \r\n            // Set positions for all instances of this type\r\n            const matrix = new THREE.Matrix4();\r\n            const dummy = new THREE.Object3D();\r\n    \r\n            objects.forEach((obj, index) => {\r\n                // Get pixel color at object position\r\n                let hexColor = this.tileMap.terrainTypes[this.tileMap.extensionTerrainType].color.slice(1);\r\n                let numColor = parseInt(hexColor, 16); // Convert hex string to number, e.g., 0xaa3311\r\n\r\n                let r = (numColor >> 16) & 0xff; // Red channel\r\n                let g = (numColor >> 8) & 0xff;  // Green channel   \r\n                let b = numColor & 0xff;         // Blue channel\r\n                if (g > r && g > b) {\r\n                    dummy.position.set(\r\n                        obj.x, \r\n                        this.game.getCollections().heightMaps[this.game.getCollections().worlds[this.level.world].heightMap].heightStep * this.tileMap.extensionTerrainType, \r\n                        obj.y\r\n                    );\r\n                    dummy.rotation.y = Math.random() * Math.PI * 2;\r\n                    const scale = 0.8 + Math.random() * 0.4;\r\n                    dummy.scale.set(scale, scale, scale);\r\n                    dummy.updateMatrix();\r\n            \r\n                    // Apply transforms while preserving mesh relationships\r\n                    instancedMeshes.forEach(instancedMesh => {\r\n                        matrix.copy(dummy.matrix);\r\n                        matrix.multiply(instancedMesh.userData.relativeMatrix);\r\n                        instancedMesh.setMatrixAt(index, matrix);\r\n                    });\r\n                }\r\n            });\r\n    \r\n            // Add instanced meshes to the scene\r\n            instancedMeshes.forEach(instancedMesh => {\r\n                instancedMesh.instanceMatrix.needsUpdate = true;\r\n                this.game.scene.add(instancedMesh);\r\n            });\r\n        });\r\n    }\r\n    renderBG(tileMapData, paths) {\r\n        this.clearMap(tileMapData);\r\n        // Generate cache if not already done\r\n        if (!this.isMapCached) {\r\n            this.cacheMap(tileMapData, paths, this.isometric);            \r\n        }        \r\n  \r\n        // Draw cached map image to main canvas\r\n      \r\n       this.ctx.drawImage( this.terrainCanvas, ( this.config.canvasWidth - this.terrainCanvas.width) / 2, ( this.config.canvasHeight - this.terrainCanvas.height) / 2 );\r\n\r\n       //this.ctx.drawImage(this.terrainCanvas, 0, 0);\r\n        //this.ctx.drawImage(this.mapCacheCanvas, 0,  -this.config.canvasHeight / 2);\r\n        this.ctx.drawImage(this.envCacheCanvasBG, 0, 0);\r\n    }\r\n    renderFG() {  \r\n        this.ctx.drawImage(this.envCacheCanvasFG, 0, this.config.canvasHeight / 2);\r\n    }    \r\n    setLevel(level) {\r\n        this.currentLevel = level;\r\n        this.terrainImages = this.imageManager.getImages(\"levels\", level);\r\n\r\n    }\r\n\r\n    drawTileMap(tileMapData) {\r\n        this.terrainTileMapper.draw(tileMapData.terrainMap);\r\n    }\r\n    clearMap(tileMapData) {\r\n        this.ctx.clearRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n        this.ctx.fillStyle = tileMapData.terrainTypes[tileMapData.extensionTerrainType].color;       \r\n        this.ctx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n    }\r\n    // Call this when map data changes or on initialization\r\n    cacheMap(tileMapData, paths, isometric) {\r\n        this.terrainCtx.clearRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n                   \r\n        // Clear the cache canvas\r\n        this.mapCacheCtx.clearRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n        \r\n        // Draw the map onto the cache canvas\r\n        this.drawTileMap(tileMapData, isometric);\r\n        this.drawPaths(this.mapCacheCtx, paths);\r\n        this.drawEnvironment(tileMapData.terrainMap.length, tileMapData.terrainMap.length * tileMapData.terrainMap.length);\r\n        \r\n        // Mark cache as valid\r\n        this.isMapCached = true;\r\n    }\r\n\r\n    drawMap(tileMap) {\r\n\r\n        this.mapCacheCtx.fillStyle = '#4a7c59';\r\n        this.mapCacheCtx.fillRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n        const tileWidth = this.config.gridSize;\r\n        const tileHeight = this.config.gridSize * 0.5;\r\n        \r\n        for (let y = 0; y < tileMap.length; y++) {\r\n            for (let x = 0; x < tileMap[y].length; x++) {\r\n                const tile = tileMap[y][x];\r\n                \r\n                // Use translator to get iso coordinates\r\n                const isoCoords = this.game.translator.gridToIso(x, y);\r\n                const isoX = isoCoords.x;\r\n                const isoY = isoCoords.y;\r\n                \r\n                this.mapCacheCtx.fillStyle = tile.color;\r\n                this.mapCacheCtx.beginPath();\r\n                this.mapCacheCtx.moveTo(isoX, isoY);\r\n                this.mapCacheCtx.lineTo(isoX + tileWidth / 2, isoY + tileHeight / 2);\r\n                this.mapCacheCtx.lineTo(isoX, isoY + tileHeight);\r\n                this.mapCacheCtx.lineTo(isoX - tileWidth / 2, isoY + tileHeight / 2);\r\n                this.mapCacheCtx.closePath();\r\n                this.mapCacheCtx.fill();\r\n                this.mapCacheCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';\r\n                this.mapCacheCtx.stroke();\r\n            }\r\n        }\r\n        \r\n       \r\n        this.drawEnvironment(tileMap.length);\r\n    }\r\n\r\n    drawPaths(ctx, paths) {\r\n        const tileHeight = this.config.gridSize * 0.5;\r\n        ctx.strokeStyle = '#ffd166';\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        \r\n        paths.forEach(path => {\r\n            // First point in path\r\n            const firstIsoCoords = this.game.translator.gridToIso(path[0].x, path[0].y);\r\n            const firstIsoX = firstIsoCoords.x;\r\n            const firstIsoY = firstIsoCoords.y + tileHeight / 2; // Add half tile height for center of tile\r\n            \r\n            ctx.moveTo(firstIsoX, firstIsoY);\r\n            \r\n            // Remaining points in path\r\n            path.forEach(location => {\r\n                const isoCoords = this.game.translator.gridToIso(location.x, location.y);\r\n                const isoX = isoCoords.x;\r\n                const isoY = isoCoords.y + tileHeight / 2; // Add half tile height for center of tile\r\n                \r\n                ctx.lineTo(isoX, isoY);\r\n            });\r\n        });\r\n        \r\n        ctx.stroke();\r\n    }\r\n\r\n    drawEnvironment(boardSize, amountToDraw) {\r\n\r\n        let itemAmt = amountToDraw;\r\n        let environmentTypes = [];\r\n        for(let envType in this.worldObjects){\r\n            environmentTypes.push(envType);\r\n        }\r\n        this.envCacheCtxBG.clearRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n        this.envCacheCtxFG.clearRect(0, 0, this.config.canvasWidth, this.config.canvasHeight);\r\n        \r\n        let items = [];\r\n        \r\n        // Check if we have stored environment objects\r\n        if (this.tileMap.environmentObjects && this.tileMap.environmentObjects.length > 0) {\r\n            // Use the stored objects\r\n            this.tileMap.environmentObjects.forEach(obj => {\r\n                const images = this.imageManager.getImages(\"environment\", obj.type);\r\n                if (images && images.idle && images.idle[0] && images.idle[0][obj.imageIndex]) {\r\n                    items.push({\r\n                        img: images.idle[0][obj.imageIndex],\r\n                        x: obj.x,\r\n                        y: obj.y\r\n                    });\r\n                }\r\n            });\r\n        } else {       \r\n            // for(let i = 0; i < itemAmt; i++) {\r\n            //     // Define the game board boundaries\r\n            //     const boardMinX = 0;\r\n            //     const boardMaxX = boardSize * this.config.gridSize;\r\n            //     const boardMinY = 0;\r\n            //     const boardMaxY = boardSize * this.config.gridSize;\r\n                \r\n            //     // Generate a random position that's outside the board but within a reasonable distance\r\n            //     let x, y;\r\n                \r\n            //     // Expand the area where we can place objects\r\n            //     const expandAmount = boardSize * this.config.gridSize; // Adjust this value as needed\r\n                \r\n            //     // Randomly choose whether to place on x-axis or y-axis outside the board\r\n            //     if (Math.random() < 0.5) {\r\n            //         // Place on the left or right of the board\r\n            //         x = Math.random() < 0.5 ?\r\n            //             boardMinX - Math.random() * expandAmount : // Left side\r\n            //             boardMaxX + Math.random() * expandAmount;  // Right side\r\n                    \r\n            //         // Allow y to be anywhere, including outside the board\r\n            //         y = boardMinY - expandAmount + Math.random() * (boardMaxY - boardMinY + 2 * expandAmount);\r\n            //     } else {\r\n            //         // Place on the top or bottom of the board\r\n            //         y = Math.random() < 0.5 ?\r\n            //             boardMinY - Math.random() * expandAmount : // Top side\r\n            //             boardMaxY + Math.random() * expandAmount;  // Bottom side\r\n                    \r\n            //         // Allow x to be anywhere, including outside the board\r\n            //         x = boardMinX - expandAmount + Math.random() * (boardMaxX - boardMinX + 2 * expandAmount);\r\n            //     }\r\n                \r\n            //     // Double-check that the position is actually outside the board\r\n            //     if (x < boardMinX || x > boardMaxX || y < boardMinY || y > boardMaxY) {\r\n            //         const type = environmentTypes[Math.floor(Math.random() * environmentTypes.length)];\r\n            //         const images = this.imageManager.getImages(\"environment\", type);\r\n            //         if(images){\r\n            //             items.push( { img: images.idle[0][parseInt(Math.random()*images.idle[0].length)], x: x, y: y});\r\n            //         }\r\n            //     } else {\r\n            //         i--; // Position inside board, try again\r\n            //     }\r\n            // }\r\n        }\r\n\r\n        items.sort((a, b) => {\r\n            return (a.y * boardSize + a.x) - (b.y * boardSize + b.x)\r\n        });\r\n\r\n        items.forEach((item) => {            \r\n            // Convert pixel to isometric\r\n            const isoPos = this.game.translator.pixelToIso(item.x, item.y);\r\n            const image = item.img;\r\n            const imgWidth = image.width;\r\n            const imgHeight = image.height;\r\n            \r\n            const drawX = isoPos.x;\r\n            const drawY = isoPos.y;\r\n            if( drawY < this.config.canvasHeight / 2 ) {\r\n                this.envCacheCtxBG.drawImage(image, drawX - imgWidth / 2, drawY - imgHeight / 2);\r\n            } else if(drawY - this.config.canvasHeight / 2 - imgHeight / 2 > 0) {//prevent trees in FG from getting chopped off at the top if they are too close to the middle of the frame.\r\n  \r\n                this.envCacheCtxFG.drawImage(image, drawX - imgWidth / 2, drawY - this.config.canvasHeight / 2 - imgHeight / 2);\r\n            }\r\n        });\r\n    }\r\n\r\n}",
        "filePath": "/global/renderers/js/MapRenderer.js",
        "fileName": "MapRenderer"
      },
      "Renderer": {
        "fileName": "Renderer",
        "script": "class Renderer extends engine.Component {\r\n\r\n    \r\n  init( { objectType, spawnType, setDirection = -2}) {\r\n        if(this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.images = this.game.imageManager.getImages(objectType, spawnType);  \r\n        this.setDirection = setDirection;\r\n        this.currentDirection = 0; // Default direction (will be 0-7 now)\r\n        // Rotated direction zones 45 degrees counter-clockwise\r\n        // Each zone covers a 45-degree arc (/4 radians)\r\n        this.directionZones = [\r\n            { min: Math.PI/8, max: 3*Math.PI/8 },     // 0: Down-Right (Southeast)\r\n            { min: 3*Math.PI/8, max: 5*Math.PI/8 },   // 1: Down\r\n            { min: 5*Math.PI/8, max: 7*Math.PI/8 },   // 2: Down-Left (Southwest)\r\n            { min: 7*Math.PI/8, max: -7*Math.PI/8 },  // 3: Left (West)\r\n            { min: -7*Math.PI/8, max: -5*Math.PI/8 }, // 4: Up-Left (Northwest)\r\n            { min: -5*Math.PI/8, max: -3*Math.PI/8 }, // 5: Up\r\n            { min: -3*Math.PI/8, max: -Math.PI/8 },   // 6: Up-Right (Northeast)\r\n            { min: -Math.PI/8, max: Math.PI/8 }       // 7: Right (East)\r\n        ];\r\n        this.isometric = this.game.getCollections().configs.game.isIsometric;\r\n    }\r\n\r\n    draw() {\r\n        if(this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        if( this.setDirection < 0 ) {\r\n            const dx = this.parent.transform.position.x - this.parent.lastPosition.x; // Change in x\r\n            const dy = this.parent.transform.position.y - this.parent.lastPosition.y; // Change in y\r\n            \r\n            // Only update direction if there's movement\r\n            if (Math.abs(dx) > 0.001 || Math.abs(dy) > 0.001) {\r\n                // Calculate angle of movement in radians\r\n                const angle = Math.atan2(dy, dx);\r\n                \r\n                // Determine which of the 8 directional zones the angle falls into\r\n                for (let i = 0; i < this.directionZones.length; i++) {\r\n                    const zone = this.directionZones[i];\r\n                    \r\n                    // Special handling for the West zone which wraps around from PI to -PI\r\n                    if (i === 3) {\r\n                        if (angle >= zone.min || angle <= zone.max) {\r\n                            this.currentDirection = i;\r\n                            break;\r\n                        }\r\n                    } \r\n                    // Normal zone check\r\n                    else if (angle >= zone.min && angle < zone.max) {\r\n                        this.currentDirection = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            this.currentDirection = this.setDirection;\r\n        }\r\n        let direction = this.currentDirection + (this.isometric ? 0 : -1);\r\n        if(direction == -1 ) direction = this.images.length - 1;//wrap around\r\n        // Draw the image for the current direction\r\n        if (this.images && this.images.length > direction) {\r\n            const image = this.images[direction];\r\n            if (image) {\r\n                const imgWidth = image.width;\r\n                const imgHeight = image.height;\r\n                \r\n                const drawX = this.parent.transform.drawPosition.x - imgWidth / 2;\r\n                let drawY = this.parent.transform.drawPosition.y - imgHeight / 2;\r\n                if( this.parent.transform.position.z ) {\r\n                   drawY -= this.parent.transform.position.z;                   \r\n                }\r\n                this.game.ctx.drawImage(image, drawX, drawY);\r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/global/renderers/js/Renderer.js"
      },
      "Health": {
        "fileName": "Health",
        "script": "class Health extends engine.Component {\r\n       \r\n  init(){\r\n        let statsComp = this.parent.getComponent('stats');\r\n        this.hp = statsComp.stats.hp;\r\n        \r\n        statsComp.addStat('maxHp', this.hp);\r\n    }\r\n\r\n    update() {        \r\n        if (this.hp <= 0){            \r\n            this.parent.destroy();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        let imageSize = this.game.getCollections().configs.game.imageSize;\r\n        let statsComp = this.parent.getComponent('stats');\r\n        const healthPercentage = this.hp / statsComp.stats.maxHp;\r\n        const barWidth = 30;\r\n        this.game.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';\r\n\r\n        // const isoPos = this.game.translator.pixelToIso(this.parent.transform.position.x, this.parent.transform.position.y)\r\n\r\n        // this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - imageSize * .3, barWidth, 5);\r\n        // if( healthPercentage >= 0 ) {\r\n        //     this.game.ctx.fillStyle = healthPercentage > 0.5 ? 'rgba(0, 255, 0, 0.5)' : healthPercentage > 0.25 ? 'rgba(255, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';\r\n        //     this.game.ctx.fillRect(isoPos.x - barWidth/2, isoPos.y - imageSize * .3, barWidth * healthPercentage, 5);\r\n        // }\r\n    }\r\n}",
        "filePath": "/global/renderers/js/Health.js"
      },
      "ModelRenderer": {
        "title": "Model Renderer",
        "fileName": "ModelRenderer",
        "parameters": "[\"objectType\",\"spawnType\"]",
        "script": "class ModelRenderer extends engine.Component {\r\n    async init({ objectType, spawnType, frameDuration }) {\r\n        if (!this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.objectType = objectType;\r\n        this.spawnType = spawnType;\r\n        this.animationState = 'idle';\r\n        this.currentFrameIndex = 0;\r\n        this.frameTime = 0;\r\n        this.frameDuration = frameDuration || 0.17;\r\n        this.lastDirection = -1;\r\n        this.currentAnimationTime = 0;\r\n        \r\n        this.fadeTime = 0.3;\r\n        this.minAnimationTime = 0;//this.fadeTime * 2;\r\n        // Load animation and model data\r\n        this.animationData = this.game.getCollections()[objectType]?.[spawnType]?.render?.animations;\r\n        this.modelData = this.game.getCollections()[objectType]?.[spawnType]?.render?.model;\r\n        this.isGLTF = this.modelData[Object.keys(this.modelData)[0]].shapes[0].type === \"gltf\";\r\n        this.clock = new THREE.Clock();\r\n        this.clock.start();\r\n\r\n        // Get the model\r\n        this.model = await this.game.modelManager.getModel(objectType, spawnType);\r\n        this.skeletonUtils = THREE_.SkeletonUtils;\r\n        this.throwTimer = -1;\r\n        this.leapTimer = -1;\r\n        this.leapTime = 1;\r\n        this.throwTime = 2;\r\n        // Clone the model once\r\n        this.modelGroup = !this.isGLTF ? this.skeletonUtils.clone(this.model) : this.model;\r\n        this.game.scene.add(this.modelGroup);\r\n        this.modelGroup.position.set(0, -10000, 0);\r\n        this.isRunning = false;\r\n        // Initialize AnimationMixer and actions if GLTF\r\n        if (this.isGLTF) {\r\n            await this.setupAnimationMixer();\r\n        }\r\n        // Set initial animation\r\n        this.setAnimation('idle');\r\n    }\r\n\r\n\r\n    async setupAnimationMixer() {\r\n        // Find the mixer and animations from userData\r\n        let mixer, animations;\r\n        this.modelGroup.traverse(object => {\r\n            if (object.userData.mixer) {\r\n                mixer = object.userData.mixer;\r\n                animations = object.userData.animations;\r\n            }\r\n        });\r\n\r\n        this.mixer = mixer;\r\n        this.animationActions = {};\r\n\r\n        // Create AnimationActions for each animation\r\n        const animationNames = Object.keys(this.animationData);\r\n        animationNames.forEach( async (name) => {\r\n            const animModel = await this.game.modelManager.getAnimation(this.objectType, this.spawnType, name);\r\n            \r\n            if(!animModel) return;\r\n            let animModelAnimations;\r\n            animModel.traverse(object => {\r\n                if (object.userData.mixer) {\r\n                    animModelAnimations = object.userData.animations;\r\n                }\r\n            });\r\n            if (animModelAnimations?.length > 0) {\r\n                const clip = animModelAnimations[0];\r\n                if (clip) {\r\n                    const action = this.mixer.clipAction(clip);\r\n                    action.setLoop(THREE.LoopRepeat);\r\n                    action.enabled = true;\r\n                    this.animationActions[name] = action;\r\n                }\r\n            }\r\n        });\r\n\r\n        // Store the current action\r\n        this.currentAction = null;\r\n    }\r\n\r\n    setAnimation(animationName, speed = 1, minAnimationTime = 0) {\r\n     \r\n        if (!this.animationData[animationName]) {\r\n            console.warn(`Animation '${animationName}' not found, defaulting to 'idle'`);\r\n            animationName = 'idle';\r\n            if (!this.animationData[animationName]) {\r\n                const availableAnims = Object.keys(this.animationData);\r\n                animationName = availableAnims.length > 0 ? availableAnims[0] : null;\r\n                if (!animationName) {\r\n                    console.error('No animations available for this model');\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.animationState !== animationName && \r\n            (this.currentAnimationTime >= this.minAnimationTime)) {\r\n            this.animationState = animationName;\r\n            this.currentAnimationTime = 0;\r\n            this.minAnimationTime = minAnimationTime;\r\n            if (this.isGLTF && this.mixer) {\r\n                const newAction = this.animationActions[animationName];\r\n                if (!newAction) {\r\n                    console.error(`No AnimationAction for ${animationName}`, this.animationActions);\r\n                    return;\r\n                }\r\n                if(newAction != this.currentAction){\r\n                    this.crossfadeTo(newAction, speed);\r\n                    this.currentAction.setEffectiveTimeScale(speed);\r\n                } else {\r\n                    this.currentAction.stop();\r\n                    this.currentAction.time = 0;\r\n                    this.currentAction.enabled = true;\r\n                    this.currentAction.setEffectiveTimeScale(speed);\r\n                    this.currentAction.play();\r\n                }\r\n\r\n\r\n            } else {\r\n                this.currentFrameIndex = 0;\r\n                this.frameTime = 0;\r\n                this.updateModelFrame();\r\n            }\r\n        }\r\n    }\r\n\r\n    crossfadeTo(newAction, speed) {\r\n        if(!newAction) return;\r\n        const previousAction = this.currentAction;\r\n        this.currentAction = newAction;\r\n        if (previousAction && previousAction !== newAction) {\r\n            previousAction.setEffectiveWeight(1);\r\n\r\n            newAction.setEffectiveWeight(1);\r\n\r\n            previousAction.play();\r\n            newAction.play();\r\n\r\n            previousAction.crossFadeTo(newAction, this.fadeTime / speed, true);\r\n\r\n            setTimeout(() => {\r\n                if (previousAction && this.currentAction !== previousAction) {\r\n                    previousAction.stop();\r\n                }\r\n            }, this.fadeTime * 1000 / speed);\r\n        } else {\r\n            newAction.enabled = true;\r\n            newAction.time = 0;\r\n            newAction.setEffectiveTimeScale(speed); // Apply animation speed\r\n            newAction.setEffectiveWeight(1);\r\n            newAction.play();\r\n        }\r\n    }\r\n\r\n    draw() {\r\n        if(!this.modelGroup) return;\r\n        if (!this.game.getCollections().configs.game.is3D) {\r\n            return;\r\n        }\r\n        this.currentAnimationTime += this.game.deltaTime;\r\n        // Update AnimationMixer for GLTF models\r\n        if (this.isGLTF && this.mixer) {\r\n            this.mixer.update(this.game.deltaTime);\r\n        }\r\n\r\n        this.updateDirection();\r\n        if (this.throwTimer >= 0) {\r\n            this.throwTimer += this.game.deltaTime;\r\n            if (this.throwTimer > this.throwTime) {\r\n                this.throwTimer = -1;\r\n            } else if (this.animationState !== 'throw') {\r\n                this.setAnimation('throw', this.throwSpeed);\r\n            }\r\n        }\r\n\r\n        if (this.leapTimer >= 0) {\r\n            this.leapTimer += this.game.deltaTime;\r\n            if (this.leapTimer > this.leapTime) {\r\n                this.leapTimer = -1;\r\n            } else if (this.animationState !== 'leap') {\r\n                this.setAnimation('leap', this.leapSpeed);\r\n            }\r\n        }\r\n        // Update skeleton for skinned meshes\r\n        this.modelGroup.traverse(object => {\r\n            if (object.isSkinnedMesh && object.skeleton) {\r\n                object.skeleton.update();\r\n            }\r\n        });\r\n\r\n        // Update frame-based animations for non-GLTF models\r\n        if (!this.isGLTF) {\r\n            this.frameTime += this.game.deltaTime;\r\n            const effectiveFrameDuration = this.frameDuration; // Scale frame duration\r\n            if (this.frameTime >= effectiveFrameDuration) {\r\n                this.frameTime -= effectiveFrameDuration;\r\n                this.advanceFrame();\r\n            }\r\n        }\r\n        this.modelGroup.scale.set(\r\n            this.parent.transform.scale.x,\r\n            this.parent.transform.scale.y,\r\n            this.parent.transform.scale.z\r\n        );\r\n        // Update position of model to match entity position\r\n        if (this.parent && this.parent.transform.position) {\r\n            this.modelGroup.position.copy(this.parent.transform.position);          \r\n\r\n            // Handle rotation based on movement direction\r\n            this.updateDirection();\r\n        }\r\n    }\r\n\r\n    jump(speed = 1) {\r\n        if(this.leapTimer > 0) {\r\n            return;\r\n        }\r\n        this.leapSpeed = speed;\r\n        this.leapTimer = 0;\r\n        this.leapTime = (this.animationActions['leap'].getClip().duration / speed);; // Scale leap time inversely with speed        \r\n        this.setAnimation('leap', speed,  this.leapTime);\r\n    }\r\n    throw(speed = 1) {        \r\n        if(this.throwTimer > 0){\r\n            return;\r\n        }\r\n        if(this.animationActions['throw']){\r\n                \r\n            this.throwSpeed = speed;\r\n            this.throwTimer = 0;\r\n            this.throwTime = (this.animationActions['throw'].getClip().duration / speed);            \r\n            this.setAnimation('throw', speed, this.throwTime * .5);\r\n        }\r\n    \r\n    }\r\n    updateDirection() {\r\n        if (this.parent && this.parent.transform.quaternion) {\r\n            this.modelGroup.quaternion.copy(this.parent.transform.quaternion);\r\n        }\r\n    }\r\n\r\n\r\n    advanceFrame() {\r\n        const frames = this.animationData[this.animationState];\r\n        if (!frames || frames.length === 0) return;\r\n\r\n        this.currentFrameIndex = (this.currentFrameIndex + 1) % frames.length;\r\n        this.updateModelFrame();\r\n    }\r\n\r\n    updateModelFrame() {\r\n        // Get current animation and frame\r\n        const frames = this.animationData[this.animationState];\r\n        if (!frames?.length) return;\r\n\r\n        const frameData = frames[this.currentFrameIndex] || {};\r\n\r\n        // Traverse the modelGroup to apply transformations\r\n        this.modelGroup.traverse((obj) => {\r\n            // Handle group-level transformations (apply to group objects)\r\n            if (!obj.isMesh && obj.name && this.modelData[obj.name]) {\r\n                const groupName = obj.name;\r\n                const groupData = frameData[groupName];\r\n                const modelGroupData = this.modelData[groupName];\r\n                this.updateObjectTransforms(obj, groupData, modelGroupData);\r\n            }\r\n\r\n            // Handle shape-level transformations (apply to meshes)\r\n            if (obj.isMesh && obj.userData?.index >= 0 && obj.parent?.name) {\r\n                const groupName = obj.parent.name;\r\n                const index = obj.userData.index;\r\n                const groupData = frameData[groupName];\r\n                const modelGroupData = this.modelData[groupName];\r\n                let shape;\r\n                if (groupData?.shapes) {\r\n                    shape = groupData.shapes.find(s => s.id === index);\r\n                }\r\n                const modelShape = modelGroupData?.shapes?.[index];\r\n\r\n                if (shape || modelShape) {\r\n                    this.updateShapeTransforms(obj, shape, modelShape);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    updateObjectTransforms(obj, groupData, modelGroupData) {\r\n        if (!modelGroupData) return;\r\n\r\n        // Position\r\n        const pos = groupData?.position || modelGroupData.position || { x: 0, y: 0, z: 0 };\r\n        obj.position.set(\r\n            pos.x ?? modelGroupData.position?.x ?? 0,\r\n            pos.y ?? modelGroupData.position?.y ?? 0,\r\n            pos.z ?? modelGroupData.position?.z ?? 0\r\n        );\r\n\r\n        // Rotation\r\n        const rot = groupData?.rotation || modelGroupData.rotation || { x: 0, y: 0, z: 0 };\r\n        obj.rotation.set(\r\n            rot.x ?? modelGroupData.rotation?.x ?? 0,\r\n            rot.y ?? modelGroupData.rotation?.y ?? 0,\r\n            rot.z ?? modelGroupData.rotation?.z ?? 0\r\n        );\r\n\r\n        // Scale\r\n        const scale = groupData?.scale || modelGroupData.scale || { x: 1, y: 1, z: 1 };\r\n        obj.scale.set(\r\n            scale.x ?? modelGroupData.scale?.x ?? 1,\r\n            scale.y ?? modelGroupData.scale?.y ?? 1,\r\n            scale.z ?? modelGroupData.scale?.z ?? 1\r\n        );\r\n    }\r\n\r\n    updateShapeTransforms(obj, shape, modelShape) {\r\n        if (!modelShape) return;\r\n\r\n        // Position (local to group)\r\n        obj.position.set(\r\n            shape?.x ?? modelShape.x ?? 0,\r\n            shape?.y ?? modelShape.y ?? 0,\r\n            shape?.z ?? modelShape.z ?? 0\r\n        );\r\n\r\n        // Rotation (local to group, convert degrees to radians)\r\n        obj.rotation.set(\r\n            ((shape?.rotationX ?? modelShape.rotationX) || 0) * Math.PI / 180,\r\n            ((shape?.rotationY ?? modelShape.rotationY) || 0) * Math.PI / 180,\r\n            ((shape?.rotationZ ?? modelShape.rotationZ) || 0) * Math.PI / 180\r\n        );\r\n\r\n        // Scale (local to group)\r\n        obj.scale.set(\r\n            shape?.scaleX ?? modelShape.scaleX ?? 1,\r\n            shape?.scaleY ?? modelShape.scaleY ?? 1,\r\n            shape?.scaleZ ?? modelShape.scaleZ ?? 1\r\n        );\r\n    }\r\n\r\n    destroy() {\r\n        if (this.modelGroup) {\r\n            // Stop and clean up all animation actions\r\n            if (this.mixer) {\r\n                Object.values(this.animationActions).forEach(action => {\r\n                    action.stop();\r\n                });\r\n                this.mixer.uncacheRoot(this.modelGroup);\r\n                this.mixer = null;\r\n            }\r\n\r\n            // Remove model from scene\r\n            if (this.game.scene) {\r\n                this.game.scene.remove(this.modelGroup);\r\n            }\r\n\r\n            // Dispose of geometries and materials\r\n            this.modelGroup.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n\r\n            // Clear children\r\n            while (this.modelGroup.children.length > 0) {\r\n                this.modelGroup.remove(this.modelGroup.children[0]);\r\n            }\r\n\r\n            this.modelGroup = null;\r\n        }\r\n    }\r\n}",
        "filePath": "/global/renderers/js/ModelRenderer.js"
      }
    },
    "themes": {
      "cyberpunk": {
        "title": "Cyber Punk",
        "fileName": "cyberpunk",
        "css": "/* Default Cyberpunk Theme */ @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&display=swap');  body {     font-family: 'Orbitron', 'Rajdhani', sans-serif;     background-color: #0a0a16;     color: #00f0ff; }  .sidebar {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px #00f0ff, inset 0 0 20px rgba(0, 240, 255, 0.2); }  .object-item {     background-color: rgba(0, 0, 35, 0.6);     border-left: 2px solid #fe01fe;     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(254, 1, 254, 0.2);     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(254, 1, 254, 0.3);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 8px rgba(254, 1, 254, 0.5); }  .editor {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #fe01fe;     box-shadow: 0 0 15px rgba(254, 1, 254, 0.3); }  #three-js-container {     border: 1px solid rgba(0, 240, 255, 0.5); }  .preview-canvas-container {     border: 1px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.3); }  .preview {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(0, 240, 255, 0.5); }  .camera-controls {     background: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff; }  .camera-controls button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff; }  .camera-controls .color-picker {     border: 1px solid #00f0ff; }  .camera-controls .size-slider {     background: #101028;     border: 1px solid #00f0ff; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #fe01fe; }  input, textarea, select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff;     text-transform: uppercase;     letter-spacing: 1px; }  button:after {     background: linear-gradient(to right, transparent, rgba(0, 240, 255, 0.2), transparent); }  button:hover {     background-color: rgba(0, 240, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5), 0 0 20px rgba(0, 240, 255, 0.2);     transform: translateY(-2px); }  button:hover:after {     transform: translateX(100%) rotate(30deg); }  button.primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  button.primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5), 0 0 20px rgba(254, 1, 254, 0.2); }  button.danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  button.danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5), 0 0 20px rgba(255, 0, 76, 0.2); }  button.active {     border: 1px solid #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);     color: #00ff9d; }  .modal {     background-color: rgba(0, 0, 20, 0.85);     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(15, 15, 35, 0.9);     border: 1px solid #00f0ff;     box-shadow: 0 0 30px rgba(0, 240, 255, 0.3), 0 0 60px rgba(0, 240, 255, 0.1); }  .property-list {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6); }  .tab-navigation {     border-bottom: 1px solid #00f0ff; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(0, 240, 255, 0.1); }  .tab.active {     border-bottom: 3px solid #fe01fe;     box-shadow: 0 5px 10px -5px rgba(254, 1, 254, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(0, 0, 35, 0.6);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.2); }  #grid-display {     background-color: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px rgba(0, 240, 255, 0.3); }  .success-message {     color: #00ff9d;     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(255, 0, 76, 0.1);     border-left: 4px solid #ff004c;     box-shadow: 0 0 10px rgba(255, 0, 76, 0.2); }  .main-content-container {     background-color: #080815;     color: #00f0ff; }  .content-sidebar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-right: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-left: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  .grid-background {     background: #05051a;     background-image: radial-gradient(rgba(0, 240, 255, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-bottom: 1px solid #00f0ff; }  .btn {     border: 1px solid #00f0ff;     background-color: rgba(0, 240, 255, 0.1);     color: #00f0ff;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(0, 240, 255, 0.2);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  .btn-primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  .btn-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .btn-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  .btn-secondary {     background-color: rgba(0, 240, 255, 0.15);     border: 1px solid #00f0ff; }  .btn-secondary:hover {     background-color: rgba(0, 240, 255, 0.25);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5); }  .btn-special {     background-color: rgba(0, 255, 157, 0.2);     border: 1px solid #00ff9d;     color: #00ff9d; }  .btn-special:hover {     background-color: rgba(0, 255, 157, 0.3);     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(0, 240, 255, 0.2); }  .shape-item {     background-color: rgba(0, 0, 35, 0.6);     border: 1px solid #00f0ff; }  .shape-item:hover {     background-color: rgba(0, 240, 255, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(0, 255, 157, 0.1);     border-color: #00ff9d;     color: #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.3); }  #inspector {     background: rgba(20, 20, 50, 0.8);     border-top: 1px solid #00f0ff; }  .form-row label {     color: #fe01fe; }  .form-row input, .form-row select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  .scene-info {     background: rgba(0, 0, 20, 0.8);     color: #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);     border: 1px solid #00f0ff; }  .button-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .button-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  h2, h3 {     color: #fe01fe;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #00f0ff;     text-shadow: 0 0 5px rgba(254, 1, 254, 0.7); }  h2:hover, h3:hover {     text-shadow: -2px 0 #00f0ff, 2px 0 #ff004c; }  .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(0, 240, 255, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(0, 240, 255, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(0, 0, 35, 0.8);     border: 1px solid #00f0ff;     color: #00ff9d;     font-family: 'Courier New', monospace;     padding: 15px;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.2), inset 0 0 30px rgba(0, 0, 35, 0.5); }  .ref-value-item {     background-color: #405060; }  .remove-ref-btn {     background: none;     border: none;     color: #ff6b6b;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(0, 0, 35, 0.6); }  ::-webkit-scrollbar-thumb {     background: #00f0ff;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #fe01fe; }  button:active::before {     content: '';     position: absolute;     top: 0;     left: 0;     width: 100%;     height: 100%;     background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.4), transparent);     animation: loading 1s infinite; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/cyberpunk.css"
      },
      "professional": {
        "title": "Professional",
        "fileName": "professional",
        "css": "/* Professional Theme */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #1a1a2e;     color: #e6e6fa;     line-height: 1.6; }  .sidebar {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.2); }  .object-item {     background-color: rgba(34, 34, 54, 0.8);     border-left: 2px solid #8a4af0;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(138, 74, 240, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(138, 74, 240, 0.25);     border-left: 3px solid #8a4af0;     box-shadow: 0 0 6px rgba(138, 74, 240, 0.4); }  .editor {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #three-js-container {     border: 1px solid rgba(75, 94, 135, 0.6); }  .preview-canvas-container {     border: 1px solid #8a4af0;     box-shadow: 0 4px 12px rgba(138, 74, 240, 0.1); }  .preview {     background-color: rgba(34, 34, 54, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(75, 94, 135, 0.5); }  .camera-controls {     background: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87; }  .camera-controls button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .camera-controls .color-picker {     border: 1px solid #4b5e87; }  .camera-controls .size-slider {     background: #2a2a42;     border: 1px solid #4b5e87; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #8a4af0; }  input, textarea, select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #8a4af0;     box-shadow: 0 0 8px rgba(138, 74, 240, 0.3); }  button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  button.primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  button.danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  button.danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  button.active {     border: 1px solid #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.4);     color: #00cc99; }  .modal {     background-color: rgba(26, 26, 46, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 8px 24px rgba(75, 94, 135, 0.2); }  .property-list {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8); }  .tab-navigation {     border-bottom: 1px solid #4b5e87; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(75, 94, 135, 0.2); }  .tab.active {     border-bottom: 2px solid #8a4af0;     box-shadow: 0 4px 8px -4px rgba(138, 74, 240, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(34, 34, 54, 0.8);     border-left: 3px solid #8a4af0;     box-shadow: 0 2px 6px rgba(138, 74, 240, 0.1); }  #grid-display {     background-color: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .success-message {     color: #00cc99;     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(240, 74, 74, 0.15);     border-left: 3px solid #f04a4a;     box-shadow: 0 2px 6px rgba(240, 74, 74, 0.1); }  .main-content-container {     background-color: #1f1f38;     color: #e6e6fa; }  .content-sidebar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-right: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-left: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .grid-background {     background: #1a1a2e;     background-image: radial-gradient(rgba(75, 94, 135, 0.15) 1px, transparent 1px);     background-size: 30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-bottom: 1px solid #4b5e87; }  .btn {     border: 1px solid #4b5e87;     background-color: rgba(75, 94, 135, 0.3);     color: #e6e6fa;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  .btn-primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  .btn-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .btn-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  .btn-secondary {     background-color: rgba(75, 94, 135, 0.25);     border: 1px solid #4b5e87; }  .btn-secondary:hover {     background-color: rgba(75, 94, 135, 0.4);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .btn-special {     background-color: rgba(0, 204, 153, 0.3);     border: 1px solid #00cc99;     color: #e6e6fa; }  .btn-special:hover {     background-color: rgba(0, 204, 153, 0.5);     box-shadow: 0 2px 8px rgba(0, 204, 153, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(75, 94, 135, 0.3); }  .shape-item {     background-color: rgba(34, 34, 54, 0.8);     border: 1px solid #4b5e87;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(75, 94, 135, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(0, 204, 153, 0.15);     border-color: #00cc99;     color: #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.3); }  #inspector {     background: rgba(34, 34, 54, 0.95);     border-top: 1px solid #4b5e87; }  .form-row label {     color: #8a4af0; }  .form-row input, .form-row select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1); }  .scene-info {     background: rgba(26, 26, 46, 0.9);     color: #e6e6fa;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15);     border: 1px solid #4b5e87; }  .button-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .button-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  h2, h3 {     color: #8a4af0;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #4b5e87;     text-shadow: 0 0 4px rgba(138, 74, 240, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(34, 34, 54, 0.8); }  ::-webkit-scrollbar-thumb {     background: #4b5e87;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #8a4af0; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional.css"
      },
      "videoGame2": {
        "title": "Video Game 2",
        "fileName": "videoGame2",
        "css": "/* retro-theme.css - Pixel Art Retro Video Game Theme */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base Styles */\r\nbody {\r\n    background-color: #1a1a1a; /* Dark retro background */\r\n    font-family: 'Press Start 2P', cursive; /* Pixelated font */\r\n    image-rendering: pixelated; /* Ensures crisp pixel art rendering */\r\n    color: #fff; /* Default text color */\r\n}\r\n\r\n/* Container */\r\n.container {\r\n    background: #2b2b2b; /* Retro gray */\r\n    border: 4px solid #000; /* Thick black border */\r\n    padding: .5em;\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    background: #3c3c3c; /* Mid-gray retro */\r\n    border: 4px solid #000;\r\n}\r\n\r\n.sidebar img {\r\n    image-rendering: pixelated;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n/* Object List */\r\n.object-item {\r\n    background: #5a5a5a; /* Darker gray */\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px; /* Smaller for pixel readability */\r\n}\r\n\r\n.object-item:hover, .object-item.selected {\r\n    background: #ffcc00; /* Bright retro yellow */\r\n    color: #000;\r\n}\r\n.object-type-item.selected {\r\n    color: #ffcc00;\r\n}\r\n\r\n/* Buttons */\r\nbutton {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    text-transform: uppercase; /* Retro game style */\r\n    transition: background 0.1s ease;\r\n}\r\n\r\nbutton:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\nbutton.primary {\r\n    background: #33cc33; /* Green for primary actions */\r\n}\r\n\r\nbutton.primary:hover {\r\n    background: #ffcc00; /* Yellow on hover */\r\n}\r\n\r\n/* Main Content */\r\n.main-content {\r\n    background: #2b2b2b;\r\n}\r\n\r\n/* Editor */\r\n.editor {\r\n    background: #3c3c3c;\r\n    border: 4px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Canvas and Grid Containers */\r\n#canvas-container, .grid-container {\r\n    background: #000; /* Black canvas background */\r\n    border: 4px solid #fff;\r\n}\r\n\r\n#canvas, #grid {\r\n    image-rendering: pixelated;\r\n    background: repeating-linear-gradient(\r\n        45deg,\r\n        #333 0px,\r\n        #333 10px,\r\n        #000 10px,\r\n        #000 20px\r\n    ); /* Retro checkerboard grid */\r\n}\r\n\r\n.scene-info {\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border: 2px solid #fff;\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 8px;\r\n}\r\n\r\n/* Toolbar */\r\n.toolbar {\r\n    background: #5a5a5a;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.btn {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    transition: background 0.1s ease;\r\n}\r\n\r\n.btn:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\n.btn.btn-danger {\r\n    background: #ff0000; /* Bright red */\r\n}\r\n\r\n.btn.btn-danger:hover {\r\n    background: #cc0000; /* Darker red */\r\n}\r\n\r\n.btn.btn-secondary {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.btn.btn-secondary:hover {\r\n    background: #9999ff; /* Lighter blue */\r\n}\r\n\r\n.btn.btn-special {\r\n    background: #ff00ff; /* Retro magenta */\r\n}\r\n\r\n.btn.btn-special:hover {\r\n    background: #cc00cc; /* Darker magenta */\r\n}\r\n\r\n/* Modals */\r\n.modal {\r\n    background: rgba(0, 0, 0, 0.8);\r\n}\r\n\r\n.modal-content {\r\n    background: #3c3c3c;\r\n    border: 4px solid #fff;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Form Elements */\r\n.form-group label {\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 10px;\r\n}\r\n\r\ninput, textarea, select {\r\n    background: #000;\r\n    border: 2px solid #fff;\r\n    color: #ffcc00; /* Retro yellow */\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n}\r\n\r\ninput[type=\"color\"] {\r\n    padding: 0; /* Fix color picker padding */\r\n    height: 20px; /* Consistent height */\r\n}\r\n\r\n/* Tabs */\r\n.tab-navigation {\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.tab {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.tab.active {\r\n    background: #ffcc00; /* Yellow for active tab */\r\n    color: #000;\r\n}\r\n\r\n/* Inspector and JSON Editor */\r\n#inspector, #json-editor {\r\n    background: #3c3c3c;\r\n    border: 2px solid #000;\r\n}\r\n\r\n#json-content {\r\n    background: #000;\r\n    color: #00ff00; /* Green for code-like text */\r\n}\r\n\r\n/* Translation Controls */\r\n.translation-controls button {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.translation-controls button:hover {\r\n    background: #9999ff;\r\n}\r\n\r\n/* Shape List */\r\n.shape-item {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.shape-item:hover {\r\n    background: #ffcc00;\r\n    color: #000;\r\n}\r\n\r\n.type-selector .object-item {\r\n  font-size: .6em;\r\n}\r\n\r\n/* codemirror-retro.css - Retro Pixel Art Theme for CodeMirror */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base CodeMirror Styles */\r\n.CodeMirror {\r\n    height: 100% !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important; /* Small size for pixel readability */\r\n    background: #000 !important; /* Black background like a CRT screen */\r\n    color: #00ff00 !important; /* Neon green default text */\r\n    border: 4px solid #fff !important; /* Thick white border */\r\n    image-rendering: pixelated; /* Crisp rendering */\r\n}\r\n.CodeMirror-gutters {\r\n background-color: #000;\r\n}\r\n\r\n/* Retro Theme Definition */\r\n.cm-s-retro .CodeMirror-gutters {\r\n    background: #1a1a1a !important; /* Dark gray gutter */\r\n    border-right: 2px solid #fff !important; /* White separator */\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-linenumber {\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n    padding: 0 5px !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-cursor {\r\n    border-left: 2px solid #ff3333 !important; /* Red blinking cursor */\r\n    animation: blink 1s step-end infinite; /* Retro blink effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-selected {\r\n    background: #ff3333 !important; /* Red selection highlight */\r\n    opacity: 0.5; /* Slightly transparent for retro effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-focused .CodeMirror-selected {\r\n    background: #ff3333 !important;\r\n}\r\n\r\n/* Syntax Highlighting */\r\n.cm-s-retro .cm-comment {\r\n    color: #6666ff !important; /* Blue for comments */\r\n    font-style: italic; /* Slight retro flair */\r\n}\r\n\r\n.cm-s-retro .cm-string {\r\n    color: #ffcc00 !important; /* Yellow for strings */\r\n}\r\n\r\n.cm-s-retro .cm-number {\r\n    color: #33cc33 !important; /* Green for numbers */\r\n}\r\n\r\n.cm-s-retro .cm-keyword {\r\n    color: #ff00ff !important; /* Magenta for keywords */\r\n    font-weight: bold; /* Bold for emphasis */\r\n}\r\n\r\n.cm-s-retro .cm-operator {\r\n    color: #fff !important; /* White for operators */\r\n}\r\n\r\n.cm-s-retro .cm-variable {\r\n    color: #00ff00 !important; /* Green for variables */\r\n}\r\n\r\n.cm-s-retro .cm-variable-2 {\r\n    color: #33cc33 !important; /* Lighter green for secondary variables */\r\n}\r\n\r\n.cm-s-retro .cm-def {\r\n    color: #ff00ff !important; /* Magenta for definitions */\r\n}\r\n\r\n.cm-s-retro .cm-property {\r\n    color: #ffcc00 !important; /* Yellow for properties */\r\n}\r\n\r\n.cm-s-retro .cm-function {\r\n    color: #ff00ff !important; /* Magenta for functions */\r\n}\r\n\r\n.cm-s-retro .cm-builtin {\r\n    color: #33cc33 !important; /* Green for built-ins */\r\n}\r\n\r\n.cm-s-retro .cm-tag {\r\n    color: #ff3333 !important; /* Red for tags (if HTML mode is used) */\r\n}\r\n\r\n.cm-s-retro .cm-attribute {\r\n    color: #ffcc00 !important; /* Yellow for attributes */\r\n}\r\n\r\n/* Matching Brackets */\r\n.cm-s-retro .CodeMirror-matchingbracket {\r\n    color: #33cc33 !important; /* Green for matching brackets */\r\n    border-bottom: 2px solid #33cc33 !important;\r\n    background: none !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-nonmatchingbracket {\r\n    color: #ff3333 !important; /* Red for non-matching brackets */\r\n    border-bottom: 2px solid #ff3333 !important;\r\n}\r\n\r\n/* Autocomplete Hints */\r\n.CodeMirror-hints {\r\n    background: #2b2b2b !important; /* Dark retro gray */\r\n    border: 2px solid #fff !important; /* White border */\r\n    color: #fff !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important;\r\n    box-shadow: 4px 4px 0 #000; /* Retro shadow effect */\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint {\r\n    color: #ffcc00 !important; /* Yellow for hint items */\r\n    padding: 5px !important;\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint-active {\r\n    background: #ff3333 !important; /* Red for selected hint */\r\n    color: #000 !important;\r\n}\r\n\r\n/* Scrollbars (minimal retro style) */\r\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar {\r\n    background: #3c3c3c !important;\r\n}\r\n\r\n.CodeMirror-scrollbar-filler {\r\n    background: #000 !important;\r\n}\r\n\r\n/* Animations */\r\n@keyframes blink {\r\n    50% { opacity: 0; }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videoGame2.css"
      },
      "aurora": {
        "title": "Aurora",
        "fileName": "aurora",
        "css": "/* Aurora Theme - Modern gradient-based design for GUTS Editor */\r\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap');\r\n\r\n:root {\r\n  /* Override editor module variables with Aurora theme */\r\n  --editor-primary: #10b981;\r\n  --editor-primary-hover: #059669;\r\n  --editor-secondary: #3b82f6;\r\n  --editor-secondary-hover: #2563eb;\r\n  --editor-danger: #f43f5e;\r\n  --editor-danger-hover: #e11d48;\r\n  --editor-success: #10b981;\r\n  --editor-warning: #f59e0b;\r\n\r\n  /* Aurora-specific colors */\r\n  --aurora-teal: #14b8a6;\r\n  --aurora-blue: #0ea5e9;\r\n  --aurora-purple: #8b5cf6;\r\n  --aurora-pink: #ec4899;\r\n\r\n  /* Background layers - darker for comfort */\r\n  --editor-bg-dark: #050810;\r\n  --editor-bg-medium: #0a0e1a;\r\n  --editor-bg-light: #0f172a;\r\n  --editor-bg-lighter: #1e293b;\r\n\r\n  /* Text colors - softer for eyes */\r\n  --editor-text-primary: #cbd5e1;\r\n  --editor-text-secondary: #94a3b8;\r\n  --editor-text-muted: #64748b;\r\n\r\n  /* Borders */\r\n  --editor-border-color: rgba(20, 184, 166, 0.12);\r\n  --editor-border-color-hover: rgba(20, 184, 166, 0.25);\r\n\r\n  /* Shadows with aurora glow - softer */\r\n  --editor-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);\r\n  --editor-shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\r\n  --editor-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);\r\n  --aurora-glow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  --aurora-glow-strong: 0 0 25px rgba(16, 185, 129, 0.3), 0 0 50px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Base body with aurora gradient background - darker and subtle */\r\nbody {\r\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\r\n  background-color: var(--editor-bg-dark);\r\n  color: var(--editor-text-primary);\r\n  background-image:\r\n    radial-gradient(ellipse at 20% 20%, rgba(16, 185, 129, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 80% 80%, rgba(59, 130, 246, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 50% 50%, rgba(139, 92, 246, 0.02) 0%, transparent 60%);\r\n  background-attachment: fixed;\r\n}\r\n\r\n/* Monospace font for code */\r\ninput[type=\"text\"],\r\ntextarea,\r\n.editor-module__textarea,\r\n.script-editor__code {\r\n  font-family: 'Fira Code', 'Monaco', 'Courier New', monospace;\r\n}\r\n\r\n/* Force dark backgrounds on all inputs - easy on the eyes */\r\ninput,\r\ntextarea,\r\nselect,\r\n.editor-module__input,\r\n.editor-module__textarea,\r\n.editor-module__select,\r\ninput[type=\"text\"],\r\ninput[type=\"number\"],\r\ninput[type=\"email\"],\r\ninput[type=\"password\"],\r\ninput[type=\"search\"],\r\ninput[type=\"url\"] {\r\n  background-color: var(--editor-bg-dark) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n/* Darker background for color pickers */\r\ninput[type=\"color\"],\r\n.editor-module__color-picker {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n}\r\n\r\n/* Sidebar styling with aurora glow */\r\n.sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Main editor area */\r\n.editor {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n/* Object items in sidebar - softer colors */\r\n.object-item {\r\n  background-color: transparent;\r\n  border-left: 2px solid transparent;\r\n  color: var(--editor-text-muted);\r\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\r\n}\r\n\r\n.object-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.05);\r\n  border-left-color: rgba(16, 185, 129, 0.5);\r\n  color: var(--editor-text-secondary);\r\n  transform: translateX(3px);\r\n}\r\n\r\n.object-item.selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), transparent);\r\n  border-left-color: var(--editor-primary);\r\n  color: var(--editor-text-primary);\r\n  box-shadow: var(--aurora-glow);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Buttons with aurora styling - much darker and easier on eyes */\r\nbutton {\r\n  font-family: 'Inter', sans-serif;\r\n  font-weight: 500;\r\n  text-transform: none;\r\n  letter-spacing: 0.02em;\r\n  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\nbutton:hover {\r\n  transform: translateY(-1px);\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\nbutton:active {\r\n  transform: translateY(0);\r\n}\r\n\r\nbutton.primary {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\nbutton.primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.18) !important;\r\n  box-shadow: 0 0 8px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\nbutton.danger {\r\n  background-color: rgba(244, 63, 94, 0.08) !important;\r\n  border-color: rgba(244, 63, 94, 0.3) !important;\r\n  color: rgba(244, 63, 94, 0.75) !important;\r\n}\r\n\r\nbutton.danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  box-shadow: 0 0 8px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n/* Editor module buttons - much darker with !important to override base styles */\r\n.editor-module__btn {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n.editor-module__btn--primary {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\n.editor-module__btn--primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--secondary {\r\n  background-color: rgba(59, 130, 246, 0.12) !important;\r\n  border-color: rgba(59, 130, 246, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--secondary:hover {\r\n  background-color: rgba(59, 130, 246, 0.18) !important;\r\n  box-shadow: 0 0 10px rgba(59, 130, 246, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--active {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.5) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.15) !important;\r\n}\r\n\r\n.editor-module__btn--danger {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  border-color: rgba(244, 63, 94, 0.35) !important;\r\n  color: rgba(244, 63, 94, 0.85) !important;\r\n}\r\n\r\n.editor-module__btn--danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.18) !important;\r\n  border-color: rgba(244, 63, 94, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--success {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--success:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--warning {\r\n  background-color: rgba(245, 158, 11, 0.12) !important;\r\n  border-color: rgba(245, 158, 11, 0.35) !important;\r\n  color: rgba(245, 158, 11, 0.9) !important;\r\n}\r\n\r\n.editor-module__btn--warning:hover {\r\n  background-color: rgba(245, 158, 11, 0.18) !important;\r\n  border-color: rgba(245, 158, 11, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(245, 158, 11, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--small {\r\n  background-color: rgba(15, 23, 42, 0.5) !important;\r\n}\r\n\r\n.editor-module__btn--small:hover {\r\n  background-color: rgba(15, 23, 42, 0.7) !important;\r\n}\r\n\r\n.editor-module__btn--icon {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn--icon:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n/* Form inputs with aurora accent - soft glow on focus */\r\ninput:focus,\r\ntextarea:focus,\r\nselect:focus,\r\n.editor-module__input:focus,\r\n.editor-module__select:focus,\r\n.editor-module__textarea:focus {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border-color: var(--editor-primary) !important;\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1) !important;\r\n  outline: none !important;\r\n}\r\n\r\n/* Range sliders - darker */\r\n.editor-module__range::-webkit-slider-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n.editor-module__range::-moz-range-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Modal styling */\r\n.modal {\r\n  background-color: rgba(10, 14, 26, 0.75);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n.modal-content {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-lg), var(--aurora-glow);\r\n}\r\n\r\n/* Property list and panels */\r\n.property-list {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n}\r\n\r\n.editor-module__panel {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n\r\n/* Section titles with aurora accent - softer */\r\n.editor-module__section-title,\r\n.editor-module__panel-title {\r\n  color: var(--editor-text-primary);\r\n  position: relative;\r\n  padding-bottom: 8px;\r\n}\r\n\r\n.editor-module__section-title::after,\r\n.editor-module__panel-title::after {\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 40px;\r\n  height: 2px;\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.6), transparent);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n/* Items with aurora hover effect - subtle */\r\n.editor-module__item:hover {\r\n  background-color: rgba(16, 185, 129, 0.04);\r\n  border-color: var(--editor-border-color-hover);\r\n  box-shadow: none;\r\n}\r\n\r\n.editor-module__item--active,\r\n.editor-module__item--selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.12), transparent);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Toolbar styling */\r\n.toolbar,\r\n.editor-module__toolbar {\r\n  background: linear-gradient(180deg, rgba(15, 23, 42, 0.8), rgba(10, 14, 26, 0.8));\r\n  border-bottom: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Grid background with aurora tint */\r\n.grid-background,\r\n.editor-module__grid-background {\r\n  background-image:\r\n    linear-gradient(rgba(16, 185, 129, 0.05) 1px, transparent 1px),\r\n    linear-gradient(90deg, rgba(16, 185, 129, 0.05) 1px, transparent 1px);\r\n  background-size: 20px 20px;\r\n}\r\n\r\n/* Status bar */\r\n.editor-module__status-bar {\r\n  background: linear-gradient(90deg, rgba(10, 14, 26, 0.9), rgba(15, 23, 42, 0.9));\r\n  border-top: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n/* Success messages */\r\n.success-message,\r\n.editor-module__message--success {\r\n  color: var(--editor-primary);\r\n  background-color: rgba(16, 185, 129, 0.1);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Warning messages */\r\n.warning,\r\n.editor-module__message--warning {\r\n  color: var(--editor-warning);\r\n  background-color: rgba(245, 158, 11, 0.1);\r\n  border-color: var(--editor-warning);\r\n}\r\n\r\n/* Instructions */\r\n.instructions {\r\n  background-color: rgba(59, 130, 246, 0.08);\r\n  border-left: 3px solid var(--editor-secondary);\r\n}\r\n\r\n/* Scrollbar styling - darker */\r\n::-webkit-scrollbar {\r\n  width: 8px;\r\n  height: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n  background: var(--editor-bg-dark);\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  background: rgba(16, 185, 129, 0.25);\r\n  border-radius: 4px;\r\n  box-shadow: none;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n  background: rgba(16, 185, 129, 0.35);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Canvas containers */\r\n#three-js-container,\r\n.preview-canvas-container {\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Camera controls */\r\n.camera-controls {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Content sidebars */\r\n.content-sidebar,\r\n.editor-module__sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n.editor-module__sidebar--right {\r\n  border-right: none;\r\n  border-left: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset 1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Shape list items */\r\n.shape-item,\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n  border-left-color: rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n.shape-item:hover,\r\n.graphics-editor__shape-item:hover,\r\n.graphics-editor__group-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.08);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Active/selected state - Aurora theme colors (teal/green glow) */\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option.active),\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option--active),\r\n.terrain-editor__environment-item.active,\r\n.terrain-editor__environment-item--active,\r\n.editor-module__selectable-item.active,\r\n.editor-module__selectable-item--active {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.4) !important;\r\n  box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.4), 0 0 8px rgba(16, 185, 129, 0.2) !important;\r\n}\r\n\r\n.terrain-editor__color-option.active,\r\n.terrain-editor__color-option--active {\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.6), 0 0 12px rgba(16, 185, 129, 0.5) !important;\r\n}\r\n\r\n/* Audio editor value displays */\r\n.audio-editor__value-display {\r\n  color: var(--editor-primary);\r\n  text-shadow: 0 0 8px rgba(16, 185, 129, 0.5);\r\n}\r\n\r\n/* Animations - disabled pulsing for comfort */\r\n@keyframes aurora-pulse {\r\n  0%, 100% {\r\n    box-shadow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  }\r\n  50% {\r\n    box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);\r\n  }\r\n}\r\n\r\n/* Removed automatic pulsing animation for eye comfort */\r\n/* .editor-module__btn--primary:hover,\r\n.editor-module__item--active,\r\n.object-item.selected {\r\n  animation: aurora-pulse 2s ease-in-out infinite;\r\n} */\r\n\r\n/* Typography enhancements */\r\nh1, h2, h3, h4 {\r\n  color: var(--editor-text-primary);\r\n  font-weight: 600;\r\n}\r\n\r\n/* Labels */\r\nlabel,\r\n.editor-module__label {\r\n  color: var(--editor-text-secondary);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Info boxes */\r\n.editor-module__info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Scene info */\r\n.scene-info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n",
        "filePath": "/global/themes/css/aurora.css"
      },
      "scifi2": {
        "title": "SciFi2.0",
        "fileName": "scifi2",
        "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap'); :root {     --primary-bg: #0a0a1a;     --secondary-bg: #121228;     --accent-color: #00ffff;     --text-color: #e0e7ff;     --border-color: #2a2a4a;     --highlight-color: #ff00ff;     --hover-color: rgba(0, 255, 255, 0.2); }  body {     background-color: var(--primary-bg);     color: var(--text-color);     font-family: 'Orbitron', 'Arial', sans-serif;     line-height: 1.6; }  .container {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 20px rgba(0, 255, 255, 0.1); }  /* Sidebar Styling */ .sidebar {     background-color: #0f0f2a;     border-right: 1px solid var(--border-color); }  .object-item, .object-type-item {     background-color: var(--secondary-bg);     border: 1px solid var(--border-color);     color: var(--text-color);     transition: all 0.3s ease; }  .object-item:hover, .object-type-item:hover {     background-color: var(--hover-color);     border-color: var(--accent-color); }  .object-item.selected, .object-type-item.selected {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Button Styling */ button {     background-color: var(--secondary-bg);     color: var(--accent-color);     border: 2px solid var(--accent-color);     transition: all 0.3s ease;     position: relative;     overflow: hidden; }  button:before {     content: '';     position: absolute;     top: 0;     left: -100%;     width: 100%;     height: 100%;     background: linear-gradient(120deg, transparent, var(--highlight-color), transparent);     transition: all 0.5s ease; }  button:hover:before {     left: 100%; }  button:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  .primary {     background-color: var(--accent-color);     color: var(--primary-bg); }  .danger {     border-color: #ff4444;     color: #ff4444; }  /* Input Styling */ input, textarea, select {     background-color: var(--secondary-bg);     color: var(--text-color);     border: 1px solid var(--border-color);     transition: border-color 0.3s ease; }  input:focus, textarea:focus, select:focus {     border-color: var(--accent-color);     outline: none;     box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }  /* Modal Styling */ .modal {     background-color: rgba(10, 10, 26, 0.9); }  .modal-content {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 30px rgba(0, 255, 255, 0.1); }  /* Graphics Editor Enhancements */ #canvas-container {     background:          linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0,         linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0;     background-size: 20px 20px;     background-color: var(--primary-bg); }  .scene-info {     background-color: rgba(18, 18, 40, 0.8);     border: 1px solid var(--border-color);     color: var(--accent-color); }  /* Toolbar Styling */ .toolbar .btn {     background-color: var(--secondary-bg);     border-color: var(--border-color);     color: var(--accent-color); }  .toolbar .btn:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Tab and Category Styling */ .tab, .category-header {     color: var(--text-color);     transition: color 0.3s ease; }  .tab:hover, .category-header:hover {     color: var(--accent-color); }  .tab.active {     border-bottom-color: var(--accent-color); }  /* Scrollbar (for browsers that support) */ ::-webkit-scrollbar {     width: 10px; }  ::-webkit-scrollbar-track {     background: var(--secondary-bg); }  ::-webkit-scrollbar-thumb {     background: var(--accent-color);     border-radius: 5px; }  ::-webkit-scrollbar-thumb:hover {     background: var(--highlight-color); }  /* Subtle Sci-Fi Animations */ @keyframes pulse-border {     0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }     50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); } }  @keyframes grid-pulse {     0%, 100% { opacity: 0.1; }     50% { opacity: 0.3; } }  /* Additional Futuristic Effects */ body::before {     content: '';     position: fixed;     top: 0;     left: 0;     width: 100%;     height: 100%;     pointer-events: none;     background:          repeating-linear-gradient(             0deg,             rgba(0, 0, 0, 0.15),             rgba(0, 0, 0, 0.15) 1px,             transparent 1px,             transparent 2px         );     opacity: 0.3;     z-index: 9999; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/scifi2.css"
      },
      "codeMirrorTheme": {
        "title": "Code - Ez On Eyes",
        "fileName": "codeMirrorTheme",
        "css": ".CodeMirror {    background: #1e1e1e;    color: #d4d4d4;    font-size: 14px; } .CodeMirror-gutters {    background: #252525;  border-right: 1px solid #444; } .CodeMirror-linenumber {    color: #888; }.CodeMirror-cursor {    border-left: 1px solid #d4d4d4; } .CodeMirror-selected {    background: #3a3a3a; }.CodeMirror-focused .CodeMirror-selected {    background: #404040; /* Slightly lighter when focused */}.CodeMirror-activeline-background {    background: #2a2a2a; /* Subtle active line highlight */}.CodeMirror-matchingbracket {    color: #b5cea8; /* Muted green for matching brackets */}.CodeMirror-nonmatchingbracket {    color: #d16969; /* Soft red for non-matching */}/* Override default theme's syntax highlighting */.cm-s-default .cm-header { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-quote { color: #b5cea8; } /* Muted green (overrides #090) */.cm-negative { color: #d16969; } /* Soft red */.cm-positive { color: #6a9955; } /* Muted green */.cm-header, .cm-strong { font-weight: 700; }.cm-em { font-style: italic; }.cm-s-default .cm-link { color: #d7ba7d; text-decoration: underline; } /* Muted yellow (overrides #00c blue) */.cm-strikethrough { text-decoration: line-through; }.cm-s-default .cm-keyword { color: #ce9178; } /* Soft orange (overrides #708 purple) */.cm-s-default .cm-atom { color: #d4d4d4; } /* Light gray (overrides #219 blue) */.cm-s-default .cm-number { color: #b5cea8; } /* Muted green (overrides #164) */.cm-s-default .cm-def { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-variable-2 { color: #d4d4d4; } /* Light gray (overrides #05a blue) */.cm-s-default .cm-variable-3, .cm-s-default .cm-type { color: #dcdcaa; } /* Soft yellow (overrides #085 blue) */.cm-s-default .cm-comment { color: #6a9955; } /* Muted green (overrides #a50) */.cm-s-default .cm-string { color: #ce9178; } /* Soft orange (overrides #a11) */.cm-s-default .cm-string-2 { color: #d7ba7d; } /* Muted yellow (overrides #f50) */.cm-s-default .cm-meta { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-qualifier { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-builtin { color: #dcdcaa; } /* Soft yellow (overrides #30a) */.cm-s-default .cm-bracket { color: #d4d4d4; } /* Light gray (overrides #997) */.cm-s-default .cm-tag { color: #dcdcaa; } /* Soft yellow (overrides #170) */.cm-s-default .cm-attribute { color: #d4d4d4; } /* Light gray (overrides #00c blue) */.cm-s-default .cm-hr { color: #888; } /* Muted gray (overrides #999) */.cm-s-default .cm-link { color: #d7ba7d; } /* Muted yellow (overrides #00c blue) */.cm-s-default .cm-error { color: #d16969; } /* Soft red (overrides red) */.cm-invalidchar { color: #d16969; } /* Soft red *//* Search highlight */.cm-searching {    background-color: rgba(255, 255, 0, 0.2); /* Subtle yellow */}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/codeMirrorTheme.css"
      },
      "professional3": {
        "title": "Claude",
        "fileName": "professional3",
        "css": "/* Eclipse Theme - A premium dark UI experience */ @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap');  :root {   --bg-primary: #0f111a;   --bg-secondary: #141725;   --bg-tertiary: #1a1d2d;   --accent-primary: #7c4dff;   --accent-secondary: #00bcd4;   --accent-tertiary: #ff4081;   --text-primary: #eceff1;   --text-secondary: #b0bec5;   --border-light: rgba(99, 114, 166, 0.25);   --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);   --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);   --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);   --gradient-bg: linear-gradient(135deg, rgba(20, 23, 37, 0.95), rgba(15, 17, 26, 0.95));   --gradient-accent: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); }  body {   font-family: 'Space Grotesk', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6;   transition: background-color 0.3s ease;   background-image:      radial-gradient(circle at 15% 15%, rgba(124, 77, 255, 0.08) 0%, transparent 25%),     radial-gradient(circle at 85% 85%, rgba(0, 188, 212, 0.08) 0%, transparent 25%); }  /* Modern sidebar with glassmorphism effect */ .sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--text-secondary);   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   margin-bottom: 4px;   border-radius: 0 4px 4px 0; }  .object-item:hover {   background-color: rgba(124, 77, 255, 0.1);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   transform: translateX(2px); }  .object-item.selected {   background: linear-gradient(90deg, rgba(124, 77, 255, 0.15), rgba(124, 77, 255, 0.05));   border-left: 3px solid var(--accent-primary);   color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   font-weight: 600; }  /* Editor area with polished look */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  #three-js-container {   border: 1px solid var(--border-light);   border-radius: 6px;   box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);   background: rgba(15, 17, 26, 0.5); }  .preview-canvas-container {   border: 1px solid var(--accent-primary);   box-shadow: 0 0 16px rgba(124, 77, 255, 0.15);   border-radius: 6px;   overflow: hidden; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-light);   border-radius: 4px; }  /* Enhanced camera controls with dynamic hover effects */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px;   box-shadow: var(--shadow-sm); }  .camera-controls button {   background-color: rgba(99, 114, 166, 0.15);   border: 1px solid var(--border-light);   color: var(--text-primary);   border-radius: 4px;   padding: 8px 12px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .camera-controls button:hover {   background-color: rgba(124, 77, 255, 0.15);   border-color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   transform: translateY(-2px) scale(1.02); }  .camera-controls button:active {   transform: translateY(1px); }  .camera-controls .color-picker {   border: 1px solid var(--border-light);   border-radius: 4px;   overflow: hidden;   box-shadow: var(--shadow-sm); }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-light);   border-radius: 4px;   height: 6px;   box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.2); }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.4);   border-radius: 50%;   cursor: pointer;   transition: all 0.2s ease; }  .camera-controls .size-slider::-webkit-slider-thumb:hover {   transform: scale(1.2); }  /* Form elements with attractive focus states */ label {   font-weight: 500;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--accent-primary);   margin-bottom: 6px;   display: block;   font-size: 0.85rem; }  input, textarea, select {   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   border-radius: 4px;   padding: 10px 12px;   box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);   transition: all 0.3s ease;   font-family: 'JetBrains Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 3px rgba(124, 77, 255, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.1);   background-color: rgba(20, 23, 37, 0.8); }  /* Modern button styles with micro-interactions */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden; }  button:hover {   background-color: rgba(99, 114, 166, 0.2);   border-color: var(--border-light);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);   transform: translateY(-2px); }  button:active {   transform: translateY(1px); }  button::after {   content: '';   position: absolute;   top: 50%;   left: 50%;   width: 100%;   height: 100%;   background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 50%);   transform: scale(0);   opacity: 0;   transition: transform 0.5s, opacity 0.3s;   pointer-events: none; }  button:active::after {   transform: scale(2);   opacity: 1;   transition: 0s; }  button.primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  button.primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.3); }  button.primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  button.primary:hover::before {   opacity: 0.1; }  button.danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  button.danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  button.active {   border: 1px solid var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.3);   color: var(--accent-secondary);   background-color: rgba(0, 188, 212, 0.15); }  /* Modal with glassmorphism effect */ .modal {   background-color: rgba(15, 17, 26, 0.7);   backdrop-filter: blur(8px);   -webkit-backdrop-filter: blur(8px); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-lg);   border-radius: 8px;   overflow: hidden;   animation: modalAppear 0.3s ease; }  @keyframes modalAppear {   from {     opacity: 0;     transform: scale(0.95) translateY(-10px);   }   to {     opacity: 1;     transform: scale(1) translateY(0);   } }  .property-list {   border: 1px solid var(--border-light);   background-color: var(--bg-tertiary);   border-radius: 6px;   overflow: hidden; }  /* Tab navigation with smooth transitions */ .tab-navigation {   border-bottom: 1px solid var(--border-light);   display: flex;   gap: 4px;   padding: 0 6px; }  .tab {   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   color: var(--text-secondary);   position: relative;   transition: all 0.3s ease;   border-radius: 4px 4px 0 0; }  .tab:hover {   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 600;   background-color: rgba(124, 77, 255, 0.05); }  .tab.active::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   right: 0;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Stylized instructions and warnings */ .instructions {   background-color: rgba(124, 77, 255, 0.05);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .instructions::before {   content: 'i';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: var(--accent-primary);   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   font-style: italic;   color: white;   font-size: 14px; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  .success-message {   color: #4caf50;   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px;   background-color: rgba(76, 175, 80, 0.1);   border-radius: 4px;   display: inline-block; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(244, 67, 54, 0.1);   border-left: 3px solid #f44336;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .warning::before {   content: '!';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: #f44336;   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   color: white;   font-size: 14px; }  /* Content containers with subtle gradients */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  #graphics-rightbar {   background: var(--gradient-bg);   border-left: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(99, 114, 166, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(99, 114, 166, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar with subtle glassmorphism */ .toolbar {   background: var(--gradient-bg);   border-bottom: 1px solid var(--border-light);   box-shadow: var(--shadow-sm);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations with consistent styling */ .btn {   border: 1px solid var(--border-light);   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 8px 14px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden;   font-size: 0.85rem; }  .btn:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);   transform: translateY(-2px); }  .btn:active {   transform: translateY(1px); }  .btn-primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  .btn-primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.2); }  .btn-primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  .btn-primary:hover::before {   opacity: 0.1; }  .btn-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  .btn-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  .btn-secondary {   background-color: rgba(99, 114, 166, 0.1);   border: 1px solid var(--border-light); }  .btn-secondary:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }  .btn-special {   background-color: rgba(0, 188, 212, 0.15);   border: 1px solid var(--accent-secondary);   color: var(--accent-secondary); }  .btn-special:hover {   background-color: rgba(0, 188, 212, 0.25);   box-shadow: 0 4px 16px rgba(0, 188, 212, 0.2); }  /* Shape list with improved visual hierarchy */ #shape-list {   border-bottom: 1px solid var(--border-light);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 4px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: rgba(99, 114, 166, 0.15);   transform: translateX(3px);   border-color: var(--border-light); }  .shape-item.active {   background-color: rgba(0, 188, 212, 0.1);   border-color: var(--accent-secondary);   color: var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.15);   font-weight: 500; }  /* Inspector panel with clean design */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-light);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--accent-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   padding: 10px 12px;   border-radius: 4px; }  /* Scene info with modern styling */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px 16px;   margin-bottom: 16px;   box-shadow: var(--shadow-sm); }  .button-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336;   padding: 10px 16px;   border-radius: 4px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .button-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2);   transform: translateY(-2px); }  /* Typography improvements */ h2, h3 {   color: var(--accent-primary);   text-transform: uppercase;   letter-spacing: 1px;   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-light);   font-weight: 600;   text-shadow: 0 0 20px rgba(124, 77, 255, 0.3);   position: relative; }  h2::after, h3::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   width: 50px;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Sleek scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(124, 77, 255, 0.3);   border-radius: 3px;   border: 1px solid var(--bg-tertiary); }  ::-webkit-scrollbar-thumb:hover {   background: var(--accent-primary); }  /* Animations and transitions */ @keyframes pulse {   0% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0.4); }   70% { box-shadow: 0 0 0 10px rgba(124, 77, 255, 0); }   100% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0); } }  .pulse-animation {   animation: pulse 2s infinite; }  /* Tooltips */ [data-tooltip] {   position: relative; }  [data-tooltip]::after {   content: attr(data-tooltip);   position: absolute;   bottom: 125%;   left: 50%;   transform: translateX(-50%);   padding: 6px 10px;   background: var(--bg-tertiary);   color: var(--text-primary);   border-radius: 4px;   font-size: 0.75rem;   white-space: nowrap;   opacity: 0;   visibility: hidden;   transition: all 0.3s ease;   z-index: 100;   box-shadow: var(--shadow-md);   border: 1px solid var(--border-light); }  [data-tooltip]:hover::after {   opacity: 1;   visibility: visible; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional3.css"
      },
      "professional2": {
        "title": "Professional Warm",
        "fileName": "professional2",
        "css": "/* Professional Cyberpunk Variation - Warm Edition */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #2b1e1e; /* Deep reddish-brown */     color: #f4e1d2; /* Soft cream for text */     line-height: 1.6; }  .sidebar {     background-color: rgba(54, 36, 36, 0.95); /* Muted dark red */     border: 1px solid #7a4e4e; /* Subtle reddish-gray */     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.2); }  .object-item {     background-color: rgba(54, 36, 36, 0.8);     border-left: 2px solid #d97706; /* Warm amber */     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(217, 119, 6, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(217, 119, 6, 0.25);     border-left: 3px solid #d97706;     box-shadow: 0 0 6px rgba(217, 119, 6, 0.4); }  .editor {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #three-js-container {     border: 1px solid rgba(122, 78, 78, 0.6); }  .preview-canvas-container {     border: 1px solid #d97706;     box-shadow: 0 4px 12px rgba(217, 119, 6, 0.1); }  .preview {     background-color: rgba(54, 36, 36, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(122, 78, 78, 0.5); }  .camera-controls {     background: rgba(46, 28, 28, 0.9); /* Darker reddish tint */     border: 1px solid #7a4e4e; }  .camera-controls button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .camera-controls .color-picker {     border: 1px solid #7a4e4e; }  .camera-controls .size-slider {     background: #3a2424;     border: 1px solid #7a4e4e; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #d97706; /* Amber for labels */ }  input, textarea, select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #d97706;     box-shadow: 0 0 8px rgba(217, 119, 6, 0.3); }  button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  button.primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  button.danger {     background-color: rgba(220, 38, 38, 0.3); /* Softer red */     border: 1px solid #dc2626;     color: #f4e1d2; }  button.danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  button.active {     border: 1px solid #10b981; /* Emerald green for active state */     box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);     color: #10b981; }  .modal {     background-color: rgba(46, 28, 28, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 8px 24px rgba(122, 78, 78, 0.2); }  .property-list {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8); }  .tab-navigation {     border-bottom: 1px solid #7a4e4e; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(122, 78, 78, 0.2); }  .tab.active {     border-bottom: 2px solid #d97706;     box-shadow: 0 4px 8px -4px rgba(217, 119, 6, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(54, 36, 36, 0.8);     border-left: 3px solid #d97706;     box-shadow: 0 2px 6px rgba(217, 119, 6, 0.1); }  #grid-display {     background-color: rgba(46, 28, 28, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .success-message {     color: #10b981; /* Emerald green for success */     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(220, 38, 38, 0.15);     border-left: 3px solid #dc2626;     box-shadow: 0 2px 6px rgba(220, 38, 38, 0.1); }  .main-content-container {     background-color: #332121; /* Slightly lighter reddish-brown */     color: #f4e1d2; }  .content-sidebar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-right: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-left: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .grid-background {     background: #2b1e1e;     background-image: radial-gradient(rgba(122, 78, 78, 0.15) 1px, transparent 1px);     background-size:30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-bottom: 1px solid #7a4e4e; }  .btn {     border: 1px solid #7a4e4e;     background-color: rgba(122, 78, 78, 0.3);     color: #f4e1d2;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  .btn-primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  .btn-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .btn-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  .btn-secondary {     background-color: rgba(122, 78, 78, 0.25);     border: 1px solid #7a4e4e; }  .btn-secondary:hover {     background-color: rgba(122, 78, 78, 0.4);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .btn-special {     background-color: rgba(16, 185, 129, 0.3);     border: 1px solid #10b981;     color: #f4e1d2; }  .btn-special:hover {     background-color: rgba(16, 185, 129, 0.5);     box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(122, 78, 78, 0.3); }  .shape-item {     background-color: rgba(54, 36, 36, 0.8);     border: 1px solid #7a4e4e;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(122, 78, 78, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(16, 185, 129, 0.15);     border-color: #10b981;     color: #10b981;     box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); }  #inspector {     background: rgba(54, 36, 36, 0.95);     border-top: 1px solid #7a4e4e; }  .form-row label {     color: #d97706; }  .form-row input, .form-row select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1); }  .scene-info {     background: rgba(46, 28, 28, 0.9prisma);     color: #f4e1d2;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15);     border: 1px solid #7a4e4e; }  .button-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .button-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  h2, h3 {     color: #d97706;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #7a4e4e;     text-shadow: 0 0 4px rgba(217, 119, 6, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(54, 36, 36, 0.8); }  ::-webkit-scrollbar-thumb {     background: #7a4e4e;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #d97706; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional2.css"
      },
      "Neon Dune": {
        "title": "Neon Dune",
        "fileName": "Neon Dune",
        "css": "body { background-color: #1a0f05; color: #ffffff; font-family: 'Arial', sans-serif; }\r\n\r\nh1, h2, h3 { color: #00ffbf; }\r\n\r\n.button-primary { background-color: #00ffbf; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; }\r\n.button-primary:hover { transform: scale(1.05); box-shadow: 0 0 15px #00ffbf; }\r\n\r\n.link { color: #00ffbf; text-decoration: none; }\r\n.link:hover { text-decoration: underline; }\r\n\r\n.card { background-color: #2d1e13; border-radius: 10px; padding: 20px; margin: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n\r\ninput, textarea { background-color: #2d1e13; color: #ffffff; border: 1px solid #00ffbf; padding: 8px; border-radius: 5px; }\r\n\r\nheader { background-color: #00ffbf; padding: 20px; text-align: center; box-shadow: 0 4px 6px rgba(0,255,191,0.3); }\r\n\r\nfooter { background-color: #2d1e13; color: #ffffff; padding: 20px; text-align: center; border-top: 1px solid #00ffbf; }\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/Neon Dune.css"
      },
      "medieval": {
        "title": "Medieval",
        "fileName": "medieval",
        "css": "/* Medieval Theme */ @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English&display=swap');  body {     font-family: 'Cinzel', 'IM Fell English', serif;     background-color: #2b1e12; /* Dark brown, earthy tone */     color: #d4b98a; /* Parchment-like beige */ }  .sidebar {     background-color: rgba(50, 40, 30, 0.8); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), inset 0 0 20px rgba(50, 40, 30, 0.3); }  .object-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .editor {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #b8860b;     box-shadow: 0 0 15px rgba(184, 134, 11, 0.3); }  #three-js-container {     border: 1px solid rgba(138, 92, 46, 0.5); /* Bronze edge */ }  .preview-canvas-container {     border: 1px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.3); }  .preview {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(138, 92, 46, 0.5); }  .camera-controls {     background: rgba(40, 30, 20, 0.7); /* Dark stone */     border: 1px solid #8a5c2e; }  .camera-controls button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a; }  .camera-controls .color-picker {     border: 1px solid #8a5c2e; }  .camera-controls .size-slider {     background: #3c2f1e; /* Darker wood */     border: 1px solid #8a5c2e; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #b8860b; /* Gold text */ }  input, textarea, select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  button:hover {     background-color: rgba(138, 92, 46, 0.3);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), 0 0 20px rgba(138, 92, 46, 0.2);     transform: translateY(-2px); }  button.primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  button.primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5), 0 0 20px rgba(184, 134, 11, 0.2); }  button.danger {     background-color: rgba(139, 0, 0, 0.2); /* Crimson */     border: 1px solid #8b0000;     color: #ff4040; }  button.danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5), 0 0 20px rgba(139, 0, 0, 0.2); }  button.active {     border: 1px solid #228b22; /* Forest green */     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5);     color: #228b22; }  .modal {     background-color: rgba(40, 30, 20, 0.85); /* Stone texture */     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(50, 40, 30, 0.9);     border: 1px solid #8a5c2e;     box-shadow: 0 0 30px rgba(138, 92, 46, 0.3), 0 0 60px rgba(138, 92, 46, 0.1); }  .property-list {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6); }  .tab-navigation {     border-bottom: 1px solid #8a5c2e; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(138, 92, 46, 0.1); }  .tab.active {     border-bottom: 3px solid #b8860b;     box-shadow: 0 5px 10px -5px rgba(184, 134, 11, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(60, 50, 40, 0.6);     border-left: 4px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.2); }  #grid-display {     background-color: rgba(40, 30, 20, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 10px rgba(138, 92, 46, 0.3); }  .success-message {     color: #228b22; /* Forest green */     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(139, 0, 0, 0.1);     border-left: 4px solid #8b0000;     box-shadow: 0 0 10px rgba(139, 0, 0, 0.2); }  .main-content-container {     background-color: #251a10; /* Darker brown */     color: #d4b98a; }  .content-sidebar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-right: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-left: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  .grid-background {     background: #1e150d;     background-image: radial-gradient(rgba(138, 92, 46, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-bottom: 1px solid #8a5c2e; }  .btn {     border: 1px solid #8a5c2e;     background-color: rgba(138, 92, 46, 0.1);     color: #d4b98a;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(138, 92, 46, 0.2);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  .btn-primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  .btn-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .btn-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  .btn-secondary {     background-color: rgba(138, 92, 46, 0.15);     border: 1px solid #8a5c2e; }  .btn-secondary:hover {     background-color: rgba(138, 92, 46, 0.25);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .btn-special {     background-color: rgba(34, 139, 34, 0.2); /* Forest green */     border: 1px solid #228b22;     color: #228b22; }  .btn-special:hover {     background-color: rgba(34, 139, 34, 0.3);     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(138, 92, 46, 0.2); }  .shape-item {     background-color: rgba(60, 50, 40, 0.6);     border: 1px solid #8a5c2e; }  .shape-item:hover {     background-color: rgba(138, 92, 46, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(34, 139, 34, 0.1);     border-color: #228b22;     color: #228b22;     box-shadow: 0 0 10px rgba(34, 139, 34, 0.3); }  #inspector {     background: rgba(60, 50, 40, 0.8);     border-top: 1px solid #8a5c2e; }  .form-row label {     color: #b8860b; }  .form-row input, .form-row select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  .scene-info {     background: rgba(40, 30, 20, 0.8);     color: #d4b98a;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3);     border: 1px solid #8a5c2e; }  .button-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .button-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  h2, h3 {     color: #b8860b;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #8a5c2e;     text-shadow: 0 0 5px rgba(184, 134, 11, 0.7); }   .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(138, 92, 46, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(138, 92, 46, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(60, 50, 40, 0.8);     border: 1px solid #8a5c2e;     color: #228b22; /* Green ink */     font-family: 'IM Fell English', serif;     padding: 15px;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.2), inset 0 0 30px rgba(60, 50, 40, 0.5); }  .ref-value-item {     background-color: #4a3a2a; /* Darker wood */ }  .remove-ref-btn {     background: none;     border: none;     color: #ff4040;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(60, 50, 40, 0.6); }  ::-webkit-scrollbar-thumb {     background: #8a5c2e;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #b8860b; }  /* Category Styling for Medieval Theme */ .type-selector {     background-color: rgba(50, 40, 30, 0.7); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: inset 0 0 10px rgba(138, 92, 46, 0.3); }  .category-header {     background-color: rgba(60, 50, 40, 0.8); /* Aged wood */     border: 1px solid #8a5c2e;     color: #d4b98a; /* Parchment beige */     text-transform: uppercase;     letter-spacing: 1px;     font-weight: bold; }  .category-header:hover {     background-color: rgba(138, 92, 46, 0.2); /* Bronze hover */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .category-types {     background-color: rgba(40, 30, 20, 0.6); /* Dark stone */ }  .object-type-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  .object-type-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-type-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .object-list {     background-color: rgba(50, 40, 30, 0.5); /* Slightly lighter wood */ }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/medieval.css"
      },
      "claude2": {
        "title": "Claude 2",
        "fileName": "claude2",
        "css": "/* Professional Theme - Clean UI */ @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');  :root {   --bg-primary: #16192e;   --bg-secondary: #1d2035;   --bg-tertiary: #252a43;   --accent-primary: #4d7cff;   --accent-muted: rgba(77, 124, 255, 0.15);   --text-primary: #e9edf5;   --text-secondary: #a9b1c3;   --border-color: rgba(108, 123, 163, 0.25);   --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.2);   --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25); }  body {   font-family: 'Inter', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6; }  /* Sidebar styling */ .sidebar {   background-color: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: none;   letter-spacing: 0.2px;   color: var(--text-secondary);   font-weight: 400;   transition: all 0.2s ease;   padding: 10px 14px;   margin-bottom: 2px; }  .object-item:hover {   background-color: var(--bg-tertiary);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary); }  .object-item.selected {   background-color: var(--accent-muted);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   font-weight: 500; }  /* Editor area */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #three-js-container {   border: 1px solid var(--border-color);   border-radius: 4px;   background: var(--bg-primary); }  .preview-canvas-container {   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-color);   border-radius: 2px; }  /* Camera controls */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px; }  .camera-controls button {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   color: var(--text-primary);   border-radius: 3px;   padding: 8px 12px;   transition: all 0.2s ease; }  .camera-controls button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .camera-controls .color-picker {   border: 1px solid var(--border-color);   border-radius: 3px; }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-color);   border-radius: 3px;   height: 5px; }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   border-radius: 50%;   cursor: pointer; }  /* Form elements */ label {   font-weight: 500;   color: var(--text-primary);   margin-bottom: 6px;   display: block;   font-size: 0.875rem; }  input, textarea, select {   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   border-radius: 3px;   width: calc(100% - 24px);  padding: 8px 12px;   transition: all 0.2s ease;   font-family: 'IBM Plex Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 2px var(--accent-muted); }  /* Button styles */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease; }  button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  button.primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  button.primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6;   box-shadow: var(--shadow-sm); }  button.danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  button.danger:hover {   background-color: rgba(235, 68, 68, 0.25);   box-shadow: var(--shadow-sm); }  button.active {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  /* Modal styling */ .modal {   background-color: rgba(22, 25, 46, 0.8); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-md);   border-radius: 4px; }  .property-list {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   border-radius: 4px; }  /* Tab navigation */ .tab-navigation {   border-bottom: 1px solid var(--border-color);   display: flex;   padding: 0 4px; }  .tab {   padding: 10px 16px;   color: var(--text-secondary);   transition: all 0.2s ease; }  .tab:hover {   background-color: var(--bg-tertiary);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 500;   border-bottom: 2px solid var(--accent-primary); }  /* Info and warning boxes */ .instructions {   background-color: var(--bg-tertiary);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .success-message {   color: #34c79a;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(235, 68, 68, 0.1);   border-left: 3px solid #eb4444;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  /* Main containers */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  #graphics-rightbar {   background: var(--bg-secondary);   border-left: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(108, 123, 163, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(108, 123, 163, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar */ .toolbar {   background: var(--bg-secondary);   border-bottom: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations */ .btn {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease;   font-size: 0.875rem; }  .btn:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  .btn-primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6; }  .btn-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  .btn-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  .btn-secondary {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color); }  .btn-secondary:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-special {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  .btn-special:hover {   background-color: rgba(52, 199, 154, 0.25); }  /* Shape list */ #shape-list {   border-bottom: 1px solid var(--border-color);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 3px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.2s ease;   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .shape-item.active {   background-color: rgba(52, 199, 154, 0.1);   border-color: #34c79a;   color: #34c79a;   font-weight: 500; }  /* Inspector panel */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-color);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--text-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   padding: 8px 12px;   border-radius: 3px; }  /* Scene info */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px 16px;   margin-bottom: 16px; }  .button-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444;   padding: 8px 14px;   border-radius: 3px;   font-weight: 500;   transition: all 0.2s ease; }  .button-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  /* Typography */ h2, h3 {   color: var(--text-primary);   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-color);   font-weight: 600; }  /* Scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(108, 123, 163, 0.5);   border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {   background: rgba(108, 123, 163, 0.7); }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/claude2.css"
      },
      "videogame": {
        "title": "Video Game",
        "fileName": "videogame",
        "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');  body {     font-family: 'Orbitron', 'Share Tech Mono', sans-serif;     background-color: #0a0a0a; /* Deep black */     color: #00d4ff; /* Neon blue */     overflow: hidden; }  .sidebar {     background: linear-gradient(135deg, rgba(10, 10, 10, 0.9), rgba(155, 0, 255, 0.1)); /* Black to purple fade */     border: 1px solid #ff007a; /* Hot pink */     box-shadow: 0 0 15px rgba(0, 212, 255, 0.5), inset 0 0 10px rgba(155, 0, 255, 0.3); }  .inventory-item {     background-color: rgba(12, 12, 12, 0.7);     border-left: 3px solid #9b00ff; /* Electric purple */     text-transform: uppercase;     letter-spacing: 2px;     transition: all 0.2s ease; }  .inventory-item:hover {     background-color: rgba(0, 212, 255, 0.2);     transform: scale(1.03);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.7); }  .inventory-item.active {     background-color: rgba(255, 0, 122, 0.3); /* Pink glow */     border-left: 5px solid #ff007a;     box-shadow: 0 0 15px rgba(255, 0, 122, 0.8); }  .hud {     background: rgba(10, 10, 10, 0.8);     border: 1px solid #00d4ff;     box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }  #game-canvas {     border: 1px dashed #c0c0c0; /* Silver dashed */     background: radial-gradient(circle, rgba(155, 0, 255, 0.1), transparent); }  .hologram-display {     border: 2px solid #9b00ff;     box-shadow: 0 0 25px rgba(155, 0, 255, 0.6);     animation: pulseGlow 2s infinite alternate; }  @keyframes pulseGlow {     0% { box-shadow: 0 0 25px rgba(155, 0, 255, 0.6); }     100% { box-shadow: 0 0 35px rgba(155, 0, 255, 0.9); } }  .control-panel {     background: rgba(0, 0, 0, 0.85);     border: 1px solid #c0c0c0; }  .control-panel button {     background-color: rgba(0, 212, 255, 0.2);     border: 1px solid #00d4ff;     color: #fff;     text-transform: uppercase;     transition: all 0.3s ease; }  .control-panel button:hover {     background-color: rgba(0, 212, 255, 0.4);     box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);     transform: translateY(-3px); }  label {     color: #ff007a; /* Hot pink */     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1.5px; }  input, textarea, select {     border: 1px solid #9b00ff;     background-color: rgba(10, 10, 10, 0.7);     color: #00d4ff;     box-shadow: 0 0 8px rgba(155, 0, 255, 0.4); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #ff007a;     box-shadow: 0 0 12px rgba(255, 0, 122, 0.7); }  button {     background-color: rgba(155, 0, 255, 0.2);     border: 1px solid #9b00ff;     color: #fff;     text-transform: uppercase;     letter-spacing: 1px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(155, 0, 255, 0.4);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.7);     transform: translateY(-2px) scale(1.05); }  button.primary {     background-color: rgba(0, 212, 255, 0.3);     border: 1px solid #00d4ff;     color: #fff; }  button.primary:hover {     background-color: rgba(0, 212, 255, 0.5);     box-shadow: 0 0 20px rgba(0, 212, 255, 0.9); }  button.alert {     background-color: rgba(255, 0, 122, 0.2);     border: 1px solid #ff007a;     color: #fff; }  button.alert:hover {     background-color: rgba(255, 0, 122, 0.4);     box-shadow: 0 0 15px rgba(255, 0, 122, 0.7); }  .modal {     background: rgba(0, 0, 0, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background: linear-gradient(45deg, rgba(10, 10, 10, 0.9), rgba(0, 212, 255, 0.1));     border: 1px solid #00d4ff;     box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }  .notification {     background-color: rgba(155, 0, 255, 0.3);     border-left: 4px solid #9b00ff;     color: #fff;     animation: slideIn 0.5s ease-out; }  @keyframes slideIn {     0% { transform: translateX(100%); opacity: 0; }     100% { transform: translateX(0); opacity: 1; } }  .main-content {     background: #0a0a0a;     animation: glitch 4s infinite; }   .grid-overlay {     background: repeating-linear-gradient(45deg, rgba(155, 0, 255, 0.05), rgba(155, 0, 255, 0.05) 10px, transparent 10px, transparent 20px); }  .btn {     border: 1px solid #c0c0c0;     background-color: rgba(0, 212, 255, 0.15);     color: #fff; }  .btn:hover {     background-color: rgba(0, 212, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.6); }  .btn-primary {     background-color: rgba(9b, 0, 255, 0.25);     border: 1px solid #9b00ff; }  .btn-primary:hover {     background-color: rgba(155, 0, 255, 0.45);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.8); }  ::-webkit-scrollbar {     width: 6px; }  ::-webkit-scrollbar-track {     background: #0a0a0a; }  ::-webkit-scrollbar-thumb {     background: #00d4ff;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #ff007a; }",
        "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videogame.css"
      }
    },
    "attackSounds": {
      "gunshot": {
        "title": "GunShot",
        "audio": {
          "waveform": "noise",
          "frequency": 200,
          "duration": 0.5,
          "noise": {
            "type": "pink",
            "amount": 0.8,
            "filter": {
              "type": "lowpass",
              "frequency": 400
            }
          },
          "envelope": {
            "attack": 0.01,
            "decay": 0.3,
            "sustain": 0.2,
            "release": 0.1
          },
          "pitchEnvelope": {
            "start": 4,
            "end": 2,
            "time": 0.5
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 800,
              "Q": 1
            },
            "distortion": 2,
            "delay": {
              "time": 0.1,
              "feedback": 0.3
            },
            "reverb": 0.4,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "missileLaunch": {
        "title": "Missile Launch",
        "audio": {
          "waveform": "noise",
          "frequency": 341,
          "duration": 0.4,
          "noise": {
            "type": "brown",
            "amount": 0.63,
            "filter": {
              "type": "bandpass",
              "frequency": 20
            }
          },
          "envelope": {
            "attack": 0.252,
            "decay": 0.4,
            "sustain": 0,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.38,
            "end": 0.59,
            "time": 0.4
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 20000,
              "Q": 1
            },
            "distortion": 0,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0.11,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "TeslaAttack": {
        "title": "Tesla Attack",
        "audio": {
          "waveform": "noise",
          "frequency": 200,
          "duration": 0.15,
          "envelope": {
            "attack": 0.001,
            "decay": 0.03,
            "sustain": 0.4,
            "release": 0.02
          },
          "pitchEnvelope": {
            "start": 2.5,
            "end": 0.8,
            "time": 0.15
          },
          "effects": {
            "filter": {
              "type": "bandpass",
              "frequency": 1200,
              "Q": 3
            },
            "distortion": 30,
            "delay": {
              "time": 0.05,
              "feedback": 0.05
            },
            "reverb": 0.05,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "laser": {
        "title": "Laser",
        "audio": {
          "waveform": "triangle",
          "frequency": 197,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0.076,
            "sustain": 0.5,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.41,
            "end": 0.23,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 400,
              "Q": 1
            },
            "distortion": 5,
            "delay": {
              "time": 0.27,
              "feedback": 0.09
            },
            "reverb": 0,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "plasma": {
        "title": "Plasma",
        "audio": {
          "waveform": "triangle",
          "frequency": 197,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0.076,
            "sustain": 0.5,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 3.41,
            "end": 0.23,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "highpass",
              "frequency": 4000,
              "Q": 1
            },
            "distortion": 5,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      }
    },
    "hitSounds": {
      "explosion": {
        "title": "Explosion",
        "audio": {
          "waveform": "noise",
          "frequency": 100,
          "duration": 1,
          "noise": {
            "type": "white",
            "amount": 0,
            "filter": {
              "type": "none",
              "frequency": 2000
            }
          },
          "envelope": {
            "attack": 0.005,
            "decay": 0.2,
            "sustain": 0.3,
            "release": 0.3
          },
          "pitchEnvelope": {
            "start": 2,
            "end": 0.5,
            "time": 1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 800,
              "Q": 1
            },
            "distortion": 3,
            "delay": {
              "time": 0.15,
              "feedback": 0.25
            },
            "reverb": 0.5,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "explosion_loud": {
        "title": "Explosion Loud",
        "audio": {
          "waveform": "noise",
          "frequency": 100,
          "duration": 1,
          "noise": {
            "type": "white",
            "amount": 0,
            "filter": {
              "type": "none",
              "frequency": 2000
            }
          },
          "envelope": {
            "attack": 0.005,
            "decay": 0.2,
            "sustain": 0.3,
            "release": 0.3
          },
          "pitchEnvelope": {
            "start": 2,
            "end": 0.5,
            "time": 1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 800,
              "Q": 1
            },
            "distortion": 3,
            "delay": {
              "time": 0.15,
              "feedback": 0.25
            },
            "reverb": 0.5,
            "bitcrusher": 0.5,
            "pan": 0
          }
        }
      },
      "plasma": {
        "title": "Plasma",
        "audio": {
          "waveform": "noise",
          "frequency": 48,
          "duration": 0.1,
          "noise": {
            "type": "white",
            "amount": 0,
            "filter": {
              "type": "none",
              "frequency": 20
            }
          },
          "envelope": {
            "attack": 0.012,
            "decay": 0.064,
            "sustain": 0.01,
            "release": 0.062
          },
          "pitchEnvelope": {
            "start": 2.45,
            "end": 0.72,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 13141,
              "Q": 0.1
            },
            "distortion": 1,
            "delay": {
              "time": 0.05,
              "feedback": 0.03
            },
            "reverb": 0,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      }
    },
    "sounds": {
      "test": {
        "title": "test",
        "audio": {
          "waveform": "noise",
          "frequency": 440,
          "duration": 0.6,
          "noise": {
            "type": "pink",
            "amount": 1,
            "filter": {
              "type": "bandpass",
              "frequency": 1200,
              "Q": 1.8
            }
          },
          "envelope": {
            "attack": 0.02,
            "decay": 0.4,
            "sustain": 0,
            "release": 0
          },
          "pitchEnvelope": {
            "start": 1.8,
            "end": 0.4,
            "time": 0.5
          },
          "effects": {
            "filter": {
              "type": "none",
              "frequency": 20000,
              "Q": 1
            },
            "distortion": 0.2,
            "delay": {
              "time": 0,
              "feedback": 0
            },
            "reverb": 0.15,
            "bitcrusher": 0,
            "pan": 0
          }
        }
      },
      "placeTower": {
        "title": "Place Tower",
        "audio": {
          "waveform": "sine",
          "frequency": 20,
          "duration": 0.2,
          "noise": {
            "type": "pink",
            "amount": 0.8,
            "filter": {
              "type": "lowpass",
              "frequency": 400
            }
          },
          "envelope": {
            "attack": 0.01,
            "decay": 0,
            "sustain": 0.1,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 4,
            "end": 4,
            "time": 0.2
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 500,
              "Q": 1
            },
            "distortion": 0,
            "delay": {
              "time": 0.05,
              "feedback": 0.2
            },
            "reverb": 0.3,
            "bitcrusher": 0.4,
            "pan": 0
          }
        }
      },
      "pickup": {
        "title": "Pickup",
        "audio": {
          "waveform": "triangle",
          "frequency": 200,
          "duration": 0.1,
          "envelope": {
            "attack": 0.001,
            "decay": 0,
            "sustain": 0,
            "release": 0.001
          },
          "pitchEnvelope": {
            "start": 0.34,
            "end": 1.89,
            "time": 0.1
          },
          "effects": {
            "filter": {
              "type": "lowpass",
              "frequency": 400,
              "Q": 1
            },
            "distortion": 20,
            "delay": {
              "time": 0,
              "feedback": 0.2
            },
            "reverb": 0,
            "bitcrusher": 0.1,
            "pan": 0
          }
        }
      }
    },
    "actions": {
      "hold": {
        "title": "Hold",
        "icon": "order_hold",
        "order": "holdPosition"
      },
      "move": {
        "title": "Force Move",
        "icon": "order_move",
        "order": "moveOrderAction"
      },
      "mineGold": {
        "title": "Peasant Mine Gold",
        "icon": "building_goldMine",
        "ability": "MineGoldAbility"
      },
      "build": {
        "title": "Peasant Build",
        "icon": "building_townHall",
        "actionSet": "peasant_buildings",
        "ability": "BuildAbility"
      }
    },
    "actionSets": {
      "peasant_actions": {
        "title": "Peasant Actions",
        "actions": [
          "move",
          "hold",
          "build"
        ]
      },
      "peasant_buildings": {
        "title": "Peasant Buildings",
        "buildings": [
          "goldMine",
          "townHall",
          "cottage",
          "barracks",
          "fletchersHall",
          "mageTower",
          "sentryTower"
        ]
      },
      "defaultUnitActions": {
        "title": "Default Unit Actions",
        "actions": [
          "move",
          "hold"
        ]
      }
    },
    "animations": {
      "2h_slash": {
        "title": "2h_slash",
        "file": "animations/2h_slash.glb"
      },
      "1h_axe_swing": {
        "title": "1h_axe_swing",
        "file": "animations/1h_axe_swing.glb"
      },
      "2h_spell_slam": {
        "title": "2h_spell_slam",
        "file": "animations/2h_spell_slam.glb"
      },
      "dance_gangnamstyle": {
        "title": "GangnamStyle",
        "file": "animations/dance_gangnamstyle.glb"
      },
      "death_delayed": {
        "title": "death_delayed",
        "file": "animations/death_delayed.glb"
      },
      "death_fallback": {
        "title": "death_fallback",
        "file": "animations/death_fallback.glb"
      },
      "hovering": {
        "title": "hovering",
        "file": "animations/hovering.glb"
      },
      "idle": {
        "title": "idle",
        "file": "animations/idle.glb"
      },
      "mutant_run": {
        "title": "mutant_run",
        "file": "animations/mutant_run.glb"
      },
      "shooting_arrow": {
        "title": "shooting_arrow",
        "file": "animations/shooting_arrow.glb"
      },
      "mutant_walk": {
        "title": "mutant_walk",
        "file": "animations/mutant_walk.glb"
      },
      "sword_slash": {
        "title": "sword_slash",
        "file": "animations/sword_slash.glb"
      },
      "walk_steady_right_hand": {
        "title": "walk_steady_right_hand",
        "file": "animations/walk_steady_right_hand.glb"
      },
      "2h_spell_cast": {
        "title": "2h_spell_cast",
        "file": "animations/2h_spell_cast.glb"
      },
      "dance_thriller": {
        "title": "Dance Thriller",
        "file": "animations/dance_thriller.glb"
      },
      "death_flyback": {
        "title": "death_flyback",
        "file": "animations/death_flyback.glb"
      },
      "mutant_idle": {
        "title": "mutant_idle",
        "file": "animations/mutant_idle.glb"
      },
      "swimming": {
        "title": "swimming",
        "file": "animations/swimming.glb"
      },
      "sword_and_shield_cast": {
        "title": "sword_and_shield_cast",
        "file": "animations/sword_and_shield_cast.glb"
      },
      "1h_spell_throw": {
        "title": "1h_spell_throw",
        "file": "animations/1h_spell_throw.glb"
      },
      "2h_spell_calldown": {
        "title": "2h_spell_calldown",
        "file": "animations/2h_spell_calldown.glb"
      },
      "death_fallforward": {
        "title": "death_fallforward",
        "file": "animations/death_fallforward.glb"
      },
      "mutant_swipe": {
        "title": "mutant_swipe",
        "file": "animations/mutant_swipe.glb"
      },
      "walk_with_shield": {
        "title": "walk_with_shield",
        "file": "animations/walk_with_shield.glb"
      },
      "2h_spell_blast": {
        "title": "2h_spell_blast",
        "file": "animations/2h_spell_blast.glb"
      },
      "2h_spell_summon": {
        "title": "2h_spell_summon",
        "file": "animations/2h_spell_summon.glb"
      },
      "running_with_2h": {
        "title": "running_with_2h",
        "file": "animations/running_with_2h.glb"
      },
      "walk_bow": {
        "title": "walk_bow",
        "file": "animations/walk_bow.glb"
      }
    },
    "effects": {
      "goldPerTrip": {
        "title": "Gold Per Trip",
        "desc": "Extra gold per trip.",
        "type": "upgrade",
        "value": 5
      },
      "spellDamage": {
        "title": "Spell Damage",
        "description": "",
        "type": "upgrade",
        "value": 10
      },
      "weaken": {
        "id": "weaken",
        "title": "Weakened",
        "desc": "Target's armor is reduced",
        "stat": "armor",
        "lifeTime": 100
      },
      "slow": {
        "id": "slow",
        "title": "Slow",
        "desc": "Target is slowed",
        "stat": "speed",
        "lifeTime": 100
      }
    },
    "models": {
      "position": {
        "title": "Position",
        "x": 0,
        "y": 0,
        "z": 0
      }
    },
    "modifierSets": {
      "global": {
        "maxBloodCoreHP": 100,
        "bloodShardMultiplier": 1,
        "towerCostMod": 1,
        "damageMultiplier": 1,
        "healingMultiplier": 1,
        "essenceMultiplier": 1,
        "towerDamageReduction": 1,
        "population": 0,
        "maxPopulation": 5
      }
    },
    "upgrades": {
      "peasantEfficiency": {
        "title": "Peasant Efficiency",
        "description": "Increase Gold Per Trip by 5",
        "value": 100,
        "effects": [
          "goldPerTrip"
        ]
      },
      "spellDamage": {
        "title": "Spell Damage",
        "description": "Increase Spell Damage",
        "value": 100,
        "effects": [
          "spellDamage"
        ]
      }
    },
    "cameras": {
      "main_perspective": {
        "title": "Main Perspective",
        "near": 0.1,
        "far": 4000,
        "position": "{ \"x\": 1000, \"y\": 750, \"z\": 1000}",
        "lookAt": "{ \"x\": 384, \"y\": 15, \"z\": 384 }",
        "fov": 75
      },
      "main": {
        "title": "Main Orthographic",
        "near": 0.1,
        "far": 50000,
        "position": "{ \"x\": 64, \"y\": 512, \"z\": 512}",
        "lookAt": "{ \"x\": 64, \"y\": 16, \"z\": 64}",
        "zoom": 1
      }
    },
    "fogs": {
      "sunnyDayFog": {
        "title": "Sunny Day Fog",
        "color": "#b3e5fc",
        "density": 0.00004,
        "enabled": false
      }
    },
    "heightMaps": {
      "fiveStep": {
        "title": "Five Step and Smoothing",
        "heightStep": 15,
        "smoothing": false,
        "enabled": true,
        "resolutionDivisor": 4
      }
    },
    "lightings": {
      "sunnyDayLighting": {
        "title": "Sunny Day Lighting",
        "ambientColor": "#b3e5fc",
        "ambientIntensity": 0.4,
        "directionalColor": "#ffcc80",
        "directionalIntensity": 0.7,
        "skyColor": "#b3e5fc",
        "groundColor": "#5a8a4f",
        "hemisphereIntensity": 0.5,
        "direction": "{\"x\":0,\"y\":-1,\"z\":-1}"
      }
    },
    "scenes": {
      "server": {
        "title": "server",
        "type": "ECS",
        "sceneData": [
          {
            "id": 1,
            "objectType": "gamePrefabs",
            "spawnType": "multiplayer",
            "managers": [
              {
                "type": "ComponentManager"
              },
              {
                "type": "GameManager"
              },
              {
                "type": "UnitCreationManager"
              },
              {
                "type": "SquadManager"
              }
            ],
            "systems": [
              {
                "type": "TerrainSystem"
              },
              {
                "type": "AISystem"
              },
              {
                "type": "MovementSystem"
              },
              {
                "type": "CombatAISystem"
              },
              {
                "type": "ProjectileSystem"
              },
              {
                "type": "TeamHealthSystem"
              },
              {
                "type": "DeathSystem"
              },
              {
                "type": "DamageSystem"
              },
              {
                "type": "AbilitySystem"
              },
              {
                "type": "SquadExperienceSystem"
              },
              {
                "type": "ServerBattlePhaseSystem"
              },
              {
                "type": "ServerPlacementSystem"
              },
              {
                "type": "LifetimeSystem"
              },
              {
                "type": "GridSystem"
              },
              {
                "type": "SchedulingSystem"
              },
              {
                "type": "PathfindingSystem"
              },
              {
                "type": "GoldMineSystem"
              },
              {
                "type": "VisionSystem"
              },
              {
                "type": "SupplySystem"
              }
            ],
            "classes": [
              {
                "collection": "abilities",
                "baseClass": "BaseAbility"
              }
            ]
          }
        ]
      },
      "client": {
        "title": "client",
        "type": "ECS",
        "sceneData": [
          {
            "id": 1,
            "objectType": "gamePrefabs",
            "spawnType": "multiplayer",
            "parent": null,
            "children": [],
            "managers": [
              {
                "type": "ComponentManager"
              },
              {
                "type": "GameManager"
              },
              {
                "type": "GameModeManager"
              },
              {
                "type": "KeyboardManager"
              },
              {
                "type": "LoadingManager"
              },
              {
                "type": "ResultsManager"
              },
              {
                "type": "SaveManager"
              },
              {
                "type": "ScreenManager"
              },
              {
                "type": "UnitCreationManager"
              },
              {
                "type": "SquadManager"
              },
              {
                "type": "MultiplayerNetworkManager"
              },
              {
                "type": "InputManager"
              }
            ],
            "systems": [
              {
                "type": "TerrainSystem"
              },
              {
                "type": "WorldSystem"
              },
              {
                "type": "PostProcessingSystem"
              },
              {
                "type": "RenderSystem"
              },
              {
                "type": "AISystem"
              },
              {
                "type": "MovementSystem"
              },
              {
                "type": "CombatAISystem"
              },
              {
                "type": "ProjectileSystem"
              },
              {
                "type": "AnimationSystem"
              },
              {
                "type": "ArmyDisplaySystem"
              },
              {
                "type": "EffectsSystem"
              },
              {
                "type": "GridSystem"
              },
              {
                "type": "MultiplayerPlacementSystem"
              },
              {
                "type": "MultiplayerUISystem"
              },
              {
                "type": "ShopSystem"
              },
              {
                "type": "TeamHealthSystem"
              },
              {
                "type": "HealthBarSystem"
              },
              {
                "type": "UnitRadiusSystem"
              },
              {
                "type": "EquipmentSystem"
              },
              {
                "type": "DeathSystem"
              },
              {
                "type": "DamageSystem"
              },
              {
                "type": "AbilitySystem"
              },
              {
                "type": "ParticleSystem"
              },
              {
                "type": "SquadExperienceSystem"
              },
              {
                "type": "LifetimeSystem"
              },
              {
                "type": "MultiplayerUISystem"
              },
              {
                "type": "SchedulingSystem"
              },
              {
                "type": "GoldMineSystem"
              },
              {
                "type": "PathfindingSystem"
              },
              {
                "type": "FogOfWarSystem"
              },
              {
                "type": "SelectedUnitSystem"
              },
              {
                "type": "UnitOrderSystem"
              },
              {
                "type": "MiniMapSystem"
              },
              {
                "type": "CameraControlSystem"
              },
              {
                "type": "DamageNumberSystem"
              },
              {
                "type": "VisionSystem"
              },
              {
                "type": "SupplySystem"
              }
            ],
            "classes": [
              {
                "collection": "abilities",
                "baseClass": "BaseAbility"
              }
            ]
          }
        ]
      }
    },
    "shadows": {
      "sunnyDayShadows": {
        "title": "Sunny Day Shadows",
        "mapSize": 2048,
        "bias": -0.0003,
        "normalBias": 0,
        "radius": 512,
        "enabled": true
      }
    },
    "worlds": {
      "shire": {
        "title": "Shire",
        "lighting": "sunnyDayLighting",
        "shadow": "sunnyDayShadows",
        "fog": "sunnyDayFog",
        "heightMap": "fiveStep",
        "camera": "main",
        "extensionSize": 768,
        "worldObjects": [
          "tree",
          "rock",
          "goldVein"
        ],
        "backgroundColor": "#b3e5fc"
      }
    },
    "buildings": {
      "fletchersHall": {
        "title": "Fletchers Hall",
        "info": "Dexterity based training.",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/fletchers_hall/fletchers_hall.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "units": [
          "1_di_scout",
          "1_d_archer"
        ],
        "footprintWidth": 2,
        "footprintHeight": 2,
        "height": 100,
        "size": 50,
        "icon": "building_fletchersHall",
        "hp": 1500
      },
      "goldMine": {
        "title": "Gold Mine",
        "info": "Mine gold veins",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/goldmine/goldmine.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1.5,
                "y": 1.5,
                "z": 1.5
              }
            }
          }
        },
        "upgrades": [
          "peasantEfficiency"
        ],
        "units": [],
        "footprintWidth": 2,
        "footprintHeight": 2,
        "size": 50,
        "icon": "building_goldMine",
        "hp": 2000,
        "height": 100
      },
      "castle": {
        "title": "Castle",
        "category": "townhall",
        "value": 100,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "width": 24,
                  "height": 16,
                  "depth": 24,
                  "color": "#cfd8dc",
                  "x": 0,
                  "y": 32,
                  "z": 0,
                  "size": 24,
                  "name": "dome",
                  "scaleX": 1
                },
                {
                  "type": "cylinder",
                  "size": 12,
                  "height": 22,
                  "color": "#cfd8dc",
                  "x": 0,
                  "y": 42,
                  "z": 0,
                  "name": "spire"
                },
                {
                  "type": "cone",
                  "size": 14,
                  "height": 20,
                  "color": "#ab47bc",
                  "x": 0,
                  "y": 62,
                  "z": 0,
                  "name": "spire roof"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 0.7,
                "z": 1
              }
            },
            "base": {
              "shapes": [
                {
                  "type": "box",
                  "width": 40,
                  "height": 12,
                  "depth": 40,
                  "color": "#3e4f57",
                  "x": 0,
                  "y": 6,
                  "z": 0,
                  "scaleX": 1,
                  "name": "base"
                },
                {
                  "type": "box",
                  "width": 44,
                  "height": 4,
                  "depth": 44,
                  "color": "#3e4f57",
                  "x": 0,
                  "y": 2,
                  "z": 0,
                  "name": "foundation"
                },
                {
                  "type": "box",
                  "width": 32,
                  "height": 12,
                  "depth": 32,
                  "color": "#78909c",
                  "x": 0,
                  "y": 17,
                  "z": 0,
                  "name": "main structure"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "towers": {
              "shapes": [
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": 16,
                  "y": 22,
                  "z": 16,
                  "name": "tower1"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": -16,
                  "y": 22,
                  "z": 16,
                  "name": "tower2"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": 16,
                  "y": 22,
                  "z": -16,
                  "name": "tower3"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": -16,
                  "y": 22,
                  "z": -16,
                  "name": "tower4"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": 16,
                  "y": 42,
                  "z": 16,
                  "name": "tower1roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": -16,
                  "y": 42,
                  "z": 16,
                  "name": "tower2roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": 16,
                  "y": 42,
                  "z": -16,
                  "name": "tower3roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": -16,
                  "y": 42,
                  "z": -16,
                  "name": "tower4roof"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 0.7,
                "z": 1
              }
            }
          }
        },
        "size": 75
      },
      "townHall": {
        "title": "Town Hall",
        "category": "townhall",
        "value": 100,
        "upgrades": [
          "peasantEfficiency"
        ],
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "purpleMColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "purpleMColor"
                  },
                  "roughness": 1,
                  "metalness": 0,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/townhall/townhall.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "footprintWidth": 3,
        "footprintHeight": 3,
        "units": [
          "peasant"
        ],
        "height": 1000,
        "size": 75,
        "icon": "building_townHall",
        "hp": 2500,
        "visionRange": 2000,
        "supplyProvided": 10
      },
      "cottage": {
        "title": "Cottage",
        "info": "A structure that fires arrows.",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/cottage/cottage.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        },
        "units": [],
        "footprintWidth": 1,
        "footprintHeight": 1,
        "height": 100,
        "size": 50,
        "icon": "building_cottage",
        "hp": 500,
        "supplyProvided": 8
      },
      "underConstruction": {
        "title": "Under Construction",
        "info": "Under Construction",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/underConstruction/underConstruction.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "units": [],
        "footprintWidth": 3,
        "footprintHeight": 2,
        "height": 100,
        "size": 75,
        "hp": 1000
      },
      "barracks": {
        "title": "Barracks",
        "info": "Strength based training.",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "metalness": 0,
                      "roughness": 1,
                      "x": 0,
                      "z": 0,
                      "scaleX": 1,
                      "name": "foundation",
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/barracks/barracks.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "units": [
          "1_sd_soldier",
          "1_s_barbarian"
        ],
        "footprintWidth": 2,
        "footprintHeight": 3,
        "height": 100,
        "size": 75,
        "icon": "building_barracks",
        "hp": 1500,
        "supplies": 7
      },
      "keep": {
        "title": "Keep",
        "category": "townhall",
        "value": 100,
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "width": 24,
                  "height": 16,
                  "depth": 24,
                  "color": "#cfd8dc",
                  "x": 0,
                  "y": 32,
                  "z": 0,
                  "size": 24,
                  "name": "dome",
                  "scaleX": 1
                },
                {
                  "type": "cylinder",
                  "size": 12,
                  "height": 22,
                  "color": "#cfd8dc",
                  "x": 0,
                  "y": 42,
                  "z": 0,
                  "name": "spire"
                },
                {
                  "type": "cone",
                  "size": 14,
                  "height": 20,
                  "color": "#ab47bc",
                  "x": 0,
                  "y": 62,
                  "z": 0,
                  "name": "spire roof"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 0.7,
                "z": 1
              }
            },
            "base": {
              "shapes": [
                {
                  "type": "box",
                  "width": 40,
                  "height": 12,
                  "depth": 40,
                  "color": "#3e4f57",
                  "x": 0,
                  "y": 6,
                  "z": 0,
                  "scaleX": 1,
                  "name": "base"
                },
                {
                  "type": "box",
                  "width": 44,
                  "height": 4,
                  "depth": 44,
                  "color": "#3e4f57",
                  "x": 0,
                  "y": 2,
                  "z": 0,
                  "name": "foundation"
                },
                {
                  "type": "box",
                  "width": 32,
                  "height": 12,
                  "depth": 32,
                  "color": "#78909c",
                  "x": 0,
                  "y": 17,
                  "z": 0,
                  "name": "main structure"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "towers": {
              "shapes": [
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": 16,
                  "y": 22,
                  "z": 16,
                  "name": "tower1"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": -16,
                  "y": 22,
                  "z": 16,
                  "name": "tower2"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": 16,
                  "y": 22,
                  "z": -16,
                  "name": "tower3"
                },
                {
                  "type": "cylinder",
                  "size": 6,
                  "height": 30,
                  "color": "#cfd8dc",
                  "x": -16,
                  "y": 22,
                  "z": -16,
                  "name": "tower4"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": 16,
                  "y": 42,
                  "z": 16,
                  "name": "tower1roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": -16,
                  "y": 42,
                  "z": 16,
                  "name": "tower2roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": 16,
                  "y": 42,
                  "z": -16,
                  "name": "tower3roof"
                },
                {
                  "type": "cone",
                  "size": 8,
                  "height": 10,
                  "color": "#0288d1",
                  "x": -16,
                  "y": 42,
                  "z": -16,
                  "name": "tower4roof"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 0.7,
                "z": 1
              }
            }
          }
        },
        "size": 75
      },
      "sentryTower": {
        "title": "Sentry Tower",
        "info": "A structure that fires arrows.",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/mage_tower/mage_tower.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "units": [],
        "footprintWidth": 2,
        "footprintHeight": 2,
        "height": 100,
        "size": 50,
        "icon": "unit_archer",
        "damage": 20,
        "attackSpeed": 1,
        "range": 300,
        "projectile": "arrow",
        "element": "physical",
        "hp": 500
      },
      "mageTower": {
        "title": "Mage Tower",
        "info": "Intelligence based training.",
        "value": 50,
        "category": "attribute",
        "render": {
          "animations": {
            "idle": [
              {}
            ],
            "underConstruction": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "blueDColor"
                      },
                      "url": "models/underConstruction/underConstruction.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "blueDColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "z": 0,
                  "scaleX": 1,
                  "name": "foundation",
                  "url": "models/mage_tower/mage_tower.glb"
                }
              ],
              "position": {
                "x": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              }
            }
          }
        },
        "upgrades": [
          "spellDamage"
        ],
        "units": [
          "1_is_acolyte",
          "1_i_apprentice"
        ],
        "footprintWidth": 2,
        "footprintHeight": 2,
        "height": 100,
        "anchored": true,
        "size": 50,
        "icon": "building_mageTower",
        "hp": 1500
      }
    },
    "cliffs": {
      "atom_four": {
        "title": "Atom Four",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "name": "main",
                  "url": "models/atom_four/atom_four.glb",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.375,
                "z": 0.375
              }
            }
          }
        }
      },
      "atom_one": {
        "title": "Atom One",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "name": "main",
                  "url": "models/atom_one_grass/atom_one_grass.glb"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.375,
                "y": 1.01,
                "z": 0.375
              }
            }
          }
        }
      },
      "atom_two": {
        "title": "Atom Two",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "name": "main",
                  "url": "models/atom_two_grass/atom_two_grass.glb"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.375,
                "z": 0.375,
                "y": 1.01
              }
            }
          }
        }
      },
      "atom_three": {
        "title": "Atom Three",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "type": "gltf",
                  "color": {
                    "paletteColor": "greyMColor"
                  },
                  "metalness": 0,
                  "roughness": 1,
                  "name": "main",
                  "url": "models/atom_three_grass/atom_three_grass.glb"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.375,
                "y": 1.01,
                "z": 0.375
              }
            }
          }
        }
      }
    },
    "gamePrefabs": {
      "main": {
        "title": "main",
        "entity": "ECSGame",
        "palette": "main",
        "mapRenderer": "level1",
        "mapManager": "level1",
        "threeJsWorld": "level1"
      }
    },
    "items": {
      "axe1h": {
        "title": "Axe 1H",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_axe_1h/item_axe_1h.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      },
      "knightSword": {
        "title": "Knight Sword",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_sword_knight/item_sword_knight.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      },
      "shieldSnowflake": {
        "title": "Snowflake Shield",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_shield_snowflake/item_shield_snowflake.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      },
      "woodStaff": {
        "title": "Wood Staff",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_staff_wood/item_staff_wood.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "position": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 0.99,
                    "y": 0.99,
                    "z": 0.99
                  }
                }
              ]
            }
          }
        }
      },
      "woodBow": {
        "title": "Wood Bow",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1,
                "z": 0
              },
              "rotation": {
                "x": -4.40619762898109e-16,
                "z": -0.008513801229241034
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_bow_peasant/item_bow_peasant.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "position": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 2,
                    "y": 2,
                    "z": 5
                  }
                }
              ]
            }
          }
        }
      },
      "knightShield": {
        "title": "Knight Shield",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_shield_knight/item_shield_knight.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      },
      "shieldLeaf": {
        "title": "Leaf Shield",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_shield_leaf/item_shield_leaf.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      },
      "staff_feathers": {
        "title": "Feathered Staff",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/item_staff_feathers/item_staff_feathers.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        }
      }
    },
    "particles": {
      "smoke": {
        "title": "Smoke",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "sphere",
                      "size": 1,
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "id": 0
                    }
                  ]
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "type": "sphere",
                      "size": 1,
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "id": 0
                    }
                  ],
                  "scale": {
                    "x": 2,
                    "y": 2,
                    "z": 2
                  }
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    }
                  ],
                  "scale": {
                    "x": 4,
                    "y": 4,
                    "z": 4
                  }
                }
              },
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "id": 0
                    }
                  ],
                  "scale": {
                    "x": 8,
                    "y": 8,
                    "z": 8
                  }
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "sphere",
                  "size": 1,
                  "color": "#000000",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "lifeSpan": 0.66
      }
    },
    "projectiles": {
      "elvenArrow": {
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/projectile_arrow/projectile_arrow.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ],
              "scale": {
                "z": 0.25,
                "y": 0.25,
                "x": 0.25
              }
            }
          }
        },
        "speed": 1000,
        "title": "Elven Arrow",
        "attackSound": "plasma",
        "hitSound": "plasma",
        "homing": true,
        "homingStrength": 0.5
      },
      "huntingArrow": {
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/projectile_arrow/projectile_arrow.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ],
              "scale": {
                "z": 0.25,
                "y": 0.25,
                "x": 0.25
              }
            }
          }
        },
        "speed": 1000,
        "title": "Hunting Arrow",
        "attackSound": "plasma",
        "hitSound": "plasma",
        "homing": true,
        "homingStrength": 0.3
      },
      "arrow": {
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/projectile_arrow/projectile_arrow.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ],
              "scale": {
                "y": 0.5,
                "x": 0.5,
                "z": 0.5
              }
            }
          }
        },
        "speed": 1000,
        "title": "Arrow",
        "attackSound": "plasma",
        "hitSound": "plasma",
        "homing": false,
        "homingStrength": 0
      },
      "lightning": {
        "customRenderer": "",
        "damageType": "electric",
        "speed": 5,
        "title": "Lightning"
      },
      "fireball": {
        "damageType": "fire",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "name": "ball",
                  "type": "sphere",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "size": 0.2,
                  "color": {
                    "paletteColor": "redDColor"
                  },
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1
                }
              ],
              "position": {
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "speed": 300,
        "title": "Fireball",
        "ballistic": false,
        "homing": false,
        "homingStrength": 0,
        "particle": "smoke",
        "shadows": false,
        "hitSound": "explosion",
        "attackSound": "missileLaunch"
      },
      "bolt": {
        "damageType": "physical",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/projectile_arrow/projectile_arrow.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ],
              "scale": {
                "z": 0.25,
                "y": 0.25,
                "x": 0.25
              }
            }
          }
        },
        "speed": 1000,
        "title": "Bolt",
        "attackSound": "plasma",
        "hitSound": "plasma",
        "homing": false,
        "homingStrength": 0
      },
      "boulder": {
        "damageType": "fire",
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "name": "ball",
                      "type": "sphere",
                      "size": 12,
                      "x": 0,
                      "z": 0,
                      "rotationX": 90,
                      "color": {
                        "paletteColor": "greyDColor"
                      },
                      "rotationY": 0,
                      "rotationZ": 0,
                      "scaleX": 1,
                      "scaleY": 1,
                      "scaleZ": 1,
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "shapes": [
                {
                  "name": "ball",
                  "type": "sphere",
                  "size": 12,
                  "x": 0,
                  "z": 0,
                  "rotationX": 90,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1
                }
              ],
              "position": {
                "x": -3.00653594771243,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "speed": 100,
        "title": "Boulder",
        "ballistic": true,
        "homing": false,
        "homingStrength": 0,
        "particle": "smoke",
        "shadows": false,
        "hitSound": "explosion",
        "attackSound": "missileLaunch"
      }
    },
    "units": {
      "0_golemFire": {
        "title": "Fire Golem",
        "size": 25,
        "height": 100,
        "value": 480,
        "hp": 2500,
        "speed": 15,
        "damage": 40,
        "attackSpeed": 0.7,
        "element": "fire",
        "armor": 8,
        "fireResistance": 1,
        "coldResistance": -0.25,
        "lightningResistance": 0.1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_walk.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_swipe.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/golem_fire/golem_fire.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "BurningAuraAbility"
        ]
      },
      "0_golemStone": {
        "title": "Stone Golem",
        "size": 25,
        "height": 100,
        "value": 480,
        "hp": 2500,
        "speed": 15,
        "damage": 150,
        "attackSpeed": 0.7,
        "element": "physical",
        "armor": 12,
        "fireResistance": 0.1,
        "coldResistance": 0.1,
        "lightningResistance": 0.1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_walk.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_swipe.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/golem/golem.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "buyable": true,
        "squadWidth": 1,
        "squadHeight": 1,
        "specUnits": [
          "0_golemIce",
          "0_golemFire"
        ],
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "icon": "unit_stoneGolem"
      },
      "1_di_scout": {
        "title": "Rogue",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 150,
        "speed": 60,
        "damage": 40,
        "attackSpeed": 1.2,
        "range": 100,
        "projectile": "arrow",
        "element": "physical",
        "armor": 0,
        "fireResistance": 0.25,
        "coldResistance": 0.25,
        "lightningResistance": 0.25,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/shooting_arrow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/rogue/rogue.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 3,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 90
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [
          "2_di_shadowAssassin",
          "2_di_trickster",
          "2_di_goblinBomber"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "icon": "unit_rogue",
        "visionRange": 800,
        "supplyCost": 2
      },
      "1_is_acolyte": {
        "title": "Acolyte",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 150,
        "speed": 45,
        "damage": 10,
        "attackSpeed": 0.9,
        "element": "divine",
        "armor": 6,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/acolyte/acolyte.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 5,
                  "y": 0,
                  "z": -2
                },
                "rotation": {
                  "x": 15,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [
          "2_is_paladin",
          "2_is_crusader",
          "2_is_oathBreaker"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "HealAbility"
        ],
        "icon": "unit_acolyte",
        "visionRange": 500,
        "supplyCost": 2
      },
      "1_sd_soldier": {
        "title": "Soldier",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 300,
        "speed": 45,
        "damage": 12,
        "attackSpeed": 0.8,
        "element": "physical",
        "armor": 4,
        "fireResistance": 0.25,
        "coldResistance": 0.25,
        "lightningResistance": 0.25,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/warrior/warrior.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 15,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [
          "2_sd_knight",
          "2_sd_hoplite",
          "2_sd_crossbowman"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "WindShieldAbility"
        ],
        "icon": "unit_soldier",
        "visionRange": 500,
        "supplyCost": 2
      },
      "1_s_barbarian": {
        "title": "Barbarian",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 300,
        "speed": 40,
        "damage": 10,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 8,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/sword_slash/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/barbarian/barbarian.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 5,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [
          "2_s_berserker",
          "2_s_gladiator",
          "2_s_warlord"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [],
        "range": 5,
        "projectile": "arrow",
        "icon": "unit_barbarian",
        "visionRange": 500,
        "supplyCost": 2
      },
      "2_d_ranger": {
        "title": "Ranger (2) [D]",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 140,
        "speed": 55,
        "damage": 16,
        "attackSpeed": 1.1,
        "range": 400,
        "projectile": "arrow",
        "element": "physical",
        "fireResistance": 0.5,
        "coldResistance": 0.5,
        "lightningResistance": 0.5,
        "armor": 1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/shooting_arrow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/ranger/ranger.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": []
      },
      "2_is_crusader": {
        "title": "Templar (2) [IS]",
        "size": 25,
        "height": 50,
        "value": 110,
        "hp": 200,
        "speed": 35,
        "damage": 14,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 6,
        "fireResistance": 0.2,
        "coldResistance": 0.2,
        "lightningResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/templar/templar.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": -1,
                  "y": 10,
                  "z": 2
                },
                "rotation": {
                  "x": 0,
                  "y": 8,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 5,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 10,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "HealAbility"
        ]
      },
      "2_i_enchanter": {
        "title": "Enchanter (2) [I]",
        "size": 25,
        "height": 50,
        "value": 140,
        "hp": 150,
        "speed": 55,
        "damage": 0,
        "attackSpeed": 0,
        "range": 160,
        "armor": 2,
        "fireResistance": 0.4,
        "coldResistance": 0,
        "lightningResistance": 0.2,
        "abilities": [
          "MindControlAbility"
        ],
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/2h_spell_summon.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/evil_sorcerer/evil_sorcerer.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "staff_feathers",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 5,
                  "z": -8
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "2_sd_crossbowman": {
        "title": "Crossbowman (2) [SD]",
        "size": 25,
        "height": 50,
        "value": 380,
        "hp": 450,
        "speed": 40,
        "damage": 32,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 12,
        "fireResistance": 0.6,
        "coldResistance": 0.1,
        "lightningResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/shooting_arrow/shooting_arrow.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/hoplite/hoplite.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": -5,
                  "y": 5,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": -20
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "range": 200,
        "projectile": "bolt"
      },
      "2_is_paladin": {
        "title": "Paladin (2) [IS]",
        "size": 25,
        "height": 50,
        "value": 110,
        "hp": 200,
        "speed": 35,
        "damage": 14,
        "attackSpeed": 1,
        "element": "divine",
        "armor": 6,
        "fireResistance": 0.2,
        "coldResistance": 0.2,
        "lightningResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/paladin/paladin.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 8,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 20,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "SmiteAbility"
        ]
      },
      "2_s_gladiator": {
        "title": "Gladiator (2) [S]",
        "size": 25,
        "height": 50,
        "value": 50,
        "hp": 150,
        "speed": 35,
        "damage": 12,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 4,
        "fireResistance": 0.05,
        "coldResistance": 0.05,
        "lightningResistance": 0.05,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/gladiator/gladiator.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 2,
                  "y": 5,
                  "z": 2
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 10
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "ArenaPresenceAbility"
        ]
      },
      "2_sd_knight": {
        "title": "Knight (2) [SD]",
        "size": 35,
        "height": 50,
        "value": 110,
        "hp": 240,
        "speed": 25,
        "damage": 20,
        "attackSpeed": 0.9,
        "element": "physical",
        "armor": 8,
        "fireResistance": 0.15,
        "coldResistance": 0.15,
        "lightningResistance": 0.1,
        "poisonResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "url": "models/knight/knight.glb",
                  "metalness": "0",
                  "roughness": "1"
                }
              ],
              "scale": {
                "z": 1,
                "y": 1,
                "x": 1
              }
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 6,
                  "y": 16,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": -6
                },
                "rotation": {
                  "x": 10,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "ChargeAbility"
        ]
      },
      "4_ancientTreant": {
        "title": "Ancient Treant",
        "size": 25,
        "height": 100,
        "value": 480,
        "hp": 720,
        "speed": 15,
        "damage": 40,
        "attackSpeed": 0.7,
        "element": "physical",
        "armor": 12,
        "fireResistance": -0.2,
        "coldResistance": 0.3,
        "lightningResistance": 0.1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_walk.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_swipe.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/treant/treant.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "4_archmage": {
        "title": "Archmage",
        "size": 25,
        "height": 50,
        "value": 420,
        "hp": 200,
        "speed": 30,
        "damage": 30,
        "attackSpeed": 0.7,
        "range": 200,
        "projectile": "fireball",
        "element": "fire",
        "armor": 4,
        "fireResistance": 0.5,
        "coldResistance": 0.2,
        "lightningResistance": 0.3,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/1h_spell_throw.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/archmage/archmage.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodStaff",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 15,
                  "z": 2
                },
                "rotation": {
                  "x": 0,
                  "y": 180,
                  "z": 0
                }
              }
            }
          ]
        },
        "abilities": [
          "ChainLightningAbility"
        ],
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "peasant": {
        "title": "Peasant",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 60,
        "speed": 40,
        "damage": 6,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 8,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/sword_slash/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/peasant/peasant.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "axe1h",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "MineGoldAbility",
          "BuildAbility"
        ],
        "icon": "unit_peasant",
        "actionSet": "peasant_actions",
        "visionRange": 400,
        "supplyCost": 1
      },
      "0_skeleton": {
        "title": "Skeleton",
        "size": 25,
        "height": 50,
        "value": -1,
        "hp": 50,
        "speed": 65,
        "damage": 10,
        "attackSpeed": 1,
        "element": "physical",
        "armor": 5,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/skeleton/skeleton.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": -8,
                  "y": -5,
                  "z": 3
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "1_i_apprentice": {
        "title": "Apprentice",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 150,
        "speed": 55,
        "damage": 15,
        "attackSpeed": 1.1,
        "range": 150,
        "element": "fire",
        "armor": 1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/1h_spell_throw/1h_spell_throw.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/apprentice/apprentice.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "woodStaff",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 20,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": true,
        "projectile": "fireball",
        "specUnits": [
          "2_i_elementalist",
          "2_i_enchanter",
          "2_i_necromancer"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [],
        "icon": "unit_apprentice",
        "visionRange": 500,
        "supplyCost": 2
      },
      "2_di_goblinBomber": {
        "title": "Goblin Bomber (2) [DI]",
        "size": 25,
        "height": 50,
        "value": 120,
        "hp": 450,
        "speed": 60,
        "damage": 40,
        "attackSpeed": 1.2,
        "element": "fire",
        "armor": 1,
        "fireResistance": 0.75,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 0.5,
                "y": 0.5,
                "z": 0.5
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/goblin/goblin.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "MeteorStrikeAbility"
        ],
        "range": 100,
        "projectile": "fireball"
      },
      "2_di_shadowAssassin": {
        "title": "Shadow Assassin (2) [DI]",
        "size": 25,
        "height": 50,
        "value": 320,
        "hp": 500,
        "speed": 80,
        "damage": 28,
        "attackSpeed": 2,
        "element": "physical",
        "armor": 4,
        "fireResistance": 0.1,
        "coldResistance": 0.2,
        "lightningResistance": 0.15,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/walk_bow.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/sword_slash.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/assassin/assassin.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 20,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": -20,
                  "z": -910
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "ShadowStrikeAbility"
        ]
      },
      "2_di_trickster": {
        "title": "Trickster (2) [DI]",
        "size": 25,
        "height": 50,
        "value": 320,
        "hp": 350,
        "speed": 80,
        "damage": 28,
        "attackSpeed": 2,
        "element": "poison",
        "armor": 4,
        "fireResistance": 0.1,
        "coldResistance": 0.2,
        "lightningResistance": 0.15,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/walk_bow.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/sword_slash.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/trickster/trickster.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 20,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": -20,
                  "z": -910
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "MirrorImagesAbility"
        ]
      },
      "2_d_trapper": {
        "title": "Trapper (2) [D]",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 140,
        "speed": 55,
        "damage": 16,
        "attackSpeed": 1.1,
        "range": 200,
        "projectile": "arrow",
        "element": "physical",
        "fireResistance": 0.5,
        "coldResistance": 0.5,
        "lightningResistance": 0.5,
        "armor": 1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/shooting_arrow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/ranger/ranger.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "ExplosiveTrapAbility"
        ]
      },
      "2_i_elementalist": {
        "title": "Elementalist (2) [I]",
        "size": 25,
        "height": 50,
        "value": 140,
        "hp": 150,
        "speed": 55,
        "damage": 0,
        "attackSpeed": 0,
        "range": 160,
        "armor": 2,
        "fireResistance": 0.4,
        "coldResistance": 0,
        "lightningResistance": 0.2,
        "abilities": [
          "ChainLightningAbility"
        ],
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/2h_spell_summon.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/archmage/archmage.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "staff_feathers",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": -10,
                  "y": 15,
                  "z": 0
                },
                "rotation": {
                  "x": 180,
                  "y": 0,
                  "z": 180
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "2_sd_hoplite": {
        "title": "Hoplite (2) [SD]",
        "size": 25,
        "height": 50,
        "value": 380,
        "hp": 450,
        "speed": 40,
        "damage": 32,
        "attackSpeed": 1,
        "element": "fire",
        "armor": 12,
        "fireResistance": 0.6,
        "coldResistance": 0.1,
        "lightningResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/hoplite/hoplite.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": -10
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": -20
                },
                "rotation": {
                  "x": 10,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "PhalanxFormationAbility"
        ]
      },
      "2_s_warlord": {
        "title": "Warlord (2) [S]",
        "size": 35,
        "height": 50,
        "value": 110,
        "hp": 240,
        "speed": 25,
        "damage": 20,
        "attackSpeed": 0.9,
        "element": "physical",
        "armor": 8,
        "fireResistance": 0.15,
        "coldResistance": 0.15,
        "lightningResistance": 0.1,
        "poisonResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "gltf",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "metalness": "0",
                  "roughness": "1",
                  "color": "#FFFFFF",
                  "url": "models/berserker/berserker.glb"
                }
              ],
              "scale": {
                "z": 1,
                "y": 1,
                "x": 1
              }
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 6,
                  "y": 16,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": -6
                },
                "rotation": {
                  "x": 10,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "BattleCryAbility"
        ]
      },
      "0_golemIce": {
        "title": "Ice Golem",
        "size": 25,
        "height": 100,
        "value": 480,
        "hp": 2500,
        "speed": 15,
        "damage": 40,
        "attackSpeed": 0.7,
        "element": "cold",
        "armor": 8,
        "coldResistance": 1,
        "lightningResistance": 0.1,
        "fireResistance": -0.25,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/idle.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_walk.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/mutant_swipe.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 2,
                "y": 2,
                "z": 2
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/golem_ice/golem_ice.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          }
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "FreezingAuraAbility"
        ]
      },
      "1_d_archer": {
        "title": "Archer",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 150,
        "speed": 55,
        "damage": 16,
        "attackSpeed": 1.1,
        "range": 200,
        "projectile": "arrow",
        "element": "physical",
        "fireResistance": 0.5,
        "coldResistance": 0.5,
        "lightningResistance": 0.5,
        "armor": 1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/shooting_arrow.glb",
                      "width": 2,
                      "height": 0.2,
                      "depth": 1,
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/scout/scout.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 90
                }
              }
            }
          ]
        },
        "buyable": true,
        "specUnits": [
          "2_d_beastMaster",
          "2_d_ranger",
          "2_d_trapper"
        ],
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [],
        "icon": "unit_archer",
        "visionRange": 650,
        "supplyCost": 2
      },
      "2_d_beastMaster": {
        "title": "Beast Master (2) [D]",
        "size": 25,
        "height": 50,
        "value": 35,
        "hp": 140,
        "speed": 55,
        "damage": 16,
        "attackSpeed": 1.1,
        "range": 200,
        "projectile": "arrow",
        "element": "physical",
        "fireResistance": 0.5,
        "coldResistance": 0.5,
        "lightningResistance": 0.5,
        "armor": 1,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/idle/idle.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_bow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/shooting_arrow.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "cast": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "models/2h_spell_summon/2h_spell_summon.glb",
                      "scale": {
                        "z": 1,
                        "y": 1,
                        "x": 1
                      },
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/beastmaster/beastmaster.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "scale": {
                    "z": 1,
                    "y": 1,
                    "x": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "offHand",
              "item": "woodBow",
              "attachmentData": {
                "bone": "",
                "offset": {
                  "x": 0,
                  "y": 0,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 90
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "SummonWolfAbility"
        ]
      },
      "2_i_necromancer": {
        "title": "Necromancer (2) [I]",
        "size": 25,
        "height": 50,
        "value": 250,
        "hp": 180,
        "speed": 35,
        "damage": 12,
        "attackSpeed": 1,
        "element": "poison",
        "armor": 3,
        "fireResistance": 0.1,
        "coldResistance": 0.3,
        "lightningResistance": 0.2,
        "range": 100,
        "projectile": "fireball",
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "type": "gltf",
                      "url": "animations/2h_spell_summon.glb",
                      "x": 0,
                      "y": 0,
                      "z": 0,
                      "rotationX": 0,
                      "rotationY": 0,
                      "rotationZ": 0,
                      "color": "#FFFFFF",
                      "metalness": "0",
                      "roughness": "1",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/necromancer/necromancer.glb",
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 20,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "woodStaff",
              "attachmentData": {
                "bone": "",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": 5
                },
                "rotation": {
                  "x": 0,
                  "y": 160,
                  "z": 0
                }
              }
            }
          ]
        },
        "abilities": [
          "RaiseDeadAbility"
        ],
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "2_s_berserker": {
        "title": "Berserker (2) [S]",
        "size": 25,
        "height": 50,
        "value": 160,
        "hp": 180,
        "speed": 55,
        "damage": 24,
        "attackSpeed": 1.5,
        "element": "physical",
        "armor": 3,
        "fireResistance": 0.1,
        "coldResistance": 0.2,
        "lightningResistance": 0.05,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_steady_right_hand.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/1h_axe_swing.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/berserker/berserker.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1",
                  "position": {
                    "y": 0,
                    "z": 0
                  },
                  "rotation": {
                    "x": 0,
                    "y": 0,
                    "z": 0
                  },
                  "scale": {
                    "x": 1,
                    "y": 1,
                    "z": 1
                  }
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "axe1h",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 5,
                  "z": 5
                },
                "rotation": {
                  "x": 15,
                  "y": 0,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "axe1h",
              "attachmentData": {
                "bone": "",
                "offset": {
                  "x": 0,
                  "y": 5,
                  "z": 5
                },
                "rotation": {
                  "x": 180,
                  "y": 0,
                  "z": 180
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": []
      },
      "2_is_oathBreaker": {
        "title": "Oathbreaker (2) [IS]",
        "size": 25,
        "height": 50,
        "value": 110,
        "hp": 200,
        "speed": 35,
        "damage": 14,
        "attackSpeed": 1,
        "element": "poison",
        "armor": 6,
        "fireResistance": 0.2,
        "coldResistance": 0.2,
        "lightningResistance": 0.2,
        "render": {
          "animations": {
            "idle": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/idle.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "walk": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/walk_with_shield.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "attack": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/sword_slash.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "death": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/death_fallback.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ],
            "celebrate": [
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_gangnamstyle.glb",
                      "id": 0
                    }
                  ]
                }
              },
              {
                "main": {
                  "shapes": [
                    {
                      "url": "animations/dance_thriller.glb",
                      "id": 0
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              },
              "shapes": [
                {
                  "type": "gltf",
                  "url": "models/oathbreaker/oathbreaker.glb",
                  "width": 2,
                  "height": 0.2,
                  "depth": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "color": "#FFFFFF",
                  "metalness": "0",
                  "roughness": "1"
                }
              ]
            }
          },
          "equipment": [
            {
              "slot": "mainHand",
              "item": "knightSword",
              "attachmentData": {
                "bone": "RightHand",
                "offset": {
                  "x": 0,
                  "y": 15,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 8,
                  "z": 0
                }
              }
            },
            {
              "slot": "offHand",
              "item": "knightShield",
              "attachmentData": {
                "bone": "LeftHand",
                "offset": {
                  "x": 0,
                  "y": 10,
                  "z": -10
                },
                "rotation": {
                  "x": 15,
                  "y": 0,
                  "z": 0
                }
              }
            }
          ]
        },
        "buyable": false,
        "squadWidth": 1,
        "squadHeight": 1,
        "placementGridWidth": 1,
        "placementGridHeight": 1,
        "abilities": [
          "CurseAbility"
        ]
      },
      "sentry": {
        "title": "Sentry Tower",
        "info": "Defensive sentry tower",
        "value": 250,
        "range": 4,
        "damage": 10,
        "attackSpeed": 0.5,
        "projectile": "arrow",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "cylinder",
                  "size": 20,
                  "height": 4,
                  "color": "#78909c",
                  "x": 0,
                  "y": 2,
                  "z": 0,
                  "name": "base",
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "scaleX": 1,
                  "scaleY": 1,
                  "scaleZ": 1
                },
                {
                  "type": "cylinder",
                  "size": 14,
                  "height": 26,
                  "color": "#78909c",
                  "x": 0,
                  "y": 17,
                  "z": 0,
                  "name": "body"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            },
            "rampart": {
              "shapes": [
                {
                  "type": "cylinder",
                  "size": 12,
                  "height": 8,
                  "color": "#3e4f57",
                  "x": 0,
                  "y": 30,
                  "z": 0,
                  "name": "rampartbase"
                },
                {
                  "type": "box",
                  "width": 3,
                  "height": 5,
                  "depth": 3,
                  "color": "#3e4f57",
                  "x": 4,
                  "y": 34,
                  "z": 4,
                  "name": "rampartblock1"
                },
                {
                  "type": "box",
                  "width": 3,
                  "height": 5,
                  "depth": 3,
                  "color": "#3e4f57",
                  "x": -4,
                  "y": 34,
                  "z": 4,
                  "name": "rampartblock2"
                },
                {
                  "type": "box",
                  "width": 3,
                  "height": 5,
                  "depth": 3,
                  "color": "#3e4f57",
                  "x": 4,
                  "y": 34,
                  "z": -4,
                  "name": "rampartblock3"
                },
                {
                  "type": "box",
                  "width": 3,
                  "height": 5,
                  "depth": 3,
                  "color": "#3e4f57",
                  "x": -4,
                  "y": 34,
                  "z": -4,
                  "name": "rampartblock4"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1.5,
                "y": 1,
                "z": 1.5
              }
            },
            "attacker": {
              "shapes": [],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        }
      }
    },
    "visuals": {
      "meteor_warning": {
        "title": "Meteor Warning",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "main": {
              "position": {
                "x": 0,
                "y": 0.1
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "shapes": [
                {
                  "type": "sphere",
                  "x": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "size": 20,
                  "scale": {
                    "y": 0.1
                  },
                  "position": {
                    "y": 10
                  },
                  "color": {
                    "paletteColor": "redDColor"
                  }
                }
              ]
            }
          }
        }
      }
    },
    "worldObjects": {
      "rock": {
        "title": "Rock",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "tetrahedron",
                  "size": 16,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": 3.5,
                  "y": 2,
                  "z": 2.5,
                  "rotationX": 50,
                  "rotationY": 140,
                  "rotationZ": 10,
                  "scaleX": 1
                },
                {
                  "type": "tetrahedron",
                  "size": 12,
                  "color": {
                    "paletteColor": "greyDColor"
                  },
                  "x": 10.5,
                  "y": 2,
                  "z": 7.5,
                  "rotationX": 50,
                  "rotationY": 150,
                  "rotationZ": 10
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        }
      },
      "tree": {
        "title": "Tree",
        "render": {
          "animations": {
            "idle": [
              {}
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "metalness": 0,
                  "roughness": 1,
                  "url": "models/new_fir/new_fir.glb"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "scale": {
                "x": 1,
                "y": 1,
                "z": 1
              }
            }
          }
        },
        "height": 75,
        "size": 25,
        "placementGridWidth": 1,
        "placementGridHeight": 1
      },
      "goldVein": {
        "title": "Gold Vein",
        "render": {
          "animations": {
            "idle": [
              {
                "shapes": {
                  "shapes": [
                    {
                      "color": {
                        "paletteColor": "greenDColor"
                      },
                      "id": 1
                    },
                    {
                      "color": {
                        "paletteColor": "greenDColor"
                      },
                      "id": 2
                    },
                    {
                      "color": {
                        "paletteColor": "greenDColor"
                      },
                      "id": 3
                    }
                  ]
                }
              }
            ]
          },
          "model": {
            "shapes": {
              "shapes": [
                {
                  "type": "gltf",
                  "size": 2,
                  "color": "#ff0000",
                  "metalness": 0,
                  "roughness": 1,
                  "x": 0,
                  "y": 0,
                  "z": 0,
                  "rotationX": 0,
                  "rotationY": 0,
                  "rotationZ": 0,
                  "url": "models/goldvein/goldvein.glb"
                }
              ],
              "position": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        },
        "placementGridWidth": 2,
        "placementGridHeight": 2,
        "snapToGrid": true,
        "height": 100
      }
    },
    "icons": {
      "building_fletchersHall": {
        "title": "Building Fletchers Hall",
        "filePath": "resources/images/icons/building_fletchersHall.png"
      },
      "building_barracks": {
        "title": "Building Barracks",
        "filePath": "resources/images/icons/building_barracks.png"
      },
      "order_hold": {
        "title": "Order Hold",
        "filePath": "resources/images/icons/order_hold.png"
      },
      "building_mageTower": {
        "title": "Building Mage Tower",
        "filePath": "resources/images/icons/building_mageTower.png"
      },
      "unit_apprentice": {
        "title": "Unit Apprentice",
        "filePath": "resources/images/icons/unit_apprentice.png"
      },
      "unit_acolyte": {
        "title": "Unit Acolyte",
        "filePath": "resources/images/icons/unit_acolyte.png"
      },
      "unit_archer": {
        "title": "Unit Archer",
        "filePath": "resources/images/icons/unit_archer.png"
      },
      "unit_rogue": {
        "title": "Unit Rogue",
        "filePath": "resources/images/icons/unit_rogue.png"
      },
      "unit_soldier": {
        "title": "Unit Soldier",
        "filePath": "resources/images/icons/unit_soldier.png"
      },
      "building_goldMine": {
        "title": "Building Gold Mine",
        "filePath": "resources/images/icons/building_goldMine.png"
      },
      "order_move": {
        "title": "Order Move",
        "filePath": "resources/images/icons/order_move.png"
      },
      "unit_peasant": {
        "title": "Unit Peasant",
        "filePath": "resources/images/icons/unit_peasant.png"
      },
      "unit_stoneGolem": {
        "title": "Unit Stone Golem",
        "filePath": "resources/images/icons/unit_stoneGolem.png"
      },
      "building_cottage": {
        "title": "Building Cottage",
        "filePath": "resources/images/icons/building_cottage.png"
      },
      "unit_barbarian": {
        "title": "Unit Barbarian",
        "filePath": "resources/images/icons/unit_barbarian.png"
      },
      "building_townHall": {
        "title": "Building Town Hall",
        "filePath": "resources/images/icons/building_townHall.png"
      }
    },
    "materials": {
      "greenL": {
        "title": "Green Light",
        "color": "#a3d39c"
      }
    },
    "palettes": {
      "main": {
        "title": "Main",
        "greenLColor": "#a3d39c",
        "greenMColor": "#5a8a4f",
        "greenDColor": "#2f4a29",
        "brownLColor": "#d9b38c",
        "brownMColor": "#8b5e3c",
        "brownDColor": "#4a2f1f",
        "blueLColor": "#b3e5fc",
        "blueMColor": "#4fc3f7",
        "blueDColor": "#0288d1",
        "redLColor": "#ffcc80",
        "redMColor": "#ff8c00",
        "redDColor": "#bf360c",
        "purpleLColor": "#e1bee7",
        "purpleMColor": "#ab47bc",
        "purpleDColor": "#6a1b9a",
        "greyLColor": "#cfd8dc",
        "greyMColor": "#78909c",
        "greyDColor": "#3e4f57"
      }
    },
    "shaders": {
      "grass": {
        "title": "Grass",
        "fragmentScript": "varying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform vec3 directionalLightColor; // DirectionalLight color\nuniform float directionalLightIntensity; // DirectionalLight intensity\nuniform vec3 directionalLightDirection; // DirectionalLight direction (world space)\nuniform vec3 ambientLightColor; // AmbientLight color\nuniform float ambientLightIntensity; // AmbientLight intensity\nuniform vec3 skyColor; // HemisphereLight sky color\nuniform vec3 groundColor; // HemisphereLight ground color\nuniform float hemisphereIntensity; // HemisphereLight intensity\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    vec4 texColor = texture2D(map, vUv);\n    vec3 color = texColor.rgb;\n\n    // Directional light (Lambertian diffuse)\n    vec3 lightDir = normalize(directionalLightDirection); // Ensure direction is normalized\n    float diff = max(dot(vNormal, lightDir), 0.0);\n    vec3 diffuse = directionalLightColor * directionalLightIntensity * diff * color;\n\n    // Ambient light\n    vec3 ambient = ambientLightColor * ambientLightIntensity * color;\n\n    // Hemisphere light\n    vec3 hemiDir = vec3(0.0, 1.0, 0.0); // Up direction for hemisphere\n    float hemiDot = dot(vNormal, hemiDir) * 0.5 + 0.5; // Remap to 0-1\n    vec3 hemi = mix(groundColor, skyColor, hemiDot) * hemisphereIntensity * color;\n\n    // Combine lighting contributions\n    vec3 litColor = diffuse + ambient + hemi;\n\n    // Apply fog\n    float fogDistance = length(vWorldPosition - cameraPosition);\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    vec3 finalColor = mix(fogColor, litColor, fogFactor);\n\n    gl_FragColor = vec4(finalColor, texColor.a);\n}",
        "vertexScript": "varying vec2 vUv;\nuniform float time;\nuniform float windSpeed;\nuniform float windStrength;\nuniform vec2 windDirection;\nattribute float instancePhase;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal; // Add for lighting\n\nvoid main() {\n    vUv = uv;\n    vec2 dir = normalize(windDirection);\n    float wave = sin(time * windSpeed + instancePhase) * windStrength;\n    wave *= uv.y;\n\n    vec3 displacement = vec3(\n        dir.x * wave,\n        0.0,\n        dir.y * wave\n    );\n\n    // Compute world position in world space\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position + displacement, 1.0);\n    vWorldPosition = worldPosition.xyz; // Store correct world position\n  \n    vec3 normal = normalize(normal); // Assuming grass geometry has normals\n    vNormal = normalize((modelMatrix * instanceMatrix * vec4(normal, 0.0)).xyz);\n\n    // Compute view position for gl_Position\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}",
        "uniforms": "{ \"time\": { \"value\": 0 }, \"windSpeed\": { \"value\": 0.8 }, \"windStrength\": { \"value\": 2 }, \"windDirection\": { \"value\": [0.8, 0.6]} }",
        "vectors": "[\"windDirection\"]"
      },
      "water": {
        "title": "Water",
        "fragmentScript": "uniform float time;\nuniform float waveHeight;\nuniform vec3 liquidColor;\nuniform vec3 foamColor;\nuniform float waveFrequency;\nuniform float fresnelPower;\nuniform vec3 lightDirection;\nuniform float ambientIntensity;\nuniform float specularIntensity;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\nuniform vec3 fogColor;\nuniform float fogDensity;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n    vec3 lightDir = normalize(lightDirection);\n\n    // Fresnel effect for edge transparency\n    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);\n\n    // Diffuse lighting\n    float diffuse = max(dot(normal, lightDir), 0.0) * 0.25;\n\n    // Specular (Blinn-Phong)\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0) * specularIntensity;\n\n    // Base color with subtle wave height modulation\n    vec3 baseColor = liquidColor * (0.8 + 0.2 * vNormalizedWaveHeight); // Slight tint variation\n\n    // Foam effect based on normalized wave height\n    float foamFactor = smoothstep(0.8, 1.0, vNormalizedWaveHeight); // Tighter range for foam at peaks\n    vec3 color = mix(baseColor, foamColor, foamFactor);\n  \n    float fogDistance = length(vWorldPosition - cameraPosition); // Distance from fragment to camera\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695); // 1.442695 = ln(2)\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    // Combine lighting components\n    vec3 lightColor = color * (ambientIntensity + diffuse) + vec3(specular);\n\t\tvec3 finalColor = mix(fogColor, lightColor, fogFactor);\n    // Apply fresnel for transparency at edges\n    float alpha = mix(0.6, 1.0, fresnel);\n\n    gl_FragColor = vec4(finalColor, alpha);\n}",
        "vertexScript": " uniform float time;\nuniform float waveHeight;\nuniform float waveFrequency;\nuniform float waveSpeed;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\n// Simple noise function for wave variation\nfloat snoise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vUv = uv;\n\n    // Combine multiple waves for more natural movement\n    float wave1 = sin(uv.x * waveFrequency + time * waveSpeed) * waveHeight;\n    float wave2 = sin(uv.y * waveFrequency * 0.7 + time * waveSpeed * 0.8) * waveHeight * 0.5;\n    float wave3 = cos((uv.x + uv.y) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * waveHeight * 0.3;\n    float displacementY = (wave1 + wave2 + wave3) * 0.5;\n\n    // Store wave height for fragment shader\n    vWaveHeight = displacementY;\n\n    // Normalize wave height based on maximum possible displacement\n    float maxWaveHeight = waveHeight * (1.0 + 0.5 + 0.3) * 0.5; // Sum of wave amplitudes\n    vNormalizedWaveHeight = displacementY / maxWaveHeight;\n\n    // Update position with displacement\n    vec3 newPosition = vec3(position.x, position.y + displacementY, position.z);\n\n    // Compute normal for lighting\n    float offset = 0.01;\n    float waveX = (sin((uv.x + offset) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    float waveZ = (sin((uv.x) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    vec3 tangent = normalize(vec3(1.0, (waveX - displacementY) / offset, 0.0));\n    vec3 bitangent = normalize(vec3(0.0, (waveZ - displacementY) / offset, 1.0));\n    vNormal = normalize(cross(tangent, bitangent));\n\n    // Pass view position for fresnel and lighting\n    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);\n    vViewPosition = (cameraPosition - worldPosition.xyz);\n    vWorldPosition = worldPosition.xyz;\n    // Apply projection and model-view transforms\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}",
        "uniforms": "{\"time\":{\"value\":0},\"waveHeight\":{\"value\":3},\"waveFrequency\":{\"value\":5},\"waveSpeed\":{\"value\":0.25},\"liquidColor\":{\"value\":\"\"},\"foamColor\":{\"value\":\"\"},\"fresnelPower\":{\"value\":0},\"lightDirection\":{\"value\":[0.5,0.5,0.5]},\"ambientIntensity\":{\"value\":1},\"specularIntensity\":{\"value\":1}}",
        "vectors": "[\"foamColor\",\"liquidColor\",\"lightDirection\"]"
      }
    },
    "textures": {
      "background": {
        "title": "background",
        "image": ""
      },
      "forest": {
        "title": "Forest",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwOEX1QMH0QuRwQqWXk7NdvLTHSwY3uy3Huz5boua9aEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAs/vWAZcNxDRQAAAABJRU5ErkJggg=="
      },
      "grass": {
        "title": "Grass",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAwCAYAAADuFn/PAAAAAXNSR0IArs4c6QAAFepJREFUeF7dnGusZFlZht+1b3Wvc++Znu6BQTQS/amJ/HAQQXBgMIDGGCBRE6KSiJFI1DhgCNEIxgAaY8IfiJJ4wRguigwzDsMEBjSK/BBNCAkRZprp6du51L323msv83yrqi+nh992zZ7L6TqnTtWqb63v/d7v/d7d7qd//t5QLoLmk0a97UShkTr9TE5SuWxUV0FSULefaTatJZeoWnjlLaduL36v00s1n3p7zMX3sjRRmjr5RioXtZKMV4xXCJKv4x+ck5pG9nrxh/FLXQdbQ6udaLlo5HiinJ74zNM3Xuj6K27uH9wrXn8+eB80Own22Yd7iQWUB4t5UGBHVleXQM9qheDUKlItyxh025ibrvX3ynlQ3nZqd1IdXy7t9QfbucqyseAmCf+TvUZVelW22VLKZgVnP+e5TR3U1E51JXWG0uOfuvC82QT3steeCw0bMJbOvqjQfBXMyXGj2SSo3WFT0uvhJRDjY6+8kHbO5FrOPQfztmsxjac2K5yd8hCCOt1MJ4eV+mzCzKvdTVXXjeRi4MkMruVEcllQ8EH97UyLqVdVBrX77Fi8ni+b4F7+M+dtA7pbmQVlHUw2YD7x2jnIlGScSslXUlYkKheNneTJVadi4FW0k+sbx2m+eqnUYJhpMfHKWs6Cn+bxVPf6mcZHlVzuVJeNgpdanVSVb+QXwaCq1ZYWi2CwRPZMTryy4kamsAGjQ69//fwzG58J7sE332cbMD6utXc2s9Pd7iZazBr7L01cxOjCCajq9lMtZl6Nl53OumrUaqcGQwT/6HJpmxmqIL+CmaaSfBNUtFf7S2Zkqe31+KRWkjgtF14uccpzykwiX8f3yH7olxS++TGDMtvcZ0t7PzbKKRhcbsL6v/S57z7nYXGvfOP5wEdpQtD0uNHBuVzTiVenk2o69mrqRlkr1dGVWtt7qcEJV9ME2xhKhJ3wLMIN0LOcN+oOUgVqtkuVFo0Gu5kSJyvWrSKzjIpFXRofSr1Boqpu1OokBmu8Lq9fVkH9Ad9rtLWX6dLTpTr9xOApzRLltqmbsf4vP3r7Jrgff9W5UPScDi959YdO2/uFDi+XekO/1CNqaXYiFUVibAg46W+ncmmwYuyXTp1uqsmoNsYzOvbKcqeilSjLpXoJbueajSv5Urrn+1oKauy9gP29s4Vmk8qYDgU/cYk9t7uVa3ZS2aHIgLexV6vrFKpESqgLqRZzrySVFqOgTVr/Fx+5lcW5173lvnB4pTb8h/i1u7IAUg/5gONDgpqoaElp4bR3d6Yr362NJXHySX8wnN/hdBdtp7yV6alvLnTX+Uw1BKmRat9YXchbqXoDWUZ1erltANd8FCzgiWODvTqDXHkRNB55BR+zqjNItXNANgJusSZwbdL6T5MH2wCKHGlfL4J27ykUGvoCr/lEVoB3zqTGRMBqgrRmpmRERbFsU1CDev1UtScDoIyNbU6eZ9YHQGZhUHkr0f7ZROXMaTKpdPVCozP3JkZB+1u5xkeNpqNSSZKot01BpgjTR8SAs+nA1s19xyat/zN//e1baoFtAFjsy0RJGmKD5GJj1m47be1nVgvAeIpk03jrA9YnkN/Nc6feMNHhpVrLRdDBPbkxnvFRrazILJMS1xizCXVQu5cohFRbe4kOr5Tqd3Mty1p5kWo6qVUvpEXpNdxJ7X3ZZCWNiiLTgmJ900dY9xysP82D6pLMbDSbNup2kjtu/Q9//Du3bsAr3nA+5Hmik2ve6B8ws72f6uoztdqdzPj4ctZYVgAfaRqMk+/fk+nqxch8ukPFP/c5wVUsyKCDc8aiwCsY1HQUlMipNZCqudTuueu0l2fZ7x+zAY3qJmjrTKbgnSYnwFTQR151pF99Yu96u9zpZUZ/W63EIK3VdrFObaU6ulyr3c2sXt1J6//+d8xu3YAH33RfGB3X6nQj+7gZZuDuvl51Ryt5AIq6lg/iSeTnznqBaknzJXnv1O1majz1I1VZer2mN9QXv31VF0Kq/k6iVgGtzDWbxhrQbmd65sJS3U6mNJGWyzrC0k4qehKYT7WkAUzkVn1hbwAFdUZlyUL6ilvWD3Vedde8B/LG//f6n3zk1t7F3f/AubC1l2sKk7kJZppm3cFKNZKEA+uhocEK7vGL3in31T+2k561EmNDZElVNWq3cutqgav1RQYoZKoWUqvPvnkVeaqqptYEJXnUh7a36fqcsaxWK2ZiZ0s6ueK1dRA7YbJuufR2OICn51p/aGJ2sY47af23FeFXvvFcgOUQBIILzCRJhBlO3XzcxMLrnTVjrR4g4jQbeXmUNhfUG6LlNKYPJVmi2aRWUwYT0cgMXocL1jMZxYLf6jhVy5UE4aGSvK4lk10EjoLLVyjubNIY1BD4tfhHp8yaWf9iZr9wAyaXQZ1Botnozlr/Y5966lYIQoqAuxNAPmwJd+84jQ6Dtg8S02umR41SkxQaTU9o1iJTohlDMe3TdFk753T54lJpklrRRWkrutBZMMNbbJuVEkpydKkBkqolzZpXu5VpPq9WwZcV0HImTawwNwZ2MKvtfeirsQX79/r6obs1tDixdfa377z1P/nIrc2Y+4kHz4V1MUsB3xWqc+rrZaOig/wMuwhWoHkKhe7as157d0cwhq1cuVCpO0hULgm4UwJTShI5RLheojk6T9Ko9kEZek8rNTxfzrw6fbruyhgUdaecNVagwfP5nI43yJdkpdTqcRBkkDcbw8h4/ViMeT4CIG9tcLgMKsi0O2j9X/6XUxsAC1qntK8oonSljTi0v/8bD+l9H36f1QZOLN9HIiZwFFweDLZlgaHr5fv8R1Ysp5zM2MxlbXIhtZM6GcOcbhRgoKjx8fdGx6U63VwvHZ/o8bSjXp9aEnR0tY4U2dODIOjFGQEbgfxxev38jHXeiet/8uFTRfgnX38+wFxodGhoQGKwnqYI+seJbHUyLee1ZieNuluJQp1oNq+0vZebMMcJrav4e3xwmMlbHvxFffrJv1U5r9Xu5RqflDZzaPWd2jbMya0R4/nkXdHNjbGA6eDKdFpp9yAz6kpA6TeoAeg/ZE1VB23twrDiUGdT1v+Ff7p1lnG9EUugnAsUy9ROmm8a9XqRSqLTrIsjDITOlEEJbIhhiTVoAXYUq2iWJfrtt75Lf/ax9xvt8146uVZaFiFbMMihyfvQe/5Kv/v+t1qGTUaV2u1Ui2Uc7pj0kA+Udhaaz5E+aALDSgrPNDmutXNXbPjYnE1Z/xOnN+C1b3phQNgynrykjEoupfGSjq94/eCPtDU5aSyIFGoqIewD1ROe/t6XjvUH/z4wOEKzBzbAc5Orh8wbU5OiwemTw9IYTZqlWi5qMTEDRugLqDHw+8zGmPH9q0WirN1YzWAaxvsNtjLj/UgdbC7zgk1a/xf/+VQGvOrnXhAorqQ1Em+SJppNvVyTqCEQqJYrAW64nxrW0/B0hyikskD42inNZUIcs2MK4louiPpN1IrIHCgjG8UAtMihiV7tfibPDhsBCMbzkSR6W6lCBRzVYm5Nc4dkDWyhVSFpAEmbtP5HP3FKivipnz0fOIlgauKccXZ0eD+XlpVXd5gaHPCh1zzdRLZ2YoE6fLa2Zmqwk14PPpIGbIjNkPNaziKvhxq2isi0OM15h4451YzNb4JtjPULXTrk0qSQqxcr7d5VmEyNzjPYox41xnTopn3dWCZtyvpvY0EMZAg4ciWFjLktKW4nrsfMNna0PEaH96UzfQgWRPtfLpAeGJxL/d0bM9t1MSWgiHNXnqmMwYS6ka+Quxk/Sr/3tnfrfR/+Qyv2dLbUICZdBJTXWIwZh8YaxIZNDpvYsSvOiB1Ff4PW//gnT0HQK15/LljHO41dKUGlCzbJd4QgllvBA1KidSRYd9nposEgAySG0cslSmqc464vpOVOLzZoFGoG8IsJcBWbpE4n0zsHqT5wsdQsiRaU2bi2ZssyhvdnCpfK9KC8RTedaTaqtHN3YTNn1rNJ6//Ko6doKEW4v+109WKUB4x99DKNDisL6HIu03tcLnW7iW0QtBDM50oTRokrSWE1noSOouHs7OfR5uOoLYijQSdXg1pt6kJtcwOTHGhoaZ58HHVSJ5g9U4uAscUMZRNLjFeeRWsMp571UoQ3af1f+PSpDLj/1edDZ+hMjsZqglQAu6Bo0gss5rUmx94G8AQQGGFj6DiBnisv+R090Puq/uvrT1gRf+evvEMf+OifWs9gDZwa5RkKqrPX2b0rs9+nSWMCNzryOjhb6OhKaboRjgs0HCCPbALaTP0081Zi2YhxjP6j3UkM/zdp/Y/+wykt6P4Hzpsjiw9LQNMcR0JjBRl8Ve00L320lAyREBjQ1BZEAkzGcOLpSDnGzI/JjulJHOgXNHHYXQALdJtUxnqgmcgSTdUYNAFTSBy8bn8Y0+vkGrOFOFfg+fQd5cJrMQ3q7URZHHV1k9b/2CdPbUCcCZfm+cFoNTqq7IMyv+UTWrp7eD/yrzTYZYOQI6IsDGT8lo70J822qZyG0SaURdaETMGGAkUEFjgxvYb5bxYhhPFifxgddlgagRZmCjH7GjsIvSFpECnqzU48Y2IbtP7nnAnzgZolKltj7KbVTaSQCD/PYlErz5yKbvSN2uk+CkrTVO1hUG9AwCujjK2OdHwt4vXoKDolOu1UJ8fVdUixeTE1IyhS3JlX0WKWfMMCySYig8QN8wZdvS3qQgz+DU9q9LBu0vpvmwkjxq29mZx4xnfgcKuLpCxtn8k0Poz+HYY03U6qKxcrDXcTkx+ADgI1NXdDdDUAKcgZBI6BPlo+NQVstx6gjIWWggN8mRglBvjRG4QmhI0FecF6c9fYyHP/bPY9vah4Szdh/bdlABtgQZnFLjgpZDQTaRlYAAYQzoAiijCQgo4Dth8+W1pW4PWsytpgxvQjbCbT2uRi6C2Qde8PFLr63Upn7i3sxIba2byWue3/vPiDevHXf/O6RxSpmblEhSvaxpONSRS9rcwcdM91bcr6H/67U50wNeDZp5faOcgNagjiyREMA1roTHuZmSM6uuAYfAMZ5RItHtEs6jO4FWyCZdMs/EIUzqDhdq4ZtpSbZsvTEdOt1GoDhqtogaTRilMx2A6SNu8zulapqqWDszCy293YZO8mrf+2DFjPhCm+fHqaI4YYFEbGkUjAW/vRwQZS3GoJyTUelZH9ZIltApo/np5rl0rtnc3t9P/C3cf6y2/1I1NazXQvfntpj6G8MB2aL1gQQSdz8Bpd+k6l3f1ClY8uvP1zkR1R+NejSpgSM+FNWf9tNYCRpE2XJrXJAQS4aGU6/OE/0l3feJc9ns3rqJLieFjVSmNCDNVxKrSd0U4mY/QRrTzVosRpkenC6AVaPv0NHTzwkIpvfsAasukosp7DK3EewDBG3pmmhLxggp9Heo7vGWluzMD1HBkx0DbDr6ZjG7L+Lz18aiL2stecD4PtTM3K7sZYDx/oM/pR3V3/hwbb8fTDXN79Y8f60NcPNF9iZaQ7DuoUmZ16jFVI0RRmhjdI0DY6HDhd/o5Xkq+G92C4cza2XN8Og77EfQPDvcy67emUvgOlNWhevEA7+YXoimMeUFaqlk7AGIyKYr5J6//s6RrwstecC6Q+NBIpoG68cXG7cQK/z2oixiYQXIxWZAHBQGYGPrIkStjtbrSyR9mU4X4m31Q6uhyVTvg/tNWyilubME5hBKiwpvjYeU9jbcGmYj83nxFTsRX+r3qMyRE2dtzUsYHblPXfDkGvuzcQTD4khXA6dto9Q7da6NfqQ/3bvNDXirbNiuHq+PoJGM81Vwr3ceWplnW0lF83bSXxjpjjy7WUwjijbMxsgW7XHBiLYHT36BJ3zaTWY5TzOPRB4+f3OQg2CLJ7DVBLsbnTpHmbJaCebtL6H/vEKQi6/9XnIO+mtyAEO5gQ94fZwIMUd1aYcbfh66cApkViLgWCv6zqeEMdfUIFg4Eq1kqLoJLblBI2joxBcogdNNx+OeN1pP17gDiaNmwuTg2wM8UdgXUx2kpoxkypNSmCU58aRWU+gNyxSet/5OOnpIh1H8CIsdN3yhwz2zgSRCrAMW0+nFUhno9wIsSKnGVBk7G0tctWcFckJihpaYF3RiWzxClZuaWNufAYw21FB7yaHwA5aESdVJef8rZ5bLR1v9zAV8Us6A9TjQ5rO/Wja7V27o7DGa5NWf8/fuxUH/Dgm18YwOZ2T7r4VKXhVh6bnZWtDzgg5aGJqGnoPVDFziCyoGuXS5OIsRuyDXg8TczLEdNqM0nR3RLI+ZQOOQ5v+AqTMjYTlQnLIoprVTr1B9F/xAVUUXBtqN+OdsbrckQXu+TmrP+Jz5weyLzhfBjuMuuN7gKCiuOBs7l9kOrkKq7pXEeXF+rvtpS4WCyno+hggxZi4KJZYiz5ywcDfeSZkWXCWpHD+IuWvxg3WixltzqZvWQBvXUGRVBhTvf+OepGhBybDRRO42ukI6Je0NZ+GkXAEK5D0yat/z+fvHi7PX3dHLEB1TzaTNgACmGxuh8YLr6cBG2fibIEOhHuBm6mW0zwBUmdLfqBxqADCsk/T3+j0r0vyW2jmHiRFdhWgDv2iBPNhv/Fez6st7/3bWp8o94wj3ddughLNGYTPJ6Yd89wH3Mc/N98rTPiTl//175yaiJGDaDQcQEd3CWJFM1Xs5yXjB9TkxLwh37woT/Xrz/0drUHTuUkqOhj1G3MgogVPW0xzgy69FSkpZ1hYjoOp5uiqgYbfK1lKZ17EYFmvuzVanY116G2d3PN59wxuZqSBawumW06zR4KqhXkYjU6BfY2ZP2fPzUP5nM4RpIMWrgdiRN5fLWyYXzAXLsy3AIFa72e0w42u5BYFviksQAt7MRyp6VT0Yt3tkMVt3dSTad4eJz1Ge1eqsG20//+d6n20EWfUBr1IHQhLjphGrX5rNHbt2f6qO9HDxG9BbI4e7xKZDJkE9Z/ehS5zl734FvuC6Qz0IHvh0ZouF2Y8smpU0gNknA3W3DmDEu4cToztmLzgHFlVBB3M6OXI1RSszhGoy4q5lq3b3dhvdhOahv6A3OAETYXlwS12wSYTre23gRZ5MK3SruvrI8wOPF2SyuTu8/+za2M4hZM2pAH7uWvOx+wh8xp7fHprKyHw/2Iw3anSyOTGkoG9Dif6cISr26XoXtsquiE9+7iPoNVMWd4TlGHydxSduIkDbvhgjkBg6A0ft06uBE1yEB3AJNqbEA/Pq6sT7ArOH3pc8+Pv7TDIIjbPMFw4+VJLHzc+4v0bPIySiVBTyM80CeAu9zMbTaS1V/yAGPhJg0yp2SgYp6doN0zhZbcVwxlj97beJcLN+0F7jGIKur6Z2QZ9kizuecr58Wi0bMXKuukn/wed51vyKG/ZZmOIhx5dvzrZQgGqqjdD4BgRtxTJAIaguhkwFxFsA1esBGuGAnshDOKrdAvmGpSC5LVVCyyGgt86W3qhVuCb0JH7a+zMQ3IaX4S+xDeH3Gwy3waEPRej/z98+Pkr3fh/wAwjitsSv4ZrwAAAABJRU5ErkJggg=="
      },
      "start": {
        "title": "Start",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwGEb1QOL0QuQwQqWXk7NdvLTHSwY3uy33VZ0v0HOdeEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAvn4mAZ8YoyRAAAAABJRU5ErkJggg=="
      },
      "end": {
        "title": "End",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlklEQVRoQ+3UIQ6AMBBEUeo5D56T4zlPPQTblNTt7zYfTTIwL7PlOvZnS/Scdy2JPnf4qSUbwPdHKyGkBFgJIS3AKgipAYYHdqIX/s6mAIFIPQQBAgF6Z1MAAYIbgOPaM+QCgkEECC68jRNAALgBON4FCAA3AMe7AAHgBuB4FyAA3AAc7wIEgBuA412AAHADcLwLmAzgBfVWYBnOEmyVAAAAAElFTkSuQmCC"
      },
      "water": {
        "title": "Water",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlUlEQVRoQ+3UwQ2AIBBEUbEh27ME27MhNF4Jhtt+lnzPJqPzMlv26362RE89j5Loc4efWrIBfH+0EkJKgJUQ0gKsgpAaYHhgJ3rh72wKEIjUQxAgEKB3NgUQILgBOK49Qy4gGESA4MLbOAEEgBuA412AAHADcLwLEABuAI53AQLADcDxLkAAuAE43gUIADcAx7uAyQBeDUJgGasSxlsAAAAASUVORK5CYII="
      },
      "rock": {
        "title": "Rock",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA40lEQVRoQ+3VPQ6DMAwFYHItBqQOzIw9I2PnDpUYeq2iTkgoyAnBvzzmyHn4syEN0/PXOXqW15wcxSWjJm8A/zeKhOASIBKCW4AoCK4ByA+soQNHn00ACCLlELIA/WPsvp/35dG46l4elLHgHgEbwNjsXOkmAExwu1YTQPv1qAAA5RkAAACUO6B8vdgG4IedlxYDUB40s9e7A4i2SSYAojW1Zt2KAe7cpJqG1p4tBqgtbPU81yCdrcsGcDaQVTiuXGwAXIGj1VUBwHZsY0QCWGhWaYbSc5JbRGUiASTD3vGuPcAKi06NGSIOm+IAAAAASUVORK5CYII="
      },
      "lava": {
        "title": "Lava",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAkUlEQVRoQ+3UQQ6AIAxEUXpnj8GdMW4Jhl0/Jd+1yei8TGP0NlqhJ54WhT53+6lRDeD7o5sQSgLchFAW4BaE0gDbA3vQC39nU4BEpBWCAIkAq7MpgADJDcBx8xlyAckgAiQXPscJIADcABzvAgSAG4DjXYAAcANwvAsQAG4AjncBAsANwPEuQAC4ATjeBRwG8AKHQEgZvHpI7AAAAABJRU5ErkJggg=="
      },
      "scales": {
        "title": "Scales",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAQ0lEQVQYV2OM6vL/z4ADXD1wi4GRoAJ9L83/2g5qGGaAdIPEwSaAOOgApgnFCpguZMXEK4DpRjeFEeRIkJHIDkV2EwCeFirmzbH2AwAAAABJRU5ErkJggg=="
      },
      "path": {
        "title": "Path",
        "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA+0lEQVRoQ+2UsRWDMAxEcZ8FskAmyIAMmAmyAAukJwlFCj+MfcLikCJqSzrdP5HmxzgPhr50H5MhuVWpyRqA70aeIJgE4AlCM4DndBlu11f1pEoP9tav9fVwCc0AxM5H4eJAKSxqADQSb53lGgQ1ANbN0tKfQxABiHTL8UAAwmi50aVKCED/8dExAJAzQAPg7Xcm3UcFgFQMOYyU8SoAKJtkQ0shOFs4NgFIxEpqzgCMpcHtBbAMRecGANSxz3vkymtvYQC1hoJ9fiWavffo0qyFAWiK+cfeLgFYuiSXAJBLYsPqCoC9DGL8EW9b/OgK4IilvM0IAGSiOYA3/xycGR8hN+EAAAAASUVORK5CYII="
      }
    },
    "abilities": {
      "CurseAbility": {
        "script": "class CurseAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'curse',\r\n            name: 'Curse',\r\n            description: 'Curses enemies, reducing their damage and making them vulnerable',\r\n            cooldown: 7.0,\r\n            range: 180,\r\n            manaCost: 50,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 1.5,\r\n            autoTrigger: 'strong_enemies',\r\n            ...params\r\n        });\r\n        \r\n        this.curseRadius = 100;\r\n        this.damageReduction = 0.5; // Reduce enemy damage by 50%\r\n        this.vulnerabilityIncrease = 1.3; // 30% more damage taken\r\n        this.duration = 20.0;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    colorRange: { start: 0x2F4F4F, end: 0x000000 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            curse: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 2,\r\n                    color: 0x696969,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Dark magic weakens the enemy forces!`);\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applyCurses(casterEntity, enemies);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    applyCurses(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Sort enemies for consistent processing order\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        const cursedEnemies = [];\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            \r\n            if (!enemyPos || !enemyCombat || !enemyHealth || enemyHealth.current <= 0) return;\r\n            \r\n            // Check if enemy is in curse radius\r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.curseRadius) {\r\n                // Apply curse effect visually\r\n                this.createVisualEffect(enemyPos, 'curse');\r\n                \r\n                // DESYNC SAFE: Use buff system instead of directly modifying stats\r\n                const Components = this.game.componentManager.getComponents();\r\n                this.game.addComponent(enemyId, this.componentTypes.BUFF, \r\n                    Components.Buff('curse', { \r\n                        damageMultiplier: this.damageReduction,\r\n                        damageTakenMultiplier: this.vulnerabilityIncrease,\r\n                        isCursed: true\r\n                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));\r\n                \r\n                // Create dark aura effect\r\n                if (this.game.effectsSystem) {\r\n                    this.game.effectsSystem.createAuraEffect(\r\n                        enemyPos.x, enemyPos.y, enemyPos.z,\r\n                        'magic',\r\n                        this.duration * 1000\r\n                    );\r\n                }\r\n                \r\n                cursedEnemies.push({\r\n                    id: enemyId,\r\n                    originalDamage: enemyCombat.damage,\r\n                    position: enemyPos\r\n                });\r\n                \r\n                // DESYNC SAFE: Schedule curse removal using scheduling system\r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    this.removeCurse(enemyId);\r\n                }, this.duration, enemyId);\r\n            }\r\n        });\r\n        \r\n      \r\n    }\r\n    \r\n    // DESYNC SAFE: Remove curse effect\r\n    removeCurse(enemyId) {\r\n        // Check if enemy still exists and has the curse buff\r\n        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'curse') {\r\n                this.game.removeComponent(enemyId, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when curse expires\r\n                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (enemyPos) {\r\n                    this.createVisualEffect(enemyPos, 'curse', { \r\n                        count: 1, \r\n                        scaleMultiplier: 0.8,\r\n                        color: 0x808080 \r\n                    });\r\n                }\r\n                \r\n            \r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CurseAbility.js",
        "fileName": "CurseAbility"
      },
      "BlizzardAbility": {
        "script": "class BlizzardAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'blizzard',\r\n            name: 'Blizzard',\r\n            description: 'Summons a devastating blizzard that freezes all enemies',\r\n            cooldown: 5.0,\r\n            range: 300,\r\n            manaCost: 0,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 10,\r\n            castTime: 2.5,\r\n            autoTrigger: 'many_enemies',\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 3;\r\n        this.blizzardRadius = 150;\r\n        this.duration = 3.0;\r\n        this.tickInterval = 0.4;\r\n        this.element = 'cold';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88ccff,\r\n                    colorRange: { start: 0x88ccff, end: 0xffffff },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.5\r\n                }\r\n            },\r\n            blizzard: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xaaddff,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 3;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `An arctic blizzard engulfs the battlefield!`, true);\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createBlizzard(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createBlizzard(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Screen effect\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenFlash('#aaffff', 0.6);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule all blizzard ticks using the scheduling system\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {\r\n            const tickDelay = this.tickInterval * tickIndex;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.executeBlizzardTick(casterEntity, tickIndex);\r\n            }, tickDelay, casterEntity);\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Execute a single blizzard tick deterministically\r\n    executeBlizzardTick(casterEntity, tickIndex) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (!casterHealth || casterHealth.current <= 0) return;\r\n        \r\n        // DESYNC SAFE: Get all enemies deterministically\r\n        const allEnemies = this.getEnemiesInRange(casterEntity, 1000); // Very large range to cover battlefield\r\n        \r\n        if (allEnemies.length === 0) return;\r\n        \r\n        // Sort enemies deterministically for consistent processing order\r\n        const sortedEnemies = allEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            \r\n            // Only affect living enemies\r\n            if (enemyPos && enemyHealth && enemyHealth.current > 0) {\r\n                // Create localized blizzard effect at each enemy\r\n                this.createVisualEffect(enemyPos, 'blizzard', { count: 3 });\r\n                \r\n                // Apply cold damage\r\n                this.dealDamageWithEffects(casterEntity, enemyId, this.damage, this.element, {\r\n                    isBlizzard: true,\r\n                    tickIndex: tickIndex\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Additional visual flair for certain ticks\r\n        if (tickIndex === 0 || tickIndex % 3 === 0) {\r\n            // Create additional atmospheric effects on key ticks\r\n            const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n            if (casterPos) {\r\n                this.createVisualEffect(casterPos, 'blizzard', { \r\n                    count: 8, \r\n                    scaleMultiplier: 2.5,\r\n                    heightOffset: 20 \r\n                });\r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BlizzardAbility.js",
        "fileName": "BlizzardAbility"
      },
      "BloodlustAbility": {
        "script": "class BloodlustAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'bloodlust',\r\n            name: 'Bloodlust',\r\n            description: 'Heal when dealing damage and gain stacking damage bonuses',\r\n            cooldown: 5.0,\r\n            range: 0,\r\n            manaCost: 0,\r\n            targetType: 'self',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.lifeStealAmount = 0.3; // 30% life steal\r\n        this.damagePerKill = 5; // Damage bonus per kill\r\n        this.maxStacks = 10; // Maximum kill stacks\r\n        this.duration = 30.0; // 30 seconds duration\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: { \r\n                type: 'magic', \r\n                options: { \r\n                    count: 3, \r\n                    color: 0x880000, \r\n                    colorRange: { start: 0x880000, end: 0xDC143C },\r\n                    scaleMultiplier: 1.4,\r\n                    speedMultiplier: 1.2\r\n                } \r\n            },\r\n            bloodlust: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xB22222,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if already has bloodlust active to prevent stacking\r\n        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n        return !existingBuff || existingBuff.buffType !== 'bloodlust';\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Berserker enters a bloodthirsty frenzy!\", true);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for bloodlust activation\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.activateBloodlust(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    activateBloodlust(casterEntity) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;\r\n        \r\n        // Check if already has bloodlust to prevent double application\r\n        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n        if (existingBuff && existingBuff.buffType === 'bloodlust') {\r\n            // DESYNC SAFE: Refresh duration instead of stacking\r\n            existingBuff.endTime = this.game.state.now + this.duration;\r\n            existingBuff.appliedTime = this.game.state.now;\r\n            \r\n            // Visual refresh effect\r\n            this.createVisualEffect(casterPos, 'bloodlust');\r\n            return;\r\n        }\r\n        \r\n        // Apply bloodlust buff\r\n        const Components = this.game.componentManager.getComponents();\r\n        this.game.addComponent(casterEntity, this.componentTypes.BUFF, \r\n            Components.Buff('bloodlust', { \r\n                lifeSteal: this.lifeStealAmount, \r\n                damagePerKill: this.damagePerKill, \r\n                maxStacks: this.maxStacks,\r\n                currentStacks: 0 // Start with 0 kill stacks\r\n            }, this.game.state.now + this.duration, true, 1, this.game.state.now));\r\n        \r\n        // Visual bloodlust effect\r\n        this.createVisualEffect(casterPos, 'bloodlust');\r\n        \r\n        // Screen effect for dramatic activation\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.2, 1.5);\r\n            this.game.effectsSystem.playScreenFlash('#8B0000', 0.3);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule buff removal\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.removeBloodlust(casterEntity);\r\n        }, this.duration, casterEntity);\r\n        \r\n \r\n    }\r\n    \r\n    // DESYNC SAFE: Remove bloodlust buff\r\n    removeBloodlust(casterEntity) {\r\n        // Check if entity still exists and has the bloodlust buff\r\n        if (this.game.hasComponent(casterEntity, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'bloodlust') {\r\n                const stacksGained = buff.modifiers.currentStacks || 0;\r\n                \r\n                this.game.removeComponent(casterEntity, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when bloodlust expires\r\n                const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n                if (casterPos) {\r\n                    this.createVisualEffect(casterPos, 'bloodlust', { \r\n                        count: 5, \r\n                        scaleMultiplier: 0.8,\r\n                        color: 0x696969 \r\n                    });\r\n                }\r\n                \r\n             \r\n            }\r\n        }\r\n    }\r\n    \r\n    // Helper method to handle kill stacking (called by damage system when enemy dies)\r\n    onEnemyKilled(killerId) {\r\n        if (!this.game.hasComponent(killerId, this.componentTypes.BUFF)) return;\r\n        \r\n        const buff = this.game.getComponent(killerId, this.componentTypes.BUFF);\r\n        if (!buff || buff.buffType !== 'bloodlust') return;\r\n        \r\n        // Increase kill stacks up to maximum\r\n        const currentStacks = buff.modifiers.currentStacks || 0;\r\n        if (currentStacks < this.maxStacks) {\r\n            buff.modifiers.currentStacks = currentStacks + 1;\r\n            \r\n            // Visual effect for gaining a kill stack\r\n            const killerPos = this.game.getComponent(killerId, this.componentTypes.POSITION);\r\n            if (killerPos) {\r\n                this.createVisualEffect(killerPos, 'bloodlust', { \r\n                    count: 3, \r\n                    scaleMultiplier: 1.2,\r\n                    heightOffset: 10 \r\n                });\r\n            }\r\n    \r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BloodlustAbility.js",
        "fileName": "BloodlustAbility"
      },
      "ChargeAbility": {
        "script": "class ChargeAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'charge',\r\n            name: 'Charge',\r\n            description: 'Rush forward dealing damage and stunning enemies',\r\n            cooldown: 5.0,\r\n            range: 150,\r\n            manaCost: 0,\r\n            targetType: 'enemy',\r\n            animation: 'attack',\r\n            priority: 8,\r\n            castTime: 0.5,\r\n            ...params\r\n        });\r\n        \r\n        this.chargeDamage = 55;\r\n        this.chargeSpeed = 300;\r\n        this.chargeDuration = 0.8; // How long the charge takes\r\n        this.stunDuration = 2.0; // How long enemies are stunned\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xC0C0C0,\r\n                    colorRange: { start: 0xC0C0C0, end: 0xFFFFFF },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            charge: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B4513,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            },\r\n            impact: {\r\n                type: 'damage',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF4500,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        \r\n        // Don't charge if already charging\r\n        const charging = this.game.getComponent(casterEntity, this.componentTypes.CHARGING);\r\n        if (charging && charging.isCharging) return false;\r\n        \r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // DESYNC SAFE: Select closest enemy deterministically\r\n        const target = this.findClosestEnemy(casterEntity, enemies);\r\n        if (!target) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Knight charges into battle!\", true);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for charge execution\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.initiateCharge(casterEntity, target);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Find closest enemy deterministically\r\n    findClosestEnemy(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return closest;\r\n    }\r\n    \r\n    initiateCharge(casterEntity, targetId) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);\r\n        \r\n        if (!pos || !targetPos || !velocity) return;\r\n        \r\n        // DESYNC SAFE: Calculate charge direction deterministically\r\n        const dx = targetPos.x - pos.x;\r\n        const dz = targetPos.z - pos.z;\r\n        const distance = Math.sqrt(dx * dx + dz * dz);\r\n        \r\n        if (distance === 0) return; // Avoid division by zero\r\n        \r\n        // DESYNC SAFE: Add charging component for state tracking\r\n        const Components = this.game.componentManager.getComponents();\r\n        this.game.addComponent(casterEntity, this.componentTypes.CHARGING, \r\n            Components.Charging(targetId, this.chargeSpeed, this.chargeDamage, \r\n                this.game.state.now, 0, distance));\r\n        \r\n        // Set velocity for charge\r\n        velocity.vx = (dx / distance) * this.chargeSpeed;\r\n        velocity.vz = (dz / distance) * this.chargeSpeed;\r\n        \r\n        // Visual charge effect\r\n        this.createVisualEffect(pos, 'charge');\r\n        \r\n        // Screen effect for dramatic charge\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.2, 1);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule charge completion\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.completeCharge(casterEntity, targetId);\r\n        }, this.chargeDuration, casterEntity);\r\n    }\r\n    \r\n    completeCharge(casterEntity, targetId) {\r\n        // Stop the charge by removing charging component and resetting velocity\r\n        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {\r\n            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);\r\n        }\r\n        \r\n        // Stop movement\r\n        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);\r\n        if (velocity) {\r\n            velocity.vx = 0;\r\n            velocity.vz = 0;\r\n        }\r\n        \r\n        // Check if target still exists and is in range for impact\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        \r\n        if (!casterPos || !targetPos || !targetHealth || targetHealth.current <= 0) return;\r\n        \r\n        // Check if we're close enough to hit the target\r\n        const distance = Math.sqrt(\r\n            Math.pow(targetPos.x - casterPos.x, 2) + \r\n            Math.pow(targetPos.z - casterPos.z, 2)\r\n        );\r\n        \r\n        if (distance <= 50) { // Hit range\r\n            // Visual impact effect\r\n            this.createVisualEffect(targetPos, 'impact');\r\n            \r\n            // Deal damage\r\n            this.dealDamageWithEffects(casterEntity, targetId, this.chargeDamage, 'physical', {\r\n                isCharge: true,\r\n                knockback: true\r\n            });\r\n            \r\n            // DESYNC SAFE: Apply stun using buff system\r\n            const Components = this.game.componentManager.getComponents();\r\n            this.game.addComponent(targetId, this.componentTypes.BUFF, \r\n                Components.Buff('stunned', { \r\n                    movementDisabled: true, \r\n                    attackDisabled: true \r\n                }, this.game.state.now + this.stunDuration, false, 1, this.game.state.now));\r\n            \r\n            // DESYNC SAFE: Schedule stun removal\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.removeStun(targetId);\r\n            }, this.stunDuration, targetId);\r\n            \r\n            // Screen effect for impact\r\n            if (this.game.effectsSystem) {\r\n                this.game.effectsSystem.playScreenShake(0.4, 2);\r\n            }\r\n            \r\n        \r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Remove stun effect\r\n    removeStun(targetId) {\r\n        // Check if target still exists and has the stun buff\r\n        if (this.game.hasComponent(targetId, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(targetId, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'stunned') {\r\n                this.game.removeComponent(targetId, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when stun expires\r\n                const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n                if (targetPos) {\r\n                    this.createVisualEffect(targetPos, 'cast', { \r\n                        count: 3, \r\n                        scaleMultiplier: 0.8,\r\n                        color: 0x87CEEB \r\n                    });\r\n                }\r\n          \r\n            }\r\n        }\r\n    }\r\n    \r\n    // Helper method to handle charge interruption (e.g., if caster dies mid-charge)\r\n    cancelCharge(casterEntity) {\r\n        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {\r\n            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);\r\n            \r\n            // Stop movement\r\n            const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);\r\n            if (velocity) {\r\n                velocity.vx = 0;\r\n                velocity.vz = 0;\r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChargeAbility.js",
        "fileName": "ChargeAbility"
      },
      "ExplosiveTrapAbility": {
        "script": "class ExplosiveTrapAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'explosive_trap',\r\n            name: 'Explosive Trap',\r\n            description: 'Place a hidden trap that explodes when enemies approach (max 2 per Trapper)',\r\n            cooldown: 15.0,\r\n            range: 100,\r\n            manaCost: 35,\r\n            targetType: 'ground',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 1.5,\r\n            ...params\r\n        });\r\n        \r\n        this.maxTrapsPerTrapper = 2;\r\n        this.trapDamage = 80;\r\n        this.explosionRadius = 100;\r\n        this.triggerRadius = 40;\r\n        this.trapPlacementDistance = 60;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B4513,\r\n                    colorRange: { start: 0x8B4513, end: 0xA0522D },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            trap_place: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x696969,\r\n                    scaleMultiplier: 0.8,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            trap_explosion: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF4500,\r\n                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // DESYNC SAFE: Check how many traps this trapper already has active\r\n        const existingTraps = this.game.getEntitiesWith(\r\n            this.componentTypes.TRAP,\r\n            this.componentTypes.POSITION\r\n        );\r\n        \r\n        // Sort traps for consistent processing\r\n        const sortedTraps = existingTraps.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        const myTraps = sortedTraps.filter(trapId => {\r\n            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);\r\n            return trap && trap.caster === casterEntity && !trap.triggered;\r\n        });\r\n        \r\n        return myTraps.length < this.maxTrapsPerTrapper;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Trapper prepares an explosive surprise!\");\r\n        \r\n        // DESYNC SAFE: Use scheduling system for trap placement\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.placeTrap(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    placeTrap(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (!casterHealth || casterHealth.current <= 0) return;\r\n        \r\n        // DESYNC SAFE: Calculate trap position deterministically\r\n        const trapPos = this.calculateTrapPosition(casterEntity, pos);\r\n        \r\n        // Create trap entity\r\n        const trapId = this.game.createEntity();\r\n        const Components = this.game.componentManager.getComponents();\r\n        \r\n        // Position component\r\n        this.game.addComponent(trapId, this.componentTypes.POSITION, \r\n            Components.Position(trapPos.x, trapPos.y, trapPos.z));\r\n        \r\n        // DESYNC SAFE: Trap component with proper game time\r\n        this.game.addComponent(trapId, this.componentTypes.TRAP, \r\n            Components.Trap(\r\n                this.trapDamage, \r\n                this.explosionRadius, \r\n                this.triggerRadius, \r\n                'physical', \r\n                casterEntity, \r\n                false, \r\n                1\r\n            ));\r\n        \r\n        // Visual indicator (hidden from enemies in actual gameplay)\r\n        this.game.addComponent(trapId, this.componentTypes.RENDERABLE, \r\n            Components.Renderable(\"effects\", \"hidden_trap\"));\r\n        \r\n        // DESYNC SAFE: Add lifetime to prevent permanent traps\r\n        this.game.addComponent(trapId, this.componentTypes.LIFETIME, \r\n            Components.Lifetime(60.0, this.game.state.now)); // 60 second lifetime\r\n        \r\n        // Visual trap placement effect\r\n        this.createVisualEffect(trapPos, 'trap_place');\r\n        \r\n      \r\n        // DESYNC SAFE: Schedule trap cleanup after lifetime\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.cleanupTrap(trapId);\r\n        }, 60.0, trapId);\r\n    }\r\n    \r\n    // DESYNC SAFE: Calculate trap position deterministically\r\n    calculateTrapPosition(casterEntity, casterPos) {\r\n        // Get facing direction for consistent placement\r\n        const facing = this.game.getComponent(casterEntity, this.componentTypes.FACING) || { angle: 0 };\r\n        \r\n        // Calculate position ahead of caster\r\n        const trapPos = {\r\n            x: casterPos.x + Math.cos(facing.angle) * this.trapPlacementDistance,\r\n            y: casterPos.y,\r\n            z: casterPos.z + Math.sin(facing.angle) * this.trapPlacementDistance\r\n        };\r\n        \r\n        // DESYNC SAFE: Validate position and adjust if needed\r\n        return this.validateTrapPosition(trapPos, casterPos);\r\n    }\r\n    \r\n    // DESYNC SAFE: Validate and adjust trap position if needed\r\n    validateTrapPosition(proposedPos, fallbackPos) {\r\n        // Basic bounds checking\r\n        if (proposedPos.x < -1000 || proposedPos.x > 1000 || \r\n            proposedPos.z < -1000 || proposedPos.z > 1000) {\r\n            return fallbackPos; // Use caster position as fallback\r\n        }\r\n        \r\n        // Check for existing traps nearby (prevent stacking)\r\n        const existingTraps = this.game.getEntitiesWith(\r\n            this.componentTypes.TRAP,\r\n            this.componentTypes.POSITION\r\n        );\r\n        \r\n        for (const trapId of existingTraps) {\r\n            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);\r\n            if (trapPos) {\r\n                const distance = Math.sqrt(\r\n                    Math.pow(trapPos.x - proposedPos.x, 2) + \r\n                    Math.pow(trapPos.z - proposedPos.z, 2)\r\n                );\r\n                \r\n                if (distance < 30) { // Too close to existing trap\r\n                    // Offset the position slightly\r\n                    return {\r\n                        x: proposedPos.x + 20,\r\n                        y: proposedPos.y,\r\n                        z: proposedPos.z + 20\r\n                    };\r\n                }\r\n            }\r\n        }\r\n        \r\n        return proposedPos; // Position is valid\r\n    }\r\n    \r\n    // DESYNC SAFE: Handle trap trigger (called by game systems when enemy approaches)\r\n    triggerTrap(trapId, triggeringEnemyId) {\r\n        const trapComponent = this.game.getComponent(trapId, this.componentTypes.TRAP);\r\n        const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);\r\n        \r\n        if (!trapComponent || !trapPos || trapComponent.triggered) return;\r\n        \r\n        // Mark trap as triggered\r\n        trapComponent.triggered = true;\r\n        trapComponent.triggerCount++;\r\n        \r\n        // Visual explosion effect\r\n        this.createVisualEffect(trapPos, 'trap_explosion');\r\n        \r\n        // Screen effects for dramatic explosion\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.showExplosionEffect(trapPos.x, trapPos.y, trapPos.z);\r\n            this.game.effectsSystem.playScreenShake(0.3, 2);\r\n        }\r\n        \r\n        // DESYNC SAFE: Apply explosion damage to all enemies in radius\r\n        this.applyExplosionDamage(trapComponent.caster, trapPos, trapComponent);\r\n        \r\n        // DESYNC SAFE: Schedule trap cleanup after explosion\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.cleanupTrap(trapId);\r\n        }, 0.5, trapId); // Small delay for explosion effects\r\n    }\r\n    \r\n    // DESYNC SAFE: Apply explosion damage deterministically\r\n    applyExplosionDamage(casterId, explosionPos, trapComponent) {\r\n        // Get all entities that could be damaged\r\n        const allEntities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.HEALTH,\r\n            this.componentTypes.TEAM\r\n        );\r\n        \r\n        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);\r\n        if (!casterTeam) return;\r\n        \r\n        // Sort entities for consistent processing\r\n        const sortedEntities = allEntities.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let damageTargets = [];\r\n        \r\n        sortedEntities.forEach(entityId => {\r\n            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            \r\n            if (!entityPos || !entityHealth || !entityTeam || entityHealth.current <= 0) return;\r\n            \r\n            // Don't damage allies\r\n            if (entityTeam.team === casterTeam.team) return;\r\n            \r\n            // Check if in explosion radius\r\n            const distance = Math.sqrt(\r\n                Math.pow(entityPos.x - explosionPos.x, 2) + \r\n                Math.pow(entityPos.z - explosionPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= trapComponent.radius) {\r\n                damageTargets.push({\r\n                    id: entityId,\r\n                    distance: distance,\r\n                    position: entityPos\r\n                });\r\n            }\r\n        });\r\n        \r\n        // Apply damage to all targets\r\n        damageTargets.forEach(target => {\r\n            // Calculate damage falloff based on distance\r\n            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / trapComponent.radius));\r\n            const finalDamage = Math.floor(trapComponent.damage * damageMultiplier);\r\n            \r\n            this.dealDamageWithEffects(casterId, target.id, finalDamage, trapComponent.element, {\r\n                isTrap: true,\r\n                isExplosion: true\r\n            });\r\n        });\r\n        \r\n     \r\n    }\r\n    \r\n    // DESYNC SAFE: Clean up trap entity\r\n    cleanupTrap(trapId) {\r\n        if (this.game.hasComponent(trapId, this.componentTypes.TRAP)) {\r\n            // Small visual effect for trap disappearing\r\n            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);\r\n            if (trapPos) {\r\n                this.createVisualEffect(trapPos, 'trap_place', { \r\n                    count: 2, \r\n                    scaleMultiplier: 0.5 \r\n                });\r\n            }\r\n            \r\n            this.game.destroyEntity(trapId);\r\n        }\r\n    }\r\n    \r\n    // Helper method for other systems to check trap count\r\n    getActiveTrapCount(trapperId) {\r\n        const existingTraps = this.game.getEntitiesWith(\r\n            this.componentTypes.TRAP,\r\n            this.componentTypes.POSITION\r\n        );\r\n        \r\n        return existingTraps.filter(trapId => {\r\n            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);\r\n            return trap && trap.caster === trapperId && !trap.triggered;\r\n        }).length;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ExplosiveTrapAbility.js",
        "fileName": "ExplosiveTrapAbility"
      },
      "DrainLifeAbility": {
        "script": "class DrainLifeAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'drain_life',\r\n            name: 'Drain Life',\r\n            description: 'Drains health from an enemy and heals the caster',\r\n            cooldown: 4.5,\r\n            range: 200,\r\n            manaCost: 45,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 1.2,\r\n            autoTrigger: 'low_health',\r\n            ...params\r\n        });\r\n        \r\n        this.drainAmount = 60;\r\n        this.healRatio = 0.8; // Heal 80% of drained health\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x800080,\r\n                    colorRange: { start: 0x800080, end: 0x4B0082 },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            drain: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B008B,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.5\r\n                }\r\n            },\r\n            heal: {\r\n                type: 'heal',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x9400D3,\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        \r\n        // Use when injured and enemies are available\r\n        return enemies.length >= 1 && \r\n               casterHealth && casterHealth.current < casterHealth.max * 0.6;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // DESYNC SAFE: Target selection\r\n        const target = this.findHighestHealthEnemy(enemies);\r\n        if (!target) return;\r\n        \r\n        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n        if (!targetPos) return;\r\n        \r\n        // Immediate effects (visual, audio, logging)\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        \r\n        // Create drain beam effect immediately\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.createEnergyBeam(\r\n                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),\r\n                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),\r\n                {\r\n                    style: { color: 0x8B008B, linewidth: 4 },\r\n                    animation: { duration: 1000, pulseEffect: true }\r\n                }\r\n            );\r\n        }\r\n        \r\n        this.logAbilityUsage(casterEntity, `Dark energy siphons life force!`);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for delayed effect\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            const currentTargetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n            if (currentTargetPos) {\r\n                this.performDrain(casterEntity, target, currentTargetPos);\r\n            }\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performDrain(casterEntity, targetId, targetPos) {\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || !casterPos || !targetPos) return;\r\n        \r\n        // Apply damage to target\r\n        const result = this.dealDamageWithEffects(casterEntity, targetId, this.drainAmount, this.element, {\r\n            isDrain: true\r\n        });\r\n        \r\n        if (result && result.damage > 0) {\r\n            // Heal caster based on damage dealt\r\n            const healAmount = Math.floor(result.damage * this.healRatio);\r\n            const actualHeal = Math.min(healAmount, casterHealth.max - casterHealth.current);\r\n            casterHealth.current += actualHeal;\r\n            \r\n            // Drain effect on target\r\n            this.createVisualEffect(targetPos, 'drain');\r\n            \r\n            // Heal effect on caster\r\n            if (actualHeal > 0) {\r\n                this.createVisualEffect(casterPos, 'heal');\r\n                \r\n                if (this.game.effectsSystem) {\r\n                    this.game.effectsSystem.showDamageNumber(\r\n                        casterPos.x, casterPos.y + 15, casterPos.z,\r\n                        actualHeal, 'heal'\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Deterministic target selection\r\n    findHighestHealthEnemy(enemies) {\r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let strongest = null;\r\n        let highestHealth = 0;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking\r\n                highestHealth = health.current;\r\n                strongest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return strongest;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DrainLifeAbility.js",
        "fileName": "DrainLifeAbility"
      },
      "IceShardAbility": {
        "script": "class IceShardAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'ice_shard',\r\n            name: 'Ice Shard',\r\n            description: 'Fires piercing ice shards that slow enemies',\r\n            cooldown: 2.5,\r\n            range: 280,\r\n            manaCost: 25,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 0.8,\r\n            autoTrigger: 'enemy_in_range',\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 40;\r\n        this.shardCount = 3;\r\n        this.element = 'cold';\r\n        this.slowDuration = 3.0;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4488ff,\r\n                    colorRange: { start: 0x4488ff, end: 0xaaffff },\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            shard: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88bbff,\r\n                    scaleMultiplier: 0.6,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 1;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Crystalline ice shards pierce the air!`);\r\n        \r\n        // Schedule all shards with staggered timing\r\n        for (let i = 0; i < this.shardCount; i++) {\r\n            const shardDelay = this.castTime + (i * 0.2); // 0.2 second stagger between shards\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                // Re-get enemies at firing time (some may have died)\r\n                const currentEnemies = this.getEnemiesInRange(casterEntity);\r\n                if (currentEnemies.length > 0) {\r\n                    // DESYNC SAFE: Select target deterministically instead of randomly\r\n                    const target = this.selectDeterministicTarget(currentEnemies, i);\r\n                    if (target) {\r\n                        this.fireIceShard(casterEntity, target);\r\n                    }\r\n                }\r\n            }, shardDelay, casterEntity);\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Deterministic target selection instead of random\r\n    selectDeterministicTarget(enemies, shardIndex) {\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Sort enemies deterministically\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Use shard index to cycle through targets deterministically\r\n        const targetIndex = shardIndex % sortedEnemies.length;\r\n        return sortedEnemies[targetIndex];\r\n    }\r\n    \r\n    fireIceShard(casterEntity, targetId) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!casterPos || !targetPos) return;\r\n        \r\n        // Visual effect at launch\r\n        this.createVisualEffect(casterPos, 'shard');\r\n        \r\n        // Deal damage with slowing effect\r\n        this.dealDamageWithEffects(casterEntity, targetId, this.damage, this.element, {\r\n            isIceShard: true,\r\n            slowDuration: this.slowDuration\r\n        });\r\n        \r\n        // DESYNC SAFE: Use scheduling system for visual effect delay\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n            if (currentTargetPos) {\r\n                this.createVisualEffect(currentTargetPos, 'shard', { count: 3 });\r\n            }\r\n        }, 0.3, casterEntity);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/IceShardAbility.js",
        "fileName": "IceShardAbility"
      },
      "LightningBoltAbility": {
        "script": "class LightningBoltAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'lightning_bolt',\r\n            name: 'Lightning Bolt',\r\n            description: 'Instantly strikes an enemy with pure lightning',\r\n            cooldown: 2.0,\r\n            range: 350,\r\n            manaCost: 30,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 0.5,\r\n            autoTrigger: 'enemy_in_range',\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 55;\r\n        this.criticalChance = 0.3; // 30% crit chance\r\n        this.element = 'lightning';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 1,\r\n                    color: 0xffff44,\r\n                    colorRange: { start: 0xffff44, end: 0xffffff },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 4.0\r\n                }\r\n            },\r\n            lightning: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 2,\r\n                    color: 0xffffaa,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 5.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 1;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // DESYNC SAFE: Find target with highest health deterministically\r\n        const target = this.findHighestHealthEnemy(enemies);\r\n        if (!target) return;\r\n        \r\n        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n        if (!targetPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Lightning crackles with divine fury!`, true);\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.strikeLightning(casterEntity, target, targetPos);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    strikeLightning(casterEntity, targetId, targetPos) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Create lightning bolt visual effect\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.createLightningBolt(\r\n                new THREE.Vector3(casterPos.x, casterPos.y + 50, casterPos.z),\r\n                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),\r\n                {\r\n                    style: { color: 0xffffaa, linewidth: 6 },\r\n                    animation: { duration: 400, flickerCount: 3 }\r\n                }\r\n            );\r\n        }\r\n        \r\n        // Lightning effect at target\r\n        this.createVisualEffect(targetPos, 'lightning');\r\n        \r\n        // Screen flash\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.15);\r\n        }\r\n        \r\n        // DESYNC SAFE: Determine critical hit deterministically instead of random\r\n        const isCritical = this.isDeterministicCritical(casterEntity, targetId);\r\n        const damage = isCritical ? this.damage * 2 : this.damage;\r\n        \r\n        // Apply lightning damage\r\n        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {\r\n            isCritical: isCritical,\r\n            isInstant: true\r\n        });\r\n    }\r\n    \r\n    // DESYNC SAFE: Deterministic critical hit calculation\r\n    isDeterministicCritical(casterId, targetId) {\r\n        // Create a deterministic \"random\" value based on entity IDs and game time\r\n        const seed = parseInt(casterId) + parseInt(targetId) + Math.floor(this.game.state.now * 100);\r\n        const pseudoRandom = (seed * 9301 + 49297) % 233280 / 233280; // Simple PRNG\r\n        \r\n        return pseudoRandom < this.criticalChance;\r\n    }\r\n    \r\n    // DESYNC SAFE: Deterministic highest health enemy finding\r\n    findHighestHealthEnemy(enemies) {\r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let strongest = null;\r\n        let highestHealth = 0;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking\r\n                highestHealth = health.current;\r\n                strongest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return strongest;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/LightningBoltAbility.js",
        "fileName": "LightningBoltAbility"
      },
      "MineGoldAbility": {
        "script": "class MineGoldAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, abilityData) {\r\n        super(game, abilityData);\r\n        this.id = 'mineGold';\r\n        this.name = 'Mine Gold';\r\n        this.description = 'Automatically mines gold from gold mines';\r\n        this.isPassive = true;\r\n        this.autocast = true;\r\n        this.enabled = true;\r\n        this.castTime = 0;\r\n        this.cooldown = 0;\r\n        this.priority = 0;\r\n        \r\n        this.goldPerTrip = 10;\r\n        this.miningRange = 25;\r\n        this.depositRange = 25;\r\n        this.miningDuration = 2;\r\n        this.depositDuration = 1;\r\n        this.waitingDistance = 30; // Distance to wait from mine when queued\r\n    }\r\n\r\n    canExecute(entityId) {\r\n        if(!this.enabled){\r\n            return false;\r\n        }\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        let miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);\r\n        if (!miningState) {\r\n            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n            \r\n            this.game.addComponent(entityId, ComponentTypes.MINING_STATE, {\r\n                state: 'idle',\r\n                targetMineEntityId: null,\r\n                targetMinePosition: null,\r\n                targetTownHall: null,\r\n                waitingPosition: null,\r\n                hasGold: false,\r\n                miningStartTime: 0,\r\n                depositStartTime: 0,\r\n                team: team?.team,\r\n                entityId: entityId\r\n            });\r\n        }\r\n        const currentAIController = this.game.aiSystem.getCurrentAIControllerId(entityId);\r\n\r\n        if(currentAIController == null){\r\n            let currentMiningStateAI = this.game.aiSystem.getAIControllerData(entityId, ComponentTypes.MINING_STATE);\r\n            this.game.aiSystem.setCurrentAIController(entityId, ComponentTypes.MINING_STATE, currentMiningStateAI); \r\n        }\r\n        \r\n        return (currentAIController == ComponentTypes.MINING_STATE);\r\n    }\r\n\r\n    execute(entityId, targetData) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);\r\n        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);\r\n        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n        \r\n        if (!miningState || !pos || !vel || !health || health.current <= 0) {\r\n            this.enabled = false;\r\n            return null;\r\n        }\r\n        this.updateMinerState(entityId, miningState, pos, vel);\r\n        return null;\r\n    }\r\n\r\n    updateMinerState(entityId, miningState, pos, vel) {\r\n        miningState.entityId = entityId;\r\n        switch (miningState.state) {\r\n            case 'idle':\r\n                this.findMineTarget(miningState);\r\n                break;\r\n            case 'walking_to_mine':\r\n                this.walkToMine(miningState, pos, vel);\r\n                break;\r\n            case 'waiting_at_mine':\r\n                this.waitAtMine(miningState, pos, vel);\r\n                break;\r\n            case 'mining':\r\n                this.mineGold(miningState);\r\n                break;\r\n            case 'walking_to_hall':\r\n                this.walkToTownHall(miningState, pos, vel);\r\n                break;\r\n            case 'depositing':\r\n                this.depositGold(miningState);\r\n                break;\r\n        }\r\n    }\r\n\r\n    findMineTarget(miningState) {\r\n        let closestMine = null;\r\n        let closestDistance = Infinity;\r\n        let closestMineEntityId = null;\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const pos = this.game.getComponent(miningState.entityId, ComponentTypes.POSITION);\r\n        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n\r\n        if (!pos) return;\r\n\r\n        // Get sorted mine entityIds for deterministic iteration\r\n        const sortedMineIds = Array.from(this.game.goldMineSystem.claimedGoldMines.keys()).sort((a, b) =>\r\n            String(a).localeCompare(String(b))\r\n        );\r\n\r\n        // Search through all claimed gold mines in deterministic order\r\n        for (const mineEntityId of sortedMineIds) {\r\n            const goldMine = this.game.goldMineSystem.claimedGoldMines.get(mineEntityId);\r\n\r\n            // Check if this mine belongs to our team\r\n            if (goldMine.team === miningState.team) {\r\n                // Calculate distance to this mine\r\n                const dx = goldMine.worldPosition.x - pos.x;\r\n                const dz = goldMine.worldPosition.z - pos.z;\r\n                const distance = Math.sqrt(dx * dx + dz * dz);\r\n\r\n                if (distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestMine = goldMine;\r\n                    closestMineEntityId = mineEntityId;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!closestMine) {\r\n            return;\r\n        }\r\n\r\n        miningState.targetMineEntityId = closestMineEntityId;\r\n        miningState.targetMinePosition = {\r\n            x: closestMine.worldPosition.x,\r\n            y: closestMine.worldPosition.y || 0,\r\n            z: closestMine.worldPosition.z\r\n        };\r\n        miningState.state = 'walking_to_mine';\r\n\r\n        if (aiState && aiState.targetPosition != miningState.targetMinePosition) {\r\n            aiState.targetPosition = miningState.targetMinePosition;\r\n            aiState.path = [];\r\n            aiState.meta = {};\r\n        }\r\n    }\r\n\r\n    findTownHall(miningState) {\r\n        const CT = this.game.componentManager.getComponentTypes();\r\n        const combatUnits = this.game.getEntitiesWith(CT.POSITION, CT.TEAM, CT.UNIT_TYPE);        \r\n        const aiState = this.game.getComponent(miningState.entityId, CT.AI_STATE);\r\n        const pos = this.game.getComponent(miningState.entityId, CT.POSITION);\r\n        \r\n        if (!pos) return;\r\n        \r\n        let closestTownHall = null;\r\n        let closestDistance = Infinity;\r\n    \r\n        for (let i = 0; i < combatUnits.length; i++) {\r\n            const entityId = combatUnits[i];\r\n            const townHallPos = this.game.getComponent(entityId, CT.POSITION);\r\n            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);\r\n            const team = this.game.getComponent(entityId, CT.TEAM);\r\n        \r\n            if (team.team == miningState.team && unitType.id == \"townHall\") {\r\n                // Calculate distance to this town hall\r\n                const dx = townHallPos.x - pos.x;\r\n                const dz = townHallPos.z - pos.z;\r\n                const distance = Math.sqrt(dx * dx + dz * dz);\r\n            \r\n                if (distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestTownHall = { x: townHallPos.x, y: townHallPos.y, z: townHallPos.z };\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (closestTownHall) {\r\n            miningState.targetTownHall = closestTownHall;\r\n            if (aiState) {\r\n                aiState.targetPosition = miningState.targetTownHall;\r\n                aiState.path = [];\r\n                aiState.meta = {};\r\n            }\r\n        }\r\n    }\r\n\r\n    walkToMine(miningState, pos, vel) {\r\n        if (!miningState.targetMinePosition || !miningState.targetMineEntityId) {\r\n            this.findMineTarget(miningState);\r\n            if (!miningState.targetMinePosition) {\r\n                miningState.state = 'idle';\r\n                return;\r\n            }\r\n        }\r\n\r\n        const mine = this.game.goldMineSystem.claimedGoldMines.get(miningState.targetMineEntityId);\r\n        if (!mine || mine.team !== miningState.team) {\r\n            // Mine no longer exists or changed teams - reset to idle\r\n            miningState.targetMineEntityId = null;\r\n            miningState.targetMinePosition = null;\r\n            miningState.waitingPosition = null;\r\n            miningState.state = 'idle';\r\n            return;\r\n        }\r\n\r\n        const dx = miningState.targetMinePosition.x - pos.x;\r\n        const dz = miningState.targetMinePosition.z - pos.z;\r\n        const dist = Math.sqrt(dx * dx + dz * dz);\r\n\r\n\r\n        if (dist < this.miningRange) {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n            \r\n            const mineEntityId = miningState.targetMineEntityId;\r\n            const isOccupied = this.game.goldMineSystem.isMineOccupied(mineEntityId);\r\n            const currentOccupant = this.game.goldMineSystem.getCurrentMiner(mineEntityId);\r\n\r\n            if (isOccupied && currentOccupant !== miningState.entityId) {\r\n                // Mine is occupied, need to wait\r\n                const queuePosition = this.game.goldMineSystem.getQueuePosition(mineEntityId, miningState.entityId);\r\n                const waitPos = this.getWaitingPosition(miningState.targetMinePosition, queuePosition);\r\n                \r\n                miningState.waitingPosition = waitPos;\r\n                miningState.state = 'waiting_at_mine';\r\n\r\n                if (aiState) {\r\n                    aiState.state = 'chasing';\r\n                    aiState.targetPosition = waitPos;\r\n                }\r\n            } else if (!isOccupied) {\r\n                // Mine is free, start mining\r\n                if (aiState) {\r\n                    aiState.state = 'idle';\r\n                    aiState.targetPosition = null;\r\n                }\r\n                pos.x = miningState.targetMinePosition.x;\r\n                pos.z = miningState.targetMinePosition.z;\r\n                vel.vx = 0;\r\n                vel.vz = 0;\r\n                miningState.state = 'mining';\r\n                miningState.miningStartTime = this.game.state.now;\r\n            }\r\n        } else {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n            \r\n            if (aiState && aiState.targetPosition != miningState.targetMinePosition) {\r\n                aiState.state = 'chasing';\r\n                aiState.targetPosition = miningState.targetMinePosition;        \r\n                aiState.path = [];                        \r\n                aiState.meta = {};\r\n            }\r\n        }\r\n    }\r\n\r\n    walkToTownHall(miningState, pos, vel) {\r\n        if (!miningState.targetTownHall) {\r\n            this.findTownHall(miningState);\r\n            if (!miningState.targetTownHall) {\r\n                miningState.state = 'idle';\r\n                return;\r\n            }\r\n        }\r\n\r\n        const dx = miningState.targetTownHall.x - pos.x;\r\n        const dz = miningState.targetTownHall.z - pos.z;\r\n        const dist = Math.sqrt(dx * dx + dz * dz);\r\n\r\n        if (dist < this.depositRange) {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n            \r\n            if (aiState) {\r\n                aiState.state = 'idle';\r\n                aiState.targetPosition = null;\r\n            }\r\n            pos.x = miningState.targetTownHall.x - 5;\r\n            pos.z = miningState.targetTownHall.z - 5;\r\n            vel.vx = 0;\r\n            vel.vz = 0;\r\n            miningState.state = 'depositing';\r\n            miningState.depositStartTime = this.game.state.now;\r\n        } else {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n            \r\n            if (aiState && aiState.targetPosition != miningState.targetTownHall) {\r\n                aiState.state = 'chasing';\r\n                aiState.targetPosition = miningState.targetTownHall;\r\n                aiState.path = [];\r\n                aiState.meta = {};\r\n            }\r\n        }\r\n    }\r\n\r\n    waitAtMine(miningState, pos, vel) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);\r\n\r\n        // Check if we're next in queue\r\n        const isNextInQueue = this.game.goldMineSystem.isNextInQueue(\r\n            miningState.targetMineEntityId, \r\n            miningState.entityId\r\n        );\r\n        \r\n        const isMineOccupied = this.game.goldMineSystem.isMineOccupied(miningState.targetMineEntityId);\r\n        \r\n        // If we're next and the mine is free, start mining\r\n        if (isNextInQueue && !isMineOccupied) {\r\n            // The goldMineSystem.processNextInQueue will be called from mineGold when mining completes\r\n            // But we can also transition directly here if we detect we're next\r\n            if (aiState) {\r\n                aiState.state = 'idle';\r\n                aiState.targetPosition = null;\r\n            }\r\n            pos.x = miningState.targetMinePosition.x;\r\n            pos.z = miningState.targetMinePosition.z;\r\n            vel.vx = 0;\r\n            vel.vz = 0;\r\n            \r\n            miningState.state = 'mining';\r\n            miningState.miningStartTime = this.game.state.now;\r\n            miningState.waitingPosition = null;\r\n        } else {\r\n            // Otherwise stay at waiting position\r\n            if (miningState.waitingPosition && aiState && aiState.state !== 'idle') {\r\n                aiState.state = 'idle';\r\n                aiState.targetPosition = null;\r\n                pos.x = miningState.waitingPosition.x;\r\n                pos.z = miningState.waitingPosition.z;\r\n                vel.vx = 0;\r\n                vel.vz = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    getWaitingPosition(minePosition, queuePosition) {\r\n        // Line up miners in a row next to each other\r\n        // Each miner stands 10 units apart\r\n        const spacing = 10;\r\n        const offsetX = queuePosition * spacing;\r\n        \r\n        return {\r\n            x: minePosition.x + this.waitingDistance + offsetX,\r\n            y: minePosition.y,\r\n            z: minePosition.z\r\n        };\r\n    }\r\n\r\n    mineGold(miningState) {\r\n        const elapsed = this.game.state.now - miningState.miningStartTime;\r\n        \r\n        if (elapsed >= this.miningDuration) {\r\n            miningState.hasGold = true;\r\n            miningState.goldAmt = 10;\r\n\r\n            if(this.game.state.teams){\r\n                let teamState = this.game.state.teams[miningState.team];\r\n                if(teamState && teamState.effects){\r\n                    let teamStateEffects = teamState.effects;\r\n                    if(teamStateEffects['goldPerTrip']){\r\n                        let goldPerTrip = teamStateEffects['goldPerTrip'];\r\n                        if(goldPerTrip && goldPerTrip.value){\r\n                            miningState.goldAmt += goldPerTrip.value;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // Change state first, then process queue\r\n            miningState.state = 'walking_to_hall';\r\n            \r\n            // Process next miner in queue now that this mine is free\r\n            if (miningState.targetMineEntityId) {\r\n                this.game.goldMineSystem.processNextInQueue(miningState.targetMineEntityId);\r\n            }\r\n            \r\n            this.findTownHall(miningState);\r\n        }\r\n    }\r\n\r\n    depositGold(miningState) {\r\n        const elapsed = this.game.state.now - miningState.depositStartTime;\r\n        \r\n        if (elapsed >= this.depositDuration) {\r\n            this.awardGold(miningState.team, miningState.goldAmt);\r\n            miningState.hasGold = false;\r\n            this.findMineTarget(miningState);\r\n        }\r\n    }\r\n\r\n    awardGold(team, goldAmt) {\r\n        if (this.game.isServer) {\r\n            const room = this.game.room;\r\n            for (const [playerId, player] of room.players) {\r\n                if(player.stats.side == team){\r\n                    player.stats.gold += goldAmt;\r\n                    break;\r\n                }\r\n            }\r\n        } else {\r\n            if (team === this.game.state.mySide) {\r\n                this.game.state.playerGold += goldAmt;\r\n            }\r\n        }\r\n    }\r\n    \r\n    logAbilityUsage(entityId) {\r\n        // Passive ability, no logging needed\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MineGoldAbility.js",
        "fileName": "MineGoldAbility"
      },
      "MultiShotAbility": {
        "script": "class MultishotAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'multi_shot',\r\n            name: 'Multi Shot',\r\n            description: 'Fire multiple arrows at different targets',\r\n            cooldown: 7.0,\r\n            range: 180,\r\n            manaCost: 25,\r\n            targetType: 'enemies',\r\n            animation: 'attack',\r\n            priority: 6,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.maxTargets = 3;\r\n        this.arrowDamage = 35;\r\n        this.shotInterval = 0.2; // Time between each arrow\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B4513,\r\n                    colorRange: { start: 0x8B4513, end: 0xDEB887 },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            arrow_launch: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xCD853F,\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            volley: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xF4A460,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Need at least one enemy to shoot at\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Select targets deterministically\r\n        const targets = this.selectMultishotTargets(enemies);\r\n        if (targets.length === 0) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \r\n            `Archer prepares to fire ${targets.length} arrows...`);\r\n        \r\n        // Schedule the multishot volley after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.fireMultishotVolley(casterEntity, targets);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    fireMultishotVolley(casterEntity, targets) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Create volley effect\r\n        this.createVisualEffect(casterPos, 'volley');\r\n        \r\n        // Fire arrows at each target with staggered timing\r\n        targets.forEach((targetId, shotIndex) => {\r\n            const shotDelay = shotIndex * this.shotInterval;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.fireSingleArrow(casterEntity, targetId, shotIndex);\r\n            }, shotDelay, casterEntity);\r\n        });\r\n        \r\n        this.logAbilityUsage(casterEntity, \r\n            `Archer fires volley of ${targets.length} arrows!`);\r\n    }\r\n    \r\n    fireSingleArrow(casterEntity, targetId, shotIndex) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        // Validate target still exists\r\n        if (!casterPos || !targetPos) return;\r\n        \r\n        // Create arrow launch effect\r\n        this.createVisualEffect(casterPos, 'arrow_launch');\r\n        \r\n        // Fire projectile if system is available\r\n        if (this.game.projectileSystem) {\r\n            const projectileData = {\r\n                id: 'arrow',\r\n                title: `Arrow ${shotIndex + 1}`,\r\n                damage: this.arrowDamage,\r\n                speed: 120,\r\n                element: this.element,\r\n                ballistic: true,\r\n                onHit: (hitPos) => {\r\n                    // Impact effect\r\n                    this.createVisualEffect(hitPos, 'arrow_launch', { \r\n                        count: 3, \r\n                        scaleMultiplier: 0.8 \r\n                    });\r\n                },\r\n                onTravel: (currentPos) => {\r\n                    // Optional: trail effect during flight\r\n                    if (shotIndex === 0) { // Only show trail on first arrow to avoid spam\r\n                        this.createVisualEffect(currentPos, 'cast', { \r\n                            count: 1, \r\n                            scaleMultiplier: 0.5,\r\n                            heightOffset: 0 \r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            \r\n            this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);\r\n        } else {\r\n            // Fallback: direct damage if no projectile system\r\n            this.dealDamageWithEffects(casterEntity, targetId, this.arrowDamage, this.element, {\r\n                isArrow: true,\r\n                isMultishot: true,\r\n                shotIndex: shotIndex\r\n            });\r\n        }\r\n        \r\n    }\r\n    \r\n    // FIXED: Deterministic target selection\r\n    selectMultishotTargets(enemies) {\r\n        if (enemies.length === 0) return [];\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Take up to maxTargets, but prioritize by distance for tactical targeting\r\n        const casterPos = this.game.getComponent(this.getCasterFromContext(), this.componentTypes.POSITION);\r\n        if (!casterPos) {\r\n            // Fallback: just take first N enemies if no caster position\r\n            return sortedEnemies.slice(0, this.maxTargets);\r\n        }\r\n        \r\n        // Calculate distances and sort by distance (closest first), then by ID for tie-breaking\r\n        const enemiesWithDistance = sortedEnemies.map(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            let distance = Infinity;\r\n            \r\n            if (enemyPos) {\r\n                distance = Math.sqrt(\r\n                    Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                    Math.pow(enemyPos.z - casterPos.z, 2)\r\n                );\r\n            }\r\n            \r\n            return { enemyId, distance };\r\n        });\r\n        \r\n        // Sort by distance first, then by entity ID for deterministic tie-breaking\r\n        enemiesWithDistance.sort((a, b) => {\r\n            if (Math.abs(a.distance - b.distance) < 0.001) { // Nearly equal distances\r\n                return String(a.enemyId).localeCompare(String(b.enemyId));\r\n            }\r\n            return a.distance - b.distance;\r\n        });\r\n        \r\n        // Return up to maxTargets closest enemies\r\n        return enemiesWithDistance\r\n            .slice(0, this.maxTargets)\r\n            .map(item => item.enemyId);\r\n    }\r\n    \r\n    // Helper method to get caster in current context (if needed)\r\n    getCasterFromContext() {\r\n        // This is a fallback - in practice, the caster should be passed to selectMultishotTargets\r\n        // For now, we'll use a simple approach\r\n        return null; // Will trigger the simpler fallback logic\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MultiShotAbility.js",
        "fileName": "MultiShotAbility"
      },
      "PiercingShotAbility": {
        "script": "class PiercingShotAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'piercing_shot',\r\n            name: 'Piercing Shot',\r\n            description: 'Fire a bolt that pierces through multiple enemies',\r\n            cooldown: 6.0,\r\n            range: 200,\r\n            manaCost: 25,\r\n            targetType: 'line',\r\n            animation: 'attack',\r\n            priority: 6,\r\n            castTime: 1.5,\r\n            ...params\r\n        });\r\n        \r\n        this.piercingDamage = 45;\r\n        this.lineWidth = 20; // Width of the piercing line\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4682B4,\r\n                    colorRange: { start: 0x4682B4, end: 0x87CEEB },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            beam_charge: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x6495ED,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            piercing_beam: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xB0C4DE,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 2.5\r\n                }\r\n            },\r\n            impact: {\r\n                type: 'damage',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4169E1,\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Need at least one enemy in range to pierce\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterFacing = this.game.getComponent(casterEntity, this.componentTypes.FACING);\r\n        \r\n        if (!casterPos || !casterFacing) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Crossbow charges a piercing bolt...`);\r\n        \r\n        // Schedule the piercing shot after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.firePiercingShot(casterEntity, casterPos, casterFacing);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    firePiercingShot(casterEntity, casterPos, casterFacing) {\r\n        // Calculate piercing line end position\r\n        const endPos = this.calculateLineEndPosition(casterPos, casterFacing);\r\n        \r\n        // Create beam charging effect\r\n        this.createVisualEffect(casterPos, 'beam_charge');\r\n        \r\n        // Schedule visual beam effect slightly before damage\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createPiercingBeamEffect(casterPos, endPos);\r\n        }, 0.2, casterEntity);\r\n        \r\n        // Schedule damage application\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applyPiercingDamage(casterEntity, casterPos, endPos);\r\n        }, 0.3, casterEntity);\r\n    }\r\n    \r\n    createPiercingBeamEffect(startPos, endPos) {\r\n        // Create piercing beam visual effect\r\n        this.createVisualEffect(startPos, 'piercing_beam');\r\n        this.createVisualEffect(endPos, 'piercing_beam', { \r\n            count: 6, \r\n            scaleMultiplier: 1.5 \r\n        });\r\n        \r\n        // Create energy beam if effects system supports it\r\n        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {\r\n            this.game.effectsSystem.createEnergyBeam(\r\n                new THREE.Vector3(startPos.x, startPos.y + 15, startPos.z),\r\n                new THREE.Vector3(endPos.x, endPos.y + 15, endPos.z),\r\n                {\r\n                    style: { color: 0x4682B4, linewidth: 4 },\r\n                    animation: { duration: 800, flickerCount: 2 }\r\n                }\r\n            );\r\n        }\r\n    }\r\n    \r\n    applyPiercingDamage(casterEntity, startPos, endPos) {\r\n        // Get all enemies in range and filter those hit by the line\r\n        const enemies = this.getEnemiesInRange(casterEntity, this.range);\r\n        const hitEnemies = this.getEnemiesInLine(enemies, startPos, endPos);\r\n        \r\n        if (hitEnemies.length === 0) {\r\n            this.logAbilityUsage(casterEntity, `Piercing bolt finds no targets!`);\r\n            return;\r\n        }\r\n        \r\n        // Sort hit enemies by distance along the line for consistent damage application\r\n        const sortedHitEnemies = this.sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos);\r\n        \r\n        // Apply damage to each enemy in order\r\n        sortedHitEnemies.forEach((enemyData, index) => {\r\n            const { enemyId, position } = enemyData;\r\n            \r\n            // Apply piercing damage\r\n            this.dealDamageWithEffects(casterEntity, enemyId, this.piercingDamage, this.element, {\r\n                isPiercing: true,\r\n                piercingIndex: index,\r\n                totalPierced: sortedHitEnemies.length\r\n            });\r\n            \r\n            // Create impact effect at each enemy position\r\n            this.createVisualEffect(position, 'impact');\r\n            \r\n         \r\n        });\r\n        \r\n        // Screen effects for dramatic impact\r\n        if (this.game.effectsSystem && sortedHitEnemies.length > 1) {\r\n            this.game.effectsSystem.playScreenShake(0.4, 2);\r\n        }\r\n        \r\n        this.logAbilityUsage(casterEntity, \r\n            `Crossbow bolt pierces through ${sortedHitEnemies.length} enemies!`);\r\n    }\r\n    \r\n    // FIXED: Deterministic line end position calculation\r\n    calculateLineEndPosition(startPos, facing) {\r\n        return {\r\n            x: startPos.x + Math.cos(facing.angle) * this.range,\r\n            y: startPos.y,\r\n            z: startPos.z + Math.sin(facing.angle) * this.range\r\n        };\r\n    }\r\n    \r\n    // FIXED: Deterministic enemy filtering in line\r\n    getEnemiesInLine(enemies, startPos, endPos) {\r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        const hitEnemies = [];\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            if (this.isInLine(startPos, endPos, enemyPos, this.lineWidth)) {\r\n                hitEnemies.push({\r\n                    enemyId: enemyId,\r\n                    position: { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z }\r\n                });\r\n            }\r\n        });\r\n        \r\n        return hitEnemies;\r\n    }\r\n    \r\n    // FIXED: More precise and deterministic line-point distance calculation\r\n    isInLine(start, end, point, width) {\r\n        if (!point) return false;\r\n        \r\n        // Calculate line parameters more precisely\r\n        const lineLength = Math.sqrt(\r\n            Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2)\r\n        );\r\n        \r\n        if (lineLength < 0.001) return false; // Avoid division by zero\r\n        \r\n        // Calculate perpendicular distance from point to line\r\n        const A = end.z - start.z;\r\n        const B = start.x - end.x;\r\n        const C = end.x * start.z - start.x * end.z;\r\n        \r\n        const distance = Math.abs(A * point.x + B * point.z + C) / Math.sqrt(A * A + B * B);\r\n        \r\n        // Also check if point is within the line segment bounds\r\n        const dotProduct = (point.x - start.x) * (end.x - start.x) + (point.z - start.z) * (end.z - start.z);\r\n        const projectionRatio = dotProduct / (lineLength * lineLength);\r\n        \r\n        // Point must be within line width and within line segment bounds\r\n        return distance <= width && projectionRatio >= 0 && projectionRatio <= 1;\r\n    }\r\n    \r\n    // FIXED: Sort enemies by distance along line for consistent ordering\r\n    sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos) {\r\n        return hitEnemies.slice().sort((a, b) => {\r\n            // Calculate distance from start of line for each enemy\r\n            const distanceA = Math.sqrt(\r\n                Math.pow(a.position.x - startPos.x, 2) + \r\n                Math.pow(a.position.z - startPos.z, 2)\r\n            );\r\n            const distanceB = Math.sqrt(\r\n                Math.pow(b.position.x - startPos.x, 2) + \r\n                Math.pow(b.position.z - startPos.z, 2)\r\n            );\r\n            \r\n            // Sort by distance from caster, then by entity ID for tie-breaking\r\n            if (Math.abs(distanceA - distanceB) < 0.001) {\r\n                return String(a.enemyId).localeCompare(String(b.enemyId));\r\n            }\r\n            return distanceA - distanceB;\r\n        });\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PiercingShotAbility.js",
        "fileName": "PiercingShotAbility"
      },
      "ShadowStrikeAbility": {
        "script": "class ShadowStrikeAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'shadow_strike',\r\n            name: 'Shadow Strike',\r\n            description: 'Teleport behind an enemy and deal critical damage',\r\n            cooldown: 9.0,\r\n            range: 120,\r\n            manaCost: 30,\r\n            targetType: 'enemy',\r\n            animation: 'attack',\r\n            priority: 8,\r\n            castTime: 0.5,\r\n            ...params\r\n        });\r\n        this.backstabDamage = 65;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F2F2F,\r\n                    colorRange: { start: 0x2F2F2F, end: 0x000000 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            teleport: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            },\r\n            backstab: {\r\n                type: 'damage',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF0000,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // DESYNC SAFE: Select target deterministically (closest enemy)\r\n        const target = this.findClosestEnemy(casterEntity, enemies);\r\n        if (!target) return;\r\n        \r\n        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n        if (!targetPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Rogue strikes from the shadows!\");\r\n        \r\n        // DESYNC SAFE: Use scheduling system for teleport and attack\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performShadowStrike(casterEntity, target);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Find closest enemy deterministically\r\n    findClosestEnemy(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return closest;\r\n    }\r\n    \r\n    performShadowStrike(casterEntity, targetId) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!casterPos || !targetPos) return;\r\n        \r\n        // DESYNC SAFE: Calculate teleport position deterministically\r\n        const teleportPos = this.calculateTeleportPosition(targetPos);\r\n        \r\n        // Visual effect at original position before teleport\r\n        this.createVisualEffect(casterPos, 'teleport');\r\n        \r\n        // Teleport behind target\r\n        casterPos.x = teleportPos.x;\r\n        casterPos.z = teleportPos.z;\r\n        \r\n        // Visual effect at new position after teleport\r\n        this.createVisualEffect(teleportPos, 'teleport');\r\n        \r\n        // Deal critical backstab damage\r\n        this.dealDamageWithEffects(casterEntity, targetId, this.backstabDamage, 'physical', {\r\n            isCritical: true,\r\n            criticalMultiplier: 2.0,\r\n            isBackstab: true\r\n        });\r\n        \r\n        // Backstab effect\r\n        this.createVisualEffect(targetPos, 'backstab');\r\n        \r\n        // Screen effect for dramatic teleport\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.2, 1.5);\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Calculate teleport position deterministically\r\n    calculateTeleportPosition(targetPos) {\r\n        // Try positions behind the target in a deterministic order\r\n        const offsets = [\r\n            { x: -25, z: -25 }, // Behind and to the left\r\n            { x: -25, z: 0 },   // Directly behind\r\n            { x: -25, z: 25 },  // Behind and to the right\r\n            { x: 0, z: -25 },   // To the left\r\n            { x: 0, z: 25 },    // To the right\r\n        ];\r\n        \r\n        // Use the first valid position\r\n        for (const offset of offsets) {\r\n            const testPos = {\r\n                x: targetPos.x + offset.x,\r\n                y: targetPos.y,\r\n                z: targetPos.z + offset.z\r\n            };\r\n            \r\n            if (this.isValidTeleportPosition(testPos)) {\r\n                return testPos;\r\n            }\r\n        }\r\n        \r\n        // Fallback position if no valid position found\r\n        return {\r\n            x: targetPos.x - 25,\r\n            y: targetPos.y,\r\n            z: targetPos.z - 25\r\n        };\r\n    }\r\n    \r\n    isValidTeleportPosition(pos) {\r\n        // Basic validation - ensure position is within reasonable bounds\r\n        // This could be enhanced with collision detection if needed\r\n        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShadowStrikeAbility.js",
        "fileName": "ShadowStrikeAbility"
      },
      "SummonWolfAbility": {
        "script": "class SummonWolfAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'summon_wolf',\r\n            name: 'Summon Wolf',\r\n            description: 'Call forth a loyal wolf companion (max 1 per Beast Master)',\r\n            cooldown: 0.0,\r\n            range: 0,\r\n            manaCost: 50,\r\n            targetType: 'self',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        this.hasSummon = false;\r\n        this.summonId = '0_skeleton';\r\n        this.summonedWolfId = null; // Track the specific summoned wolf\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x228b22,\r\n                    colorRange: { start: 0x228b22, end: 0x90ee90 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            },\r\n            summon: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x32cd32,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if this Beast Master already has a summoned wolf that's still alive\r\n        if (this.summonedWolfId) {\r\n            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);\r\n            const wolfDeathState = this.game.getComponent(this.summonedWolfId, this.componentTypes.DEATH_STATE);\r\n            \r\n            // If wolf is dead or dying, reset our tracking\r\n            if (!wolfHealth || wolfHealth.current <= 0 || (wolfDeathState && wolfDeathState.isDying)) {\r\n                this.hasSummon = false;\r\n                this.summonedWolfId = null;\r\n            }\r\n        }\r\n        \r\n        return !this.hasSummon;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const team = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        if (!pos || !team) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Beast Master summons a faithful wolf!\");\r\n        \r\n        // DESYNC SAFE: Use scheduling system for summoning\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performSummon(casterEntity, pos, team);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performSummon(casterEntity, summonPos, team) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (!casterHealth || casterHealth.current <= 0) return;\r\n        \r\n        // DESYNC SAFE: Find deterministic summon position\r\n        const wolfPosition = this.findSummonPosition(summonPos);\r\n        \r\n        // Create wolf companion\r\n        const wolfId = this.createSummonedCreature(wolfPosition, this.summonId, team.team, casterEntity);\r\n        \r\n        if (wolfId) {\r\n            this.hasSummon = true;\r\n            this.summonedWolfId = wolfId;\r\n            \r\n            // Summon effect at wolf position\r\n            this.createVisualEffect(wolfPosition, 'summon');\r\n            \r\n            // Screen effect for dramatic summoning\r\n            if (this.game.effectsSystem) {\r\n                this.game.effectsSystem.playScreenShake(0.15, 1);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Find a valid summon position deterministically\r\n    findSummonPosition(basePos) {\r\n        // Try positions in a deterministic pattern around the caster\r\n        const offsets = [\r\n            { x: 30, z: 0 },    // Right\r\n            { x: -30, z: 0 },   // Left\r\n            { x: 0, z: 30 },    // Forward\r\n            { x: 0, z: -30 },   // Back\r\n            { x: 21, z: 21 },   // Diagonal positions\r\n            { x: -21, z: 21 },\r\n            { x: 21, z: -21 },\r\n            { x: -21, z: -21 }\r\n        ];\r\n        \r\n        // Try each position in order until we find a valid one\r\n        for (const offset of offsets) {\r\n            const testPos = {\r\n                x: basePos.x + offset.x,\r\n                y: basePos.y,\r\n                z: basePos.z + offset.z\r\n            };\r\n            \r\n            // Simple position validation (could be enhanced with collision checking)\r\n            if (this.isValidSummonPosition(testPos)) {\r\n                return testPos;\r\n            }\r\n        }\r\n        \r\n        // Fallback to right side of caster if no valid position found\r\n        return {\r\n            x: basePos.x + 30,\r\n            y: basePos.y,\r\n            z: basePos.z\r\n        };\r\n    }\r\n    \r\n    isValidSummonPosition(pos) {\r\n        // Basic validation - ensure position is within reasonable bounds\r\n        // This could be enhanced with collision detection if needed\r\n        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;\r\n    }\r\n    \r\n    createSummonedCreature(pos, unitDefId, team, summoner) {\r\n        try {\r\n            const creatureId = this.game.createEntity();\r\n            const components = this.game.componentManager.getComponents();\r\n            const componentTypes = this.game.componentManager.getComponentTypes();\r\n            \r\n            // Get unit definition for stats (with fallbacks)\r\n            const collections = this.game.getCollections();\r\n            const unitDef = collections?.units?.[unitDefId] || {\r\n                hp: 60,\r\n                damage: 25,\r\n                range: 30,\r\n                attackSpeed: 1.2,\r\n                speed: 40,\r\n                size: 20\r\n            };\r\n            \r\n            // Add all standard unit components\r\n            this.game.addComponent(creatureId, componentTypes.POSITION, \r\n                components.Position(pos.x, pos.y, pos.z));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.VELOCITY, \r\n                components.Velocity(0, 0, 0, (unitDef.speed) * 20));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.RENDERABLE, \r\n                components.Renderable(\"units\", unitDefId));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.HEALTH, \r\n                components.Health(unitDef.hp));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.COMBAT, \r\n                components.Combat(unitDef.damage, unitDef.range, unitDef.attackSpeed));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.COLLISION, \r\n                components.Collision(unitDef.size, unitDef.height));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.TEAM, \r\n                components.Team(team));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.UNIT_TYPE, \r\n                components.UnitType(unitDefId, 'Summoned Wolf', 0));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.AI_STATE, \r\n                components.AIState('idle'));\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.ANIMATION, \r\n                components.Animation());\r\n            \r\n            this.game.addComponent(creatureId, componentTypes.FACING, \r\n                components.Facing(0));\r\n            \r\n            // DESYNC SAFE: Use game time for summoned component\r\n            this.game.addComponent(creatureId, componentTypes.SUMMONED, \r\n                components.Summoned(summoner, unitDefId, null, this.game.state.now || 0));\r\n            \r\n            return creatureId;\r\n        } catch (error) {\r\n            console.error('Failed to create summoned creature:', error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    // Helper method to clean up when the summoner dies\r\n    onSummonerDeath(summonerId) {\r\n        if (this.summonedWolfId && this.game.hasComponent(this.summonedWolfId, this.componentTypes.HEALTH)) {\r\n            // Kill the summoned wolf when summoner dies\r\n            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);\r\n            if (wolfHealth && wolfHealth.current > 0) {\r\n                wolfHealth.current = 0;\r\n                \r\n                // Trigger death system for the wolf\r\n                if (this.game.deathSystem) {\r\n                    this.game.deathSystem.handleEntityDeath(this.summonedWolfId);\r\n                }\r\n            }\r\n        }\r\n        \r\n        this.hasSummon = false;\r\n        this.summonedWolfId = null;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SummonWolfAbility.js",
        "fileName": "SummonWolfAbility"
      },
      "SmiteAbility": {
        "script": "class SmiteAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'smite',\r\n            name: 'Divine Smite',\r\n            description: 'Calls down divine wrath upon the strongest enemy',\r\n            cooldown: 6.0,\r\n            range: 400,\r\n            manaCost: 65,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 9,\r\n            castTime: 1.8,\r\n            autoTrigger: 'strong_enemy',\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 80;\r\n        this.bonusDamageVsUndead = 2.0; // Double damage vs undead\r\n        this.pillarDelay = 0.5; // Time between pillar and damage\r\n        this.element = 'divine';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFD700,\r\n                    colorRange: { start: 0xFFD700, end: 0xFFFACD },\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            },\r\n            smite: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFF8DC,\r\n                    scaleMultiplier: 3.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            pillar: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xF0E68C,\r\n                    scaleMultiplier: 4.0,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            divine_judgment: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFFFE0,\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 1;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Target the strongest enemy (highest health) deterministically\r\n        const target = this.findHighestHealthEnemyDeterministic(enemies);\r\n        if (!target) return null;\r\n        \r\n        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n        if (!targetPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Divine judgment descends from the heavens!`);\r\n        \r\n        // Schedule the divine smite after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performDivineSmite(casterEntity, target, targetPos);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performDivineSmite(casterEntity, targetId, originalTargetPos) {\r\n        // Get current target position (target may have moved)\r\n        const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const targetPos = currentTargetPos || originalTargetPos; // Fallback to original position\r\n        \r\n        // Create pillar of light effect\r\n        this.createVisualEffect(targetPos, 'pillar');\r\n        \r\n        // Create divine judgment aura effect\r\n        this.createVisualEffect(targetPos, 'divine_judgment');\r\n        \r\n        // Screen flash and shake\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenFlash('#FFD700', 0.5);\r\n            this.game.effectsSystem.playScreenShake(0.3, 3);\r\n        }\r\n        \r\n        this.logAbilityUsage(casterEntity, `A pillar of divine light appears!`);\r\n        \r\n        // Schedule the actual damage after pillar effect\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applySmiteDamage(casterEntity, targetId, targetPos);\r\n        }, this.pillarDelay, targetId);\r\n    }\r\n    \r\n    applySmiteDamage(casterEntity, targetId, targetPos) {\r\n        // Validate target still exists\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        if (!targetHealth || targetHealth.current <= 0) {\r\n            this.logAbilityUsage(casterEntity, `Divine judgment finds no target!`);\r\n            return;\r\n        }\r\n        \r\n        // Calculate damage (bonus vs undead)\r\n        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);\r\n        let damage = this.damage;\r\n        let isUndeadTarget = false;\r\n        \r\n        if (targetUnitType && (\r\n            targetUnitType.title.includes('undead') || \r\n            targetUnitType.title.includes('skeleton') ||\r\n            targetUnitType.title.includes('zombie') ||\r\n            targetUnitType.id.includes('undead')\r\n        )) {\r\n            damage = Math.floor(damage * this.bonusDamageVsUndead);\r\n            isUndeadTarget = true;\r\n        }\r\n        \r\n        // Apply divine damage\r\n        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {\r\n            isSmite: true,\r\n            isCritical: true,\r\n            isAntiUndead: isUndeadTarget,\r\n            criticalMultiplier: 1.5\r\n        });\r\n        \r\n        // Create smite impact effect\r\n        this.createVisualEffect(targetPos, 'smite');\r\n      \r\n    \r\n    }\r\n    \r\n    // FIXED: Deterministic highest health enemy selection\r\n    findHighestHealthEnemyDeterministic(enemies) {\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let strongest = null;\r\n        let highestHealth = 0;\r\n        \r\n        // Process enemies in deterministic order\r\n        sortedEnemies.forEach(enemyId => {\r\n            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            if (!health) return;\r\n            \r\n            // Use >= for consistent tie-breaking (first in sorted order wins when health is equal)\r\n            if (health.current >= highestHealth) {\r\n                highestHealth = health.current;\r\n                strongest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return strongest;\r\n    }\r\n    \r\n    // Helper method to check if target is undead (for potential future use)\r\n    isUndeadTarget(targetId) {\r\n        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);\r\n        if (!targetUnitType) return false;\r\n        \r\n        return targetUnitType.title.includes('undead') || \r\n               targetUnitType.title.includes('skeleton') ||\r\n               targetUnitType.title.includes('zombie') ||\r\n               targetUnitType.id.includes('undead');\r\n    }\r\n    \r\n    // Helper method to get effective damage against target\r\n    getEffectiveDamage(targetId) {\r\n        let damage = this.damage;\r\n        \r\n        if (this.isUndeadTarget(targetId)) {\r\n            damage = Math.floor(damage * this.bonusDamageVsUndead);\r\n        }\r\n        \r\n        return damage;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SmiteAbility.js",
        "fileName": "SmiteAbility"
      },
      "WindShieldAbility": {
        "script": "class WindShieldAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'wind_shield',\r\n            name: 'Wind Shield',\r\n            description: 'Creates protective wind barriers that deflect projectiles',\r\n            cooldown: 8.0,\r\n            range: 200,\r\n            manaCost: 60,\r\n            targetType: 'defensive',\r\n            animation: 'cast',\r\n            priority: 4,\r\n            castTime: 1.2,\r\n            autoTrigger: 'projectiles_incoming',\r\n            ...params\r\n        });\r\n        \r\n        this.shieldDuration = 15.0;\r\n        this.deflectionChance = 0.7; // 70% chance to deflect projectiles\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 1,\r\n                    color: 0xE0FFFF,\r\n                    colorRange: { start: 0xE0FFFF, end: 0x87CEEB },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.5\r\n                }\r\n            },\r\n            shield: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 1,\r\n                    color: 0xAFEEEE,\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        // Use when there are allies to protect and enemies with projectiles nearby\r\n        const enemies = this.getEnemiesInRange(casterEntity, 300);\r\n        return allies.length >= 1 && enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Protective winds swirl around allies!`);\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createWindShields(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createWindShields(casterEntity) {\r\n        // DESYNC SAFE: Get and sort allies deterministically\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        sortedAllies.forEach(allyId => {\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            if (!allyPos) return;\r\n            // Shield effect\r\n            this.createVisualEffect(allyPos, 'shield');            \r\n            \r\n            // DESYNC SAFE: Add shield component using scheduling system for duration\r\n            const Components = this.game.componentManager.getComponents();\r\n            this.game.addComponent(allyId, this.componentTypes.BUFF, \r\n                Components.Buff('wind_shield', { \r\n                    deflectionChance: this.deflectionChance,\r\n                    projectileReflection: true\r\n                }, this.game.state.now + this.shieldDuration, false, 1, this.game.state.now));\r\n            \r\n            // DESYNC SAFE: Schedule shield removal\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {\r\n                    const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n                    if (buff && buff.buffType === 'wind_shield') {\r\n                        this.game.removeComponent(allyId, this.componentTypes.BUFF);\r\n                        \r\n                        // Visual effect when shield expires\r\n                        const currentPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n                        if (currentPos) {\r\n                            this.createVisualEffect(currentPos, 'shield', { \r\n                                count: 3, \r\n                                scaleMultiplier: 0.5,\r\n                                color: 0x87CEEB \r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }, this.shieldDuration, allyId);\r\n        });\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/WindShieldAbility.js",
        "fileName": "WindShieldAbility"
      },
      "BurningAuraAbility": {
        "script": "class BurningAuraAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'burning_aura',\r\n            name: 'Burning Aura',\r\n            description: 'Emanate heat that burns nearby enemies',\r\n            cooldown: 0,\r\n            range: 100,\r\n            manaCost: 0,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 0,\r\n            ...params\r\n        });\r\n        this.drainPerSecond = 8;\r\n        this.duration = 12.0; // 12 seconds instead of 1200 seconds\r\n        this.tickInterval = 1.0; // 1 second between ticks\r\n        this.hasActiveAura = false;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'fire',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4B0082,\r\n                    colorRange: { start: 0x4B0082, end: 0x000000 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            burning: {\r\n                type: 'fire',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            empowerment: {\r\n                type: 'fire',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Only allow one active aura per caster\r\n        return !this.hasActiveAura;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        this.createVisualEffect(pos, 'cast');\r\n        \r\n        // Mark aura as active\r\n        this.hasActiveAura = true;\r\n        \r\n        // DESYNC SAFE: Schedule all aura ticks using the scheduling system\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {\r\n            const tickDelay = this.tickInterval * tickIndex;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.executeAuraTick(casterEntity, tickIndex, totalTicks);\r\n            }, tickDelay, casterEntity);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule aura cleanup\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.hasActiveAura = false;\r\n        }, this.duration, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Execute a single aura tick deterministically\r\n    executeAuraTick(casterEntity, tickIndex, totalTicks) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {\r\n            // Caster is dead, end the aura early\r\n            this.hasActiveAura = false;\r\n            return;\r\n        }\r\n        \r\n        // DESYNC SAFE: Get enemies and allies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        \r\n        // Sort for consistent processing order\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Process enemies - burn their health\r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            \r\n            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.range) {\r\n                // Apply burn damage\r\n                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'fire', {\r\n                    tickIndex: tickIndex\r\n                });\r\n                \r\n                // Visual corruption effect\r\n                this.createVisualEffect(enemyPos, 'burning', { heightOffset: 10 });\r\n            }\r\n        });\r\n        // Additional visual effects every few ticks\r\n        if (tickIndex % 3 === 0) {\r\n            this.createVisualEffect(casterPos, 'burning', { \r\n                count: 6, \r\n                scaleMultiplier: 2.5,\r\n                heightOffset: 15 \r\n            });\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BurningAuraAbility.js",
        "fileName": "BurningAuraAbility"
      },
      "CorruptingAuraAbility": {
        "script": "class CorruptingAuraAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'corrupting_aura',\r\n            name: 'Corrupting Aura',\r\n            description: 'Emanate dark energy that drains enemies and empowers undead (does not stack)',\r\n            cooldown: 0,\r\n            range: 100,\r\n            manaCost: 0,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 0,\r\n            ...params\r\n        });\r\n        this.drainPerSecond = 8;\r\n        this.duration = 12.0; // 12 seconds instead of 1200 seconds\r\n        this.tickInterval = 1.0; // 1 second between ticks\r\n        this.hasActiveAura = false;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4B0082,\r\n                    colorRange: { start: 0x4B0082, end: 0x000000 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            corruption: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            empowerment: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Only allow one active aura per caster\r\n        return !this.hasActiveAura;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Oathbreaker spreads corrupting darkness!\");\r\n        \r\n        // Mark aura as active\r\n        this.hasActiveAura = true;\r\n        \r\n        // DESYNC SAFE: Schedule all aura ticks using the scheduling system\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {\r\n            const tickDelay = this.tickInterval * tickIndex;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.executeAuraTick(casterEntity, tickIndex, totalTicks);\r\n            }, tickDelay, casterEntity);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule aura cleanup\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.hasActiveAura = false;\r\n        }, this.duration, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Execute a single aura tick deterministically\r\n    executeAuraTick(casterEntity, tickIndex, totalTicks) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {\r\n            // Caster is dead, end the aura early\r\n            this.hasActiveAura = false;\r\n            return;\r\n        }\r\n        \r\n        // DESYNC SAFE: Get enemies and allies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        \r\n        // Sort for consistent processing order\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Process enemies - drain their health\r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            \r\n            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.range) {\r\n                // Apply drain damage\r\n                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'divine', {\r\n                    isCorruption: true,\r\n                    tickIndex: tickIndex\r\n                });\r\n                \r\n                // Visual corruption effect\r\n                this.createVisualEffect(enemyPos, 'corruption', { heightOffset: 10 });\r\n            }\r\n        });\r\n        \r\n        // Process allies - empower undead\r\n        sortedAllies.forEach(allyId => {\r\n            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            \r\n            if (!unitType || !allyPos) return;\r\n            \r\n            // Check if this is an undead unit\r\n            if (unitType.id === 'skeleton' || unitType.title.includes('undead') || unitType.title.includes('Skeleton')) {\r\n                const distance = Math.sqrt(\r\n                    Math.pow(allyPos.x - casterPos.x, 2) + \r\n                    Math.pow(allyPos.z - casterPos.z, 2)\r\n                );\r\n                \r\n                if (distance <= this.range) {\r\n                    // Check if already has empowerment buff\r\n                    const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n                    \r\n                    if (!existingBuff || existingBuff.buffType !== 'dark_empowerment') {\r\n                        const Components = this.game.componentManager.getComponents();\r\n                        this.game.addComponent(allyId, this.componentTypes.BUFF, \r\n                            Components.Buff('dark_empowerment', { \r\n                                damageMultiplier: 1.3,\r\n                                attackSpeedMultiplier: 1.2\r\n                            }, this.game.state.now + 3.0, false, 1, this.game.state.now));\r\n                        \r\n                        // Visual empowerment effect\r\n                        this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Additional visual effects every few ticks\r\n        if (tickIndex % 3 === 0) {\r\n            this.createVisualEffect(casterPos, 'corruption', { \r\n                count: 6, \r\n                scaleMultiplier: 2.5,\r\n                heightOffset: 15 \r\n            });\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CorruptingAuraAbility.js",
        "fileName": "CorruptingAuraAbility"
      },
      "EnchantWeaponAbility": {
        "script": "class EnchantWeaponAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'enchant_weapon',\r\n            name: 'Enchant Weapon',\r\n            description: 'Enchant ally weapons with elemental damage (does not stack, refreshes duration)',\r\n            cooldown: 12.0,\r\n            range: 100,\r\n            manaCost: 35,\r\n            targetType: 'allies',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 1.5,\r\n            ...params\r\n        });\r\n        \r\n        this.elementalDamage = 15;\r\n        this.duration = 30.0; // 30 seconds\r\n        this.availableElements = ['fire', 'cold', 'lightning'];\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFD700,\r\n                    colorRange: { start: 0xFFD700, end: 0xFFA500 },\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            enchant_fire: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF4500,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            },\r\n            enchant_cold: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x00BFFF,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            },\r\n            enchant_lightning: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFFF00,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        // Only use if there are allies to enchant (excluding self)\r\n        return allies.length >= 1;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Enchanter begins weaving magical enhancements!`);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for enchantment application\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applyWeaponEnchantments(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    applyWeaponEnchantments(casterEntity) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort allies deterministically\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let enchantedCount = 0;\r\n        \r\n        sortedAllies.forEach((allyId, index) => {\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            \r\n            // Only enchant living allies\r\n            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;\r\n            \r\n            // DESYNC SAFE: Check if already enchanted - don't stack enchantments\r\n            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n            \r\n            // DESYNC SAFE: Select element deterministically based on ally index and game time\r\n            const selectedElement = this.selectDeterministicElement(allyId, index);\r\n            \r\n            if (existingBuff && existingBuff.buffType === 'enchant_weapon') {\r\n                // DESYNC SAFE: Refresh duration and update element\r\n                existingBuff.endTime = this.game.state.now + this.duration;\r\n                existingBuff.appliedTime = this.game.state.now;\r\n                existingBuff.modifiers.weaponElement = selectedElement;\r\n            } else {\r\n                // Apply new weapon enchantment\r\n                const Components = this.game.componentManager.getComponents();\r\n                this.game.addComponent(allyId, this.componentTypes.BUFF, \r\n                    Components.Buff('enchant_weapon', { \r\n                        weaponElement: selectedElement,\r\n                        elementalDamage: this.elementalDamage,\r\n                        glowing: true\r\n                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));\r\n                \r\n                // DESYNC SAFE: Schedule enchantment removal\r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    this.removeEnchantment(allyId);\r\n                }, this.duration, allyId);\r\n            }\r\n            \r\n            // Visual enchantment effect based on element\r\n            this.createVisualEffect(allyPos, `enchant_${selectedElement}`);\r\n            \r\n            enchantedCount++;\r\n        });\r\n        \r\n        // Screen effect for successful enchantment\r\n        if (this.game.effectsSystem && enchantedCount > 0) {\r\n            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);\r\n        }\r\n        \r\n     \r\n    }\r\n    \r\n    // DESYNC SAFE: Select element deterministically instead of randomly\r\n    selectDeterministicElement(allyId, allyIndex) {\r\n        // Create a deterministic \"random\" value based on ally ID, game time, and index\r\n        const seed = parseInt(allyId) + Math.floor(this.game.state.now * 100) + allyIndex;\r\n        const pseudoRandom = (seed * 9301 + 49297) % 233280; // Simple PRNG\r\n        const elementIndex = Math.floor((pseudoRandom / 233280) * this.availableElements.length);\r\n        \r\n        return this.availableElements[elementIndex];\r\n    }\r\n    \r\n    // Alternative deterministic selection method (cycle through elements)\r\n    selectCyclicElement(allyIndex) {\r\n        return this.availableElements[allyIndex % this.availableElements.length];\r\n    }\r\n    \r\n    // DESYNC SAFE: Remove enchantment effect\r\n    removeEnchantment(allyId) {\r\n        // Check if ally still exists and has the enchantment buff\r\n        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'enchant_weapon') {\r\n                const element = buff.modifiers.weaponElement || 'fire';\r\n                \r\n                this.game.removeComponent(allyId, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when enchantment expires\r\n                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n                if (allyPos) {\r\n                    this.createVisualEffect(allyPos, `enchant_${element}`, { \r\n                        count: 3, \r\n                        scaleMultiplier: 0.6,\r\n                        speedMultiplier: 0.8\r\n                    });\r\n                }\r\n                \r\n              \r\n            }\r\n        }\r\n    }\r\n    \r\n    // Helper method to get enchantment color for UI/effects\r\n    getElementColor(element) {\r\n        switch (element) {\r\n            case 'fire': return 0xFF4500;\r\n            case 'cold': return 0x00BFFF;\r\n            case 'lightning': return 0xFFFF00;\r\n            default: return 0xFFD700;\r\n        }\r\n    }\r\n    \r\n    // Helper method to get element damage type for combat system integration\r\n    getElementDamageType(element) {\r\n        switch (element) {\r\n            case 'fire': return 'fire';\r\n            case 'cold': return 'cold';\r\n            case 'lightning': return 'lightning';\r\n            default: return 'magic';\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/EnchantWeaponAbility.js",
        "fileName": "EnchantWeaponAbility"
      },
      "InfernoAbility": {
        "script": "class InfernoAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'inferno',\r\n            name: 'Inferno',\r\n            description: 'Creates a blazing inferno that damages all enemies in a large area',\r\n            cooldown: 8.0,\r\n            range: 200,\r\n            manaCost: 80,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 9,\r\n            castTime: 2.0,\r\n            autoTrigger: 'multiple_enemies',\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 35;\r\n        this.infernoRadius = 120;\r\n        this.duration = 4.0;\r\n        this.tickInterval = 0.5;\r\n        this.element = 'fire';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff2200,\r\n                    colorRange: { start: 0xff2200, end: 0xffaa00 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            inferno: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff4400,\r\n                    scaleMultiplier: 3.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            tick: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff3300,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.6\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Find best cluster position deterministically\r\n        const clusterPos = this.findBestClusterPosition(enemies, 2);\r\n        const infernoCenter = clusterPos || this.getDefaultTargetPosition(casterPos, enemies);\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `The battlefield prepares for an unstoppable inferno!`);\r\n        \r\n        // Schedule the inferno to start after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createInferno(casterEntity, infernoCenter);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createInferno(casterEntity, centerPos) {\r\n        // Create initial inferno effect\r\n        this.createVisualEffect(centerPos, 'inferno');\r\n        \r\n        // Screen effect\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenFlash('#ff3300', 0.4);\r\n        }\r\n        \r\n        this.logAbilityUsage(casterEntity, `The battlefield erupts in an unstoppable inferno!`);\r\n        \r\n        // Schedule damage ticks deterministically\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickNumber = 0; tickNumber < totalTicks; tickNumber++) {\r\n            const tickDelay = tickNumber * this.tickInterval;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks);\r\n            }, tickDelay, casterEntity);\r\n        }\r\n    }\r\n    \r\n    performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks) {\r\n        // Apply damage to all enemies in radius\r\n        if (this.game.damageSystem) {\r\n            const results = this.game.damageSystem.applySplashDamage(\r\n                casterEntity,\r\n                centerPos,\r\n                this.damage,\r\n                this.element,\r\n                this.infernoRadius,\r\n                { allowFriendlyFire: false, isSpell: true }\r\n            );\r\n            \r\n            // Log damage on first and last ticks\r\n            if (tickNumber === 0 && results.length > 0) {\r\n                this.logAbilityUsage(casterEntity, `Inferno burns ${results.length} enemies!`);\r\n            }\r\n        }\r\n        \r\n        // Visual tick effect (except on last tick to avoid overlap)\r\n        if (tickNumber < totalTicks - 1) {\r\n            this.createVisualEffect(centerPos, 'tick');\r\n        }\r\n    }\r\n    \r\n    // FIXED: Deterministic cluster position finding\r\n    findBestClusterPosition(enemies, minTargets) {\r\n        if (enemies.length < minTargets) return null;\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let bestPosition = null;\r\n        let maxTargetsHit = 0;\r\n        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance\r\n        \r\n        // Check each enemy position as potential cluster center\r\n        sortedEnemies.forEach(potentialCenter => {\r\n            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);\r\n            if (!centerPos) return;\r\n            \r\n            let targetsInRange = 0;\r\n            let totalDistance = 0;\r\n            \r\n            // Count enemies within inferno radius of this position\r\n            sortedEnemies.forEach(enemyId => {\r\n                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (!enemyPos) return;\r\n                \r\n                const distance = Math.sqrt(\r\n                    Math.pow(enemyPos.x - centerPos.x, 2) + \r\n                    Math.pow(enemyPos.z - centerPos.z, 2)\r\n                );\r\n                \r\n                if (distance <= this.infernoRadius) {\r\n                    targetsInRange++;\r\n                    totalDistance += distance;\r\n                }\r\n            });\r\n            \r\n            // Only consider positions that hit minimum targets\r\n            if (targetsInRange >= minTargets) {\r\n                // Calculate score: prioritize more targets, then lower total distance for tie-breaking\r\n                const score = (targetsInRange * 1000) - totalDistance;\r\n                \r\n                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)\r\n                if (targetsInRange > maxTargetsHit || \r\n                    (targetsInRange === maxTargetsHit && score >= bestScore)) {\r\n                    maxTargetsHit = targetsInRange;\r\n                    bestScore = score;\r\n                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };\r\n                }\r\n            }\r\n        });\r\n        \r\n        return bestPosition;\r\n    }\r\n    \r\n    // FIXED: Deterministic fallback position when no cluster is found\r\n    getDefaultTargetPosition(casterPos, enemies) {\r\n        if (enemies.length === 0) return casterPos;\r\n        \r\n        // Sort enemies deterministically and pick the first one\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        const firstEnemy = sortedEnemies[0];\r\n        \r\n        const enemyPos = this.game.getComponent(firstEnemy, this.componentTypes.POSITION);\r\n        return enemyPos ? { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z } : casterPos;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/InfernoAbility.js",
        "fileName": "InfernoAbility"
      },
      "MirrorImagesAbility": {
        "script": "class MirrorImagesAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'mirror_images',\r\n            name: 'Mirror Images',\r\n            description: 'Creates 2 weaker illusions of self',\r\n            cooldown: 10.0,\r\n            range: 0, // Self-target\r\n            manaCost: 0,\r\n            targetType: 'self',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 1.5,\r\n            autoTrigger: 'low_health',\r\n            ...params\r\n        });\r\n        \r\n        this.imageCount = 2;\r\n        this.imageDuration = 5.0;\r\n        this.imageHealthRatio = 0.4; // 40% of original health\r\n        this.imageDamageRatio = 0.6; // 60% of original damage\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4169E1,\r\n                    colorRange: { start: 0x4169E1, end: 0x87CEEB },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            mirror: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x6495ED,\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            illusion: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xB0C4DE,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Use when low on health or facing multiple enemies\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (casterHealth && casterHealth.current < casterHealth.max * 0.5) {\r\n            return true;\r\n        }\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity, 150);\r\n        return enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Reality fractures as mirror images appear!`);\r\n        \r\n        // Schedule mirror image creation after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createMirrorImages(casterEntity, casterPos);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createMirrorImages(casterEntity, casterPos) {\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);\r\n        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterCollision = this.game.getComponent(casterEntity, this.componentTypes.COLLISION);\r\n        const casterVelocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);\r\n        \r\n        if (!casterTeam || !casterUnitType || !casterCombat || !casterHealth) return;\r\n        \r\n        // Mirror effect at caster\r\n        this.createVisualEffect(casterPos, 'mirror');\r\n        \r\n        const createdImages = [];\r\n        \r\n        // Create images at deterministic positions\r\n        for (let i = 0; i < this.imageCount; i++) {\r\n            const imagePos = this.getDeterministicImagePosition(casterPos, i);\r\n            \r\n            const imageId = this.createMirrorImage(\r\n                casterEntity, imagePos, casterTeam, casterUnitType, \r\n                casterCombat, casterHealth, casterCollision, casterVelocity\r\n            );\r\n            \r\n            if (imageId !== null) {\r\n                createdImages.push(imageId);\r\n                // Illusion creation effect\r\n                this.createVisualEffect(imagePos, 'illusion');\r\n                \r\n                // Schedule image removal deterministically\r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    this.removeMirrorImage(imageId);\r\n                }, this.imageDuration, imageId);\r\n            }\r\n        }\r\n        \r\n    }\r\n    \r\n    // FIXED: Deterministic positioning algorithm\r\n    getDeterministicImagePosition(casterPos, imageIndex) {\r\n        // Use predefined positions instead of trigonometry for determinism\r\n        const positions = [\r\n            { offsetX: -35, offsetZ: 25 },   // Left-back\r\n            { offsetX: 35, offsetZ: 25 }     // Right-back\r\n        ];\r\n        \r\n        const offset = positions[imageIndex % positions.length];\r\n        \r\n        return {\r\n            x: casterPos.x + offset.offsetX,\r\n            y: casterPos.y,\r\n            z: casterPos.z + offset.offsetZ\r\n        };\r\n    }\r\n    \r\n    createMirrorImage(originalId, imagePos, team, unitType, combat, health, collision, velocity) {\r\n        // Use deterministic entity creation if available, otherwise use standard method\r\n        const imageId = this.game.createEntity ? this.game.createEntity() : this.generateDeterministicId(originalId);\r\n        \r\n        if (imageId === null || imageId === undefined) return null;\r\n        \r\n        const components = this.game.componentManager.getComponents();\r\n        \r\n        try {\r\n            // Add components in deterministic order (alphabetical by component type)\r\n            this.game.addComponent(imageId, this.componentTypes.AI_STATE, \r\n                components.AIState('idle'));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.ANIMATION, \r\n                components.Animation());\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.COLLISION, \r\n                components.Collision(collision?.radius, collision.height));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.COMBAT, \r\n                components.Combat(\r\n                    Math.floor(combat.damage * this.imageDamageRatio),\r\n                    combat.range,\r\n                    combat.attackSpeed,\r\n                    combat.projectile,\r\n                    0,\r\n                    combat.element || 'physical',\r\n                    Math.floor((combat.armor || 0) * 0.5), // Half armor\r\n                    combat.fireResistance || 0,\r\n                    combat.coldResistance || 0,\r\n                    combat.lightningResistance || 0\r\n                ));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.EQUIPMENT, \r\n                components.Equipment());\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.FACING, \r\n                components.Facing(0));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.HEALTH, \r\n                components.Health(Math.floor(health.max * this.imageHealthRatio)));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.MIRROR_IMAGE, \r\n                components.MirrorImage(originalId, true, this.game.state.now || 0));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.POSITION, \r\n                components.Position(imagePos.x, imagePos.y, imagePos.z));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.RENDERABLE, \r\n                components.Renderable(\"units\", unitType.id || unitType.title));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.TEAM, \r\n                components.Team(team.team));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.UNIT_TYPE, \r\n                components.UnitType(\r\n                    unitType.id || unitType.title,\r\n                    `Mirror Image`,\r\n                    0 // No value - they're illusions\r\n                ));\r\n                \r\n            this.game.addComponent(imageId, this.componentTypes.VELOCITY, \r\n                components.Velocity(0, 0, 0, velocity?.maxSpeed || 40));\r\n            \r\n            return imageId;\r\n            \r\n        } catch (error) {\r\n            console.error(`Failed to create mirror image:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    // FIXED: Deterministic removal instead of lifetime system\r\n    removeMirrorImage(imageId) {\r\n        if (!this.game.hasEntity || !this.game.hasEntity(imageId)) return;\r\n        \r\n        const imagePos = this.game.getComponent(imageId, this.componentTypes.POSITION);\r\n        \r\n        // Create disappearance effect\r\n        if (imagePos) {\r\n            this.createVisualEffect(imagePos, 'illusion');\r\n        }\r\n        \r\n        // Remove the entity\r\n        if (this.game.removeEntity) {\r\n            this.game.removeEntity(imageId);\r\n        } else if (this.game.destroyEntity) {\r\n            this.game.destroyEntity(imageId);\r\n        }\r\n       \r\n    }\r\n    \r\n    // Fallback method for deterministic ID generation (if needed)\r\n    generateDeterministicId(originalId) {\r\n        // This is a fallback - ideally the game should provide deterministic entity creation\r\n        const timestamp = this.game.state.now || this.game.state.now || 0;\r\n        return `mirror_${originalId}_${Math.floor(timestamp * 1000)}`;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MirrorImagesAbility.js",
        "fileName": "MirrorImagesAbility"
      },
      "RageAbility": {
        "script": "class RageAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'raging_strike',\r\n            name: 'Raging Strike',\r\n            description: 'Unleash primal fury with increased damage and attack speed',\r\n            cooldown: 5.0,\r\n            range: 0, // Self-buff\r\n            manaCost: 20,\r\n            targetType: 'self',\r\n            animation: 'attack',\r\n            priority: 6,\r\n            castTime: 0.8,\r\n            ...params\r\n        });\r\n        \r\n        this.rageDuration = 8.0;\r\n        this.damageMultiplier = 1.5;\r\n        this.attackSpeedMultiplier = 1.3;\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: { \r\n                    count: 3, \r\n                    color: 0xff4444, \r\n                    colorRange: { start: 0xff4444, end: 0xff8800 },\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            rage: {\r\n                type: 'magic',\r\n                options: { \r\n                    count: 3, \r\n                    color: 0xff0000, \r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            fury: {\r\n                type: 'magic',\r\n                options: { \r\n                    count: 3, \r\n                    color: 0xcc0000, \r\n                    scaleMultiplier: 2.2,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if there are enemies nearby to rage against\r\n        const enemies = this.getEnemiesInRange(casterEntity, 100);\r\n        if (enemies.length === 0) return false;\r\n        \r\n        // Don't stack rage buffs - check if already raged\r\n        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n        if (existingBuff && existingBuff.buffType === 'rage') return false;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Primal fury begins to build...`);\r\n        \r\n        // Schedule the rage activation after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.activateRage(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    activateRage(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Create dramatic rage effects\r\n        this.createVisualEffect(casterPos, 'rage');\r\n        \r\n        // Schedule a secondary fury effect for visual impact\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            if (this.game.hasComponent && this.game.hasComponent(casterEntity, this.componentTypes.POSITION)) {\r\n                const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n                if (pos) {\r\n                    this.createVisualEffect(pos, 'fury');\r\n                }\r\n            }\r\n        }, 0.5, casterEntity);\r\n        \r\n        // Apply rage buff with proper timing\r\n        const Components = this.game.componentManager.getComponents();\r\n        const currentTime = this.game.state.now || this.game.state.now || 0;\r\n        const endTime = currentTime + this.rageDuration;\r\n        \r\n        this.game.addComponent(casterEntity, this.componentTypes.BUFF, \r\n            Components.Buff(\r\n                'rage', \r\n                { \r\n                    damageMultiplier: this.damageMultiplier, \r\n                    attackSpeedMultiplier: this.attackSpeedMultiplier,\r\n                    moveSpeedMultiplier: 1.1 // Slight movement speed bonus\r\n                }, \r\n                endTime,     // Proper end time\r\n                false,       // Not stackable\r\n                1,           // Single stack\r\n                currentTime  // Applied time\r\n            )\r\n        );\r\n        \r\n        // Screen effects for dramatic impact\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.3, 2);\r\n            this.game.effectsSystem.playScreenFlash('#ff4444', 0.4);\r\n        }\r\n    \r\n        \r\n        // Schedule buff expiration warning\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.warnRageEnding(casterEntity);\r\n        }, this.rageDuration - 1.0, casterEntity);\r\n    }\r\n    \r\n    // FIXED: Add rage ending warning for better gameplay feedback\r\n    warnRageEnding(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        // Check if entity still exists and has the buff\r\n        const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n        if (!buff || buff.buffType !== 'rage') return;\r\n        \r\n        if (casterPos) {\r\n            // Create fading effect\r\n            this.createVisualEffect(casterPos, 'cast', { \r\n                count: 5, \r\n                color: 0x884444,\r\n                scaleMultiplier: 0.8 \r\n            });\r\n        }\r\n       \r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RageAbility.js",
        "fileName": "RageAbility"
      },
      "TrackingMark": {
        "script": "class TrackingMarkAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'tracking_mark',\r\n            name: 'Tracking Mark',\r\n            description: 'Mark an enemy for increased damage - multiple Rangers can mark the same target for stacking effect',\r\n            cooldown: 8.0,\r\n            range: 200,\r\n            manaCost: 20,\r\n            targetType: 'enemy',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.markDamageIncrease = 0.25; // 25% per mark\r\n        this.maxMarks = 4; // Cap at 4 marks (100% bonus)\r\n        this.markDuration = 15.0;\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF6347,\r\n                    colorRange: { start: 0xFF6347, end: 0xFF4500 },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            mark_target: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xDC143C,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            tracking_beam: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF0000,\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            },\r\n            mark_stack: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Need at least one enemy to mark\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Select target deterministically\r\n        const target = this.selectMarkTarget(enemies, casterEntity);\r\n        if (!target) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Ranger takes aim at their prey...`);\r\n        \r\n        // Schedule the mark application after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applyTrackingMark(casterEntity, target);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    applyTrackingMark(casterEntity, targetId) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        // Validate target still exists\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        if (!targetHealth || targetHealth.current <= 0 || !targetPos) {\r\n            this.logAbilityUsage(casterEntity, `Target has vanished from sight!`);\r\n            return;\r\n        }\r\n        \r\n        // Create marking beam effect if caster still exists\r\n        if (casterPos) {\r\n            this.createTrackingBeamEffect(casterPos, targetPos);\r\n        }\r\n        \r\n        // Apply or stack the tracking mark\r\n        const markResult = this.applyOrStackMark(casterEntity, targetId);\r\n        \r\n        // Create appropriate visual effect based on result\r\n        if (markResult.isNewMark) {\r\n            this.createVisualEffect(targetPos, 'mark_target');\r\n        } else if (markResult.wasStacked) {\r\n            this.createVisualEffect(targetPos, 'mark_stack');\r\n        } else {\r\n            // Mark refreshed\r\n            this.createVisualEffect(targetPos, 'tracking_beam');\r\n        }\r\n        \r\n        // Enhanced logging\r\n        this.logMarkResult(casterEntity, targetId, markResult);\r\n    }\r\n    \r\n    applyOrStackMark(casterEntity, targetId) {\r\n        const Components = this.game.componentManager.getComponents();\r\n        const currentTime = this.game.state.now || this.game.state.now || 0;\r\n        const endTime = currentTime + this.markDuration;\r\n        \r\n        // Check for existing tracking mark\r\n        let existingMark = this.game.getComponent(targetId, this.componentTypes.BUFF);\r\n        \r\n        if (existingMark && existingMark.buffType === 'marked') {\r\n            // Stack the mark up to the maximum\r\n            if (existingMark.stacks < this.maxMarks) {\r\n                existingMark.stacks++;\r\n                existingMark.damageTakenMultiplier = 1 + (this.markDamageIncrease * existingMark.stacks);\r\n                existingMark.endTime = endTime; // Refresh duration\r\n                existingMark.appliedTime = currentTime; // Update applied time\r\n                \r\n                // Track who applied this stack (for potential future features)\r\n                if (!existingMark.appliedBy) {\r\n                    existingMark.appliedBy = [];\r\n                }\r\n                if (!existingMark.appliedBy.includes(casterEntity)) {\r\n                    existingMark.appliedBy.push(casterEntity);\r\n                }\r\n                \r\n                return {\r\n                    isNewMark: false,\r\n                    wasStacked: true,\r\n                    wasRefreshed: false,\r\n                    currentStacks: existingMark.stacks,\r\n                    damageMultiplier: existingMark.damageTakenMultiplier\r\n                };\r\n            } else {\r\n                // Just refresh duration if at max stacks\r\n                existingMark.endTime = endTime;\r\n                existingMark.appliedTime = currentTime;\r\n                \r\n                return {\r\n                    isNewMark: false,\r\n                    wasStacked: false,\r\n                    wasRefreshed: true,\r\n                    currentStacks: existingMark.stacks,\r\n                    damageMultiplier: existingMark.damageTakenMultiplier\r\n                };\r\n            }\r\n        } else {\r\n            // Apply new tracking mark\r\n            this.game.addComponent(targetId, this.componentTypes.BUFF, \r\n                Components.Buff(\r\n                    'marked', \r\n                    { \r\n                        damageTakenMultiplier: 1 + this.markDamageIncrease,\r\n                        revealed: true,\r\n                        markedBy: casterEntity,\r\n                        appliedBy: [casterEntity]\r\n                    }, \r\n                    endTime,      // End time\r\n                    true,         // Stackable\r\n                    1,            // Initial stack count\r\n                    currentTime   // Applied time\r\n                )\r\n            );\r\n            \r\n            return {\r\n                isNewMark: true,\r\n                wasStacked: false,\r\n                wasRefreshed: false,\r\n                currentStacks: 1,\r\n                damageMultiplier: 1 + this.markDamageIncrease\r\n            };\r\n        }\r\n    }\r\n    \r\n    createTrackingBeamEffect(casterPos, targetPos) {\r\n        // Create a visual connection between ranger and target\r\n        this.createVisualEffect(casterPos, 'tracking_beam');\r\n        this.createVisualEffect(targetPos, 'tracking_beam');\r\n        \r\n        // Create energy beam if effects system supports it\r\n        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {\r\n            this.game.effectsSystem.createEnergyBeam(\r\n                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),\r\n                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),\r\n                {\r\n                    style: { color: 0xFF6347, linewidth: 3 },\r\n                    animation: { duration: 600, flickerCount: 2 }\r\n                }\r\n            );\r\n        }\r\n    }\r\n    \r\n    logMarkResult(casterEntity, targetId, markResult) {\r\n       \r\n        \r\n    }\r\n    \r\n    // FIXED: Deterministic target selection\r\n    selectMarkTarget(enemies, casterEntity) {\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Priority 1: Unmarked enemies (new marks are more valuable)\r\n        const unmarkedEnemies = sortedEnemies.filter(enemyId => {\r\n            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n            return !buff || buff.buffType !== 'marked';\r\n        });\r\n        \r\n        if (unmarkedEnemies.length > 0) {\r\n            // Among unmarked enemies, prioritize by distance (closest first)\r\n            return this.selectClosestEnemy(unmarkedEnemies, casterEntity);\r\n        }\r\n        \r\n        // Priority 2: Marked enemies that can be stacked further\r\n        const stackableEnemies = sortedEnemies.filter(enemyId => {\r\n            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n            return buff && buff.buffType === 'marked' && buff.stacks < this.maxMarks;\r\n        });\r\n        \r\n        if (stackableEnemies.length > 0) {\r\n            // Among stackable enemies, prioritize by current stacks (higher first for focused fire)\r\n            return this.selectHighestStackedEnemy(stackableEnemies);\r\n        }\r\n        \r\n        // Priority 3: Any marked enemy (for duration refresh)\r\n        return this.selectClosestEnemy(sortedEnemies, casterEntity);\r\n    }\r\n    \r\n    selectClosestEnemy(enemies, casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos || enemies.length === 0) return null;\r\n        \r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        enemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            // Use <= for consistent tie-breaking (first in sorted order wins)\r\n            if (distance <= closestDistance) {\r\n                closestDistance = distance;\r\n                closest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return closest;\r\n    }\r\n    \r\n    selectHighestStackedEnemy(enemies) {\r\n        let highestStacked = null;\r\n        let highestStacks = 0;\r\n        \r\n        enemies.forEach(enemyId => {\r\n            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n            if (!buff || buff.buffType !== 'marked') return;\r\n            \r\n            // Use >= for consistent tie-breaking (first in sorted order wins)\r\n            if (buff.stacks >= highestStacks) {\r\n                highestStacks = buff.stacks;\r\n                highestStacked = enemyId;\r\n            }\r\n        });\r\n        \r\n        return highestStacked;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/TrackingMark.js",
        "fileName": "TrackingMark"
      },
      "ArenaPresenceAbility": {
        "script": "class ArenaPresenceAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'arena_presence',\r\n            name: 'Arena Presence',\r\n            description: 'Intimidate nearby enemies, reducing their damage and accuracy (does not stack)',\r\n            cooldown: 10.0,\r\n            range: 120,\r\n            manaCost: 25,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 1.2,\r\n            ...params\r\n        });\r\n        \r\n        this.intimidationDuration = 15.0;\r\n        this.damageReduction = 0.25; // 25% damage reduction\r\n        this.accuracyReduction = 0.2; // 20% accuracy reduction\r\n        this.fearRadius = this.range;\r\n        this.element = 'psychological';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    colorRange: { start: 0x8B0000, end: 0xFF4500 },\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            intimidation_aura: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x800000,\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 0.6\r\n                }\r\n            },\r\n            fear_effect: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4B0000,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            presence_wave: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x660000,\r\n                    scaleMultiplier: 3.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Need enemies nearby to intimidate\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Gladiator's presence fills the arena with dread...`);\r\n        \r\n        // Schedule the intimidation after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.unleashArenaPresence(casterEntity, enemies);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    unleashArenaPresence(casterEntity, targetEnemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Create intimidation aura effect\r\n        this.createVisualEffect(casterPos, 'intimidation_aura');\r\n        \r\n        // Create expanding presence wave\r\n        this.createVisualEffect(casterPos, 'presence_wave');\r\n        \r\n        // Sort enemies deterministically for consistent processing\r\n        const sortedEnemies = targetEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let intimidatedCount = 0;\r\n        let refreshedCount = 0;\r\n        \r\n        // Apply intimidation to each enemy in deterministic order\r\n        sortedEnemies.forEach((enemyId, index) => {\r\n            const intimidationResult = this.applyIntimidation(casterEntity, enemyId);\r\n            \r\n            if (intimidationResult.success) {\r\n                if (intimidationResult.wasRefreshed) {\r\n                    refreshedCount++;\r\n                } else {\r\n                    intimidatedCount++;\r\n                }\r\n                \r\n                // Schedule staggered fear effects for visual appeal\r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                    if (enemyPos) {\r\n                        this.createVisualEffect(enemyPos, 'fear_effect');\r\n                    }\r\n                }, index * 0.1, enemyId);\r\n            }\r\n        });\r\n        \r\n        // Screen effects for dramatic presence\r\n        if (this.game.effectsSystem && (intimidatedCount > 0 || refreshedCount > 0)) {\r\n            this.game.effectsSystem.playScreenShake(0.4, 2);\r\n            this.game.effectsSystem.playScreenFlash('#8B0000', 0.6);\r\n        }\r\n        \r\n       \r\n    }\r\n    \r\n    applyIntimidation(casterEntity, enemyId) {\r\n        // Validate enemy still exists and is alive\r\n        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n        const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n        \r\n        if (!enemyHealth || enemyHealth.current <= 0 || !enemyPos) {\r\n            return { success: false, reason: 'target_invalid' };\r\n        }\r\n        \r\n        // Check if already intimidated - don't stack multiple intimidations\r\n        const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n        const currentTime = this.game.state.now || this.game.state.now || 0;\r\n        const endTime = currentTime + this.intimidationDuration;\r\n        \r\n        if (existingBuff && existingBuff.buffType === 'intimidated') {\r\n            // Refresh duration instead of stacking\r\n            existingBuff.endTime = endTime;\r\n            existingBuff.appliedTime = currentTime;\r\n            \r\n         \r\n            \r\n            return { success: true, wasRefreshed: true };\r\n        } else {\r\n            // Apply new intimidation buff\r\n            const Components = this.game.componentManager.getComponents();\r\n            \r\n            this.game.addComponent(enemyId, this.componentTypes.BUFF, \r\n                Components.Buff(\r\n                    'intimidated', \r\n                    { \r\n                        damageReduction: this.damageReduction,\r\n                        accuracyReduction: this.accuracyReduction,\r\n                        intimidatedBy: casterEntity,\r\n                        fearLevel: 1\r\n                    }, \r\n                    endTime,      // End time\r\n                    false,        // Not stackable\r\n                    1,            // Single stack\r\n                    currentTime   // Applied time\r\n                )\r\n            );\r\n            \r\n       \r\n            \r\n            return { success: true, wasRefreshed: false };\r\n        }\r\n    }\r\n    \r\n    // Helper method to check intimidation effectiveness\r\n    getIntimidationEffectiveness(casterEntity, enemyId) {\r\n        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);\r\n        const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n        \r\n        if (!casterCombat || !enemyCombat || !casterHealth || !enemyHealth) {\r\n            return 1.0; // Default effectiveness\r\n        }\r\n        \r\n        // Calculate intimidation effectiveness based on relative power\r\n        const casterPower = (casterCombat.damage || 1) * (casterHealth.current || 1);\r\n        const enemyPower = (enemyCombat.damage || 1) * (enemyHealth.current || 1);\r\n        \r\n        const powerRatio = casterPower / Math.max(enemyPower, 1);\r\n        \r\n        // Effectiveness between 0.5 and 1.5 based on power difference\r\n        return Math.max(0.5, Math.min(1.5, 0.7 + (powerRatio * 0.3)));\r\n    }\r\n    \r\n    // Helper method to get current intimidation status\r\n    getIntimidationStatus(enemyId) {\r\n        const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n        \r\n        if (!buff || buff.buffType !== 'intimidated') {\r\n            return { isIntimidated: false };\r\n        }\r\n        \r\n        const currentTime = this.game.state.now || this.game.state.now || 0;\r\n        const timeRemaining = Math.max(0, buff.endTime - currentTime);\r\n        \r\n        return {\r\n            isIntimidated: true,\r\n            timeRemaining: timeRemaining,\r\n            damageReduction: buff.modifiers?.damageReduction || this.damageReduction,\r\n            accuracyReduction: buff.modifiers?.accuracyReduction || this.accuracyReduction,\r\n            intimidatedBy: buff.modifiers?.intimidatedBy\r\n        };\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ArenaPresenceAbility.js",
        "fileName": "ArenaPresenceAbility"
      },
      "ConsecrationAbility": {
        "script": "class ConsecrationAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'consecration',\r\n            name: 'Consecration',\r\n            description: 'Sanctify the ground, creating a zone that damages undead and heals the living',\r\n            cooldown: 18.0,\r\n            range: 0, // Centered on caster\r\n            manaCost: 50,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 2.0,\r\n            ...params\r\n        });\r\n        \r\n        this.consecrationRadius = 120;\r\n        this.duration = 15.0; // 15 seconds\r\n        this.tickInterval = 2.0; // Every 2 seconds\r\n        this.tickDamage = 12; // Damage to undead per tick\r\n        this.tickHeal = 8; // Healing to living per tick\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: { \r\n                type: 'magic', \r\n                options: { \r\n                    count: 3, \r\n                    color: 0xffffaa, \r\n                    colorRange: { start: 0xffffaa, end: 0xffffff },\r\n                    scaleMultiplier: 1.6,\r\n                    speedMultiplier: 1.2\r\n                } \r\n            },\r\n            consecration: { \r\n                type: 'heal', \r\n                options: { \r\n                    count: 3, \r\n                    color: 0xffffdd, \r\n                    scaleMultiplier: 0.6,\r\n                    speedMultiplier: 1.0\r\n                } \r\n            },\r\n            purge: { \r\n                type: 'damage', \r\n                options: { \r\n                    count: 3, \r\n                    color: 0xffffff, \r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                } \r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if there are units nearby that would benefit from consecration\r\n        const nearbyUnits = this.getUnitsInRange(casterEntity, this.consecrationRadius);\r\n        return nearbyUnits.length >= 2; // At least 2 units to affect\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \"Templar consecrates the battlefield with holy power!\", true);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for consecration creation\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createConsecration(casterEntity, pos);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createConsecration(casterEntity, consecrationPos) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (!casterHealth || casterHealth.current <= 0) return;\r\n        \r\n        // Create consecrated ground entity\r\n        const consecrationId = this.game.createEntity();\r\n        const Components = this.game.componentManager.getComponents();\r\n        \r\n        this.game.addComponent(consecrationId, this.componentTypes.POSITION, \r\n            Components.Position(consecrationPos.x, consecrationPos.y, consecrationPos.z));\r\n        \r\n        this.game.addComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT, \r\n            Components.TemporaryEffect('consecrated_ground', {\r\n                caster: casterEntity,\r\n                radius: this.consecrationRadius,\r\n                tickInterval: this.tickInterval,\r\n                tickDamage: this.tickDamage,\r\n                tickHeal: this.tickHeal\r\n            }, this.game.state.now));\r\n        \r\n        this.game.addComponent(consecrationId, this.componentTypes.RENDERABLE, \r\n            Components.Renderable(\"effects\", \"consecration\"));\r\n        \r\n        // DESYNC SAFE: Schedule all consecration ticks using the scheduling system\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {\r\n            const tickDelay = this.tickInterval * tickIndex;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex);\r\n            }, tickDelay, consecrationId);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule consecration cleanup\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.cleanupConsecration(consecrationId);\r\n        }, this.duration, consecrationId);\r\n        \r\n        // Screen effect for consecration creation\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.5);\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Execute a single consecration tick deterministically\r\n    executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex) {\r\n        // Check if consecration entity still exists\r\n        if (!this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {\r\n            return;\r\n        }\r\n        \r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterTeam) {\r\n            // Caster died, end consecration early\r\n            this.cleanupConsecration(consecrationId);\r\n            return;\r\n        }\r\n        \r\n        // DESYNC SAFE: Get all units in area deterministically\r\n        const allUnits = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.HEALTH,\r\n            this.componentTypes.TEAM\r\n        );\r\n        \r\n        // Sort units for consistent processing order\r\n        const sortedUnits = allUnits.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let undeadDamaged = 0;\r\n        let livingHealed = 0;\r\n        \r\n        sortedUnits.forEach(unitId => {\r\n            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);\r\n            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);\r\n            const team = this.game.getComponent(unitId, this.componentTypes.TEAM);\r\n            const unitType = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);\r\n            \r\n            if (!unitPos || !health || !team || health.current <= 0) return;\r\n            \r\n            // Check if unit is in consecration radius\r\n            const distance = Math.sqrt(\r\n                Math.pow(unitPos.x - consecrationPos.x, 2) + \r\n                Math.pow(unitPos.z - consecrationPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.consecrationRadius) {\r\n                // DESYNC SAFE: Determine if unit is undead/evil deterministically\r\n                const isUndead = this.isUndeadUnit(unitType);\r\n                \r\n                if (isUndead) {\r\n                    // Damage undead/evil units\r\n                    this.dealDamageWithEffects(casterEntity, unitId, this.tickDamage, 'divine', {\r\n                        isConsecration: true,\r\n                        tickIndex: tickIndex\r\n                    });\r\n                    this.createVisualEffect(unitPos, 'purge', { heightOffset: 10 });\r\n                    undeadDamaged++;\r\n                } else if (team.team === casterTeam.team) {\r\n                    // Heal living allies\r\n                    if (health.current < health.max) {\r\n                        const healAmount = Math.min(this.tickHeal, health.max - health.current);\r\n                        health.current += healAmount;\r\n                        \r\n                        this.createVisualEffect(unitPos, 'consecration', { heightOffset: 10 });\r\n                        \r\n                        if (this.game.effectsSystem) {\r\n                            this.game.effectsSystem.showDamageNumber(\r\n                                unitPos.x, unitPos.y + 15, unitPos.z, \r\n                                healAmount, 'heal'\r\n                            );\r\n                        }\r\n                        livingHealed++;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Additional visual effects every few ticks\r\n        if (tickIndex % 3 === 0) {\r\n            this.createVisualEffect(consecrationPos, 'consecration', { \r\n                count: 8, \r\n                scaleMultiplier: 2.0,\r\n                heightOffset: 5 \r\n            });\r\n        }\r\n        \r\n   \r\n    }\r\n    \r\n    // DESYNC SAFE: Determine if unit is undead deterministically\r\n    isUndeadUnit(unitType) {\r\n        if (!unitType) return false;\r\n        \r\n        // Check various undead/evil identifiers\r\n        return (\r\n            unitType.id === 'skeleton' ||\r\n            unitType.id === 'zombie' ||\r\n            unitType.id === 'lich' ||\r\n            unitType.id === 'wraith' ||\r\n            unitType.id === 'demon'\r\n        );\r\n    }\r\n    \r\n    // DESYNC SAFE: Get all units in range\r\n    getUnitsInRange(casterEntity, radius) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return [];\r\n        \r\n        const allUnits = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.HEALTH\r\n        );\r\n        \r\n        return allUnits.filter(unitId => {\r\n            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);\r\n            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);\r\n            \r\n            if (!unitPos || !health || health.current <= 0) return false;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(unitPos.x - casterPos.x, 2) + \r\n                Math.pow(unitPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            return distance <= radius;\r\n        }).sort((a, b) => String(a).localeCompare(String(b))); // Sort for determinism\r\n    }\r\n    \r\n    // DESYNC SAFE: Clean up consecration\r\n    cleanupConsecration(consecrationId) {\r\n        if (this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {\r\n            // Visual effect for consecration ending\r\n            const consecrationPos = this.game.getComponent(consecrationId, this.componentTypes.POSITION);\r\n            if (consecrationPos) {\r\n                this.createVisualEffect(consecrationPos, 'consecration', { \r\n                    count: 12, \r\n                    scaleMultiplier: 1.5,\r\n                    color: 0xffd700 \r\n                });\r\n            }\r\n            \r\n            this.game.destroyEntity(consecrationId);\r\n            \r\n       \r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ConsecrationAbility.js",
        "fileName": "ConsecrationAbility"
      },
      "FreezingAuraAbility": {
        "script": "class FreezingAuraAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'freezing_aura',\r\n            name: 'Freezing Aura',\r\n            description: 'Emanate freezing cold',\r\n            cooldown: 0,\r\n            range: 100,\r\n            manaCost: 0,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 0,\r\n            ...params\r\n        });\r\n        this.drainPerSecond = 8;\r\n        this.duration = 12.0; // 12 seconds instead of 1200 seconds\r\n        this.tickInterval = 1.0; // 1 second between ticks\r\n        this.hasActiveAura = false;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4B0082,\r\n                    colorRange: { start: 0x4B0082, end: 0x000000 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            freezing: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            empowerment: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B0000,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Only allow one active aura per caster\r\n        return !this.hasActiveAura;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        this.createVisualEffect(pos, 'cast');\r\n        // Mark aura as active\r\n        this.hasActiveAura = true;\r\n        \r\n        // DESYNC SAFE: Schedule all aura ticks using the scheduling system\r\n        const totalTicks = Math.floor(this.duration / this.tickInterval);\r\n        \r\n        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {\r\n            const tickDelay = this.tickInterval * tickIndex;\r\n            \r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.executeAuraTick(casterEntity, tickIndex, totalTicks);\r\n            }, tickDelay, casterEntity);\r\n        }\r\n        \r\n        // DESYNC SAFE: Schedule aura cleanup\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.hasActiveAura = false;\r\n        }, this.duration, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Execute a single aura tick deterministically\r\n    executeAuraTick(casterEntity, tickIndex, totalTicks) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {\r\n            // Caster is dead, end the aura early\r\n            this.hasActiveAura = false;\r\n            return;\r\n        }\r\n        \r\n        // DESYNC SAFE: Get enemies and allies deterministically\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        \r\n        // Sort for consistent processing order\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n\r\n        \r\n        // Process allies - empower undead\r\n        sortedAllies.forEach(allyId => {\r\n            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            \r\n            if (!unitType || !allyPos) return;\r\n            \r\n            // Check if this is an undead unit\r\n            const distance = Math.sqrt(\r\n                Math.pow(allyPos.x - casterPos.x, 2) + \r\n                Math.pow(allyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.range) {\r\n                // Check if already has empowerment buff\r\n                const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n                \r\n                if (!existingBuff || existingBuff.buffType !== 'ice_armor') {\r\n                    const Components = this.game.componentManager.getComponents();\r\n                    this.game.addComponent(allyId, this.componentTypes.BUFF, \r\n                        Components.Buff('ice_armor', { \r\n                            armorMultiplier: 1.5\r\n                        }, this.game.state.now + 3.0, false, 1, this.game.state.now));\r\n                    \r\n                    // Visual empowerment effect\r\n                    this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });\r\n                }\r\n            }\r\n            \r\n        });\r\n        \r\n        // Additional visual effects every few ticks\r\n        if (tickIndex % 3 === 0) {\r\n            this.createVisualEffect(casterPos, 'freezing', { \r\n                count: 6, \r\n                scaleMultiplier: 2.5,\r\n                heightOffset: 50 \r\n            });\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FreezingAuraAbility.js",
        "fileName": "FreezingAuraAbility"
      },
      "PhalanxFormationAbility": {
        "script": "class PhalanxFormationAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'phalanx_formation',\r\n            name: 'Phalanx Formation',\r\n            description: 'Link with nearby Hoplites - more Hoplites = stronger formation bonus',\r\n            cooldown: 2.0,\r\n            range: 80,\r\n            manaCost: 0,\r\n            targetType: 'allies',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 1.2,\r\n            ...params\r\n        });\r\n        \r\n        this.formationDuration = 25.0;\r\n        this.baseArmorMultiplier = 1.15; // 15% base armor bonus\r\n        this.perHopliteBonus = 0.15;     // Additional 15% per hoplite\r\n        this.maxArmorMultiplier = 2.0;   // Cap at 200%\r\n        this.baseCounterChance = 0.2;    // 20% base counter attack chance\r\n        this.perHopliteCounterBonus = 0.05; // +5% per hoplite\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4169E1,\r\n                    colorRange: { start: 0x4169E1, end: 0xB0C4DE },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            formation: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x6495ED,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            phalanx: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x87CEEB,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if caster already has a phalanx buff to prevent re-casting\r\n        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);\r\n        if (existingBuff && existingBuff.buffType === 'phalanx') return false;\r\n        \r\n        // Must have at least one nearby hoplite ally (not counting self)\r\n        const nearbyHoplites = this.getNearbyHoplites(casterEntity);\r\n        return nearbyHoplites.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);\r\n        \r\n        if (!casterPos || !casterUnitType) return null;\r\n        \r\n        const nearbyHoplites = this.getNearbyHoplites(casterEntity);\r\n        if (nearbyHoplites.length === 0) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, \r\n            `Hoplite begins forming phalanx with ${nearbyHoplites.length} allies...`);\r\n        \r\n        // Schedule the formation creation after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createPhalanxFormation(casterEntity, nearbyHoplites);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    createPhalanxFormation(casterEntity, nearbyHoplites) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Sort hoplites deterministically for consistent processing\r\n        const sortedHoplites = nearbyHoplites.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        const phalanxSize = sortedHoplites.length + 1; // Include caster\r\n        const armorMultiplier = Math.min(\r\n            this.baseArmorMultiplier + (phalanxSize * this.perHopliteBonus), \r\n            this.maxArmorMultiplier\r\n        );\r\n        const counterAttackChance = this.baseCounterChance + (phalanxSize * this.perHopliteCounterBonus);\r\n        \r\n        // Create formation effect at caster position\r\n        this.createVisualEffect(casterPos, 'formation');\r\n        \r\n        // Apply formation buff to all Hoplites in range (including caster)\r\n        const allHoplites = [casterEntity, ...sortedHoplites];\r\n        let formationSuccess = 0;\r\n        \r\n        // Process hoplites in deterministic order\r\n        allHoplites.forEach((hopliteId, index) => {\r\n            // Validate hoplite still exists and is a hoplite\r\n            const unitType = this.game.getComponent(hopliteId, this.componentTypes.UNIT_TYPE);\r\n            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);\r\n            \r\n            if (!unitType || !position || unitType.id !== 'hoplite') return;\r\n            \r\n            // Apply phalanx buff\r\n            const Components = this.game.componentManager.getComponents();\r\n            const currentTime = this.game.state.now || this.game.state.now || 0;\r\n            const endTime = currentTime + this.formationDuration;\r\n            \r\n            this.game.addComponent(hopliteId, this.componentTypes.BUFF, \r\n                Components.Buff(\r\n                    'phalanx', \r\n                    { \r\n                        armorMultiplier: armorMultiplier,\r\n                        counterAttackChance: counterAttackChance,\r\n                        formationSize: phalanxSize,\r\n                        formationLeader: casterEntity,\r\n                        formationRole: (hopliteId === casterEntity) ? 'leader' : 'member'\r\n                    }, \r\n                    endTime,     // Proper end time\r\n                    false,       // Not stackable\r\n                    1,           // Single stack  \r\n                    currentTime  // Applied time\r\n                )\r\n            );\r\n            \r\n            // Create phalanx effect on each member\r\n            this.createVisualEffect(position, 'phalanx');\r\n            \r\n            // Schedule a delayed formation link effect for visual appeal\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                const pos = this.game.getComponent(hopliteId, this.componentTypes.POSITION);\r\n                if (pos) {\r\n                    this.createVisualEffect(pos, 'formation', { \r\n                        count: 3, \r\n                        scaleMultiplier: 1.0 \r\n                    });\r\n                }\r\n            }, index * 0.2, hopliteId); // Staggered visual effects\r\n            \r\n            formationSuccess++;\r\n        });\r\n        \r\n        // Screen effects for dramatic formation\r\n        if (this.game.effectsSystem && formationSuccess > 0) {\r\n            this.game.effectsSystem.playScreenFlash('#4169E1', 0.4);\r\n        }\r\n    \r\n      \r\n        \r\n        // Schedule formation expiration warning\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.warnFormationEnding(allHoplites);\r\n        }, this.formationDuration - 2.0, casterEntity);\r\n    }\r\n    \r\n    // FIXED: Deterministic nearby hoplite detection\r\n    getNearbyHoplites(casterEntity) {\r\n        const allAllies = this.getAlliesInRange(casterEntity);\r\n        \r\n        // Filter and sort hoplites deterministically\r\n        const hoplites = allAllies.filter(allyId => {\r\n            if (allyId === casterEntity) return false; // Exclude self\r\n            \r\n            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);\r\n            return unitType && unitType.id === 'hoplite';\r\n        });\r\n        \r\n        // Sort deterministically for consistent processing\r\n        return hoplites.sort((a, b) => String(a).localeCompare(String(b)));\r\n    }\r\n    \r\n    // FIXED: Formation ending warning\r\n    warnFormationEnding(hopliteIds) {\r\n        let activeFormationMembers = 0;\r\n        \r\n        hopliteIds.forEach(hopliteId => {\r\n            // Check if hoplite still exists and has the phalanx buff\r\n            const buff = this.game.getComponent(hopliteId, this.componentTypes.BUFF);\r\n            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);\r\n            \r\n            if (!buff || buff.buffType !== 'phalanx' || !position) return;\r\n            \r\n            // Create warning effect\r\n            this.createVisualEffect(position, 'cast', { \r\n                count: 3, \r\n                color: 0x4169E1,\r\n                scaleMultiplier: 0.8 \r\n            });\r\n            \r\n            activeFormationMembers++;\r\n        });\r\n       \r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PhalanxFormationAbility.js",
        "fileName": "PhalanxFormationAbility"
      },
      "BuildAbility": {
        "script": "class BuildAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, abilityData) {\r\n        super(game, abilityData);\r\n        this.id = 'build';\r\n        this.name = 'Build';\r\n        this.description = 'Construct buildings';\r\n        this.isPassive = true;\r\n        this.autocast = false;\r\n        this.castTime = 0;\r\n        this.cooldown = 0;\r\n        this.priority = 0;\r\n        this.enabled = true;\r\n        this.meta = { preventEnemiesInRangeCheck: true };\r\n        this.buildRange = 50;\r\n    }\r\n\r\n    canExecute(entityId) {\r\n        if(!this.enabled){\r\n            return false;\r\n        }\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        let buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);\r\n        \r\n        if (!buildingState) {\r\n            return false;\r\n        }\r\n\r\n        return this.game.aiSystem.getCurrentAIControllerId(entityId) == ComponentTypes.BUILDING_STATE;\r\n    }\r\n    execute(entityId, targetData) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const buildState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);\r\n        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);\r\n        \r\n        if (!buildState || !pos || !vel) {\r\n            return null;\r\n        }\r\n\r\n        this.updateBuilderState(entityId, buildState, pos, vel);\r\n        return null;\r\n    }\r\n\r\n    updateBuilderState(entityId, buildState, pos, vel) {\r\n        buildState.entityId = entityId;\r\n        \r\n        switch (buildState.state) {\r\n            case 'idle':\r\n                break;\r\n            case 'walking_to_construction':\r\n                this.walkToConstruction(buildState, pos, vel);\r\n                break;\r\n            case 'constructing':\r\n                this.constructBuilding(buildState);\r\n                break;\r\n        }\r\n    }\r\n\r\n    assignToBuild(peasantEntityId, buildingEntityId, peasantInfo) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        const aiState = this.game.getComponent(peasantEntityId, ComponentTypes.AI_STATE);\r\n        const buildingPos = this.game.getComponent(buildingEntityId, ComponentTypes.POSITION);\r\n        \r\n        if (!buildingPos) return;\r\n\r\n        const buildingPlacement = this.game.getComponent(buildingEntityId, ComponentTypes.PLACEMENT);\r\n        const renderComponent = this.game.getComponent(buildingEntityId, ComponentTypes.RENDERABLE);\r\n        renderComponent.spawnType = 'underConstruction';\r\n        \r\n        this.game.removeComponent(buildingEntityId, ComponentTypes.HEALTH);\r\n\r\n        const peasantId = peasantInfo.peasantId;\r\n        const buildTime = peasantInfo.buildTime;       \r\n        \r\n        if (buildingPlacement) {\r\n            buildingPlacement.isUnderConstruction = true;\r\n            buildingPlacement.buildTime = buildTime;\r\n            buildingPlacement.assignedBuilder = peasantId || null;\r\n        }\r\n\r\n        this.peasantId = peasantEntityId;\r\n        this.game.addComponent(peasantEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('walking_to_construction', buildingEntityId, buildingPos, this.game.state.round));\r\n        this.game.addComponent(buildingEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('planned_for_construction', buildingEntityId, buildingPos, null));\r\n        \r\n        let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(peasantEntityId, ComponentTypes.BUILDING_STATE);\r\n        currentBuildingStateAI.targetPosition = buildingPos;                          \r\n        currentBuildingStateAI.meta = this.meta;\r\n        this.game.aiSystem.setCurrentAIController(peasantEntityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);    \r\n\r\n        if (buildingPlacement) {\r\n            buildingPlacement.assignedBuilder = peasantEntityId;\r\n            buildingPlacement.isUnderConstruction = true;\r\n        }\r\n    }\r\n\r\n    walkToConstruction(buildState, pos, vel) {\r\n        \r\n        if (!buildState.targetBuildingPosition || !buildState.targetBuildingEntityId) {\r\n            buildState.state = 'idle';\r\n            return;\r\n        }\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const buildingPosition = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.POSITION);\r\n        const buildingBuildState = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.BUILDING_STATE);\r\n        \r\n        if (!buildingPosition) {\r\n            buildState.targetBuildingEntityId = null;\r\n            buildState.targetBuildingPosition = null;\r\n            buildState.state = 'idle';\r\n            return;\r\n        }\r\n\r\n        const dx = buildState.targetBuildingPosition.x - pos.x;\r\n        const dz = buildState.targetBuildingPosition.z - pos.z;\r\n        const dist = Math.sqrt(dx * dx + dz * dz);\r\n\r\n        if (dist < this.buildRange) {\r\n            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);            \r\n            currentBuildingStateAI.targetPosition = null;  \r\n            currentBuildingStateAI.state = 'idle';                                    \r\n            currentBuildingStateAI.meta = this.meta;            \r\n            this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);   \r\n\r\n            pos.x = buildState.targetBuildingPosition.x + this.buildRange;\r\n            pos.z = buildState.targetBuildingPosition.z;\r\n            vel.vx = 0;\r\n            vel.vz = 0;\r\n            buildState.state = 'constructing';\r\n            buildState.constructionStartTime = this.game.state.round;\r\n            buildingBuildState.state = 'under_construction';\r\n            buildingBuildState.constructionStartTime = this.game.state.round;\r\n        } else {     \r\n            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);\r\n            if(currentBuildingStateAI.targetPosition != buildState.targetBuildingPosition){\r\n                currentBuildingStateAI.targetPosition = buildState.targetBuildingPosition;  \r\n                currentBuildingStateAI.state = 'chasing';                          \r\n                currentBuildingStateAI.meta = this.meta;\r\n                this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);   \r\n            }\r\n        }\r\n    }\r\n\r\n    constructBuilding(buildState) {\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);\r\n        const unitType = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.UNIT_TYPE);\r\n        this.game.addComponent(buildState.targetBuildingEntityId, ComponentTypes.HEALTH, Components.Health(unitType.hp));\r\n        \r\n\r\n        const elapsed = this.game.state.round - buildState.constructionStartTime;\r\n        const buildTime = buildingPlacement.buildTime || 1;\r\n        if (this.game.animationSystem) {\r\n            const animState = this.game.animationSystem.entityAnimationStates.get(buildState.entityId);\r\n            if(animState){\r\n                const finished = this.game.animationSystem.isAnimationFinished(buildState.entityId, animState.currentClip);\r\n                if(finished || animState.currentClip != 'attack'){\r\n                    this.game.abilitySystem.startAbilityAnimation(buildState.entityId, { castTime: 1 });\r\n                }\r\n            }\r\n        }\r\n\r\n        if (elapsed >= buildTime) {            \r\n            this.completeConstruction(buildState);\r\n        }\r\n    }\r\n\r\n    completeConstruction(buildState) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);\r\n        const aiState = this.game.getComponent(this.peasantId, ComponentTypes.AI_STATE);\r\n        const renderComponent = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.RENDERABLE);\r\n        renderComponent.spawnType = buildingPlacement.unitType.id;\r\n        this.game.renderSystem?.removeInstance(buildState.targetBuildingEntityId);\r\n        if (!buildingPlacement) {\r\n            buildState.state = 'idle';\r\n            return;\r\n        }\r\n        if(this.game.shopSystem){\r\n            this.game.shopSystem.addBuilding(buildingPlacement.unitType.id, buildingPlacement.squadUnits[0]);\r\n        }\r\n        \r\n        buildingPlacement.isUnderConstruction = false;\r\n        buildingPlacement.assignedBuilder = null;\r\n\r\n        if (this.game.animationSystem) {\r\n            this.game.animationSystem.changeAnimation(buildState.targetBuildingEntityId, 'idle', 1.0, 0);\r\n        }\r\n\r\n        buildState.targetBuildingEntityId = null;\r\n        buildState.targetBuildingPosition = null;\r\n        buildState.state = 'idle';\r\n        \r\n        this.game.aiSystem.removeCurrentAIController(this.peasantId);\r\n        \r\n        this.game.removeComponent(this.peasantId, ComponentTypes.BUILDING_STATE);\r\n    }\r\n    \r\n    onPlacementPhaseStart(entityId) {\r\n        if(this.canExecute(entityId)){\r\n            this.execute(entityId);\r\n        }\r\n    }\r\n    \r\n    logAbilityUsage(entityId) {\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BuildAbility.js",
        "fileName": "BuildAbility"
      },
      "Tornado": {
        "script": "class CurseAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'curse',\r\n            name: 'Curse',\r\n            description: 'Curses enemies, reducing their damage and making them vulnerable',\r\n            cooldown: 7.0,\r\n            range: 180,\r\n            manaCost: 50,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 5,\r\n            castTime: 1.5,\r\n            autoTrigger: 'strong_enemies',\r\n            ...params\r\n        });\r\n        \r\n        this.curseRadius = 100;\r\n        this.damageReduction = 0.5; // Reduce enemy damage by 50%\r\n        this.vulnerabilityIncrease = 1.3; // 30% more damage taken\r\n        this.duration = 20.0;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    colorRange: { start: 0x2F4F4F, end: 0x000000 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            curse: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 2,\r\n                    color: 0x696969,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.applyCurses(casterEntity, enemies);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    applyCurses(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        enemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);\r\n            \r\n            if (!enemyPos || !enemyCombat) return;\r\n            \r\n            // Check if enemy is in curse radius\r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.curseRadius) {\r\n                // Apply curse effect\r\n                this.createVisualEffect(enemyPos, 'curse');\r\n                \r\n                // Reduce enemy damage\r\n                const originalDamage = enemyCombat.damage;\r\n                enemyCombat.damage = Math.floor(enemyCombat.damage * this.damageReduction);\r\n                \r\n                // Create dark aura effect\r\n                if (this.game.effectsSystem) {\r\n                    this.game.effectsSystem.createAuraEffect(\r\n                        enemyPos.x, enemyPos.y, enemyPos.z,\r\n                        'magic',\r\n                        this.duration * 1000\r\n                    );\r\n                }\r\n                        \r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    if (this.game.getComponent(enemyId, this.componentTypes.COMBAT)) {\r\n                        enemyCombat.damage = originalDamage;\r\n                    }\r\n                }, this.duration, enemyId);\r\n\r\n            }\r\n        });\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/Tornado.js",
        "fileName": "Tornado"
      },
      "MindControlAbility": {
        "script": "class MindControlAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'mind_control',\r\n            name: 'Mind Control',\r\n            description: 'Charms enemy to fight for you',\r\n            cooldown: 5.0,\r\n            range: 190,\r\n            manaCost: 0,\r\n            targetType: 'enemy',\r\n            animation: 'cast',\r\n            priority: 8,\r\n            castTime: 3.0,\r\n            ...params\r\n        });\r\n\r\n        // How long control lasts once applied\r\n        this.controlDuration = 5.0;\r\n\r\n        // DESYNC SAFE: Track pending controls deterministically\r\n        // Map<targetId, { team, contributors: Set<casterId>, progress: number, startTime: number, scheduledActionId: string }>\r\n        this.pendingControls = new Map();\r\n\r\n        // DESYNC SAFE: Track active beams for cleanup\r\n        // Map<targetId, { team, beams: Map<casterId, effectData> }>\r\n        this.beamRegistry = new Map();\r\n    }\r\n\r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8A2BE2,\r\n                    colorRange: { start: 0x8A2BE2, end: 0xDDA0DD },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.8\r\n                }\r\n            },\r\n            control: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x9932CC,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            charm: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xDA70D6,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        \r\n        // Filter out enemies that are already being controlled or targeted\r\n        const validTargets = enemies.filter(enemyId => {\r\n            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);\r\n            const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n            \r\n            if (!enemyTeam || !casterTeam) return false;\r\n            \r\n            // Don't target enemies that are already controlled by our team\r\n            if (enemyTeam.team === casterTeam.team) return false;\r\n            \r\n            // Don't target enemies that are already being mind controlled\r\n            return !this.pendingControls.has(enemyId);\r\n        });\r\n        \r\n        return validTargets.length > 0;\r\n    }\r\n\r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        \r\n        if (!casterPos || !casterTeam) return;\r\n\r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        const validTargets = enemies.filter(enemyId => {\r\n            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);\r\n            return enemyTeam && enemyTeam.team !== casterTeam.team && !this.pendingControls.has(enemyId);\r\n        });\r\n\r\n        if (validTargets.length === 0) return;\r\n\r\n        // DESYNC SAFE: Select target deterministically (closest enemy)\r\n        const target = this.findClosestEnemy(casterEntity, validTargets);\r\n        if (!target) return;\r\n\r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `${this.name} begins to dominate an enemy mind!`);\r\n\r\n        // DESYNC SAFE: Use scheduling system for mind control process\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.startMindControl(casterEntity, target);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n\r\n    // DESYNC SAFE: Find closest enemy deterministically\r\n    findClosestEnemy(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n\r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n\r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n\r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n\r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closest = enemyId;\r\n            }\r\n        });\r\n\r\n        return closest;\r\n    }\r\n\r\n    // DESYNC SAFE: Start mind control process\r\n    startMindControl(casterId, targetId) {\r\n        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);\r\n        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!casterTeam || !targetTeam || !targetPos) return;\r\n\r\n        // Check if target is already being controlled\r\n        if (this.pendingControls.has(targetId)) {\r\n            // Add this caster as a contributor to existing control attempt\r\n            const existing = this.pendingControls.get(targetId);\r\n            existing.contributors.add(casterId);\r\n            this.createBeam(casterId, targetId);\r\n            return;\r\n        }\r\n\r\n        // Start new mind control attempt\r\n        const controlData = {\r\n            team: casterTeam.team,\r\n            contributors: new Set([casterId]),\r\n            progress: 0,\r\n            startTime: this.game.state.now,\r\n            originalTeam: targetTeam.team\r\n        };\r\n\r\n        this.pendingControls.set(targetId, controlData);\r\n\r\n        // Create visual beam effect\r\n        this.createBeam(casterId, targetId);\r\n\r\n        // Visual effect on target\r\n        this.createVisualEffect(targetPos, 'control');\r\n\r\n        // DESYNC SAFE: Schedule the mind control completion check\r\n        const completionTime = 2.0; // 2 seconds to complete mind control\r\n        const actionId = this.game.schedulingSystem.scheduleAction(() => {\r\n            this.completeMindControl(targetId);\r\n        }, completionTime, casterId);\r\n\r\n        controlData.scheduledActionId = actionId;\r\n    }\r\n\r\n    // DESYNC SAFE: Complete mind control process\r\n    completeMindControl(targetId) {\r\n        const controlData = this.pendingControls.get(targetId);\r\n        if (!controlData) return;\r\n\r\n        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!targetTeam || !targetPos) {\r\n            this.cancelMindControl(targetId);\r\n            return;\r\n        }\r\n\r\n        // Check if any contributors are still alive and in range\r\n        const validContributors = Array.from(controlData.contributors).filter(casterId => {\r\n            const casterHealth = this.game.getComponent(casterId, this.componentTypes.HEALTH);\r\n            const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);\r\n            \r\n            if (!casterHealth || casterHealth.current <= 0 || !casterPos) return false;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(casterPos.x - targetPos.x, 2) + \r\n                Math.pow(casterPos.z - targetPos.z, 2)\r\n            );\r\n            \r\n            return distance <= this.range;\r\n        });\r\n\r\n        if (validContributors.length === 0) {\r\n            this.cancelMindControl(targetId);\r\n            return;\r\n        }\r\n\r\n        // Apply mind control\r\n        this.applyMindControl(targetId, controlData);\r\n    }\r\n\r\n    // DESYNC SAFE: Apply mind control effect\r\n    applyMindControl(targetId, controlData) {\r\n        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!targetTeam || !targetPos) return;\r\n\r\n        // Change team\r\n        targetTeam.team = controlData.team;\r\n\r\n        // Visual charm effect\r\n        this.createVisualEffect(targetPos, 'charm');\r\n\r\n       \r\n\r\n        // Clean up beams\r\n        this.clearAllBeamsForTarget(targetId);\r\n\r\n        // Remove from pending controls\r\n        this.pendingControls.delete(targetId);\r\n\r\n        // DESYNC SAFE: Schedule the mind control to expire\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.expireMindControl(targetId, controlData.originalTeam);\r\n        }, this.controlDuration, null);\r\n    }\r\n\r\n    // DESYNC SAFE: Cancel mind control attempt\r\n    cancelMindControl(targetId) {\r\n        const controlData = this.pendingControls.get(targetId);\r\n        if (!controlData) return;\r\n\r\n        // Cancel scheduled completion if it exists\r\n        if (controlData.scheduledActionId) {\r\n            this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);\r\n        }\r\n\r\n        // Clean up beams\r\n        this.clearAllBeamsForTarget(targetId);\r\n\r\n        // Remove from pending controls\r\n        this.pendingControls.delete(targetId);\r\n    }\r\n\r\n    // DESYNC SAFE: Expire mind control effect\r\n    expireMindControl(targetId, originalTeam) {\r\n        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!targetTeam) return; // Target might be dead\r\n\r\n        // Restore original team\r\n        targetTeam.team = originalTeam;\r\n\r\n        // Visual effect for mind control ending\r\n        if (targetPos) {\r\n            this.createVisualEffect(targetPos, 'control', { count: 2 });\r\n        }\r\n\r\n    \r\n    }\r\n\r\n    // DESYNC SAFE: Create visual beam effect\r\n    createBeam(casterId, targetId) {\r\n        const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!casterPos || !targetPos || !this.game.effectsSystem) return;\r\n\r\n        // Create beam using the effects system\r\n        const beamEffect = this.game.effectsSystem.createEnergyBeam(\r\n            new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),\r\n            new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),\r\n            {\r\n                style: { color: 0x8A2BE2, linewidth: 3 },\r\n                animation: { duration: 2000, pulseEffect: true }\r\n            }\r\n        );\r\n\r\n        // Track beam for cleanup\r\n        if (!this.beamRegistry.has(targetId)) {\r\n            this.beamRegistry.set(targetId, { beams: new Map() });\r\n        }\r\n        \r\n        this.beamRegistry.get(targetId).beams.set(casterId, beamEffect);\r\n    }\r\n\r\n    // DESYNC SAFE: Clear all beams for a target\r\n    clearAllBeamsForTarget(targetId) {\r\n        const entry = this.beamRegistry.get(targetId);\r\n        if (!entry) return;\r\n\r\n        // Clean up all beams for this target\r\n        for (const [casterId, beamEffect] of entry.beams.entries()) {\r\n            if (beamEffect && this.game.scene) {\r\n                try {\r\n                    this.game.scene.remove(beamEffect);\r\n                    if (beamEffect.geometry) beamEffect.geometry.dispose();\r\n                    if (beamEffect.material) beamEffect.material.dispose();\r\n                } catch (error) {\r\n                    console.warn('Error cleaning up beam:', error);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.beamRegistry.delete(targetId);\r\n    }\r\n\r\n    // DESYNC SAFE: Clear specific beam\r\n    clearBeam(casterId, targetId) {\r\n        const entry = this.beamRegistry.get(targetId);\r\n        if (!entry) return;\r\n\r\n        const beamEffect = entry.beams.get(casterId);\r\n        if (beamEffect && this.game.scene) {\r\n            try {\r\n                this.game.scene.remove(beamEffect);\r\n                if (beamEffect.geometry) beamEffect.geometry.dispose();\r\n                if (beamEffect.material) beamEffect.material.dispose();\r\n            } catch (error) {\r\n                console.warn('Error cleaning up specific beam:', error);\r\n            }\r\n        }\r\n\r\n        entry.beams.delete(casterId);\r\n        \r\n        // If no more beams for this target, remove the entry\r\n        if (entry.beams.size === 0) {\r\n            this.beamRegistry.delete(targetId);\r\n        }\r\n    }\r\n\r\n    // DESYNC SAFE: Handle when a caster dies or becomes invalid\r\n    onCasterDeath(casterId) {\r\n        // Remove from all pending controls\r\n        for (const [targetId, controlData] of this.pendingControls.entries()) {\r\n            if (controlData.contributors.has(casterId)) {\r\n                controlData.contributors.delete(casterId);\r\n                \r\n                // Clear the beam for this caster\r\n                this.clearBeam(casterId, targetId);\r\n                \r\n                // If no contributors left, cancel the mind control\r\n                if (controlData.contributors.size === 0) {\r\n                    this.cancelMindControl(targetId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // DESYNC SAFE: Handle when a target dies\r\n    onTargetDeath(targetId) {\r\n        // Clean up any pending mind control\r\n        this.cancelMindControl(targetId);\r\n    }\r\n\r\n    // DESYNC SAFE: System cleanup\r\n    destroy() {\r\n        // Cancel all pending controls\r\n        for (const [targetId, controlData] of this.pendingControls.entries()) {\r\n            if (controlData.scheduledActionId) {\r\n                this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);\r\n            }\r\n        }\r\n        this.pendingControls.clear();\r\n\r\n        // Clean up all beams\r\n        for (const [targetId] of this.beamRegistry.entries()) {\r\n            this.clearAllBeamsForTarget(targetId);\r\n        }\r\n        this.beamRegistry.clear();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MindControlAbility.js",
        "fileName": "MindControlAbility"
      },
      "DisruptionBombAbility": {
        "script": "class DisruptionBombAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'disruption_bomb',\r\n            name: 'Disruption Bomb',\r\n            description: 'Throw a bomb that disables enemy abilities and equipment (effects do not stack)',\r\n            cooldown: 16.0,\r\n            range: 130,\r\n            manaCost: 40,\r\n            targetType: 'area',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 1.3,\r\n            ...params\r\n        });\r\n        \r\n        this.explosionRadius = 90;\r\n        this.disruptionDuration = 12.0;\r\n        this.accuracyReduction = 0.4; // 40% accuracy reduction\r\n        this.movementSlowed = 0.6; // Movement slowed to 60%\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF4500,\r\n                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.8\r\n                }\r\n            },\r\n            explosion: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8A2BE2,\r\n                    colorRange: { start: 0x8A2BE2, end: 0x4B0082 },\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            disruption: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x9932CC,\r\n                    scaleMultiplier: 1.3,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        // Only use if there are at least 2 enemies to disrupt\r\n        return enemies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(pos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Saboteur prepares a disruption bomb!`);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for bomb throw and explosion\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.throwDisruptionBomb(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    throwDisruptionBomb(casterEntity) {\r\n        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        if (!casterHealth || casterHealth.current <= 0) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        \r\n        // DESYNC SAFE: Find best cluster position deterministically\r\n        const clusterPos = this.findBestClusterPosition(enemies, 2);\r\n        const targetPos = clusterPos || pos;\r\n        \r\n        // Visual explosion effect\r\n        this.createVisualEffect(targetPos, 'explosion');\r\n        \r\n        // Screen effects for dramatic explosion\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.showExplosionEffect(targetPos.x, targetPos.y, targetPos.z);\r\n            this.game.effectsSystem.playScreenShake(0.4, 2);\r\n            this.game.effectsSystem.playScreenFlash('#8A2BE2', 0.3);\r\n        }\r\n        \r\n        // DESYNC SAFE: Apply disruption effects deterministically\r\n        this.applyDisruptionEffects(casterEntity, enemies, targetPos);\r\n    }\r\n    \r\n    // DESYNC SAFE: Apply disruption effects to enemies in range\r\n    applyDisruptionEffects(casterEntity, enemies, bombPos) {\r\n        // Sort enemies for consistent processing order\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let disruptedCount = 0;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            \r\n            // Only affect living enemies\r\n            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;\r\n            \r\n            // Check if enemy is in explosion radius\r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - bombPos.x, 2) + \r\n                Math.pow(enemyPos.z - bombPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.explosionRadius) {\r\n                // DESYNC SAFE: Check if already disrupted - don't stack disruptions\r\n                const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n                \r\n                if (existingBuff && existingBuff.buffType === 'disrupted') {\r\n                    // DESYNC SAFE: Just refresh duration instead of stacking\r\n                    existingBuff.endTime = this.game.state.now + this.disruptionDuration;\r\n                    existingBuff.appliedTime = this.game.state.now;\r\n                } else {\r\n                    // Apply new disruption buff\r\n                    const Components = this.game.componentManager.getComponents();\r\n                    this.game.addComponent(enemyId, this.componentTypes.BUFF, \r\n                        Components.Buff('disrupted', { \r\n                            abilitiesDisabled: true,\r\n                            accuracyReduction: this.accuracyReduction,\r\n                            movementSlowed: this.movementSlowed\r\n                        }, this.game.state.now + this.disruptionDuration, false, 1, this.game.state.now));\r\n                    \r\n                    // DESYNC SAFE: Schedule disruption removal\r\n                    this.game.schedulingSystem.scheduleAction(() => {\r\n                        this.removeDisruption(enemyId);\r\n                    }, this.disruptionDuration, enemyId);\r\n                }\r\n                \r\n                // Visual disruption effect on each affected enemy\r\n                this.createVisualEffect(enemyPos, 'disruption');\r\n                \r\n                disruptedCount++;\r\n            }\r\n        });\r\n        \r\n       \r\n    }\r\n    \r\n    // DESYNC SAFE: Find best cluster position deterministically\r\n    findBestClusterPosition(enemies, minCluster = 2) {\r\n        if (enemies.length < minCluster) return null;\r\n        \r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let bestPos = null;\r\n        let bestScore = 0;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!pos) return;\r\n            \r\n            // Count nearby enemies within explosion radius\r\n            let nearbyCount = 0;\r\n            sortedEnemies.forEach(otherId => {\r\n                if (otherId === enemyId) return;\r\n                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);\r\n                if (!otherPos) return;\r\n                \r\n                const distance = Math.sqrt(\r\n                    Math.pow(pos.x - otherPos.x, 2) + \r\n                    Math.pow(pos.z - otherPos.z, 2)\r\n                );\r\n                \r\n                if (distance <= this.explosionRadius) nearbyCount++;\r\n            });\r\n            \r\n            // Use >= for consistent tie-breaking (first in sorted order wins)\r\n            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {\r\n                bestScore = nearbyCount;\r\n                bestPos = { x: pos.x, y: pos.y, z: pos.z };\r\n            }\r\n        });\r\n        \r\n        return bestPos;\r\n    }\r\n    \r\n    // DESYNC SAFE: Remove disruption effect\r\n    removeDisruption(enemyId) {\r\n        // Check if enemy still exists and has the disruption buff\r\n        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'disrupted') {\r\n                this.game.removeComponent(enemyId, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when disruption expires\r\n                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (enemyPos) {\r\n                    this.createVisualEffect(enemyPos, 'disruption', { \r\n                        count: 3, \r\n                        scaleMultiplier: 0.8,\r\n                        color: 0x87CEEB \r\n                    });\r\n                }\r\n                \r\n           \r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DisruptionBombAbility.js",
        "fileName": "DisruptionBombAbility"
      },
      "ShieldWallAbility": {
        "script": "class ShieldWallAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'shield_wall',\r\n            name: 'Shield Wall',\r\n            description: 'Form a defensive stance, reducing damage and taunting enemies',\r\n            cooldown: 12.0,\r\n            range: 0, // Self-buff with taunt radius\r\n            manaCost: 30,\r\n            targetType: 'self',\r\n            animation: 'cast',\r\n            priority: 4,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.wallDuration = 10.0;\r\n        this.damageReduction = 0.75; // 75% damage reduction\r\n        this.tauntRadius = 200;\r\n        this.originalArmorMultiplier = 1.0;\r\n        this.element = 'physical';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x708090,\r\n                    colorRange: { start: 0x708090, end: 0xC0C0C0 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            shield_formation: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4682B4,\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            defensive_stance: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x2F4F4F,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 0.6\r\n                }\r\n            },\r\n            taunt_aura: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF6347,\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        // Check if already has shield wall to prevent stacking\r\n        const existingWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);\r\n        if (existingWall && existingWall.isActive) return false;\r\n        \r\n        // Use when enemies are nearby and threatening\r\n        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Soldier prepares to form a shield wall...`);\r\n        \r\n        // Schedule the shield wall formation after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.formShieldWall(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    formShieldWall(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);\r\n        \r\n        if (!casterPos) return;\r\n        \r\n        // Create shield formation effect\r\n        this.createVisualEffect(casterPos, 'shield_formation');\r\n        \r\n        // Store original armor for restoration later\r\n        const originalArmor = casterCombat ? casterCombat.armor : 0;\r\n        \r\n        // Apply shield wall component with proper timing\r\n        const Components = this.game.componentManager.getComponents();\r\n        const currentTime = this.game.state.now || this.game.state.now || 0;\r\n        const endTime = currentTime + this.wallDuration;\r\n        \r\n        this.game.addComponent(casterEntity, this.componentTypes.SHIELD_WALL, \r\n            Components.ShieldWall(\r\n                this.damageReduction,\r\n                endTime,\r\n                this.tauntRadius,\r\n                originalArmor\r\n            )\r\n        );\r\n        \r\n        // Schedule defensive stance visual effect\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n            if (pos) {\r\n                this.createVisualEffect(pos, 'defensive_stance');\r\n            }\r\n        }, 0.5, casterEntity);\r\n        \r\n        // Apply taunt effect to nearby enemies\r\n        this.applyTauntToEnemies(casterEntity);\r\n        \r\n        // Screen effects for dramatic formation\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.3, 1);\r\n        }\r\n        \r\n    \r\n      \r\n        \r\n        // Schedule shield wall expiration warning\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.warnShieldWallEnding(casterEntity);\r\n        }, this.wallDuration - 1.5, casterEntity);\r\n        \r\n        // Schedule shield wall removal (failsafe)\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.removeShieldWall(casterEntity);\r\n        }, this.wallDuration, casterEntity);\r\n    }\r\n    \r\n    applyTauntToEnemies(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Sort enemies deterministically for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let tauntedCount = 0;\r\n        \r\n        sortedEnemies.forEach((enemyId, index) => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyAI = this.game.getComponent(enemyId, this.componentTypes.AI_STATE);\r\n            \r\n            if (!enemyPos || !enemyAI) return;\r\n            \r\n            // Apply taunt component\r\n            const Components = this.game.componentManager.getComponents();\r\n            const currentTime = this.game.state.now || this.game.state.now || 0;\r\n            const tauntEndTime = currentTime + (this.wallDuration * 0.8); // Taunt lasts 80% of shield wall\r\n            \r\n            this.game.addComponent(enemyId, this.componentTypes.TAUNT, \r\n                Components.Taunt(\r\n                    casterEntity,     // Taunter\r\n                    tauntEndTime,     // End time\r\n                    this.tauntRadius, // Radius\r\n                    true              // Is taunted\r\n                )\r\n            );\r\n            \r\n            // Force AI to target the shield wall user\r\n  \r\n            enemyAI.target = casterEntity;\r\n            enemyAI.targetPosition = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n            enemyAI.path = [];\r\n            enemyAI.meta = {};\r\n        \r\n            // Schedule staggered taunt effects for visual appeal\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (pos) {\r\n                    this.createVisualEffect(pos, 'taunt_aura');\r\n                }\r\n            }, index * 0.1, enemyId);\r\n            \r\n            tauntedCount++;\r\n        });\r\n        \r\n        if (tauntedCount > 0) {\r\n            this.logAbilityUsage(casterEntity, \r\n                `Shield wall taunts ${tauntedCount} enemies to attack!`);\r\n        }\r\n    }\r\n    \r\n    // FIXED: Shield wall ending warning\r\n    warnShieldWallEnding(casterEntity) {\r\n        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        // Check if shield wall still exists and is active\r\n        if (!shieldWall || !shieldWall.isActive || !casterPos) return;\r\n        \r\n        // Create warning effect\r\n        this.createVisualEffect(casterPos, 'cast', { \r\n            count: 4, \r\n            color: 0x708090,\r\n            scaleMultiplier: 0.8 \r\n        });\r\n     \r\n    }\r\n    \r\n    // FIXED: Proper shield wall removal\r\n    removeShieldWall(casterEntity) {\r\n        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!shieldWall) return;\r\n        \r\n        // Create dissolution effect\r\n        if (casterPos) {\r\n            this.createVisualEffect(casterPos, 'defensive_stance', { \r\n                count: 6, \r\n                scaleMultiplier: 0.6 \r\n            });\r\n        }\r\n        \r\n        // Remove shield wall component\r\n        this.game.removeComponent(casterEntity, this.componentTypes.SHIELD_WALL);\r\n        \r\n       \r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShieldWallAbility.js",
        "fileName": "ShieldWallAbility"
      },
      "BaseAbility": {
        "fileName": "BaseAbility",
        "script": "class BaseAbility {\r\n    constructor(game, config = {}) {\r\n        this.game = game;\r\n        this.id = config.id || 'unknown';\r\n        this.name = config.name || 'Unknown Ability';\r\n        this.description = config.description || '';\r\n        this.cooldown = config.cooldown || 10.0;\r\n        this.range = config.range || 100;\r\n        this.manaCost = config.manaCost || 0;\r\n        this.targetType = config.targetType || 'auto';\r\n        this.animation = config.animation || 'cast';\r\n        this.priority = config.priority || 5;\r\n        this.castTime = config.castTime || 1.5;\r\n        this.autoTrigger = config.autoTrigger || 'combat';\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        this.effects = this.defineEffects();\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: { type: 'magic', options: { count: 15, scaleMultiplier: 0.8, speedMultiplier: 0.6 } },\r\n            impact: { type: 'magic', options: { count: 10, scaleMultiplier: 1.2 } }\r\n        };\r\n    }\r\n    \r\n    createVisualEffect(position, effectName = 'cast', customOptions = {}) {\r\n        if (!this.game.effectsSystem) return;\r\n        \r\n        const effectDef = this.effects[effectName];\r\n        if (effectDef) {\r\n            const mergedOptions = { ...effectDef.options, ...customOptions, heightOffset: customOptions.heightOffset || 0 };\r\n            this.game.effectsSystem.createParticleEffect(position.x, position.y + mergedOptions.heightOffset, position.z, effectDef.type, mergedOptions);\r\n        } else {\r\n            this.game.effectsSystem.createParticleEffect(position.x, position.y + customOptions.heightOffset || 0, position.z, 'magic', customOptions);\r\n        }\r\n    }\r\n    \r\n    logAbilityUsage(casterEntity, message = null, showScreenEffect = false) {\r\n      \r\n    }\r\n    \r\n    dealDamageWithEffects(sourceId, targetId, damage, element = 'physical', options = {}) {\r\n        if (this.game.damageSystem) {\r\n            const result = this.game.damageSystem.applyDamage(sourceId, targetId, damage, element, { isSpell: true, ...options });\r\n            \r\n            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n            if (targetPos && this.game.effectsSystem) {\r\n                const effectType = result.isCritical ? 'critical' : 'damage';\r\n                this.game.effectsSystem.showDamageNumber(targetPos.x, targetPos.y + 15, targetPos.z, result.damage, effectType);\r\n                this.createVisualEffect(targetPos, 'impact');\r\n            }\r\n            \r\n            return result;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    // FIXED: Entities already sorted from getEntitiesWith()\r\n    getEnemiesInRange(casterEntity, range = null) {\r\n        const effectiveRange = range || this.range;\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        \r\n        if (!casterPos || !casterTeam) return [];\r\n        \r\n        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)\r\n            .filter(entityId => {\r\n                if (entityId === casterEntity) return false;\r\n                \r\n                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n                \r\n                if (!pos || !team || !health || health.current <= 0) return false;\r\n                if (team.team === casterTeam.team) return false;\r\n                \r\n                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));\r\n                return distance <= effectiveRange;\r\n            });\r\n    }\r\n    \r\n    // FIXED: Entities already sorted from getEntitiesWith()\r\n    getAlliesInRange(casterEntity, range = null) {\r\n        const effectiveRange = range || this.range;\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        \r\n        if (!casterPos || !casterTeam) return [];\r\n        \r\n        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)\r\n            .filter(entityId => {\r\n                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n                \r\n                if (!pos || !team || !health || health.current <= 0) return false;\r\n                if (team.team !== casterTeam.team) return false;\r\n                \r\n                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));\r\n                return distance <= effectiveRange;\r\n            });\r\n    }\r\n    \r\n    // FIXED: Entities already sorted, remove redundant sorting\r\n    findBestClusterPosition(entities, minCluster = 2) {\r\n        if (entities.length < minCluster) return null;\r\n        \r\n        let bestPos = null;\r\n        let bestScore = 0;\r\n        \r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            if (!pos) return;\r\n            \r\n            let nearbyCount = 0;\r\n            entities.forEach(otherId => {\r\n                if (otherId === entityId) return;\r\n                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);\r\n                if (!otherPos) return;\r\n                \r\n                const distance = Math.sqrt(Math.pow(pos.x - otherPos.x, 2) + Math.pow(pos.z - otherPos.z, 2));\r\n                if (distance <= 80) nearbyCount++;\r\n            });\r\n            \r\n            // Use >= for consistent tie-breaking (first in sorted order wins)\r\n            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {\r\n                bestScore = nearbyCount;\r\n                bestPos = { x: pos.x, y: pos.y, z: pos.z };\r\n            }\r\n        });\r\n        \r\n        return bestPos;\r\n    }\r\n    onBattleEnd() {\r\n    }\r\n    canExecute(casterEntity) { return true; }\r\n    execute(casterEntity, targetData = null) { console.log(`${this.name} executed by entity ${casterEntity}`); }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BaseAbility.js"
      },
      "ChainLightningAbility": {
        "fileName": "ChainLightningAbility",
        "script": "class ChainLightningAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'chain_lightning',\r\n            name: 'Chain Lightning',\r\n            description: 'Lightning that jumps between multiple enemies',\r\n            cooldown: 4.0,\r\n            range: 250,\r\n            manaCost: 40,\r\n            targetType: 'enemy',\r\n            animation: 'cast',\r\n            priority: 7,\r\n            castTime: 1,\r\n            ...params\r\n        });\r\n        \r\n        this.initialDamage = 60;\r\n        this.maxJumps = 5;\r\n        this.jumpRange = 70;\r\n        this.damageReduction = 0.8;\r\n        this.element = 'lightning';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x00aaff,\r\n                    colorRange: { start: 0x00aaff, end: 0x88aaff },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 2.0\r\n                }\r\n            },\r\n            lightning: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x00ccff,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 3.0\r\n                }\r\n            },\r\n            arc: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88aaff,\r\n                    scaleMultiplier: 0.8,\r\n                    speedMultiplier: 2.5\r\n                }\r\n            },\r\n            impact: {\r\n                type: 'damage',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x00aaff,\r\n                    scaleMultiplier: 1.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length >= 1;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Initial cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n   \r\n        // DESYNC SAFE: Find closest enemy deterministically\r\n        const firstTarget = this.findClosestEnemy(casterEntity, enemies);\r\n        if (!firstTarget) return;\r\n               \r\n        this.startChainLightning(casterEntity, firstTarget, enemies);\r\n    }\r\n    \r\n    // DESYNC SAFE: Start the chain lightning sequence deterministically\r\n    startChainLightning(sourceId, firstTarget, availableTargets) {\r\n        const hitTargets = []; // Track which targets have been hit\r\n        \r\n        // Process the entire chain synchronously to avoid timing issues\r\n        this.processLightningChain(sourceId, firstTarget, availableTargets, hitTargets, this.maxJumps, this.initialDamage, 0);\r\n    }\r\n    \r\n    // DESYNC SAFE: Process the entire lightning chain deterministically\r\n    processLightningChain(sourceId, currentTarget, availableTargets, hitTargets, remainingJumps, damage, jumpIndex) {\r\n        if (remainingJumps <= 0 || !currentTarget || hitTargets.includes(currentTarget)) {\r\n            return;\r\n        }\r\n        \r\n        const targetPos = this.game.getComponent(currentTarget, this.componentTypes.POSITION);\r\n        if (!targetPos) return;\r\n        \r\n        // Add target to hit list\r\n        hitTargets.push(currentTarget);\r\n        \r\n        // Schedule this jump's effects with a small delay for visual appeal\r\n        const jumpDelay = jumpIndex * 0.15; // 150ms between jumps\r\n        \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            // Lightning strike effect\r\n            this.createVisualEffect(targetPos, 'lightning');\r\n            \r\n            // Apply damage\r\n            this.dealDamageWithEffects(sourceId, currentTarget, Math.floor(damage), this.element);\r\n            \r\n            // Screen flash for dramatic effect (only on first hit)\r\n            if (this.game.effectsSystem && jumpIndex === 0) {\r\n                this.game.effectsSystem.playScreenFlash('#00aaff', 0.2);\r\n            }\r\n            \r\n            // Create visual arc effect if there was a previous target\r\n            if (jumpIndex > 0) {\r\n                const previousTarget = hitTargets[jumpIndex - 1];\r\n                const previousPos = this.game.getComponent(previousTarget, this.componentTypes.POSITION);\r\n                if (previousPos) {\r\n                    this.createLightningArc(previousPos, targetPos);\r\n                }\r\n            }\r\n        }, jumpDelay, sourceId);\r\n        \r\n        // DESYNC SAFE: Find next target deterministically\r\n        const nextTarget = this.findNextChainTarget(currentTarget, availableTargets, hitTargets);\r\n        \r\n        if (nextTarget && remainingJumps > 1) {\r\n            // Recursively process the next jump\r\n            this.processLightningChain(\r\n                sourceId, \r\n                nextTarget, \r\n                availableTargets, \r\n                hitTargets, \r\n                remainingJumps - 1, \r\n                damage * this.damageReduction, \r\n                jumpIndex + 1\r\n            );\r\n        }\r\n    }\r\n    \r\n    // DESYNC SAFE: Find closest enemy deterministically\r\n    findClosestEnemy(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            // Use < for consistent tie-breaking (first in sorted order wins)\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closest = enemyId;\r\n            }\r\n        });\r\n        \r\n        return closest;\r\n    }\r\n    \r\n    // DESYNC SAFE: Find next chain target deterministically\r\n    findNextChainTarget(fromTarget, availableTargets, hitTargets) {\r\n        const fromPos = this.game.getComponent(fromTarget, this.componentTypes.POSITION);\r\n        if (!fromPos) return null;\r\n        \r\n        // Sort targets deterministically first\r\n        const sortedTargets = availableTargets.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let closest = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        sortedTargets.forEach(targetId => {\r\n            if (targetId === fromTarget || hitTargets.includes(targetId)) return;\r\n            \r\n            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n            if (!targetPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(targetPos.x - fromPos.x, 2) + \r\n                Math.pow(targetPos.z - fromPos.z, 2)\r\n            );\r\n            \r\n            // Use < for consistent tie-breaking\r\n            if (distance <= this.jumpRange && distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closest = targetId;\r\n            }\r\n        });\r\n        \r\n        return closest;\r\n    }\r\n    \r\n    createLightningArc(fromPos, toPos) {\r\n        if (!this.game.scene) return;\r\n        \r\n        // Create lightning bolt geometry with deterministic path (no random)\r\n        const points = this.generateDeterministicLightningPath(fromPos, toPos);\r\n        const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n        \r\n        // Create lightning material\r\n        const material = new THREE.LineBasicMaterial({\r\n            color: 0x00ddff,\r\n            linewidth: 3,\r\n            transparent: true,\r\n            opacity: 1.0,\r\n            blending: THREE.AdditiveBlending\r\n        });\r\n        \r\n        // Create the lightning line\r\n        const lightningLine = new THREE.Line(geometry, material);\r\n        this.game.scene.add(lightningLine);\r\n        \r\n        // Animate the lightning arc\r\n        this.animateLightningArc(lightningLine, material);\r\n        \r\n        // Add bright points at connection points\r\n        this.createLightningPoints(fromPos, toPos);\r\n    }\r\n    \r\n    // DESYNC SAFE: Generate deterministic lightning path (no random)\r\n    generateDeterministicLightningPath(fromPos, toPos) {\r\n        const points = [];\r\n        const segments = 3; // Number of lightning segments\r\n        \r\n        points.push(new THREE.Vector3(\r\n            fromPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),\r\n            fromPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,\r\n            fromPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)\r\n        ));\r\n        \r\n        // Create jagged lightning path using deterministic values\r\n        for (let i = 1; i < segments; i++) {\r\n            const progress = i / segments;\r\n            \r\n            // Linear interpolation between start and end\r\n            const baseX = fromPos.x + (toPos.x - fromPos.x) * progress;\r\n            const baseY = fromPos.y + (toPos.y - fromPos.y) * progress + 10;\r\n            const baseZ = fromPos.z + (toPos.z - fromPos.z) * progress;\r\n            \r\n            // Add deterministic jagged deviation based on segment index\r\n            const deviation = 15; // Maximum deviation from straight line\r\n            const jaggedX = baseX + (((i * 37) % 100) / 100 - 0.5) * deviation; // Deterministic \"random\"\r\n            const jaggedY = baseY + (((i * 73) % 100) / 100 - 0.5) * deviation * 0.5;\r\n            const jaggedZ = baseZ + (((i * 91) % 100) / 100 - 0.5) * deviation;\r\n            \r\n            points.push(new THREE.Vector3(\r\n                jaggedX + (this.game.effectsSystem?.effectOffset?.x || 0),\r\n                jaggedY + (this.game.effectsSystem?.effectOffset?.y || 0),\r\n                jaggedZ + (this.game.effectsSystem?.effectOffset?.z || 0)\r\n            ));\r\n        }\r\n        \r\n        points.push(new THREE.Vector3(\r\n            toPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),\r\n            toPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,\r\n            toPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)\r\n        ));\r\n        \r\n        return points;\r\n    }\r\n    \r\n    animateLightningArc(lightningLine, material) {\r\n        // Use game time for deterministic animation instead of real time\r\n        const startTime = this.game.state.now;\r\n        const animationDuration = 0.48; // 480ms in game time\r\n        const flickerInterval = 0.08; // 80ms in game time\r\n        \r\n        // DESYNC SAFE: Use scheduling system for animation frames\r\n        const animateFrame = (frameIndex) => {\r\n            const currentTime = this.game.state.now;\r\n            const elapsed = currentTime - startTime;\r\n            \r\n            if (elapsed >= animationDuration) {\r\n                // Fade out and remove\r\n                this.fadeLightningArc(lightningLine, material);\r\n                return;\r\n            }\r\n            \r\n            // Deterministic flicker effect based on frame index\r\n            material.opacity = 0.2 + 0.6 * ((frameIndex % 3) / 2); // Cycles between 0.2, 0.5, 0.8\r\n            material.color.setHex((frameIndex % 2) === 0 ? 0x00ddff : 0x88aaff);\r\n            \r\n            // Schedule next frame\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                animateFrame(frameIndex + 1);\r\n            }, flickerInterval, null);\r\n        };\r\n        \r\n        animateFrame(0);\r\n    }\r\n    \r\n    fadeLightningArc(lightningLine, material) {\r\n        // Quick cleanup instead of complex fade animation for multiplayer safety\r\n        if (this.game.scene && lightningLine.parent) {\r\n            this.game.scene.remove(lightningLine);\r\n            lightningLine.geometry.dispose();\r\n            lightningLine.material.dispose();\r\n        }\r\n    }\r\n    \r\n    createLightningPoints(fromPos, toPos) {\r\n        // Create bright particle effects at connection points\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.createParticleEffect(\r\n                fromPos.x, fromPos.y + 10, fromPos.z, 'magic', {\r\n                    count: 5,\r\n                    color: 0x00ddff,\r\n                    scaleMultiplier: 0.8,\r\n                    speedMultiplier: 2.0,\r\n                    heightOffset: 0\r\n                }\r\n            );\r\n            \r\n            // DESYNC SAFE: Use scheduling system for delayed effect\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                if (this.game.effectsSystem) {\r\n                    this.game.effectsSystem.createParticleEffect(\r\n                        toPos.x, toPos.y + 10, toPos.z, 'magic', {\r\n                            count: 5,\r\n                            color: 0x00ddff,\r\n                            scaleMultiplier: 0.8,\r\n                            speedMultiplier: 2.0,\r\n                            heightOffset: 0\r\n                        }\r\n                    );\r\n                }\r\n            }, 0.1, null);\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChainLightningAbility.js"
      },
      "MassHealAbility": {
        "fileName": "MassHealAbility",
        "script": "class MassHealAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'mass_heal',\r\n            name: 'Mass Heal',\r\n            description: 'Heal all injured allies across the battlefield',\r\n            cooldown: 15.0,\r\n            range: 300,\r\n            manaCost: 60,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 9,\r\n            castTime: 2.0,\r\n            autoTrigger: 'low_team_health',\r\n            ...params\r\n        });\r\n        \r\n        this.healPercent = 0.4; // 40% of max health\r\n        this.minInjuredAllies = 3;\r\n        this.element = 'divine';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88ff88,\r\n                    colorRange: { start: 0x88ff88, end: 0xffffaa },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            heal: {\r\n                type: 'heal',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88ffaa,\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            mass_heal: {\r\n                type: 'heal',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xaaffaa,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 0.6\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const injuredAllies = this.getInjuredAllies(allies);\r\n        return injuredAllies.length >= this.minInjuredAllies;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const injuredAllies = this.getInjuredAllies(allies);\r\n        \r\n        if (injuredAllies.length < this.minInjuredAllies) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Divine energy gathers to heal the wounded!`);\r\n        \r\n        // Schedule the mass heal to trigger after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performMassHeal(casterEntity, injuredAllies);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performMassHeal(casterEntity, targetAllies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        let healedCount = 0;\r\n        let totalHealing = 0;\r\n        \r\n        // Sort allies deterministically for consistent processing order\r\n        const sortedAllies = targetAllies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        // Process each ally deterministically\r\n        sortedAllies.forEach(allyId => {\r\n            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            \r\n            if (!health || !allyPos) return;\r\n            \r\n            // Only heal if ally is still injured\r\n            if (health.current < health.max) {\r\n                const healAmount = Math.floor(health.max * this.healPercent);\r\n                const actualHeal = Math.min(healAmount, health.max - health.current);\r\n                \r\n                if (actualHeal > 0) {\r\n                    // Apply healing\r\n                    health.current += actualHeal;\r\n                    healedCount++;\r\n                    totalHealing += actualHeal;\r\n                    \r\n                    // Create heal effect on each ally\r\n                    this.createVisualEffect(allyPos, 'heal');\r\n                    \r\n                    // Show heal number\r\n                    if (this.game.effectsSystem) {\r\n                        this.game.effectsSystem.showDamageNumber(\r\n                            allyPos.x, allyPos.y + 50, allyPos.z,\r\n                            actualHeal, 'heal'\r\n                        );\r\n                    }\r\n                \r\n                }\r\n            }\r\n        });\r\n        \r\n        // Create major healing effect at caster position\r\n        if (casterPos && healedCount > 0) {\r\n            this.createVisualEffect(casterPos, 'mass_heal');\r\n        }\r\n        \r\n        // Screen effect for dramatic impact\r\n        if (this.game.effectsSystem && healedCount > 0) {\r\n            this.game.effectsSystem.playScreenFlash('#88ff88', 0.3);\r\n        }\r\n        \r\n        // Log final results\r\n        this.logAbilityUsage(casterEntity, \r\n            `Mass heal restores ${healedCount} allies for ${totalHealing} total health!`);\r\n    }\r\n    \r\n    // FIXED: Deterministic injured ally detection\r\n    getInjuredAllies(allies) {\r\n        // Sort allies deterministically first for consistent processing\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        return sortedAllies.filter(allyId => {\r\n            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            // Check if ally is injured (below 80% health threshold)\r\n            return health && health.current < health.max * 0.8;\r\n        });\r\n    }\r\n    \r\n    // Helper method to get all valid heal targets (for future use)\r\n    getAllHealTargets(allies) {\r\n        // Sort allies deterministically first for consistent processing\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        return sortedAllies.filter(allyId => {\r\n            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            // Any ally that isn't at full health\r\n            return health && health.current < health.max;\r\n        });\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MassHealAbility.js"
      },
      "FireStormAbility": {
        "fileName": "FireStormAbility",
        "script": "class FirestormAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'fireStorm',\r\n            name: 'Fire Storm',\r\n            description: 'Rain fire on the largest enemy cluster',\r\n            cooldown: 12.0,\r\n            range: 200,\r\n            manaCost: 50,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 8,\r\n            castTime: 2.5,\r\n            autoTrigger: 'enemy_cluster',\r\n            ...params\r\n        });\r\n        \r\n        this.stormRadius = 90;\r\n        this.damage = 70;\r\n        this.element = 'fire';\r\n        this.minTargets = 3;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff2200,\r\n                    colorRange: { start: 0xff2200, end: 0xffaa00 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            firestorm: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff4400,\r\n                    colorRange: { start: 0xff4400, end: 0xff0000 },\r\n                    scaleMultiplier: 2.5,\r\n                    speedMultiplier: 0.6\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);\r\n        return clusterPos !== null;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);\r\n        \r\n        if (!clusterPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `The sky darkens as firestorm approaches!`);\r\n        \r\n        // Schedule the firestorm to hit after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performFirestorm(casterEntity, clusterPos);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performFirestorm(casterEntity, targetPos) {\r\n        // Create firestorm visual effect\r\n        this.createVisualEffect(targetPos, 'firestorm');\r\n        \r\n        // Apply fire damage to all enemies in storm area\r\n        if (this.game.damageSystem) {\r\n            const results = this.game.damageSystem.applySplashDamage(\r\n                casterEntity,\r\n                targetPos,\r\n                this.damage,\r\n                this.element,\r\n                this.stormRadius,\r\n                { allowFriendlyFire: false, isSpell: true }\r\n            );\r\n            \r\n            this.logAbilityUsage(casterEntity, \r\n                `Firestorm engulfs ${results.length} enemies in flames!`);\r\n        }\r\n    }\r\n    \r\n    // FIXED: Deterministic cluster position finding\r\n    findBestClusterPosition(enemies, minTargets) {\r\n        if (enemies.length < minTargets) return null;\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let bestPosition = null;\r\n        let maxTargetsHit = 0;\r\n        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance\r\n        \r\n        // Check each enemy position as potential cluster center\r\n        sortedEnemies.forEach(potentialCenter => {\r\n            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);\r\n            if (!centerPos) return;\r\n            \r\n            let targetsInRange = 0;\r\n            let totalDistance = 0;\r\n            \r\n            // Count enemies within storm radius of this position\r\n            sortedEnemies.forEach(enemyId => {\r\n                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (!enemyPos) return;\r\n                \r\n                const distance = Math.sqrt(\r\n                    Math.pow(enemyPos.x - centerPos.x, 2) + \r\n                    Math.pow(enemyPos.z - centerPos.z, 2)\r\n                );\r\n                \r\n                if (distance <= this.stormRadius) {\r\n                    targetsInRange++;\r\n                    totalDistance += distance;\r\n                }\r\n            });\r\n            \r\n            // Only consider positions that hit minimum targets\r\n            if (targetsInRange >= minTargets) {\r\n                // Calculate score: prioritize more targets, then lower total distance for tie-breaking\r\n                const score = (targetsInRange * 1000) - totalDistance;\r\n                \r\n                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)\r\n                if (targetsInRange > maxTargetsHit || \r\n                    (targetsInRange === maxTargetsHit && score >= bestScore)) {\r\n                    maxTargetsHit = targetsInRange;\r\n                    bestScore = score;\r\n                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };\r\n                }\r\n            }\r\n        });\r\n        \r\n        return bestPosition;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireStormAbility.js"
      },
      "RaiseDeadAbility": {
        "fileName": "RaiseDeadAbility",
        "script": "class RaiseDeadAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'raise_dead',\r\n            name: 'Raise Dead',\r\n            description: 'Convert corpses into skeleton warriors',\r\n            cooldown: 1.0,\r\n            range: 150,\r\n            manaCost: 0,\r\n            targetType: 'auto',\r\n            animation: 'cast',\r\n            priority: 1,\r\n            castTime: 1.0,\r\n            autoTrigger: 'corpses_available',\r\n            ...params\r\n        });\r\n        \r\n        this.maxCorpsesToRaise = 4;\r\n        this.raisedUnitType = '0_skeleton';\r\n        this.element = 'dark';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x4B0082,\r\n                    colorRange: { start: 0x4B0082, end: 0x8B008B },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            raise_dead: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x8B008B,\r\n                    colorRange: { start: 0x8B008B, end: 0x32CD32 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.5\r\n                }\r\n            },\r\n            necromancy: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x228B22,\r\n                    scaleMultiplier: 1.8,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        if (!this.game.deathSystem) return false;\r\n        \r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return false;\r\n        \r\n        const validCorpses = this.getValidCorpsesInRange(casterPos);\r\n        return validCorpses.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        \r\n        if (!this.game.deathSystem || !casterPos || !casterTeam) return null;\r\n        \r\n        const validCorpses = this.getValidCorpsesInRange(casterPos);\r\n        if (validCorpses.length === 0) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Dark magic stirs the dead...`);\r\n        \r\n        // Schedule the necromancy after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performRaiseDeadRitual(casterEntity, validCorpses, casterTeam.team);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performRaiseDeadRitual(casterEntity, validCorpses, team) {\r\n        const collections = this.game.getCollections();\r\n        if (!collections?.units?.[this.raisedUnitType]) {\r\n            console.warn(`${this.raisedUnitType} unit type not found`);\r\n            return;\r\n        }\r\n        \r\n        const skeletonDef = collections.units[this.raisedUnitType];\r\n        \r\n        // Sort corpses deterministically for consistent processing order\r\n        const sortedCorpses = this.sortCorpsesDeterministically(validCorpses);\r\n        const corpsesToRaise = sortedCorpses.slice(0, this.maxCorpsesToRaise);\r\n        \r\n        let raisedCount = 0;\r\n        const raisedSkeletons = [];\r\n        \r\n        // Process corpses in deterministic order\r\n        corpsesToRaise.forEach((corpseData, index) => {\r\n            const consumedCorpse = this.game.deathSystem.consumeCorpse(corpseData.entityId);\r\n            if (!consumedCorpse) return;\r\n            \r\n            const skeletonId = this.createSkeletonFromCorpse(\r\n                corpseData.position, \r\n                skeletonDef, \r\n                team, \r\n                index\r\n            );\r\n            \r\n            if (skeletonId !== null) {\r\n                raisedCount++;\r\n                raisedSkeletons.push(skeletonId);\r\n                \r\n                // Create raising effect\r\n                this.createVisualEffect(corpseData.position, 'raise_dead');\r\n                this.logCorpseRaising(consumedCorpse, team);\r\n                \r\n                // Schedule a delayed necromancy effect for dramatic flair\r\n                this.game.schedulingSystem.scheduleAction(() => {\r\n                    this.createVisualEffect(corpseData.position, 'necromancy');\r\n                }, 0.5, skeletonId);\r\n            }\r\n        });\r\n        \r\n        if (raisedCount > 0) {\r\n            this.logAbilityUsage(casterEntity, \r\n                `Necromancy raises ${raisedCount} skeleton${raisedCount > 1 ? 's' : ''} from the dead!`);\r\n                \r\n            // Screen effect for dramatic impact\r\n            if (this.game.effectsSystem) {\r\n                this.game.effectsSystem.playScreenFlash('#4B0082', 0.4);\r\n            }\r\n        }\r\n    }\r\n    \r\n    // FIXED: Deterministic corpse validation and retrieval\r\n    getValidCorpsesInRange(casterPos) {\r\n        const nearbyCorpses = this.game.deathSystem.getCorpsesInRange(casterPos, this.range);\r\n        \r\n        // Filter out corpses that are already the raised unit type (prevent re-raising skeletons)\r\n        const validCorpses = nearbyCorpses.filter(corpseData => {\r\n            return corpseData.corpse.originalUnitType.id !== this.raisedUnitType;\r\n        });\r\n        \r\n        return validCorpses;\r\n    }\r\n    \r\n    // FIXED: Deterministic corpse sorting\r\n    sortCorpsesDeterministically(corpses) {\r\n        return corpses.slice().sort((a, b) => {\r\n            // Sort by entity ID first for primary determinism\r\n            const idComparison = String(a.entityId).localeCompare(String(b.entityId));\r\n            if (idComparison !== 0) return idComparison;\r\n            \r\n            // Secondary sort by position for additional determinism\r\n            if (a.position.x !== b.position.x) {\r\n                return a.position.x - b.position.x;\r\n            }\r\n            if (a.position.z !== b.position.z) {\r\n                return a.position.z - b.position.z;\r\n            }\r\n            \r\n            return 0;\r\n        });\r\n    }\r\n    \r\n    // FIXED: Deterministic skeleton creation with ordered components\r\n    createSkeletonFromCorpse(corpsePos, skeletonDef, team, creationIndex) {\r\n        const skeletonId = this.game.createEntity ? this.game.createEntity() : null;\r\n        if (skeletonId === null || skeletonId === undefined) return null;\r\n        \r\n        const components = this.game.componentManager.getComponents();\r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        // FIXED: Deterministic facing based on creation order, not team\r\n        const initialFacing = (creationIndex % 2 === 0) ? 0 : Math.PI;\r\n        \r\n        try {\r\n            // Add components in deterministic alphabetical order\r\n            this.game.addComponent(skeletonId, componentTypes.AI_STATE, \r\n                components.AIState('idle'));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.ANIMATION, \r\n                components.Animation());\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.COLLISION, \r\n                components.Collision(skeletonDef.size, skeletonDef.height));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.COMBAT, \r\n                components.Combat(\r\n                    skeletonDef.damage || 15, \r\n                    skeletonDef.range || 25, \r\n                    skeletonDef.attackSpeed || 1.0,\r\n                    skeletonDef.projectile || null, \r\n                    0, \r\n                    skeletonDef.element || 'physical',\r\n                    skeletonDef.armor || 0, \r\n                    skeletonDef.fireResistance || 0,\r\n                    skeletonDef.coldResistance || 0, \r\n                    skeletonDef.lightningResistance || 0\r\n                ));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.EQUIPMENT, \r\n                components.Equipment());\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.FACING, \r\n                components.Facing(initialFacing));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.HEALTH, \r\n                components.Health(skeletonDef.hp || 50));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.POSITION, \r\n                components.Position(corpsePos.x, corpsePos.y, corpsePos.z));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.RENDERABLE, \r\n                components.Renderable(\"units\", this.raisedUnitType));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.TEAM, \r\n                components.Team(team));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.UNIT_TYPE, \r\n                components.UnitType(\r\n                    this.raisedUnitType, \r\n                    skeletonDef.title || \"Skeleton\", \r\n                    skeletonDef.value || 25\r\n                ));\r\n                \r\n            this.game.addComponent(skeletonId, componentTypes.VELOCITY, \r\n                components.Velocity(0, 0, 0, (skeletonDef.speed || 1) * 20));\r\n            \r\n            return skeletonId;\r\n            \r\n        } catch (error) {\r\n            console.error(`Failed to create skeleton from corpse:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    logCorpseRaising(corpse, team) {\r\n       \r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RaiseDeadAbility.js"
      },
      "BattleCryAbility": {
        "fileName": "BattleCryAbility",
        "script": "class BattleCryAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'battle_cry',\r\n            name: 'Battle Cry',\r\n            description: 'Rally nearby allies, boosting their damage and morale (does not stack)',\r\n            cooldown: 15.0,\r\n            range: 150,\r\n            manaCost: 40,\r\n            targetType: 'allies',\r\n            animation: 'cast',\r\n            priority: 8,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.damageMultiplier = 1.3; // 30% damage boost\r\n        this.duration = 20.0; // 20 seconds\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFFD700,\r\n                    colorRange: { start: 0xFFD700, end: 0xFF4500 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            rally: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xFF6347,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        // Only use if there are at least 2 allies to rally (including potentially the caster)\r\n        return allies.length >= 2;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        \r\n        // DESYNC SAFE: Use scheduling system for the rally effect\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.performBattleCry(casterEntity);\r\n        }, this.castTime, casterEntity);\r\n        \r\n        // Log immediately when cast starts\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        this.logAbilityUsage(casterEntity, `Warlord rallies ${allies.length} allies to battle!`, true);\r\n    }\r\n    \r\n    performBattleCry(casterEntity) {\r\n        // Check if caster is still alive\r\n        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        \r\n        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort allies deterministically\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let ralliedCount = 0;\r\n        \r\n        sortedAllies.forEach(allyId => {\r\n            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            \r\n            // Only rally living allies\r\n            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;\r\n            \r\n            // DESYNC SAFE: Check if already rallied - don't stack multiple battle cries\r\n            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n            \r\n            if (existingBuff && existingBuff.buffType === 'rallied') {\r\n                // DESYNC SAFE: Refresh duration instead of stacking\r\n                existingBuff.endTime = this.game.state.now + this.duration;\r\n                existingBuff.appliedTime = this.game.state.now; // Update applied time\r\n            } else {\r\n                // Apply new rally buff\r\n                const Components = this.game.componentManager.getComponents();\r\n                this.game.addComponent(allyId, this.componentTypes.BUFF, \r\n                    Components.Buff('rallied', { \r\n                        damageMultiplier: this.damageMultiplier, \r\n                        moralBoost: true, \r\n                        fearImmunity: true \r\n                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));\r\n            }\r\n            \r\n            // Visual rally effect on each ally\r\n            this.createVisualEffect(allyPos, 'rally');\r\n            \r\n            // DESYNC SAFE: Schedule buff removal\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.removeRallyBuff(allyId);\r\n            }, this.duration, allyId);\r\n            \r\n            ralliedCount++;\r\n        });\r\n        \r\n        // Screen effect for dramatic rally\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.3, 2);\r\n            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);\r\n        }\r\n        \r\n        // Additional visual effect at caster position\r\n        this.createVisualEffect(casterPos, 'rally', { \r\n            count: 12, \r\n            scaleMultiplier: 3.0,\r\n            heightOffset: 20 \r\n        });\r\n \r\n    }\r\n    \r\n    // DESYNC SAFE: Remove rally buff\r\n    removeRallyBuff(allyId) {\r\n        // Check if ally still exists and has the rally buff\r\n        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {\r\n            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);\r\n            if (buff && buff.buffType === 'rallied') {\r\n                this.game.removeComponent(allyId, this.componentTypes.BUFF);\r\n                \r\n                // Visual effect when rally expires\r\n                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);\r\n                if (allyPos) {\r\n                    this.createVisualEffect(allyPos, 'rally', { \r\n                        count: 2, \r\n                        scaleMultiplier: 0.8,\r\n                        color: 0xCD853F \r\n                    });\r\n                }\r\n       \r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BattleCryAbility.js"
      },
      "HealAbility": {
        "fileName": "HealAbility",
        "script": "class HealAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'heal',\r\n            name: 'Heal',\r\n            description: 'Restores health to the most injured ally',\r\n            cooldown: 30,\r\n            range: 200,\r\n            manaCost: 40,\r\n            targetType: 'ally',\r\n            animation: 'cast',\r\n            priority: 8,\r\n            castTime: 1.0,\r\n            autoTrigger: 'injured_ally',\r\n            ...params\r\n        });\r\n        \r\n        this.healAmount = 80;\r\n        this.element = 'divine';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 2,\r\n                    color: 0x88ff88,\r\n                    colorRange: { start: 0x88ff88, end: 0xffffaa },\r\n                    scaleMultiplier: 1.0,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            heal: {\r\n                type: 'heal',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0x88ffaa,\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        return allies.some(allyId => {\r\n            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            return health && health.current < health.max; // Ally needs healing\r\n        });\r\n    }\r\n        \r\n    execute(casterEntity, targetData = null) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const allies = this.getAlliesInRange(casterEntity);\r\n        const target = this.findMostInjuredAlly(allies);\r\n        \r\n        if (!target) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `Divine light mends wounds!`);\r\n        \r\n    \r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);\r\n            if (targetPos) {\r\n                this.performHeal(casterEntity, target, targetPos);\r\n            }\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    performHeal(casterEntity, targetId, targetPos) {\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        if (!targetHealth) return;\r\n        // Heal effect\r\n        this.createVisualEffect(targetPos, 'heal');\r\n        \r\n        // Apply healing\r\n        const actualHeal = Math.min(this.healAmount, targetHealth.max - targetHealth.current);\r\n        targetHealth.current += actualHeal;\r\n        \r\n        // Show heal number\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.showDamageNumber(\r\n                targetPos.x, targetPos.y + 50, targetPos.z,\r\n                actualHeal, 'heal'\r\n            );\r\n        }\r\n        \r\n    \r\n    }\r\n        \r\n    findMostInjuredAlly(allies) {\r\n        // Sort allies deterministically first\r\n        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let mostInjured = null;\r\n        let lowestHealthRatio = 1.0;\r\n        \r\n        sortedAllies.forEach(allyId => {\r\n            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);\r\n            if (health && health.max > 0) {\r\n                const healthRatio = health.current / health.max;\r\n                // Use <= for consistent tie-breaking (first in sorted order wins)\r\n                if (healthRatio <= lowestHealthRatio) {\r\n                    lowestHealthRatio = healthRatio;\r\n                    mostInjured = allyId;\r\n                }\r\n            }\r\n        });\r\n        \r\n        return mostInjured;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/HealAbility.js"
      },
      "FireBallAbility": {
        "fileName": "FireBallAbility",
        "script": "class FireballAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'fireBall',\r\n            name: 'Fire Ball',\r\n            description: 'Launch a fiery projectile that explodes on impact',\r\n            cooldown: 5.0,\r\n            range: 150,\r\n            manaCost: 30,\r\n            targetType: 'enemy',\r\n            animation: 'cast',\r\n            priority: 6,\r\n            castTime: 1.5,\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 60;\r\n        this.splashRadius = 80;\r\n        this.element = 'fire';\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff4400,\r\n                    colorRange: { start: 0xff4400, end: 0xff8800 },\r\n                    scaleMultiplier: 1.2,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            },\r\n            projectile: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff2200,\r\n                    scaleMultiplier: 0.6,\r\n                    speedMultiplier: 1.5\r\n                }\r\n            },\r\n            explosion: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff4400,\r\n                    colorRange: { start: 0xff4400, end: 0xff0000 },\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.2\r\n                }\r\n            },\r\n            impact: {\r\n                type: 'damage',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff0000,\r\n                    scaleMultiplier: 1.0\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity, targetData = null) {\r\n        if (!this.game.projectileSystem) return;\r\n        \r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return;\r\n        \r\n        // DESYNC SAFE: Get and sort enemies deterministically\r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        if (enemies.length === 0) return;\r\n        \r\n        // Immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        \r\n        // DESYNC SAFE: Find closest enemy deterministically\r\n        const closestEnemy = this.findClosestEnemy(casterEntity, enemies);\r\n        if (!closestEnemy) return;\r\n        \r\n        this.logAbilityUsage(casterEntity, `Fireball launched at enemy target!`, true);\r\n        \r\n        // DESYNC SAFE: Use scheduling system for projectile firing\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.fireProjectile(casterEntity, closestEnemy);\r\n        }, this.castTime, casterEntity);\r\n    }\r\n    \r\n    // DESYNC SAFE: Deterministic closest enemy finding\r\n    findClosestEnemy(casterEntity, enemies) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        // Sort enemies deterministically first\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let closestEnemy = null;\r\n        let closestDistance = Infinity;\r\n        \r\n        sortedEnemies.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            if (!enemyPos) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - casterPos.x, 2) + \r\n                Math.pow(enemyPos.z - casterPos.z, 2)\r\n            );\r\n            \r\n            // Use < for consistent tie-breaking (first in sorted order wins)\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestEnemy = enemyId;\r\n            }\r\n        });\r\n        \r\n        return closestEnemy;\r\n    }\r\n    \r\n    fireProjectile(casterEntity, targetId) {\r\n        if (!this.game.projectileSystem) return;\r\n        \r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!casterPos || !targetPos) return;\r\n        \r\n        // Create fireball projectile with enhanced effects\r\n        const projectileData = {\r\n            id: 'fireball',\r\n            title: 'Fireball',\r\n            damage: this.damage,\r\n            speed: 80,\r\n            element: this.element,\r\n            ballistic: true,\r\n            splashRadius: this.splashRadius,\r\n            homing: true,\r\n            homingStrength: 0.3,\r\n            onHit: (impactPos) => {\r\n                // Explosion effect\r\n                this.createVisualEffect(impactPos, 'explosion');\r\n                if (this.game.effectsSystem) {\r\n                    this.game.effectsSystem.playScreenShake(0.3, 2);\r\n                }\r\n                \r\n                // DESYNC SAFE: Handle splash damage deterministically\r\n                this.handleSplashDamage(casterEntity, impactPos);\r\n            },\r\n            onTravel: (currentPos) => {\r\n                // Trail effect during flight\r\n                this.createVisualEffect(currentPos, 'projectile', { heightOffset: 0 });\r\n            }\r\n        };\r\n        \r\n        this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);\r\n    }\r\n    \r\n    // DESYNC SAFE: Handle splash damage deterministically\r\n    handleSplashDamage(casterEntity, impactPos) {\r\n        // Get all entities in splash radius\r\n        const allEntities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.HEALTH,\r\n            this.componentTypes.TEAM\r\n        );\r\n        \r\n        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);\r\n        if (!casterTeam) return;\r\n        \r\n        const splashTargets = [];\r\n        \r\n        // Find all valid targets in splash radius\r\n        allEntities.forEach(entityId => {\r\n            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            \r\n            if (!entityPos || !entityTeam || entityTeam.team === casterTeam.team) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(entityPos.x - impactPos.x, 2) + \r\n                Math.pow(entityPos.z - impactPos.z, 2)\r\n            );\r\n            \r\n            if (distance <= this.splashRadius) {\r\n                splashTargets.push({\r\n                    id: entityId,\r\n                    distance: distance,\r\n                    position: entityPos\r\n                });\r\n            }\r\n        });\r\n        \r\n        // DESYNC SAFE: Sort splash targets deterministically\r\n        splashTargets.sort((a, b) => {\r\n            // Primary sort by distance\r\n            if (Math.abs(a.distance - b.distance) > 0.001) {\r\n                return a.distance - b.distance;\r\n            }\r\n            // Secondary sort by entity ID for deterministic tie-breaking\r\n            return String(a.id).localeCompare(String(b.id));\r\n        });\r\n        \r\n        // Apply splash damage to all targets\r\n        splashTargets.forEach(target => {\r\n            // Calculate damage falloff based on distance\r\n            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / this.splashRadius));\r\n            const splashDamage = Math.floor(this.damage * damageMultiplier);\r\n            \r\n            // Apply damage\r\n            this.dealDamageWithEffects(casterEntity, target.id, splashDamage, this.element, {\r\n                isSplash: true\r\n            });\r\n            \r\n            // Impact effect on each target\r\n            this.createVisualEffect(target.position, 'impact');\r\n        });\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireBallAbility.js"
      },
      "MeteorStrikeAbility": {
        "fileName": "MeteorStrikeAbility",
        "script": "class MeteorStrikeAbility extends engine.app.appClasses['BaseAbility'] {\r\n    constructor(game, params = {}) {\r\n        super(game, {\r\n            id: 'meteor_strike',\r\n            name: 'Meteor Strike',\r\n            description: 'Devastating strike on the densest enemy formation',\r\n            cooldown: 5.0,\r\n            range: 300,\r\n            manaCost: 0,\r\n            targetType: 'enemies',\r\n            animation: 'cast',\r\n            priority: 10,\r\n            castTime: 1.0,\r\n            ...params\r\n        });\r\n        \r\n        this.damage = 200;\r\n        this.splashRadius = 120;\r\n        this.delay = 3.0;\r\n        this.element = 'fire';\r\n        this.minTargets = 0;\r\n    }\r\n    \r\n    defineEffects() {\r\n        return {\r\n            cast: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff4400,\r\n                    colorRange: { start: 0xff4400, end: 0xffaa00 },\r\n                    scaleMultiplier: 2.0,\r\n                    speedMultiplier: 0.5\r\n                }\r\n            },\r\n            warning: {\r\n                type: 'magic',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff0000,\r\n                    scaleMultiplier: 1.5,\r\n                    speedMultiplier: 1.0\r\n                }\r\n            },\r\n            meteor_explosion: {\r\n                type: 'explosion',\r\n                options: {\r\n                    count: 3,\r\n                    color: 0xff2200,\r\n                    colorRange: { start: 0xff2200, end: 0xffaa00 },\r\n                    scaleMultiplier: 4.0,\r\n                    speedMultiplier: 0.8\r\n                }\r\n            }\r\n        };\r\n    }\r\n    \r\n    canExecute(casterEntity) {\r\n        const enemies = this.getEnemiesInRange(casterEntity);        \r\n        return enemies.length > 0;\r\n    }\r\n    \r\n    execute(casterEntity) {\r\n        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);\r\n        if (!casterPos) return null;\r\n        \r\n        const enemies = this.getEnemiesInRange(casterEntity);\r\n        const targetPos = this.findBestClusterPosition(enemies, this.minTargets);\r\n        \r\n        if (!targetPos) return null;\r\n        \r\n        // Show immediate cast effect\r\n        this.createVisualEffect(casterPos, 'cast');\r\n        this.logAbilityUsage(casterEntity, `A massive meteor approaches from the heavens!`);\r\n        \r\n        // Schedule warning indicator after cast time\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.createMeteorWarning(targetPos);\r\n        }, this.castTime, casterEntity);\r\n        \r\n        // Schedule meteor impact after cast time + delay\r\n        this.game.schedulingSystem.scheduleAction(() => {\r\n            this.meteorImpact(casterEntity, targetPos);\r\n        }, this.castTime + this.delay, casterEntity);\r\n    }\r\n    \r\n    createMeteorWarning(position) {\r\n        // Create warning effect instead of entity for better desync safety\r\n        this.createVisualEffect(position, 'warning');\r\n        \r\n        // Schedule repeated warning effects during the delay period\r\n        const warningInterval = 0.5;\r\n        const warningCount = Math.floor(this.delay / warningInterval);\r\n        \r\n        for (let i = 1; i < warningCount; i++) {\r\n            this.game.schedulingSystem.scheduleAction(() => {\r\n                this.createVisualEffect(position, 'warning');\r\n            }, i * warningInterval, null);\r\n        }\r\n        \r\n        this.logAbilityUsage(null, `The ground trembles as a meteor approaches!`);\r\n    }\r\n    \r\n    meteorImpact(casterEntity, position) {\r\n        // Create massive explosion effect\r\n        this.createVisualEffect(position, 'meteor_explosion');\r\n        \r\n        // Screen effects for dramatic impact\r\n        if (this.game.effectsSystem) {\r\n            this.game.effectsSystem.playScreenShake(0.8, 4);\r\n            this.game.effectsSystem.playScreenFlash('#ff4400', 0.5);\r\n        }\r\n        \r\n        // Apply splash damage\r\n        if (this.game.damageSystem) {\r\n            const results = this.game.damageSystem.applySplashDamage(\r\n                casterEntity,\r\n                position,\r\n                this.damage,\r\n                this.element,\r\n                this.splashRadius,\r\n                { allowFriendlyFire: false, isSpell: true }\r\n            );\r\n         \r\n        }\r\n    }\r\n    \r\n    // FIXED: Deterministic cluster position finding\r\n    findBestClusterPosition(enemies, minTargets) {\r\n        if (enemies.length === 0) return null;\r\n        \r\n        // Sort enemies deterministically first for consistent processing\r\n        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));\r\n        \r\n        let bestPosition = null;\r\n        let maxTargetsHit = 0;\r\n        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance\r\n        \r\n        // Check each enemy position as potential impact center\r\n        sortedEnemies.forEach(potentialCenter => {\r\n            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);\r\n            if (!centerPos) return;\r\n            \r\n            let targetsInRange = 0;\r\n            let totalDistance = 0;\r\n            \r\n            // Count enemies within splash radius of this position\r\n            sortedEnemies.forEach(enemyId => {\r\n                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n                if (!enemyPos) return;\r\n                \r\n                const distance = Math.sqrt(\r\n                    Math.pow(enemyPos.x - centerPos.x, 2) + \r\n                    Math.pow(enemyPos.z - centerPos.z, 2)\r\n                );\r\n                \r\n                if (distance <= this.splashRadius) {\r\n                    targetsInRange++;\r\n                    totalDistance += distance;\r\n                }\r\n            });\r\n            \r\n            // Calculate score: prioritize more targets, then lower total distance for tie-breaking\r\n            const score = (targetsInRange * 1000) - totalDistance;\r\n            \r\n            // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)\r\n            if (targetsInRange > maxTargetsHit || \r\n                (targetsInRange === maxTargetsHit && score >= bestScore)) {\r\n                maxTargetsHit = targetsInRange;\r\n                bestScore = score;\r\n                bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };\r\n            }\r\n        });\r\n        \r\n        // If no good cluster found but we have enemies, target the first enemy deterministically\r\n        if (!bestPosition && sortedEnemies.length > 0) {\r\n            const firstEnemyPos = this.game.getComponent(sortedEnemies[0], this.componentTypes.POSITION);\r\n            if (firstEnemyPos) {\r\n                bestPosition = { x: firstEnemyPos.x, y: firstEnemyPos.y, z: firstEnemyPos.z };\r\n            }\r\n        }\r\n        \r\n        return bestPosition;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MeteorStrikeAbility.js"
      }
    },
    "functions": {
      "calculateStats": {
        "script": "function calculateStats(stats, calcArray) {\r\n\r\n    if( calcArray && calcArray.length > 0 ) {\r\n        let additiveStats = {};\r\n        let multiplicitiveStats = {};\r\n        for(let key in stats) {\r\n            additiveStats[key] = [];\r\n            multiplicitiveStats[key] = [];\r\n        }\r\n        for(let effect of calcArray) {\r\n            effect.apply(stats, additiveStats, multiplicitiveStats);\r\n        }\r\n        let addedEffects = {};\r\n        for(let key in additiveStats){\r\n            for(let val of additiveStats[key]){ \r\n                if(addedEffects[key]){\r\n                    addedEffects[key] += val - 1;\r\n                } else {\r\n                    addedEffects[key] = val - 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let key in addedEffects) {\r\n            if( stats[key] ) {\r\n                stats[key] *= ( 1 + addedEffects[key] );\r\n            }\r\n        }\r\n\r\n        let multipliedUpgrades = {};        \r\n        for(let key in multiplicitiveStats){\r\n            for(let val of multiplicitiveStats[key]){ \r\n                if(stats[key]){\r\n                    stats[key] *= val;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateStats.js",
        "fileName": "calculateStats"
      },
      "calculateDamage": {
        "script": "function calculateDamage(attack, target) {\r\n    // Set default values if not provided\r\n    \r\n    attack.speed = attack.speed || 5;     \r\n    attack.piercing = attack.piercing || 0,\r\n    attack.splashRadius = attack.splashRadius || 0;\r\n    attack.critChance = attack.critChance || .05;\r\n    attack.critMultiplier = attack.critMultiplier || 2;\r\n    attack.penetration = {\r\n      \"fire\": attack.firePenetration || 0,\r\n      \"electric\": attack.electricPenetration || 0,\r\n      \"cold\": attack.coldPenetration || 0,\r\n      \"physical\": attack.physicalPenetration || 0,\r\n      \"toxic\": attack.toxicPenetration || 0,\r\n    }\r\n    target.resistances = {\r\n      \"fire\": target.fireResistance || 0,\r\n      \"electric\": target.electricResistance || 0,\r\n      \"cold\": target.coldResistance || 0,\r\n      \"physical\": target.physicalResistance || 0,\r\n      \"toxic\": target.toxicResistance || 0,\r\n    }\r\n    \r\n    // Initialize result object\r\n    const result = {\r\n      damageBlocked: 0,\r\n      damageAbsorbed: 0,\r\n      damageDealt: 0,\r\n      energyShieldRemaining: target.energyShield || 0,\r\n      wasEvaded: false,\r\n      wasCritical: Math.random() <= attack.critChance,\r\n      hitDetails: {}\r\n    };\r\n    \r\n    // Check for evasion\r\n    if (target.evasion && target.evasion > 0) {\r\n      const evasionRoll = Math.random() * 100;\r\n      if (evasionRoll < target.evasion) {\r\n        result.wasEvaded = true;\r\n        result.hitDetails.evasion = \"Attack evaded\";\r\n        return result;\r\n      }\r\n    }\r\n    \r\n    // Calculate initial damage\r\n    let damage = attack.baseDamage;\r\n    \r\n    // Apply critical hit\r\n    if (result.wasCritical) {\r\n      damage *= attack.critMultiplier;\r\n      result.hitDetails.critical = `Critical hit (${attack.critMultiplier}x damage)`;\r\n    }\r\n    \r\n    // Apply resistances based on damage type\r\n  \r\n    if(attack.damageType != \"physical\") {\r\n      const resistance = target.resistances[attack.damageType] || 0;\r\n      const penetration = attack.penetration[attack.damageType] || 0;\r\n      const finalResist = resistance - penetration;\r\n      let resistanceMultiplier = 1 - (finalResist / 100);\r\n      damage *= resistanceMultiplier;\r\n  \r\n      \r\n      if (finalResist !== 0) {\r\n        if (finalResist > 0) {\r\n          result.hitDetails.resistance = `${attack.damageType} resisted (${finalResist}%)`;\r\n        } else {\r\n          result.hitDetails.resistance = `${attack.damageType} vulnerability (${-finalResist}%)`;\r\n        }\r\n      }  \r\n    }\r\n    \r\n    // Apply armor (only affects physical damage)\r\n    if (attack.damageType === \"physical\" && target.armor > 0) {\r\n      let effectiveArmor = target.armor;\r\n      if (attack.penetration.physical > 0 ) {\r\n        // Piercing ignores 75% of armor\r\n        effectiveArmor = target.armor * (1 - attack.penetration.physical);\r\n      }\r\n      // Armor formula: damage reduction percentage = armor / (armor + 100)\r\n      const armorReduction = effectiveArmor / (effectiveArmor + 100);\r\n      const blockedDamage = damage * armorReduction;\r\n      \r\n      damage -= blockedDamage;\r\n      result.damageBlocked = blockedDamage;\r\n      result.hitDetails.armor = `Armor blocked ${blockedDamage.toFixed(1)} damage`;\r\n    }\r\n    \r\n    // Round damage to 1 decimal place for cleaner numbers\r\n    damage = Math.round(damage * 10) / 10;\r\n    \r\n    // Apply shield absorption\r\n    if (target.energyShield > 0) {\r\n      if (damage <= target.energyShield) {\r\n        // Shield absorbs all damage\r\n        result.damageAbsorbed = damage;\r\n        result.energyShieldRemaining = target.energyShield - damage;\r\n        result.hitDetails.energyShield = `Shield absorbed all damage, ${result.energyShieldRemaining.toFixed(1)} shield remaining`;\r\n        damage = 0;\r\n      } else {\r\n        // Shield is depleted, remaining damage goes through\r\n        result.damageAbsorbed = target.energyShield;\r\n        result.damageDealt = damage - target.energyShield;\r\n        result.energyShieldRemaining = 0;\r\n        result.hitDetails.energyShield = `Shield depleted, ${result.damageDealt.toFixed(1)} damage dealt to health`;\r\n        damage -= target.energyShield;\r\n      }\r\n    } else {\r\n      // No shield, all damage goes to health\r\n      result.damageDealt = damage;\r\n    }\r\n    \r\n    // Make sure we don't return negative damage\r\n    result.damageDealt = Math.max(0, result.damageDealt);\r\n    \r\n    return result;\r\n  }\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateDamage.js",
        "fileName": "calculateDamage"
      }
    },
    "managers": {
      "ComponentManager": {
        "script": "class ComponentManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.componentManager = this;\r\n        this.models = this.game.getCollections().models;        \r\n        this.game.componentTypes = this.getComponentTypes();\r\n        //this.models.position == { x: 0, y: 0, z: 0 };\r\n    }\r\n\r\n    deepMerge(target, source) {\r\n        const result = { ...target };\r\n        \r\n        for (const key in source) {\r\n            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\r\n                result[key] = this.deepMerge(result[key] || {}, source[key]);\r\n            } else {\r\n                result[key] = source[key] == 'null' ? null : source[key];\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    getModels() {\r\n        let components = {};\r\n        Object.keys(this.models).forEach((modelId) => {\r\n            const data = this.models[modelId];\r\n            components[modelId] = (params = {}) => {\r\n                return this.deepMerge(data, params);\r\n            };        \r\n        });\r\n        return components;\r\n    }\r\n    getComponents(){\r\n        return {\r\n            Position: (x = 0, y = 0, z = 0) => ({ x, y, z }),\r\n            Velocity: (vx = 0, vy = 0, vz = 0, maxSpeed = 100, affectedByGravity = true, anchored = false) => ({ vx, vy, vz, maxSpeed, affectedByGravity, anchored}),\r\n            Facing: (angle) => ({ angle: angle || 0 }),\r\n            Renderable: (objectType, spawnType, capacity = 128) => ({ objectType, spawnType, capacity }),\r\n            Collision: (radius = 1, height = 50) => ({ radius, height }),\r\n            Health: (max = 100) => ({ max, current: max }),\r\n            Building: (type) => ( { type }),\r\n            \r\n            // Enhanced Combat component with elemental damage and defenses\r\n            Combat: (\r\n                damage = 0, \r\n                range = 1, \r\n                attackSpeed = 1, \r\n                projectile = null, \r\n                lastAttack = 0,\r\n                element = 'physical',\r\n                armor = 0,\r\n                fireResistance = 0,\r\n                coldResistance = 0,\r\n                lightningResistance = 0,\r\n                poisonResistance = 0,\r\n                visionRange = 300\r\n            ) => ({\r\n                damage,\r\n                range,\r\n                attackSpeed,\r\n                projectile,\r\n                lastAttack,\r\n                element,\r\n                armor,\r\n                fireResistance,\r\n                coldResistance,\r\n                lightningResistance,\r\n                poisonResistance,\r\n                visionRange\r\n            }),\r\n            Placement: (placement = null) => (placement),\r\n            Team: (team = 'neutral') => ({ team }),\r\n            UnitType: (unitType) => ({ ...unitType }),\r\n            AIState: (state = 'idle', targetPosition = null, target = null, aiControllerId = null, meta = {} ) => \r\n                ({ state, targetPosition, target, aiControllerId, meta }),\r\n            Animation: (scale = 1, rotation = 0, flash = 0) => ({ scale, rotation, flash }),\r\n            \r\n            // Enhanced Projectile component with element support\r\n            Projectile: (\r\n                damage = 10, \r\n                speed = 200, \r\n                range = 100, \r\n                target = null, \r\n                source = null, \r\n                startTime = 0,\r\n                element = 'physical'\r\n            ) => ({\r\n                damage,\r\n                speed,\r\n                range,\r\n                target,\r\n                source,\r\n                startTime,\r\n                element\r\n            }),\r\n            Lifetime: (duration = 5, startTime = 0) => ({ duration, startTime }),\r\n            HomingTarget: (targetId = null, homingStrength = 0.5, lastKnownPosition = null) => \r\n                ({ targetId, homingStrength, lastKnownPosition }),\r\n            \r\n            // Enhanced Equipment component that can provide resistances\r\n            Equipment: (slots = {}) => ({ \r\n                slots: {\r\n                    mainHand: null,\r\n                    offHand: null,\r\n                    helmet: null,\r\n                    chest: null,\r\n                    legs: null,\r\n                    feet: null,\r\n                    back: null,\r\n                    ...slots\r\n                }\r\n            }),\r\n            \r\n            EquipmentSlot: (slotType, itemId = null, attachmentPoint = null, offset = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) => ({\r\n                slotType,\r\n                itemId,\r\n                attachmentPoint,\r\n                offset,\r\n                rotation\r\n            }),\r\n            \r\n            // Enhanced EquipmentItem with defensive stats\r\n            EquipmentItem: (\r\n                itemType, \r\n                modelPath, \r\n                stats = {},\r\n                armor = 0,\r\n                fireResistance = 0,\r\n                coldResistance = 0,\r\n                lightningResistance = 0,\r\n                poisonResistance = 0,\r\n                element = null  // Weapon element\r\n            ) => ({\r\n                itemType,\r\n                modelPath,\r\n                stats: {\r\n                    ...stats,\r\n                    armor,\r\n                    fireResistance,\r\n                    coldResistance,\r\n                    lightningResistance,\r\n                    poisonResistance,\r\n                    element\r\n                },\r\n                attachmentData: {\r\n                    mainHand: {\r\n                        bone: 'Hand_R',\r\n                        offset: { x: 0, y: 0, z: 0 },\r\n                        rotation: { x: 0, y: 0, z: 0 }\r\n                    },\r\n                    offHand: {\r\n                        bone: 'Hand_L', \r\n                        offset: { x: 0, y: 0, z: 0 },\r\n                        rotation: { x: 0, y: 0, z: 0 }\r\n                    }\r\n                }\r\n            }),\r\n            \r\n            Corpse: (originalUnitType = null, deathTime = 0, teamAtDeath = 'neutral') => ({ \r\n                originalUnitType, \r\n                deathTime, \r\n                teamAtDeath,\r\n                isCorpse: true \r\n            }),\r\n            \r\n            DeathState: (isDying = false, deathStartTime = 0, deathAnimationDuration = 2.0) => ({ \r\n                isDying, \r\n                deathStartTime, \r\n                deathAnimationDuration \r\n            }),\r\n\r\n            // Status effect component for tracking temporary effects\r\n            StatusEffect: (\r\n                effectType = 'buff',\r\n                element = null,\r\n                duration = 0,\r\n                startTime = 0,\r\n                sourceId = null,\r\n                stacks = 1,\r\n                maxStacks = 1\r\n            ) => ({\r\n                effectType,  // 'buff', 'debuff', 'dot', 'immunity'\r\n                element,\r\n                duration,\r\n                startTime,\r\n                sourceId,\r\n                stacks,\r\n                maxStacks\r\n            }),\r\n\r\n            // Resistance component for temporary resistances/immunities\r\n            ElementalResistance: (\r\n                fireResistance = 0,\r\n                coldResistance = 0,\r\n                lightningResistance = 0,\r\n                poisonResistance = 0,\r\n                physicalResistance = 0,\r\n                divineResistance = 0,\r\n                duration = null,\r\n                permanent = true\r\n            ) => ({\r\n                fireResistance,\r\n                coldResistance,\r\n                lightningResistance,\r\n                poisonResistance,\r\n                physicalResistance,\r\n                divineResistance,\r\n                duration,\r\n                permanent\r\n            }),\r\n\r\n            // =============================================\r\n            // TACTICAL ABILITY COMPONENTS (from original)\r\n            // =============================================\r\n            MiningState: (state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId) => ({\r\n                state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId\r\n            }),\r\n            BuildingState: (state, targetBuildingEntityId, targetBuildingPosition, constructionStartTime) => ({\r\n                state, \r\n                targetBuildingEntityId, \r\n                targetBuildingPosition, \r\n                constructionStartTime                \r\n            }),\r\n            MindControlled: (originalTeam = 'neutral', controller = null, endTime = 0) => ({\r\n                originalTeam,\r\n                controller,\r\n                endTime,\r\n                isControlled: true\r\n            }),\r\n            \r\n            MirrorImage: (originalEntity = null, isIllusion = true, createdTime = 0) => ({\r\n                originalEntity,\r\n                isIllusion,\r\n                createdTime: createdTime || (this.game.state.now || 0)\r\n            }),\r\n            \r\n            Trap: (\r\n                damage = 50, \r\n                radius = 80, \r\n                triggerRadius = 30, \r\n                element = 'physical', \r\n                caster = null, \r\n                triggered = false, \r\n                maxTriggers = 1\r\n            ) => ({\r\n                damage,\r\n                radius,\r\n                triggerRadius,\r\n                element,\r\n                caster,\r\n                triggered,\r\n                triggerCount: 0,\r\n                maxTriggers\r\n            }),\r\n            \r\n            Summoned: (summoner = null, summonType = 'generic', originalStats = null, createdTime = 0) => ({\r\n                summoner,\r\n                summonType,\r\n                originalStats,\r\n                createdTime: createdTime || (this.game.state.now || 0),\r\n                isSummoned: true\r\n            }),\r\n            \r\n            TemporaryEffect: (effectType = 'generic', data = {}, createdTime = 0) => ({\r\n                effectType,\r\n                data,\r\n                createdTime: createdTime || (this.game.state.now || 0)\r\n            }),\r\n            \r\n            Thorns: (reflectionPercent = 0.5, endTime = 0, totalReflected = 0) => ({\r\n                reflectionPercent,\r\n                endTime: endTime || (this.game.state.now || 0) + 20,\r\n                totalReflected,\r\n                isActive: true\r\n            }),\r\n            \r\n            Taunt: (taunter = null, endTime = 0, radius = 0, isTaunted = true) => ({\r\n                taunter,\r\n                endTime: endTime || (this.game.state.now || 0) + 5,\r\n                radius,\r\n                isTaunted\r\n            }),\r\n            \r\n            ShieldWall: (damageReduction = 0.75, endTime = 0, tauntRadius = 200, originalArmor = 0) => ({\r\n                damageReduction,\r\n                endTime: endTime || (this.game.state.now || 0) + 10,\r\n                tauntRadius,\r\n                originalArmor,\r\n                isActive: true\r\n            }),\r\n            \r\n            // =============================================\r\n            // ENHANCED BUFF SYSTEM FOR NEW SPELLS\r\n            // =============================================\r\n            \r\n            Buff: (\r\n                buffType = 'generic', \r\n                modifiers = {}, \r\n                endTime = 0, \r\n                stackable = false, \r\n                stacks = 1, \r\n                appliedTime = 0\r\n            ) => ({\r\n                buffType,\r\n                modifiers,\r\n                endTime: endTime || (this.game.state.now || 0) + 30,\r\n                stackable,\r\n                stacks,\r\n                appliedTime: appliedTime || (this.game.state.now || 0),\r\n                isActive: true,\r\n                \r\n                // Specific buff properties based on type\r\n                ...(buffType === 'rallied' && {\r\n                    damageMultiplier: modifiers.damageMultiplier || 1.3,\r\n                    moralBoost: true,\r\n                    fearImmunity: true\r\n                }),\r\n                \r\n                ...(buffType === 'intimidated' && {\r\n                    damageReduction: modifiers.damageReduction || 0.25,\r\n                    accuracyReduction: modifiers.accuracyReduction || 0.2\r\n                }),\r\n                \r\n                ...(buffType === 'phalanx' && {\r\n                    armorMultiplier: modifiers.armorMultiplier || 1.0,\r\n                    counterAttackChance: modifiers.counterAttackChance || 0.2,\r\n                    formationSize: modifiers.formationSize || 1\r\n                }),\r\n                \r\n                ...(buffType === 'marked' && {\r\n                    damageTakenMultiplier: modifiers.damageTakenMultiplier || 1.25,\r\n                    revealed: true,\r\n                    markedBy: modifiers.markedBy || null\r\n                }),\r\n                \r\n                ...(buffType === 'poison_weapon' && {\r\n                    poisonDamage: modifiers.poisonDamage || 25,\r\n                    poisonDuration: modifiers.poisonDuration || 6,\r\n                    attacksRemaining: modifiers.attacksRemaining || 5\r\n                }),\r\n                \r\n                ...(buffType === 'disrupted' && {\r\n                    abilitiesDisabled: true,\r\n                    accuracyReduction: modifiers.accuracyReduction || 0.4,\r\n                    movementSlowed: modifiers.movementSlowed || 0.6\r\n                }),\r\n                \r\n                ...(buffType === 'magic_weapon' && {\r\n                    weaponElement: modifiers.weaponElement || 'fire',\r\n                    elementalDamage: modifiers.elementalDamage || 15,\r\n                    glowing: true\r\n                }),\r\n                \r\n                ...(buffType === 'dark_empowerment' && {\r\n                    damageMultiplier: modifiers.damageMultiplier,\r\n                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier\r\n                }),\r\n                \r\n                ...(buffType === 'ice_armor' && {\r\n                    armorMultiplier: modifiers.armorMultiplier,\r\n                }),\r\n                \r\n                ...(buffType === 'rage' && {\r\n                    damageMultiplier: modifiers.damageMultiplier || 1.5,\r\n                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier || 1.3\r\n                }),\r\n                \r\n                ...(buffType === 'bloodlust' && {\r\n                    lifeSteal: modifiers.lifeSteal || 0.3,\r\n                    damagePerKill: modifiers.damagePerKill || 5,\r\n                    maxStacks: modifiers.maxStacks || 10\r\n                }),\r\n                \r\n                ...(buffType === 'stunned' && {\r\n                    movementDisabled: true,\r\n                    attackDisabled: true\r\n                })\r\n            }),\r\n            \r\n            Whirlwind: (\r\n                damage = 30, \r\n                radius = 80, \r\n                endTime = 0, \r\n                hitInterval = 0.3, \r\n                lastHitTime = 0, \r\n                totalHits = 0\r\n            ) => ({\r\n                damage,\r\n                radius,\r\n                endTime: endTime || (this.game.state.now || 0) + 2,\r\n                hitInterval,\r\n                lastHitTime,\r\n                totalHits,\r\n                isActive: true\r\n            }),\r\n\r\n            // =============================================\r\n            // FORMATION AND SQUAD COMPONENTS\r\n            // =============================================\r\n            \r\n            Formation: (\r\n                formationType = 'none',\r\n                formationSize = 1,\r\n                formationLeader = null,\r\n                formationMembers = [],\r\n                formationBonuses = {},\r\n                isActive = false\r\n            ) => ({\r\n                formationType, // 'phalanx', 'wedge', 'line', 'circle', etc.\r\n                formationSize,\r\n                formationLeader,\r\n                formationMembers,\r\n                formationBonuses,\r\n                isActive,\r\n                createdTime: (this.game.state.now || 0)\r\n            }),\r\n            \r\n            SquadMember: (\r\n                squadId = null,\r\n                squadRole = 'member', // 'leader', 'member', 'specialist'\r\n                squadPosition = { x: 0, z: 0 },\r\n                squadBonuses = {}\r\n            ) => ({\r\n                squadId,\r\n                squadRole,\r\n                squadPosition,\r\n                squadBonuses,\r\n                joinedTime: (this.game.state.now || 0)\r\n            }),\r\n\r\n            // =============================================\r\n            // ABILITY COOLDOWN AND RESOURCE COMPONENTS\r\n            // =============================================\r\n            \r\n            AbilityCooldowns: (cooldowns = {}) => ({\r\n                cooldowns, // Map of abilityId -> cooldownEndTime\r\n                lastAbilityUsed: null,\r\n                lastAbilityTime: 0\r\n            }),\r\n            \r\n            ResourcePool: (\r\n                mana = 100,\r\n                maxMana = 100,\r\n                manaRegen = 5,\r\n                stamina = 100,\r\n                maxStamina = 100,\r\n                staminaRegen = 10,\r\n                focus = 100,\r\n                maxFocus = 100\r\n            ) => ({\r\n                mana,\r\n                maxMana,\r\n                manaRegen,\r\n                stamina,\r\n                maxStamina, \r\n                staminaRegen,\r\n                focus,\r\n                maxFocus,\r\n                lastRegenTick: (this.game.state.now || 0)\r\n            }),\r\n\r\n            // =============================================\r\n            // VISUAL EFFECT COMPONENTS\r\n            // =============================================\r\n            \r\n            VisualEffect: (\r\n                effectType = 'particle',\r\n                effectData = {},\r\n                duration = 1.0,\r\n                startTime = 0,\r\n                attachedTo = null\r\n            ) => ({\r\n                effectType,\r\n                effectData,\r\n                duration,\r\n                startTime: startTime || (this.game.state.now || 0),\r\n                attachedTo,\r\n                isActive: true\r\n            }),\r\n            \r\n            Aura: (\r\n                auraType = 'generic',\r\n                radius = 50,\r\n                effects = {},\r\n                visualEffect = null,\r\n                persistent = true,\r\n                pulseInterval = 1.0,\r\n                lastPulse = 0\r\n            ) => ({\r\n                auraType,\r\n                radius,\r\n                effects,\r\n                visualEffect,\r\n                persistent,\r\n                pulseInterval,\r\n                lastPulse,\r\n                createdTime: (this.game.state.now || 0)\r\n            }),\r\n\r\n            // =============================================\r\n            // TARGETING AND AI COMPONENTS\r\n            // =============================================\r\n            \r\n            TargetingPreference: (\r\n                preferredTargets = [],\r\n                avoidedTargets = [],\r\n                targetPriority = 'nearest',\r\n                maxTargetRange = 200,\r\n                requiresLineOfSight = false\r\n            ) => ({\r\n                preferredTargets,\r\n                avoidedTargets,\r\n                targetPriority, // 'nearest', 'weakest', 'strongest', 'marked', 'leader'\r\n                maxTargetRange,\r\n                requiresLineOfSight,\r\n                currentTarget: null,\r\n                targetLockTime: 0\r\n            }),\r\n            \r\n            Threat: (\r\n                threatLevel = 0,\r\n                maxThreat = 100,\r\n                threatDecay = 1,\r\n                lastThreatUpdate = 0,\r\n                threatSources = new Map()\r\n            ) => ({\r\n                threatLevel,\r\n                maxThreat,\r\n                threatDecay,\r\n                lastThreatUpdate,\r\n                threatSources\r\n            }),\r\n\r\n            // =============================================\r\n            // SPECIAL ABILITY STATE COMPONENTS\r\n            // =============================================\r\n            \r\n            Charging: (\r\n                target = null,\r\n                chargeSpeed = 100,\r\n                chargeDamage = 50,\r\n                chargeStartTime = 0,\r\n                chargeDistance = 0,\r\n                maxChargeDistance = 150\r\n            ) => ({\r\n                target,\r\n                chargeSpeed,\r\n                chargeDamage,\r\n                chargeStartTime,\r\n                chargeDistance,\r\n                maxChargeDistance,\r\n                isCharging: true\r\n            }),\r\n            \r\n            Channeling: (\r\n                abilityId = null,\r\n                channelDuration = 3.0,\r\n                channelStartTime = 0,\r\n                canBeInterrupted = true,\r\n                interruptThreshold = 10\r\n            ) => ({\r\n                abilityId,\r\n                channelDuration,\r\n                channelStartTime,\r\n                canBeInterrupted,\r\n                interruptThreshold,\r\n                isChanneling: true\r\n            }),\r\n            \r\n            Stealthed: (\r\n                stealthLevel = 1.0, // 0.0 = invisible, 1.0 = fully visible\r\n                detectionRadius = 30,\r\n                stealthStartTime = 0,\r\n                canAttackWhileStealth = false,\r\n                breaksOnAttack = true\r\n            ) => ({\r\n                stealthLevel,\r\n                detectionRadius,\r\n                stealthStartTime,\r\n                canAttackWhileStealth,\r\n                breaksOnAttack,\r\n                isStealth: true\r\n            }),\r\n\r\n            // =============================================\r\n            // ENVIRONMENTAL INTERACTION COMPONENTS  \r\n            // =============================================\r\n            \r\n            EnvironmentalHazard: (\r\n                hazardType = 'generic',\r\n                damagePerTick = 10,\r\n                tickInterval = 1.0,\r\n                element = 'physical',\r\n                affectsTeams = ['all'],\r\n                lastTickTime = 0\r\n            ) => ({\r\n                hazardType, // 'fire', 'poison_cloud', 'ice_field', 'lightning_storm', etc.\r\n                damagePerTick,\r\n                tickInterval,\r\n                element,\r\n                affectsTeams,\r\n                lastTickTime,\r\n                createdTime: (this.game.state.now || 0)\r\n            }),\r\n            \r\n            Consecrated: (\r\n                consecrationLevel = 1.0,\r\n                healPerTick = 5,\r\n                damageToUndead = 10,\r\n                tickInterval = 2.0,\r\n                caster = null,\r\n                lastTickTime = 0\r\n            ) => ({\r\n                consecrationLevel,\r\n                healPerTick,\r\n                damageToUndead,\r\n                tickInterval,\r\n                caster,\r\n                lastTickTime,\r\n                isConsecrated: true\r\n            })\r\n        };\r\n    }\r\n\r\n    getComponentTypes() {\r\n        return {\r\n            // Basic Components\r\n            TRANSFORM: 'transform',\r\n            POSITION: 'position',\r\n            FACING: 'facing',\r\n            VELOCITY: 'velocity',\r\n            SCALE: 'scale',\r\n            RENDERABLE: 'renderable',\r\n            MAP_RENDERER: 'mapRenderer',\r\n            SPRITE: 'sprite',\r\n            MAP_MANAGER: 'mapManager',\r\n            WORLD_OBJECT: 'worldObject',\r\n            ENVIRONMENT_OBJECT: 'environmentObject',\r\n            \r\n            // Unit Components\r\n            PLACEMENT: 'placement',\r\n            TEAM: 'team',\r\n            UNIT_TYPE: 'unitType',\r\n            AI_STATE: 'aiState',\r\n            ANIMATION: 'animation',\r\n            HEALTH: 'health',\r\n            COMBAT: 'combat',\r\n            COLLISION: 'collision',\r\n            BUILDING: 'building',\r\n            \r\n            // Projectile System\r\n            PROJECTILE: 'projectile',\r\n            LIFETIME: 'lifetime',\r\n            HOMING_TARGET: 'homingTarget',\r\n            \r\n            // Entity System\r\n            ENTITY_TYPE: 'entityType',\r\n            LEVEL_DATA: 'levelData',\r\n            \r\n            // Equipment System\r\n            EQUIPMENT: 'equipment',\r\n            EQUIPMENT_SLOT: 'equipmentSlot',\r\n            EQUIPMENT_ITEM: 'equipmentItem',\r\n            \r\n            // Death System\r\n            CORPSE: 'corpse',\r\n            DEATH_STATE: 'deathState',\r\n            \r\n            // Status Effects\r\n            STATUS_EFFECT: 'statusEffect',\r\n            ELEMENTAL_RESISTANCE: 'elementalResistance',\r\n\r\n            // =============================================\r\n            // TACTICAL ABILITY COMPONENT TYPES\r\n            // =============================================\r\n            MIND_CONTROLLED: 'mindControlled',\r\n            MIRROR_IMAGE: 'mirrorImage',\r\n            TRAP: 'trap',\r\n            SUMMONED: 'summoned',\r\n            TEMPORARY_EFFECT: 'temporaryEffect',\r\n            THORNS: 'thorns',\r\n            TAUNT: 'taunt',\r\n            SHIELD_WALL: 'shieldWall',\r\n            BUFF: 'buff',\r\n            WHIRLWIND: 'whirlwind',\r\n\r\n            // =============================================\r\n            // NEW SPELL SUPPORT COMPONENT TYPES\r\n            // =============================================\r\n            \r\n            // Formation and Squad\r\n            FORMATION: 'formation',\r\n            SQUAD_MEMBER: 'squadMember',\r\n            \r\n            // Ability Resources\r\n            ABILITY_COOLDOWNS: 'abilityCooldowns',\r\n            RESOURCE_POOL: 'resourcePool',\r\n            \r\n            // Visual Effects\r\n            VISUAL_EFFECT: 'visualEffect',\r\n            AURA: 'aura',\r\n            MINING_STATE: 'miningState',\r\n            BUILDING_STATE: 'buildingState',\r\n            // AI and Targeting\r\n            TARGETING_PREFERENCE: 'targetingPreference',\r\n            THREAT: 'threat',\r\n            \r\n            // Special States\r\n            CHARGING: 'charging',\r\n            CHANNELING: 'channeling',\r\n            STEALTHED: 'stealthed',\r\n            \r\n            // Environmental\r\n            ENVIRONMENTAL_HAZARD: 'environmentalHazard',\r\n            CONSECRATED: 'consecrated'\r\n        };\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ComponentManager.js",
        "fileName": "ComponentManager"
      },
      "GameModeManager": {
        "script": "class GameModeManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.gameModeManager = this;        \r\n        this.modes = this.initializeGameModes();\r\n        this.setupUI();\r\n    }\r\n\r\n    initializeGameModes() {\r\n        return {\r\n            arena: {\r\n                id: 'arena',\r\n                title: 'Arena',\r\n                icon: '',\r\n                interfaceId: 'createOrJoinRoom',\r\n                description: 'Battle against another player in real-time strategic combat',\r\n                difficulty: 'Player vs Player',\r\n                difficultyClass: 'pvp',\r\n                isMultiplayer: true,\r\n                maxPlayers: 2,\r\n                startingGold: 100,\r\n                onStart: (mode) => {\r\n                    this.game.uiSystem.handleMultiplayerModeSelection(mode);\r\n                }\r\n            }\r\n            // ,\r\n            // campaign: {\r\n            //     id: 'campaign',\r\n            //     title: 'Campaign',\r\n            //     icon: '',\r\n            //     description: 'Progress through increasingly difficult battles and unlock new units',\r\n            //     startingGold: 100\r\n            // },\r\n            // survival: {\r\n            //     id: 'survival',\r\n            //     title: 'Survival',\r\n            //     icon: '',\r\n            //     description: 'See how many waves you can survive with limited resources',\r\n            //     startingGold: 150\r\n            // },\r\n            // arena: {\r\n            //     id: 'arena',\r\n            //     title: 'Arena',\r\n            //     icon: '',\r\n            //     description: 'Quick battles with balanced armies for testing strategies',\r\n            //     startingGold: 200\r\n            // },\r\n            // challenge: {\r\n            //     id: 'challenge',\r\n            //     title: 'Challenge',\r\n            //     icon: '',\r\n            //     description: 'Face pre-built enemy compositions with specific constraints',\r\n            //     startingGold: 100\r\n            // },\r\n            // endless: {\r\n            //     id: 'endless',\r\n            //     title: 'Endless',\r\n            //     icon: '',\r\n            //     description: 'Battle continues until defeat with exponentially scaling enemies',\r\n            //     startingGold: 100\r\n            // },\r\n            // tournament: {\r\n            //     id: 'tournament',\r\n            //     title: 'Tournament',\r\n            //     icon: '',\r\n            //     description: 'Bracket-style competition against AI opponents',\r\n            //     startingGold: 120\r\n            // }\r\n        };\r\n    }\r\n\r\n    setupUI() {\r\n        const modeGrid = document.getElementById('modeGrid');\r\n        if (!modeGrid) return;\r\n\r\n        modeGrid.innerHTML = '';\r\n        \r\n        Object.values(this.modes).forEach(mode => {\r\n            const card = this.createModeCard(mode);\r\n            modeGrid.appendChild(card);\r\n        });\r\n    }\r\n\r\n    createModeCard(mode) {\r\n        const card = document.createElement('div');\r\n        card.className = 'mode-card';\r\n        card.dataset.mode = mode.id;\r\n        \r\n        card.innerHTML = `\r\n            <div class=\"mode-icon\">${mode.icon}</div>\r\n            <div class=\"mode-title\">${mode.title}</div>\r\n            <div class=\"mode-description\">${mode.description}</div>\r\n            <div class=\"mode-difficulty ${mode.difficultyClass}\">${mode.difficulty}</div>\r\n        `;\r\n\r\n        card.addEventListener('click', () => this.selectMode(mode.id));\r\n        \r\n        return card;\r\n    }\r\n\r\n    selectMode(modeId) {\r\n        // Remove previous selection\r\n        document.querySelectorAll('.mode-card').forEach(card => {\r\n            card.classList.remove('selected');\r\n        });\r\n        \r\n        // Add selection to clicked card\r\n        const selectedCard = document.querySelector(`[data-mode=\"${modeId}\"]`);\r\n        if (selectedCard) {\r\n            selectedCard.classList.add('selected');\r\n            this.game.screenManager.setGameMode(modeId);\r\n            const modeConfig = this.getModeConfig(modeId);\r\n            modeConfig.onStart(modeConfig);\r\n        }\r\n    }\r\n\r\n    getSelectedMode() {\r\n        return this.modes[this.game.screenManager.selectedGameMode];\r\n    }\r\n\r\n    getModeConfig(modeId) {\r\n        return this.modes[modeId];\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameModeManager.js",
        "fileName": "GameModeManager"
      },
      "InputManager": {
        "script": "class InputManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.inputManager = this;\r\n        this.keyStates = {};\r\n        this.mouseState = { x: 0, y: 0, pressed: false };\r\n        this.shortcuts = new Map();\r\n        \r\n    }\r\n    \r\n    init() {\r\n        this.setupCanvasEvents();\r\n        this.setupButtonEvents();\r\n        this.setupKeyboardEvents();\r\n        this.setupMouseTracking();\r\n        this.setupDefaultShortcuts();\r\n    }\r\n        \r\n    setupCanvasEvents() {\r\n        const canvas = document.getElementById('gameCanvas');\r\n        if (!canvas) return;\r\n        \r\n        canvas.addEventListener('click', (event) => {\r\n            this.game.placementSystem.handleCanvasClick(event);\r\n        });\r\n        \r\n        canvas.addEventListener('contextmenu', (event) => {\r\n            event.preventDefault();\r\n            this.handleRightClick(event);\r\n        });\r\n    }\r\n    \r\n    setupButtonEvents() {        \r\n        const mainMenuPlayGameBtn = document.getElementById('mainMenu_PlayGameBtn');\r\n        const mainMenuTutorialBtn = document.getElementById('mainMenu_TutorialBtn');\r\n        const mainMenuSettingsBtn = document.getElementById('mainMenu_SettingsBtn');\r\n        const mainMenuCreditsBtn = document.getElementById('mainMenu_CreditsBtn');\r\n\r\n        const gameModeBackBtn = document.getElementById('gameMode_BackBtn');\r\n\r\n        const gamePauseBtn = document.getElementById('game_PauseBtn');\r\n        const gameExitBtn = document.getElementById('game_ExitBtn');\r\n        \r\n        \r\n        const victoryNextRoundBtn = document.getElementById('victory_NextRoundBtn');\r\n        const victoryRestartBtn = document.getElementById('victory_RestartBtn');\r\n        const victoryMainMenuBtn = document.getElementById('victory_MainMenuBtn');\r\n\r\n        \r\n        const defeatRetryBtn = document.getElementById('defeat_RetryBtn');\r\n        const defeatChangeModeBtn = document.getElementById('defeat_ChangeModeBtn');\r\n        const defeatMainMenuBtn = document.getElementById('defeat_MainMenuBtn');\r\n\r\n        \r\n        const pausedResumeBtn = document.getElementById('paused_ResumeBtn');\r\n        const pausedRestartBtn = document.getElementById('paused_RestartBtn');\r\n        const pausedMainMenuBtn = document.getElementById('paused_MainMenuBtn');\r\n\r\n        mainMenuPlayGameBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showGameModeSelect();\r\n        });\r\n        mainMenuTutorialBtn?.addEventListener('click', () => {\r\n            alert('Tutorial coming soon! Check the battle log for basic instructions when you start playing.');\r\n        });\r\n        mainMenuSettingsBtn?.addEventListener('click', () => {\r\n            this.showSettingsModal();\r\n        });\r\n        mainMenuCreditsBtn?.addEventListener('click', () => {\r\n            alert('Auto Battle Arena\\nDeveloped with Claude AI\\n\\nA tactical auto-battler game featuring strategic unit placement and AI opponents.');\r\n        });\r\n\r\n        gameModeBackBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showMainMenu();\r\n        });\r\n\r\n        gamePauseBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.pauseGame();\r\n        });\r\n        gameExitBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.exitToMenu();\r\n        });\r\n\r\n        victoryNextRoundBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.continueGame();\r\n        });\r\n        victoryRestartBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.restartGame();\r\n        });\r\n        victoryMainMenuBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showMainMenu();\r\n        });\r\n\r\n        defeatRetryBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.restartGame();\r\n        });\r\n        defeatChangeModeBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showGameModeSelect();\r\n        });\r\n        defeatMainMenuBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showMainMenu();\r\n        });\r\n\r\n        pausedResumeBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.resumeGame();\r\n        });\r\n        pausedRestartBtn?.addEventListener('click', () => {\r\n            this.game.gameManager.restartGame();\r\n        });\r\n        pausedMainMenuBtn?.addEventListener('click', () => {\r\n            this.game.screenManager.showMainMenu();\r\n        });\r\n\r\n\r\n\r\n    }\r\n    \r\n    setupKeyboardEvents() {\r\n        document.addEventListener('keydown', (event) => {\r\n            this.keyStates[event.code] = true;\r\n            this.handleKeyDown(event);\r\n        });\r\n        \r\n        document.addEventListener('keyup', (event) => {\r\n            this.keyStates[event.code] = false;\r\n            this.handleKeyUp(event);\r\n        });\r\n        \r\n        // Prevent default browser shortcuts that might interfere\r\n        document.addEventListener('keydown', (event) => {\r\n            if (this.shouldPreventDefault(event)) {\r\n                event.preventDefault();\r\n            }\r\n        });\r\n    }\r\n        \r\n    setupMouseTracking() {\r\n        document.addEventListener('mousedown', (event) => {\r\n            this.mouseState.pressed = true;\r\n        });\r\n        \r\n        document.addEventListener('mouseup', (event) => {\r\n            this.mouseState.pressed = false;\r\n        });\r\n        \r\n        document.addEventListener('mousemove', (event) => {\r\n            this.mouseState.x = event.clientX;\r\n            this.mouseState.y = event.clientY;\r\n        });\r\n    }\r\n    \r\n    setupDefaultShortcuts() {\r\n        // Define keyboard shortcuts\r\n        this.shortcuts.set('Escape', () => this.handleEscapeKey());\r\n        this.shortcuts.set('KeyH', () => this.showHelpModal());\r\n        this.shortcuts.set('KeyP', () => this.game.phaseSystem.pauseGame());\r\n        this.shortcuts.set('Space', () => this.handleSpaceKey());\r\n        this.shortcuts.set('F1', () => this.showHelpModal());\r\n    }\r\n    \r\n    handleKeyDown(event) {\r\n        const shortcutKey = this.getShortcutKey(event);\r\n        const shortcutHandler = this.shortcuts.get(shortcutKey);\r\n        \r\n        if (shortcutHandler) {\r\n            event.preventDefault();\r\n            shortcutHandler();\r\n        }\r\n        \r\n        // Handle continuous key press actions\r\n        this.handleContinuousKeys(event);\r\n    }\r\n    \r\n    handleKeyUp(event) {\r\n        // Handle key release actions if needed\r\n        this.handleKeyRelease(event);\r\n    }\r\n    \r\n    getShortcutKey(event) {\r\n        let key = event.code;\r\n        if (event.ctrlKey) key += '+Control';\r\n        if (event.shiftKey) key += '+Shift';\r\n        if (event.altKey) key += '+Alt';\r\n        return key;\r\n    }\r\n    \r\n    handleEscapeKey() {\r\n        const pauseMenu = document.getElementById('pauseMenu');\r\n        \r\n        if (this.game.state.currentScreen === 'gameScreen') {\r\n            this.game.phaseSystem.pauseGame();\r\n        } else if (pauseMenu && pauseMenu.style.display === 'flex') {\r\n            this.game.phaseSystem.resumeGame();\r\n        }\r\n        this.cancelSelectedUnit();\r\n    }\r\n    \r\n    handleSpaceKey() {\r\n        const state = this.game.state;\r\n        if (state.phase === 'placement') {\r\n            this.game.phaseSystem.toggleReady();\r\n        }\r\n    }\r\n    \r\n    handleSaveGame() {\r\n        // Trigger save game functionality\r\n        GUTS.NotificationSystem.show('Game saved!', 'success', 2000);\r\n    }\r\n    \r\n    selectUnitShortcut(index) {\r\n        const unitCards = document.querySelectorAll('.unit-card');\r\n        if (unitCards[index] && !unitCards[index].classList.contains('disabled')) {\r\n            unitCards[index].click();\r\n        }\r\n    }\r\n    \r\n    handleContinuousKeys(event) {\r\n        // Handle keys that should trigger repeatedly while held\r\n        if (this.keyStates['ArrowUp']) {\r\n            this.scrollBattleLog(-1);\r\n        }\r\n        if (this.keyStates['ArrowDown']) {\r\n            this.scrollBattleLog(1);\r\n        }\r\n    }\r\n    \r\n    handleKeyRelease(event) {\r\n        // Handle specific key release events\r\n        console.log(event.code);\r\n        switch (event.code) {\r\n            case 'Tab':\r\n                this.cycleThroughUnits();\r\n                break;\r\n        }\r\n    }\r\n    \r\n    shouldPreventDefault(event) {\r\n        // Prevent certain browser shortcuts\r\n        if (event.ctrlKey && event.code === 'KeyS') return true;\r\n        if (event.code === 'F1') return true;\r\n        return false;\r\n    }\r\n    \r\n    handleRightClick(event) {\r\n        // Handle right-click on canvas (e.g., cancel selection)\r\n\r\n    }\r\n        \r\n    updateMousePosition(event) {\r\n        this.mouseState.x = event.clientX;\r\n        this.mouseState.y = event.clientY;\r\n    }\r\n   \r\n    \r\n    cancelSelectedUnit() {\r\n        const state = this.game.state;\r\n        if (state.selectedUnitType) {\r\n            document.querySelectorAll('.selected').forEach(selected => {\r\n                selected.classList.remove('selected');\r\n            });\r\n            state.selectedUnitType = null;\r\n            this.game.placementSystem.handleUnitSelectionChange(null);\r\n        }\r\n    }\r\n    cycleThroughUnits() {\r\n        const unitCards = document.querySelectorAll('.unit-card:not(.disabled)');\r\n        const currentSelected = document.querySelector('.unit-card.selected');\r\n        \r\n        if (unitCards.length === 0) return;\r\n        \r\n        let nextIndex = 0;\r\n        if (currentSelected) {\r\n            const currentIndex = Array.from(unitCards).indexOf(currentSelected);\r\n            nextIndex = (currentIndex + 1) % unitCards.length;\r\n        }\r\n        \r\n        unitCards[nextIndex].click();\r\n    }\r\n    \r\n    scrollBattleLog(direction) {\r\n        const battleLog = document.getElementById('battleLog');\r\n        if (battleLog) {\r\n            battleLog.scrollTop += direction * 20;\r\n        }\r\n    }\r\n    \r\n    handleMainMenuAction() {\r\n        if (confirm('Return to main menu? Current progress will be lost.')) {\r\n            // Trigger main menu navigation\r\n            if (window.screenManager) {\r\n                window.screenManager.showMainMenu();\r\n            }\r\n        }\r\n    }\r\n    \r\n    showSettingsModal() {\r\n        const settingsContent = `\r\n            <h3> GAME SETTINGS</h3>\r\n            <div class=\"settings-section\">\r\n                <h4>Graphics</h4>\r\n                <label><input type=\"checkbox\" id=\"particles-enabled\" checked> Particle Effects</label>\r\n                <label><input type=\"checkbox\" id=\"screen-shake\" checked> Screen Shake</label>\r\n                <label><input type=\"range\" id=\"particle-density\" min=\"0.5\" max=\"2\" step=\"0.1\" value=\"1\"> Particle Density</label>\r\n            </div>\r\n            <div class=\"settings-section\">\r\n                <h4>Audio</h4>\r\n                <label><input type=\"checkbox\" id=\"sound-effects\" checked> Sound Effects</label>\r\n                <label><input type=\"range\" id=\"volume\" min=\"0\" max=\"1\" step=\"0.1\" value=\"0.7\"> Volume</label>\r\n            </div>\r\n            <div class=\"settings-section\">\r\n                <h4>Controls</h4>\r\n                <p><strong>ESC</strong> - Pause/Resume</p>\r\n                <p><strong>H</strong> - Help</p>\r\n                <p><strong>Space</strong> - Ready</p>\r\n                <p><strong>1-4</strong> - Select Units</p>\r\n                <p><strong>Ctrl+R</strong> - Restart</p>\r\n            </div>\r\n        `;\r\n        \r\n        this.showModal('Settings', settingsContent, () => {\r\n            this.applySettings();\r\n        });\r\n    }\r\n    \r\n    applySettings() {\r\n        // Apply settings from modal\r\n        const particlesEnabled = document.getElementById('particles-enabled')?.checked ?? true;\r\n        const screenShake = document.getElementById('screen-shake')?.checked ?? true;\r\n        const particleDensity = document.getElementById('particle-density')?.value ?? 1;\r\n        const soundEffects = document.getElementById('sound-effects')?.checked ?? true;\r\n        const volume = document.getElementById('volume')?.value ?? 0.7;\r\n        \r\n        // Save to localStorage\r\n        localStorage.setItem('gameSettings', JSON.stringify({\r\n            particlesEnabled,\r\n            screenShake,\r\n            particleDensity,\r\n            soundEffects,\r\n            volume\r\n        }));\r\n        \r\n        GUTS.NotificationSystem.show('Settings saved!', 'success');\r\n    }\r\n    \r\n    showHelpModal() {\r\n        const helpContent = `\r\n            <h3> CONTROLS</h3>\r\n            <div class=\"help-section\">\r\n                <p><strong>ESC</strong> - Pause/Resume game</p>\r\n                <p><strong>H or F1</strong> - Show this help</p>\r\n                <p><strong>P</strong> - Pause game</p>\r\n                <p><strong>Space</strong> - Ready for battle</p>\r\n                <p><strong>Ctrl+R</strong> - Restart game</p>\r\n                <p><strong>Ctrl+S</strong> - Save game</p>\r\n                <p><strong>1-4</strong> - Quick select units</p>\r\n                <p><strong>Tab</strong> - Cycle through units</p>\r\n                <p><strong>Right Click</strong> - Cancel selection</p>\r\n            </div>\r\n            \r\n            <h3> HOW TO PLAY</h3>\r\n            <div class=\"help-section\">\r\n                <p>1. <strong>Select units</strong> from the shop by clicking or using number keys</p>\r\n                <p>2. <strong>Place units</strong> on your side of the battlefield (left half)</p>\r\n                <p>3. <strong>Ready up</strong> when your army is prepared</p>\r\n                <p>4. <strong>Watch the battle</strong> unfold automatically</p>\r\n                <p>5. <strong>Earn gold</strong> from victories to build stronger armies</p>\r\n            </div>\r\n            \r\n            <h3> STRATEGY TIPS</h3>\r\n            <div class=\"help-section\">\r\n                <p> Balance offense and defense in your army</p>\r\n                <p> Position tanks in front to absorb damage</p>\r\n                <p> Place ranged units behind melee fighters</p>\r\n                <p> Spread units to avoid area damage</p>\r\n                <p> Save some gold for emergency purchases</p>\r\n                <p> Adapt your strategy based on enemy composition</p>\r\n            </div>\r\n        `;\r\n        \r\n        this.showModal('Game Help', helpContent);\r\n    }\r\n    \r\n    showModal(title, content, onClose = null) {\r\n        const modal = document.createElement('div');\r\n        modal.className = 'game-modal';\r\n        modal.innerHTML = `\r\n            <div class=\"modal-backdrop\"></div>\r\n            <div class=\"modal-content\">\r\n                <div class=\"modal-header\">\r\n                    <h2>${title}</h2>\r\n                    <button class=\"modal-close\" type=\"button\">&times;</button>\r\n                </div>\r\n                <div class=\"modal-body\">${content}</div>\r\n            </div>\r\n        `;\r\n        \r\n        const closeBtn = modal.querySelector('.modal-close');\r\n        const backdrop = modal.querySelector('.modal-backdrop');\r\n        \r\n        const closeModal = () => {\r\n            if (document.body.contains(modal)) {\r\n                document.body.removeChild(modal);\r\n                if (onClose) onClose();\r\n            }\r\n        };\r\n        \r\n        closeBtn.addEventListener('click', closeModal);\r\n        backdrop.addEventListener('click', closeModal);\r\n        \r\n        // Close on ESC key\r\n        const escHandler = (event) => {\r\n            if (event.key === 'Escape') {\r\n                closeModal();\r\n                document.removeEventListener('keydown', escHandler);\r\n            }\r\n        };\r\n        document.addEventListener('keydown', escHandler);\r\n        \r\n        document.body.appendChild(modal);\r\n        this.addModalCSS();\r\n    }\r\n    \r\n    addModalCSS() {\r\n        if (document.querySelector('#modal-styles')) return;\r\n        \r\n        const style = document.createElement('style');\r\n        style.id = 'modal-styles';\r\n        style.textContent = `\r\n            .game-modal {\r\n                position: fixed; top: 0; left: 0; width: 100%; height: 100%;\r\n                z-index: 2000; display: flex; justify-content: center; align-items: center;\r\n            }\r\n            \r\n            .modal-backdrop {\r\n                position: absolute; top: 0; left: 0; width: 100%; height: 100%;\r\n                background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(3px);\r\n            }\r\n            \r\n            .modal-content {\r\n                position: relative; background: linear-gradient(145deg, #1a1a2e, #16213e);\r\n                border: 2px solid #00ffff; border-radius: 10px; max-width: 600px;\r\n                width: 90%; max-height: 80%; overflow-y: auto;\r\n                animation: modalAppear 0.3s ease-out;\r\n                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);\r\n            }\r\n            \r\n            @keyframes modalAppear {\r\n                from { transform: scale(0.9); opacity: 0; }\r\n                to { transform: scale(1); opacity: 1; }\r\n            }\r\n            \r\n            .modal-header {\r\n                padding: 1rem; border-bottom: 1px solid #333;\r\n                display: flex; justify-content: space-between; align-items: center;\r\n                background: rgba(0, 255, 255, 0.1);\r\n            }\r\n            \r\n            .modal-header h2 { color: #00ffff; margin: 0; }\r\n            \r\n            .modal-close {\r\n                background: none; border: none; color: #ccc; font-size: 1.5rem;\r\n                cursor: pointer; padding: 0; width: 30px; height: 30px;\r\n                display: flex; align-items: center; justify-content: center;\r\n                border-radius: 50%; transition: all 0.2s;\r\n            }\r\n            \r\n            .modal-close:hover { \r\n                color: #ff4444; background: rgba(255, 68, 68, 0.1); \r\n            }\r\n            .modal-body {\r\n                padding: 1.5rem; color: #ccc; line-height: 1.6;\r\n            }\r\n            \r\n            .modal-body h3 { \r\n                color: #00ffff; margin-top: 1.5rem; margin-bottom: 0.8rem;\r\n                border-bottom: 1px solid #333; padding-bottom: 0.5rem;\r\n            }\r\n            \r\n            .modal-body h4 {\r\n                color: #ffff88; margin-top: 1rem; margin-bottom: 0.5rem;\r\n            }\r\n            \r\n            .modal-body p { margin-bottom: 0.6rem; }\r\n            .modal-body strong { color: #ffff00; }\r\n            \r\n            .help-section {\r\n                margin-bottom: 1rem; padding-left: 1rem;\r\n            }\r\n            \r\n            .settings-section {\r\n                margin-bottom: 1.5rem; padding: 1rem;\r\n                background: rgba(255, 255, 255, 0.05);\r\n                border-radius: 5px;\r\n            }\r\n            \r\n            .settings-section label {\r\n                display: block; margin-bottom: 0.8rem;\r\n                color: #ccc; cursor: pointer;\r\n            }\r\n            \r\n            .settings-section input[type=\"checkbox\"] {\r\n                margin-right: 0.5rem; accent-color: #00ffff;\r\n            }\r\n            \r\n            .settings-section input[type=\"range\"] {\r\n                width: 100%; margin-top: 0.3rem;\r\n                accent-color: #00ffff;\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n    \r\n    // Utility methods\r\n    isKeyPressed(keyCode) {\r\n        return this.keyStates[keyCode] || false;\r\n    }\r\n    \r\n    getMousePosition() {\r\n        return { ...this.mouseState };\r\n    }\r\n    \r\n    addCustomShortcut(keyCombo, handler) {\r\n        this.shortcuts.set(keyCombo, handler);\r\n    }\r\n    \r\n    removeShortcut(keyCombo) {\r\n        this.shortcuts.delete(keyCombo);\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/InputManager.js",
        "fileName": "InputManager"
      },
      "UnitCreationManager": {
        "script": "class UnitCreationManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.unitCreationManager = this;\r\n        this.SPEED_MODIFIER = 20;\r\n        // Default component values for missing unit data\r\n        this.defaults = {\r\n            hp: 100,\r\n            damage: 10,\r\n            range: 30,\r\n            speed: 40,\r\n            attackSpeed: 1.0,\r\n            size: 5,\r\n            height: 50,\r\n            armor: 0,\r\n            fireResistance: 0,\r\n            coldResistance: 0,\r\n            lightningResistance: 0,\r\n            element: 'physical',\r\n            projectile: null,\r\n            value: 50\r\n        };\r\n        \r\n        // Equipment slot priorities for auto-equipping\r\n        this.equipmentPriority = [\r\n            'weapon',\r\n            'armor',\r\n            'helmet',\r\n            'boots',\r\n            'gloves',\r\n            'accessory'\r\n        ];\r\n        \r\n        // Team-specific configurations\r\n        this.teamConfigs = {\r\n            left: {\r\n                initialFacing: 0,\r\n                aiState: 'idle',\r\n                colorTint: null\r\n            },\r\n            right: {\r\n                initialFacing: Math.PI,\r\n                aiState: 'idle',\r\n                colorTint: 0xff4444\r\n            }\r\n        };\r\n        \r\n        // Component creation cache for performance\r\n        this.componentCache = new Map();\r\n        \r\n        // Unit creation statistics\r\n        this.stats = {\r\n            totalCreated: 0,\r\n            createdByTeam: new Map(),\r\n            createdByType: new Map(),\r\n            equipmentFailures: 0,\r\n            abilityFailures: 0,\r\n            squadsCreated: 0\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Create a new unit entity with all required components\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldY - World Y coordinate\r\n     * @param {number} worldZ - World Z coordinate\r\n     * @param {Object} unitType - Unit type definition\r\n     * @param {string} team - Team identifier ('left' or 'right')\r\n     * @returns {number} Entity ID\r\n     */\r\n    create(worldX, worldY, worldZ, targetPosition, placement, team) {\r\n        const unitType = placement.unitType;\r\n        try {\r\n            // Round world coordinates to ensure deterministic entity IDs across client and server\r\n            const roundedX = Math.round(worldX * 100) / 100;\r\n            const roundedZ = Math.round(worldZ * 100) / 100;\r\n            const entity = this.game.createEntity(`${unitType.id}_${roundedX}_${roundedZ}_${team}_${this.game.state.round}`);\r\n            console.log('created unit', unitType.id, team, entity);\r\n            const teamConfig = this.teamConfigs[team];\r\n            // Add core components\r\n            this.addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig);\r\n            \r\n            // Add combat components\r\n            this.addCombatComponents(entity, unitType);\r\n            \r\n            // Add AI and behavior components\r\n            this.addBehaviorComponents(entity, targetPosition, unitType);\r\n            \r\n            // Add visual and interaction components\r\n            this.addVisualComponents(entity, unitType, teamConfig);\r\n            \r\n            // Schedule equipment and abilities (async to avoid blocking)\r\n            this.schedulePostCreationSetup(entity, unitType);\r\n            \r\n            // Update statistics\r\n            this.updateCreationStats(unitType, team);\r\n            return entity;\r\n        } catch (error) {\r\n            console.error('Failed to create unit:', error);\r\n            throw new Error(`Unit creation failed: ${error.message}`);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Create multiple squads efficiently from placement data\r\n     * @param {Array} placements - Array of placement data from client\r\n     * @param {string} team - Team identifier\r\n     * @param {string|null} playerId - Optional player ID\r\n     * @returns {Array} Array of created squad placement data\r\n     */\r\n    createSquadFromPlacement(placement, team, playerId = null) {\r\n\r\n        const gridPosition = placement.gridPosition;\r\n        const targetPosition = placement.targetPosition;\r\n        const unitType = placement.unitType;\r\n\r\n        try {\r\n            // Get squad configuration\r\n            const squadData = this.game.squadManager.getSquadData(unitType);\r\n            const validation = this.game.squadManager.validateSquadConfig(squadData);\r\n            \r\n            if (!validation.valid) {\r\n                console.log(\"invalid squad config\");\r\n                return false;\r\n            }\r\n\r\n            // Calculate unit positions within the squad\r\n            const unitPositions = this.game.squadManager.calculateUnitPositions(\r\n                gridPosition,\r\n                unitType\r\n            );\r\n\r\n            // Calculate cells occupied by the squad\r\n            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);\r\n\r\n            // Generate unique placement ID\r\n            const placementId = `squad_${team}_${gridPosition.x}_${gridPosition.z}`;\r\n            const squadUnits = [];\r\n\r\n            \r\n            // Create individual units for the squad\r\n            for (const pos of unitPositions) {\r\n                const terrainHeight = this.getTerrainHeight(pos.x, pos.z);\r\n                const unitY = terrainHeight !== null ? terrainHeight : 0;\r\n\r\n                const entityId = this.create(pos.x, unitY, pos.z, targetPosition, placement, team);\r\n\r\n                // Add playerId to the team component if provided\r\n                if (playerId && this.game.componentManager) {\r\n                    const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n                    const teamComponent = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n                    if (teamComponent) {\r\n                        teamComponent.playerId = playerId;\r\n                    }\r\n                }\r\n                if(unitType.collection == 'buildings'){\r\n                    this.game.placementSystem.saveBuilding(entityId, team, gridPosition, unitType)\r\n                }\r\n                squadUnits.push(entityId);\r\n                this.game.gameManager.call('reserveGridCells', cells, entityId);\r\n            }\r\n\r\n            // Occupy grid cells\r\n            // Update squad creation statistics\r\n            this.stats.squadsCreated++;\r\n\r\n            // Initialize squad in experience system if available\r\n            if (this.game.squadExperienceSystem) {\r\n                this.game.squadExperienceSystem.initializeSquad(placementId, unitType, squadUnits, team);\r\n            }\r\n\r\n            // const squadInfo = this.game.squadManager.getSquadInfo(unitType);\r\n         \r\n            return {\r\n                placementId: placementId,\r\n                gridPosition: gridPosition,\r\n                unitType: unitType,\r\n                squadUnits: squadUnits,\r\n                cells: cells,\r\n                isSquad: squadUnits.length > 1,\r\n                team: team,\r\n                playerId: playerId,\r\n                timestamp: Date.now()\r\n            };\r\n\r\n        } catch (error) {\r\n            console.error('Squad creation failed:', error);\r\n            throw new Error(`Squad creation failed: ${error.message}`);\r\n        }\r\n    \r\n    }\r\n\r\n    /**\r\n     * Clean up squads by destroying their units and freeing grid cells\r\n     * @param {Array} squads - Array of squad placement data\r\n     */\r\n    cleanupSquads(squads) {\r\n        for (const squad of squads) {\r\n            try {\r\n                // Destroy squad units\r\n                for (const unit of squad.squadUnits || []) {\r\n                    if (this.game.destroyEntity && unit) {\r\n                        this.game.destroyEntity(unit);\r\n                    }\r\n                }\r\n\r\n                // Free grid cells\r\n                if (this.game.gridSystem && squad.placementId) {\r\n                    this.game.gridSystem.freeCells(squad.placementId);\r\n                }\r\n\r\n                // Remove from experience system\r\n                if (this.game.squadExperienceSystem && squad.placementId) {\r\n                    this.game.squadExperienceSystem.removeSquad(squad.placementId);\r\n                }\r\n\r\n            } catch (error) {\r\n                console.warn(`Failed to cleanup squad ${squad.placementId}:`, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get squad information for a unit type\r\n     * @param {Object} unitType - Unit type definition\r\n     * @returns {Object} Squad information\r\n     */\r\n    getSquadInfo(unitType) {\r\n        if (this.game.squadManager) {\r\n            return this.game.squadManager.getSquadInfo(unitType);\r\n        }\r\n        \r\n        // Fallback squad info\r\n        return {\r\n            unitName: unitType.title || unitType.id || 'Unknown',\r\n            squadSize: 1,\r\n            formationType: 'single',\r\n            spacing: 1\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Validate if a squad can be placed at the given position\r\n     * @param {Object} gridPosition - Grid position {x, z}\r\n     * @param {Object} unitType - Unit type definition\r\n     * @param {string} team - Team identifier\r\n     * @returns {boolean} True if placement is valid\r\n     */\r\n    canPlaceSquad(gridPosition, unitType, team) {\r\n        if (!this.game.squadManager || !this.game.gridSystem) {\r\n            return this.game.gridSystem ? \r\n                this.game.gridSystem.isValidPosition(gridPosition) : true;\r\n        }\r\n\r\n        try {\r\n            const squadData = this.game.squadManager.getSquadData(unitType);\r\n            const validation = this.game.squadManager.validateSquadConfig(squadData);\r\n            \r\n            if (!validation.valid) {\r\n                return false;\r\n            }\r\n\r\n            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);\r\n            return this.game.gridSystem.isValidPlacement(cells, team);\r\n            \r\n        } catch (error) {\r\n            console.warn('Squad placement validation failed:', error);\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add core position and identity components\r\n     * @param {number} entity - Entity ID\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldY - World Y coordinate\r\n     * @param {number} worldZ - World Z coordinate\r\n     * @param {Object} unitType - Unit type definition\r\n     * @param {string} team - Team identifier\r\n     * @param {Object} teamConfig - Team configuration\r\n     */\r\n    addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig) {\r\n        const unitType = placement.unitType;\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        \r\n        // Position component\r\n        this.game.addComponent(entity, ComponentTypes.POSITION, \r\n            Components.Position(worldX, worldY, worldZ));\r\n        \r\n        // Velocity component with movement capabilities\r\n        const maxSpeed = (unitType.speed) * this.SPEED_MODIFIER;\r\n        this.game.addComponent(entity, ComponentTypes.VELOCITY, \r\n            Components.Velocity(0, 0, 0, maxSpeed, true, unitType.collection == 'buildings' ? true : false));\r\n        \r\n        // Team identification\r\n        this.game.addComponent(entity, ComponentTypes.TEAM, \r\n            Components.Team(team));\r\n        \r\n        this.game.addComponent(entity, ComponentTypes.PLACEMENT, \r\n            Components.Placement(placement));\r\n        \r\n        // Unit type information\r\n        this.game.addComponent(entity, ComponentTypes.UNIT_TYPE, \r\n            Components.UnitType(\r\n                unitType\r\n            ));\r\n        \r\n        // Facing direction\r\n        this.game.addComponent(entity, ComponentTypes.FACING, \r\n            Components.Facing(teamConfig.initialFacing));\r\n    }\r\n    \r\n    /**\r\n     * Add combat-related components\r\n     * @param {number} entity - Entity ID\r\n     * @param {Object} unitType - Unit type definition\r\n     */\r\n    addCombatComponents(entity, unitType) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        // Health component\r\n        const maxHP = unitType.hp || this.defaults.hp;\r\n        this.game.addComponent(entity, ComponentTypes.HEALTH, \r\n            Components.Health(maxHP));\r\n        \r\n        // Combat component with all combat stats\r\n        this.game.addComponent(entity, ComponentTypes.COMBAT, \r\n            Components.Combat(\r\n                unitType.damage,\r\n                unitType.range,\r\n                unitType.attackSpeed,\r\n                unitType.projectile,\r\n                0, // Initial attack cooldown\r\n                unitType.element,\r\n                unitType.armor,\r\n                unitType.fireResistance,\r\n                unitType.coldResistance,\r\n                unitType.lightningResistance, \r\n                0,\r\n                unitType.visionRange\r\n            ));\r\n        \r\n        // Collision component for physical interactions\r\n        this.game.addComponent(entity, ComponentTypes.COLLISION, \r\n            Components.Collision(unitType.size || this.defaults.size, unitType.height));\r\n    }\r\n    \r\n    /**\r\n     * Add AI and behavior components\r\n     * @param {number} entity - Entity ID\r\n     */\r\n    addBehaviorComponents(entity, targetPosition, unitType) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        // AI state for behavior control\r\n        this.game.addComponent(entity, ComponentTypes.AI_STATE, \r\n            Components.AIState('idle', targetPosition));\r\n        \r\n        // Animation state\r\n        this.game.addComponent(entity, ComponentTypes.ANIMATION, \r\n            Components.Animation());\r\n        \r\n        // Equipment container\r\n        this.game.addComponent(entity, ComponentTypes.EQUIPMENT, \r\n            Components.Equipment());\r\n    }\r\n    \r\n    /**\r\n     * Add visual and rendering components\r\n     * @param {number} entity - Entity ID\r\n     * @param {Object} unitType - Unit type definition\r\n     * @param {Object} teamConfig - Team configuration\r\n     */\r\n    addVisualComponents(entity, unitType, teamConfig) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        \r\n        // Renderable component for visual representation\r\n        this.game.addComponent(entity, ComponentTypes.RENDERABLE, \r\n            Components.Renderable(unitType.collection, unitType.id || 'default'));\r\n        \r\n        // Add team-specific visual modifications\r\n        if (teamConfig.colorTint && this.game.addComponent) {\r\n            // Optional: Add color tint component if available\r\n            try {\r\n                if (ComponentTypes.COLOR_TINT) {\r\n                    this.game.addComponent(entity, ComponentTypes.COLOR_TINT,\r\n                        Components.ColorTint(teamConfig.colorTint));\r\n                }\r\n            } catch (error) {\r\n                // Color tint not available, continue without it\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Schedule post-creation setup (equipment and abilities)\r\n     * @param {number} entityId - Entity ID\r\n     * @param {Object} unitType - Unit type definition\r\n     */\r\n    schedulePostCreationSetup(entityId, unitType) {\r\n\r\n        this.setupEquipment(entityId, unitType);\r\n        this.setupAbilities(entityId, unitType);\r\n    }\r\n    \r\n    /**\r\n     * Equip unit with items from unit definition\r\n     * @param {number} entityId - Entity ID\r\n     * @param {Object} unitType - Unit type definition\r\n     */\r\n    async setupEquipment(entityId, unitType) {\r\n\r\n        if (!this.game.equipmentSystem || !unitType?.render?.equipment) {\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            // Sort equipment by priority for better equipping order\r\n            const equipmentList = [...unitType.render.equipment].sort((a, b) => {\r\n                const priorityA = this.equipmentPriority.indexOf(a.slot) || 999;\r\n                const priorityB = this.equipmentPriority.indexOf(b.slot) || 999;\r\n                return priorityA - priorityB;\r\n            });\r\n            \r\n            // Equip each item\r\n            for (const equippedItem of equipmentList) {\r\n                const itemData = this.getItemFromCollection(equippedItem.item);\r\n                if (itemData) {\r\n                    try {\r\n                        await this.game.equipmentSystem.equipItem(\r\n                            entityId, \r\n                            equippedItem, \r\n                            itemData, \r\n                            equippedItem.item\r\n                        );\r\n                    } catch (equipError) {\r\n                        console.warn(`Failed to equip ${equippedItem.item} on slot ${equippedItem.slot}:`, equipError);\r\n                        this.stats.equipmentFailures++;\r\n                    }\r\n                } else {\r\n                    console.warn(`Item ${equippedItem.item} not found in collections`);\r\n                    this.stats.equipmentFailures++;\r\n                }\r\n            }\r\n        } catch (error) {\r\n            console.error(`Equipment setup failed for entity ${entityId}:`, error);\r\n            this.stats.equipmentFailures++;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add abilities to unit from unit definition\r\n     * @param {number} entityId - Entity ID\r\n     * @param {Object} unitType - Unit type definition\r\n     */\r\n    setupAbilities(entityId, unitType) {\r\n        if (!this.game.abilitySystem || !unitType?.abilities) {\r\n            return;\r\n        }\r\n        \r\n        try {\r\n            // Validate abilities exist before adding\r\n            const validAbilities = unitType.abilities.filter(abilityId => {\r\n                const abilityData = this.getAbilityFromCollection(abilityId);\r\n                if (!abilityData) {\r\n                    console.warn(`Ability ${abilityId} not found in collections`);\r\n                    this.stats.abilityFailures++;\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            \r\n            if (validAbilities.length > 0) {\r\n                this.game.abilitySystem.addAbilitiesToUnit(entityId, validAbilities);\r\n            }\r\n        } catch (error) {\r\n            console.error(`Ability setup failed for entity ${entityId}:`, error);\r\n            this.stats.abilityFailures++;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get item data from game collections\r\n     * @param {string} itemId - Item identifier\r\n     * @returns {Object|null} Item data or null if not found\r\n     */\r\n    getItemFromCollection(itemId) {\r\n        try {\r\n            const collections = this.game.getCollections();\r\n            if (!collections?.items?.[itemId]) {\r\n                return null;\r\n            }\r\n            return collections.items[itemId];\r\n        } catch (error) {\r\n            console.warn(`Error accessing item collection for ${itemId}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get ability data from game collections\r\n     * @param {string} abilityId - Ability identifier\r\n     * @returns {Object|null} Ability data or null if not found\r\n     */\r\n    getAbilityFromCollection(abilityId) {\r\n        try {\r\n            const collections = this.game.getCollections();\r\n            if (!collections?.abilities?.[abilityId]) {\r\n                return null;\r\n            }\r\n            return collections.abilities[abilityId];\r\n        } catch (error) {\r\n            console.warn(`Error accessing ability collection for ${abilityId}:`, error);\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get terrain height at world position\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {number} Terrain height\r\n     */\r\n    getTerrainHeight(worldX, worldZ) {\r\n        try {\r\n            if (this.game.terrainSystem?.getTerrainHeightAtPosition) {\r\n                return this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);\r\n            }\r\n        } catch (error) {\r\n            console.warn(`Error getting terrain height at (${worldX}, ${worldZ}):`, error);\r\n        }\r\n        return 0; // Default to ground level\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Update creation statistics\r\n     * @param {Object} unitType - Unit type definition\r\n     * @param {string} team - Team identifier\r\n     */\r\n    updateCreationStats(unitType, team) {\r\n        this.stats.totalCreated++;\r\n        \r\n        // Track by team\r\n        const teamCount = this.stats.createdByTeam.get(team) || 0;\r\n        this.stats.createdByTeam.set(team, teamCount + 1);\r\n        \r\n        // Track by unit type\r\n        const unitTypeId = unitType.id || 'unknown';\r\n        const typeCount = this.stats.createdByType.get(unitTypeId) || 0;\r\n        this.stats.createdByType.set(unitTypeId, typeCount + 1);\r\n    }\r\n    \r\n    /**\r\n     * Get creation statistics\r\n     * @returns {Object} Statistics summary\r\n     */\r\n    getStats() {\r\n        return {\r\n            totalCreated: this.stats.totalCreated,\r\n            createdByTeam: Object.fromEntries(this.stats.createdByTeam),\r\n            createdByType: Object.fromEntries(this.stats.createdByType),\r\n            equipmentFailures: this.stats.equipmentFailures,\r\n            abilityFailures: this.stats.abilityFailures,\r\n            squadsCreated: this.stats.squadsCreated,\r\n            successRate: {\r\n                equipment: 1 - (this.stats.equipmentFailures / Math.max(1, this.stats.totalCreated)),\r\n                abilities: 1 - (this.stats.abilityFailures / Math.max(1, this.stats.totalCreated))\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Reset creation statistics\r\n     */\r\n    resetStats() {\r\n        this.stats = {\r\n            totalCreated: 0,\r\n            createdByTeam: new Map(),\r\n            createdByType: new Map(),\r\n            equipmentFailures: 0,\r\n            abilityFailures: 0,\r\n            squadsCreated: 0\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Validate unit type definition\r\n     * @param {Object} unitType - Unit type to validate\r\n     * @returns {Object} Validation result\r\n     */\r\n    validateUnitType(unitType) {\r\n        const errors = [];\r\n        const warnings = [];\r\n        \r\n        if (!unitType) {\r\n            errors.push('Unit type is required');\r\n            return { valid: false, errors, warnings };\r\n        }\r\n        \r\n        // Check required fields\r\n        if (!unitType.id) warnings.push('Unit ID missing, using default');\r\n        if (!unitType.title) warnings.push('Unit title missing, using ID or default');\r\n        \r\n        // Validate numeric stats\r\n        const numericFields = ['hp', 'damage', 'range', 'speed', 'armor', 'value'];\r\n        numericFields.forEach(field => {\r\n            if (unitType[field] !== undefined && (isNaN(unitType[field]) || unitType[field] < 0)) {\r\n                errors.push(`${field} must be a non-negative number`);\r\n            }\r\n        });\r\n        \r\n        // Check equipment references\r\n        if (unitType.render?.equipment) {\r\n            unitType.render.equipment.forEach((item, index) => {\r\n                if (!item.item) {\r\n                    warnings.push(`Equipment item ${index} missing item ID`);\r\n                }\r\n                if (!item.slot) {\r\n                    warnings.push(`Equipment item ${index} missing slot`);\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Check ability references\r\n        if (unitType.abilities && !Array.isArray(unitType.abilities)) {\r\n            errors.push('Abilities must be an array');\r\n        }\r\n        \r\n        return {\r\n            valid: errors.length === 0,\r\n            errors,\r\n            warnings\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Clean up resources and cache\r\n     */\r\n    dispose() {\r\n        this.componentCache.clear();\r\n        this.resetStats();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/UnitCreationManager.js",
        "fileName": "UnitCreationManager"
      },
      "ResultsManager": {
        "script": "class ResultsManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.resultsManager = this;                \r\n    }\r\n\r\n    showVictory(stats) {\r\n        this.populateStats('victoryStats', stats, 'victory');\r\n        this.game.screenManager.showVictoryScreen();\r\n    }\r\n\r\n    showDefeat(stats) {\r\n        this.populateStats('defeatStats', stats, 'defeat');\r\n        this.game.screenManager.showDefeatScreen();\r\n    }\r\n\r\n    populateStats(containerId, stats, type) {\r\n        const container = document.getElementById(containerId);\r\n        if (!container) return;\r\n\r\n        container.innerHTML = '';\r\n\r\n        const statItems = type === 'victory' \r\n            ? this.getVictoryStats(stats)\r\n            : this.getDefeatStats(stats);\r\n\r\n        statItems.forEach(item => {\r\n            const card = this.createStatCard(item.label, item.value);\r\n            container.appendChild(card);\r\n        });\r\n    }\r\n\r\n    getVictoryStats(stats) {\r\n        return [\r\n            { label: 'Round Reached', value: stats.round || 1 },\r\n            { label: 'Gold Earned', value: stats.goldEarned || 0 },\r\n            { label: 'Units Deployed', value: stats.unitsDeployed || 0 },\r\n            { label: 'Time Played', value: this.formatTime(stats.totalPlayTime || 0) }\r\n        ];\r\n    }\r\n\r\n    getDefeatStats(stats) {\r\n        return [\r\n            { label: 'Final Round', value: stats.round || 1 },\r\n            { label: 'Total Gold', value: stats.goldEarned || 0 },\r\n            { label: 'Units Lost', value: stats.unitsLost || 0 },\r\n            { label: 'Survival Time', value: this.formatTime(stats.totalPlayTime || 0) }\r\n        ];\r\n    }\r\n\r\n    createStatCard(label, value) {\r\n        const card = document.createElement('div');\r\n        card.className = 'stat-card';\r\n        card.innerHTML = `\r\n            <div class=\"stat-label\">${label}</div>\r\n            <div class=\"stat-value\">${value}</div>\r\n        `;\r\n        return card;\r\n    }\r\n\r\n    formatTime(milliseconds) {\r\n        const seconds = Math.floor(milliseconds / 1000);\r\n        const minutes = Math.floor(seconds / 60);\r\n        const remainingSeconds = seconds % 60;\r\n        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ResultsManager.js",
        "fileName": "ResultsManager"
      },
      "ScreenManager": {
        "script": "class ScreenManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.screenManager = this;\r\n    }\r\n\r\n    \r\n\r\n    showScreen(screenId) {\r\n        document.querySelectorAll('.screen').forEach(screen => {\r\n            screen.classList.remove('active');\r\n        });\r\n        \r\n        const targetScreen = document.getElementById(screenId);\r\n        if (targetScreen) {\r\n            targetScreen.classList.add('active');\r\n        }\r\n    }\r\n\r\n    showMainMenu() {\r\n        this.setScreen('mainMenu');\r\n    }\r\n\r\n    showGameModeSelect() {\r\n        this.setScreen('gameModeSelect');\r\n        // Reset selection\r\n        document.querySelectorAll('.mode-card').forEach(card => {\r\n            card.classList.remove('selected');\r\n        });\r\n        this.selectedGameMode = null;\r\n    }\r\n\r\n    showLoadingScreen() {\r\n        this.setScreen('loadingScreen');\r\n    }\r\n\r\n    showGameScreen() {\r\n        this.setScreen('gameScreen');\r\n    }\r\n\r\n    showVictoryScreen() {\r\n        this.setScreen('victoryScreen');\r\n    }\r\n\r\n    showDefeatScreen() {\r\n        this.setScreen('defeatScreen');\r\n    }\r\n\r\n\r\n    \r\n    reset() {\r\n        this.currentScreen = 'mainMenu';\r\n        this.selectedGameMode = null;\r\n        this.gameStartTime = null;\r\n        this.isPaused = false;\r\n        this.stats = {\r\n            round: 1,\r\n            goldEarned: 0,\r\n            unitsDeployed: 0,\r\n            unitsLost: 0,\r\n            totalPlayTime: 0\r\n        };\r\n    }\r\n\r\n    setScreen(screenId) {\r\n        this.currentScreen = screenId;\r\n        this.showScreen(screenId);\r\n    }\r\n\r\n    setGameMode(mode) {\r\n        this.selectedGameMode = mode;\r\n    }\r\n\r\n    onGameStarted() {\r\n        this.gameStartTime = Date.now();\r\n    }\r\n\r\n    endGame(result, finalStats = {}) {\r\n        if (this.gameStartTime) {\r\n            this.stats.totalPlayTime = Date.now() - this.gameStartTime;\r\n        }\r\n        Object.assign(this.stats, finalStats);\r\n    }\r\n\r\n    pause() {\r\n        this.isPaused = true;\r\n    }\r\n\r\n    resume() {\r\n        this.isPaused = false;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ScreenManager.js",
        "fileName": "ScreenManager"
      },
      "GameManager": {
        "script": "class GameManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.gameManager = this;\r\n        this.services = new Map();\r\n    }\r\n\r\n    initializeGame(){\r\n        if (!this.game.screenManager.selectedGameMode) {\r\n            alert('Please select a game mode first!');\r\n            return;\r\n        }\r\n\r\n        this.game.screenManager.showLoadingScreen();\r\n        \r\n        // Update loading content based on selected mode\r\n        const mode = this.game.gameModeManager.getSelectedMode();\r\n        if (mode) {\r\n            const loadingTip = document.querySelector('.loading-tip');\r\n            if (loadingTip) {\r\n                loadingTip.textContent = `Mode: ${mode.title} - ${mode.description}`;\r\n            }\r\n        }\r\n\r\n        this.game.triggerEvent('onGameStarted');\r\n\r\n        setTimeout(() => {   \r\n            this.game.state.isPaused = false;\r\n            this.game.uiSystem.start();\r\n            this.game.screenManager.showGameScreen();  \r\n        }, 2000);\r\n        \r\n    }\r\n\r\n    pauseGame() {\r\n        this.game.screenManager.pause();\r\n        const pauseMenu = document.getElementById('pauseMenu');\r\n        if (pauseMenu) {\r\n            pauseMenu.style.display = 'flex';\r\n        }\r\n    }\r\n\r\n    resumeGame() {\r\n        this.game.screenManager.resume();\r\n        const pauseMenu = document.getElementById('pauseMenu');\r\n        if (pauseMenu) {\r\n            pauseMenu.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    restartGame() {\r\n        const confirmRestart = this.game.screenManager.currentScreen === 'gameScreen' \r\n            ? confirm('Are you sure you want to restart? Your current progress will be lost.')\r\n            : true;\r\n\r\n        if (confirmRestart) {\r\n            this.initializeGame();\r\n        }\r\n        \r\n        // Hide pause menu if open\r\n        const pauseMenu = document.getElementById('pauseMenu');\r\n        if (pauseMenu) {\r\n            pauseMenu.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    exitToMenu() {\r\n        if (confirm('Are you sure you want to exit to the main menu? Your progress will be lost.')) {\r\n            this.game.phaseSystem.reset();\r\n            this.game.screenManager.showMainMenu();\r\n        }\r\n    }\r\n\r\n    continueGame() {\r\n        // Continue to next round/level\r\n        this.game.screenManager.stats.round++;\r\n        this.initializeGame();\r\n    }\r\n\r\n    // Systems call this in constructor or init()\r\n    register(key, method) {\r\n        if (this.services.has(key)) {\r\n            debugger;\r\n            console.warn(`Service ${key} already registered! Overwriting.`);\r\n        }\r\n        this.services.set(key, method);\r\n    }\r\n\r\n    has(key){\r\n        return this.services.has(key);\r\n    }\r\n\r\n    // Public API\r\n    call(key, ...args) {\r\n        const method = this.services.get(key);\r\n        if (!method) {\r\n            return undefined;\r\n        }\r\n        return method(...args);\r\n    }\r\n\r\n    // Optional: async version\r\n    async callAsync(key, ...args) {\r\n        return this.call(key, ...args);\r\n    }\r\n\r\n    // Debug\r\n    listServices() {\r\n        return Array.from(this.services.keys());\r\n    }\r\n\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameManager.js",
        "fileName": "GameManager"
      },
      "KeyboardManager": {
        "script": "class KeyboardManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.keyboardManager = this;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/KeyboardManager.js",
        "fileName": "KeyboardManager"
      },
      "MultiplayerNetworkManager": {
        "script": "class MultiplayerNetworkManager {\r\n    constructor(game) {\r\n        this.game = game;\r\n        this.game.networkManager = this;\r\n        \r\n        // State tracking\r\n        this.roomId = null;\r\n        this.isHost = false;\r\n        this.gameState = null;\r\n        // Store unsubscribe functions\r\n        this.networkUnsubscribers = [];\r\n    }\r\n\r\n    // GUTS Manager Interface\r\n    init(params) {\r\n        this.params = params || {};\r\n        this.connectToServer();        \r\n        this.setupNetworkListeners();\r\n    }\r\n\r\n    async connectToServer() {\r\n        try {\r\n            await this.game.clientNetworkManager.connect();\r\n            \r\n            // Call server to get player ID\r\n            this.game.clientNetworkManager.call(\r\n                'CONNECT',\r\n                null,\r\n                'CONNECTED',\r\n                (data, error) => {\r\n                    if (error) {\r\n                        console.error('Failed to get player ID:', error);\r\n                        this.game.uiSystem.showNotification('Failed to get player ID from server', 'error');\r\n                    } else if (data && data.playerId) {\r\n                        this.game.clientNetworkManager.playerId = data.playerId;\r\n                        this.game.state.playerId = data.playerId;\r\n                    } else {\r\n                        console.error('Server response missing player ID:', data);\r\n                        this.game.uiSystem.showNotification('Server did not provide player ID', 'error');\r\n                    }\r\n                }\r\n            );\r\n            \r\n        } catch (error) {\r\n            console.error('Failed to connect to server:', error);\r\n            this.game.uiSystem.showNotification('Failed to connect to server', 'error');\r\n        }\r\n    }\r\n\r\n    setupNetworkListeners() {\r\n        const nm = this.game.clientNetworkManager;\r\n        if (!nm) {\r\n            console.error('ClientNetworkManager not available');\r\n            return;\r\n        }\r\n\r\n        // Listen to events that update the UI\r\n        this.networkUnsubscribers.push(\r\n            nm.listen('PLAYER_JOINED', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handlePlayerJoined(data);\r\n            }),\r\n\r\n            nm.listen('PLAYER_LEFT', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handlePlayerLeft(data);\r\n            }),\r\n\r\n            nm.listen('PLAYER_READY_UPDATE', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handlePlayerReadyUpdate(data);\r\n            }),\r\n\r\n            nm.listen('GAME_STARTED', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handleGameStarted(data);\r\n            }),\r\n            nm.listen('OPPONENT_SQUAD_TARGET_SET', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handleOpponentSquadTarget(data);\r\n            }),\r\n            nm.listen('OPPONENT_SQUAD_TARGETS_SET', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handleOpponentSquadTargets(data);\r\n            }),\r\n            nm.listen('READY_FOR_BATTLE_UPDATE', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handleReadyForBattleUpdate(data);\r\n            }),\r\n\r\n            nm.listen('BATTLE_END', (data) => {\r\n                this.syncWithServerState(data);   \r\n                this.handleBattleEnd(data);\r\n            }),\r\n\r\n            nm.listen('GAME_END', (data) => {\r\n                this.syncWithServerState(data);        \r\n                this.handleGameEnd(data);\r\n            })\r\n        );\r\n    }\r\n\r\n    createRoom(playerName, maxPlayers = 2) {\r\n        this.game.uiSystem.showNotification('Creating room...', 'info');\r\n        \r\n        this.game.clientNetworkManager.call(\r\n            'CREATE_ROOM',\r\n            { playerName, maxPlayers },\r\n            'ROOM_CREATED',\r\n            (data, error) => {\r\n                if (error) {\r\n                    this.game.uiSystem.showNotification(`Failed to create room: ${error.message}`, 'error');\r\n                } else {\r\n                    this.roomId = data.roomId;\r\n                    this.isHost = data.isHost;\r\n                    this.gameState = data.gameState;\r\n                    this.game.uiSystem.showNotification(`Room created! Code: ${this.roomId}`, 'success');\r\n                    this.game.uiSystem.showLobby(data.gameState, this.roomId);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    joinRoom(roomId, playerName) {\r\n        this.game.uiSystem.showNotification('Joining room...', 'info');\r\n        \r\n        this.game.clientNetworkManager.call(\r\n            'JOIN_ROOM',\r\n            { roomId, playerName },\r\n            'ROOM_JOINED',\r\n            (data, error) => {\r\n                if (error) {\r\n                    this.game.uiSystem.showNotification(`Failed to join room: ${error.message}`, 'error');\r\n                } else {\r\n                    this.roomId = data.roomId;\r\n                    this.isHost = data.isHost;\r\n                    this.gameState = data.gameState;\r\n                    this.game.uiSystem.showNotification(`Joined room ${this.roomId}`, 'success');\r\n                    this.game.uiSystem.showLobby(data.gameState, this.roomId);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    startQuickMatch(playerName) {\r\n        this.game.uiSystem.showNotification('Finding opponent...', 'info');\r\n        \r\n        this.game.clientNetworkManager.call(\r\n            'QUICK_MATCH',\r\n            { playerName },\r\n            'QUICK_MATCH_FOUND',\r\n            (data, error) => {\r\n                if (error) {\r\n                    this.game.uiSystem.showNotification(`Quick match failed: ${error.message}`, 'error');\r\n                } else {\r\n                    this.roomId = data.roomId;\r\n                    this.isHost = data.isHost;\r\n                    this.gameState = data.gameState;\r\n                    this.game.uiSystem.showNotification(`Match found! Entering room...`, 'success');\r\n                    this.game.uiSystem.showLobby(data.gameState, this.roomId);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    getStartingState(callback){\r\n        this.game.clientNetworkManager.call(\r\n            'GET_STARTING_STATE',\r\n            {},\r\n            'GOT_STARTING_STATE',\r\n            (data, error) => {           \r\n                if (data.error) {\r\n                    console.log('getStartingState error:', data.error);\r\n                    callback(false, error);\r\n                } else {\r\n                    console.log('getStartingState response:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    submitPlacement(placement, callback){\r\n        if(this.game.state.phase != \"placement\") {\r\n            callback(false, 'Not in placement phase.');\r\n        };\r\n        this.game.clientNetworkManager.call(\r\n            'SUBMIT_PLACEMENT',\r\n            { placement },\r\n            'SUBMITTED_PLACEMENT',\r\n            (data, error) => {           \r\n                if (data.error) {\r\n                    console.log('Placement error:', data.error);\r\n                    callback(false, error);\r\n                } else {\r\n                    console.log('Placement response:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    purchaseUpgrade(data, callback){\r\n        if(this.game.state.phase != \"placement\") {\r\n            callback(false, 'Not in placement phase.');\r\n        };\r\n        this.game.clientNetworkManager.call(\r\n            'PURCHASE_UPGRADE',\r\n            { data },\r\n            'PURCHASED_UPGRADE',\r\n            (data, error) => {           \r\n                if (data.error) {\r\n                    console.log('Purchase error:', data.error);\r\n                    callback(false, error);\r\n                } else {\r\n                    console.log('Purchase response:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    setSquadTarget(data, callback) {\r\n        if(this.game.state.phase != \"placement\") {\r\n            callback(false, 'Not in placement phase.');\r\n        };\r\n        this.game.clientNetworkManager.call(\r\n            'SET_SQUAD_TARGET',\r\n            data,\r\n            'SQUAD_TARGET_SET',\r\n            (data, error) => {\r\n                if (error || data.error) {\r\n                    console.log('Set target error:', error || data.error);\r\n                    callback(false, error || data.error);\r\n                } else {\r\n                    console.log('Set target response:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    setSquadTargets(data, callback) {\r\n        if(this.game.state.phase != \"placement\") {\r\n            callback(false, 'Not in placement phase.');\r\n        };\r\n        this.game.clientNetworkManager.call(\r\n            'SET_SQUAD_TARGETS',\r\n            data,\r\n            'SQUAD_TARGETS_SET',\r\n            (data, error) => {\r\n                if (error || data.error) {\r\n                    console.log('Set target error:', error || data.error);\r\n                    callback(false, error || data.error);\r\n                } else {\r\n                    console.log('Set target response:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    toggleReadyForBattle(callback) {\r\n        if(this.game.state.phase != \"placement\") {\r\n            callback(false, 'Not in placement phase.');\r\n        };\r\n        this.game.clientNetworkManager.call(\r\n            'READY_FOR_BATTLE',\r\n            {},\r\n            'READY_FOR_BATTLE_RESPONSE',\r\n            (data, error) => {                                \r\n                if (data.error) {\r\n                    console.log('Battle ready state error:', data.error);\r\n                    callback(false, data.error);\r\n                } else {\r\n                    console.log('Battle ready state updated:', data);\r\n                    callback(true, data);\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    toggleReady() {\r\n        this.game.clientNetworkManager.call('TOGGLE_READY');\r\n    }\r\n\r\n    startGame() {\r\n        if (!this.isHost) return;\r\n        this.game.clientNetworkManager.call('START_GAME');\r\n    }\r\n\r\n    leaveRoom() {\r\n        this.game.clientNetworkManager.call('LEAVE_ROOM');\r\n    }\r\n\r\n    handlePlayerJoined(data){\r\n\r\n        this.game.uiSystem.showNotification(`${data.playerName} joined the room`, 'info');\r\n        this.game.uiSystem.updateLobby(data.gameState);\r\n    }\r\n\r\n    handlePlayerLeft(data){\r\n\r\n        this.game.uiSystem.showNotification('Player left the room', 'warning');\r\n        this.game.uiSystem.updateLobby(data.gameState);\r\n    }\r\n\r\n    handlePlayerReadyUpdate(data){\r\n\r\n        this.game.uiSystem.updateLobby(data.gameState);\r\n        console.log('handlePlayerReadyUpdate', data);\r\n        // Show notification for ready state changes\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        if (data.playerId === myPlayerId) {\r\n            if(!data.ready){\r\n                console.log(\"not ready\", data);\r\n            }\r\n            this.game.uiSystem.showNotification(\r\n                data.ready ? 'You are ready!' : 'Ready status removed',\r\n                data.ready ? 'success' : 'info'\r\n            );\r\n        }\r\n        \r\n        if (data.allReady) {\r\n            this.game.uiSystem.showNotification('All players ready! Game starting...', 'success');\r\n        }\r\n    }\r\n\r\n    handleGameStarted(data){\r\n        this.game.gameManager.initializeGame(data);\r\n    }\r\n\r\n    handleReadyForBattleUpdate(data) {\r\n        this.game.placementSystem.handleReadyForBattleUpdate(data);\r\n    }\r\n\r\n    handleBattleEnd(data) {\r\n        \r\n        if (data.entitySync) {\r\n            this.resyncEntities(data.entitySync);\r\n        }\r\n        this.game.triggerEvent('onBattleEnd');        \r\n        console.log('battle result', data);\r\n        this.game.desyncDebugger.displaySync(true); \r\n        this.game.desyncDebugger.enabled = false;\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        data.gameState?.players?.forEach((player) => {\r\n            if(player.id == myPlayerId) {\r\n                this.game.state.playerGold = player.stats.gold;\r\n            }\r\n        })\r\n        this.game.state.round += 1;\r\n        // Transition back to placement phase\r\n        this.game.state.phase = 'placement';\r\n        this.game.triggerEvent('onPlacementPhaseStart');   \r\n    }\r\n\r\n    resyncEntities(entitySync) {\r\n\r\n        for (const [entityId, components] of Object.entries(entitySync)) {\r\n        \r\n            \r\n            for (const [componentType, componentData] of Object.entries(components)) {\r\n                if (this.game.hasComponent(entityId, componentType)) {\r\n                    const existing = this.game.getComponent(entityId, componentType);\r\n                    Object.assign(existing, componentData);\r\n                } \r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    handleGameEnd(data) {\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        if (data.result.winner === myPlayerId) {\r\n            this.game.uiSystem.showNotification('GAME WON! Congratulations!', 'success');\r\n        } else {\r\n            this.game.uiSystem.showNotification('Game lost. Better luck next time!', 'warning');\r\n        }\r\n    }\r\n \r\n    handleRoundResult(roundResult) {\r\n        const state = this.game.state;\r\n        state.phase = 'ended';      \r\n    }\r\n\r\n    handleOpponentSquadTarget(data) {\r\n        const { placementId, targetPosition, meta } = data;\r\n        this.game.unitOrderSystem.applySquadTargetPosition(placementId, targetPosition, meta);        \r\n    }\r\n\r\n    handleOpponentSquadTargets(data) {\r\n        const { placementIds, targetPositions, meta } = data;\r\n        this.game.unitOrderSystem.applySquadsTargetPositions(placementIds, targetPositions, meta);        \r\n    }\r\n\r\n    syncWithServerState(data) {\r\n        if(!data.gameState) return;\r\n        const gameState = data.gameState;\r\n        if (!gameState.players) return;\r\n        console.log('sync with server', gameState);\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        const myPlayer = gameState.players.find(p => p.id === myPlayerId);\r\n        \r\n        if (myPlayer) {\r\n            // Sync squad count and side\r\n            if (this.game.state) {\r\n                this.game.state.mySide = myPlayer.stats.side;\r\n                this.game.state.playerGold = myPlayer.stats.gold;\r\n                this.game.state.playerHealth = myPlayer.stats.health;\r\n                this.game.state.round = gameState.round;\r\n                this.game.state.serverGameState = gameState;\r\n            }\r\n            \r\n            // Set team sides in grid system\r\n            const opponent = gameState.players.find(p => p.id !== myPlayerId);\r\n            if (opponent && this.game.gridSystem) {\r\n                this.game.gridSystem.setTeamSides({\r\n                    player: myPlayer.stats.side,\r\n                    enemy: opponent.stats.side\r\n                });\r\n            }\r\n            \r\n            // Also set sides in placement system\r\n            if (this.game.placementSystem ) {\r\n                if(this.game.placementSystem.setTeamSides) {\r\n                \r\n                    this.game.placementSystem.setTeamSides({\r\n                        player: myPlayer.stats.side,\r\n                        enemy: opponent.stats.side\r\n                    });\r\n                }\r\n\r\n                this.game.placementSystem.setPlacementExperience(myPlayer.placements);\r\n            }\r\n\r\n                \r\n            // Update UI to reflect synced experience data\r\n            if (this.game.shopSystem && this.game.shopSystem.updateGoldDisplay) {\r\n                this.game.shopSystem.updateGoldDisplay();\r\n            }\r\n            \r\n        }\r\n    }\r\n \r\n    dispose() {\r\n        this.networkUnsubscribers.forEach(unsubscribe => {\r\n            if (typeof unsubscribe === 'function') {\r\n                unsubscribe();\r\n            }\r\n        });\r\n        this.networkUnsubscribers = [];\r\n        \r\n    }\r\n\r\n         \r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/MultiplayerNetworkManager.js",
        "fileName": "MultiplayerNetworkManager"
      },
      "AutoBattleMultiplayerManager": {
        "fileName": "AutoBattleMultiplayerManager"
      },
      "LoadingManager": {
        "script": "class LoadingManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.loadingManager = this;\r\n        this.loadingSteps = [\r\n            'Initializing game engine...',\r\n            'Loading unit data...',\r\n            'Preparing battlefield...',\r\n            'Setting up AI opponents...',\r\n            'Ready to battle!'\r\n        ];\r\n    }\r\n\r\n    showLoadingWithProgress(onComplete) {\r\n        let currentStep = 0;\r\n        const loadingText = document.querySelector('.loading-text');\r\n        \r\n        const progressInterval = setInterval(() => {\r\n            if (currentStep < this.loadingSteps.length) {\r\n                if (loadingText) {\r\n                    loadingText.textContent = this.loadingSteps[currentStep];\r\n                }\r\n                currentStep++;\r\n            } else {\r\n                clearInterval(progressInterval);\r\n                onComplete();\r\n            }\r\n        }, 400);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/LoadingManager.js",
        "fileName": "LoadingManager"
      },
      "SquadManager": {
        "script": "class SquadManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.squadManager = this;\r\n        this.ELEMENT_TYPES = {\r\n            PHYSICAL: 'physical',\r\n            FIRE: 'fire',\r\n            COLD: 'cold',\r\n            LIGHTNING: 'lightning',\r\n            POISON: 'poison',\r\n            DIVINE: 'divine'\r\n        };\r\n        \r\n        this.DEFAULT_SQUAD_CONFIG = {\r\n            squadWidth: 1,\r\n            squadHeight: 1,\r\n            placementGridWidth: 1,\r\n            placementGridHeight: 1\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Extract squad configuration from unit type definition\r\n     * @param {Object} unitType - Unit type definition\r\n     * @returns {Object} Squad configuration with dimensions\r\n     */\r\n    getSquadData(unitType) {\r\n        return {\r\n            squadWidth: unitType.squadWidth || this.DEFAULT_SQUAD_CONFIG.squadWidth,\r\n            squadHeight: unitType.squadHeight || this.DEFAULT_SQUAD_CONFIG.squadHeight,\r\n            placementGridWidth: unitType.placementGridWidth || this.DEFAULT_SQUAD_CONFIG.placementGridWidth,\r\n            placementGridHeight: unitType.placementGridHeight || this.DEFAULT_SQUAD_CONFIG.placementGridHeight\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Calculate which grid cells a squad would occupy\r\n     * @param {Object} gridPos - Center grid position {x, z}\r\n     * @param {Object} squadData - Squad configuration\r\n     * @returns {Array} Array of cell positions {x, z}\r\n     */\r\n    getSquadCells(gridPos, squadData) {\r\n        const cells = [];\r\n        const { placementGridWidth, placementGridHeight } = squadData;\r\n        \r\n        if(squadData.collection == \"buildings\"){\r\n            return this.calculateFootprintCells(gridPos, squadData);\r\n        }\r\n        // Calculate starting position to center the formation\r\n        const startX = gridPos.x - Math.floor(placementGridWidth / 2);\r\n        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);\r\n        \r\n        for (let x = 0; x < placementGridWidth; x++) {\r\n            for (let z = 0; z < placementGridHeight; z++) {\r\n                cells.push({\r\n                    x: startX + x,\r\n                    z: startZ + z\r\n                });\r\n            }\r\n        }\r\n        \r\n        return cells;\r\n    }\r\n      \r\n    calculateFootprintCells(gridPos, building) {\r\n        const cells = [];\r\n        // Footprint is in terrain grid units - use directly for preview\r\n        const footprintWidth = building.footprintWidth || building.placementGridWidth || 1;\r\n        const footprintHeight = building.footprintHeight || building.placementGridHeight || 1;\r\n\r\n        const startX = gridPos.x - Math.floor(footprintWidth * 2 / 2);\r\n        const startZ = gridPos.z - Math.floor(footprintHeight * 2 / 2);\r\n\r\n        // Calculate center position for each footprint cell in placement grid coordinates\r\n        for (let z = 0; z < footprintHeight; z++) {\r\n            for (let x = 0; x < footprintWidth; x++) {\r\n                // Each footprint cell is centered in its 2x2 placement grid area\r\n                cells.push({\r\n                    x: startX + x * 2 + 1,  // Center of 2-cell width\r\n                    z: startZ + z * 2 + 1   // Center of 2-cell height\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }  \r\n    /**\r\n     * Calculate world positions for individual units within a squad formation\r\n     * @param {Object} gridPos - Center grid position {x, z}\r\n     * @param {Object} squadData - Squad configuration\r\n     * @param {Object} gridSystem - GridSystem instance for coordinate conversion\r\n     * @returns {Array} Array of world positions {x, z}\r\n     */\r\n    calculateUnitPositions(gridPos, unitType) {\r\n        const squadData = this.getSquadData(unitType);\r\n        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;\r\n        const positions = [];\r\n        const cellSize = this.game.gridSystem.dimensions.cellSize;\r\n\r\n        // Compute the top-left (min) cell of the formation footprint\r\n        const startCellX = gridPos.x - Math.floor(placementGridWidth / 2);\r\n        const startCellZ = gridPos.z - Math.floor(placementGridHeight / 2);\r\n\r\n        // Compute the true geometric center of the whole footprint, even for even sizes\r\n        // Example: width=2 -> center at (start + 0.5); width=3 -> center at (start + 1)\r\n        const centerCellX = startCellX + (placementGridWidth - 1) / 2;\r\n        const centerCellZ = startCellZ + (placementGridHeight - 1) / 2;\r\n        const centerWorldPos = this.game.gridSystem.gridToWorld(centerCellX, centerCellZ);\r\n\r\n        // If squad footprint matches placement footprint, snap each unit to its cell center.\r\n        if (squadWidth === placementGridWidth && squadHeight === placementGridHeight) {\r\n            for (let row = 0; row < squadHeight; row++) {\r\n                for (let col = 0; col < squadWidth; col++) {\r\n                    const cellX = startCellX + col;\r\n                    const cellZ = startCellZ + row;\r\n                    const wp = this.game.gridSystem.gridToWorld(cellX, cellZ);\r\n                    positions.push({ x: wp.x, z: wp.z });\r\n                }\r\n            }\r\n            return positions;\r\n        }\r\n\r\n        // General case: distribute units evenly across the footprint bounds\r\n        const formationWorldWidth  = placementGridWidth  * cellSize;\r\n        const formationWorldHeight = placementGridHeight * cellSize;\r\n\r\n        // Single unit: drop on the geometric center of the footprint\r\n        if (squadWidth === 1 && squadHeight === 1) {\r\n            positions.push({ x: centerWorldPos.x, z: centerWorldPos.z });\r\n            return positions;\r\n        }\r\n\r\n        // Start from the top-left point of the unit grid *inside* the formation bounds\r\n        const stepX = formationWorldWidth  / Math.max(1, squadWidth);\r\n        const stepZ = formationWorldHeight / Math.max(1, squadHeight);\r\n\r\n        const startX = centerWorldPos.x - (formationWorldWidth / 2) + (stepX / 2);\r\n        const startZ = centerWorldPos.z - (formationWorldHeight / 2) + (stepZ / 2);\r\n\r\n        console.log(stepX, formationWorldWidth, squadWidth, centerWorldPos, formationWorldWidth, stepX);\r\n\r\n        for (let row = 0; row < squadHeight; row++) {\r\n            for (let col = 0; col < squadWidth; col++) {\r\n                const x = startX + col * stepX;\r\n                const z = startZ + row * stepZ;\r\n                positions.push({ x, z });\r\n            }\r\n        }\r\n\r\n        return positions;\r\n    }\r\n\r\n    /**\r\n     * Check if a squad can fit within given zone bounds\r\n     * @param {Object} squadData - Squad configuration\r\n     * @param {Object} bounds - Zone boundaries {minX, maxX, minZ, maxZ}\r\n     * @returns {boolean} True if squad can fit\r\n     */\r\n    canFitInZone(squadData, bounds) {\r\n        const zoneWidth = bounds.maxX - bounds.minX + 1;\r\n        const zoneHeight = bounds.maxZ - bounds.minZ + 1;\r\n        \r\n        return squadData.placementGridWidth <= zoneWidth && \r\n               squadData.placementGridHeight <= zoneHeight;\r\n    }\r\n    \r\n    /**\r\n     * Calculate the total number of units in a squad\r\n     * @param {Object} squadData - Squad configuration\r\n     * @returns {number} Total unit count\r\n     */\r\n    getSquadSize(squadData) {\r\n        return squadData.squadWidth * squadData.squadHeight;\r\n    }\r\n    \r\n    /**\r\n     * Get formation type based on squad dimensions\r\n     * @param {Object} squadData - Squad configuration\r\n     * @returns {string} Formation type description\r\n     */\r\n    getFormationType(squadData) {\r\n        const { squadWidth, squadHeight } = squadData;\r\n        \r\n        if (squadWidth === 1 && squadHeight === 1) {\r\n            return 'single';\r\n        } else if (squadWidth === 1) {\r\n            return 'column';\r\n        } else if (squadHeight === 1) {\r\n            return 'line';\r\n        } else if (squadWidth === squadHeight) {\r\n            return 'square';\r\n        } else {\r\n            return 'rectangle';\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate formation density (units per grid cell)\r\n     * @param {Object} squadData - Squad configuration\r\n     * @returns {number} Units per grid cell ratio\r\n     */\r\n    getFormationDensity(squadData) {\r\n        const totalUnits = this.getSquadSize(squadData);\r\n        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;\r\n        return totalUnits / gridCells;\r\n    }\r\n    \r\n    /**\r\n     * Get optimal spacing between units in world coordinates\r\n     * @param {Object} squadData - Squad configuration\r\n     * @param {Object} gridSystem - GridSystem instance\r\n     * @returns {Object} Spacing values {x, z}\r\n     */\r\n    getUnitSpacing(squadData, gridSystem) {\r\n        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;\r\n        \r\n        const formationWorldWidth = placementGridWidth * gridSystem.dimensions.cellSize;\r\n        const formationWorldHeight = placementGridHeight * gridSystem.dimensions.cellSize;\r\n        \r\n        return {\r\n            x: squadWidth > 1 ? formationWorldWidth / squadWidth : 0,\r\n            z: squadHeight > 1 ? formationWorldHeight / squadHeight : 0\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Validate squad configuration\r\n     * @param {Object} squadData - Squad configuration to validate\r\n     * @returns {Object} Validation result {valid, errors}\r\n     */\r\n    validateSquadConfig(squadData) {\r\n        const errors = [];\r\n        \r\n        if (!squadData) {\r\n            errors.push('Squad data is required');\r\n            return { valid: false, errors };\r\n        }\r\n        \r\n        const requiredFields = ['squadWidth', 'squadHeight', 'placementGridWidth', 'placementGridHeight'];\r\n        for (const field of requiredFields) {\r\n            if (typeof squadData[field] !== 'number' || squadData[field] < 1) {\r\n                errors.push(`${field} must be a positive number`);\r\n            }\r\n        }\r\n        \r\n        // Logical validations\r\n        if (squadData.squadWidth > squadData.placementGridWidth * 10) {\r\n            errors.push('Squad width seems unreasonably large for grid size');\r\n        }\r\n        \r\n        if (squadData.squadHeight > squadData.placementGridHeight * 10) {\r\n            errors.push('Squad height seems unreasonably large for grid size');\r\n        }\r\n        \r\n        // Check if formation makes sense\r\n        const totalUnits = squadData.squadWidth * squadData.squadHeight;\r\n        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;\r\n        \r\n        if (totalUnits > gridCells * 4) {\r\n            errors.push('Too many units for the allocated grid space');\r\n        }\r\n        \r\n        return {\r\n            valid: errors.length === 0,\r\n            errors\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Generate squad info for display purposes\r\n     * @param {Object} unitType - Unit type definition\r\n     * @returns {Object} Formatted squad information\r\n     */\r\n    getSquadInfo(unitType) {\r\n        const squadData = this.getSquadData(unitType);\r\n        const validation = this.validateSquadConfig(squadData);\r\n        \r\n        return {\r\n            unitName: unitType.title || unitType.id || 'Unknown Unit',\r\n            squadSize: this.getSquadSize(squadData),\r\n            formationType: this.getFormationType(squadData),\r\n            density: this.getFormationDensity(squadData),\r\n            gridFootprint: `${squadData.placementGridWidth}x${squadData.placementGridHeight}`,\r\n            unitFormation: `${squadData.squadWidth}x${squadData.squadHeight}`,\r\n            isValid: validation.valid,\r\n            errors: validation.errors,\r\n            cost: unitType.value || 0,\r\n            totalValue: (unitType.value || 0) * this.getSquadSize(squadData)\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Check if two squads would overlap\r\n     * @param {Object} pos1 - First squad position\r\n     * @param {Object} squad1 - First squad data\r\n     * @param {Object} pos2 - Second squad position  \r\n     * @param {Object} squad2 - Second squad data\r\n     * @returns {boolean} True if squads overlap\r\n     */\r\n    wouldSquadsOverlap(pos1, squad1, pos2, squad2) {\r\n        const cells1 = this.getSquadCells(pos1, squad1);\r\n        const cells2 = this.getSquadCells(pos2, squad2);\r\n        \r\n        for (const cell1 of cells1) {\r\n            for (const cell2 of cells2) {\r\n                if (cell1.x === cell2.x && cell1.z === cell2.z) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Find all valid positions for a squad within bounds\r\n     * @param {Object} squadData - Squad configuration\r\n     * @param {Object} bounds - Zone boundaries\r\n     * @param {Set} occupiedCells - Set of occupied cell keys \"x,z\"\r\n     * @returns {Array} Array of valid grid positions\r\n     */\r\n    findValidPositions(squadData, bounds, occupiedCells = new Set()) {\r\n        const validPositions = [];\r\n        \r\n        // Check each possible center position\r\n        for (let x = bounds.minX; x <= bounds.maxX; x++) {\r\n            for (let z = bounds.minZ; z <= bounds.maxZ; z++) {\r\n                const gridPos = { x, z };\r\n                const cells = this.getSquadCells(gridPos, squadData);\r\n                \r\n                // Check if all cells are within bounds and unoccupied\r\n                const isValid = cells.every(cell => {\r\n                    if (cell.x < bounds.minX || cell.x > bounds.maxX ||\r\n                        cell.z < bounds.minZ || cell.z > bounds.maxZ) {\r\n                        return false;\r\n                    }\r\n                    \r\n                    const key = `${cell.x},${cell.z}`;\r\n                    return !occupiedCells.has(key);\r\n                });\r\n                \r\n                if (isValid) {\r\n                    validPositions.push(gridPos);\r\n                }\r\n            }\r\n        }\r\n        \r\n        return validPositions;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SquadManager.js",
        "fileName": "SquadManager"
      },
      "SaveManager": {
        "script": "class SaveManager {\r\n    constructor(app) {\r\n        this.game = app;\r\n        this.game.saveManager = this;\r\n        this.setupAutoSave();\r\n    }\r\n\r\n    setupAutoSave() {\r\n        // Auto-save every 30 seconds\r\n        setInterval(() => {\r\n            this.saveGameState();\r\n        }, 30000);\r\n    }\r\n\r\n    saveGameState() {\r\n     \r\n    }\r\n\r\n    loadGameState() {\r\n        // In a real implementation, you might load from localStorage here\r\n        // const saved = localStorage.getItem('autoBattleArena_save');\r\n        // return saved ? JSON.parse(saved) : null;\r\n        return null;\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SaveManager.js",
        "fileName": "SaveManager"
      }
    },
    "systems": {
      "AbilitySystem": {
        "script": "class AbilitySystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.abilitySystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        this.abilityActionCounter = 0;\r\n        this.entityAbilities = new Map();\r\n        this.abilityCooldowns = new Map();\r\n        this.abilityQueue = new Map();\r\n        this.abilityActions = new Map();\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('getEntityAbilities', this.getEntityAbilities.bind(this));\r\n        this.game.gameManager.register('removeEntityAbilities', this.removeEntityAbilities.bind(this));\r\n    }\r\n\r\n    addAbilitiesToUnit(entityId, abilityIds) {\r\n        if (!Array.isArray(abilityIds)) {\r\n            abilityIds = [abilityIds];\r\n        }\r\n        const unitAbilities = [];\r\n        \r\n        abilityIds.forEach(abilityId => {\r\n            const AbilityClass = this.game.app.appClasses[abilityId];\r\n            if (AbilityClass) {\r\n                const abilityInstance = new AbilityClass(this.game, this.game.getCollections().abilities[abilityId]);\r\n                unitAbilities.push(abilityInstance);\r\n            } else {\r\n                console.warn(`Ability '${abilityId}' not found`);\r\n            }\r\n        });\r\n        \r\n        if (unitAbilities.length > 0) {\r\n            this.entityAbilities.set(entityId, unitAbilities);\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (this.game.state.phase !== 'battle') return;\r\n\r\n        this.processAbilityQueue();\r\n        this.processAbilityActions();\r\n        this.updateAIAbilityUsage();\r\n    }\r\n    processAbilityQueue() {        \r\n        for (const [entityId, queuedAbility] of this.abilityQueue.entries()) {\r\n            if (this.game.state.now >= queuedAbility.executeTime) {\r\n                const abilities = this.entityAbilities.get(entityId);\r\n                if (abilities) {\r\n                    const ability = abilities.find(a => a.id === queuedAbility.abilityId);\r\n                    if (ability) {\r\n                        // Execute ability and get potential callback\r\n                        const abilityAction = ability.execute(entityId, queuedAbility.targetData);\r\n                        \r\n                        // If ability returns a callback, schedule it deterministically\r\n                        if (typeof abilityAction === 'function') {\r\n                            // Add to a delayed effects queue\r\n                            this.scheduleAbilityAction(abilityAction, ability.castTime);\r\n                        }\r\n                    }\r\n                }\r\n                this.abilityQueue.delete(entityId);\r\n            }\r\n        }\r\n    }\r\n    scheduleAbilityAction(action, castTime) {        \r\n        const executeTime = this.game.state.now + castTime;\r\n        const effectId = `${this.game.state.now}_${this.abilityActionCounter++}`;\r\n    \r\n        this.abilityActions.set(effectId, {\r\n            callback: action,\r\n            executeTime: executeTime\r\n        });\r\n    }\r\n    processAbilityActions() {\r\n        if (!this.abilityActions) return;\r\n        \r\n        for (const [effectId, abilityAction] of this.abilityActions.entries()) {\r\n            if (this.game.state.now >= abilityAction.executeTime) {\r\n                abilityAction.callback();\r\n                this.abilityActions.delete(effectId);\r\n            }\r\n        }\r\n    }\r\n    updateAIAbilityUsage() {\r\n        const sortedEntityIds = Array.from(this.entityAbilities.keys()).sort((a, b) => \r\n            String(a).localeCompare(String(b))\r\n        );\r\n        \r\n        sortedEntityIds.forEach(entityId => {\r\n            const abilities = this.entityAbilities.get(entityId);\r\n            this.considerAbilityUsage(entityId, abilities);\r\n        });\r\n    }\r\n    \r\n    considerAbilityUsage(entityId, abilities) {\r\n        if (this.abilityQueue.has(entityId)) {\r\n            return; // Entity is already casting an ability, wait for it to finish\r\n        }\r\n        \r\n        const availableAbilities = abilities\r\n            .filter(ability => this.isAbilityOffCooldown(entityId, ability.id))\r\n            .filter(ability => ability.canExecute(entityId))\r\n            .sort((a, b) => b.priority - a.priority);\r\n        \r\n        // Check if unit is waiting and now has abilities available\r\n        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);\r\n        if (aiState && aiState.state === 'waiting' && availableAbilities.length > 0) {\r\n            // Transition back to attacking state since we have abilities ready\r\n            if (this.game.combatAISystems) {\r\n                this.game.combatAISystems.changeAIState(aiState, 'attacking');\r\n                \r\n                // Re-enable movement decisions by resetting decision time\r\n                aiState.aiBehavior.lastDecisionTime = 0;\r\n                \r\n            }\r\n        }\r\n        \r\n        if (availableAbilities.length > 0) {\r\n            this.useAbility(entityId, availableAbilities[0].id);\r\n        }\r\n    }\r\n    \r\n    useAbility(entityId, abilityId, targetData = null) {\r\n        const abilities = this.entityAbilities.get(entityId);\r\n        if (!abilities) return false;\r\n        \r\n        const ability = abilities.find(a => a.id === abilityId);\r\n        if (!ability) return false;\r\n        \r\n\r\n        \r\n        if (!this.isAbilityOffCooldown(entityId, abilityId)) {\r\n            return false;\r\n        }\r\n        \r\n        if (!ability.canExecute(entityId, targetData)) {\r\n            return false;\r\n        }\r\n\r\n        if (!ability.isPassive) {\r\n            this.startAbilityAnimation(entityId, ability);\r\n        }\r\n        this.abilityQueue.set(entityId, {\r\n            abilityId: abilityId,\r\n            targetData: targetData,\r\n            executeTime: this.game.state.now + ability.castTime\r\n        });\r\n        \r\n        this.setCooldown(entityId, abilityId, ability.cooldown);\r\n        ability.logAbilityUsage(entityId);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    startAbilityAnimation(entityId, ability) {\r\n        const animationsToTry = ['attack', 'idle'];\r\n\r\n        for (const anim of animationsToTry) {\r\n\r\n            // For abilities, use normal speed unless it's an attack-based ability\r\n            let animationSpeed = 1.0;\r\n            let minAnimationTime = 1.5;\r\n\r\n            if (ability) {\r\n                animationSpeed = this.game.gameManager.call('calculateAnimationSpeed', entityId, ability.castTime);\r\n                minAnimationTime = 1 / ability.castTime;\r\n            }\r\n            if(this.game.gameManager.has('triggerSinglePlayAnimation')){\r\n                this.game.gameManager.call('triggerSinglePlayAnimation', entityId, anim, animationSpeed, minAnimationTime);\r\n            }\r\n            break;\r\n\r\n        }\r\n    }\r\n    \r\n    setCooldown(entityId, abilityId, cooldownDuration) {\r\n        const key = `${entityId}_${abilityId}`;\r\n        this.abilityCooldowns.set(key, this.game.state.now + cooldownDuration);\r\n    }\r\n    \r\n    isAbilityOffCooldown(entityId, abilityId) {\r\n        const key = `${entityId}_${abilityId}`;\r\n        const cooldownEnd = this.abilityCooldowns.get(key);\r\n        return !cooldownEnd || this.game.state.now >= cooldownEnd;\r\n    }\r\n    \r\n    getRemainingCooldown(entityId, abilityId) {\r\n        const key = `${entityId}_${abilityId}`;\r\n        const cooldownEnd = this.abilityCooldowns.get(key);\r\n        return !cooldownEnd ? 0 : Math.max(0, cooldownEnd - this.game.state.now);\r\n    }\r\n    \r\n    getEntityAbilities(entityId) {\r\n        return this.entityAbilities.get(entityId) || [];\r\n    }\r\n    \r\n    getAbilityCooldowns(entityId) {\r\n        const abilities = this.getEntityAbilities(entityId);\r\n\r\n        return abilities.map(ability => ({\r\n            id: ability.id,\r\n            name: ability.name,\r\n            remainingCooldown: this.getRemainingCooldown(entityId, ability.id),\r\n            totalCooldown: ability.cooldown\r\n        }));\r\n    }\r\n    \r\n    createAbility(abilityId) {\r\n        const AbilityClass = this.game.app.appClasses[abilityId];\r\n        return AbilityClass ? new AbilityClass() : null;\r\n    }\r\n    \r\n    getAvailableAbilityIds() {\r\n        return Object.keys(this.game.getCollections().abilities);\r\n    }\r\n        \r\n    removeEntityAbilities(entityId) {\r\n        this.entityAbilities.delete(entityId);\r\n        this.abilityQueue.delete(entityId);\r\n        \r\n        // Clean up cooldowns\r\n        const keysToRemove = [];\r\n        for (const key of this.abilityCooldowns.keys()) {\r\n            if (key.startsWith(`${entityId}_`)) {\r\n                keysToRemove.push(key);\r\n            }\r\n        }\r\n        keysToRemove.forEach(key => this.abilityCooldowns.delete(key));\r\n        \r\n    }\r\n    onPlacementPhaseStart() {\r\n        for (const [entityId, abilities] of this.entityAbilities.entries()) {\r\n            abilities.forEach(ability => {\r\n                if (typeof ability.onPlacementPhaseStart === 'function') {\r\n                    ability.onPlacementPhaseStart(entityId);\r\n                }\r\n            });\r\n        }            \r\n    }     \r\n    onBattleEnd() {\r\n        \r\n        // Call onBattleEnd on all ability instances\r\n        for (const [entityId, abilities] of this.entityAbilities.entries()) {\r\n            abilities.forEach(ability => {\r\n                if (typeof ability.onBattleEnd === 'function') {\r\n                    ability.onBattleEnd(entityId);\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Clear all ability queues and cooldowns\r\n        this.abilityQueue.clear();\r\n        this.abilityActions.clear();\r\n        this.abilityCooldowns.clear();\r\n        this.abilityActionCounter = 0;\r\n        \r\n    }\r\n\r\n    destroy() {\r\n        this.entityAbilities.clear();\r\n        this.abilityCooldowns.clear();\r\n        this.abilityQueue.clear();\r\n        this.abilityActions.clear();\r\n    }\r\n    entityDestroyed(entityId) {\r\n        this.removeEntityAbilities(entityId);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AbilitySystem.js",
        "fileName": "AbilitySystem"
      },
      "AnimationSystem": {
        "script": "class AnimationSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.animationSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n\r\n        // Animation state tracking (VAT-only, no mixers)\r\n        this.entityAnimationStates = new Map(); // entityId -> { currentClip, lastStateChange, flags, etc. }\r\n        \r\n        // Animation configuration\r\n        this.MIN_MOVEMENT_THRESHOLD = 0.1;\r\n        this.MIN_ATTACK_ANIMATION_TIME = 0.4;\r\n        this.STATE_CHANGE_COOLDOWN = 0.1;\r\n\r\n        // Single-play animations (play once then stop/transition)\r\n        this.SINGLE_PLAY_ANIMATIONS = new Set([\r\n            'attack', 'cast', 'death'\r\n        ]);\r\n\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('triggerSinglePlayAnimation', this.triggerSinglePlayAnimation.bind(this));\r\n        this.game.gameManager.register('isAnimationFinished', this.isAnimationFinished.bind(this));\r\n        this.game.gameManager.register('setCorpseAnimation', this.setCorpseAnimation.bind(this));\r\n        this.game.gameManager.register('startCelebration', this.startCelebration.bind(this));\r\n        this.game.gameManager.register('stopCelebration', this.stopCelebration.bind(this));\r\n        this.game.gameManager.register('playDeathAnimation', this.playDeathAnimation.bind(this));\r\n        this.game.gameManager.register('getEntityAnimations', () => this.entityAnimationStates);\r\n    }\r\n\r\n    update() {\r\n        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;\r\n        this.updateEntityAnimations();\r\n    }\r\n\r\n    updateEntityAnimations() {\r\n        const CT = this.componentTypes;\r\n        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);\r\n\r\n        entities.forEach(entityId => {\r\n            // Only process instanced entities\r\n            if (!this.game.renderSystem?.isInstanced(entityId)) return;\r\n\r\n            const velocity = this.game.getComponent(entityId, CT.VELOCITY);\r\n            const health = this.game.getComponent(entityId, CT.HEALTH);\r\n            const combat = this.game.getComponent(entityId, CT.COMBAT);\r\n            const aiState = this.game.getComponent(entityId, CT.AI_STATE);\r\n\r\n            // Ensure entity has animation state\r\n            if (!this.entityAnimationStates.has(entityId)) {\r\n                this.initializeEntityAnimationState(entityId);\r\n            }\r\n\r\n            // Update animation logic\r\n            this.updateEntityAnimationLogic(entityId, velocity, health, combat, aiState);\r\n        });\r\n\r\n        // Clean up removed entities\r\n        this.cleanupRemovedEntities(new Set(entities));\r\n    }\r\n\r\n    initializeEntityAnimationState(entityId) {\r\n        const state = {\r\n            currentClip: 'idle',\r\n            lastStateChange: this.game.state?.now || 0,\r\n            animationTime: 0,\r\n            minAnimationTime: 0,\r\n            pendingClip: null,\r\n            pendingSpeed: null,\r\n            pendingMinTime: null,\r\n            isTriggered: false,\r\n            isDying: false,\r\n            isCorpse: false,\r\n            isCelebrating: false,\r\n            // NEW: Track fallback usage to prevent thrashing\r\n            lastRequestedClip: null,    // What was originally requested\r\n            lastResolvedClip: null,     // What actually got set\r\n            fallbackCooldown: 0         // Time remaining before allowing re-request of failed clip\r\n        };\r\n\r\n        this.entityAnimationStates.set(entityId, state);\r\n\r\n        // Set initial animation\r\n        this.game.renderSystem?.setInstanceClip(entityId, 'idle', true);\r\n        this.game.renderSystem?.setInstanceSpeed(entityId, 1);\r\n\r\n    }\r\n\r\n    updateEntityAnimationLogic(entityId, velocity, health, combat, aiState) {\r\n    \r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return;\r\n\r\n        const currentTime = this.game.state?.now || 0;\r\n        const deltaTime = this.game.state?.deltaTime || 1/60;\r\n        animState.animationTime += deltaTime;\r\n\r\n        // NEW: Handle animation completion for locked states\r\n        if (animState.isDying || animState.isCorpse || animState.isCelebrating) {\r\n            // Handle celebration completion ONLY\r\n            if (animState.isCelebrating && this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {\r\n                const isFinished = this.isAnimationFinished(entityId, animState.currentClip);\r\n                \r\n                if (isFinished) {\r\n                    this.stopCelebration(entityId);\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            return; // Still locked, don't process normal animation logic\r\n        }\r\n        // Handle pending triggered animations (from external calls)\r\n        if (animState.isTriggered && animState.pendingClip) {\r\n            this.applyTriggeredAnimation(entityId, animState);\r\n            return;\r\n        }\r\n\r\n        // Determine desired animation based on game state\r\n        const desired = this.determineDesiredAnimation(entityId, velocity, health, combat, aiState);\r\n    \r\n        // Check if we should change animation\r\n        const shouldChange = this.shouldChangeAnimation(entityId, animState, desired, currentTime);\r\n        \r\n\r\n        if (shouldChange) {\r\n            this.changeAnimation(entityId, desired.clip, desired.speed, desired.minTime);\r\n        } else {\r\n            // Update animation speed if needed (for continuous animations)\r\n            this.updateAnimationSpeed(entityId, desired.speed);\r\n        }\r\n    }\r\n\r\n    determineDesiredAnimation(entityId, velocity, health, combat, aiState) {\r\n        let clip = 'idle';\r\n        let speed = 1.0;\r\n        let minTime = 0;\r\n\r\n        if(this.game.state.phase == 'battle'){\r\n            // Check movement first\r\n            const isMoving = velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD);\r\n            \r\n            if (isMoving) {\r\n                clip = 'walk';\r\n                speed = this.calculateWalkSpeed(velocity);\r\n            }\r\n\r\n            // AI state overrides\r\n            if (aiState) {\r\n                switch (aiState.state) {\r\n                    case 'attacking':\r\n                    case 'combat':\r\n                        // During combat, prefer walking if moving, otherwise idle\r\n                        if (!isMoving) {\r\n                            clip = 'idle';\r\n                            speed = 1.0;\r\n                        }\r\n                        break;\r\n                        \r\n                    case 'chasing':\r\n                    case 'moving':\r\n                        clip = 'walk';\r\n                        speed = this.calculateWalkSpeed(velocity);\r\n                        break;\r\n                        \r\n                    case 'waiting':\r\n                        clip = isMoving ? 'walk' : 'idle';\r\n                        if (isMoving) speed = this.calculateWalkSpeed(velocity);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return { clip, speed, minTime };\r\n    }\r\n\r\n    shouldChangeAnimation(entityId, animState, desired, currentTime) {\r\n        // 1) If we are in a single-play clip, don't allow state changes until it's finished\r\n        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {\r\n            const finished = this.isAnimationFinished(entityId, animState.currentClip);\r\n\r\n            // Respect explicit minAnimationTime as an additional guard\r\n            const minTimeSatisfied = (animState.minAnimationTime <= 0) || (animState.animationTime >= animState.minAnimationTime);\r\n\r\n            // Block changes until BOTH: (a) clip finished OR (b) min time satisfied (use whichever is stricter for your game)\r\n            // If you want strictly \"finished\", change to: if (!finished) return false;\r\n            if (!finished && !minTimeSatisfied) {\r\n                return false;\r\n            }\r\n            // Once finished (or min time hit), we can flow through to normal logic below.\r\n        }\r\n\r\n        // 2) Cooldown: prevent thrashing even for continuous animations\r\n        const timeSinceLastChange = currentTime - animState.lastStateChange;\r\n        if(timeSinceLastChange < 0){\r\n            return true;\r\n\r\n        }\r\n        if (timeSinceLastChange < this.STATE_CHANGE_COOLDOWN) {\r\n            return false;\r\n        }\r\n\r\n        // 3) If the desired clip differs, allow change (this now runs AFTER the single-play guard)\r\n        if (animState.currentClip !== desired.clip) {\r\n            return true;\r\n        }\r\n\r\n        // 4) For single-play, if somehow the clip finished (edge case) allow refresh\r\n        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {\r\n            if (this.isAnimationFinished(entityId, animState.currentClip)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // 5) Respect minAnimationTime for non-single-play too\r\n        if (animState.minAnimationTime > 0 && animState.animationTime < animState.minAnimationTime) {\r\n            return false;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    changeAnimation(entityId, clipName, speed = 1.0, minTime = 0) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return false;\r\n\r\n        // Try to resolve clip name to available clip\r\n        const resolvedClip = this.resolveClipName(entityId, clipName);\r\n        \r\n        // Apply animation change\r\n        const success = this.game.renderSystem?.setInstanceClip(entityId, resolvedClip, true);\r\n        if (success) {\r\n            this.game.renderSystem?.setInstanceSpeed(entityId, speed);\r\n            \r\n            // Update state\r\n            animState.currentClip = resolvedClip;\r\n            animState.lastStateChange = this.game.state?.now || 0;\r\n            animState.animationTime = 0;\r\n            animState.minAnimationTime = minTime;\r\n            \r\n            return true;\r\n        } else {\r\n            console.warn(`[AnimationSystem]  Failed to change animation for entity ${entityId}: ${clipName} -> ${resolvedClip}`);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    updateAnimationSpeed(entityId, targetSpeed) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return;\r\n\r\n        // Only update speed for continuous animations\r\n        if (!this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {\r\n            this.game.renderSystem?.setInstanceSpeed(entityId, targetSpeed);\r\n        }\r\n    }\r\n\r\n    applyTriggeredAnimation(entityId, animState) {\r\n        const clip = animState.pendingClip;\r\n        const speed = animState.pendingSpeed || 1.0;\r\n        const minTime = animState.pendingMinTime || 0;\r\n\r\n        // Clear pending state\r\n        animState.pendingClip = null;\r\n        animState.pendingSpeed = null;\r\n        animState.pendingMinTime = null;\r\n        animState.isTriggered = false;\r\n\r\n        // Apply the animation\r\n        this.changeAnimation(entityId, clip, speed, minTime);\r\n    }\r\n\r\n    // Public API methods\r\n    \r\n    triggerSinglePlayAnimation(entityId, clipName, speed = 1.0, minTime = 0) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) {\r\n            console.warn(`[AnimationSystem] No animation state for entity ${entityId}`);\r\n            return false;\r\n        }\r\n\r\n        \r\n        // Queue the animation\r\n        animState.pendingClip = clipName;\r\n        animState.pendingSpeed = speed;\r\n        animState.pendingMinTime = minTime;\r\n        animState.isTriggered = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    playDeathAnimation(entityId) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) {\r\n            console.warn(`[AnimationSystem]  No animation state found for entity ${entityId} during death`);\r\n            return;\r\n        }\r\n\r\n        // Set death state\r\n        animState.isDying = true;\r\n        animState.isCorpse = false;\r\n        animState.isCelebrating = false;\r\n        \r\n        // Clear any pending animations\r\n        animState.isTriggered = false;\r\n        animState.pendingClip = null;\r\n        animState.pendingSpeed = null;\r\n        animState.pendingMinTime = null;\r\n        \r\n        // Reset fallback tracking for death animation\r\n        animState.lastRequestedClip = null;\r\n        animState.lastResolvedClip = null;\r\n        animState.fallbackCooldown = 0;\r\n        \r\n        // Apply death animation immediately\r\n        this.changeAnimation(entityId, 'death', 1.0, 0);\r\n        \r\n    }\r\n\r\n    setCorpseAnimation(entityId) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return;\r\n\r\n        // Update animation state flags\r\n        animState.isDying = false;\r\n        animState.isCorpse = true;\r\n        \r\n        // Get the current clip's duration and set to last frame\r\n        const animationStateData = this.game.gameManager.call('getEntityAnimationState', entityId);\r\n        \r\n        if (animationStateData && animationStateData.clipDuration > 0) {\r\n            // Set to 99% through the animation (last frame before loop)\r\n            const lastFrameTime = animationStateData.clipDuration * 0.99;\r\n            this.game.gameManager.call('setInstanceAnimationTime', entityId, lastFrameTime);\r\n        }\r\n        \r\n        // Now freeze it at that frame\r\n        this.game.gameManager.call('setInstanceSpeed', entityId, 0);\r\n    }\r\n\r\n    startCelebration(entityId, teamType = null) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return;\r\n\r\n        animState.isCelebrating = true;\r\n        \r\n        // Try celebration animations, fallback to idle\r\n        const celebrationClips = ['celebrate'];\r\n        let clipToUse = 'idle';\r\n        \r\n        for (const clip of celebrationClips) {\r\n            if (this.hasClip(entityId, clip)) {\r\n                clipToUse = clip;\r\n                break;\r\n            }\r\n        }\r\n\r\n        this.changeAnimation(entityId, clipToUse, 1.0, 0);\r\n    }\r\n\r\n    stopCelebration(entityId) {\r\n        const animState = this.entityAnimationStates.get(entityId);\r\n        if (!animState) return;\r\n\r\n        animState.isCelebrating = false;\r\n        this.changeAnimation(entityId, 'idle', 1.0, 0);\r\n    }\r\n\r\n    entityJump(entityId, speed = 1.0) {\r\n        if (this.hasClip(entityId, 'leap')) {\r\n            this.triggerSinglePlayAnimation(entityId, 'leap', speed, 0.5);\r\n        }\r\n    }\r\n\r\n    entityThrow(entityId, speed = 1.0) {\r\n        if (this.hasClip(entityId, 'throw')) {\r\n            this.triggerSinglePlayAnimation(entityId, 'throw', speed, 0.3);\r\n        }\r\n    }\r\n\r\n    stopAllAnimations(entityId) {\r\n        this.game.renderSystem?.setInstanceSpeed(entityId, 0);\r\n    }\r\n\r\n    // Utility methods\r\n\r\n    calculateWalkSpeed(velocity) {\r\n        if (!velocity) return 1.0;\r\n        const speed = Math.sqrt((velocity.vx || 0) ** 2 + (velocity.vz || 0) ** 2);\r\n        return Math.min(2.0, Math.max(0.5, speed / 30)); // Adjust divisor based on your units\r\n    }\r\n\r\n    isAnimationFinished(entityId, clipName) {\r\n        if (!this.SINGLE_PLAY_ANIMATIONS.has(clipName)) {\r\n            return false; // Continuous animations never finish\r\n        }\r\n\r\n        const animationState = this.game.gameManager.call('getEntityAnimationState', entityId);\r\n        if (!animationState) {\r\n            return true;\r\n        }\r\n\r\n        // Check if we've played through most of the clip\r\n        const progress = animationState.animTime / animationState.clipDuration;\r\n        const isFinished = progress >= 0.9; // Consider finished at 90%\r\n        \r\n        return isFinished;\r\n    }\r\n\r\n    hasClip(entityId, clipName) {\r\n        const CT = this.componentTypes;\r\n        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);\r\n        if (!renderable) return false;\r\n\r\n        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);\r\n        return batchInfo?.availableClips?.includes(clipName) || false;\r\n    }\r\n\r\n    resolveClipName(entityId, desiredClip) {\r\n        const CT = this.componentTypes;\r\n        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);\r\n        if (!renderable) return 'idle';\r\n\r\n        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);\r\n        if (!batchInfo) return 'idle';\r\n\r\n        const availableClips = batchInfo.availableClips;\r\n\r\n        // Return if exact match exists\r\n        if (availableClips.includes(desiredClip)) {\r\n            return desiredClip;\r\n        }\r\n\r\n        // Try fallbacks\r\n        const fallbacks = {\r\n            'attack': ['combat', 'fight', 'swing', 'strike', 'idle'],\r\n            'shoot': ['bow', 'cast', 'throw', 'attack', 'idle'],\r\n            'bow': ['shoot', 'cast', 'throw', 'attack', 'idle'],\r\n            'cast': ['shoot', 'throw', 'attack', 'idle'],\r\n            'walk': ['run', 'move', 'step', 'idle'],\r\n            'hurt': ['damage', 'hit', 'pain', 'idle'],\r\n            'death': ['die', 'idle'],\r\n            'celebrate': ['victory', 'cheer', 'dance', 'happy', 'win', 'idle']\r\n        };\r\n\r\n        const fallbackList = fallbacks[desiredClip] || ['idle'];\r\n        for (const fallback of fallbackList) {\r\n            if (availableClips.includes(fallback)) {\r\n                return fallback;\r\n            }\r\n        }\r\n\r\n        // Final fallback\r\n        return availableClips[0] || 'idle';\r\n    }\r\n\r\n    // Cleanup methods\r\n\r\n    cleanupRemovedEntities(currentEntities) {\r\n        const toRemove = [];\r\n        \r\n        for (const entityId of this.entityAnimationStates.keys()) {\r\n            if (!currentEntities.has(entityId)) {\r\n                toRemove.push(entityId);\r\n            }\r\n        }\r\n\r\n        toRemove.forEach(entityId => {\r\n            this.removeEntityAnimations(entityId);\r\n        });\r\n    }\r\n\r\n    entityDestroyed(entityId){\r\n        this.removeEntityAnimations(entityId);\r\n    }\r\n    removeEntityAnimations(entityId) {\r\n        this.entityAnimationStates.delete(entityId);        \r\n    }\r\n\r\n    destroy() {\r\n        this.entityAnimationStates.clear();\r\n    }\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AnimationSystem.js",
        "fileName": "AnimationSystem"
      },
      "CameraControlSystem": {
        "script": "class CameraControlSystem extends engine.BaseSystem {\r\n  constructor(game) {\r\n    super(game);\r\n    this.game.cameraControlSystem = this;\r\n\r\n    this.SPEED = 900; // world units per second\r\n\r\n    // Mouse state\r\n    this.mouseX = -1;\r\n    this.mouseY = -1;\r\n    this.inside = false;\r\n\r\n    // When mouse leaves the window, keep panning in these directions\r\n    this.holdDirX = 0; // -1 left, +1 right\r\n    this.holdDirZ = 0; // +1 up/forward, -1 down/backward\r\n\r\n    this.vertical_threshold = 10;\r\n\r\n    // Reusable vectors\r\n    this.right = new THREE.Vector3();\r\n    this.fwd   = new THREE.Vector3();\r\n    this.delta = new THREE.Vector3();\r\n  }\r\n\r\n  init() {\r\n    this.game.gameManager.register('cameraLookAt', this.lookAt.bind(this));\r\n\r\n    this.onMove  = (e)=>this.onMouseMove(e);\r\n    this.onEnter = ()=>{ this.inside = true; this.holdDirX = 0; this.holdDirZ = 0; };\r\n    this.onLeave = ()=>this.onMouseLeave();\r\n    this.onBlur  = ()=>{ this.inside = false; this.holdDirX = 0; this.holdDirZ = 0; };\r\n\r\n    window.addEventListener('mousemove', this.onMove, { passive: true });\r\n    window.addEventListener('mouseenter', this.onEnter);\r\n    window.addEventListener('mouseleave', this.onLeave);\r\n    window.addEventListener('blur',      this.onBlur);\r\n    window.addEventListener('wheel', (e) => {\r\n      let dy = e.deltaY;\r\n      if(dy > 0){\r\n        //scrolling down\r\n        this.game.camera.zoom = this.game.camera.zoom * 0.9;\r\n      } else {\r\n        this.game.camera.zoom = this.game.camera.zoom * 1.1;\r\n      }\r\n      this.game.camera.zoom = Math.min(2, this.game.camera.zoom);\r\n      this.game.camera.updateProjectionMatrix();\r\n    });\r\n  }\r\n\r\n  dispose() {\r\n    window.removeEventListener('mousemove', this.onMove);\r\n    window.removeEventListener('mouseenter', this.onEnter);\r\n    window.removeEventListener('mouseleave', this.onLeave);\r\n    window.removeEventListener('blur',       this.onBlur);\r\n  }\r\n\r\n  onMouseMove(e) {\r\n    this.mouseX = e.clientX;\r\n    this.mouseY = e.clientY;\r\n    this.inside = true;\r\n  }\r\n\r\n  onMouseLeave() {\r\n    // Decide which edge we left from and hold that pan direction\r\n    const w = window.innerWidth  || document.documentElement.clientWidth;\r\n    const h = window.innerHeight || document.documentElement.clientHeight;\r\n\r\n    // X hold\r\n    if (this.mouseX <= 0)            this.holdDirX = -1;\r\n    else if (this.mouseX >= w - 1)   this.holdDirX =  1;\r\n    else                              this.holdDirX =  0;\r\n\r\n    // Z hold (reversed per your request: top = +forward, bottom = -backward)\r\n    if (this.mouseY <= this.vertical_threshold)            this.holdDirZ =  1;  // went off top -> forward\r\n    else if (this.mouseY >= h - this.vertical_threshold)   this.holdDirZ = -1;  // went off bottom -> backward\r\n    else                              this.holdDirZ =  0;\r\n\r\n    this.inside = false;\r\n  }\r\n\r\n  clampCamera(camera, padding = 0) {\r\n    const extendedSize = this.game.gameManager.call('getWorldExtendedSize');\r\n    const half = extendedSize ? extendedSize * 0.5 : 1000;\r\n    camera.position.x = Math.max(-half + padding, Math.min(half - padding, camera.position.x));\r\n    camera.position.z = Math.max(-half + padding, Math.min(half - padding, camera.position.z));\r\n\r\n    if (camera.userData?.lookAt instanceof THREE.Vector3) {\r\n      camera.userData.lookAt.x = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.x));\r\n      camera.userData.lookAt.z = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.z));\r\n    }\r\n  }\r\n\r\n  updateGroundBasis(camera) {\r\n    this.right.set(1,0,0).applyQuaternion(camera.quaternion);\r\n    this.fwd.set(0,0,-1).applyQuaternion(camera.quaternion);\r\n    this.right.y = 0; this.fwd.y = 0;\r\n    if (this.right.lengthSq() > 0) this.right.normalize();\r\n    if (this.fwd.lengthSq() > 0) this.fwd.normalize();\r\n  }\r\n\r\n  lookAt(worldX, worldZ){\r\n    const pitch = 35.264 * Math.PI / 180;\r\n    const yaw = 135 * Math.PI / 180;\r\n    const distance = 10240;\r\n\r\n    const cdx = Math.sin(yaw) * Math.cos(pitch);\r\n    const cdz = Math.cos(yaw) * Math.cos(pitch);\r\n\r\n    const cameraPosition = {\r\n        x: worldX - cdx * distance,\r\n        y: distance,\r\n        z: worldZ - cdz * distance\r\n    };\r\n\r\n    const lookAt = { x: worldX, y: 0, z: worldZ };\r\n\r\n    this.game.camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);\r\n    this.game.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);\r\n  }\r\n\r\n\r\n  moveCamera() {\r\n    const cam = this.game.camera;\r\n    if (!cam) return;\r\n\r\n    const dt = this.game.state.deltaTime || 1/60;\r\n\r\n    const w = window.innerWidth  || document.documentElement.clientWidth;\r\n    const h = window.innerHeight || document.documentElement.clientHeight;\r\n\r\n    // Compute directions from current mouse position (supports off-screen values too)\r\n    let dirX = 0;\r\n    let dirZ = 0;\r\n\r\n    if (this.inside) {\r\n      if (this.mouseX <= 0)           dirX = -1;\r\n      else if (this.mouseX >= w - 1)  dirX =  1;\r\n\r\n      // Z reversed: top edge -> +1 (forward), bottom -> -1 (backward)\r\n      if (this.mouseY <= this.vertical_threshold)           dirZ =  1;\r\n      else if (this.mouseY >= h - this.vertical_threshold)  dirZ = -1;\r\n\r\n      // Clear holds while inside; well recompute every frame\r\n      this.holdDirX = 0;\r\n      this.holdDirZ = 0;\r\n    } else {\r\n      // Outside windowkeep moving in the last known edge direction\r\n      dirX = this.holdDirX;\r\n      dirZ = this.holdDirZ;\r\n    }\r\n\r\n    if (dirX === 0 && dirZ === 0) return;\r\n\r\n    this.updateGroundBasis(cam);\r\n\r\n    this.delta.set(0,0,0)\r\n      .addScaledVector(this.right, dirX * this.SPEED * dt)\r\n      .addScaledVector(this.fwd,   dirZ * this.SPEED * dt);\r\n\r\n    cam.position.add(this.delta);\r\n\r\n    if (cam.userData?.lookAt instanceof THREE.Vector3) {\r\n      cam.userData.lookAt.add(this.delta);\r\n      cam.lookAt(cam.userData.lookAt);\r\n    }\r\n\r\n    this.clampCamera(cam, 0);\r\n  }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CameraControlSystem.js",
        "fileName": "CameraControlSystem"
      },
      "DamageSystem": {
        "script": "class DamageSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.damageSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        // Element types\r\n        this.ELEMENT_TYPES = {\r\n            PHYSICAL: 'physical',\r\n            FIRE: 'fire',\r\n            COLD: 'cold',\r\n            LIGHTNING: 'lightning',\r\n            POISON: 'poison',\r\n            DIVINE: 'divine'\r\n        };\r\n\r\n        // Poison DoT configuration\r\n        this.POISON_CONFIG = {\r\n            DEFAULT_DURATION: 5.0,  // seconds\r\n            DEFAULT_TICKS: 5,       // number of damage instances\r\n            STACK_LIMIT: 50,         // maximum poison stacks\r\n            STACK_REFRESH: true     // new poison refreshes duration\r\n        };\r\n\r\n        // Status effect tracking\r\n        this.activeStatusEffects = new Map(); // entityId -> { poison: [...], other effects }\r\n        \r\n        // Damage event queue for delayed damage (melee attacks, etc.)\r\n        this.pendingDamageEvents = new Map();\r\n        \r\n        // Configuration\r\n        this.RESISTANCE_CAP = 0.9; // Maximum resistance (90%)\r\n        this.MIN_DAMAGE = 1; // Minimum damage that can be dealt\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('applyDamage', this.applyDamage.bind(this));\r\n        this.game.gameManager.register('applySplashDamage', this.applySplashDamage.bind(this));\r\n        this.game.gameManager.register('getDamageElementTypes', () => this.ELEMENT_TYPES);\r\n        this.game.gameManager.register('scheduleDamage', this.scheduleDamage.bind(this));\r\n        this.game.gameManager.register('curePoison', this.curePoison.bind(this));\r\n        this.game.gameManager.register('getPoisonStacks', this.getPoisonStacks.bind(this));\r\n        this.game.gameManager.register('clearAllDamageEffects', this.clearAllDamageEffects.bind(this));\r\n        this.game.gameManager.register('clearAllStatusEffects', this.clearAllStatusEffects.bind(this));\r\n        this.game.gameManager.register('getAttackerModifiers', this.getAttackerModifiers.bind(this));\r\n    }\r\n\r\n    // =============================================\r\n    // CORE DAMAGE APPLICATION METHODS\r\n    // =============================================\r\n\r\n    /**\r\n     * Main damage application method - handles all damage types and resistances\r\n     * @param {number} sourceId - Entity dealing damage\r\n     * @param {number} targetId - Entity receiving damage  \r\n     * @param {number} baseDamage - Base damage amount\r\n     * @param {string} element - Damage element type\r\n     * @param {Object} options - Additional options (splash, crit, etc.)\r\n     */\r\n    applyDamage(sourceId, targetId, baseDamage, element = this.ELEMENT_TYPES.PHYSICAL, options = {}) {\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);\r\n        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n\r\n        if (!targetHealth || (targetDeathState && targetDeathState.isDying)) {\r\n            return { damage: 0, prevented: true, reason: 'target_invalid' };\r\n        }\r\n        \r\n        const defenderMods = this.getDefenderModifiers(targetId);\r\n        // Get target's defenses\r\n        const defenses = this.getEntityDefenses(targetId, defenderMods);\r\n        const attackerMods = this.getAttackerModifiers(sourceId);\r\n        let buffedDamage = baseDamage * attackerMods.damageMultiplier;\r\n\r\n        \r\n\r\n        if (options.isCritical) {\r\n            buffedDamage *= options.criticalMultiplier || 2.0;\r\n        }\r\n        // Handle poison as special case (DoT)\r\n        if (element === this.ELEMENT_TYPES.POISON) {\r\n            return this.applyPoisonDoT(sourceId, targetId, buffedDamage, options);\r\n        }\r\n        // Calculate final damage after resistances/armor\r\n        const damageResult = this.calculateFinalDamage(sourceId, targetId, buffedDamage, element, defenses, defenderMods, options);\r\n\r\n        // Apply immediate damage\r\n        targetHealth.current -= damageResult.finalDamage;\r\n\r\n        // Visual feedback\r\n        this.applyVisualFeedback(targetId, damageResult, element);\r\n\r\n        // Check for death\r\n        if (targetHealth.current <= 0) {\r\n            this.handleEntityDeath(targetId);\r\n        }\r\n\r\n        this.game.gameManager.call('setRetaliatoryTarget', targetId, sourceId);\r\n        \r\n        this.game.gameManager.call('showDamageNumber', targetPos.x, targetPos.y + targetUnitType.height, targetPos.z, damageResult.finalDamage, element);\r\n        \r\n        return {\r\n            damage: damageResult.finalDamage,\r\n            originalDamage: baseDamage,\r\n            buffedDamage: buffedDamage,\r\n            mitigated: damageResult.mitigated,\r\n            element: element,\r\n            fatal: targetHealth.current <= 0\r\n        };\r\n    }\r\n    getAttackerModifiers(attackerId) {\r\n        const buff = this.game.getComponent(attackerId, this.componentTypes.BUFF);\r\n        if (!buff || !buff.isActive) return { \r\n            damageMultiplier: 1.0,\r\n            attackSpeedMultiplier: 1.0 \r\n        };\r\n        \r\n        const currentTime = this.game.state.now || 0;\r\n        if (buff.endTime && currentTime > buff.endTime) return { \r\n            damageMultiplier: 1.0,\r\n            attackSpeedMultiplier: 1.0 \r\n        };\r\n        \r\n        return {\r\n            damageMultiplier: buff.modifiers?.damageMultiplier || 1.0,\r\n            attackSpeedMultiplier: buff.modifiers?.attackSpeedMultiplier || 1.0\r\n        };\r\n    }\r\n    getDefenderModifiers(defenderId) {\r\n        const buff = this.game.getComponent(defenderId, this.componentTypes.BUFF);\r\n        if (!buff || !buff.isActive) return { \r\n            armorMultiplier: 1.0, \r\n            damageTakenMultiplier: 1.0, \r\n            damageReduction: 0 \r\n        };\r\n        \r\n        const currentTime = this.game.state.now || 0;\r\n        if (buff.endTime && currentTime > buff.endTime) return { \r\n            armorMultiplier: 1.0, \r\n            damageTakenMultiplier: 1.0, \r\n            damageReduction: 0 \r\n        };\r\n        \r\n        return {\r\n            armorMultiplier: buff.modifiers?.armorMultiplier || buff.armorMultiplier || 1.0,\r\n            damageTakenMultiplier: buff.modifiers?.damageTakenMultiplier || buff.damageTakenMultiplier || 1.0,\r\n            damageReduction: buff.modifiers?.damageReduction || buff.damageReduction || 0,\r\n            additionalLightningResistance: buff.modifiers?.additionalLightningResistance || buff.additionalLightningResistance || 0,\r\n            additionalFireResistance: buff.modifiers?.additionalFireResistance || buff.additionalFireResistance || 0,\r\n            additionalColdResistance: buff.modifiers?.additionalColdResistance || buff.additionalColdResistance || 0,\r\n            additionalElementalResistance: buff.modifiers?.additionalElementalResistance || buff.additionalElementalResistance || 0\r\n        };\r\n    }\r\n    /**\r\n     * Apply splash/area damage around a point\r\n     * @param {number} sourceId - Source of the damage\r\n     * @param {Object} centerPos - Center position {x, y, z}\r\n     * @param {number} baseDamage - Base damage amount\r\n     * @param {string} element - Damage element\r\n     * @param {number} radius - Splash radius\r\n     * @param {Object} options - Additional options\r\n     */\r\n    applySplashDamage(sourceId, centerPos, baseDamage, element, radius, options = {}) {\r\n        const results = [];\r\n        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);\r\n        \r\n        if (!sourceTeam) return results;\r\n\r\n        // Find all entities within splash radius\r\n        const allEntities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION, \r\n            this.componentTypes.HEALTH,\r\n            this.componentTypes.TEAM\r\n        );\r\n        allEntities.forEach(entityId => {\r\n            if (entityId === sourceId && !options.allowSelfDamage) return; // Don't damage source by default\r\n            \r\n            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            \r\n            if (!entityPos || !entityTeam) return;\r\n            if (entityTeam.team === sourceTeam.team && !options.allowFriendlyFire) return;\r\n\r\n            // Calculate 3D distance from explosion center\r\n            const distance = this.calculateDistance3D(centerPos, entityPos);\r\n            \r\n            if (distance <= radius) {\r\n                // Calculate damage based on distance (closer = more damage)\r\n                const damageMultiplier = Math.max(0.2, 1 - (distance / radius));\r\n                const adjustedDamage = Math.floor(baseDamage * damageMultiplier);\r\n           \r\n                // Apply damage (experience will be awarded inside applyDamage)\r\n                const result = this.applyDamage(sourceId, entityId, adjustedDamage, element, {\r\n                    ...options,\r\n                    isSplash: true,\r\n                    splashDistance: distance,\r\n                    splashMultiplier: damageMultiplier\r\n                });\r\n                \r\n\r\n                if (result.damage > 0) {\r\n                    results.push({\r\n                        entityId,\r\n                        ...result,\r\n                        distance\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        return results;\r\n    }\r\n\r\n    // =============================================\r\n    // DAMAGE CALCULATION METHODS\r\n    // =============================================\r\n\r\n    /**\r\n     * Calculate final damage after all resistances and modifiers\r\n     */\r\n    calculateFinalDamage(sourceId, targetId, baseDamage, element, defenses, defenderMods, options = {}) {\r\n        let finalDamage = baseDamage;\r\n        let mitigated = 0;\r\n\r\n        // Apply element-specific damage reduction\r\n        switch (element) {\r\n            case this.ELEMENT_TYPES.PHYSICAL:\r\n                const armor = defenses.armor || 0;\r\n                mitigated = Math.min(armor, finalDamage - this.MIN_DAMAGE);\r\n                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - armor);\r\n                break;\r\n\r\n            case this.ELEMENT_TYPES.FIRE:\r\n                const fireResist = this.capResistance(defenses.fireResistance || 0);\r\n                mitigated = Math.floor(finalDamage * fireResist);\r\n                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - fireResist)));\r\n                break;\r\n\r\n            case this.ELEMENT_TYPES.COLD:\r\n                const coldResist = this.capResistance(defenses.coldResistance || 0);\r\n                mitigated = Math.floor(finalDamage * coldResist);\r\n                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - coldResist)));\r\n                break;\r\n\r\n            case this.ELEMENT_TYPES.LIGHTNING:\r\n                const lightningResist = this.capResistance(defenses.lightningResistance || 0);\r\n                mitigated = Math.floor(finalDamage * lightningResist);\r\n                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - lightningResist)));\r\n                break;\r\n\r\n            case this.ELEMENT_TYPES.DIVINE:\r\n                // Divine damage cannot be reduced\r\n                mitigated = 0;\r\n                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage));\r\n                break;\r\n\r\n            default:\r\n                console.warn(`Unknown damage element: ${element}, treating as physical`);\r\n                const defaultArmor = defenses.armor || 0;\r\n                mitigated = Math.min(defaultArmor, finalDamage - this.MIN_DAMAGE);\r\n                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - defaultArmor);\r\n                break;\r\n        }\r\n        // Apply damage taken multiplier (from marks, etc.)\r\n        finalDamage *= defenderMods.damageTakenMultiplier;\r\n        \r\n        // Apply flat damage reduction (from intimidation, shield wall, etc.)\r\n        if (defenderMods.damageReduction > 0) {\r\n            const reductionAmount = Math.floor(finalDamage * defenderMods.damageReduction);\r\n            finalDamage -= reductionAmount;\r\n            mitigated += reductionAmount;\r\n        }\r\n        return {\r\n            finalDamage,\r\n            mitigated,\r\n            originalDamage: baseDamage\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get entity's defensive stats from all sources\r\n     */\r\n    getEntityDefenses(entityId, defenderMods) {\r\n        const defenses = {\r\n            armor: 0,\r\n            fireResistance: 0,\r\n            coldResistance: 0,\r\n            lightningResistance: 0\r\n        };\r\n\r\n        // Get base defenses from combat component\r\n        const combatComponent = this.game.getComponent(entityId, this.componentTypes.COMBAT);\r\n        if (combatComponent) {\r\n            defenses.armor = combatComponent.armor || 0;\r\n            defenses.fireResistance = combatComponent.fireResistance || 0;\r\n            defenses.coldResistance = combatComponent.coldResistance || 0;\r\n            defenses.lightningResistance = combatComponent.lightningResistance || 0;\r\n        }\r\n\r\n        // Add temporary resistance bonuses from status effects\r\n        defenses.armor *= defenderMods.armorMultiplier; // Apply armor multiplier from buffs\r\n        defenses.fireResistance = defenses.fireResistance + defenderMods.additionalFireResistance + defenderMods.additionalElementalResistance;\r\n        defenses.coldResistance = defenses.coldResistance + defenderMods.additionalColdResistance + defenderMods.additionalElementalResistance;\r\n        defenses.lightningResistance = defenses.lightningResistance + defenderMods.additionalLightningResistance + defenderMods.additionalElementalResistance;\r\n\r\n        return defenses;\r\n    }\r\n\r\n    // =============================================\r\n    // POISON SYSTEM METHODS\r\n    // =============================================\r\n\r\n    /**\r\n     * Apply poison damage over time - poison cannot be resisted, only cured\r\n     */\r\n    applyPoisonDoT(sourceId, targetId, totalDamage, options = {}) {\r\n        const duration = options.duration || this.POISON_CONFIG.DEFAULT_DURATION;\r\n        const ticks = options.ticks || this.POISON_CONFIG.DEFAULT_TICKS;\r\n        \r\n        // Poison cannot be resisted - it always applies at full strength\r\n        const perTickDamage = Math.max(1, Math.ceil(totalDamage / ticks));\r\n\r\n        // Initialize status effects for target if needed\r\n        if (!this.activeStatusEffects.has(targetId)) {\r\n            this.activeStatusEffects.set(targetId, { poison: [] });\r\n        }\r\n\r\n        const statusEffects = this.activeStatusEffects.get(targetId);\r\n        \r\n        // Check current poison stacks\r\n        if (statusEffects.poison.length >= this.POISON_CONFIG.STACK_LIMIT) {\r\n            if (this.POISON_CONFIG.STACK_REFRESH) {\r\n                // Remove oldest poison stack and add new one\r\n                statusEffects.poison.shift();\r\n            } else {\r\n                // Cannot add more poison\r\n                return { damage: 0, prevented: true, reason: 'stack_limit' };\r\n            }\r\n        }\r\n        const poisonEffect = {\r\n            sourceId,\r\n            remainingTicks: ticks,\r\n            damagePerTick: perTickDamage,\r\n            tickInterval: duration / ticks,\r\n            nextTickTime: this.game.state.now + (duration / ticks),\r\n            startTime: this.game.state.now,\r\n            totalDamage: perTickDamage * ticks\r\n        };\r\n\r\n        statusEffects.poison.push(poisonEffect);\r\n\r\n      \r\n        return {\r\n            damage: poisonEffect.totalDamage,\r\n            isPoison: true,\r\n            stacks: statusEffects.poison.length,\r\n            tickDamage: perTickDamage,\r\n            duration: duration\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Process ongoing poison damage\r\n     */\r\n    processStatusEffects() {     \r\n\r\n        \r\n        for (const [entityId, statusEffects] of this.activeStatusEffects.entries()) {\r\n            const targetHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n            const targetDeathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);\r\n            \r\n            if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {\r\n                // Entity is dead or dying, remove all status effects\r\n                this.activeStatusEffects.delete(entityId);\r\n                continue;\r\n            }\r\n            // Process poison effects\r\n            statusEffects.poison = statusEffects.poison.filter(poisonEffect => {\r\n                if (this.game.state.now >= poisonEffect.nextTickTime) {\r\n                    // Apply poison damage\r\n                    targetHealth.current -= poisonEffect.damagePerTick;\r\n                    \r\n                    // Visual feedback for poison\r\n                    this.applyVisualFeedback(entityId, { finalDamage: poisonEffect.damagePerTick }, this.ELEMENT_TYPES.POISON);\r\n\r\n                    // Check for death from poison\r\n                    if (targetHealth.current <= 0) {\r\n                        this.handleEntityDeath(entityId);\r\n                        return false; // Remove this poison effect\r\n                    }\r\n\r\n                    // Update for next tick\r\n                    poisonEffect.remainingTicks--;\r\n                    poisonEffect.nextTickTime = this.game.state.now + poisonEffect.tickInterval;\r\n\r\n                    // Keep poison if ticks remain\r\n                    return poisonEffect.remainingTicks > 0;\r\n                }\r\n                return true; // Keep poison effect\r\n            });\r\n\r\n            // Remove entity from status effects if no effects remain\r\n            if (statusEffects.poison.length === 0) {\r\n                this.activeStatusEffects.delete(entityId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cure poison effects\r\n     */\r\n    curePoison(targetId, stacksToRemove = null) {\r\n        const statusEffects = this.activeStatusEffects.get(targetId);\r\n        if (!statusEffects || statusEffects.poison.length === 0) return false;\r\n\r\n        const removeCount = stacksToRemove || statusEffects.poison.length;\r\n        const removedStacks = statusEffects.poison.splice(0, removeCount);\r\n\r\n        if (statusEffects.poison.length === 0) {\r\n            this.activeStatusEffects.delete(targetId);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // =============================================\r\n    // DELAYED DAMAGE SYSTEM\r\n    // =============================================\r\n\r\n    /**\r\n     * Schedule damage to be applied later (for melee attacks, timed effects, etc.)\r\n     */\r\n    scheduleDamage(sourceId, targetId, damage, element, delay, options = {}) {\r\n        const triggerTime = this.game.state.now + delay;\r\n        const eventId = `${sourceId}_${targetId}_${this.game.state.now}_${Math.random()}`;\r\n        \r\n        this.pendingDamageEvents.set(eventId, {\r\n            sourceId,\r\n            targetId,\r\n            damage,\r\n            element: element || this.ELEMENT_TYPES.PHYSICAL,\r\n            triggerTime,\r\n            options,\r\n            eventId\r\n        });\r\n        \r\n        return eventId;\r\n    }\r\n\r\n    /**\r\n     * Process pending damage events\r\n     */\r\n    processPendingDamage() {        \r\n\r\n        const eventsToRemove = [];\r\n        \r\n        for (const [eventId, event] of this.pendingDamageEvents.entries()) {\r\n\r\n            if (this.game.state.now >= event.triggerTime) {\r\n                // Check if target is still valid\r\n                const targetHealth = this.game.getComponent(event.targetId, this.componentTypes.HEALTH);\r\n                const targetDeathState = this.game.getComponent(event.targetId, this.componentTypes.DEATH_STATE);\r\n                \r\n                if (targetHealth && targetHealth.current > 0 && (!targetDeathState || !targetDeathState.isDying)) {\r\n                    // Apply the delayed damage\r\n                     this.applyDamage(event.sourceId, event.targetId, event.damage, event.element, {\r\n                        ...event.options,\r\n                        isDelayed: true\r\n                    });\r\n                }\r\n                \r\n                eventsToRemove.push(eventId);\r\n            }\r\n        }\r\n        \r\n        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));\r\n    }\r\n\r\n\r\n    calculateDistance3D(pos1, pos2) {\r\n        const dx = pos2.x - pos1.x;\r\n        const dy = pos2.y - pos1.y;\r\n        const dz = pos2.z - pos1.z;\r\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n    }\r\n\r\n    capResistance(resistance) {\r\n        return Math.min(this.RESISTANCE_CAP, Math.max(-1.0, resistance));\r\n    }\r\n\r\n    getPoisonStacks(entityId) {\r\n        const statusEffects = this.activeStatusEffects.get(entityId);\r\n        return statusEffects ? statusEffects.poison.length : 0;\r\n    }\r\n\r\n\r\n    applyVisualFeedback(targetId, damageResult, element) {\r\n        const targetAnimation = this.game.getComponent(targetId, this.componentTypes.ANIMATION);\r\n        if (targetAnimation) {\r\n            // Different flash intensities based on element\r\n            switch (element) {\r\n                case this.ELEMENT_TYPES.FIRE:\r\n                    targetAnimation.flash = 0.6;\r\n                    break;\r\n                case this.ELEMENT_TYPES.COLD:\r\n                    targetAnimation.flash = 0.5;\r\n                    break;\r\n                case this.ELEMENT_TYPES.LIGHTNING:\r\n                    targetAnimation.flash = 0.8;\r\n                    break;\r\n                case this.ELEMENT_TYPES.POISON:\r\n                    targetAnimation.flash = 0.3; // Subtle for DoT\r\n                    break;\r\n                case this.ELEMENT_TYPES.DIVINE:\r\n                    targetAnimation.flash = 0.7;\r\n                    break;\r\n                default:\r\n                    targetAnimation.flash = 0.5;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    handleEntityDeath(entityId) {\r\n        // Notify other systems about death\r\n        this.game.gameManager.call('startDeathProcess', entityId);\r\n    }\r\n\r\n    entityDestroyed(entityId) {\r\n        // Clear pending damage events for this entity\r\n        const eventsToRemove = [];\r\n        for (const [eventId, event] of this.pendingDamageEvents.entries()) {\r\n            if (event.sourceId === entityId || event.targetId === entityId) {\r\n                eventsToRemove.push(eventId);\r\n            }\r\n        }\r\n        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));\r\n        \r\n        // Clear status effects\r\n        this.activeStatusEffects.delete(entityId);\r\n    }\r\n\r\n    update() {\r\n        this.processStatusEffects();\r\n        this.processPendingDamage();\r\n    }\r\n\r\n    clearAllStatusEffects(entityId) {\r\n        this.activeStatusEffects.delete(entityId);\r\n    }\r\n\r\n    clearAllDamageEffects() {        \r\n        this.activeStatusEffects.clear();  \r\n        this.pendingDamageEvents.clear();\r\n    }\r\n\r\n    getStatusEffects(entityId) {\r\n        return this.activeStatusEffects.get(entityId) || { poison: [] };\r\n    }\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageSystem.js",
        "fileName": "DamageSystem"
      },
      "CombatAISystem": {
        "script": "class CombatAISystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.combatAISystems = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        this.DEFAULT_UNIT_RADIUS = 25;\r\n        this.ATTACK_RANGE_BUFFER = 10;\r\n        this.ALLY_SPACING_DISTANCE = 10;\r\n        this.ENEMY_SPACING_DISTANCE = 5;\r\n        this.AVOIDANCE_RADIUS_MULTIPLIER = 1;\r\n        this.STRONG_AVOIDANCE_FORCE = 50;\r\n        this.GENTLE_AVOIDANCE_FORCE = 10;\r\n\r\n        this.TARGET_SWITCH_COOLDOWN = 0.3;\r\n        this.MOVEMENT_DECISION_INTERVAL = 0.05;\r\n\r\n        this.MIN_ATTACK_ANIMATION_TIME = 0.4;\r\n        this.STATE_CHANGE_COOLDOWN = 0.1;\r\n\r\n        this.DAMAGE_TIMING_RATIO = 0.5;\r\n\r\n        // Use placement grid size (half of terrain grid) for position threshold\r\n        this.TARGET_POSITION_THRESHOLD = this.game.getCollections().configs.game.gridSize / 2 * 0.5;\r\n        // Debug logging\r\n        this.DEBUG_ENEMY_DETECTION = true; // Set to false to disable debug\r\n\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('setRetaliatoryTarget', this.setRetaliatoryTarget.bind(this));\r\n        this.game.gameManager.register('startDeathProcess', this.startDeathProcess.bind(this));\r\n        this.game.gameManager.register('calculateAnimationSpeed', this.calculateAnimationSpeed.bind(this));\r\n    }\r\n\r\n    update() {\r\n        const CT = this.componentTypes;\r\n        if (this.game.state.phase !== 'battle'){\r\n            const combatUnits = this.game.getEntitiesWith(\r\n               CT.AI_STATE\r\n            );\r\n            for (let i = 0; i < combatUnits.length; i++) {\r\n                const entityId = combatUnits[i];\r\n                const aiState = this.game.getComponent(entityId, CT.AI_STATE);\r\n                if (aiState.state !== 'idle') {\r\n                    this.changeAIState(aiState, 'idle');\r\n                }\r\n                aiState.target = null;\r\n            }\r\n            return;\r\n        }\r\n\r\n        const combatUnits = this.game.getEntitiesWith(\r\n            CT.POSITION, CT.COMBAT, CT.TEAM, CT.AI_STATE\r\n        );\r\n        for (let i = 0; i < combatUnits.length; i++) {\r\n            const entityId = combatUnits[i];\r\n            const pos = this.game.getComponent(entityId, CT.POSITION);\r\n            const combat = this.game.getComponent(entityId, CT.COMBAT);\r\n            const team = this.game.getComponent(entityId, CT.TEAM);\r\n            const aiState = this.game.getComponent(entityId, CT.AI_STATE);\r\n            const vel = this.game.getComponent(entityId, CT.VELOCITY);\r\n            const collision = this.game.getComponent(entityId, CT.COLLISION);\r\n            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);\r\n\r\n            if (!pos || !vel || !combat || !team || !aiState){\r\n                 continue;\r\n            }\r\n            \r\n            // DEBUG: Log combat range and position\r\n            const preventEnemiesInRangeCheck = aiState.meta ? aiState.meta.preventEnemiesInRangeCheck : false; \r\n            if (!aiState.aiBehavior.initialized) {\r\n                aiState.aiBehavior = {\r\n                    lastDecisionTime: 0,\r\n                    targetLockTime: 0,\r\n                    lastStateChange: 0,\r\n                    lastAttackStart: 0,\r\n                    initialized: true\r\n                };\r\n            }\r\n            const aiBehavior = aiState.aiBehavior;\r\n\r\n            const enemiesInVisionRange = preventEnemiesInRangeCheck ? [] : (this.getAllEnemiesInVision(entityId, pos, unitType, team, combat) || []);\r\n            \r\n            // DEBUG: Log enemies found\r\n            if (aiState.target) {\r\n                const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);\r\n                const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);\r\n                if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {\r\n                    aiState.target = null;                                    \r\n                    this.onLostTarget(entityId);  \r\n                }\r\n            }\r\n            if(aiState.targetPosition){\r\n                const distance = Math.sqrt(\r\n                    Math.pow( aiState.targetPosition.x - pos.x, 2) + \r\n                    Math.pow( aiState.targetPosition.z - pos.z, 2)\r\n                );\r\n                aiState.targetDistance = distance;\r\n            } else {\r\n                aiState.targetDistance = 0;\r\n            }\r\n            if (enemiesInVisionRange.length === 0) {\r\n                if(aiState.targetPosition){\r\n                    if(aiState.targetDistance > this.TARGET_POSITION_THRESHOLD && !vel.anchored){\r\n                        if(aiState.state !== 'chasing'){\r\n                            this.changeAIState(aiState, 'chasing');\r\n                        }\r\n                    } else {\r\n                        if (aiState.state !== 'idle') {\r\n                            \r\n                            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);\r\n                            if(currentAI == \"CombatAISystem\"){\r\n                                this.onLostTarget(entityId);\r\n                            }\r\n                            this.changeAIState(aiState, 'idle');\r\n                        }\r\n                    }\r\n                }   \r\n            }\r\n\r\n            if (aiBehavior.nextMoveTime == null) aiBehavior.nextMoveTime = 0;\r\n    \r\n            if (aiState.state !== 'waiting') {\r\n                aiBehavior.nextMoveTime = this.game.state.now + this.MOVEMENT_DECISION_INTERVAL;\r\n                this.makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision);\r\n                aiBehavior.lastDecisionTime = this.game.state.now;\r\n            }\r\n\r\n            this.handleCombat(entityId, pos, combat, aiState, collision);\r\n        }\r\n    }\r\n\r\n    getAllEnemiesInVision(entityId, pos, unitType, team, combat) {\r\n        const allUnits = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.TEAM,\r\n            this.componentTypes.HEALTH\r\n        );\r\n        \r\n        const visionRange = combat.visionRange;\r\n        \r\n        return allUnits.filter(otherId => {\r\n            if (otherId === entityId) return false;\r\n            \r\n            const otherTeam = this.game.getComponent(otherId, this.componentTypes.TEAM);\r\n            const otherHealth = this.game.getComponent(otherId, this.componentTypes.HEALTH);\r\n            const otherDeathState = this.game.getComponent(otherId, this.componentTypes.DEATH_STATE);\r\n            const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);\r\n            \r\n            if (!otherTeam || otherTeam.team === team.team) return false;\r\n            if (!otherHealth || otherHealth.current <= 0) return false;\r\n            if (otherDeathState && otherDeathState.isDying) return false;\r\n            if (!otherPos) return false;\r\n            \r\n            return this.isInVisionRange(entityId, otherId, visionRange) && this.game.gameManager.call('hasLineOfSight', pos, otherPos, unitType, entityId);                   \r\n        });\r\n    }\r\n\r\n\r\n    changeAIState(aiState, newState) {\r\n\r\n        const aiBehavior = aiState.aiBehavior;\r\n        if (this.game.state.now - aiBehavior.lastStateChange < this.STATE_CHANGE_COOLDOWN) return false;\r\n        if (aiState.state === 'attacking') {\r\n            const attackDuration = this.game.state.now - aiBehavior.lastAttackStart;\r\n            if (attackDuration < this.MIN_ATTACK_ANIMATION_TIME) return false;\r\n        }\r\n        if (aiState.state !== newState) {\r\n            aiState.state = newState;\r\n            aiBehavior.lastStateChange = this.game.state.now;\r\n            if (newState === 'attacking') aiBehavior.lastAttackStart = this.game.state.now;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision) {\r\n        // CHANGED: Always try to find the best target from ALL enemies\r\n        let targetEnemy = this.findBestTarget(entityId, pos, combat.range, enemiesInVisionRange, aiState);\r\n        \r\n        if (!targetEnemy) {\r\n            aiState.target = null;\r\n            this.onLostTarget(entityId);\r\n            return;\r\n        }\r\n        \r\n        const targetHealth = this.game.getComponent(targetEnemy, this.componentTypes.HEALTH);\r\n        const targetDeathState = this.game.getComponent(targetEnemy, this.componentTypes.DEATH_STATE);\r\n        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {\r\n            aiState.target = null;\r\n            return;\r\n        }\r\n        \r\n        const enemyPos = this.game.getComponent(targetEnemy, this.componentTypes.POSITION);\r\n        if (!enemyPos) return;\r\n\r\n        let currentCombatAi = this.game.gameManager.call('getAIControllerData', entityId, \"CombatAISystem\");\r\n        let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);\r\n\r\n        // Set the target\r\n        currentCombatAi.target = targetEnemy;\r\n        aiState.target = targetEnemy;\r\n\r\n        // Check if we have direct line of sight to the target\r\n        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n        const hasLOS = this.game.gameManager.call('hasLineOfSight', pos, enemyPos, unitType, entityId);\r\n        const hasDirectPath = this.game.gameManager.call('hasDirectWalkablePath', pos, enemyPos, entityId);\r\n\r\n        if (hasLOS && hasDirectPath) {\r\n            // Can see AND walk directly - use steering only\r\n            aiState.path = null;\r\n            aiState.useDirectMovement = true;\r\n        } \r\n\r\n        if(currentAI != \"CombatAISystem\"){\r\n            this.game.gameManager.call('setCurrentAIController', entityId, \"CombatAISystem\", currentCombatAi);\r\n        }\r\n        if (this.isInAttackRange(entityId, targetEnemy, combat)) {\r\n            // Check if this is a spell caster and if abilities are available\r\n   \r\n            this.changeAIState(aiState, 'attacking');\r\n        } else {\r\n            if(aiState.state !== 'chasing'){\r\n                this.changeAIState(aiState, 'chasing');\r\n            }\r\n        }\r\n    }\r\n\r\n    findBestTarget(entityId, pos, range, enemiesInVisionRange, aiState) {\r\n        const aiBehavior = aiState.aiBehavior;\r\n        let bestTarget = null;\r\n        let bestScore = -Infinity;\r\n        \r\n        // If unit is currently attacking, stick with current target unless switching would be much better\r\n        if (aiState.target && enemiesInVisionRange.includes(aiState.target)) {\r\n            const currentTargetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);\r\n            const currentTargetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);\r\n            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);\r\n\r\n            const isCurrentTargetValid = currentTargetHealth && \r\n                                       currentTargetHealth.current > 0 && \r\n                                       (!currentTargetDeathState || !currentTargetDeathState.isDying) &&\r\n                                       currentTargetPos;\r\n            \r\n            if (isCurrentTargetValid) {\r\n                // Calculate current target score\r\n                const currentDistance = Math.sqrt(\r\n                    Math.pow(currentTargetPos.x - pos.x, 2) + \r\n                    Math.pow(currentTargetPos.z - pos.z, 2)\r\n                );\r\n                const currentHealthRatio = currentTargetHealth.current / (currentTargetHealth.max || currentTargetHealth.current);\r\n                const currentScore = this.calculateTargetScore(currentDistance, currentHealthRatio, true);\r\n                \r\n                // Only switch if we find a significantly better target\r\n                bestScore = currentScore * 1.2; // 20% bonus for current target (sticky targeting)\r\n                bestTarget = aiState.target;\r\n            }\r\n        }\r\n        \r\n        // Evaluate all enemies to find the best target\r\n        enemiesInVisionRange.forEach(enemyId => {\r\n            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);\r\n            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);\r\n            const enemyDeathState = this.game.getComponent(enemyId, this.componentTypes.DEATH_STATE);\r\n            \r\n            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;\r\n            if (enemyDeathState && enemyDeathState.isDying) return;\r\n            \r\n            const distance = Math.sqrt(\r\n                Math.pow(enemyPos.x - pos.x, 2) + \r\n                Math.pow(enemyPos.z - pos.z, 2)\r\n            );\r\n\r\n            const healthRatio = enemyHealth.current / (enemyHealth.max || enemyHealth.current);\r\n            const isCurrentTarget = (enemyId === aiState.target);\r\n            \r\n            const score = this.calculateTargetScore(distance, healthRatio, isCurrentTarget);\r\n            \r\n            if (score > bestScore) {\r\n                bestScore = score;\r\n                bestTarget = enemyId;\r\n            }\r\n            \r\n        });\r\n        \r\n        if (bestTarget !== aiState.target) {\r\n            aiBehavior.targetLockTime = this.game.state.now;\r\n        }\r\n        \r\n        return bestTarget;\r\n    }\r\n\r\n    calculateTargetScore(distance, healthRatio, isCurrentTarget) {\r\n        let score = 0;\r\n        \r\n        // Distance factor - closer is better, but not overwhelmingly so\r\n        // Use logarithmic scaling so very far enemies are still viable\r\n        const maxDistance = 20000; // Assume max battlefield size\r\n        const distanceFactor = Math.max(0, (maxDistance - distance) / maxDistance);\r\n        score += distanceFactor * 100;    \r\n\r\n        \r\n        // Current target bonus for stability\r\n        if (isCurrentTarget) {\r\n            score += 50000;\r\n        }\r\n        \r\n        \r\n        return score;\r\n    }\r\n\r\n    onLostTarget(entityId) {\r\n        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);\r\n        aiState.useDirectMovement = false;\r\n        let currentCombatAI = this.game.gameManager.call('getAIControllerData', entityId, \"CombatAISystem\");\r\n        currentCombatAI.target = null;\r\n        if(this.game.gameManager.call('hasAIControllerData', entityId, \"UnitOrderSystem\")){\r\n            let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, \"UnitOrderSystem\");\r\n            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);\r\n            if(currentAI == \"CombatAISystem\"){\r\n                this.game.gameManager.call('setCurrentAIController', entityId, \"UnitOrderSystem\", currentOrderAI);\r\n            }\r\n        }\r\n    }\r\n\r\n    handleCombat(entityId, pos, combat, aiState, collision) {\r\n        const aiBehavior = aiState.aiBehavior;\r\n        if (!aiState.target || aiState.state !== 'attacking'){\r\n           // console.log('no target or not attacking', aiState); \r\n            return;\r\n        }\r\n        \r\n        const targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);\r\n        const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);\r\n        const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);\r\n        \r\n        if (!targetPos || !targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {\r\n            aiState.target = null;\r\n            this.onLostTarget(entityId);       \r\n            return;\r\n        }\r\n        \r\n        if (!this.isInAttackRange(entityId, aiState.target, combat, 5)) {\r\n            this.changeAIState(aiState, 'chasing');\r\n            console.log('not in attack range');\r\n            return;\r\n        }\r\n        \r\n        // Handle melee units with damage > 0\r\n        if (combat.damage > 0) {\r\n            const effectiveAttackSpeed = this.getEffectiveAttackSpeed(entityId, combat.attackSpeed);\r\n            if ((this.game.state.now - combat.lastAttack) >= 1 / effectiveAttackSpeed) {\r\n                this.initiateAttack(entityId, aiState.target, combat);\r\n                combat.lastAttack = this.game.state.now;\r\n                aiBehavior.lastAttackStart = this.game.state.now;\r\n            }\r\n        }           \r\n    }\r\n\r\n    log(){\r\n        if(arguments[0].indexOf(\"barbarian\") >= 0){\r\n            console.log(...arguments)\r\n        }\r\n    }\r\n    \r\n    initiateAttack(attackerId, targetId, combat) {\r\n        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);\r\n        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);\r\n        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) return;\r\n        \r\n        if(this.game.gameManager.has('triggerSinglePlayAnimation')){\r\n            const animationSpeed = this.calculateAnimationSpeed(attackerId, combat.attackSpeed);\r\n            const minAnimationTime = 1 / combat.attackSpeed * 0.8; // 80% of attack interval\r\n            this.game.gameManager.call('triggerSinglePlayAnimation', attackerId, 'attack', animationSpeed, minAnimationTime);\r\n        }\r\n        \r\n        if (combat.projectile) {\r\n            this.scheduleProjectileLaunch(attackerId, targetId, combat);\r\n        } else {\r\n            this.scheduleMeleeDamage(attackerId, targetId, combat);\r\n        }\r\n    }\r\n\r\n    calculateAnimationSpeed(attackerId, animationSpeed) {\r\n        const attackInterval = 1 / animationSpeed;\r\n        \r\n        // Default fallback duration\r\n        let baseAnimationDuration = 0.8;\r\n        \r\n        if (this.game.gameManager.has('getEntityAnimations')) {\r\n            // NEW: Get duration from VAT bundle instead of mixer actions\r\n            const CT = this.componentTypes;\r\n            const renderable = this.game.getComponent(attackerId, CT.RENDERABLE);\r\n            \r\n            if (renderable) {\r\n                const batchInfo = this.game.renderSystem?.getBatchInfo(\r\n                    renderable.objectType, \r\n                    renderable.spawnType\r\n                );\r\n                \r\n                if (batchInfo) {\r\n                    const bundle = this.game.modelManager?.getVATBundle(\r\n                        renderable.objectType, \r\n                        renderable.spawnType\r\n                    );\r\n                    \r\n                    if (bundle?.meta?.clips) {\r\n                        // Find attack clip duration\r\n                        const attackClip = bundle.meta.clips.find(clip => \r\n                            clip.name === 'attack' || clip.name === 'combat' || clip.name === 'fight'\r\n                        );\r\n                        if (attackClip) {\r\n                            baseAnimationDuration = attackClip.duration;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // OLD SYSTEM COMPATIBILITY (remove this once VAT is working):\r\n            // Keep this as fallback in case you need it temporarily\r\n            const entityAnimations = this.game.gameManager.call('getEntityAnimations');\r\n            if (entityAnimations) {\r\n                const animationActions = entityAnimations.get(attackerId);\r\n                if (animationActions && animationActions.attack) {\r\n                    const attackAction = animationActions.attack;\r\n                    if (attackAction.getClip) {\r\n                        baseAnimationDuration = attackAction.getClip().duration;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Calculate speed to fit animation into attack interval\r\n        const targetAnimationDuration = Math.max(attackInterval * 0.9, 0.2);\r\n        let resultSpeed = baseAnimationDuration / targetAnimationDuration;\r\n        \r\n        return resultSpeed;\r\n    }\r\n\r\n    scheduleMeleeDamage(attackerId, targetId, combat) {\r\n        if (!this.game.damageSystem) {\r\n            console.warn('DamageSystem not found, cannot schedule melee damage');\r\n            return;\r\n        }\r\n\r\n        const attackInterval = 1 / combat.attackSpeed;\r\n        const damageDelay = attackInterval * this.DAMAGE_TIMING_RATIO;\r\n    \r\n        const element = this.getDamageElement(attackerId, combat);\r\n        \r\n        this.game.gameManager.call('scheduleDamage',\r\n            attackerId,\r\n            targetId,\r\n            combat.damage,\r\n            element,\r\n            damageDelay,\r\n            {\r\n                isMelee: true,\r\n                weaponRange: combat.range + this.ATTACK_RANGE_BUFFER + 1\r\n            }\r\n        );\r\n    }\r\n\r\n    scheduleProjectileLaunch(attackerId, targetId, combat) {\r\n        const attackInterval = 1 / combat.attackSpeed;\r\n        const launchDelay = attackInterval * this.DAMAGE_TIMING_RATIO;\r\n        \r\n        // Clean generic scheduling\r\n        this.game.gameManager.call('scheduleAction', () => {\r\n            this.fireProjectileAttack(attackerId, targetId, combat.projectile);\r\n        }, launchDelay, attackerId);\r\n    }\r\n\r\n    fireProjectileAttack(attackerId, targetId, projectileTypeId) {\r\n        if (!this.game.projectileSystem) return;\r\n        const projectileData = this.game.getCollections().projectiles[projectileTypeId];\r\n        if (!projectileData) return;\r\n        this.game.gameManager.call('fireProjectile', attackerId, targetId, {\r\n            id: projectileTypeId,\r\n            ...projectileData\r\n        });\r\n    }\r\n\r\n    getDamageElement(entityId, combat) {\r\n        if (combat.element) {\r\n            return combat.element;\r\n        }\r\n        \r\n        const weaponElement = this.getWeaponElement(entityId);\r\n        if (weaponElement) {\r\n            return weaponElement;\r\n        }\r\n        \r\n        return this.game.damageSystem?.ELEMENT_TYPES?.PHYSICAL || 'physical';\r\n    }\r\n\r\n    getWeaponElement(entityId) {\r\n        if (!this.game.equipmentSystem) return null;\r\n        \r\n        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);\r\n        if (!equipment) return null;\r\n        \r\n        const mainHandItem = equipment.slots.mainHand;\r\n        if (mainHandItem) {\r\n            const itemData = this.game.gameManager.call('getItemData', mainHandItem);\r\n            if (itemData && itemData.stats && itemData.stats.element) {\r\n                return itemData.stats.element;\r\n            }\r\n        }\r\n\r\n        const offHandItem = equipment.slots.offHand;\r\n        if (offHandItem) {\r\n            const itemData = this.game.gameManager.call('getItemData', offHandItem);\r\n            if (itemData && itemData.stats && itemData.stats.element) {\r\n                return itemData.stats.element;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    calculateDistances(pos1, pos2, collision1, collision2) {\r\n        const dx = pos2.x - pos1.x;\r\n        const dz = pos2.z - pos1.z;\r\n        const centerToCenterDistance = Math.sqrt(dx * dx + dz * dz);\r\n        const radius1 = this.getUnitRadius(collision1);\r\n        const radius2 = this.getUnitRadius(collision2);\r\n        const edgeToEdgeDistance = Math.max(0, centerToCenterDistance - radius1 - radius2);\r\n        const distanceToTargetEdge = Math.max(0, centerToCenterDistance - radius2);\r\n        return {\r\n            centerToCenter: centerToCenterDistance,\r\n            edgeToEdge: edgeToEdgeDistance,\r\n            attackerCenterToTargetEdge: distanceToTargetEdge,\r\n            attackerRadius: radius1,\r\n            targetRadius: radius2\r\n        };\r\n    }\r\n\r\n    isInAttackRange(attackerId, targetId, combat, extraBuffer = 0) {\r\n        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);\r\n        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);\r\n        if (!attackerPos || !targetPos) return false;\r\n\r\n        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);\r\n        const effectiveRange = combat.range + this.ATTACK_RANGE_BUFFER + extraBuffer;\r\n        return distances.attackerCenterToTargetEdge <= effectiveRange;\r\n    }\r\n\r\n    isInVisionRange(viewerId, targetId, visionRange) {\r\n        const viewerPos = this.game.getComponent(viewerId, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const viewerCollision = this.game.getComponent(viewerId, this.componentTypes.COLLISION);\r\n        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);\r\n        if (!viewerPos || !targetPos) return false;\r\n\r\n        const distances = this.calculateDistances(viewerPos, targetPos, viewerCollision, targetCollision);\r\n        return distances.attackerCenterToTargetEdge <= visionRange;\r\n    }\r\n\r\n    isWithinEdgeToEdgeRange(attackerId, targetId, maxRange) {\r\n        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);\r\n        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);\r\n        if (!attackerPos || !targetPos) return false;\r\n        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);\r\n        return distances.edgeToEdge <= maxRange;\r\n    }\r\n\r\n    getUnitRadius(collision) {\r\n        if (collision && collision.radius) {\r\n            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);\r\n        }\r\n        return this.DEFAULT_UNIT_RADIUS;\r\n    }\r\n\r\n    startDeathProcess(entityId) {\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n        const existingDeathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);\r\n        if (existingDeathState && existingDeathState.isDying) return;\r\n        \r\n        if (this.game.damageSystem) {\r\n            this.game.gameManager.call('clearAllStatusEffects', entityId);\r\n        }\r\n        \r\n        this.game.addComponent(entityId, ComponentTypes.DEATH_STATE, Components.DeathState(true, this.game.state.now, 2.0));\r\n        if (this.game.hasComponent(entityId, ComponentTypes.AI_STATE)) {\r\n            this.game.removeComponent(entityId, ComponentTypes.AI_STATE);\r\n        }\r\n        const velocity = this.game.getComponent(entityId, ComponentTypes.VELOCITY);\r\n        if (velocity) { velocity.x = 0; velocity.y = 0; velocity.z = 0; }\r\n        \r\n        if (this.game.hasComponent(entityId, ComponentTypes.COMBAT)) {\r\n            this.game.removeComponent(entityId, ComponentTypes.COMBAT);\r\n        }\r\n        \r\n        if (this.game.animationSystem) {\r\n            this.game.gameManager.call('playDeathAnimation', entityId);\r\n        }\r\n        if(this.game.abilitySystem){\r\n            this.game.gameManager.call('removeEntityAbilities', entityId);\r\n        }\r\n    }\r\n    \r\n    applyDamage(sourceId, targetId, damage, element, options = {}) {\r\n        if (!this.game.damageSystem) {\r\n            console.warn('DamageSystem not found, cannot apply damage');\r\n            return { damage: 0, prevented: true, reason: 'no_damage_system' };\r\n        }\r\n                \r\n        return this.game.gameManager.call('applyDamage', sourceId, targetId, damage, element, options);\r\n    }\r\n\r\n    applySplashDamage(sourceId, centerPos, damage, element, radius, options = {}) {\r\n        if (!this.game.damageSystem) {\r\n            console.warn('DamageSystem not found, cannot apply splash damage');\r\n            return [];\r\n        }\r\n        \r\n        return this.game.gameManager.call('applySplashDamage', sourceId, centerPos, damage, element, radius, options);\r\n    }\r\n\r\n    curePoison(targetId, stacksToRemove = null) {\r\n        if (!this.game.damageSystem) {\r\n            console.warn('DamageSystem not found, cannot cure poison');\r\n            return false;\r\n        }\r\n\r\n        return this.game.gameManager.call('curePoison', targetId, stacksToRemove);\r\n    }\r\n\r\n    getPoisonStacks(entityId) {\r\n        if (!this.game.damageSystem) {\r\n            return 0;\r\n        }\r\n\r\n        return this.game.gameManager.call('getPoisonStacks', entityId);\r\n    }\r\n\r\n    getEffectiveAttackSpeed(entityId, baseAttackSpeed) {\r\n        const attackerMods = this.game.gameManager.call('getAttackerModifiers', entityId);\r\n        return baseAttackSpeed * (attackerMods.attackSpeedMultiplier || 1.0);\r\n    }\r\n\r\n    getStatusEffects(entityId) {\r\n        if (!this.game.damageSystem) {\r\n            return { poison: [] };\r\n        }\r\n\r\n        return this.game.gameManager.call('getStatusEffects', entityId);\r\n    }\r\n\r\n    setRetaliatoryTarget(entityId, attackerId) {\r\n        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);\r\n        if (!aiState) return;\r\n        \r\n        if (aiState.target) return;\r\n        \r\n        const attackerHealth = this.game.getComponent(attackerId, this.componentTypes.HEALTH);\r\n        const attackerDeathState = this.game.getComponent(attackerId, this.componentTypes.DEATH_STATE);\r\n        if (!attackerHealth || attackerHealth.current <= 0) return;\r\n        if (attackerDeathState && attackerDeathState.isDying) return;\r\n        \r\n        const attackerTeam = this.game.getComponent(attackerId, this.componentTypes.TEAM);\r\n        const defenderTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n        if (attackerTeam && defenderTeam && attackerTeam.team === defenderTeam.team) return;\r\n        \r\n        aiState.target = attackerId;\r\n    }\r\n\r\n    debugStatusEffects() {\r\n        if (!this.game.damageSystem) {\r\n            return;\r\n        }\r\n\r\n        this.game.gameManager.call('debugStatusEffects');\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CombatAISystem.js",
        "fileName": "CombatAISystem"
      },
      "HealthBarSystem": {
        "script": "class HealthBarSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.healthBarSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        // Health bar configuration\r\n        this.HEALTH_BAR_WIDTH = 32;\r\n        this.HEALTH_BAR_HEIGHT = 4;\r\n        this.HEALTH_BAR_OFFSET_Y = 50; // Units above unit\r\n        this.BACKGROUND_DEPTH = 2; // Slight offset to prevent z-fighting\r\n        \r\n        // Track health bar meshes\r\n        this.healthBars = new Map(); // entityId -> { background, fill, group, lastHealth }\r\n        \r\n        // Initialize only after world system is ready\r\n        this.initialized = false;\r\n    }\r\n    \r\n    initialize() {\r\n        if (this.initialized || !this.game.scene) return;\r\n        \r\n        this.initialized = true;\r\n        console.log('Simple Quad HealthBarSystem initialized');\r\n    }\r\n    \r\n    update() {\r\n        // Wait for scene to be available from WorldSystem\r\n        if (!this.game.scene || !this.game.camera) {\r\n            return;\r\n        }\r\n        \r\n        // Initialize if not done yet\r\n        if (!this.initialized) {\r\n            this.initialize();\r\n        }\r\n        \r\n        // Get all entities with health and position\r\n        const healthEntities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.HEALTH,\r\n            this.componentTypes.UNIT_TYPE\r\n        );\r\n        \r\n        // Update existing health bars and create new ones\r\n        healthEntities.forEach(entityId => {\r\n            const pos    = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n            const team   = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            if (!pos || !health) return;\r\n\r\n            // === Fog-of-war visibility filter (enemies only) ===\r\n            const isEnemy = this.isEnemy(team);\r\n            const isVisible = !isEnemy || this.isVisibleAt(pos);\r\n\r\n            // If enemy not visible: hide existing bar (if any) and skip work\r\n            if (!isVisible) {\r\n                const hb = this.healthBars.get(entityId);\r\n                if (hb) hb.group.visible = false;\r\n                return;\r\n            }\r\n            // Coming back into vision: unhide if we already have one\r\n            const existing = this.healthBars.get(entityId);\r\n            if (existing) existing.group.visible = true;\r\n            // === end FOW filter ===\r\n\r\n            // Create health bar if it doesn't exist\r\n            if (!existing) {\r\n                this.createHealthBarMesh(entityId, team);\r\n            }\r\n\r\n            // Update health bar\r\n            this.updateHealthBarMesh(entityId, pos, health, team);\r\n        });\r\n        \r\n        // Clean up health bars for destroyed entities\r\n        this.cleanupRemovedHealthBars(healthEntities);\r\n    }\r\n    \r\n    createHealthBarMesh(entityId, team) {\r\n        // Create group to hold both background and fill\r\n        const group = new THREE.Group();\r\n        \r\n        // Create background quad (dark background)\r\n        const backgroundGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);\r\n        const backgroundMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x222222\r\n        });\r\n        const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);\r\n        background.position.z = -this.BACKGROUND_DEPTH; // Slightly behind\r\n        \r\n        // Create health fill quad\r\n        const fillGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);\r\n        const fillMaterial = new THREE.MeshBasicMaterial({\r\n            color: this.getHealthColor(team)\r\n        });\r\n        const fill = new THREE.Mesh(fillGeometry, fillMaterial);\r\n        \r\n        // Add both to group\r\n        group.add(background);\r\n        group.add(fill);\r\n        \r\n        // Add to scene\r\n        this.game.scene.add(group);\r\n        \r\n        // Store references\r\n        this.healthBars.set(entityId, {\r\n            background: background,\r\n            fill: fill,\r\n            group: group,\r\n            fillGeometry: fillGeometry,\r\n            fillMaterial: fillMaterial,\r\n            lastHealth: -1, // Force initial update\r\n            lastHealthPercent: -1,\r\n            lastMaxHealth: -1, // Track max health changes for notch updates\r\n            notches: [] // Array to hold notch meshes\r\n        });\r\n        \r\n        // Set high render order to ensure health bars render on top of everything\r\n        background.renderOrder = 9999;\r\n        fill.renderOrder = 10000;\r\n    }\r\n    \r\n    updateHealthBarMesh(entityId, pos, health, team) {\r\n        const healthBarData = this.healthBars.get(entityId);\r\n        if (!healthBarData) return;\r\n        \r\n        const { background, fill, group, fillGeometry, fillMaterial } = healthBarData;\r\n        \r\n\r\n        // Position group above unit\r\n        const unitType  = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n        const collections = this.game.getCollections?.();\r\n        const unitData = (unitType && collections && collections[unitType.collection])\r\n            ? collections[unitType.collection][unitType.id]\r\n            : null;\r\n\r\n        const baseY   = pos.y || 0;\r\n        const heightY = (unitData && unitData.height != null)\r\n            ? unitData.height\r\n            : this.HEALTH_BAR_OFFSET_Y;\r\n\r\n        group.position.set(pos.x, baseY + heightY, pos.z);\r\n\r\n        \r\n        // Make health bar always face camera (billboard effect)\r\n        const cameraPosition = this.game.camera.position;\r\n        group.lookAt(cameraPosition.x, cameraPosition.y, cameraPosition.z);\r\n        \r\n        // Calculate health percentage\r\n        const currentHealthPercent = Math.max(0, Math.min(100, (health.current / health.max) * 100));\r\n        \r\n        // Only update if health changed\r\n        if (healthBarData.lastHealthPercent !== currentHealthPercent) {\r\n            // Update fill width by scaling\r\n            const healthRatio = currentHealthPercent / 100;\r\n            fill.scale.x = healthRatio;\r\n            \r\n            // Adjust position to keep fill left-aligned\r\n            fill.position.x = -(this.HEALTH_BAR_WIDTH * (1 - healthRatio)) / 2;\r\n            \r\n            // Update color based on health percentage\r\n            fillMaterial.color.setHex(this.getHealthColorByPercent(currentHealthPercent, team));\r\n            \r\n            healthBarData.lastHealthPercent = currentHealthPercent;\r\n        }\r\n        \r\n        // Hide health bar if unit is at full health (optional)\r\n        if (this.shouldHideFullHealthBars() && health.current >= health.max) {\r\n            group.visible = false;\r\n        } else {\r\n            group.visible = true;\r\n        }\r\n        \r\n        // Update notches based on max health\r\n        this.updateHealthBarNotches(entityId, health.max);\r\n    }\r\n    \r\n    getHealthColor(team) {\r\n        const teamColors = {\r\n            'player': 0x00ff00,  // Green for player\r\n            'enemy': 0x00ff00,   // Green for enemy (all start green)\r\n            'neutral': 0x00ff00  // Green for neutral\r\n        };\r\n        return teamColors[team?.team] || teamColors.neutral;\r\n    }\r\n    \r\n    getHealthColorByPercent(percent, team) {\r\n        // All units start with green, then transition based on health\r\n        if (percent > 75) {\r\n            return 0x00ff00; // Green\r\n        } else if (percent > 50) {\r\n            return 0x88ff00; // Yellow-green\r\n        } else if (percent > 25) {\r\n            return 0xffff00; // Yellow\r\n        } else if (percent > 10) {\r\n            return 0xff8800; // Orange\r\n        } else {\r\n            return 0xff0000; // Red for critical health\r\n        }\r\n    }\r\n    \r\n    updateHealthBarNotches(entityId, maxHealth) {\r\n        const healthBarData = this.healthBars.get(entityId);\r\n        if (!healthBarData) return;\r\n        \r\n        // Only update notches if max health changed\r\n        if (healthBarData.lastMaxHealth === maxHealth) return;\r\n        \r\n        // Remove existing notches\r\n        healthBarData.notches.forEach(notch => {\r\n            healthBarData.group.remove(notch);\r\n            notch.geometry.dispose();\r\n            notch.material.dispose();\r\n        });\r\n        healthBarData.notches = [];\r\n        \r\n        // Calculate how many 100 HP marks we need\r\n        const numNotches = Math.floor(maxHealth / 100);\r\n\r\n        if (numNotches >= 1) { // Create notches for any unit with 100+ HP\r\n            const notchWidth = 1; // Make notches wider so they're more visible\r\n            const notchHeight = this.HEALTH_BAR_HEIGHT; // Make them shorter\r\n            \r\n            for (let i = 1; i <= numNotches; i++) { // i represents the HP value (100, 200, 300, etc.)\r\n                const hpValue = i * 100; // 100, 200, 300, etc.\r\n                \r\n                // Calculate position as percentage of max health\r\n                const positionPercent = hpValue / maxHealth; // 100/140 = 0.714 for your archer\r\n                \r\n                // Convert to X offset (-50% to +50% of bar width)\r\n                const xOffset = (positionPercent - 0.5) * this.HEALTH_BAR_WIDTH;\r\n                \r\n                \r\n                // Create notch geometry\r\n                const notchGeometry = new THREE.PlaneGeometry(notchWidth, notchHeight);\r\n                const notchMaterial = new THREE.MeshBasicMaterial({\r\n                    color: 0x000000, // White notch lines for better visibility\r\n                    transparent: false\r\n                });\r\n                \r\n                const notch = new THREE.Mesh(notchGeometry, notchMaterial);\r\n                notch.position.set(xOffset, -this.HEALTH_BAR_HEIGHT * 0.5 + notchHeight * 0.5, 0.2); // Further in front\r\n                notch.renderOrder = 10001; // Above fill\r\n                \r\n                healthBarData.group.add(notch);\r\n                healthBarData.notches.push(notch);\r\n                \r\n            }\r\n        }\r\n        \r\n        healthBarData.lastMaxHealth = maxHealth;\r\n    }\r\n    \r\n    shouldHideFullHealthBars() {\r\n        // You can make this configurable\r\n        return false; // Set to true to hide health bars when units are at full health\r\n    }\r\n    \r\n    cleanupRemovedHealthBars(currentEntities) {\r\n        const currentEntitySet = new Set(currentEntities);\r\n        \r\n        for (const [entityId] of this.healthBars.entries()) {\r\n            if (!currentEntitySet.has(entityId)) {\r\n                this.removeHealthBarMesh(entityId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    removeHealthBarMesh(entityId) {\r\n        const healthBarData = this.healthBars.get(entityId);\r\n        if (healthBarData) {\r\n            // Remove group from scene\r\n            if (this.game.scene) {\r\n                this.game.scene.remove(healthBarData.group);\r\n            }\r\n            \r\n            // Dispose of main geometries and materials\r\n            healthBarData.background.geometry.dispose();\r\n            healthBarData.background.material.dispose();\r\n            healthBarData.fill.geometry.dispose();\r\n            healthBarData.fill.material.dispose();\r\n            \r\n            // Dispose of notches\r\n            healthBarData.notches.forEach(notch => {\r\n                notch.geometry.dispose();\r\n                notch.material.dispose();\r\n            });\r\n            \r\n            // Remove from map\r\n            this.healthBars.delete(entityId);\r\n        }\r\n    }\r\n    \r\n    // Utility methods for configuration\r\n    setHealthBarScale(scale = 1.0) {\r\n        this.healthBars.forEach(healthBarData => {\r\n            const newWidth = this.HEALTH_BAR_WIDTH * scale;\r\n            const newHeight = this.HEALTH_BAR_HEIGHT * scale;\r\n            \r\n            // Update background geometry\r\n            healthBarData.background.geometry.dispose();\r\n            healthBarData.background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);\r\n            \r\n            // Update fill geometry \r\n            healthBarData.fillGeometry.dispose();\r\n            healthBarData.fillGeometry = new THREE.PlaneGeometry(newWidth, newHeight);\r\n            healthBarData.fill.geometry = healthBarData.fillGeometry;\r\n            \r\n            // Force position update\r\n            healthBarData.lastHealthPercent = -1;\r\n        });\r\n    }\r\n    isEnemy(teamComp) {\r\n        const myTeam = this.game?.state?.mySide;\r\n        if (myTeam == null || !teamComp) return false;\r\n        return teamComp.team !== myTeam;\r\n    }\r\n\r\n    isVisibleAt(pos) {\r\n        const fow = this.game?.fogOfWarSystem;\r\n        if (!fow || !pos) return true; // if no FOW, default to visible\r\n        return fow.isVisibleAt(pos.x, pos.z);\r\n    }\r\n\r\n    toggleHealthBars(visible = true) {\r\n        this.healthBars.forEach(healthBarData => {\r\n            healthBarData.group.visible = visible;\r\n        });\r\n    }\r\n    \r\n    setHealthBarOffset(offsetY) {\r\n        this.HEALTH_BAR_OFFSET_Y = offsetY;\r\n        // Positions will be updated on next frame\r\n    }\r\n    \r\n    // Update all health bar colors (useful for team color changes)\r\n    updateAllHealthBarColors() {\r\n        this.healthBars.forEach((healthBarData, entityId) => {\r\n            // Force color update\r\n            healthBarData.lastHealthPercent = -1;\r\n        });\r\n    }\r\n    \r\n    // Set render order to ensure health bars appear on top\r\n    setRenderOrder(order = 1000) {\r\n        this.healthBars.forEach(healthBarData => {\r\n            healthBarData.background.renderOrder = order;\r\n            healthBarData.fill.renderOrder = order + 1;\r\n        });\r\n    }\r\n    \r\n    destroy() {\r\n        // Clean up all health bar meshes\r\n        for (const [entityId] of this.healthBars.entries()) {\r\n            this.removeHealthBarMesh(entityId);\r\n        }\r\n        \r\n        this.healthBars.clear();\r\n        this.initialized = false;\r\n        \r\n        console.log('Simple Quad HealthBarSystem destroyed');\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/HealthBarSystem.js",
        "fileName": "HealthBarSystem"
      },
      "MultiplayerPlacementSystem": {
        "script": "class MultiplayerPlacementSystem extends engine.BaseSystem {\r\n    constructor(game, sceneManager) {\r\n        super(game);\r\n        this.sceneManager = sceneManager;\r\n        this.game.placementSystem = this;\r\n        \r\n        this.raycaster = new THREE.Raycaster();\r\n        this.mouse = new THREE.Vector2();\r\n        this.canvas = this.game.canvas;\r\n        \r\n        this.playerPlacements = [];\r\n        this.opponentPlacements = [];        \r\n        this.undoStack = [];\r\n        this.maxUndoSteps = 10;\r\n        \r\n        this.game.state.targetPositions = new Map();\r\n        this.isPlayerReady = false;\r\n        this.hasSubmittedPlacements = false;\r\n        \r\n        this.lastMouseMoveTime = 0;\r\n        this.lastValidationTime = 0;\r\n        this.cachedValidation = null;\r\n        this.cachedGridPos = null;\r\n        this.groundMeshCache = null;\r\n        this.lastUpdateTime = 0;\r\n        this.config = {\r\n            maxSquadsPerRound: 2,\r\n            enablePreview: true,\r\n            enableUndo: true,\r\n            validationThrottle: .32\r\n        };\r\n        this.elements = {};\r\n        this.mouseOffset = {\r\n            x: 0,\r\n            z: 24\r\n        }\r\n    }\r\n\r\n    init(params) {\r\n        this.params = params || {};\r\n\r\n        this.game.gameManager.register('getPlacementById', this.getPlacementById.bind(this));\r\n        this.game.gameManager.register('getPlacementsForSide', this.getPlacementsForSide.bind(this));\r\n        this.game.gameManager.register('createPlacementData', this.createPlacementData.bind(this));\r\n        this.game.gameManager.register('placeSquadOnBattlefield', this.placeSquad.bind(this));\r\n        this.game.gameManager.register('getOpponentPlacements', () => this.opponentPlacements);\r\n        this.game.gameManager.register('getWorldPositionFromMouse', this.getWorldPositionFromMouse.bind(this));\r\n\r\n        this.initializeSubsystems();\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    setupEventListeners() {\r\n        this.initializeControls();\r\n        this.elements.readyButton.addEventListener('click', () => {\r\n            this.togglePlacementReady();\r\n        });\r\n        \r\n        this.elements.undoButton.addEventListener('click', () => {\r\n            this.undoLastPlacement();\r\n\r\n            this.elements.undoButton.style.transform = 'scale(0.95)';\r\n            setTimeout(() => {\r\n                this.elements.undoButton.style.transform = 'scale(1)';\r\n            }, 150);\r\n            \r\n            this.game.gameManager.call('showNotification', ' Last deployment undone', 'info', 2000);\r\n         \r\n        });\r\n        \r\n        this.elements.undoButton.addEventListener('mouseenter', () => {\r\n            if (!this.elements.undoButton.disabled) {\r\n                this.elements.undoButton.style.background = 'linear-gradient(135deg, #616161, #757575)';\r\n                this.elements.undoButton.style.transform = 'translateY(-2px)';\r\n                this.elements.undoButton.style.boxShadow = '0 4px 12px rgba(117, 117, 117, 0.3)';\r\n            }\r\n        });\r\n        \r\n        this.elements.undoButton.addEventListener('mouseleave', () => {\r\n            if (!this.elements.undoButton.disabled) {\r\n                this.elements.undoButton.style.background = 'linear-gradient(135deg, var(--stone-gray), #616161)';\r\n                this.elements.undoButton.style.transform = 'translateY(0)';\r\n                this.elements.undoButton.style.boxShadow = 'none';\r\n            }\r\n        });\r\n    }\r\n\r\n    initializeSubsystems() {\r\n       \r\n        this.squadManager = this.game.squadManager;\r\n        this.unitCreator = this.game.unitCreationManager;\r\n         \r\n        if (this.config.enablePreview) {\r\n            this.placementPreview = new GUTS.PlacementPreview(this.game);\r\n        }\r\n        \r\n        this.groundMeshCache = this.findGroundMesh();\r\n    }\r\n\r\n    onGameStarted() {\r\n        this.getStartingState();\r\n        this.onPlacementPhaseStart();\r\n    }\r\n\r\n    getStartingState() {\r\n         this.game.networkManager.getStartingState((success, response) => {\r\n            if(success){\r\n                const buildingTypes = this.game.getCollections().buildings;\r\n                const unitTypes = this.game.getCollections().buildings;\r\n                response.startingUnits.forEach((unitData) => {\r\n                    const unitId = unitData.type;\r\n                    const unitPos = unitData.position;\r\n                    const collection = this.game.getCollections()[unitData.collection];\r\n                    if(collection){\r\n                        const unitDef = collection[unitId];\r\n                        const placementData = { id: unitId, collection: unitData.collection, ...unitDef };       \r\n                        const placement = this.createPlacementData(unitPos, placementData, this.game.state.mySide);\r\n                        placement.isStartingState = true;\r\n                        this.game.networkManager.submitPlacement(placement, (success, response) => {\r\n                            if(success){\r\n                                this.placeSquad(placement);\r\n                                if(placement.unitType.collection == \"buildings\"){\r\n                                    this.game.gameManager.call('addBuilding', placement.unitType.id, placement.squadUnits[0]);\r\n                                }\r\n                            }\r\n                        });            \r\n                    }          \r\n                });\r\n                const pos = response.camera.position;\r\n                const look = response.camera.lookAt;\r\n                this.game.camera.position.set(pos.x, pos.y, pos.z);\r\n                this.game.camera.lookAt(look.x, look.y, look.z);\r\n            }\r\n        });   \r\n    }\r\n\r\n    getPlacementsForSide(side){\r\n        if(side == this.game.state.mySide){\r\n            return this.playerPlacements;\r\n        } else {\r\n            return this.opponentPlacements;\r\n        }\r\n    }\r\n\r\n    onPlacementPhaseStart() {\r\n        this.isPlayerReady = false;\r\n        this.hasSubmittedPlacements = false;\r\n\r\n        this.game.gameManager.call('resetShop');\r\n        this.game.gameManager.call('clearAllDamageEffects');\r\n        this.game.gameManager.call('clearAllEffects');\r\n\r\n        this.enablePlacementUI();\r\n        this.elements.readyButton.textContent = 'Ready for Battle';\r\n    }\r\n    \r\n    respawnEnemyUnits() {\r\n        this.respawnSquads(this.opponentPlacements, this.game.state.mySide == 'left' ? 'right' : 'left');\r\n    }\r\n          \r\n    getTotalUnitCount(placements) {\r\n        return placements.reduce((sum, placement) => {\r\n            return sum + (placement.isSquad ? placement.squadUnits.length : 1);\r\n        }, 0);\r\n    }     \r\n    \r\n    createRespawnEffect(position, team) {\r\n        const effectType = team === 'player' ? 'magic' : 'heal';\r\n        this.game.gameManager.call('createParticleEffect',\r\n            position.x,\r\n            position.y,\r\n            position.z,\r\n            effectType,\r\n            { count: 3, speedMultiplier: 0.6 }\r\n        );\r\n    }\r\n        \r\n    enablePlacementUI() {\r\n        this.elements.readyButton.disabled = false;   \r\n        this.elements.undoButton.disabled = false;      \r\n    }\r\n        \r\n    disablePlacementUI() {\r\n        this.elements.readyButton.disabled = true; \r\n        this.elements.undoButton.disabled = true;        \r\n    }\r\n\r\n    updatePlacementUI() {\r\n        if (this.elements.undoButton) {\r\n            this.elements.undoButton.disabled = this.undoStack.length === 0;\r\n            this.elements.undoButton.style.opacity = this.undoStack.length === 0 ? '0.5' : '1';\r\n        }\r\n    }\r\n\r\n    togglePlacementReady(callback) {\r\n        if (this.elements.readyButton) {\r\n            this.elements.readyButton.disabled = true;\r\n            this.elements.readyButton.textContent = 'Updating...';\r\n        }\r\n        this.game.networkManager.toggleReadyForBattle((success, response) => {\r\n            if(success){\r\n                this.hasSubmittedPlacements = true;\r\n                this.elements.readyButton.textContent = 'Waiting for Opponent...';\r\n            } else {\r\n                if (this.elements.readyButton) {\r\n                    this.elements.readyButton.disabled = false;\r\n                    this.elements.readyButton.textContent = 'Ready for Battle';\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    handleReadyForBattleUpdate(data) {\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        if (data.playerId === myPlayerId) {\r\n            this.isPlayerReady = data.ready;\r\n            this.updatePlacementUI();\r\n        } \r\n        \r\n        if (data.allReady) {\r\n            let opponentPlacements = null;\r\n            data.gameState.players.forEach((player) => {\r\n                if(player.id != myPlayerId){\r\n                    opponentPlacements = player.placements;\r\n                }\r\n            });\r\n            this.applyOpponentPlacements(opponentPlacements);\r\n            this.applyTargetPositions();\r\n            this.game.state.phase = 'battle';\r\n            this.game.triggerEvent(\"onBattleStart\");\r\n            this.game.resetCurrentTime();\r\n            this.resetAI();\r\n            this.game.desyncDebugger.enabled = true;\r\n            this.game.desyncDebugger.displaySync(true);\r\n            if (this.elements.readyButton) {\r\n                this.elements.readyButton.disabled = true;\r\n                this.elements.readyButton.textContent = 'Battling!';\r\n            }\r\n        } else {\r\n            const opponentReady = data.gameState?.players?.find(p => p.id !== myPlayerId)?.ready;\r\n            if (opponentReady) {\r\n                this.game.gameManager.call('showNotification', 'Opponent is ready for battle!', 'info');\r\n            }\r\n        }\r\n    }\r\n\r\n    resetAI() {\r\n        const componentTypes = this.game.componentManager.getComponentTypes();            \r\n        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      \r\n        AIEntities.forEach((entityId) => {\r\n            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);\r\n            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);\r\n            combat.lastAttack = 0;\r\n            aiState.aiBehavior = {};\r\n        });\r\n    }\r\n\r\n    applyTargetPositions(){\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const allPlacements = [...this.playerPlacements, ...this.opponentPlacements];\r\n        allPlacements.forEach((placement) => {\r\n            placement.squadUnits.forEach(entityId => {\r\n                const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);\r\n                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n                if (aiState && position) {\r\n                    let targetPosition = aiState.targetPosition;\r\n                    let meta = aiState.meta;\r\n                    let tempMoveOrders = this.game.gameManager.call('getTemporaryOpponentMoveOrders').get(placement.placementId);\r\n                    if(tempMoveOrders){\r\n                        targetPosition = tempMoveOrders.targetPosition;\r\n                        meta = tempMoveOrders.meta;\r\n                        this.game.gameManager.call('deleteTemporaryOpponentMoveOrder', placement.placementId);                    \r\n                    }\r\n                    if(targetPosition){\r\n                        const currentAIController = this.game.gameManager.call('getCurrentAIControllerId', entityId);\r\n\r\n                        if(!currentAIController || currentAIController == \"UnitOrderSystem\"){\r\n                            const dx = position.x - targetPosition.x;\r\n                            const dz = position.z - targetPosition.z;\r\n                            const distSq = dx * dx + dz * dz;\r\n                            const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;\r\n                            const threshold = placementGridSize * 0.5;\r\n\r\n                            if (distSq <= threshold * threshold) {\r\n                                this.game.gameManager.call('removeCurrentAIController', entityId);\r\n                                placement.targetPosition = null;\r\n                            } else {\r\n                                let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, \"UnitOrderSystem\");\r\n                                currentOrderAI.targetPosition = targetPosition;\r\n                                currentOrderAI.path = [];\r\n                                  if(entityId == \"peasant_1224_1368_right_1\"){\r\n                                    console.log(\"applyTargetPositions\");\r\n                                }\r\n                                currentOrderAI.meta = { ...meta };\r\n                                this.game.gameManager.call('setCurrentAIController', entityId, \"UnitOrderSystem\", currentOrderAI);\r\n                            }\r\n                        }\r\n                    }                    \r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    update() {\r\n        if (this.game.state.phase !== 'placement') {\r\n            this.lastRaycastTime = 0;\r\n            this.lastValidationTime = 0;\r\n            this.lastUpdateTime = 0;            \r\n            this.disablePlacementUI();\r\n            return;\r\n        }\r\n        \r\n        if (this.game.state.now - this.lastValidationTime > this.config.validationThrottle) {\r\n            this.updateCursorState();\r\n            this.updatePlacementUI();\r\n            this.lastValidationTime = this.game.state.now;\r\n        }\r\n    }\r\n\r\n    applyOpponentPlacements(opponentData) {\r\n        opponentData.forEach(placement => {\r\n            if(this.game.gameManager.call('getOpponentPlacements').find(p => p.placementId === placement.placementId)) {\r\n                return;\r\n            }\r\n            this.placeSquad(placement);         \r\n        });\r\n\r\n        if (this.game.state) {\r\n            this.game.state.enemyPlacementComplete = true;\r\n        }\r\n    }\r\n\r\n    createEnemyFromOpponentPlacement(opponentPlacement) {\r\n        this.game.gameManager.call('setSquadInfo', opponentPlacement.placementId, opponentPlacement.experience);\r\n\r\n        if (this.game.squadManager && this.game.unitCreationManager) {\r\n            const unitPositions = this.game.squadManager.calculateUnitPositions(\r\n                opponentPlacement.gridPosition,\r\n                opponentPlacement.unitType\r\n            );\r\n\r\n            let squadUnits = [];\r\n            unitPositions.forEach((pos, index) => {\r\n                const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);\r\n                const unitY = terrainHeight !== null ? terrainHeight : 0;\r\n\r\n                let entityId = this.game.unitCreationManager.create(\r\n                    pos.x,\r\n                    unitY,\r\n                    pos.z,\r\n                    opponentPlacement.targetPosition,\r\n                    opponentPlacement,\r\n                    this.game.state.mySide == 'right' ? 'left' : 'right'\r\n                );\r\n                if (opponentPlacement.unitType.id === 'goldMine') {\r\n                    // Convert footprint (terrain grid units) to placement grid cells\r\n                    const footprintWidth = opponentPlacement.unitType.footprintWidth || opponentPlacement.unitType.placementGridWidth || 2;\r\n                    const footprintHeight = opponentPlacement.unitType.footprintHeight || opponentPlacement.unitType.placementGridHeight || 2;\r\n                    const gridWidth = footprintWidth * 2;\r\n                    const gridHeight = footprintHeight * 2;\r\n\r\n                    const opponentSide = this.game.state.mySide === 'right' ? 'left' : 'right';\r\n\r\n                    this.game.gameManager.call('buildGoldMine',\r\n                        entityId,\r\n                        opponentSide,\r\n                        opponentPlacement.gridPosition,\r\n                        gridWidth,\r\n                        gridHeight\r\n                    );\r\n                }                \r\n                this.game.gameManager.call('reserveGridCells', opponentPlacement.cells, entityId);\r\n                squadUnits.push(entityId);\r\n            });\r\n            opponentPlacement.squadUnits = squadUnits;\r\n        }\r\n\r\n  \r\n\r\n        this.opponentPlacements.push(opponentPlacement);\r\n    }\r\n\r\n    handleUnitSelectionChange() {\r\n        this.cachedValidation = null;\r\n        this.cachedGridPos = null;\r\n        this.cachedWorldPos = null;\r\n        this.lastMouseX = null;\r\n        this.lastMouseY = null;\r\n        this.lastRaycastTime = null;\r\n        this.lastRaycastMouseX = null;\r\n        this.lastRaycastMouseY = null;\r\n        this.approximateWorldScale = null;\r\n        this.previousWorldPos = null;\r\n        this.previousMouseX = null;\r\n        this.previousMouseY = null;\r\n        \r\n        if (this.squadValidationCache) {\r\n            this.squadValidationCache.clear();\r\n        }\r\n        \r\n        if (this.placementPreview) {\r\n            this.placementPreview.clear();\r\n        }\r\n        \r\n        document.body.style.cursor = 'default';\r\n    }\r\n\r\n    onActivateBuildingPlacement(){\r\n        this.handleUnitSelectionChange();\r\n    }\r\n\r\n    handleCanvasClick(event) {\r\n        const state = this.game.state;\r\n        \r\n        if (this.settingTargetPosition) {\r\n            return;\r\n        }\r\n        \r\n        if (state.phase !== 'placement') {\r\n            return;\r\n        }\r\n        if(!state.selectedUnitType) {\r\n            return;\r\n        }\r\n        \r\n        if (this.isPlayerReady) {\r\n            return;\r\n        }\r\n        \r\n        if (!this.canPlayerPlaceSquad()) {\r\n            return;\r\n        }\r\n        \r\n        if (state.playerGold < state.selectedUnitType.value) {\r\n            return;\r\n        }\r\n        if (this.game.supplySystem && !this.game.supplySystem.canAffordSupply(this.game.state.mySide, state.selectedUnitType)) {\r\n            console.log('Not enough supply to place this unit');\r\n            return;\r\n        }\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        const worldPosition = this.getWorldPositionFromMouse(event, mouseX, mouseY);\r\n\r\n        // Adjust world position to account for camera angle and cell centering        \r\n        const adjustedWorldPos = {\r\n            x: worldPosition.x + this.mouseOffset.x,\r\n            z: worldPosition.z + this.mouseOffset.z\r\n        };\r\n\r\n        let gridPos = this.game.gameManager.call('convertWorldToGridPosition', adjustedWorldPos.x, adjustedWorldPos.z);\r\n\r\n        let isValidPlacement = this.isValidGridPlacement(adjustedWorldPos);\r\n       \r\n        if (!isValidPlacement) {\r\n            return;\r\n        }\r\n    \r\n        if (this.game.squadManager) {\r\n            const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);\r\n            const validation = this.game.squadManager.validateSquadConfig(squadData);\r\n        \r\n            if (!validation.valid) {\r\n                return;\r\n            }\r\n        }\r\n        \r\n        const placement = this.createPlacementData(gridPos, state.selectedUnitType, this.game.state.mySide);\r\n\r\n        this.game.networkManager.submitPlacement(placement, (success, response) => {\r\n            if(success){\r\n                this.placeSquad(placement);\r\n            }\r\n        });        \r\n    }\r\n\r\n    canPlayerPlaceSquad() {\r\n        return true;\r\n    }\r\n\r\n    placeSquad(placement) {\r\n        const unitPositions = this.game.squadManager.calculateUnitPositions(placement.gridPosition, placement.unitType);\r\n        const undoInfo = this.createUndoInfo(placement);\r\n        \r\n        const squadUnits = this.createSquadUnits(placement, unitPositions, placement.team, undoInfo);\r\n        placement.squadUnits = squadUnits;\r\n        placement.isSquad = squadUnits.length > 1;\r\n        this.updateGameStateForPlacement(placement, undoInfo);\r\n\r\n        this.game.gameManager.call('initializeSquad', placement.placementId, placement.unitType, squadUnits, placement.team);\r\n\r\n        if (squadUnits.length <= 8) {\r\n            this.createPlacementEffects(unitPositions.slice(0, 8), placement.team);\r\n        }\r\n        \r\n        this.cachedValidation = null;\r\n        this.cachedGridPos = null;\r\n        \r\n        if (this.placementPreview) {\r\n            this.placementPreview.clear();\r\n        }\r\n\r\n        this.game.state.selectedUnitType = null;\r\n        this.handleUnitSelectionChange();\r\n        \r\n        return placement;\r\n    }\r\n\r\n    createSquadUnits(placement, unitPositions, team, undoInfo) {\r\n        const createdUnits = [];\r\n        \r\n        const maxUnits = Math.min(unitPositions.length, 16);\r\n        const positions = unitPositions.slice(0, maxUnits);\r\n        \r\n        positions.forEach(pos => {\r\n            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z) || 0;\r\n            const unitY = terrainHeight !== null ? terrainHeight : 0;\r\n\r\n            const entityId = this.game.unitCreationManager.create(pos.x, unitY, pos.z, pos, placement, team);\r\n            createdUnits.push(entityId);\r\n            undoInfo.unitIds.push(entityId);\r\n\r\n            this.game.gameManager.call('reserveGridCells', placement.cells, entityId);\r\n\r\n            if(placement.unitType.id == 'goldMine'){\r\n                // Convert footprint (terrain grid units) to placement grid cells\r\n                const footprintWidth = placement.unitType.footprintWidth || placement.unitType.placementGridWidth || 2;\r\n                const footprintHeight = placement.unitType.footprintHeight || placement.unitType.placementGridHeight || 2;\r\n                const gridWidth = footprintWidth * 2;\r\n                const gridHeight = footprintHeight * 2;\r\n                this.game.gameManager.call('buildGoldMine', entityId, team, placement.gridPosition, gridWidth, gridHeight);\r\n            }\r\n            if (placement.peasantInfo && placement.collection === 'buildings') {\r\n                const peasantInfo = placement.peasantInfo;\r\n                const peasantId = peasantInfo.peasantId;\r\n                const peasantAbilities = this.game.gameManager.call('getEntityAbilities', peasantId);\r\n                if (peasantAbilities) {\r\n                    const buildAbility = peasantAbilities.find(a => a.id === 'build');\r\n                    if (buildAbility) {\r\n                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);\r\n                    }\r\n                }\r\n                \r\n                this.game.state.peasantBuildingPlacement = null;\r\n            }\r\n        });\r\n        \r\n        return createdUnits;\r\n    }\r\n\r\n    createUndoInfo(placement) {\r\n        return {\r\n            type: 'squad_placement',\r\n            placementId: placement.placementId,\r\n            collection: placement.collection,\r\n            unitType: { ...placement.unitType },\r\n            cost: placement.unitType.value || 0,\r\n            gridPosition: { ...placement.gridPosition },\r\n            cells: [...placement.cells],\r\n            unitIds: [],\r\n            team: this.game.state.mySide,\r\n            timestamp: this.game.state.now\r\n        };\r\n    }\r\n\r\n    createPlacementData(gridPos, unitType, team) {\r\n        const squadData = this.game.squadManager.getSquadData(unitType);\r\n        const cells = this.game.squadManager.getSquadCells(gridPos, squadData);\r\n        \r\n        const placementId = `squad_${team}_${gridPos.x}_${gridPos.z}_${this.game.state.round}`;\r\n        return {\r\n            placementId: placementId,\r\n            gridPosition: gridPos,\r\n            cells: cells,\r\n            collection: unitType.collection,\r\n            unitType: { ...unitType },\r\n            squadUnits: [],\r\n            team: team,\r\n            targetPosition: this.game.state.targetPositions.get(placementId),\r\n            roundPlaced: this.game.state.round,\r\n            timestamp: this.game.state.now,\r\n            peasantInfo: this.game.state.peasantBuildingPlacement\r\n        };\r\n    }\r\n\r\n    updateGameStateForPlacement(placement, undoInfo) {                \r\n        if (this.isMyTeam(placement.team)) {\r\n            this.addToUndoStack(undoInfo);\r\n            if(!placement.isStartingState){\r\n                this.game.state.playerGold -= (placement.unitType.value || 0);\r\n            }\r\n            this.playerPlacements.push(placement);\r\n        } else {\r\n            this.opponentPlacements.push(placement);\r\n        }\r\n    }\r\n\r\n    setPlacementExperience(placements) {\r\n        if (placements) {\r\n            placements.forEach(placement => {\r\n                if (placement.experience && placement.placementId) {\r\n                    const experienceData = placement.experience;\r\n                    let squadData = this.game.gameManager.call('getSquadInfo', placement.placementId);\r\n                    \r\n                    if (squadData) {\r\n                        squadData.level = experienceData.level;\r\n                        squadData.experience = experienceData.experience;\r\n                        squadData.experienceToNextLevel = experienceData.experienceToNextLevel;\r\n                        squadData.canLevelUp = experienceData.canLevelUp;                    \r\n                    }\r\n                }\r\n            });            \r\n        }\r\n    }\r\n\r\n    isMyTeam(team){\r\n        return team == this.game.state.mySide;\r\n    }\r\n\r\n    createPlacementEffects(unitPositions, team) {\r\n        const effectType = this.isMyTeam(team) ? 'magic' : 'defeat';\r\n        const maxEffects = Math.min(unitPositions.length, 6);\r\n\r\n        for (let i = 0; i < maxEffects; i++) {\r\n            const pos = unitPositions[i];\r\n            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);\r\n            const unitY = terrainHeight !== null ? terrainHeight : 0;\r\n\r\n            this.game.gameManager.call('createParticleEffect',\r\n                pos.x,\r\n                unitY,\r\n                pos.z,\r\n                effectType,\r\n                { count: 3, speedMultiplier: 0.8 }\r\n            );\r\n        }\r\n    }\r\n\r\n    undoLastPlacement() {\r\n        if (!this.config.enableUndo) return;\r\n        \r\n        const state = this.game.state;\r\n        \r\n        if (state.phase !== 'placement') {\r\n            return;\r\n        }\r\n        \r\n        if (this.isPlayerReady) {\r\n            return;\r\n        }\r\n        \r\n        if (this.undoStack.length === 0) {\r\n            return;\r\n        }\r\n        \r\n        const undoInfo = this.undoStack.pop();\r\n\r\n        try {\r\n            undoInfo.unitIds.forEach(entityId => {\r\n                if (this.game.destroyEntity) {\r\n                    this.game.destroyEntity(entityId);\r\n                }\r\n            });\r\n\r\n            state.playerGold += undoInfo.cost;\r\n\r\n            const placementIndex = this.playerPlacements.findIndex(p => p.placementId === undoInfo.placementId);\r\n            if (placementIndex !== -1) {\r\n                this.playerPlacements.splice(placementIndex, 1);\r\n            }\r\n\r\n            this.game.gameManager.call('removeSquad', undoInfo.placementId);\r\n\r\n            this.game.gameManager.call('releaseGridCells', undoInfo.placementId);\r\n            this.createUndoEffects(undoInfo);\r\n\r\n            this.cachedValidation = null;\r\n            this.cachedGridPos = null;\r\n            \r\n        } catch (error) {\r\n            console.error('Undo failed:', error);\r\n        }\r\n    }\r\n\r\n    createUndoEffects(undoInfo) {\r\n        const maxEffects = Math.min(undoInfo.cells.length, 4);\r\n\r\n        for (let i = 0; i < maxEffects; i++) {\r\n            const cell = undoInfo.cells[i];\r\n            const worldPos = this.game.gameManager.call('convertGridToWorldPosition', cell.x, cell.z);\r\n            this.game.gameManager.call('createParticleEffect',\r\n                worldPos.x,\r\n                0,\r\n                worldPos.z,\r\n                'magic',\r\n                { count: 3, speedMultiplier: 0.7 }\r\n            );\r\n        }\r\n    }\r\n\r\n    getPlacementById(placementId) {\r\n        const playerPlacement = this.playerPlacements.find(placement => placement.placementId === placementId);\r\n        if (playerPlacement) {\r\n            return playerPlacement;\r\n        }\r\n        \r\n        const opponentPlacement = this.opponentPlacements.find(placement => placement.placementId === placementId);\r\n        if (opponentPlacement) {\r\n            return opponentPlacement;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    collectPlayerPlacements() {\r\n        return this.playerPlacements;\r\n    }\r\n\r\n    initializeControls() {\r\n        this.elements.readyButton = document.getElementById('placementReadyBtn');\r\n        this.elements.undoButton = document.getElementById('undoBtn');\r\n\r\n        if (this.config.enableUndo) {\r\n            document.addEventListener('keydown', (event) => {\r\n                if ((event.ctrlKey || event.metaKey) && event.key === 'z') {\r\n                    event.preventDefault();\r\n                    this.undoLastPlacement();\r\n                }\r\n            });\r\n        }\r\n        \r\n        if (this.config.enablePreview && this.placementPreview) {\r\n            let animationFrameId = null;\r\n            let pendingMouseEvent = null;\r\n            \r\n            const throttledMouseMove = (event) => {\r\n                if (animationFrameId) {\r\n                    cancelAnimationFrame(animationFrameId);\r\n                }\r\n                pendingMouseEvent = event;\r\n                \r\n                animationFrameId = requestAnimationFrame(() => {\r\n                    if (this.game.state.now - this.lastUpdateTime < .08) {\r\n                        return;\r\n                    }\r\n                    \r\n                    this.lastUpdateTime = this.game.state.now;\r\n                    if (this.game.state.phase === 'placement' && \r\n                        this.game.state.selectedUnitType && \r\n                        !this.isPlayerReady &&\r\n                        pendingMouseEvent) {\r\n                        \r\n                        this.updatePlacementPreview(pendingMouseEvent);\r\n                    }\r\n                    \r\n                    animationFrameId = null;\r\n                    pendingMouseEvent = null;\r\n                });\r\n            };\r\n            \r\n            this.canvas.addEventListener('mousemove', throttledMouseMove);\r\n            \r\n            this.canvas.addEventListener('mouseleave', () => {\r\n                if (animationFrameId) {\r\n                    cancelAnimationFrame(animationFrameId);\r\n                    animationFrameId = null;\r\n                }\r\n                \r\n                this.placementPreview.clear();\r\n                this.cachedValidation = null;\r\n                this.cachedGridPos = null;\r\n                document.body.style.cursor = 'default';\r\n            });\r\n        }\r\n    }\r\n\r\n    updatePlacementPreview(event) {\r\n        if (!this.placementPreview) return;\r\n        \r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        \r\n        this.lastMouseX = mouseX;\r\n        this.lastMouseY = mouseY;\r\n        \r\n        const timeSinceLastRaycast = this.game.state.now - (this.lastRaycastTime || 0);\r\n        const shouldRaycast = timeSinceLastRaycast > 0.15;\r\n        \r\n        let worldPosition;\r\n        if (!shouldRaycast) {\r\n            return;\r\n        } else {\r\n            worldPosition = this.getWorldPositionFromMouse(event, mouseX, mouseY);\r\n            \r\n            if (worldPosition) {\r\n                this.cachedWorldPos = worldPosition;\r\n                this.lastRaycastTime = this.game.state.now;\r\n                this.lastRaycastMouseX = mouseX;\r\n                this.lastRaycastMouseY = mouseY;\r\n            }\r\n        }\r\n        \r\n        if (!worldPosition) {\r\n            this.placementPreview.clear();\r\n            document.body.style.cursor = 'not-allowed';\r\n            return;\r\n        }\r\n\r\n        // Adjust world position to account for camera angle and cell centering\r\n        // Add half cell size to snap to nearest cell center\r\n        const adjustedWorldPos = {\r\n            x: worldPosition.x + this.mouseOffset.x,\r\n            z: worldPosition.z + this.mouseOffset.z\r\n        };\r\n\r\n        const gridPos = this.game.gameManager.call('convertWorldToGridPosition', adjustedWorldPos.x, adjustedWorldPos.z);\r\n        const state = this.game.state;\r\n        \r\n        let isValid = this.isValidGridPlacement(adjustedWorldPos);\r\n        let unitPositions = null;\r\n        let isBuilding = state.selectedUnitType.collection === 'buildings';\r\n\r\n        const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);\r\n        const cells = this.game.squadManager.getSquadCells(gridPos, squadData);\r\n        if (this.game.squadManager.getSquadSize(squadData) > 1) {\r\n            unitPositions = this.game.squadManager.calculateUnitPositions(gridPos, state.selectedUnitType);\r\n        }\r\n        \r\n        // For buildings, show footprint-sized preview. For units, show placement grid cells.\r\n        const worldPositions = cells.map(cell =>\r\n            this.game.gameManager.call('convertGridToWorldPosition', cell.x, cell.z)\r\n        );\r\n\r\n        if (unitPositions && unitPositions.length > 0) {\r\n            this.placementPreview.showWithUnitMarkers(worldPositions, unitPositions, isValid, isBuilding);\r\n        } else {\r\n            this.placementPreview.showAtWorldPositions(worldPositions, isValid, isBuilding);\r\n        }\r\n\r\n        document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';\r\n    }\r\n\r\n    getCurrentCells(gridPos) {\r\n\r\n\r\n        // For buildings, show footprint-sized preview. For units, show placement grid cells.\r\n        return \r\n    }\r\n\r\n    getWorldPositionFromMouse(event, mouseX, mouseY) {\r\n        if (!this.game.scene || !this.game.camera) return null;\r\n\r\n        if (!this.mouse) {\r\n            this.mouse = new THREE.Vector2();\r\n        }\r\n\r\n        if (mouseX !== undefined && mouseY !== undefined) {\r\n            this.mouse.set(mouseX, mouseY);\r\n        } else {\r\n            const rect = this.canvas.getBoundingClientRect();\r\n            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        }\r\n\r\n        if (!this.raycaster) {\r\n            this.raycaster = new THREE.Raycaster();\r\n        }\r\n        this.raycaster.setFromCamera(this.mouse, this.game.camera);\r\n\r\n        // Try to raycast directly against the terrain mesh (most efficient)\r\n        if (this.groundMeshCache) {\r\n            const intersects = this.raycaster.intersectObject(this.groundMeshCache, false);\r\n            if (intersects.length > 0) {\r\n                return intersects[0].point;\r\n            }\r\n        }\r\n\r\n        // Fallback: raycast to flat plane at y=0 if ground mesh not available\r\n        const ray = this.raycaster.ray;\r\n\r\n        if (Math.abs(ray.direction.y) < 0.0001) {\r\n            return null;\r\n        }\r\n\r\n        const distance = (0 - ray.origin.y) / ray.direction.y;\r\n\r\n        if (distance < 0) {\r\n            return null;\r\n        }\r\n\r\n        const intersectionPoint = ray.origin.clone().add(\r\n            ray.direction.clone().multiplyScalar(distance)\r\n        );\r\n\r\n        return intersectionPoint;\r\n    }\r\n\r\n    findGroundMesh() {\r\n        for (let child of this.game.scene.children) {\r\n            if (child.isMesh && child.geometry?.type === 'PlaneGeometry') {\r\n                return child;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    isValidGridPlacement(worldPos, unitDef) {\r\n        const selectedUnitType = unitDef || this.game.state.selectedUnitType;\r\n\r\n        let gridPos = this.game.gameManager.call('convertWorldToGridPosition', worldPos.x, worldPos.z);\r\n        let cells = [];\r\n        let isValid = false;\r\n        let gridValid = false;\r\n\r\n        if (selectedUnitType.collection === 'buildings') {\r\n            cells = this.calculateBuildingCells(gridPos, selectedUnitType);\r\n\r\n            if (selectedUnitType.id === 'goldMine') {\r\n                // Convert footprint to placement grid cells\r\n                const footprintWidth = selectedUnitType.footprintWidth || selectedUnitType.placementGridWidth || 2;\r\n                const footprintHeight = selectedUnitType.footprintHeight || selectedUnitType.placementGridHeight || 2;\r\n                const gridWidth = footprintWidth * 2;\r\n                const gridHeight = footprintHeight * 2;\r\n                const validation = this.game.gameManager.call('isValidGoldMinePlacement', gridPos, gridWidth, gridHeight);\r\n                isValid = validation.valid;\r\n            } else {\r\n                gridValid = this.game.gameManager.call('isValidGridPlacement', cells, this.game.state.mySide);\r\n\r\n                let terrainValid = true;\r\n                cells.forEach((cell) => {\r\n                    // Convert placement grid coordinates to terrain grid coordinates\r\n                    const terrainGridX = Math.floor(cell.x / 2);\r\n                    const terrainGridZ = Math.floor(cell.z / 2);\r\n                    const terrainTypeId = this.game.gameManager.call('getTerrainTypeAtGridPosition', terrainGridX, terrainGridZ);\r\n                    if(!terrainTypeId) {\r\n                        terrainValid = false;\r\n                        return;\r\n                    }\r\n                    const terrainType = this.game.gameManager.call('getTileMapTerrainType', terrainTypeId);\r\n                    // Check walkability using placement grid cell (already in placement grid coords)\r\n                    const isPositionWalkable = this.game.gameManager.call('isGridPositionWalkable', cell);\r\n                    terrainValid = terrainValid && terrainType.buildable && isPositionWalkable;\r\n                });\r\n\r\n                isValid = gridValid && terrainValid;\r\n            }\r\n        } else {\r\n            const squadData = this.game.squadManager.getSquadData(selectedUnitType);\r\n            cells = this.game.squadManager.getSquadCells(gridPos, squadData);\r\n            gridValid = this.game.gameManager.call('isValidGridPlacement', cells, this.game.state.mySide);\r\n            isValid = gridValid;\r\n        }\r\n        return isValid;\r\n    }\r\n\r\n    addToUndoStack(undoInfo) {\r\n        if (!this.config.enableUndo) return;\r\n        \r\n        this.undoStack.push(undoInfo);\r\n        \r\n        if (this.undoStack.length > this.maxUndoSteps) {\r\n            this.undoStack.shift();\r\n        }\r\n    }\r\n\r\n    clearUndoStack() {\r\n        this.undoStack = [];\r\n    }\r\n\r\n    getUndoStatus() {\r\n        return {\r\n            canUndo: this.undoStack.length > 0 && this.config.enableUndo && !this.isPlayerReady,\r\n            undoCount: this.undoStack.length,\r\n            maxUndoSteps: this.maxUndoSteps,\r\n            lastAction: this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1] : null\r\n        };\r\n    }\r\n\r\n    setTeamSides(sides) {\r\n        this.teamSides = {\r\n            player: sides?.player || 'left',\r\n            enemy: sides?.enemy || 'right'\r\n        };\r\n    }\r\n\r\n    calculateBuildingCells(gridPos, building) {\r\n        const cells = [];\r\n        // Convert footprint (terrain grid units) to placement grid cells (multiply by 2)\r\n        const footprintWidth = building.footprintWidth || building.placementGridWidth || 1;\r\n        const footprintHeight = building.footprintHeight || building.placementGridHeight || 1;\r\n        const gridWidth = footprintWidth * 2;\r\n        const gridHeight = footprintHeight * 2;\r\n\r\n        const startX = gridPos.x - Math.floor(gridWidth / 2);\r\n        const startZ = gridPos.z - Math.floor(gridHeight / 2);\r\n\r\n        for (let z = 0; z < gridHeight; z++) {\r\n            for (let x = 0; x < gridWidth; x++) {\r\n                cells.push({\r\n                    x: startX + x,\r\n                    z: startZ + z\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n\r\n    updateCursorState(isValid) {\r\n        if (this.isPlayerReady) {\r\n            document.body.style.cursor = 'not-allowed';\r\n        } else if (this.game.state.selectedUnitType) {\r\n            document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';\r\n        } else {\r\n            document.body.style.cursor = 'default';\r\n        }\r\n    }\r\n\r\n    onBattleEnd() {        \r\n        this.removeDeadSquadsAfterRound();\r\n    }\r\n        \r\n    removeDeadSquadsAfterRound() {\r\n        if (!this.game.componentManager) return;\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        this.playerPlacements = this.filterDeadSquads(this.playerPlacements, ComponentTypes);\r\n        this.opponentPlacements = this.filterDeadSquads(this.opponentPlacements, ComponentTypes);\r\n    }\r\n\r\n    filterDeadSquads(placements, ComponentTypes) {\r\n        return placements.filter(placement => {\r\n            if (!placement.squadUnits || placement.squadUnits.length === 0) {\r\n                this.cleanupDeadSquad(placement);\r\n                return false;\r\n            }\r\n\r\n            const aliveUnits = placement.squadUnits.filter(entityId => {\r\n                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n                const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);\r\n                const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);\r\n                if(buildingState) return true;\r\n                return health && health.current > 0 && (!deathState || !deathState.isDying);\r\n            });\r\n\r\n            if (aliveUnits.length === 0) {\r\n                this.cleanupDeadSquad(placement);\r\n                return false;\r\n            }\r\n\r\n            placement.squadUnits = aliveUnits;\r\n            return true;\r\n        });\r\n    }\r\n\r\n    cleanupDeadSquad(placement) {\r\n        if (placement.placementId) {\r\n            this.game.gameManager.call('releaseGridCells', placement.placementId);\r\n            this.game.gameManager.call('removeSquad', placement.placementId);\r\n        }\r\n    }\r\n\r\n    resetAllPlacements() {\r\n        this.game.gameManager.call('resetSquadExperience');\r\n\r\n        this.playerPlacements = [];\r\n        this.opponentPlacements = [];\r\n        this.isPlayerReady = false;\r\n        this.hasSubmittedPlacements = false;\r\n        this.clearUndoStack();\r\n        \r\n        this.cachedValidation = null;\r\n        this.cachedGridPos = null;\r\n        this.groundMeshCache = null;\r\n        this.groundMeshCache = this.findGroundMesh();\r\n        \r\n        if (this.placementPreview) {\r\n            this.placementPreview.clear();\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        this.cachedValidation = null;\r\n        this.cachedGridPos = null;\r\n        this.groundMeshCache = null;\r\n        \r\n        if (this.placementPreview) {\r\n            this.placementPreview.dispose();\r\n        }\r\n                \r\n        this.resetAllPlacements();\r\n    }\r\n\r\n    getUnitAtWorldPosition(worldPos) {\r\n        const clickRadius = 30;\r\n        let closestEntityId = null;\r\n        let closestDistance = clickRadius;\r\n        \r\n        const entities = this.game.getEntitiesWith(\r\n            this.game.componentManager.getComponentTypes().POSITION,\r\n            this.game.componentManager.getComponentTypes().TEAM\r\n        );\r\n        \r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);\r\n            const team = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().TEAM);\r\n            \r\n            const dx = pos.x - worldPos.x;\r\n            const dz = pos.z - worldPos.z;\r\n            const distance = Math.sqrt(dx * dx + dz * dz);\r\n            \r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestEntityId = entityId;\r\n            }\r\n        });\r\n        \r\n        return closestEntityId;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerPlacementSystem.js",
        "fileName": "MultiplayerPlacementSystem"
      },
      "MiniMapSystem": {
        "script": "class MiniMapSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.miniMapSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        this.MINIMAP_SIZE = 200;\r\n        this.MINIMAP_PADDING = 10;\r\n        \r\n        this.container = null;\r\n        this.canvas = null;\r\n        this.ctx = null;\r\n        \r\n        this.minimapCamera = null;\r\n        this.minimapScene = null;\r\n        this.minimapRenderTarget = null;\r\n        \r\n        this.unitIconGeometry = null;\r\n        this.buildingIconGeometry = null;\r\n        this.goldVeinIconGeometry = null;\r\n        this.friendlyIconMaterial = null;\r\n        this.friendlyInstancedMesh = null;\r\n        this.enemyIconMaterial = null;\r\n        this.enemyInstancedMesh = null;\r\n        this.friendlyBuildingMaterial = null;\r\n        this.friendlyBuildingMesh = null;\r\n        this.enemyBuildingMaterial = null;\r\n        this.enemyBuildingMesh = null;\r\n        this.goldVeinMaterial = null;\r\n        this.goldVeinMesh = null;\r\n        this.tempMatrix = null;\r\n        \r\n        this.isDragging = false;\r\n        this.minimapWorldSize = 0;\r\n        this.initialized = false;\r\n        this.MINIMAP_ROTATION = -45;\r\n    }\r\n\r\n    onGameStarted() {\r\n        // Get the container and its actual width\r\n        this.container = document.getElementById('miniMapContainer');\r\n        const rect = this.container.getBoundingClientRect();\r\n       // this.MINIMAP_SIZE = rect.width; // use actual displayed size\r\n\r\n        // Use that size for both the canvas and render target\r\n        this.minimapWorldSize = this.game.gameManager.call('getWorldExtendedSize');\r\n        \r\n        this.createMinimapCamera();\r\n        this.addTerrainBackground(); \r\n        this.createIconMaterials();\r\n        this.createMinimapUI();\r\n        this.setupEventListeners();\r\n        this.initialized = true;\r\n    }\r\n\r\n\r\n    createMinimapCamera() {\r\n        const halfSize = this.minimapWorldSize / 2;\r\n        \r\n        this.minimapCamera = new THREE.OrthographicCamera(\r\n            -halfSize, halfSize,\r\n            halfSize, -halfSize,\r\n            0.1, 1000\r\n        );\r\n        this.minimapCamera.position.set(0, 500, 0);\r\n        this.minimapCamera.lookAt(0, 0, 0);\r\n        \r\n        this.minimapScene = new THREE.Scene();\r\n        \r\n        this.minimapRenderTarget = new THREE.WebGLRenderTarget(\r\n            this.MINIMAP_SIZE,\r\n            this.MINIMAP_SIZE,\r\n            {\r\n                minFilter: THREE.LinearFilter,\r\n                magFilter: THREE.LinearFilter,\r\n                format: THREE.RGBAFormat\r\n            }\r\n        );\r\n        \r\n        this.addFogBackground();\r\n    }\r\n\r\n    addFogBackground() {\r\n        const fogQuad = new THREE.Mesh(\r\n            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),\r\n            new THREE.ShaderMaterial({\r\n                uniforms: {\r\n                    explorationTexture: { value: null },\r\n                    visibilityTexture: { value: null }\r\n                },\r\n                vertexShader: `\r\n                    varying vec2 vUv;\r\n                    void main() {\r\n                        vUv = uv;\r\n                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                    }\r\n                `,\r\n                fragmentShader: `\r\n                    uniform sampler2D explorationTexture;\r\n                    uniform sampler2D visibilityTexture;\r\n                    varying vec2 vUv;\r\n                    \r\n                    void main() {\r\n                        float explored = texture2D(explorationTexture, vUv).r;\r\n                        float visible = texture2D(visibilityTexture, vUv).r;\r\n                        \r\n                        vec3 color;\r\n                        float alpha;\r\n                        if (visible > 0.0) {\r\n                            // Fully visible - make it transparent so terrain shows through\r\n                            color = vec3(0.0);\r\n                            alpha = 0.0;\r\n                        } else if (explored > 0.0) {\r\n                            // Explored but not visible - dark overlay\r\n                            color = vec3(0.0);\r\n                            alpha = 0.6;\r\n                        } else {\r\n                            // Unexplored - black\r\n                            color = vec3(0.0);\r\n                            alpha = 1.0;\r\n                        }\r\n                        \r\n                        gl_FragColor = vec4(color, alpha);\r\n                    }\r\n                `,\r\n                transparent: true,\r\n                depthWrite: false,\r\n                depthTest: false\r\n            })\r\n        );\r\n        fogQuad.rotation.x = -Math.PI / 2;\r\n        fogQuad.position.y = -1;\r\n        fogQuad.renderOrder = 100;\r\n        \r\n        this.minimapScene.add(fogQuad);\r\n        this.fogQuad = fogQuad;\r\n    }\r\n\r\n    createIconMaterials() {\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        // Unit icons - slightly bigger\r\n        this.unitIconGeometry = new THREE.CircleGeometry(gridSize, 4);\r\n        \r\n        // Building icons - much bigger\r\n        this.buildingIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);\r\n        \r\n        // Gold vein icons - medium size\r\n        this.goldVeinIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);\r\n        \r\n        const MAX_UNITS = 1000;\r\n        const MAX_BUILDINGS = 200;\r\n        \r\n        // Friendly units\r\n        this.friendlyIconMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x00ff00,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        this.friendlyInstancedMesh = new THREE.InstancedMesh(\r\n            this.unitIconGeometry,\r\n            this.friendlyIconMaterial,\r\n            MAX_UNITS\r\n        );\r\n        this.friendlyInstancedMesh.renderOrder = 100;\r\n        this.friendlyInstancedMesh.count = 0;\r\n        this.minimapScene.add(this.friendlyInstancedMesh);\r\n        \r\n        // Enemy units\r\n        this.enemyIconMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xff0000,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        this.enemyInstancedMesh = new THREE.InstancedMesh(\r\n            this.unitIconGeometry,\r\n            this.enemyIconMaterial,\r\n            MAX_UNITS\r\n        );\r\n        this.enemyInstancedMesh.renderOrder = 100;\r\n        this.enemyInstancedMesh.count = 0;\r\n        this.minimapScene.add(this.enemyInstancedMesh);\r\n        \r\n        // Friendly buildings\r\n        this.friendlyBuildingMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0x00ff00,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        this.friendlyBuildingMesh = new THREE.InstancedMesh(\r\n            this.buildingIconGeometry,\r\n            this.friendlyBuildingMaterial,\r\n            MAX_BUILDINGS\r\n        );\r\n        this.friendlyBuildingMesh.renderOrder = 100;\r\n        this.friendlyBuildingMesh.count = 0;\r\n        this.minimapScene.add(this.friendlyBuildingMesh);\r\n        \r\n        // Enemy buildings\r\n        this.enemyBuildingMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xff0000,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        this.enemyBuildingMesh = new THREE.InstancedMesh(\r\n            this.buildingIconGeometry,\r\n            this.enemyBuildingMaterial,\r\n            MAX_BUILDINGS\r\n        );\r\n        this.enemyBuildingMesh.renderOrder = 100;\r\n        this.enemyBuildingMesh.count = 0;\r\n        this.minimapScene.add(this.enemyBuildingMesh);\r\n        \r\n        // Gold veins (yellow)\r\n        this.goldVeinMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xFFD700,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false,\r\n            depthTest: false\r\n        });\r\n        \r\n        this.goldVeinMesh = new THREE.InstancedMesh(\r\n            this.goldVeinIconGeometry,\r\n            this.goldVeinMaterial,\r\n            100\r\n        );\r\n        this.goldVeinMesh.renderOrder = 50;\r\n        this.goldVeinMesh.count = 0;\r\n        this.minimapScene.add(this.goldVeinMesh);\r\n        \r\n        this.tempMatrix = new THREE.Matrix4();\r\n        this.rotationMatrix = new THREE.Matrix4();\r\n        this.rotationMatrix.makeRotationX(-Math.PI / 2);\r\n    }\r\n\r\n    createMinimapUI() {\r\n        this.canvas = document.createElement('canvas');\r\n        this.canvas.width = this.MINIMAP_SIZE;\r\n        this.canvas.height = this.MINIMAP_SIZE;\r\n        this.canvas.style.width = '100%';\r\n        this.canvas.style.height = '100%';\r\n        this.canvas.style.display = 'block';\r\n        this.ctx = this.canvas.getContext('2d');\r\n\r\n        if (this.container) {\r\n            this.container.appendChild(this.canvas);\r\n        }\r\n\r\n        // Update render target to match\r\n        if (this.minimapRenderTarget) {\r\n            this.minimapRenderTarget.setSize(this.MINIMAP_SIZE, this.MINIMAP_SIZE);\r\n        }\r\n    }\r\n\r\n\r\n    setupEventListeners() {\r\n        this.container.addEventListener('mousedown', (e) => {\r\n            this.isDragging = true;\r\n            this.handleMinimapClick(e);\r\n        });\r\n        \r\n        this.container.addEventListener('mousemove', (e) => {\r\n            if (this.isDragging) {\r\n                this.handleMinimapClick(e);\r\n            }\r\n        });\r\n        \r\n        this.container.addEventListener('mouseup', () => {\r\n            this.isDragging = false;\r\n        });\r\n        \r\n        this.container.addEventListener('mouseleave', () => {\r\n            this.isDragging = false;\r\n        });\r\n    }\r\n\r\n    handleMinimapClick(event) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n         const camera = this.game.camera;\r\n     \r\n        // Get click position relative to canvas center (in pixels)\r\n        const clickX = event.clientX - rect.left - rect.width / 2;\r\n        const clickY = event.clientY - rect.top - rect.height / 2;\r\n        \r\n        // Apply inverse rotation to compensate for CSS rotation\r\n        const angle = -this.MINIMAP_ROTATION * Math.PI / 180;\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        \r\n        const rotatedX = clickX * cos - clickY * sin;\r\n        const rotatedY = clickX * sin + clickY * cos;\r\n\r\n        // Convert back to normalized coordinates (0..1)\r\n        const nx = (rotatedX + rect.width / 2) / rect.width;\r\n        const ny = (rotatedY + rect.height / 2) / rect.height;\r\n\r\n        let worldSize = this.game.gameManager.call('getTerrainSize') * 2;\r\n        // Map to world coordinates\r\n        const half = worldSize * 0.5;\r\n        const worldX = nx * worldSize - half;\r\n        const worldZ = ny * worldSize - half;\r\n        this.game.gameManager.call('cameraLookAt', worldX, worldZ);\r\n    }\r\n\r\n    update() {\r\n        if(!this.initialized) return;\r\n        this.updateFogTextures();\r\n        this.updateUnitIcons();\r\n        this.updateGoldVeinIcons();\r\n        this.renderMinimap();\r\n    }\r\n\r\n    updateFogTextures() {\r\n        if (!this.game.fogOfWarSystem || !this.fogQuad) return;\r\n\r\n        this.fogQuad.material.uniforms.explorationTexture.value =\r\n            this.game.gameManager.call('getExplorationTexture');\r\n        this.fogQuad.material.uniforms.visibilityTexture.value =\r\n            this.game.gameManager.call('getFogTexture');\r\n\r\n        const groundTexture = this.game.gameManager.call('getGroundTexture');\r\n        if (this.terrainQuad && groundTexture) {\r\n            this.terrainQuad.material.map = groundTexture;\r\n            this.terrainQuad.material.needsUpdate = true;\r\n        }\r\n    }\r\n\r\n    updateUnitIcons() {\r\n        const myTeam = this.game.state.mySide;\r\n        if (!myTeam) return;\r\n        \r\n        const entities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.TEAM,\r\n            this.componentTypes.UNIT_TYPE\r\n        ).filter(id => {\r\n            const unitType = this.game.getComponent(id, this.componentTypes.UNIT_TYPE);\r\n            return unitType.collection == \"units\" || unitType.collection == \"buildings\"\r\n        });\r\n        \r\n        let friendlyUnitIndex = 0;\r\n        let enemyUnitIndex = 0;\r\n        let friendlyBuildingIndex = 0;\r\n        let enemyBuildingIndex = 0;\r\n        \r\n        for (const entityId of entities) {\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            \r\n            if (!pos || !team || projectile) continue;\r\n            \r\n            const isMyUnit = team.team === myTeam;\r\n            const visible = this.game.fogOfWarSystem?.isVisibleAt(pos.x, pos.z);\r\n            \r\n            if (!isMyUnit && !visible) continue;\r\n            \r\n            this.tempMatrix.makeTranslation(pos.x, 0, pos.z);\r\n            this.tempMatrix.multiply(this.rotationMatrix);\r\n            \r\n            if (unitType.collection == 'buildings') {\r\n                // It's a building\r\n                if (isMyUnit) {\r\n                    this.friendlyBuildingMesh.setMatrixAt(friendlyBuildingIndex, this.tempMatrix);\r\n                    friendlyBuildingIndex++;\r\n                } else {\r\n                    this.enemyBuildingMesh.setMatrixAt(enemyBuildingIndex, this.tempMatrix);\r\n                    enemyBuildingIndex++;\r\n                }\r\n            } else if(unitType.collection == 'units') {\r\n                // It's a unit\r\n                if (isMyUnit) {\r\n                    this.friendlyInstancedMesh.setMatrixAt(friendlyUnitIndex, this.tempMatrix);\r\n                    friendlyUnitIndex++;\r\n                } else {\r\n                    this.enemyInstancedMesh.setMatrixAt(enemyUnitIndex, this.tempMatrix);\r\n                    enemyUnitIndex++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        this.friendlyInstancedMesh.count = friendlyUnitIndex;\r\n        this.enemyInstancedMesh.count = enemyUnitIndex;\r\n        this.friendlyBuildingMesh.count = friendlyBuildingIndex;\r\n        this.enemyBuildingMesh.count = enemyBuildingIndex;\r\n        \r\n        if (friendlyUnitIndex > 0) {\r\n            this.friendlyInstancedMesh.instanceMatrix.needsUpdate = true;\r\n        }\r\n        if (enemyUnitIndex > 0) {\r\n            this.enemyInstancedMesh.instanceMatrix.needsUpdate = true;\r\n        }\r\n        if (friendlyBuildingIndex > 0) {\r\n            this.friendlyBuildingMesh.instanceMatrix.needsUpdate = true;\r\n        }\r\n        if (enemyBuildingIndex > 0) {\r\n            this.enemyBuildingMesh.instanceMatrix.needsUpdate = true;\r\n        }\r\n    }\r\n\r\n    updateGoldVeinIcons() {\r\n        const goldVeins = this.game.gameManager.call('getGoldVeinLocations');\r\n        if (!goldVeins) {\r\n            return;\r\n        }\r\n        let goldIndex = 0;\r\n        \r\n        for (const vein of goldVeins) {\r\n            // Skip if claimed (has a gold mine built on it)\r\n            if (vein.claimed) continue;\r\n            \r\n            const explored = this.game.fogOfWarSystem?.isExploredAt(vein.worldX, vein.worldZ);\r\n            if (!explored) continue;\r\n            \r\n            this.tempMatrix.makeTranslation(vein.worldX, 0, vein.worldZ);\r\n            this.tempMatrix.multiply(this.rotationMatrix);\r\n            this.goldVeinMesh.setMatrixAt(goldIndex, this.tempMatrix);\r\n            goldIndex++;\r\n        }\r\n        \r\n        this.goldVeinMesh.count = goldIndex;\r\n        \r\n        if (goldIndex > 0) {\r\n            this.goldVeinMesh.instanceMatrix.needsUpdate = true;\r\n        }\r\n    }\r\n\r\n    updateCameraView() {\r\n        if (!this.game.camera) return;\r\n        \r\n        const camera = this.game.camera;\r\n        const cameraPos = camera.position;\r\n        \r\n        if (!cameraPos || isNaN(cameraPos.x) || isNaN(cameraPos.y) || isNaN(cameraPos.z)) {\r\n            return;\r\n        }\r\n        \r\n        const fov = camera.fov * (Math.PI / 180);\r\n        const aspect = camera.aspect;\r\n        const distance = camera.position.y;\r\n        \r\n        if (isNaN(fov) || isNaN(aspect) || isNaN(distance) || distance <= 0) {\r\n            return;\r\n        }\r\n        \r\n        const viewHeight = 2 * Math.tan(fov / 2) * distance;\r\n        const viewWidth = viewHeight * aspect;\r\n        \r\n        const halfWidth = viewWidth / 2;\r\n        const halfHeight = viewHeight / 2;\r\n        \r\n        const points = [\r\n            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight),\r\n            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z - halfHeight),\r\n            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z + halfHeight),\r\n            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z + halfHeight),\r\n            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight)\r\n        ];\r\n        \r\n        if (this.cameraViewMesh) {\r\n            this.cameraViewMesh.geometry.setFromPoints(points);\r\n        } else {\r\n            const geometry = new THREE.BufferGeometry().setFromPoints(points);\r\n            const material = new THREE.LineBasicMaterial({\r\n                color: 0xffffff,\r\n                linewidth: 3,\r\n                depthWrite: false,\r\n                depthTest: false\r\n            });\r\n            this.cameraViewMesh = new THREE.Line(geometry, material);\r\n            this.cameraViewMesh.renderOrder = 1000;\r\n            this.minimapScene.add(this.cameraViewMesh);\r\n        }\r\n    }\r\n\r\n    addTerrainBackground() {\r\n        // Get the ground texture from the world system\r\n        const groundTexture = this.game.gameManager.call('getGroundTexture');\r\n        if (!groundTexture) {\r\n            console.warn('MiniMapSystem: Ground texture not available');\r\n            return;\r\n        }\r\n\r\n        const terrainQuad = new THREE.Mesh(\r\n            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),\r\n            new THREE.MeshBasicMaterial({\r\n                map: groundTexture,\r\n                depthWrite: false,\r\n                depthTest: false\r\n            })\r\n        );\r\n        terrainQuad.rotation.x = -Math.PI / 2;\r\n        terrainQuad.position.y = -2; // Below fog\r\n        terrainQuad.renderOrder = -2000;\r\n        \r\n        this.minimapScene.add(terrainQuad);\r\n        this.terrainQuad = terrainQuad;\r\n    }\r\n\r\n    renderMinimap() {\r\n        this.game.renderer.setRenderTarget(this.minimapRenderTarget);\r\n        this.game.renderer.render(this.minimapScene, this.minimapCamera);\r\n        \r\n        const pixels = new Uint8Array(this.MINIMAP_SIZE * this.MINIMAP_SIZE * 4);\r\n        this.game.renderer.readRenderTargetPixels(\r\n            this.minimapRenderTarget,\r\n            0, 0,\r\n            this.MINIMAP_SIZE, this.MINIMAP_SIZE,\r\n            pixels\r\n        );\r\n        \r\n        this.game.renderer.setRenderTarget(null);\r\n        \r\n        const imageData = this.ctx.createImageData(this.MINIMAP_SIZE, this.MINIMAP_SIZE);\r\n        \r\n        for (let y = 0; y < this.MINIMAP_SIZE; y++) {\r\n            for (let x = 0; x < this.MINIMAP_SIZE; x++) {\r\n                const srcIdx = (y * this.MINIMAP_SIZE + x) * 4;\r\n                const dstIdx = ((this.MINIMAP_SIZE - 1 - y) * this.MINIMAP_SIZE + x) * 4;\r\n                \r\n                imageData.data[dstIdx + 0] = pixels[srcIdx + 0];\r\n                imageData.data[dstIdx + 1] = pixels[srcIdx + 1];\r\n                imageData.data[dstIdx + 2] = pixels[srcIdx + 2];\r\n                imageData.data[dstIdx + 3] = pixels[srcIdx + 3];\r\n            }\r\n        }\r\n        \r\n        this.ctx.putImageData(imageData, 0, 0);\r\n        \r\n        this.drawCameraOutline();\r\n    }\r\n        \r\n    drawCameraOutline() {\r\n        const camera = this.game.camera;\r\n        if (!camera || !camera.isOrthographicCamera) return;\r\n\r\n        // Frustum corners in NDC (CCW)\r\n        const corners = [\r\n            { x: -1, y: -1 }, // left-bottom\r\n            { x:  1, y: -1 }, // right-bottom\r\n            { x:  1, y:  1 }, // right-top\r\n            { x: -1, y:  1 }, // left-top\r\n        ];\r\n\r\n        // Intersect each corner \"ray\" with the ground plane (y=0)\r\n        const hits = [];\r\n        for (const c of corners) {\r\n            const hit = this.orthoCornerToGround(camera, c.x, c.y);\r\n            if (!hit) return; // early out if any corner can't hit the ground\r\n            hits.push(hit);\r\n        }\r\n\r\n        // Convert to canvas space\r\n        const pts = hits.map(h => this.worldToCanvas(h.x, h.z));\r\n\r\n        // Draw polygon overlay\r\n        this.ctx.save();\r\n        this.ctx.strokeStyle = '#ffffff';\r\n        this.ctx.lineWidth = 1;\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(pts[0].x, pts[0].y);\r\n        for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);\r\n        this.ctx.closePath();\r\n        this.ctx.stroke();\r\n        this.ctx.restore();\r\n    }\r\n\r\n    orthoCornerToGround(camera, ndcX, ndcY) {\r\n        // Point on near plane in world space\r\n        const p = new THREE.Vector3(ndcX, ndcY, -1).unproject(camera);\r\n\r\n        // Camera forward (world)\r\n        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);\r\n\r\n        const EPS = 1e-6;\r\n        if (Math.abs(forward.y) < EPS) return null; // looking exactly parallel to ground\r\n\r\n        // Move along forward so y -> 0\r\n        const t = -p.y / forward.y;\r\n        if (t <= 0) return null;                    // corner ray goes upward/behind\r\n        return p.addScaledVector(forward, t);       // world-space hit (x, 0, z)\r\n    }\r\n    \r\n    worldToCanvas(x, z) {\r\n        const half = this.minimapWorldSize / 2;\r\n        const nx = (x + half) / this.minimapWorldSize;\r\n        const nz = (z + half) / this.minimapWorldSize;\r\n        const cx = nx * this.MINIMAP_SIZE;\r\n        const cy = nz * this.MINIMAP_SIZE;\r\n        return { x: cx, y: cy };\r\n    }\r\n    \r\n    dispose() {\r\n        if (this.container && this.container.parentNode) {\r\n            this.container.parentNode.removeChild(this.container);\r\n        }\r\n        \r\n        if (this.minimapRenderTarget) {\r\n            this.minimapRenderTarget.dispose();\r\n        }\r\n        \r\n        if (this.unitIconGeometry) {\r\n            this.unitIconGeometry.dispose();\r\n        }\r\n        \r\n        if (this.buildingIconGeometry) {\r\n            this.buildingIconGeometry.dispose();\r\n        }\r\n        \r\n        if (this.goldVeinIconGeometry) {\r\n            this.goldVeinIconGeometry.dispose();\r\n        }\r\n        \r\n        if (this.friendlyIconMaterial) {\r\n            this.friendlyIconMaterial.dispose();\r\n        }\r\n        \r\n        if (this.friendlyInstancedMesh) {\r\n            this.minimapScene.remove(this.friendlyInstancedMesh);\r\n            this.friendlyInstancedMesh.dispose();\r\n        }\r\n        \r\n        if (this.enemyIconMaterial) {\r\n            this.enemyIconMaterial.dispose();\r\n        }\r\n        \r\n        if (this.enemyInstancedMesh) {\r\n            this.minimapScene.remove(this.enemyInstancedMesh);\r\n            this.enemyInstancedMesh.dispose();\r\n        }\r\n        \r\n        if (this.friendlyBuildingMaterial) {\r\n            this.friendlyBuildingMaterial.dispose();\r\n        }\r\n        \r\n        if (this.friendlyBuildingMesh) {\r\n            this.minimapScene.remove(this.friendlyBuildingMesh);\r\n            this.friendlyBuildingMesh.dispose();\r\n        }\r\n        \r\n        if (this.enemyBuildingMaterial) {\r\n            this.enemyBuildingMaterial.dispose();\r\n        }\r\n        \r\n        if (this.enemyBuildingMesh) {\r\n            this.minimapScene.remove(this.enemyBuildingMesh);\r\n            this.enemyBuildingMesh.dispose();\r\n        }\r\n        \r\n        if (this.goldVeinMaterial) {\r\n            this.goldVeinMaterial.dispose();\r\n        }\r\n        \r\n        if (this.goldVeinMesh) {\r\n            this.minimapScene.remove(this.goldVeinMesh);\r\n            this.goldVeinMesh.dispose();\r\n        }\r\n        \r\n        if (this.terrainQuad) {\r\n            this.minimapScene.remove(this.terrainQuad);\r\n            this.terrainQuad.geometry.dispose();\r\n            this.terrainQuad.material.dispose();\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MiniMapSystem.js",
        "fileName": "MiniMapSystem"
      },
      "ProjectileSystem": {
        "script": "class ProjectileSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.projectileSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n\r\n        // Configuration\r\n        this.HIT_DETECTION_RADIUS = 24;\r\n        this.TRAIL_UPDATE_INTERVAL = 0.05;\r\n        \r\n        // Ballistic configuration\r\n        this.DEFAULT_LAUNCH_ANGLE = Math.PI / 4; // 45 degrees\r\n        this.MIN_LAUNCH_ANGLE = Math.PI / 6; // 30 degrees\r\n        this.MAX_LAUNCH_ANGLE = Math.PI / 3; // 60 degrees\r\n        this.BALLISTIC_HEIGHT_MULTIPLIER = 0.3; // How high the arc goes relative to distance\r\n        this.PROJECTILE_LIFETIME = 200;\r\n        \r\n        // Ground impact detection\r\n        this.GROUND_IMPACT_THRESHOLD = 0; // Distance from ground to trigger impact\r\n        \r\n        // Trail tracking for visual effects\r\n        this.projectileTrails = new Map();\r\n        \r\n        // Get gravity from movement system\r\n        this.GRAVITY = this.game.movementSystem?.GRAVITY;\r\n    }\r\n    \r\n    // Deterministic rounding helper\r\n    roundForDeterminism(value, precision = 6) {\r\n        return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('deleteProjectileTrail', this.deleteProjectileTrail.bind(this));\r\n        this.game.gameManager.register('fireProjectile', this.fireProjectile.bind(this));\r\n    }\r\n\r\n    deleteProjectileTrail(entityId) {\r\n        if (this.projectileTrails) {\r\n            this.projectileTrails.delete(entityId);\r\n        }\r\n    }\r\n\r\n    fireProjectile(sourceId, targetId, projectileData = {}) {\r\n        const sourcePos = this.game.getComponent(sourceId, this.componentTypes.POSITION);\r\n        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);\r\n        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);\r\n        \r\n        if (!sourcePos || !sourceCombat || !targetPos) return null;\r\n        \r\n        // Create projectile entity\r\n        const projectileId = this.game.createEntity();\r\n        const components = this.game.componentManager.getComponents();\r\n        \r\n        // Determine projectile element (from weapon, combat component, or projectile data)\r\n        const projectileElement = this.determineProjectileElement(sourceId, projectileData);\r\n        \r\n        // Pass source ID to trajectory calculation for ballistic projectiles\r\n        const projectileDataWithSource = { ...projectileData, sourceId: sourceId };\r\n        \r\n        // Calculate trajectory based on projectile type\r\n        const trajectory = this.calculateTrajectory(sourcePos, targetPos, projectileDataWithSource);\r\n        \r\n        // Determine spawn height - ballistic projectiles start above ground to avoid immediate impact\r\n        const spawnHeight = Math.max(sourcePos.y + 20, 20);           \r\n        \r\n        // Add components with full 3D support\r\n        this.game.addComponent(projectileId, this.componentTypes.POSITION, \r\n            components.Position(sourcePos.x, spawnHeight, sourcePos.z));\r\n        \r\n        this.game.addComponent(projectileId, this.componentTypes.VELOCITY, \r\n            components.Velocity(trajectory.vx, trajectory.vy, trajectory.vz, projectileData.speed, projectileData.ballistic || false));\r\n        \r\n         // Enhanced projectile component with element\r\n        this.game.addComponent(projectileId, this.componentTypes.PROJECTILE, {\r\n            damage: sourceCombat.damage,\r\n            speed: projectileData.speed,\r\n            range: sourceCombat.range * 1.5,\r\n            target: targetId,\r\n            source: sourceId,\r\n            startTime: this.game.state.now,\r\n            startX: sourcePos.x,\r\n            startY: spawnHeight,\r\n            startZ: sourcePos.z,\r\n            isBallistic: projectileData.ballistic || false,\r\n            targetX: targetPos.x,\r\n            targetY: targetPos.y + 20,\r\n            targetZ: targetPos.z,\r\n            launchAngle: trajectory.launchAngle,\r\n            timeToTarget: trajectory.timeToTarget,\r\n            weaponRange: trajectory.weaponRange || sourceCombat.range,\r\n            element: projectileElement\r\n        });\r\n\r\n        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);\r\n        \r\n        // Add UNIT_TYPE component for projectiles\r\n        this.game.addComponent(projectileId, this.componentTypes.UNIT_TYPE, \r\n            components.UnitType(projectileData.id, projectileData.title, 0));\r\n        \r\n        // Add TEAM component (same team as source)\r\n        if (sourceTeam) {\r\n            this.game.addComponent(projectileId, this.componentTypes.TEAM, \r\n                components.Team(sourceTeam.team));\r\n        }\r\n\r\n        // Visual component        \r\n        this.game.addComponent(projectileId, this.componentTypes.RENDERABLE, \r\n            components.Renderable(\"projectiles\", projectileData.id));\r\n        \r\n        // Use LifetimeSystem instead of direct component\r\n        if (this.game.gameManager) {\r\n            this.game.gameManager.call('addLifetime', projectileId, this.PROJECTILE_LIFETIME, {\r\n                fadeOutDuration: 1.0, // Fade out in last second\r\n                onDestroy: (entityId) => {\r\n                    // Custom cleanup for projectiles\r\n                    this.cleanupProjectileData(entityId);\r\n                }\r\n            });\r\n        } else {\r\n            // Fallback to old method if LifetimeSystem not available\r\n            this.game.addComponent(projectileId, this.componentTypes.LIFETIME,\r\n                components.Lifetime(this.PROJECTILE_LIFETIME, this.game.state.now));\r\n        }\r\n        \r\n        // Homing component if specified\r\n        if (projectileData.homing && projectileData.homingStrength > 0) {\r\n            const homingStrength = projectileData.ballistic ? \r\n                projectileData.homingStrength * 0.3 : projectileData.homingStrength;\r\n            this.game.addComponent(projectileId, this.componentTypes.HOMING_TARGET, \r\n                components.HomingTarget(targetId, homingStrength, { x: targetPos.x, y: targetPos.y, z: targetPos.z }));\r\n        }\r\n        \r\n        return projectileId;\r\n    }\r\n    \r\n    cleanupProjectileData(projectileId) {\r\n        // Clean up trail data\r\n        this.projectileTrails.delete(projectileId);\r\n    }\r\n\r\n    /**\r\n     * Determine the element of a projectile based on various sources\r\n     */\r\n    determineProjectileElement(sourceId, projectileData) {\r\n        // Priority order: projectile data > weapon element > combat element > default physical\r\n        \r\n        // 1. Check projectile data for explicit element\r\n        if (projectileData.element) {\r\n            return projectileData.element;\r\n        }\r\n        \r\n        // 2. Check combat component element\r\n        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);\r\n        if (sourceCombat && sourceCombat.element) {\r\n            return sourceCombat.element;\r\n        }\r\n        \r\n        // 3. Default to physical\r\n        const elementTypes = this.game.gameManager ? this.game.gameManager.call('getDamageElementTypes') : null;\r\n        return elementTypes?.PHYSICAL || 'physical';\r\n    }\r\n\r\n    calculateTrajectory(sourcePos, targetPos, projectileData) {\r\n        const dx = targetPos.x - sourcePos.x;\r\n        const dy = targetPos.y - sourcePos.y; // Height difference\r\n        const dz = targetPos.z - sourcePos.z; // Forward/backward distance\r\n        const projectileSpeed = projectileData.speed;\r\n        \r\n        // For ballistic projectiles, calculate arc trajectory based on weapon range\r\n        if (projectileData.ballistic) {\r\n            return this.calculateBallisticTrajectory(sourcePos, targetPos, projectileSpeed, projectileData);\r\n        } else {\r\n            // Direct trajectory for non-ballistic projectiles\r\n            const totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n            if (totalDistance === 0) {\r\n                return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };\r\n            }\r\n            \r\n            const initialVx = (dx / totalDistance) * projectileSpeed;\r\n            const initialVy = (dy / totalDistance) * projectileSpeed;\r\n            const initialVz = (dz / totalDistance) * projectileSpeed;\r\n            \r\n            return {\r\n                vx: this.roundForDeterminism(initialVx),\r\n                vy: this.roundForDeterminism(initialVy),\r\n                vz: this.roundForDeterminism(initialVz),\r\n                launchAngle: this.roundForDeterminism(Math.atan2(Math.sqrt(dx * dx + dz * dz), dy)),\r\n                timeToTarget: this.roundForDeterminism(totalDistance / projectileSpeed)\r\n            };\r\n        }\r\n    }\r\n    \r\n    calculateBallisticTrajectory(sourcePos, targetPos, speed, projectileData) {\r\n        const dx = targetPos.x - sourcePos.x;\r\n        const dy = targetPos.y - sourcePos.y; // Height difference\r\n        const dz = targetPos.z - sourcePos.z; // Forward/backward distance\r\n        \r\n        const horizontalDistance = Math.sqrt(dx * dx + dz * dz);\r\n        \r\n        if (horizontalDistance === 0) {\r\n            return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };\r\n        }\r\n        \r\n        // Get the firing unit's combat range to determine proper ballistic trajectory\r\n        const sourceId = projectileData.sourceId;\r\n        const sourceCombat = sourceId ? this.game.getComponent(sourceId, this.componentTypes.COMBAT) : null;\r\n        const weaponRange = sourceCombat ? sourceCombat.range : horizontalDistance;\r\n        \r\n        // Use 45-degree angle for optimal range (gives maximum distance for given initial velocity)\r\n        const launchAngle = Math.PI / 4; // 45 degrees\r\n        const g = this.GRAVITY;\r\n        \r\n        // Calculate the initial velocity needed to reach the weapon's maximum range at 45 degrees\r\n        const optimalInitialVelocity = Math.sqrt(weaponRange * g);\r\n        \r\n        // Calculate what range this velocity would achieve at our target distance\r\n        const actualRange = Math.min(horizontalDistance, weaponRange);\r\n        \r\n        // If target is within range, calculate trajectory to hit it exactly\r\n        let initialVelocity;\r\n        let actualLaunchAngle = launchAngle;\r\n        \r\n        if (horizontalDistance <= weaponRange) {\r\n            // Target is within range - calculate exact trajectory\r\n            const maxRangeAtOptimalVelocity = (optimalInitialVelocity * optimalInitialVelocity) / g;\r\n            \r\n            if (horizontalDistance <= maxRangeAtOptimalVelocity) {\r\n                // We can reach this distance with our optimal velocity\r\n                initialVelocity = optimalInitialVelocity;\r\n                // Calculate the required angle: sin(2) = (range * g) / v\r\n                const sin2Theta = (horizontalDistance * g) / (initialVelocity * initialVelocity);\r\n                \r\n                // We want the lower trajectory angle (there are two solutions)\r\n                const angle2Theta = Math.asin(Math.min(1, sin2Theta));\r\n                actualLaunchAngle = angle2Theta / 2;\r\n                \r\n                // Prefer angles between 15 and 75 for realistic artillery\r\n                if (actualLaunchAngle < Math.PI / 12) { // Less than 15\r\n                    actualLaunchAngle = Math.PI / 12;\r\n                } else if (actualLaunchAngle > 5 * Math.PI / 12) { // More than 75\r\n                    actualLaunchAngle = 5 * Math.PI / 12;\r\n                }\r\n            } else {\r\n                // Use 45 and calculate required velocity for this specific distance\r\n                actualLaunchAngle = Math.PI / 4;\r\n                initialVelocity = Math.sqrt(horizontalDistance * g);\r\n            }\r\n        } else {\r\n            // Target is beyond weapon range - fire at maximum range in target direction\r\n            initialVelocity = optimalInitialVelocity;\r\n            actualLaunchAngle = Math.PI / 4; // 45 for maximum range\r\n        }\r\n        \r\n        // Calculate time of flight\r\n        const timeToTarget = (2 * initialVelocity * Math.sin(actualLaunchAngle)) / g;\r\n        \r\n        // Calculate horizontal direction unit vector\r\n        const horizontalDirectionX = dx / horizontalDistance;\r\n        const horizontalDirectionZ = dz / horizontalDistance;\r\n        \r\n        // Calculate initial velocity components\r\n        const horizontalVelocity = initialVelocity * Math.cos(actualLaunchAngle);\r\n        const vx = horizontalDirectionX * horizontalVelocity;\r\n        const vz = horizontalDirectionZ * horizontalVelocity;\r\n        const vy = initialVelocity * Math.sin(actualLaunchAngle); // Initial upward velocity\r\n        \r\n        // Adjust for height difference if target is at different elevation\r\n        if (Math.abs(dy) > 5) { // Only adjust for significant height differences\r\n            const heightAdjustment = dy / timeToTarget;\r\n            const adjustedVy = vy + heightAdjustment;\r\n            \r\n            return {\r\n                vx: this.roundForDeterminism(vx),\r\n                vy: this.roundForDeterminism(adjustedVy),\r\n                vz: this.roundForDeterminism(vz),\r\n                launchAngle: this.roundForDeterminism(actualLaunchAngle),\r\n                timeToTarget: this.roundForDeterminism(timeToTarget),\r\n                weaponRange: this.roundForDeterminism(weaponRange),\r\n                calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)\r\n            };\r\n        }\r\n        \r\n        return {\r\n            vx: this.roundForDeterminism(vx),\r\n            vy: this.roundForDeterminism(vy),\r\n            vz: this.roundForDeterminism(vz),\r\n            launchAngle: this.roundForDeterminism(actualLaunchAngle),\r\n            timeToTarget: this.roundForDeterminism(timeToTarget),\r\n            weaponRange: this.roundForDeterminism(weaponRange),\r\n            calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)\r\n        };\r\n    }\r\n    \r\n    update() {\r\n        if (this.game.state.phase !== 'battle') return;\r\n        \r\n        const projectiles = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION, \r\n            this.componentTypes.VELOCITY, \r\n            this.componentTypes.PROJECTILE\r\n        );        \r\n        projectiles.forEach(projectileId => {\r\n            const pos = this.game.getComponent(projectileId, this.componentTypes.POSITION);\r\n            const vel = this.game.getComponent(projectileId, this.componentTypes.VELOCITY);\r\n            const projectile = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE);\r\n            const homing = this.game.getComponent(projectileId, this.componentTypes.HOMING_TARGET);\r\n                        \r\n            // Update homing behavior\r\n            if (homing && homing.targetId && projectile.isBallistic) {\r\n                this.updateBallisticHoming(projectileId, pos, vel, projectile, homing);\r\n            } else if (homing && homing.targetId) {\r\n                this.updateHomingProjectile(projectileId, pos, vel, projectile, homing);\r\n            }\r\n            \r\n            // Handle different collision types based on projectile type\r\n            if (projectile.isBallistic) {\r\n                // Ballistic projectiles ONLY check for ground impact\r\n                this.handleProjectileGroundImpact(projectileId, pos, projectile);\r\n            } else {\r\n                // Non-ballistic projectiles check for direct unit hits\r\n                this.checkProjectileCollisions(projectileId, pos, projectile);\r\n            }\r\n            \r\n            // Update visual trail\r\n            this.updateProjectileTrail(projectileId, pos);\r\n        });\r\n    }\r\n    \r\n    updateBallisticHoming(projectileId, pos, vel, projectile, homing) {\r\n        // Get current target position\r\n        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);\r\n        \r\n        if (targetPos) {\r\n            // Update last known position\r\n            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };\r\n            \r\n            // For ballistic projectiles, we adjust the trajectory mid-flight\r\n            // Calculate time elapsed since launch\r\n            const timeElapsed = this.game.state.now - projectile.startTime;\r\n            const remainingTime = Math.max(0.1, projectile.timeToTarget - timeElapsed);\r\n            \r\n            // Calculate where we need to be to hit the moving target\r\n            const dx = targetPos.x - pos.x;\r\n            const dy = targetPos.y - pos.y;\r\n            const dz = targetPos.z - pos.z;\r\n            \r\n            // Adjust horizontal velocity to reach new target position\r\n            const requiredHorizontalVelX = dx / remainingTime;\r\n            const requiredHorizontalVelZ = dz / remainingTime;\r\n            \r\n            // Apply homing adjustment with strength factor\r\n            const homingStrength = homing.homingStrength * this.game.state.deltaTime * 2; // Reduced for ballistic\r\n            vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + requiredHorizontalVelX * homingStrength);\r\n            vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + requiredHorizontalVelZ * homingStrength);\r\n            \r\n            // For vertical homing, we need to be more careful to maintain ballistic arc\r\n            // Only adjust if we're in the descending phase\r\n            if (vel.vy < 0) { // Falling down\r\n                const requiredVerticalVel = (dy + 0.5 * this.GRAVITY * remainingTime * remainingTime) / remainingTime;\r\n                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength * 0.5) + requiredVerticalVel * (homingStrength * 0.5));\r\n            }\r\n        } else if (homing.lastKnownPosition) {\r\n            // Target is gone, continue toward last known position\r\n            const dx = homing.lastKnownPosition.x - pos.x;\r\n            const dy = homing.lastKnownPosition.y - pos.y;\r\n            const dz = homing.lastKnownPosition.z - pos.z;\r\n            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n            \r\n            if (distance < 20) {\r\n                // Close enough to last known position, destroy projectile\r\n                this.destroyProjectile(projectileId);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    \r\n    updateHomingProjectile(projectileId, pos, vel, projectile, homing) {\r\n        // Get current target position\r\n        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);\r\n        \r\n        if (targetPos) {\r\n            // Update last known position\r\n            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };\r\n            \r\n            // Calculate direction to target\r\n            const dx = targetPos.x - pos.x;\r\n            const dy = targetPos.y - pos.y;\r\n            const dz = targetPos.z - pos.z;\r\n            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n            \r\n            if (distance > 0) {\r\n                // Calculate desired velocity direction\r\n                const desiredVx = (dx / distance) * projectile.speed;\r\n                const desiredVy = (dy / distance) * projectile.speed;\r\n                const desiredVz = (dz / distance) * projectile.speed;\r\n                \r\n                // Blend current velocity with desired velocity based on homing strength\r\n                const homingStrength = homing.homingStrength * this.game.state.deltaTime * 5; // Adjust responsiveness\r\n                vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + desiredVx * homingStrength);\r\n                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength) + desiredVy * homingStrength);\r\n                vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + desiredVz * homingStrength);\r\n                \r\n                // Maintain speed\r\n                const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy + vel.vz * vel.vz);\r\n                if (currentSpeed > 0) {\r\n                    const speedRatio = projectile.speed / currentSpeed;\r\n                    vel.vx = this.roundForDeterminism(vel.vx * speedRatio);\r\n                    vel.vy = this.roundForDeterminism(vel.vy * speedRatio);\r\n                    vel.vz = this.roundForDeterminism(vel.vz * speedRatio);\r\n                }\r\n            }\r\n        } else {\r\n            homing.targetId = null;\r\n        }\r\n    }\r\n    \r\n    checkProjectileCollisions(projectileId, pos, projectile) {\r\n        // Only for NON-ballistic projectiles\r\n        if (projectile.isBallistic) return; // Skip collision check for ballistic\r\n        \r\n        // Get all potential targets\r\n        const allEntities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION, \r\n            this.componentTypes.TEAM,\r\n            this.componentTypes.HEALTH\r\n        );\r\n        \r\n        const sourceTeam = this.game.getComponent(projectile.source, this.componentTypes.TEAM);\r\n        if (!sourceTeam) return;\r\n        \r\n        let hitDetected = false;\r\n\r\n        for (const entityId of allEntities) {\r\n            if (hitDetected) break; // Stop after first hit to ensure consistency\r\n            if (entityId === projectile.source) continue; // Don't hit the source\r\n            \r\n            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);\r\n            \r\n            if (!entityPos || !entityTeam || !entityHealth) continue;\r\n            if (entityTeam.team === sourceTeam.team) continue; // Don't hit allies\r\n            \r\n            // Calculate 3D distance with consistent precision\r\n            const dx = Math.round((entityPos.x - pos.x) * 1000) / 1000;\r\n            const dy = Math.round((entityPos.y - pos.y) * 1000) / 1000;\r\n            const dz = Math.round((entityPos.z - pos.z) * 1000) / 1000;\r\n            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n            \r\n            // Get entity radius for collision detection\r\n            const entityUnitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            const entityRadius = this.getUnitRadius(entityUnitType);\r\n\r\n            // Check collision for direct hit\r\n            if (distance <= entityRadius + this.HIT_DETECTION_RADIUS) {\r\n                // Direct hit detected!\r\n                this.handleProjectileHit(projectileId, entityId, entityPos, projectile);\r\n                hitDetected = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    handleProjectileGroundImpact(entityId, pos, projectile) {\r\n        // Only for ballistic projectiles\r\n        if (!projectile.isBallistic) return;\r\n        \r\n        // Get actual terrain height for projectile impact\r\n        const terrainHeight = this.game.gameManager ? this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z) : null;\r\n        const actualGroundLevel = terrainHeight !== null ? terrainHeight : this.game.movementSystem?.GROUND_LEVEL || 0;\r\n        \r\n        // Check if projectile hit the ground\r\n        if (pos.y <= actualGroundLevel + this.GROUND_IMPACT_THRESHOLD) {\r\n            // Ballistic projectiles explode on ground impact\r\n            this.triggerBallisticExplosion(entityId, pos, projectile, actualGroundLevel);\r\n            return;\r\n        }\r\n    }\r\n\r\n    handleProjectileHit(projectileId, targetId, targetPos, projectile) {\r\n        if (this.game.gameManager) {\r\n            const damage = projectile.damage;\r\n            const elementTypes = this.game.gameManager.call('getDamageElementTypes');\r\n            const element = projectile.element || elementTypes.PHYSICAL;\r\n\r\n            this.game.gameManager.call('applyDamage', projectile.source, targetId, damage, element, {\r\n                isProjectile: true,\r\n                projectileId: projectileId\r\n            });\r\n            if(!this.game.isServer){\r\n                this.game.gameManager.call('createParticleEffect', targetPos.x, targetPos.y, targetPos.z, 'magic', {\r\n                    color: this.getElementalEffectColor(element),\r\n                    count: 3\r\n                });\r\n            }\r\n        }\r\n\r\n\r\n        this.destroyProjectile(projectileId);\r\n    }\r\n\r\n    triggerBallisticExplosion(entityId, pos, projectile, groundLevel) {\r\n        this.createGroundExplosion(entityId, pos, projectile, groundLevel);\r\n\r\n        if (this.game.gameManager) {\r\n            const splashRadius = 80;\r\n            const splashDamage = Math.floor(projectile.damage);\r\n            const elementTypes = this.game.gameManager.call('getDamageElementTypes');\r\n            const element = projectile.element || elementTypes.PHYSICAL;\r\n\r\n            const results = this.game.gameManager.call('applySplashDamage',\r\n                projectile.source,\r\n                pos,\r\n                splashDamage,\r\n                element,\r\n                splashRadius,\r\n                {\r\n                    isBallistic: true,\r\n                    projectileId: entityId,\r\n                    allowFriendlyFire: false\r\n                }\r\n            );\r\n\r\n            if (this.game.combatAISystems && projectile.source && results) {\r\n                for (const result of results) {\r\n                    if (result.targetId && result.actualDamage > 0) {\r\n                        this.game.combatAISystems.setRetaliatoryTarget(result.targetId, projectile.source);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.destroyProjectile(entityId);\r\n    }\r\n    \r\n \r\n\r\n    createGroundExplosion(projectileId, pos, projectile, groundLevel) {\r\n\r\n    }\r\n\r\n    // Get visual effect color based on element\r\n    getElementalEffectColor(element) {\r\n        if (!this.game.gameManager) return '#ff2200'; // blood-red\r\n\r\n        const elementTypes = this.game.gameManager.call('getDamageElementTypes');\r\n\r\n        switch (element) {\r\n            case elementTypes.FIRE:\r\n                return '#ffaa00'; // Default orange\r\n            case elementTypes.COLD:\r\n                return '#44aaff'; // Light blue\r\n            case elementTypes.LIGHTNING:\r\n                return '#ffff44'; // Bright yellow\r\n            case elementTypes.POISON:\r\n                return '#44ff44'; // Green\r\n            case elementTypes.DIVINE:\r\n                return '#ffddaa'; // Golden\r\n            case elementTypes.PHYSICAL:\r\n            default:\r\n                return '#ff2200'; // Default orange\r\n        }\r\n    }\r\n\r\n    // Get explosion effect type based on element\r\n    getElementalExplosionEffect(element) {\r\n        if (!this.game.gameManager) return 'explosion';\r\n\r\n        const elementTypes = this.game.gameManager.call('getDamageElementTypes');\r\n\r\n        switch (element) {\r\n            case elementTypes.FIRE:\r\n                return 'fire_explosion';\r\n            case elementTypes.COLD:\r\n                return 'ice_explosion';\r\n            case elementTypes.LIGHTNING:\r\n                return 'lightning_explosion';\r\n            case elementTypes.POISON:\r\n                return 'poison_explosion';\r\n            case elementTypes.DIVINE:\r\n                return 'divine_explosion';\r\n            case elementTypes.PHYSICAL:\r\n            default:\r\n                return 'explosion';\r\n        }\r\n    }\r\n    \r\n    updateProjectileTrail(projectileId, pos) {\r\n        const projectileVisual = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE_VISUAL);\r\n        if (!projectileVisual || projectileVisual.trailLength <= 0) return;\r\n        \r\n        if (!this.projectileTrails.has(projectileId)) {\r\n            this.projectileTrails.set(projectileId, []);\r\n        }\r\n        \r\n        const trail = this.projectileTrails.get(projectileId);\r\n        \r\n        // Add current position to trail (full 3D)\r\n        trail.push({ x: pos.x, y: pos.y, z: pos.z, time: (this.game.state.now || 0) });\r\n        \r\n        // Remove old trail points\r\n        while (trail.length > projectileVisual.trailLength) {\r\n            trail.shift();\r\n        }\r\n    }\r\n        \r\n    destroyProjectile(projectileId) {\r\n        this.game.gameManager.call('destroyEntityImmediately', projectileId, true);    \r\n        this.game.destroyEntity(projectileId);\r\n        this.cleanupProjectileData(projectileId);\r\n    }\r\n    \r\n    getUnitRadius(unitType) {\r\n        const DEFAULT_UNIT_RADIUS = 15;\r\n        \r\n        if (unitType && unitType.size) {\r\n            return Math.max(DEFAULT_UNIT_RADIUS, unitType.size);\r\n        }\r\n        \r\n        const collections = this.game.getCollections && this.game.getCollections();\r\n        if (collections && collections.units && unitType) {\r\n            const unitDef = collections.units[unitType.id];\r\n            if (unitDef && unitDef.size) {\r\n                return Math.max(DEFAULT_UNIT_RADIUS, unitDef.size);\r\n            }\r\n        }\r\n        \r\n        return DEFAULT_UNIT_RADIUS;\r\n    }\r\n    \r\n    getProjectileTrail(projectileId) {\r\n        return this.projectileTrails.get(projectileId) || [];\r\n    }\r\n    entityDestroyed(entityId) {\r\n        // Clean up projectile trails\r\n        if (this.projectileTrails) {\r\n            this.projectileTrails.delete(entityId);\r\n        }\r\n        \r\n        // Clean up any projectile tracking\r\n        if (this.activeProjectiles) {\r\n            this.activeProjectiles.delete(entityId);\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ProjectileSystem.js",
        "fileName": "ProjectileSystem"
      },
      "PathfindingSystem": {
        "script": "class PathfindingSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.pathfindingSystem = this;\r\n\r\n        this.navMesh = null;\r\n        this.navGridSize = null; // Will be set from config\r\n        this.navGridWidth = 0;\r\n        this.navGridHeight = 0;\r\n        \r\n        this.terrainTypes = null;\r\n        this.walkabilityCache = new Map();\r\n        this.ramps = new Set(); // Stores ramp locations in \"x,z\" format (terrain grid coords)\r\n\r\n        this.pathCache = new Map();\r\n        this.MAX_CACHE_SIZE = 1000;\r\n        this.CACHE_EXPIRY_TIME = 5000;\r\n\r\n        this.pathRequests = [];\r\n        this.MAX_PATHS_PER_FRAME = 100;\r\n\r\n        // Path smoothing configuration\r\n        // Lower values = less aggressive smoothing = less corner cutting\r\n        // Higher values = more aggressive smoothing = smoother but riskier paths\r\n        this.MAX_SMOOTH_LOOKAHEAD = 3; // Maximum waypoints to look ahead when smoothing\r\n        \r\n        this.initialized = false;\r\n    }\r\n\r\n    init() {\r\n        if (this.initialized) return;\r\n\r\n        this.game.gameManager.register('isPositionWalkable', this.isPositionWalkable.bind(this));\r\n        this.game.gameManager.register('isGridPositionWalkable', this.isGridPositionWalkable.bind(this));\r\n        this.game.gameManager.register('requestPath', this.requestPath.bind(this));  \r\n        this.game.gameManager.register('hasRampAt', this.hasRampAt.bind(this));  \r\n        this.game.gameManager.register('hasDirectWalkablePath', this.hasDirectWalkablePath.bind(this)); // ADD THIS\r\n\r\n\r\n        const collections = this.game.getCollections();\r\n        if (!collections) {\r\n            console.warn('PathfindingSystem: Collections not available');\r\n            return;\r\n        }\r\n        \r\n        const level = collections.levels?.[this.game.state.level];\r\n        if (!level || !level.tileMap) {\r\n            console.warn('PathfindingSystem: Level or tileMap not available');\r\n            return;\r\n        }\r\n        \r\n        if (!this.game.terrainSystem || !this.game.terrainSystem.initialized) {\r\n            console.warn('PathfindingSystem: Waiting for terrain system...');\r\n            return;\r\n        }\r\n        \r\n        this.terrainTypes = level.tileMap.terrainTypes;\r\n        if (!this.terrainTypes) {\r\n            console.warn('PathfindingSystem: No terrain types found in level');\r\n            return;\r\n        }\r\n\r\n        // Set navigation grid size to half of terrain grid (matches placement grid)\r\n        this.navGridSize = collections.configs.game.gridSize / 2;\r\n        console.log('PathfindingSystem: Using nav grid size', this.navGridSize);\r\n\r\n        // Load ramps data\r\n        this.loadRamps(level.tileMap);\r\n\r\n        this.buildWalkabilityCache();\r\n        this.bakeNavMesh();\r\n        this.initialized = true;\r\n        console.log('PathfindingSystem: Initialized with', this.terrainTypes.length, 'terrain types');\r\n    }\r\n\r\n    loadRamps(tileMap) {\r\n        this.ramps.clear();\r\n\r\n        const ramps = tileMap.ramps || [];\r\n        for (const ramp of ramps) {\r\n            const key = `${ramp.x},${ramp.z}`;\r\n            this.ramps.add(key);\r\n        }\r\n\r\n        console.log(`PathfindingSystem: Loaded ${ramps.length} ramps`);\r\n    }\r\n\r\n    buildWalkabilityCache() {\r\n        // This cache is now deprecated in favor of height-based walkability\r\n        // Kept for backwards compatibility with old level data\r\n        this.walkabilityCache.clear();\r\n\r\n        for (let i = 0; i < this.terrainTypes.length; i++) {\r\n            const terrainType = this.terrainTypes[i];\r\n            const walkableNeighbors = terrainType.walkableNeighbors || [];\r\n\r\n            for (let j = 0; j < this.terrainTypes.length; j++) {\r\n                const targetType = this.terrainTypes[j].type;\r\n                const canWalk = walkableNeighbors.includes(targetType);\r\n\r\n                const key = `${i}-${j}`;\r\n                this.walkabilityCache.set(key, canWalk);\r\n            }\r\n        }\r\n    }\r\n\r\n    canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex) {\r\n        // NEW: Use height-based walkability if heightMap is available\r\n        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {\r\n            // Always walkable between same terrain types\r\n            return true;\r\n        }\r\n\r\n        // OLD: Fall back to walkableNeighbors cache for backwards compatibility\r\n        const key = `${fromTerrainIndex}-${toTerrainIndex}`;\r\n        return this.walkabilityCache.get(key) === true;\r\n    }\r\n\r\n    // Convert nav grid coordinates to terrain grid coordinates\r\n    navGridToTerrainGrid(navGridX, navGridZ) {\r\n        const worldPos = this.navGridToWorld(navGridX, navGridZ);\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const terrainSize = this.game.gameManager.call('getTerrainSize');\r\n\r\n        const terrainX = Math.floor((worldPos.x + terrainSize / 2) / gridSize);\r\n        const terrainZ = Math.floor((worldPos.z + terrainSize / 2) / gridSize);\r\n\r\n        return { x: terrainX, z: terrainZ };\r\n    }\r\n\r\n    // Check if there's a ramp at the given nav grid position\r\n    hasRampAtNav(navGridX, navGridZ) {\r\n        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);\r\n        const key = `${terrainGrid.x},${terrainGrid.z}`;\r\n        return this.ramps.has(key);\r\n    }\r\n    \r\n    hasRampAt(gridX, gridZ) {\r\n        return this.ramps.has(`${gridX},${gridZ}`);\r\n    }\r\n\r\n    // Get height level at nav grid position\r\n    getHeightLevelAtNavGrid(navGridX, navGridZ) {\r\n        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);\r\n        return this.game.terrainSystem?.getHeightLevelAtGridPosition(terrainGrid.x, terrainGrid.z) || 0;\r\n    }\r\n\r\n    // Check if movement between terrains is allowed (either through height + ramps or walkableNeighbors)\r\n    canWalkBetweenTerrainsWithRamps(fromTerrainIndex, toTerrainIndex, fromNavGridX, fromNavGridZ, toNavGridX, toNavGridZ) {\r\n        // NEW: Use height-based walkability if heightMap is available\r\n        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {\r\n            const fromHeight = this.getHeightLevelAtNavGrid(fromNavGridX, fromNavGridZ);\r\n            const toHeight = this.getHeightLevelAtNavGrid(toNavGridX, toNavGridZ);\r\n\r\n            // Same height level = always walkable\r\n            if (fromHeight === toHeight) {\r\n                return true;\r\n            }\r\n\r\n            // Different heights = only walkable with a ramp\r\n            // Ramps allow movement between any adjacent height levels\r\n            if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // OLD: Use walkableNeighbors logic for backwards compatibility\r\n        // First check normal walkability\r\n        if (this.canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex)) {\r\n            return true;\r\n        }\r\n\r\n        // If not normally walkable, check if there's a ramp at either position\r\n        // Ramps allow movement between any terrain heights\r\n        if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    bakeNavMesh() {\r\n        const terrainSize = this.game.gameManager.call('getTerrainSize');\r\n        \r\n        this.navGridWidth = Math.ceil(terrainSize / this.navGridSize);\r\n        this.navGridHeight = Math.ceil(terrainSize / this.navGridSize);\r\n        \r\n        this.navMesh = new Uint8Array(this.navGridWidth * this.navGridHeight);\r\n        \r\n        const halfTerrain = terrainSize / 2;\r\n        \r\n        // First pass: populate the navmesh with terrain types\r\n        for (let z = 0; z < this.navGridHeight; z++) {\r\n            for (let x = 0; x < this.navGridWidth; x++) {\r\n                const worldX = (x * this.navGridSize) - halfTerrain + this.navGridSize / 2;\r\n                const worldZ = (z * this.navGridSize) - halfTerrain + this.navGridSize / 2;\r\n                \r\n                const terrainType = this.game.gameManager.call('getTerrainTypeAtPosition', worldX, worldZ);\r\n                \r\n                const idx = z * this.navGridWidth + x;\r\n                this.navMesh[idx] = terrainType !== null ? terrainType : 0;\r\n            }\r\n        }\r\n        \r\n        // Second pass: mark cells adjacent to impassable terrain as impassable\r\n        // Create a copy to read from while we modify\r\n        const originalNavMesh = new Uint8Array(this.navMesh);\r\n        \r\n        // for (let z = 0; z < this.navGridHeight; z++) {\r\n        //     for (let x = 0; x < this.navGridWidth; x++) {\r\n        //         const idx = z * this.navGridWidth + x;\r\n        //         const currentTerrain = originalNavMesh[idx];\r\n                \r\n        //         // Check if this cell is walkable\r\n        //         if (this.isTerrainWalkable(currentTerrain)) {\r\n        //             // Check all 8 neighbors\r\n        //             const neighbors = [\r\n        //                 {dx: 1, dz: 0}, {dx: -1, dz: 0}, \r\n        //                 {dx: 0, dz: 1}, {dx: 0, dz: -1},\r\n        //                 {dx: 1, dz: 1}, {dx: -1, dz: 1}, \r\n        //                 {dx: 1, dz: -1}, {dx: -1, dz: -1}\r\n        //             ];\r\n                    \r\n        //             for (const {dx, dz} of neighbors) {\r\n        //                 const nx = x + dx;\r\n        //                 const nz = z + dz;\r\n                        \r\n        //                 if (nx >= 0 && nx < this.navGridWidth && nz >= 0 && nz < this.navGridHeight) {\r\n        //                     const neighborIdx = nz * this.navGridWidth + nx;\r\n        //                     const neighborTerrain = originalNavMesh[neighborIdx];\r\n                            \r\n        //                     // If neighbor is impassable or we can't walk to it\r\n        //                     if (!this.isTerrainWalkable(neighborTerrain) || \r\n        //                         !this.canWalkBetweenTerrains(currentTerrain, neighborTerrain)) {\r\n        //                         // Mark this cell as impassable (use 255 as a special marker)\r\n        //                         this.navMesh[idx] = 255;\r\n        //                         break;\r\n        //                     }\r\n        //                 }\r\n        //             }\r\n        //         }\r\n        //     }\r\n        // }\r\n        \r\n        console.log(`PathfindingSystem: Baked nav mesh ${this.navGridWidth}x${this.navGridHeight} with buffer zones`);\r\n    }\r\n    \r\n    isTerrainWalkable(terrainIndex) {\r\n        if (terrainIndex === null || terrainIndex === 255) return false;\r\n        \r\n        // A terrain is walkable if it has at least one walkable neighbor defined\r\n        const terrainType = this.terrainTypes[terrainIndex];\r\n        if (!terrainType) return false;\r\n        \r\n        const walkableNeighbors = terrainType.walkableNeighbors || [];\r\n        return walkableNeighbors.length > 0;\r\n    }\r\n\r\n    worldToNavGrid(worldX, worldZ) {\r\n        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;\r\n        const gridX = Math.floor((worldX + halfTerrain) / this.navGridSize);\r\n        const gridZ = Math.floor((worldZ + halfTerrain) / this.navGridSize);\r\n        return { x: gridX, z: gridZ };\r\n    }\r\n\r\n    navGridToWorld(gridX, gridZ) {\r\n        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;\r\n        const worldX = (gridX * this.navGridSize) - halfTerrain + this.navGridSize / 2;\r\n        const worldZ = (gridZ * this.navGridSize) - halfTerrain + this.navGridSize / 2;\r\n        return { x: worldX, z: worldZ };\r\n    }\r\n\r\n    getTerrainAtNavGrid(gridX, gridZ) {\r\n        if (gridX < 0 || gridX >= this.navGridWidth || gridZ < 0 || gridZ >= this.navGridHeight) {\r\n            return null;\r\n        }\r\n        return this.navMesh[gridZ * this.navGridWidth + gridX];\r\n    }\r\n\r\n    requestPath(entityId, startX, startZ, endX, endZ, priority = 0) {\r\n        const cacheKey = `${Math.floor(startX/50)},${Math.floor(startZ/50)}-${Math.floor(endX/50)},${Math.floor(endZ/50)}`;\r\n        \r\n        const cached = this.pathCache.get(cacheKey);\r\n        if (cached && (this.game.state.now - cached.timestamp) < this.CACHE_EXPIRY_TIME) {\r\n            return cached.path;\r\n        }\r\n        \r\n        this.pathRequests.push({\r\n            entityId,\r\n            startX,\r\n            startZ,\r\n            endX,\r\n            endZ,\r\n            priority,\r\n            cacheKey,\r\n            timestamp: this.game.state.now\r\n        });\r\n        \r\n        return null;\r\n    }\r\n\r\n    findPath(startX, startZ, endX, endZ, cacheKey = null) {\r\n        const startGrid = this.worldToNavGrid(startX, startZ);\r\n        const endGrid = this.worldToNavGrid(endX, endZ);\r\n        \r\n        if (startGrid.x === endGrid.x && startGrid.z === endGrid.z) {\r\n            return [{ x: endX, z: endZ }];\r\n        }\r\n        \r\n        const openSet = new GUTS.MinHeap();\r\n        const closedSet = new Set();\r\n        const cameFrom = new Map();\r\n        const gScore = new Map();\r\n        const fScore = new Map();\r\n        \r\n        const startKey = `${startGrid.x},${startGrid.z}`;\r\n        const endKey = `${endGrid.x},${endGrid.z}`;\r\n        \r\n        gScore.set(startKey, 0);\r\n        fScore.set(startKey, this.heuristic(startGrid, endGrid));\r\n        openSet.push({ key: startKey, x: startGrid.x, z: startGrid.z, f: fScore.get(startKey) });\r\n        \r\n        const directions = [\r\n            {dx: 1, dz: 0}, {dx: -1, dz: 0}, {dx: 0, dz: 1}, {dx: 0, dz: -1},\r\n            {dx: 1, dz: 1}, {dx: -1, dz: 1}, {dx: 1, dz: -1}, {dx: -1, dz: -1}\r\n        ];\r\n        \r\n        let iterations = 0;\r\n        const maxIterations = this.navGridWidth * this.navGridHeight;\r\n        \r\n        // Track the closest point we've found to the destination\r\n        let closestNode = { key: startKey, x: startGrid.x, z: startGrid.z };\r\n        let closestDistance = this.heuristic(startGrid, endGrid);\r\n        \r\n        while (!openSet.isEmpty() && iterations < maxIterations) {\r\n            iterations++;\r\n            \r\n            const current = openSet.pop();\r\n            const currentKey = current.key;\r\n            \r\n            if (currentKey === endKey) {\r\n                const path = this.reconstructPath(cameFrom, currentKey, endX, endZ);\r\n                \r\n                if (cacheKey) {\r\n                    this.addToCache(cacheKey, path);\r\n                }\r\n                \r\n                return path;\r\n            }\r\n            \r\n            closedSet.add(currentKey);\r\n            \r\n            // Check if this is closer to the destination than previous closest\r\n            const distToEnd = this.heuristic({ x: current.x, z: current.z }, endGrid);\r\n            if (distToEnd < closestDistance) {\r\n                closestDistance = distToEnd;\r\n                closestNode = current;\r\n            }\r\n            \r\n            const currentTerrain = this.getTerrainAtNavGrid(current.x, current.z);\r\n            \r\n            for (const dir of directions) {\r\n                const neighborX = current.x + dir.dx;\r\n                const neighborZ = current.z + dir.dz;\r\n                const neighborKey = `${neighborX},${neighborZ}`;\r\n                \r\n                if (closedSet.has(neighborKey)) continue;\r\n                \r\n                const neighborTerrain = this.getTerrainAtNavGrid(neighborX, neighborZ);\r\n                if (neighborTerrain === null || neighborTerrain === 255) continue;\r\n\r\n                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, neighborTerrain, current.x, current.z, neighborX, neighborZ)) {\r\n                    continue;\r\n                }\r\n                \r\n                const isDiagonal = dir.dx !== 0 && dir.dz !== 0;\r\n                \r\n                // For diagonal moves, check both adjacent cells to prevent corner cutting\r\n                if (isDiagonal) {\r\n                    const terrainX = this.getTerrainAtNavGrid(current.x + dir.dx, current.z);\r\n                    const terrainZ = this.getTerrainAtNavGrid(current.x, current.z + dir.dz);\r\n\r\n                    // Both adjacent cells must exist and be walkable\r\n                    if (terrainX === null || terrainX === 255 ||\r\n                        terrainZ === null || terrainZ === 255) {\r\n                        continue;\r\n                    }\r\n\r\n                    if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, current.x, current.z, current.x + dir.dx, current.z) ||\r\n                        !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, current.x, current.z, current.x, current.z + dir.dz)) {\r\n                        continue;\r\n                    }\r\n                }\r\n                \r\n                const moveCost = isDiagonal ? 1.414 : 1;\r\n                const tentativeGScore = gScore.get(currentKey) + moveCost;\r\n                \r\n                if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {\r\n                    cameFrom.set(neighborKey, currentKey);\r\n                    gScore.set(neighborKey, tentativeGScore);\r\n                    \r\n                    const h = this.heuristic({x: neighborX, z: neighborZ}, endGrid);\r\n                    const f = tentativeGScore + h;\r\n                    fScore.set(neighborKey, f);\r\n                    \r\n                    openSet.push({ key: neighborKey, x: neighborX, z: neighborZ, f });\r\n                }\r\n            }\r\n        }\r\n        \r\n        // No path found to exact destination - return path to closest reachable point\r\n        if (closestNode.key !== startKey) {\r\n            const closestWorld = this.navGridToWorld(closestNode.x, closestNode.z);\r\n            const path = this.reconstructPath(cameFrom, closestNode.key, closestWorld.x, closestWorld.z);\r\n            \r\n            if (cacheKey) {\r\n                this.addToCache(cacheKey, path);\r\n            }\r\n            \r\n            console.log(`PathfindingSystem: No path to destination, returning path to closest point (distance: ${closestDistance.toFixed(1)})`);\r\n            return path;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    reconstructPath(cameFrom, currentKey, endX, endZ) {\r\n        const path = [];\r\n        const gridPath = [];\r\n        \r\n        let current = currentKey;\r\n        while (current) {\r\n            const [x, z] = current.split(',').map(Number);\r\n            gridPath.unshift({ x, z });\r\n            current = cameFrom.get(current);\r\n        }\r\n        \r\n        for (const gridPoint of gridPath) {\r\n            const worldPos = this.navGridToWorld(gridPoint.x, gridPoint.z);\r\n            path.push(worldPos);\r\n        }\r\n        \r\n        if (path.length > 0) {\r\n            path[path.length - 1] = { x: endX, z: endZ };\r\n        }\r\n        \r\n        return this.smoothPath(path);\r\n    }\r\n\r\n    smoothPath(path) {\r\n        if (path.length <= 2) return path;\r\n\r\n        const smoothed = [path[0]];\r\n        let currentIdx = 0;\r\n\r\n        while (currentIdx < path.length - 1) {\r\n            let farthestVisible = currentIdx + 1;\r\n\r\n            // Limit how far ahead we look to prevent aggressive corner cutting\r\n            const maxLookahead = Math.min(\r\n                path.length - 1,\r\n                currentIdx + this.MAX_SMOOTH_LOOKAHEAD\r\n            );\r\n\r\n            // Check from far to near within the limited lookahead range\r\n            // This still prioritizes smoother paths but prevents excessive shortcuts\r\n            for (let i = maxLookahead; i > currentIdx + 1; i--) {\r\n                if (this.hasLineOfSight(path[currentIdx], path[i])) {\r\n                    farthestVisible = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            smoothed.push(path[farthestVisible]);\r\n            currentIdx = farthestVisible;\r\n        }\r\n\r\n        return smoothed;\r\n    }\r\n    hasDirectWalkablePath(fromPos, toPos, entityId = null) {\r\n        if (!this.initialized || !this.navMesh) return false;\r\n        \r\n        const fromGrid = this.worldToNavGrid(fromPos.x, fromPos.z);\r\n        const toGrid = this.worldToNavGrid(toPos.x, toPos.z);\r\n        \r\n        // Same grid cell = direct path\r\n        if (fromGrid.x === toGrid.x && fromGrid.z === toGrid.z) {\r\n            return true;\r\n        }\r\n        \r\n        // Bresenham's line algorithm to check every grid cell along the path\r\n        const dx = Math.abs(toGrid.x - fromGrid.x);\r\n        const dz = Math.abs(toGrid.z - fromGrid.z);\r\n        const sx = fromGrid.x < toGrid.x ? 1 : -1;\r\n        const sz = fromGrid.z < toGrid.z ? 1 : -1;\r\n        let err = dx - dz;\r\n        \r\n        let x = fromGrid.x;\r\n        let z = fromGrid.z;\r\n        let lastX = x;\r\n        let lastZ = z;\r\n        let lastTerrain = this.getTerrainAtNavGrid(x, z);\r\n\r\n        // If starting position isn't walkable, fail immediately\r\n        if (!this.isTerrainWalkable(lastTerrain)) {\r\n            return false;\r\n        }\r\n\r\n        while (true) {\r\n            // Reached destination\r\n            if (x === toGrid.x && z === toGrid.z) {\r\n                return true;\r\n            }\r\n\r\n            const currentTerrain = this.getTerrainAtNavGrid(x, z);\r\n\r\n            // Hit impassable terrain or out of bounds\r\n            if (currentTerrain === null || currentTerrain === 255) {\r\n                return false;\r\n            }\r\n\r\n            // Check if current terrain is walkable\r\n            if (!this.isTerrainWalkable(currentTerrain)) {\r\n                return false;\r\n            }\r\n\r\n            // Check if we can transition from last terrain to current terrain\r\n            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {\r\n                return false;\r\n            }\r\n            \r\n            const e2 = 2 * err;\r\n            const willMoveX = e2 > -dz;\r\n            const willMoveZ = e2 < dx;\r\n            \r\n            // For diagonal movement, check both adjacent cells to prevent corner cutting\r\n            if (willMoveX && willMoveZ) {\r\n                const terrainX = this.getTerrainAtNavGrid(x + sx, z);\r\n                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);\r\n\r\n                // Both adjacent cells must be valid and walkable\r\n                if (terrainX === null || terrainX === 255 ||\r\n                    terrainZ === null || terrainZ === 255) {\r\n                    return false;\r\n                }\r\n\r\n                if (!this.isTerrainWalkable(terrainX) || !this.isTerrainWalkable(terrainZ)) {\r\n                    return false;\r\n                }\r\n\r\n                // Check terrain transitions for both adjacent cells\r\n                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||\r\n                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            lastTerrain = currentTerrain;\r\n            lastX = x;\r\n            lastZ = z;\r\n\r\n            // Move along the line\r\n            if (willMoveX) {\r\n                err -= dz;\r\n                x += sx;\r\n            }\r\n            if (willMoveZ) {\r\n                err += dx;\r\n                z += sz;\r\n            }\r\n        }\r\n    }\r\n    hasLineOfSight(from, to) {\r\n        const fromGrid = this.worldToNavGrid(from.x, from.z);\r\n        const toGrid = this.worldToNavGrid(to.x, to.z);\r\n        \r\n        const dx = Math.abs(toGrid.x - fromGrid.x);\r\n        const dz = Math.abs(toGrid.z - fromGrid.z);\r\n        const sx = fromGrid.x < toGrid.x ? 1 : -1;\r\n        const sz = fromGrid.z < toGrid.z ? 1 : -1;\r\n        let err = dx - dz;\r\n        \r\n        let x = fromGrid.x;\r\n        let z = fromGrid.z;\r\n        let lastX = x;\r\n        let lastZ = z;\r\n        let lastTerrain = this.getTerrainAtNavGrid(x, z);\r\n\r\n        while (true) {\r\n            if (x === toGrid.x && z === toGrid.z) return true;\r\n\r\n            const currentTerrain = this.getTerrainAtNavGrid(x, z);\r\n            if (currentTerrain === null || currentTerrain === 255) return false;\r\n\r\n            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {\r\n                return false;\r\n            }\r\n            \r\n            const e2 = 2 * err;\r\n            const willMoveX = e2 > -dz;\r\n            const willMoveZ = e2 < dx;\r\n            \r\n            // Check for diagonal movement (corner cutting)\r\n            if (willMoveX && willMoveZ) {\r\n                // We're moving diagonally - check both adjacent cells to prevent corner cutting\r\n                const terrainX = this.getTerrainAtNavGrid(x + sx, z);\r\n                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);\r\n                \r\n                // Both adjacent cells must be valid and walkable from current position\r\n                if (terrainX === null || terrainX === 255 ||\r\n                    terrainZ === null || terrainZ === 255) {\r\n                    return false;\r\n                }\r\n\r\n                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||\r\n                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            lastTerrain = currentTerrain;\r\n            lastX = x;\r\n            lastZ = z;\r\n\r\n            if (willMoveX) {\r\n                err -= dz;\r\n                x += sx;\r\n            }\r\n            if (willMoveZ) {\r\n                err += dx;\r\n                z += sz;\r\n            }\r\n        }\r\n    }\r\n\r\n    heuristic(a, b) {\r\n        const dx = Math.abs(a.x - b.x);\r\n        const dz = Math.abs(a.z - b.z);\r\n        return Math.sqrt(dx * dx + dz * dz);\r\n    }\r\n\r\n    addToCache(key, path) {\r\n        if (this.pathCache.size >= this.MAX_CACHE_SIZE) {\r\n            const oldestKey = null;\r\n            let oldestTime = Infinity;\r\n            \r\n            for (const [k, v] of this.pathCache.entries()) {\r\n                if (v.timestamp < oldestTime) {\r\n                    oldestTime = v.timestamp;\r\n                    oldestKey = k;\r\n                }\r\n            }\r\n            \r\n            if (oldestKey) {\r\n                this.pathCache.delete(oldestKey);\r\n            }\r\n        }\r\n        \r\n        this.pathCache.set(key, {\r\n            path: path,\r\n            timestamp: this.game.state.now\r\n        });\r\n    }\r\n\r\n    clearPathCache() {\r\n        this.pathCache.clear();\r\n    }\r\n\r\n    update() {\r\n        if (!this.initialized) {\r\n            this.init();\r\n            return;\r\n        }\r\n        \r\n        const now = this.game.state.now;\r\n        const keysToDelete = [];\r\n        \r\n        for (const [key, data] of this.pathCache.entries()) {\r\n            if (now - data.timestamp > this.CACHE_EXPIRY_TIME) {\r\n                keysToDelete.push(key);\r\n            }\r\n        }\r\n        \r\n        keysToDelete.sort();\r\n        for (const key of keysToDelete) {\r\n            this.pathCache.delete(key);\r\n        }\r\n        \r\n        if (this.pathRequests.length === 0) return;\r\n        \r\n        this.pathRequests.sort((a, b) => {\r\n            if (b.priority !== a.priority) return b.priority - a.priority;\r\n            return String(a.entityId).localeCompare(String(b.entityId));\r\n        });\r\n        \r\n        const pathsToProcess = Math.min(this.MAX_PATHS_PER_FRAME, this.pathRequests.length);\r\n        \r\n        for (let i = 0; i < pathsToProcess; i++) {\r\n            const request = this.pathRequests.shift();\r\n            \r\n            const path = this.findPath(\r\n                request.startX,\r\n                request.startZ,\r\n                request.endX,\r\n                request.endZ,\r\n                request.cacheKey\r\n            );\r\n            \r\n            if (path && this.game.componentManager) {\r\n                const componentTypes = this.game.componentManager.getComponentTypes();\r\n                const aiState = this.game.getComponent(request.entityId, componentTypes.AI_STATE);\r\n                \r\n                if (aiState) {\r\n                    aiState.path = path;\r\n                    aiState.pathIndex = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    isGridPositionWalkable(gridPos) {\r\n        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', gridPos.x, gridPos.z);\r\n        return this.isPositionWalkable(worldPos);\r\n    }\r\n\r\n    isPositionWalkable(pos) {\r\n        const grid = this.worldToNavGrid(pos.x, pos.z);\r\n        \r\n        // Check bounds\r\n        if (grid.x < 0 || grid.x >= this.navGridWidth || \r\n            grid.z < 0 || grid.z >= this.navGridHeight) {\r\n            return false;\r\n        }\r\n        \r\n        const terrain = this.getTerrainAtNavGrid(grid.x, grid.z);\r\n        return this.isTerrainWalkable(terrain);\r\n    }\r\n\r\n    ping() {\r\n        console.log('pong');\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PathfindingSystem.js",
        "fileName": "PathfindingSystem"
      },
      "RenderSystem": {
        "script": "class RenderSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.renderSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n\r\n        this.vatBatches = new Map();\r\n        this.entityToInstance = new Map();\r\n        this.batchCreationPromises = new Map();\r\n        \r\n        this.modelScale = 32;\r\n        this.DEFAULT_CAPACITY = 128;\r\n        this.MIN_MOVEMENT_THRESHOLD = 0.1;\r\n\r\n        this.DEBUG = true;\r\n        this.DEBUG_LEVEL = 1;\r\n        this._frame = 0;\r\n        this._stats = {\r\n            entitiesProcessed: 0,\r\n            instancesCreated: 0,\r\n            instancesRemoved: 0,\r\n            batchesActive: 0\r\n        };\r\n\r\n        this._bindDebugHelpers();\r\n        this.hiddenEntities = new Set();\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('setInstanceClip', this.setInstanceClip.bind(this));\r\n        this.game.gameManager.register('setInstanceSpeed', this.setInstanceSpeed.bind(this));\r\n        this.game.gameManager.register('isInstanced', this.isInstanced.bind(this));\r\n        this.game.gameManager.register('getEntityAnimationState', this.getEntityAnimationState.bind(this));\r\n        this.game.gameManager.register('setInstanceAnimationTime', this.setInstanceAnimationTime.bind(this));\r\n    }\r\n\r\n    _bindDebugHelpers() {\r\n        if (typeof window !== \"undefined\") {\r\n            window.VATRenderDebug = {\r\n                dumpBatches: () => this.dumpBatches(),\r\n                dumpInstances: () => this.dumpInstances(),\r\n                setDebugLevel: (level) => this.DEBUG_LEVEL = level,\r\n                getStats: () => this._stats\r\n            };\r\n        }\r\n    }\r\n\r\n    async update() {\r\n        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;\r\n\r\n        this._frame++;\r\n        await this.updateEntities();\r\n        this.updateAnimations();\r\n        this.finalizeUpdates();\r\n    }\r\n\r\n    async updateEntities() {\r\n        const CT = this.componentTypes;\r\n        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);\r\n        this._stats.entitiesProcessed = entities.length;\r\n        entities.forEach(async (entityId) => {\r\n            const pos = this.game.getComponent(entityId, CT.POSITION);\r\n            const renderable = this.game.getComponent(entityId, CT.RENDERABLE);\r\n            const velocity = this.game.getComponent(entityId, CT.VELOCITY);\r\n            const facing = this.game.getComponent(entityId, CT.FACING);\r\n            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);\r\n\r\n            if (!unitType) return;\r\n\r\n            const fow = this.game.fogOfWarSystem;            \r\n            const isVisible = fow ? fow.isVisibleAt(pos.x, pos.z) : true;\r\n            if (unitType.collection != \"worldObjects\" && unitType.collection != \"cliffs\" && !isVisible) {\r\n                if (this.entityToInstance.has(entityId)) {\r\n                    this.hideEntityInstance(entityId);\r\n                }\r\n                return;\r\n            } else {\r\n                if (this.hiddenEntities.has(entityId)) {\r\n                    this.showEntityInstance(entityId);\r\n                }\r\n            }\r\n\r\n            if (typeof renderable.spawnType !== 'string') {\r\n                console.error(`[RenderSystem] Unit entity ${entityId} has invalid spawnType:`, {\r\n                    objectType: renderable.objectType,\r\n                    spawnType: renderable.spawnType,\r\n                    spawnTypeType: typeof renderable.spawnType\r\n                });\r\n                return;\r\n            }\r\n\r\n            let instance = this.entityToInstance.get(entityId);\r\n            if (!instance) {\r\n                await this.createInstance(entityId, renderable.objectType, renderable.spawnType, renderable.capacity);\r\n                instance = this.entityToInstance.get(entityId);\r\n            }\r\n\r\n            if (instance && !this.hiddenEntities.has(entityId)) {\r\n                this.updateInstanceTransform(instance, pos, velocity, facing);\r\n            }\r\n        });\r\n\r\n        this.cleanupRemovedEntities(new Set(entities));\r\n    }\r\n\r\n    async createInstance(entityId, objectType, spawnType, capacity = this.DEFAULT_CAPACITY) {\r\n        if (typeof spawnType !== 'string') {\r\n            console.error(`[RenderSystem] CRITICAL: spawnType should be string but got ${typeof spawnType}:`, spawnType);\r\n            return null;\r\n        }\r\n\r\n        const batchKey = `${objectType}_${spawnType}`;\r\n        let batch = this.vatBatches.get(batchKey);\r\n        if (!batch) {\r\n            if (this.batchCreationPromises.has(batchKey)) {\r\n                try {\r\n                    batch = await this.batchCreationPromises.get(batchKey);\r\n                } catch (error) {\r\n                    return null;\r\n                }\r\n            } else {\r\n                const creationPromise = this.createVATBatch(batchKey, objectType, spawnType, capacity);\r\n                this.batchCreationPromises.set(batchKey, creationPromise);\r\n                \r\n                try {\r\n                    batch = await creationPromise;\r\n                    if (!batch) {\r\n                        console.error(`[RenderSystem] Failed to create batch for ${batchKey}`);\r\n                        return null;\r\n                    }\r\n                } finally {\r\n                    this.batchCreationPromises.delete(batchKey);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!batch || !batch.capacity) {\r\n            console.error(`[RenderSystem] Batch has no capacity property:`, batch);\r\n            return null;\r\n        }\r\n\r\n        let instanceIndex = -1;\r\n        for (let i = 0; i < batch.capacity; i++) {\r\n            if (!batch.entityMap.has(i)) {               \r\n                instanceIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (instanceIndex === -1) {\r\n            console.warn(`[RenderSystem] Batch ${batchKey} is full (${batch.capacity} instances)`);\r\n            return null;\r\n        }\r\n\r\n        batch.entityMap.set(instanceIndex, entityId);\r\n        batch.count = Math.max(batch.count, instanceIndex + 1);\r\n        batch.mesh.count = batch.count;\r\n\r\n        if (batch.attributes && batch.attributes.clipIndex) {\r\n            batch.attributes.clipIndex.setX(instanceIndex, 0);\r\n            batch.attributes.animTime.setX(instanceIndex, 0);\r\n            batch.attributes.animSpeed.setX(instanceIndex, 1);\r\n            \r\n            batch.attributes.clipIndex.array[instanceIndex] = 0;\r\n            batch.attributes.animTime.array[instanceIndex] = 0;\r\n            batch.attributes.animSpeed.array[instanceIndex] = 1;\r\n            \r\n            batch.dirty.animation = true; \r\n        }\r\n\r\n        const instance = { batchKey, instanceIndex };\r\n        this.entityToInstance.set(entityId, instance);\r\n        this._stats.instancesCreated++;\r\n    \r\n        return instance;\r\n    }\r\n\r\n    async createVATBatch(batchKey, objectType, spawnType, capacity) {\r\n        const collections = this.game.getCollections?.();\r\n        let objectDef = null;\r\n        \r\n        if (collections[objectType]) {\r\n            objectDef = collections[objectType][spawnType];\r\n            if (!objectDef && typeof spawnType === 'number') {\r\n                const objectKeys = Object.keys(collections[objectType]);\r\n                if (spawnType < objectKeys.length) {\r\n                    const unitKey = objectKeys[spawnType];\r\n                    objectDef = collections[objectType][unitKey];\r\n                }\r\n            }\r\n            if (!objectDef) {\r\n                objectDef = collections[objectType][String(spawnType)];\r\n            }\r\n        }\r\n        \r\n        if (!objectDef) {\r\n            console.error(`[RenderSystem] No object definition found for ${objectType} - ${spawnType}`);\r\n            return null;\r\n        }\r\n\r\n        let bundleResult;\r\n        try {\r\n            bundleResult = await this.game.modelManager.requestVATBundle(objectType, spawnType, objectDef);\r\n        } catch (error) {\r\n            console.error(`[RenderSystem] VAT bundle request failed for ${batchKey}:`, error);\r\n            return null;\r\n        }\r\n        \r\n        if (!bundleResult.ready) {\r\n            console.warn(`[RenderSystem] VAT bundle not ready for ${batchKey}`);\r\n            return null;\r\n        }\r\n\r\n        const bundle = bundleResult.bundle;\r\n        if (!bundle) {\r\n            console.error(`[RenderSystem] No bundle in result for ${batchKey}`, bundleResult);\r\n            return null;\r\n        }\r\n        \r\n        if (!bundle.geometry || !bundle.material) {\r\n            console.error(`[RenderSystem] Invalid VAT bundle for ${batchKey} - missing geometry or material:`, {\r\n                hasGeometry: !!bundle.geometry,\r\n                hasMaterial: !!bundle.material,\r\n                bundle\r\n            });\r\n            return null;\r\n        }\r\n\r\n        if (bundle.meta) {\r\n            if (bundle.meta.clips && bundle.meta.clipIndexByName) {\r\n                bundle.meta.clips.forEach((clip, arrayIndex) => {\r\n                    const mappedIndex = bundle.meta.clipIndexByName[clip.name];\r\n                    const match = mappedIndex === arrayIndex;\r\n                    if (!match) {\r\n                        console.error(`[RenderSystem] METADATA CORRUPTION: Clip \"${clip.name}\" index mismatch!`);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            console.error(`[RenderSystem] CRITICAL: No meta object in VAT bundle for ${batchKey}`);\r\n        }\r\n\r\n        const geometry = bundle.geometry.clone();\r\n        const material = bundle.material;\r\n\r\n        material.uuid = THREE.MathUtils.generateUUID();\r\n        material.needsUpdate = true;\r\n\r\n        material.userData = {\r\n            batchKey: batchKey,\r\n            createdAt: Date.now(),\r\n            vatTexture: bundle.meta.vatTextureId || 'unknown'\r\n        };\r\n\r\n        this.setupVATAttributes(geometry, capacity);\r\n\r\n        const mesh = new THREE.InstancedMesh(geometry, material, capacity);\r\n        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\r\n        mesh.count = 0;\r\n        mesh.castShadow = true;\r\n        mesh.receiveShadow = true;\r\n\r\n        mesh.frustumCulled = false;\r\n        \r\n        const boundingBox = new THREE.Box3();\r\n        const size = this.modelScale * 2;\r\n        boundingBox.setFromCenterAndSize(new THREE.Vector3(0, 0, 0), new THREE.Vector3(size, size, size));\r\n        geometry.boundingBox = boundingBox;\r\n        geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), this.modelScale);\r\n\r\n        if (!material.side || material.side === THREE.FrontSide) {\r\n            material.side = THREE.DoubleSide;\r\n        }\r\n\r\n        this.game.scene.add(mesh);\r\n\r\n        const batch = {\r\n            mesh,\r\n            geometry,\r\n            material,\r\n            capacity,\r\n            count: 0,\r\n            entityMap: new Map(),\r\n            attributes: {\r\n                clipIndex: geometry.getAttribute('aClipIndex'),\r\n                animTime: geometry.getAttribute('aAnimTime'),\r\n                animSpeed: geometry.getAttribute('aAnimSpeed')\r\n            },\r\n            dirty: {\r\n                matrices: false,\r\n                animation: false\r\n            },\r\n            meta: bundle.meta,\r\n            bundleSource: `${objectType}/${spawnType}`\r\n        };\r\n\r\n        for (let i = 0; i < capacity; i++) {\r\n            batch.attributes.clipIndex.setX(i, 0);\r\n            batch.attributes.animTime.setX(i, 0);\r\n            batch.attributes.animSpeed.setX(i, 1);\r\n        }\r\n        batch.dirty.animation = true;\r\n\r\n        this.vatBatches.set(batchKey, batch);\r\n        this._stats.batchesActive = this.vatBatches.size;\r\n  \r\n        return batch;\r\n    }\r\n\r\n    setupVATAttributes(geometry, capacity) {\r\n        const clipIndexArray = new Float32Array(capacity).fill(0);\r\n        const animTimeArray = new Float32Array(capacity).fill(0);\r\n        const animSpeedArray = new Float32Array(capacity).fill(1);\r\n\r\n        const clipIndexAttr = new THREE.InstancedBufferAttribute(clipIndexArray, 1);\r\n        const animTimeAttr = new THREE.InstancedBufferAttribute(animTimeArray, 1);\r\n        const animSpeedAttr = new THREE.InstancedBufferAttribute(animSpeedArray, 1);\r\n        \r\n        clipIndexAttr.setUsage(THREE.DynamicDrawUsage);\r\n        animTimeAttr.setUsage(THREE.DynamicDrawUsage);\r\n        animSpeedAttr.setUsage(THREE.DynamicDrawUsage);\r\n        \r\n        geometry.setAttribute('aClipIndex', clipIndexAttr);\r\n        geometry.setAttribute('aAnimTime', animTimeAttr);\r\n        geometry.setAttribute('aAnimSpeed', animSpeedAttr);\r\n    }\r\n\r\n    updateInstanceTransform(instance, pos, velocity, facing) {\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return;\r\n\r\n        const matrix = new THREE.Matrix4();\r\n        const baseScale = (batch.meta && batch.meta.baseScale) ? batch.meta.baseScale : new THREE.Vector3(1, 1, 1);\r\n        const basePosition = (batch.meta && batch.meta.basePos) ? batch.meta.basePos : new THREE.Vector3(0, 0, 0);\r\n\r\n        const position = new THREE.Vector3(\r\n            pos.x + basePosition.x,\r\n            pos.y + basePosition.y,\r\n            pos.z + basePosition.z\r\n        );\r\n        \r\n        const quaternion = new THREE.Quaternion();\r\n        const facingAngle = this.calculateFacingAngle(velocity, facing);\r\n        if (facingAngle !== null) {\r\n            const isProjectile = !facing || facing.angle === undefined;\r\n\t\t\tif(isProjectile) {\r\n                const direction = new THREE.Vector3(velocity.vx, velocity.vy, velocity.vz).normalize();\r\n                const defaultForward = new THREE.Vector3(0, 1, 0);\r\n                quaternion.setFromUnitVectors(defaultForward, direction);\r\n            } else {\r\n\t\t\t\tquaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -facingAngle + Math.PI / 2);\r\n\t\t\t}\r\n        }\r\n\r\n        const scale = new THREE.Vector3(\r\n            this.modelScale * baseScale.x,\r\n            this.modelScale * baseScale.y,\r\n            this.modelScale * baseScale.z\r\n        );\r\n\r\n        matrix.compose(position, quaternion, scale);\r\n        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);\r\n        batch.dirty.matrices = true;\r\n    }\r\n\r\n    calculateFacingAngle(velocity, facing) {\r\n        if (velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD)) {\r\n            return Math.atan2(velocity.vz, velocity.vx);\r\n        }\r\n        \r\n        if (facing && facing.angle !== undefined) {\r\n            return facing.angle;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    updateAnimations() {\r\n        const dt = this.game.state?.deltaTime;\r\n        if (!dt) return;\r\n\r\n        for (const [batchKey, batch] of this.vatBatches) {\r\n            if (batchKey.startsWith('buildings_')) continue;\r\n            const clipIndexAttr = batch.attributes.clipIndex;\r\n            const animTimeAttr = batch.attributes.animTime;\r\n            const animSpeedAttr = batch.attributes.animSpeed;\r\n            \r\n            let hasAnimationUpdates = false;\r\n\r\n            for (const [instanceIndex, entityId] of batch.entityMap) {\r\n                const currentTime = animTimeAttr.array[instanceIndex];\r\n                const speed = animSpeedAttr.array[instanceIndex];\r\n                const clipIndex = clipIndexAttr.array[instanceIndex];\r\n\r\n                if (speed > 0) {\r\n                    const clip = batch.meta.clips[clipIndex];\r\n                    const duration = clip?.duration || 1.0;\r\n                    \r\n                    const newTime = (currentTime + dt * speed) % duration;\r\n                    animTimeAttr.array[instanceIndex] = newTime;\r\n                    hasAnimationUpdates = true;\r\n                }\r\n            }\r\n\r\n            if (hasAnimationUpdates) {\r\n                animTimeAttr.needsUpdate = true;\r\n                batch.dirty.animation = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    finalizeUpdates() {\r\n        for (const batch of this.vatBatches.values()) {\r\n            if (batch.dirty.matrices) {\r\n                batch.mesh.instanceMatrix.needsUpdate = true;\r\n                batch.dirty.matrices = false;\r\n            }\r\n            \r\n            if (batch.dirty.animation) {\r\n                batch.attributes.clipIndex.needsUpdate = true;\r\n                batch.attributes.animSpeed.needsUpdate = true;\r\n                batch.dirty.animation = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    setInstanceClip(entityId, clipName, resetTime = true) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) {\r\n            console.warn(`[RenderSystem] No instance found for entity ${entityId}`);\r\n            return false;\r\n        }\r\n\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) {\r\n            console.warn(`[RenderSystem] No batch found for key ${instance.batchKey}`);\r\n            return false;\r\n        }\r\n\r\n        const clipIndex = batch.meta.clipIndexByName[clipName];\r\n        if (clipIndex === undefined) {\r\n            console.warn(`[RenderSystem] Clip '${clipName}' not found in batch ${instance.batchKey}.`);\r\n            console.warn(`Available:`, Object.keys(batch.meta.clipIndexByName));\r\n            console.warn(`  - Batch meta clips array:`, batch.meta.clips?.map(c => c.name || 'unnamed'));\r\n            console.warn(`  - Bundle source:`, batch.bundleSource || 'unknown');\r\n            return false;\r\n        }\r\n\r\n        const currentEntity = batch.entityMap.get(instance.instanceIndex);\r\n        \r\n        if (currentEntity !== entityId) {\r\n            console.error(`[RenderSystem] SLOT CORRUPTION! Slot ${instance.instanceIndex} maps to ${currentEntity} but trying to write for ${entityId}`);\r\n            \r\n            let correctSlot = -1;\r\n            for (const [slot, mappedEntityId] of batch.entityMap.entries()) {\r\n                if (mappedEntityId === entityId) {\r\n                    correctSlot = slot;\r\n                    break;\r\n                }\r\n            }\r\n            if (correctSlot !== -1) {\r\n                console.warn(`[RenderSystem] RECOVERY: Found correct slot ${correctSlot} for entity ${entityId}`);\r\n                instance.instanceIndex = correctSlot;\r\n                this.entityToInstance.set(entityId, instance);\r\n            } else {\r\n                console.error(`[RenderSystem] CORRUPTION: Entity ${entityId} not found in any slot!`);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        batch.attributes.clipIndex.setX(instance.instanceIndex, clipIndex);\r\n        batch.attributes.clipIndex.array[instance.instanceIndex] = clipIndex;\r\n        \r\n        if (resetTime) {\r\n            batch.attributes.animTime.setX(instance.instanceIndex, 0);\r\n            batch.attributes.animTime.array[instance.instanceIndex] = 0;\r\n        }\r\n        batch.dirty.animation = true;\r\n\r\n        const verifyClipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];\r\n  \r\n        if (verifyClipIndex !== clipIndex) {\r\n            console.error(`[RenderSystem] WRITE FAILED! Expected ${clipIndex} but got ${verifyClipIndex}`);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    setInstanceSpeed(entityId, speed) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) return false;\r\n\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return false;\r\n\r\n        batch.attributes.animSpeed.setX(instance.instanceIndex, speed);\r\n        batch.dirty.animation = true;\r\n    \r\n        return true;\r\n    }\r\n\r\n    setInstanceAnimationTime(entityId, time) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) return false;\r\n\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return false;\r\n\r\n        batch.attributes.animTime.setX(instance.instanceIndex, time);\r\n        batch.attributes.animTime.array[instance.instanceIndex] = time;\r\n        batch.dirty.animation = true;\r\n\r\n        return true;\r\n    }\r\n\r\n    getEntityAnimationState(entityId) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) return null;\r\n\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return null;\r\n\r\n        try {\r\n            const clipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];\r\n            const animTime = batch.attributes.animTime.array[instance.instanceIndex];\r\n            const animSpeed = batch.attributes.animSpeed.array[instance.instanceIndex];\r\n\r\n            if (clipIndex === undefined || clipIndex === null) return null;\r\n\r\n            const clipName = Object.keys(batch.meta.clipIndexByName).find(\r\n                name => batch.meta.clipIndexByName[name] === clipIndex\r\n            );\r\n\r\n            return {\r\n                clipName,\r\n                clipIndex,\r\n                animTime,\r\n                animSpeed,\r\n                clipDuration: batch.meta.clips[clipIndex]?.duration || 1.0\r\n            };\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    cleanupRemovedEntities(currentEntities) {\r\n        const toRemove = [];\r\n        \r\n        for (const [entityId, instance] of this.entityToInstance) {\r\n            if (!currentEntities.has(entityId)) {\r\n                toRemove.push(entityId);\r\n            }\r\n        }\r\n\r\n        toRemove.forEach(entityId => {\r\n            this.removeInstance(entityId);\r\n        });\r\n    }\r\n\r\n    removeInstance(entityId) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) return;\r\n\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return;\r\n\r\n        const mappedEntity = batch.entityMap.get(instance.instanceIndex);\r\n        if (mappedEntity !== entityId) {\r\n            console.error(`[RenderSystem] CORRUPTION DETECTED! Instance ${instance.instanceIndex} maps to ${mappedEntity} but trying to remove ${entityId}`);\r\n        }\r\n\r\n        batch.entityMap.delete(instance.instanceIndex);\r\n        this.entityToInstance.delete(entityId);\r\n\r\n        const matrix = new THREE.Matrix4();\r\n        matrix.scale(new THREE.Vector3(0, 0, 0));\r\n        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);\r\n        batch.dirty.matrices = true;\r\n\r\n        batch.attributes.clipIndex.setX(instance.instanceIndex, 0);\r\n        batch.attributes.animTime.setX(instance.instanceIndex, 0);\r\n        batch.attributes.animSpeed.setX(instance.instanceIndex, 0);\r\n        \r\n        batch.attributes.clipIndex.array[instance.instanceIndex] = 0;\r\n        batch.attributes.animTime.array[instance.instanceIndex] = 0;\r\n        batch.attributes.animSpeed.array[instance.instanceIndex] = 0;\r\n        \r\n        batch.dirty.animation = true;\r\n\r\n        this._stats.instancesRemoved++;\r\n    }\r\n\r\n    isInstanced(entityId) {\r\n        return this.entityToInstance.has(entityId);\r\n    }\r\n\r\n    getBatchInfo(objectType, spawnType) {\r\n        const batchKey = `${objectType}_${spawnType}`;\r\n        const batch = this.vatBatches.get(batchKey);\r\n        if (!batch) return null;\r\n\r\n        return {\r\n            batchKey,\r\n            capacity: batch.capacity,\r\n            count: batch.count,\r\n            activeInstances: batch.entityMap.size,\r\n            availableClips: Object.keys(batch.meta.clipIndexByName)\r\n        };\r\n    }\r\n\r\n    dumpBatches() {\r\n        const batches = [];\r\n        for (const [key, batch] of this.vatBatches) {\r\n            batches.push({\r\n                key,\r\n                capacity: batch.capacity,\r\n                count: batch.count,\r\n                activeInstances: batch.entityMap.size,\r\n                clips: Object.keys(batch.meta.clipIndexByName),\r\n                entityMappings: Array.from(batch.entityMap.entries())\r\n            });\r\n        }\r\n        return batches;\r\n    }\r\n\r\n    dumpInstances() {\r\n        const instances = [];\r\n        for (const [entityId, instance] of this.entityToInstance) {\r\n            const state = this.getEntityAnimationState(entityId);\r\n            instances.push({\r\n                entityId,\r\n                batchKey: instance.batchKey,\r\n                instanceIndex: instance.instanceIndex,\r\n                animationState: state\r\n            });\r\n        }\r\n        return instances;\r\n    }\r\n\r\n    entityDestroyed(entityId) {\r\n        this.removeInstance(entityId);\r\n    }\r\n\r\n    isEnemy(teamComp) {\r\n        const myTeam = this.game?.state?.mySide;\r\n        if (!teamComp || myTeam == null) return false;\r\n        return teamComp.team !== myTeam && teamComp.team !== \"neutral\";\r\n    }\r\n\r\n\r\n    hideEntityInstance(entityId) {\r\n        const instance = this.entityToInstance.get(entityId);\r\n        if (!instance) return;\r\n        const batch = this.vatBatches.get(instance.batchKey);\r\n        if (!batch) return;\r\n\r\n        const m = new THREE.Matrix4();\r\n        m.scale(new THREE.Vector3(0, 0, 0));\r\n        batch.mesh.setMatrixAt(instance.instanceIndex, m);\r\n        batch.dirty.matrices = true;\r\n\r\n        this.hiddenEntities.add(entityId);\r\n    }\r\n\r\n    showEntityInstance(entityId) {\r\n        this.hiddenEntities.delete(entityId);\r\n    }\r\n\r\n    destroy() {\r\n        for (const batch of this.vatBatches.values()) {\r\n            if (batch.mesh) {\r\n                this.game.scene.remove(batch.mesh);\r\n                batch.mesh.geometry?.dispose();\r\n                batch.mesh.material?.dispose();\r\n            }\r\n        }\r\n        \r\n        this.vatBatches.clear();\r\n        this.entityToInstance.clear();\r\n        this.batchCreationPromises.clear();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/RenderSystem.js",
        "fileName": "RenderSystem"
      },
      "SelectedUnitSystem": {
        "script": "class SelectedUnitSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.selectedUnitSystem = this;\r\n        this.canvas = this.game.canvas;\r\n        \r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        // Selection circle configuration\r\n        this.CIRCLE_RADIUS = 25;\r\n        this.CIRCLE_SEGMENTS = 32;\r\n        this.CIRCLE_THICKNESS = 2;\r\n        this.CIRCLE_COLOR = 0x00ff00; // Green selection color\r\n        this.CIRCLE_OFFSET_Y = 1;   // Slightly above ground to prevent z-fighting\r\n        \r\n        // Track selection circles\r\n        this.selectionCircles = new Map(); // entityId -> { circle, group, lastPosition }\r\n        \r\n        // Currently highlighted units\r\n        this.highlightedUnits = new Set();\r\n        \r\n        // Box selection state\r\n        this.boxSelection = {\r\n            active: false,\r\n            startX: 0,\r\n            startY: 0,\r\n            currentX: 0,\r\n            currentY: 0,\r\n            element: null\r\n        };\r\n        \r\n        // Selection mode tracking\r\n        this.selectedUnitIds = new Set(); // Track multiple selected squads\r\n        \r\n        this.currentSelectedIndex = 0;\r\n        // Initialize flag\r\n        this.initialized = false;\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('getSelectedSquads', this.getSelectedSquads.bind(this));\r\n    }\r\n\r\n    initialize() {\r\n        if (this.initialized || !this.game.scene) return;\r\n        \r\n        this.initialized = true;\r\n        this.createBoxSelectionElement();\r\n        this.setupBoxSelectionListeners();\r\n        \r\n        const unitPortrait = document.getElementById('unitPortrait');   \r\n        unitPortrait.addEventListener('click', () => {\r\n            if(this.game.cameraControlSystem) {\r\n                if(this.game.state.selectedEntity.entityId){\r\n                    const pos = this.game.getComponent(this.game.state.selectedEntity.entityId, this.game.componentManager.getComponentTypes().POSITION);\r\n                    if(pos){\r\n                        this.game.gameManager.call('cameraLookAt', pos.x, pos.z);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    createBoxSelectionElement() {\r\n        // Create the visual selection box element\r\n        const boxElement = document.createElement('div');\r\n        boxElement.id = 'unitSelectionBox';\r\n        boxElement.style.cssText = `\r\n            position: absolute;\r\n            border: 2px solid rgba(0, 255, 0, 0.8);\r\n            background: rgba(0, 255, 0, 0.1);\r\n            pointer-events: none;\r\n            display: none;\r\n            z-index: 10000;\r\n        `;\r\n        document.body.appendChild(boxElement);\r\n        this.boxSelection.element = boxElement;\r\n    }\r\n    \r\n    setupBoxSelectionListeners() {\r\n        // Mouse down - start box selection\r\n        this.canvas.addEventListener('mousedown', (event) => {\r\n            // Only left click, and not clicking on UI elements\r\n            if (event.button !== 0) return;\r\n            \r\n            const rect = this.canvas.getBoundingClientRect();\r\n            this.boxSelection.startX = event.clientX;\r\n            this.boxSelection.startY = event.clientY;\r\n            this.boxSelection.currentX = event.clientX;\r\n            this.boxSelection.currentY = event.clientY;\r\n            this.boxSelection.active = true;\r\n            \r\n            // Don't show box immediately - wait for drag\r\n        });\r\n        \r\n        // Mouse move - update box selection\r\n        this.canvas.addEventListener('mousemove', (event) => {\r\n            if (!this.boxSelection.active) return;\r\n            \r\n            this.boxSelection.currentX = event.clientX;\r\n            this.boxSelection.currentY = event.clientY;\r\n            \r\n            // Calculate distance dragged\r\n            const dx = this.boxSelection.currentX - this.boxSelection.startX;\r\n            const dy = this.boxSelection.currentY - this.boxSelection.startY;\r\n            const distance = Math.sqrt(dx * dx + dy * dy);\r\n            \r\n            // Only show box if dragged more than 5 pixels (prevents accidental box on click)\r\n            if (distance > 5) {\r\n                this.updateBoxSelectionVisual();\r\n            }\r\n        });\r\n        \r\n        // Mouse up - complete box selection\r\n        this.canvas.addEventListener('mouseup', (event) => {\r\n            if (!this.boxSelection.active) return;\r\n            \r\n            const dx = this.boxSelection.currentX - this.boxSelection.startX;\r\n            const dy = this.boxSelection.currentY - this.boxSelection.startY;\r\n            const distance = Math.sqrt(dx * dx + dy * dy);\r\n            \r\n            // If dragged significantly, do box selection\r\n            if (distance > 5) {\r\n                requestAnimationFrame(() => {\r\n                    this.completeBoxSelection(event);\r\n                });\r\n            } else {\r\n                // Single click selection\r\n                \r\n                requestAnimationFrame(() => {\r\n                    this.checkUnitSelectionClick(event);\r\n                });\r\n            }\r\n            \r\n            // Reset box selection state\r\n            this.boxSelection.active = false;\r\n            this.boxSelection.element.style.display = 'none';\r\n        });\r\n        \r\n        // Cancel box selection on context menu or escape\r\n        this.canvas.addEventListener('contextmenu', (event) => {\r\n            if (this.boxSelection.active) {\r\n                event.preventDefault();\r\n                this.cancelBoxSelection();\r\n            }\r\n        });\r\n        \r\n        document.addEventListener('keydown', (event) => {\r\n            if (event.key === 'Escape' && this.boxSelection.active) {\r\n                this.cancelBoxSelection();\r\n            }\r\n        });\r\n    }\r\n    \r\n    updateBoxSelectionVisual() {\r\n        const box = this.boxSelection;\r\n        const element = box.element;\r\n        \r\n        // Calculate box dimensions\r\n        const left = Math.min(box.startX, box.currentX);\r\n        const top = Math.min(box.startY, box.currentY);\r\n        const width = Math.abs(box.currentX - box.startX);\r\n        const height = Math.abs(box.currentY - box.startY);\r\n        \r\n        // Update element\r\n        element.style.left = left + 'px';\r\n        element.style.top = top + 'px';\r\n        element.style.width = width + 'px';\r\n        element.style.height = height + 'px';\r\n        element.style.display = 'block';\r\n    }\r\n        \r\n    completeBoxSelection(event) {\r\n        const box = this.boxSelection;\r\n        \r\n        // Get box boundaries in screen space (client coordinates)\r\n        const left = Math.min(box.startX, box.currentX);\r\n        const right = Math.max(box.startX, box.currentX);\r\n        const top = Math.min(box.startY, box.currentY);\r\n        const bottom = Math.max(box.startY, box.currentY);\r\n        \r\n        // Find all units within the selection box\r\n        const selectedUnits = this.getUnitsInScreenBox(left, top, right, bottom);\r\n        \r\n        // Check if shift is held for additive selection\r\n        const isAdditive = event.shiftKey;\r\n        \r\n        if (!isAdditive) {\r\n            this.selectedUnitIds.clear();\r\n        }\r\n        selectedUnits.forEach((unitId) => {\r\n            this.selectedUnitIds.add(unitId);\r\n        });\r\n        this.currentSelectedIndex = 0;\r\n        if (this.selectedUnitIds.size > 0) {\r\n            this.updateMultipleSquadSelection();\r\n        } else {            \r\n            this.deselectAll();\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    getUnitsInScreenBox(left, top, right, bottom) {\r\n        const selectedUnits = [];\r\n        const selectedBuildings = [];\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        \r\n        // Get all entities with position component\r\n        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION);\r\n        \r\n        entities.forEach(entityId => {\r\n            // Only select units on player's team\r\n            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n            if (!team) return;\r\n            \r\n            // Try multiple ways to check team\r\n            const unitTeam = team.team || team.side || team.teamId;\r\n            const myTeam = this.game.state.mySide || this.game.state.playerSide || this.game.state.team;\r\n            \r\n            if (unitTeam !== myTeam) {\r\n                return;\r\n            }\r\n            \r\n            // Get position component\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            if (!pos || !unitType) return;\r\n            \r\n            // Convert world position to screen position\r\n            const screenPos = this.worldToScreen(pos.x, pos.y, pos.z);\r\n            if (!screenPos) return;\r\n            \r\n            // Convert normalized screen coords (0-1) to client coordinates\r\n            const screenX = screenPos.x * rect.width + rect.left;\r\n            const screenY = screenPos.y * rect.height + rect.top;\r\n            \r\n            // Check if within selection box (in client coordinates)\r\n            if (screenX >= left && screenX <= right && \r\n                screenY >= top && screenY <= bottom) {\r\n                if(unitType.collection == 'units'){\r\n                    selectedUnits.push(entityId);\r\n                } else {\r\n                    selectedBuildings.push(entityId);\r\n                }\r\n            }\r\n        });\r\n        \r\n        return selectedUnits.length > 0 ? selectedUnits : selectedBuildings;\r\n    }\r\n    worldToScreen(x, y, z) {\r\n        if (!this.game.camera || !this.game.canvas) return null;\r\n        \r\n        try {\r\n            // Create a 3D vector\r\n            const vector = new THREE.Vector3(x, y, z);\r\n            \r\n            // Project to screen space\r\n            vector.project(this.game.camera);\r\n            \r\n            // Check if behind camera\r\n            if (vector.z > 1) return null;\r\n            \r\n            // Convert to screen coordinates (0 to 1 range)\r\n            // (0,0) is top-left, (1,1) is bottom-right\r\n            return {\r\n                x: (vector.x + 1) / 2,\r\n                y: (-vector.y + 1) / 2\r\n            };\r\n        } catch (error) {\r\n            console.warn('[SelectedUnitSystem] worldToScreen error:', error);\r\n            return null;\r\n        }\r\n    }\r\n    findSquadForUnit(entityId) {           \r\n        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n        return team?.placementId || null;\r\n    }\r\n    updateMultipleSquadSelection() {        \r\n        this.currentSelectedIndex = 0;\r\n        const unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];\r\n    \r\n        this.setSelectedEntity(unitId);         \r\n        this.highlightUnits(Array.from(this.selectedUnitIds)); \r\n        this.game.triggerEvent(\"onMultipleUnitsSelected\", this.selectedUnitIds);\r\n        if(this.selectedUnitIds.size > 0){\r\n            let unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];\r\n            this.game.triggerEvent(\"onUnitSelected\", unitId);\r\n        }\r\n    }\r\n    \r\n    \r\n    cancelBoxSelection() {\r\n        this.boxSelection.active = false;\r\n        this.boxSelection.element.style.display = 'none';\r\n    }\r\n\r\n    checkUnitSelectionClick(event) {\r\n        const rect = this.canvas.getBoundingClientRect();\r\n        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n        const worldPos = this.game.gameManager.call('getWorldPositionFromMouse', event, mouseX, mouseY);\r\n    \r\n        if (!worldPos) return;\r\n    \r\n        const placementId = this.getPlacementAtWorldPosition(worldPos);\r\n    \r\n        if (placementId) {\r\n            const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n            if (placement && placement.team === this.game.state.mySide) {\r\n                let entityId = placement.squadUnits[0];\r\n                // Check if shift is held for additive selection\r\n                if (event.shiftKey) {\r\n                    if (this.selectedUnitIds.has(entityId)) {\r\n                        // Deselect if already selected\r\n                        this.selectedUnitIds.delete(entityId);\r\n                    } else {\r\n                        // Add to selection\r\n                        this.selectedUnitIds.add(entityId);\r\n                    }\r\n                    this.updateMultipleSquadSelection();\r\n                } else {\r\n                    // Single selection (clear others)\r\n                    this.deselectAll();\r\n                    this.selectedUnitIds.add(entityId);\r\n                    this.selectUnit(entityId, placementId);\r\n                }\r\n            }\r\n        } else {\r\n            // Clicked on empty space - deselect all\r\n            if (!event.shiftKey) {\r\n                this.deselectAll();\r\n            }\r\n        }\r\n    }\r\n    \r\n    deselectAll() {\r\n        this.clearAllHighlights();\r\n        this.selectedUnitIds.clear();                \r\n        this.game.state.selectedEntity.entityId = null;\r\n        this.game.state.selectedEntity.collection = null;\r\n\r\n        const actionPanel = document.getElementById('actionPanel');     \r\n        if(actionPanel) {\r\n            actionPanel.innerHTML = \"\";\r\n        }\r\n\r\n        const selectedUnits = document.getElementById('selectedUnits');        \r\n        if(selectedUnits) {\r\n            selectedUnits.innerHTML = \"\";\r\n        }\r\n\r\n        const unitPortrait = document.getElementById('unitPortrait');        \r\n        if(unitPortrait){\r\n            unitPortrait.innerHTML = \"\";\r\n        }\r\n        \r\n        this.game.triggerEvent('onDeSelectAll');\r\n    }\r\n\r\n    getPlacementAtWorldPosition(worldPos) {\r\n        const clickRadius = 30;\r\n        let closestPlacementId = null;\r\n        let closestDistance = clickRadius;\r\n        \r\n        const entities = this.game.getEntitiesWith(\r\n            this.game.componentManager.getComponentTypes().POSITION,\r\n            this.game.componentManager.getComponentTypes().PLACEMENT\r\n        );\r\n        \r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);\r\n            const placement = this.game.getComponent(entityId, this.componentTypes.PLACEMENT);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            \r\n            const dx = pos.x - worldPos.x;\r\n            const dz = pos.z - worldPos.z;\r\n            let distance = Math.sqrt(dx * dx + dz * dz);\r\n            \r\n            if(unitType.size) {\r\n                distance -= unitType.size;\r\n            }\r\n                \r\n\r\n            if (distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestPlacementId = placement.placementId;\r\n            }\r\n        });\r\n        \r\n        return closestPlacementId;\r\n    }\r\n\r\n    selectUnit(entityId, placementId) {\r\n        if (!entityId) return;\r\n        \r\n        const squadData = this.game.gameManager.call('getSquadInfo', placementId);\r\n        \r\n        if (squadData) {\r\n            const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n            squadData.unitIds = placement.squadUnits;\r\n            this.setSelectedEntity(entityId);\r\n            this.highlightUnits(placement.squadUnits);              \r\n            this.game.triggerEvent(\"onUnitSelected\", entityId)\r\n        }\r\n    }\r\n\r\n    setSelectedEntity(entityId){         \r\n        const CT = this.game.componentManager.getComponentTypes();\r\n        const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);     \r\n        this.game.state.selectedEntity.entityId = entityId;\r\n        this.game.state.selectedEntity.collection = unitType.collection;      \r\n    }\r\n\r\n    update() {\r\n        // Wait for scene to be available\r\n        if (!this.game.scene || !this.game.camera) {\r\n            return;\r\n        }\r\n        \r\n        // Initialize if not done yet\r\n        if (!this.initialized) {\r\n            this.initialize();\r\n        }\r\n        \r\n        \r\n        // Update all active selection circles\r\n        this.updateSelectionCircles();\r\n        \r\n        // Clean up circles for units that no longer exist or are deselected\r\n        this.cleanupRemovedCircles();\r\n    }\r\n    \r\n    highlightUnits(unitIds) {\r\n        if (!unitIds || !Array.isArray(unitIds)) {\r\n            this.clearAllHighlights();\r\n            return;\r\n        }\r\n        \r\n        // Convert to Set for easy comparison\r\n        const newHighlightSet = new Set(unitIds);\r\n        \r\n        // Remove circles for units no longer selected\r\n        for (const entityId of this.highlightedUnits) {\r\n            if (!newHighlightSet.has(entityId)) {\r\n                this.removeSelectionCircle(entityId);\r\n            }\r\n        }\r\n        \r\n        // Add circles for newly selected units\r\n        for (const entityId of unitIds) {\r\n            if (!this.highlightedUnits.has(entityId)) {\r\n                this.createSelectionCircle(entityId);\r\n            }\r\n        }\r\n        \r\n        if(document){\r\n            const container = document.getElementById('unitPortrait');\r\n            container.innerHTML = ``;\r\n            const portrait = this.createPortrait(unitIds[this.currentSelectedIndex]);\r\n            if(portrait){\r\n                container.append(portrait);\r\n            }\r\n            const selectedUnitsContainer = document.getElementById('selectedUnits');\r\n            selectedUnitsContainer.innerHTML = ``;\r\n            \r\n            unitIds.forEach((unitId, index) => {\r\n                const selectedPortrait = this.createPortrait(unitId);\r\n                if(selectedPortrait){\r\n                    const selectedUnitIconContainer = document.createElement('div');\r\n                    if(index == this.currentSelectedIndex){                        \r\n                        selectedUnitIconContainer.classList.add('selected');\r\n                    }\r\n                    selectedUnitIconContainer.append(selectedPortrait);\r\n                    selectedUnitsContainer.append(selectedUnitIconContainer);\r\n                    selectedUnitIconContainer.addEventListener('click', () => {\r\n                        this.deselectAll();\r\n                        this.selectedUnitIds.add(unitId);\r\n                        const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);\r\n                        this.selectUnit(unitId, placement.placementId);\r\n                    });\r\n                }            \r\n            });            \r\n        }\r\n        // Update tracked set\r\n        this.highlightedUnits = newHighlightSet;\r\n        \r\n    }\r\n\r\n    createPortrait(entityId){\r\n        if(document) {\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            const icon = this.game.getCollections().icons[unitType.icon];\r\n\r\n            if(icon){\r\n                const img = document.createElement('img');\r\n                img.src = `./${icon.filePath}`;\r\n                return img;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    clearAllHighlights() {\r\n        // Remove all selection circles\r\n        for (const entityId of this.highlightedUnits) {\r\n            this.removeSelectionCircle(entityId);\r\n        }\r\n        \r\n        this.currentSelectedIndex = 0;\r\n        this.highlightedUnits.clear();\r\n    }\r\n    \r\n    createSelectionCircle(entityId) {\r\n        // Don't create if already exists\r\n        if (this.selectionCircles.has(entityId)) return;\r\n        \r\n        // Get entity position to determine size\r\n        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n        \r\n        // Determine radius based on unit type\r\n        const radius = this.getUnitRadius(entityId);\r\n        \r\n        // Create ring geometry (donut shape)\r\n        const geometry = new THREE.RingGeometry(\r\n            radius - this.CIRCLE_THICKNESS / 2,\r\n            radius + this.CIRCLE_THICKNESS / 2,\r\n            this.CIRCLE_SEGMENTS\r\n        );\r\n        \r\n        // Create material\r\n        const material = new THREE.MeshBasicMaterial({\r\n            color: this.CIRCLE_COLOR,\r\n            transparent: true,\r\n            opacity: 0.8,\r\n            side: THREE.DoubleSide\r\n        });\r\n        \r\n        // Create mesh\r\n        const circle = new THREE.Mesh(geometry, material);\r\n        circle.rotation.x = -Math.PI / 2; // Lay flat on ground\r\n        circle.renderOrder = 9998; // Render before health bars\r\n        \r\n        // Create group to hold circle\r\n        const group = new THREE.Group();\r\n        group.add(circle);\r\n        \r\n        // Add to UI scene\r\n        this.game.scene.add(group);\r\n        \r\n        // Store reference\r\n        this.selectionCircles.set(entityId, {\r\n            circle: circle,\r\n            group: group,\r\n            geometry: geometry,\r\n            material: material,\r\n            radius: radius,\r\n            lastPosition: { x: pos.x, y: pos.y, z: pos.z },\r\n            baseOpacity: 0.8\r\n        });\r\n        \r\n        console.log(`[SelectedUnitSystem] Created selection circle for entity ${entityId}`);\r\n    }\r\n    \r\n    updateSelectionCircles() {\r\n        for (const [entityId, circleData] of this.selectionCircles) {\r\n            // Check if entity still exists\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            if (!pos) {\r\n                this.removeSelectionCircle(entityId);\r\n                continue;\r\n            }\r\n            \r\n            // Update position\r\n            circleData.group.position.set(pos.x, pos.y + this.CIRCLE_OFFSET_Y, pos.z);\r\n        }\r\n    }\r\n    \r\n    getUnitRadius(entityId) {\r\n        // Try to get unit type to determine appropriate radius\r\n        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n        \r\n        if (unitType) {\r\n            const collections = this.game.getCollections?.();\r\n            const unitData = (collections && collections[unitType.collection])\r\n                ? collections[unitType.collection][unitType.id]\r\n                : null;\r\n            \r\n            if (unitData && unitData.size) {\r\n                return unitData.size + 2; // Slightly larger than unit\r\n            }\r\n        }\r\n        \r\n        // Default radius if no unit data\r\n        return this.CIRCLE_RADIUS;\r\n    }\r\n    \r\n    cleanupRemovedCircles() {\r\n        for (const [entityId] of this.selectionCircles) {\r\n            // Check if entity still exists\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            if (!pos) {\r\n                this.removeSelectionCircle(entityId);\r\n            }\r\n            \r\n            // Check if entity is still highlighted\r\n            if (!this.highlightedUnits.has(entityId)) {\r\n                this.removeSelectionCircle(entityId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    removeSelectionCircle(entityId) {\r\n        const circleData = this.selectionCircles.get(entityId);\r\n        if (!circleData) return;\r\n        \r\n        // Remove from scene\r\n        if (this.game.scene) {\r\n            this.game.scene.remove(circleData.group);\r\n        }\r\n        \r\n        // Dispose of resources\r\n        circleData.geometry.dispose();\r\n        circleData.material.dispose();\r\n        \r\n        // Remove from map\r\n        this.selectionCircles.delete(entityId);\r\n        \r\n        console.log(`[SelectedUnitSystem] Removed selection circle for entity ${entityId}`);\r\n    }\r\n    \r\n    // Configuration methods\r\n    setSelectionColor(color) {\r\n        this.CIRCLE_COLOR = color;\r\n        \r\n        // Update existing circles\r\n        for (const [_, circleData] of this.selectionCircles) {\r\n            circleData.material.color.setHex(color);\r\n        }\r\n    }\r\n    \r\n    \r\n    setCircleThickness(thickness) {\r\n        this.CIRCLE_THICKNESS = thickness;\r\n        \r\n        // Would need to recreate all circles to apply\r\n        // For now, just update the config for future circles\r\n    }\r\n    \r\n    toggleAnimation(enabled) {\r\n        if (!enabled) {\r\n            // Reset all circles to default state\r\n            for (const [_, circleData] of this.selectionCircles) {\r\n                circleData.circle.scale.set(1, 1, 1);\r\n                circleData.circle.rotation.z = 0;\r\n                circleData.material.opacity = circleData.baseOpacity;\r\n            }\r\n        }\r\n    }\r\n    \r\n    // Utility to check if a unit is currently highlighted\r\n    isHighlighted(entityId) {\r\n        return this.highlightedUnits.has(entityId);\r\n    }\r\n    \r\n    // Get all currently highlighted unit IDs\r\n    getHighlightedUnits() {\r\n        return Array.from(this.highlightedUnits);\r\n    }\r\n    \r\n    // Get all currently selected squad IDs\r\n    getSelectedSquads() {\r\n        let placementIds = new Set();\r\n        const CT = this.game.componentManager.getComponentTypes();\r\n        Array.from(this.selectedUnitIds).forEach((unitId) => {\r\n            const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);\r\n            placementIds.add(placement.placementId);\r\n        });\r\n        return [...placementIds];\r\n    }\r\n    getSelectedUnits() {\r\n        return Array.from(this.selectedUnitIds);\r\n    }\r\n\r\n    \r\n    onBattleStart() {\r\n        this.deselectAll();\r\n    }\r\n    onKeyDown(key) {\r\n        if (key === 'Escape') {\r\n            this.deselectAll();\r\n        }\r\n    }\r\n    \r\n    destroy() {\r\n        // Clean up box selection element\r\n        if (this.boxSelection.element && this.boxSelection.element.parentElement) {\r\n            this.boxSelection.element.parentElement.removeChild(this.boxSelection.element);\r\n        }\r\n        \r\n        // Clean up all selection circles\r\n        for (const [entityId] of this.selectionCircles) {\r\n            this.removeSelectionCircle(entityId);\r\n        }\r\n        \r\n        this.selectionCircles.clear();\r\n        this.highlightedUnits.clear();\r\n        this.selectedUnitIds.clear();\r\n        this.initialized = false;\r\n        \r\n        console.log('[SelectedUnitSystem] Destroyed');\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SelectedUnitSystem.js",
        "fileName": "SelectedUnitSystem"
      },
      "ServerPlacementSystem": {
        "script": "class ServerPlacementSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);  \r\n        this.game.placementSystem = this;\r\n        this.serverNetworkManager = this.engine.serverNetworkManager;  \r\n        this.playerPlacements = new Map();\r\n        this.leftPlacements = [];\r\n        this.rightPlacements = [];\r\n        this.placementReadyStates = new Map();\r\n        this.numPlayers = 2;\r\n     }\r\n\r\n    init(params) {\r\n        this.params = params || {};\r\n        this.game.gameManager.register('getPlacementsForSide', this.getPlacementsForSide.bind(this));\r\n        this.game.gameManager.register('getPlacementById', this.getPlacementById.bind(this));\r\n        this.subscribeToEvents();\r\n    }\r\n    subscribeToEvents() {\r\n        if (!this.game.serverEventManager) {\r\n            console.error('No event manager found on engine');\r\n            return;\r\n        }\r\n\r\n        // Subscribe to room management events\r\n        this.game.serverEventManager.subscribe('GET_STARTING_STATE', this.handleGetStartingState.bind(this));\r\n        this.game.serverEventManager.subscribe('SUBMIT_PLACEMENT', this.handleSubmitPlacement.bind(this));\r\n        this.game.serverEventManager.subscribe('PURCHASE_UPGRADE', this.handlePurchaseUpgrade.bind(this));\r\n        this.game.serverEventManager.subscribe('READY_FOR_BATTLE', this.handleReadyForBattle.bind(this));\r\n        this.game.serverEventManager.subscribe('LEVEL_SQUAD', this.handleLevelSquad.bind(this));\r\n        this.game.serverEventManager.subscribe('SET_SQUAD_TARGET', this.handleSetSquadTarget.bind(this));\r\n        this.game.serverEventManager.subscribe('SET_SQUAD_TARGETS', this.handleSetSquadTargets.bind(this));\r\n    \r\n    }\r\n\r\n    getPlacementById(placementId) {\r\n        // Search in player placements first\r\n        const leftPlacements = this.leftPlacements.find(placement => placement.placementId === placementId);\r\n        if (leftPlacements) {\r\n            return leftPlacements;\r\n        }\r\n        \r\n        // Search in opponent placements\r\n        const rightPlacements = this.rightPlacements.find(placement => placement.placementId === placementId);\r\n        if (rightPlacements) {\r\n            return rightPlacements;\r\n        }\r\n        \r\n        // Return null if no matching placement is found\r\n        return null;\r\n    }\r\n    getPlayerIdByPlacementId(placementId) {\r\n        // Iterate through all players and their placements\r\n        for (const [playerId, placements] of this.playerPlacements) {\r\n            // Check if any placement in this player's placements matches the placementId\r\n            const foundPlacement = placements.find(placement => placement.placementId === placementId);\r\n            if (foundPlacement) {\r\n                return playerId;\r\n            }\r\n        }\r\n        \r\n        // Return null if no matching placement is found\r\n        return null;\r\n    }\r\n    getPlacementsForSide(side){\r\n        if(side == 'left'){\r\n            return this.leftPlacements;\r\n        } else {\r\n            return this.rightPlacements;\r\n        }\r\n    }\r\n\r\n    handleGetStartingState(eventData) {\r\n        try {\r\n            const { playerId, data } = eventData;\r\n  \r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n            if (!roomId) { \r\n                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', { \r\n                    error: 'Room not found'\r\n                });\r\n                return;\r\n            }\r\n            const room = this.engine.getRoom(roomId);\r\n            const player = room.getPlayer(playerId);\r\n            // Broadcast ready state update to all players in room\r\n            if(player){\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', this.getStartingState(player));\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error('Error getting starting state:', error);\r\n            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'GOT_STARTING_STATE', { \r\n                error: 'Server error while submitting placements',\r\n                playerId: eventData.playerId,\r\n                ready: false,\r\n                received: data,\r\n                success: false\r\n            });\r\n        }\r\n    }\r\n\r\n    async handleLevelSquad(eventData){\r\n        const { playerId, data } = eventData;\r\n        const { placementId, specializationId } = data;\r\n        let playerGold = 0;\r\n        if(playerId){\r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);         \r\n            if(roomId){\r\n                const room = this.engine.getRoom(roomId);\r\n                if(room){\r\n                    const player = room.players.get(playerId);                    \r\n                    playerGold = player.stats.gold;\r\n                    console.log('got player gold', playerGold);\r\n            \r\n                    if (!this.game.gameManager.call('canAffordLevelUp', placementId, playerGold)) {\r\n                        console.log(\"not enough gold to level up\");\r\n                        this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {\r\n                            playerId: playerId,\r\n                            error: \"gold_low_error\",\r\n                            success: false\r\n                        });\r\n                        return false;\r\n                    }\r\n                    const success1 = specializationId ? this.game.gameManager.call('applySpecialization', placementId, specializationId, playerId) : true;\r\n\r\n                    await this.game.gameManager.call('levelUpSquad', placementId, null, playerId, (success) => {\r\n                        console.log('success?: ', success1, success);\r\n                        if(success1 && success){\r\n                            const levelUpCost = this.game.gameManager.call('getLevelUpCost', placementId);        \r\n                            \r\n                            player.stats.gold -= levelUpCost;\r\n                            console.log('leveled, new gold amt:', player.stats.gold);\r\n                            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {\r\n                                playerId: playerId,\r\n                                currentGold: player.stats.gold,\r\n                                success: true\r\n                            });\r\n                        }\r\n                    });\r\n           \r\n                }\r\n            }\r\n        } \r\n    }\r\n\r\n    handleSubmitPlacement(eventData) {\r\n        try {\r\n            const { playerId, data } = eventData;\r\n            const { placement, ready } = data;\r\n  \r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n            if (!roomId) { \r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', { \r\n                    error: 'Room not found'\r\n                });\r\n                return;\r\n            }\r\n            const room = this.engine.getRoom(roomId);\r\n            const player = room.getPlayer(playerId);\r\n            // Broadcast ready state update to all players in room\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', this.submitPlayerPlacement(playerId, player, placement, true));\r\n            \r\n        } catch (error) {\r\n            console.error('Error submitting placements:', error);\r\n            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'READY_FOR_BATTLE_UPDATE', { \r\n                error: 'Server error while submitting placements',\r\n                playerId: eventData.playerId,\r\n                ready: false,\r\n                received: data\r\n            });\r\n        }\r\n    }\r\n\r\n    handlePurchaseUpgrade(eventData) {\r\n        try {\r\n            const { playerId, data } = eventData;\r\n            \r\n  \r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n            if (!roomId) { \r\n                this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', { \r\n                    error: 'Room not found'\r\n                });\r\n                return;\r\n            }\r\n            const room = this.engine.getRoom(roomId);\r\n            const player = room.getPlayer(playerId);\r\n            // Broadcast ready state update to all players in room\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', this.purchaseUpgrade(playerId, player, data.data, true));\r\n            \r\n        } catch (error) {\r\n            console.error('Error purchasing upgrades:', error);\r\n            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'PURCHASED_UPGRADE', { \r\n                error: 'Server error while purchasing upgrades',\r\n                playerId: eventData.playerId,\r\n                ready: false,\r\n                received: data\r\n            });\r\n        }\r\n    }\r\n\r\n    handleSetSquadTarget(eventData) {\r\n        try {\r\n            const { playerId, data } = eventData;\r\n            const { placementId, targetPosition, meta } = data;\r\n            if(this.game.state.phase != \"placement\") {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { \r\n                    success: false\r\n                });\r\n                return;\r\n            };\r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n            if (!roomId) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { \r\n                    error: 'Room not found'\r\n                });\r\n                return;\r\n            }\r\n            \r\n            const room = this.engine.getRoom(roomId);\r\n            const player = room.getPlayer(playerId);\r\n            \r\n            if (!player) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { \r\n                    error: 'Player not found'\r\n                });\r\n                return;\r\n            }\r\n            \r\n            // Validate placement belongs to player            \r\n            const placement = this.getPlacementById(placementId);\r\n            \r\n            if (!placement) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { \r\n                    error: 'Placement not found'\r\n                });\r\n                return;\r\n            }\r\n            \r\n            // Store target position in placement data\r\n            placement.targetPosition = targetPosition;\r\n            placement.squadUnits.forEach((unitId) => {\r\n                if(targetPosition){\r\n                    let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, \"UnitOrderSystem\");\r\n                    currentOrderAI.targetPosition = targetPosition;\r\n                    currentOrderAI.path = [];\r\n                    currentOrderAI.meta = meta;\r\n                    this.game.gameManager.call('setCurrentAIController', unitId, \"UnitOrderSystem\", currentOrderAI);\r\n                }\r\n            });\r\n                    \r\n               \r\n            \r\n            // Send success response to requesting player\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { \r\n                success: true,\r\n                placementId,\r\n                targetPosition,\r\n                meta\r\n            });\r\n            \r\n            // Broadcast to other players in the room\r\n            for (const [otherPlayerId, otherPlayer] of room.players) {\r\n                if (otherPlayerId !== playerId) {\r\n                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGET_SET', {\r\n                        placementId,\r\n                        targetPosition,\r\n                        meta\r\n                    });\r\n                }\r\n            }\r\n            \r\n            console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);\r\n            \r\n        } catch (error) {\r\n            console.error('Error setting squad target:', error);\r\n            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGET_SET', { \r\n                error: 'Server error while setting squad target'\r\n            });\r\n        }\r\n    }\r\n\r\n    handleSetSquadTargets(eventData) {\r\n        try {\r\n            const { playerId, data } = eventData;\r\n            const { placementIds, targetPositions, meta } = data;\r\n            if(this.game.state.phase != \"placement\") {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { \r\n                    success: false\r\n                });\r\n                return;\r\n            };\r\n            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n            if (!roomId) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { \r\n                    error: 'Room not found'\r\n                });\r\n                return;\r\n            }\r\n            \r\n            const room = this.engine.getRoom(roomId);\r\n            const player = room.getPlayer(playerId);\r\n            \r\n            if (!player) {\r\n                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { \r\n                    error: 'Player not found'\r\n                });\r\n                return;\r\n            }\r\n            \r\n            for(let i = 0; i < placementIds.length; i++){\r\n                let placementId = placementIds[i];\r\n                let targetPosition = targetPositions[i];\r\n                // Validate placement belongs to player            \r\n                const placement = this.getPlacementById(placementId);\r\n                \r\n                if (!placement) {\r\n                    console.log(placementId, 'not found');\r\n                    this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { \r\n                        error: 'Placement not found'\r\n                    });\r\n                    return;\r\n                }\r\n                \r\n                // Store target position in placement data\r\n                placement.targetPosition = targetPosition;\r\n                placement.squadUnits.forEach((unitId) => {\r\n                    if(targetPosition){\r\n                        let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, \"UnitOrderSystem\");\r\n                        currentOrderAI.targetPosition = targetPosition;\r\n                        currentOrderAI.path = [];\r\n                        currentOrderAI.meta = meta;\r\n                        this.game.gameManager.call('setCurrentAIController', unitId, \"UnitOrderSystem\", currentOrderAI);\r\n                    }\r\n                });\r\n                        \r\n\r\n                \r\n                console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);\r\n            }\r\n\r\n                        // Send success response to requesting player\r\n            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { \r\n                success: true\r\n            });\r\n            \r\n            // Broadcast to other players in the room\r\n            for (const [otherPlayerId, otherPlayer] of room.players) {\r\n                if (otherPlayerId !== playerId) {\r\n                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGETS_SET', {\r\n                        placementIds,\r\n                        targetPositions,\r\n                        meta\r\n                    });\r\n                }\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error('Error setting squad target:', error);\r\n            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGETS_SET', { \r\n                error: 'Server error while setting squad target'\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    handleReadyForBattle(eventData) {\r\n        const { playerId, data } = eventData; \r\n        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);\r\n        if (!roomId) { \r\n            this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { \r\n                error: 'Room not found'\r\n            });\r\n            return;\r\n        }\r\n        const room = this.engine.getRoom(roomId);\r\n          \r\n        const player = room.getPlayer(playerId);\r\n        // Update ready state\r\n        player.ready = true;\r\n        this.placementReadyStates.set(playerId, true);\r\n        \r\n        this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { success: true });\r\n            \r\n        // Check if all players are ready and start battle if so\r\n        if (this.areAllPlayersReady() && this.game.state.phase === 'placement') {\r\n\r\n            const gameState = room.getGameState();\r\n            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       \r\n                gameState: gameState,\r\n                allReady: true\r\n            });\r\n            this.placementReadyStates.clear();\r\n            // Small delay to ensure clients receive the ready update\r\n\r\n            this.game.resetCurrentTime();\r\n            this.applyTargetPositions();\r\n            this.game.desyncDebugger.enabled = true;\r\n            this.game.desyncDebugger.displaySync(true);\r\n            this.resetAI();\r\n            this.game.gameManager.call('startBattle', room);\r\n        } else {\r\n            const gameState = room.getGameState();\r\n            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       \r\n                gameState: gameState,\r\n                allReady: false\r\n            });\r\n        }\r\n\r\n    }\r\n    \r\n    resetAI() {\r\n        const componentTypes = this.game.componentManager.getComponentTypes();            \r\n        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      \r\n        AIEntities.forEach((entityId) => {\r\n            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);\r\n            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);\r\n            combat.lastAttack = 0;\r\n            aiState.aiBehavior = {};\r\n        });\r\n    }\r\n\r\n    applyTargetPositions() {\r\n     //   console.log('APPLY TARGET POSITIONS');\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        for (const [playerId, placements] of this.playerPlacements) {\r\n            placements.forEach((placement) => {     \r\n                const targetPosition = placement.targetPosition;         \r\n                placement.squadUnits.forEach(entityId => {\r\n                    const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);\r\n                    const position = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n                    if (aiState && position) {\r\n                        \r\n                        if(targetPosition){\r\n                            const currentAIController = this.game.gameManager.call('getCurrentAIControllerId', entityId);\r\n\r\n                            if(!currentAIController || currentAIController == \"UnitOrderSystem\"){\r\n                                const dx = position.x - targetPosition.x;\r\n                                const dz = position.z - targetPosition.z;\r\n                                const distSq = dx * dx + dz * dz;\r\n                                const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;\r\n                                const threshold = placementGridSize * 0.5;\r\n\r\n                                if (distSq <= threshold * threshold) {\r\n                                    this.game.gameManager.call('removeCurrentAIController', entityId);\r\n                                    placement.targetPosition = null;\r\n                                } else {\r\n                                    let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, \"UnitOrderSystem\");\r\n                                    currentOrderAI.targetPosition = targetPosition;\r\n                                    currentOrderAI.path = [];\r\n                                    this.game.gameManager.call('setCurrentAIController', entityId, \"UnitOrderSystem\", currentOrderAI);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    areAllPlayersReady() {\r\n        let states = [...this.placementReadyStates.values()]\r\n        return states.length == this.numPlayers && states.every(ready => ready === true);\r\n    }\r\n\r\n\r\n    submitPlayerPlacement(playerId, player, placement) {\r\n        // console.log(`=== SUBMIT PLACEMENT DEBUG ===`);\r\n        // console.log(`Player ID: ${playerId}`);\r\n        // console.log(`Room ID: ${this.game.room?.id || 'NO ROOM'}`);\r\n        // console.log(`Game phase: ${this.game.state.phase}`);\r\n        // console.log(`================================`);\r\n    \r\n        if (this.game.state.phase !== 'placement') {\r\n            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };\r\n        }\r\n        \r\n        // Validate placements if provided\r\n        if ( !this.validatePlacement(placement, player)) {\r\n            return { success: false, error: 'Invalid placement' };\r\n        }\r\n\r\n\r\n        // Deduct gold only for new units\r\n        if (placement.unitType?.value > 0 && !placement.isStartingState) {\r\n            player.stats.gold -= placement.unitType?.value;\r\n        }            \r\n        \r\n        \r\n        // Store placements\r\n        let playerPlacements = this.playerPlacements.get(playerId);\r\n        if(playerPlacements){\r\n            playerPlacements.push(placement);\r\n        } else {\r\n            playerPlacements = [placement];\r\n        }\r\n        this.playerPlacements.set(playerId, playerPlacements);\r\n\r\n        if(player.stats.side == 'left'){\r\n            this.leftPlacements = this.playerPlacements.get(playerId);\r\n        } else {\r\n            this.rightPlacements = this.playerPlacements.get(playerId);\r\n        }\r\n\r\n        const result = this.game.gameManager.call('spawnSquadFromPlacement', playerId, placement);\r\n\r\n        if(result.success && result.squad){\r\n            let squadUnits = [];\r\n            result.squad.squadUnits.forEach((entityId) => {\r\n                squadUnits.push(entityId);\r\n            })\r\n            placement.squadUnits = squadUnits;\r\n            if (placement.placementId) {\r\n                this.game.gameManager.call('initializeSquad',\r\n                    placement.placementId,\r\n                    placement.unitType,\r\n                    placement.squadUnits,\r\n                    placement.team\r\n                );\r\n            }\r\n            if (placement.peasantInfo && placement.collection === 'buildings') {\r\n                const peasantInfo = placement.peasantInfo;\r\n                const peasantId = peasantInfo.peasantId;\r\n                const entityId = placement.squadUnits[0];\r\n\r\n                // Get the build ability from the peasant's abilities\r\n\r\n                const peasantAbilities = this.game.gameManager.call('getEntityAbilities', peasantId);\r\n                if (peasantAbilities) {\r\n                    //console.log(\"peasantAbilities\", peasantAbilities);\r\n                    const buildAbility = peasantAbilities.find(a => a.id === 'build');\r\n                    if (buildAbility) {\r\n                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);\r\n                    }\r\n                }\r\n                \r\n                \r\n                // Clear the flag (only once for first building entity)\r\n                this.game.state.peasantBuildingPlacement = null;\r\n            }\r\n        }\r\n\r\n\r\n        return { success: result.success };\r\n    }\r\n\r\n\r\n    onBattleEnd() {        \r\n        this.removeDeadSquadsAfterRound();\r\n       \r\n        this.game.desyncDebugger.displaySync(true);\r\n        this.game.desyncDebugger.enabled = false;\r\n    }\r\n    \r\n    removeDeadSquadsAfterRound() {\r\n        if (!this.game.componentManager) return;\r\n\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n\r\n        this.playerPlacements.forEach((placements, playerId) => {\r\n            const survivingPlacements = placements.filter(placement => {\r\n                if (!placement.experience?.unitIds || placement.experience.unitIds.length === 0) {\r\n                    this.cleanupDeadSquad(placement);\r\n                    return false;\r\n                }\r\n\r\n                const aliveUnits = placement.experience.unitIds.filter(entityId => {\r\n                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);\r\n                    const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);\r\n                    if(buildingState) return true;\r\n                    return health && health.current > 0 && (!deathState || !deathState.isDying);\r\n                });\r\n\r\n                if (aliveUnits.length === 0) {\r\n                    this.cleanupDeadSquad(placement);\r\n                    return false;\r\n                }\r\n\r\n                placement.experience.unitIds = aliveUnits;\r\n                return true;\r\n            });\r\n\r\n            this.playerPlacements.set(playerId, survivingPlacements);\r\n        });\r\n    }\r\n\r\n    cleanupDeadSquad(placement) {\r\n        if (placement.placementId) {\r\n            this.game.gameManager.call('releaseGridCells', placement.placementId);\r\n            this.game.gameManager.call('removeSquad', placement.placementId);\r\n        }\r\n\r\n       // console.log(`Squad eliminated: ${placement.unitType?.title || placement.placementId}`);\r\n    }\r\n\r\n\r\n    validatePlacement(placement, player) {\r\n       \r\n        if(placement.isStartingState) return true;\r\n        // Calculate cost of only NEW units\r\n        const newUnitCost =  placement.unitType?.value;\r\n        \r\n        \r\n        if (newUnitCost > player.stats.gold) {\r\n            console.log(`Player ${player.id} insufficient gold: ${newUnitCost} > ${player.stats.gold}`);\r\n            return false;\r\n        }\r\n        if (this.game.gameManager.has('canAffordSupply') && !this.game.gameManager.call('canAffordSupply', player.stats.side, placement.unitType)) {\r\n            console.log(`Player ${player.id} insufficient supply for unit: ${placement.unitType.id}`);\r\n            return false;\r\n        }\r\n        if (!placement.gridPosition || !placement.unitType) {\r\n            console.log(`Player ${player.id} invalid placement data:`, placement);\r\n            return false;\r\n        }\r\n        \r\n        // Validate side placement - no mirroring, direct side enforcement\r\n        const squadData = this.game.squadManager.getSquadData(placement.unitType);\r\n        const cells = this.game.squadManager.getSquadCells(placement.gridPosition, squadData);\r\n        if(!this.game.gameManager.call('isValidGridPlacement', cells, player.stats.side)){\r\n            console.log('Invalid Placement', placement);\r\n            for (const cell of cells) {\r\n                const key = `${cell.x},${cell.z}`;\r\n                const cellState = this.game.gridSystem.state.get(key);\r\n                if (cellState && cellState.occupied) {\r\n                    console.log('occupied:', cell, cellState);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n    \r\n        \r\n        return true;\r\n    }\r\n    clearAllPlacements(){\r\n\r\n        this.playerPlacements.keys().forEach((playerId) => {\r\n            this.clearPlayerPlacements(playerId);\r\n        });\r\n\r\n        this.playerPlacements = new Map();\r\n        this.leftPlacements = new Map();\r\n        this.rightPlacements = new Map();\r\n        this.placementReadyStates = new Map();  \r\n    }\r\n    clearPlayerPlacements(playerId) {\r\n        try {\r\n            // Get player's placements\r\n            const placements = this.playerPlacements.get(playerId) || [];\r\n            \r\n            // Remove entities created by this player's placements\r\n            placements.forEach(placement => {\r\n                if (placement.squadUnits) {\r\n                    placement.squadUnits.forEach(entityId => {\r\n                        try {\r\n                            if (this.game.destroyEntity) {\r\n                                this.game.destroyEntity(entityId);\r\n                            }\r\n                        } catch (error) {\r\n                            console.warn(`Error destroying entity ${entityId}:`, error);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Free grid cells\r\n                if (placement.placementId) {\r\n                    this.game.gameManager.call('releaseGridCells', placement.placementId);\r\n                }\r\n            });\r\n            \r\n            // Clear from maps\r\n            this.playerPlacements.delete(playerId);\r\n            \r\n            // Clear from undo stack if it's this player\r\n            if (this.undoStack) {\r\n                this.undoStack = this.undoStack.filter(undo => undo.playerId !== playerId);\r\n            }\r\n            \r\n            console.log(`Cleared placements for player ${playerId}`);\r\n            \r\n        } catch (error) {\r\n            console.error(`Error clearing placements for player ${playerId}:`, error);\r\n        }\r\n    }\r\n\r\n    saveBuilding(entityId, team, gridPosition, unitType) {\r\n        console.log(`=== Purchase Building DEBUG ===`);     \r\n        console.log(`Data received:`, entityId, team, unitType);\r\n\r\n        if (unitType.id === 'goldMine') {\r\n            // Convert footprint (terrain grid units) to placement grid cells\r\n            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 2;\r\n            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 2;\r\n            const gridWidth = footprintWidth * 2;\r\n            const gridHeight = footprintHeight * 2;\r\n\r\n            const result = this.game.gameManager.call('buildGoldMine', entityId, team, gridPosition, gridWidth, gridHeight);\r\n            if (!result.success) {\r\n                return result;\r\n            }\r\n        }            \r\n        console.log(`SUCCESS`);\r\n        console.log(`================================`);\r\n        return { success: true };\r\n    }\r\n\r\n    purchaseUpgrade(playerId, player, data) {\r\n        console.log(`=== Purchase Upgrade DEBUG ===`);       \r\n        console.log(`Data received:`, data);\r\n    \r\n        if (this.game.state.phase !== 'placement') {\r\n            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };\r\n        }\r\n\r\n        const upgrade = this.game.getCollections().upgrades[data.upgradeId];\r\n        if(upgrade?.value <= player.stats.gold){\r\n            player.stats.gold -= upgrade.value;\r\n            if(!this.game.state.teams){\r\n                this.game.state.teams = {};\r\n            }\r\n            if(!this.game.state.teams[player.stats.side]) {\r\n                this.game.state.teams[player.stats.side] = {};\r\n            } \r\n            if(!this.game.state.teams[player.stats.side].effects) {\r\n                this.game.state.teams[player.stats.side].effects = {};\r\n            }\r\n            upgrade.effects.forEach((effectId) => {\r\n                const effect = this.game.getCollections().effects[effectId];\r\n                this.game.state.teams[player.stats.side].effects[effectId] = effect;\r\n            })\r\n            \r\n            console.log(`SUCCESS`);\r\n            console.log(`================================`);\r\n            return { success: true };\r\n        }\r\n\r\n        console.log(`ERROR`);    \r\n        console.log(`================================`);\r\n        \r\n        return { success: false, error: \"Not enough gold.\" };\r\n    }\r\n\r\n    getStartingState(player){\r\n\r\n        let startPosition = { x: 10, z: 10 };\r\n        if(player.stats.side == 'right'){\r\n            startPosition = { x: 116, z: 116 };\r\n        }\r\n        \r\n        // Find nearest unclaimed gold vein\r\n        let nearestGoldVeinLocation = null;\r\n        let minDistance = Infinity;\r\n\r\n        const goldVeinLocations = this.game.gameManager.call('getGoldVeinLocations');\r\n        if (goldVeinLocations) {\r\n            goldVeinLocations.forEach(vein => {\r\n                // Skip if already claimed\r\n                if (vein.claimed) return;\r\n                \r\n                // Calculate distance from start position to vein\r\n                const dx = vein.gridPos.x - startPosition.x;\r\n                const dz = vein.gridPos.z - startPosition.z;\r\n                const distance = Math.sqrt(dx * dx + dz * dz);\r\n                \r\n                if (distance < minDistance) {\r\n                    minDistance = distance;\r\n                    nearestGoldVeinLocation = vein.gridPos;\r\n                }\r\n            });\r\n        }\r\n        \r\n        \r\n        // Calculate peasant positions on the same side as gold mine\r\n        // TownHall is 2x2, so it occupies a 2x2 area centered at startPosition\r\n        const dx = nearestGoldVeinLocation.x - startPosition.x;\r\n        const dz = nearestGoldVeinLocation.z - startPosition.z;\r\n        \r\n        let peasantPositions = [];\r\n        \r\n        // Determine which side the gold mine is on and place peasants accordingly\r\n        if (Math.abs(dx) > Math.abs(dz)) {\r\n            // Gold mine is more to the east or west\r\n            if (dx > 0) {\r\n                // Gold mine is to the EAST, place peasants on east side\r\n                // TownHall occupies x to x+1, so peasants start at x+2\r\n                peasantPositions = [\r\n                    { x: startPosition.x + 2, z: startPosition.z - 1 },\r\n                    { x: startPosition.x + 2, z: startPosition.z },\r\n                    { x: startPosition.x + 2, z: startPosition.z + 1 },\r\n                    { x: startPosition.x + 2, z: startPosition.z + 2 }\r\n                ];\r\n            } else {\r\n                // Gold mine is to the WEST, place peasants on west side\r\n                // TownHall occupies x-1 to x, so peasants start at x-2\r\n                peasantPositions = [\r\n                    { x: startPosition.x - 2, z: startPosition.z - 1 },\r\n                    { x: startPosition.x - 2, z: startPosition.z },\r\n                    { x: startPosition.x - 2, z: startPosition.z + 1 },\r\n                    { x: startPosition.x - 2, z: startPosition.z + 2 }\r\n                ];\r\n            }\r\n        } else {\r\n            // Gold mine is more to the north or south\r\n            if (dz > 0) {\r\n                // Gold mine is to the SOUTH, place peasants on south side\r\n                // TownHall occupies z to z+1, so peasants start at z+2\r\n                peasantPositions = [\r\n                    { x: startPosition.x - 1, z: startPosition.z + 2 },\r\n                    { x: startPosition.x, z: startPosition.z + 2 },\r\n                    { x: startPosition.x + 1, z: startPosition.z + 2 },\r\n                    { x: startPosition.x + 2, z: startPosition.z + 2 }\r\n                ];\r\n            } else {\r\n                // Gold mine is to the NORTH, place peasants on north side\r\n                // TownHall occupies z-1 to z, so peasants start at z-2\r\n                peasantPositions = [\r\n                    { x: startPosition.x - 1, z: startPosition.z - 2 },\r\n                    { x: startPosition.x, z: startPosition.z - 2 },\r\n                    { x: startPosition.x + 1, z: startPosition.z - 2 },\r\n                    { x: startPosition.x + 2, z: startPosition.z - 2 }\r\n                ];\r\n            }\r\n        }\r\n        \r\n        const startingUnits = [\r\n            {\r\n                type: \"townHall\",\r\n                collection: \"buildings\",\r\n                position: startPosition\r\n            },\r\n            {\r\n                type: \"goldMine\",\r\n                collection: \"buildings\",\r\n                position: nearestGoldVeinLocation\r\n            },\r\n            {\r\n                type: \"peasant\",\r\n                collection: \"units\",\r\n                position: peasantPositions[0]\r\n            },\r\n            {\r\n                type: \"peasant\",\r\n                collection: \"units\",\r\n                position: peasantPositions[1]\r\n            },\r\n            {\r\n                type: \"peasant\",\r\n                collection: \"units\",\r\n                position: peasantPositions[2]\r\n            },\r\n            {\r\n                type: \"peasant\",\r\n                collection: \"units\",\r\n                position: peasantPositions[3]\r\n            }\r\n        ];\r\n\r\n        const pitch = 35.264 * Math.PI / 180;\r\n        const yaw = 135 * Math.PI / 180;\r\n        const distance = 10240;\r\n\r\n        const cdx = Math.sin(yaw) * Math.cos(pitch);\r\n        const cdz = Math.cos(yaw) * Math.cos(pitch);\r\n\r\n\r\n\r\n        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', startPosition.x, startPosition.z);\r\n\r\n        const cameraPosition = {\r\n            x: worldPos.x - cdx * distance,\r\n            y: distance,\r\n            z: worldPos.z - cdz * distance\r\n        };\r\n\r\n        const lookAt = {\r\n            x: worldPos.x,\r\n            y: 0, \r\n            z: worldPos.z\r\n        };\r\n\r\n        return {\r\n            success: true,\r\n            startingUnits,\r\n            camera: {\r\n                position: cameraPosition,\r\n                lookAt\r\n            }\r\n        };\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerPlacementSystem.js",
        "fileName": "ServerPlacementSystem"
      },
      "ShopSystem": {
        "script": "class ShopSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.shopSystem = this;\r\n        \r\n        this.ownedBuildings = new Map();\r\n        this.buildingUpgrades = new Map();\r\n        this.buildingProductionProgress = new Map();\r\n        this.game.state.selectedEntity = {\r\n            \"collection\": null,\r\n            \"entityId\": null\r\n        };\r\n        this.townHallLevel = 0;\r\n        \r\n        this.lastExperienceUpdate = 0;\r\n        this.uiEnhancements = new GUTS.FantasyUIEnhancements(game);\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('addBuilding', this.addBuilding.bind(this));\r\n        this.game.gameManager.register('resetShop', this.reset.bind(this));\r\n        this.game.gameManager.register('updateSquadExperience', this.updateSquadExperience.bind(this));\r\n    }\r\n\r\n    updateSquadExperience() {\r\n        this.createExperiencePanel();\r\n    }\r\n\r\n    clearActionPanel() {\r\n        const container = document.getElementById('actionPanel');\r\n        if (!container) return;\r\n        container.innerHTML = '';\r\n    }\r\n\r\n    clearSelectedEntity() {    \r\n        this.game.state.selectedEntity.entityId = null;\r\n        this.game.state.selectedEntity.collection = null;\r\n    }\r\n    onUnitSelected(entityId){\r\n        const CT = this.game.componentManager.getComponentTypes();\r\n        const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);\r\n        if(unitType.collection == \"buildings\") {\r\n            const placement = this.game.getComponent(entityId, CT.PLACEMENT);        \r\n            this.renderBuildingActions(placement);\r\n        }\r\n    }\r\n    renderBuildingActions(placement) {\r\n        const building = placement.unitType;\r\n        const container = document.getElementById('actionPanel');  \r\n        if (!container) return;\r\n        container.innerHTML = '';\r\n        if (!building) {\r\n            this.clearSelectedEntity();\r\n            return;\r\n        }\r\n       \r\n        const buildingId = this.game.state.selectedEntity.entityId;\r\n        if(this.buildingProductionProgress.has(buildingId)){\r\n            const hasUnits = building.units && building.units.length > 0;\r\n            const hasUpgrades = building.upgrades && building.upgrades.length > 0;\r\n            if (hasUnits) {\r\n                const unitsSection = this.createUnitsSection(building);\r\n                container.appendChild(unitsSection);\r\n            }\r\n\r\n            if (hasUpgrades) {\r\n                const upgradesSection = this.createUpgradesSection(building);\r\n                container.appendChild(upgradesSection);\r\n            }\r\n\r\n            if (!hasUnits && !hasUpgrades) {\r\n                const empty = document.createElement('div');\r\n                empty.className = 'action-empty';\r\n                empty.textContent = 'No actions available';\r\n                container.appendChild(empty);\r\n            }\r\n        } else {\r\n            const empty = document.createElement('div');\r\n            empty.className = 'action-empty';\r\n            empty.textContent = 'Under Construction';\r\n            container.appendChild(empty);\r\n        }\r\n        \r\n        container.removeAttribute('style');\r\n    }\r\n\r\n    createUnitsSection(building) {\r\n        const section = document.createElement('div');\r\n        section.className = 'action-section';\r\n\r\n        const grid = document.createElement('div');\r\n        grid.className = 'action-grid';\r\n        const UnitTypes = this.game.getCollections().units;\r\n        \r\n        const buildingId = this.game.state.selectedEntity.entityId;\r\n        const productionProgress = this.buildingProductionProgress.get(buildingId);\r\n        const remainingCapacity = 1 - productionProgress;\r\n        \r\n        building.units.forEach(unitId => {\r\n            const unit = UnitTypes[unitId];\r\n            const buildTime = unit.buildTime || 1;\r\n            const canAfford = this.game.state.playerGold >= unit.value;\r\n            const hasCapacity = buildTime <= remainingCapacity + 0.001;\r\n            \r\n            const hasSupply = !this.game.supplySystem || this.game.supplySystem.canAffordSupply(this.game.state.mySide, unit);\r\n            \r\n            let locked = !canAfford || !hasCapacity || !hasSupply;\r\n            let lockReason = null;\r\n            if (!canAfford) {\r\n                lockReason = \"Can't afford\";\r\n            } else if (!hasCapacity) {\r\n                lockReason = `Need ${buildTime.toFixed(1)} rounds`;\r\n            } else if (!hasSupply) {\r\n                lockReason = \"Not enough supply\";\r\n            }\r\n            \r\n            const btn = this.createActionButton({\r\n                iconId: unit.icon,\r\n                title: unit.title,\r\n                cost: unit.value,\r\n                buildTime: buildTime,\r\n                locked: locked,\r\n                lockReason: lockReason,\r\n                onClick: () => this.purchaseUnit(unitId, unit)\r\n            });\r\n            grid.appendChild(btn);\r\n        });\r\n\r\n        section.appendChild(grid);\r\n        return section;\r\n    }\r\n\r\n    createUpgradesSection(building) {\r\n        const section = document.createElement('div');\r\n        section.className = 'action-section';\r\n\r\n        const header = document.createElement('div');\r\n        header.className = 'action-section-header';\r\n        header.textContent = 'UPGRADES';\r\n        section.appendChild(header);\r\n\r\n        const grid = document.createElement('div');\r\n        grid.className = 'action-grid';\r\n\r\n        const buildingId = this.game.state.selectedEntity.entityId;\r\n        const purchasedUpgrades = this.buildingUpgrades.get(buildingId) || new Set();\r\n\r\n        building.upgrades.forEach(upgradeId => {\r\n            const upgrade = this.game.getCollections().upgrades[upgradeId];\r\n            if (!upgrade) return;\r\n\r\n            const isOwned = purchasedUpgrades.has(upgradeId);\r\n            const locked = isOwned || this.game.state.playerGold < upgrade.value;\r\n\r\n            const btn = this.createActionButton({\r\n                icon: upgrade.icon || '',\r\n                title: upgrade.title,\r\n                cost: upgrade.value,\r\n                locked: locked,\r\n                lockReason: isOwned ? 'Owned' : (locked ? \"Can't afford\" : null),\r\n                owned: isOwned,\r\n                onClick: () => !isOwned && this.purchaseUpgrade(upgradeId, upgrade, buildingId)\r\n            });\r\n            grid.appendChild(btn);\r\n        });\r\n\r\n        section.appendChild(grid);\r\n        return section;\r\n    }\r\n\r\n    createActionButton(options) {\r\n        const {\r\n            iconId,\r\n            title,\r\n            cost,\r\n            buildTime,\r\n            locked = false,\r\n            lockReason = null,\r\n            onClick\r\n        } = options;\r\n\r\n        const btn = document.createElement('button');\r\n        btn.className = 'action-btn';\r\n        if (locked) btn.classList.add('locked');\r\n\r\n        const iconEl = document.createElement('div');\r\n        iconEl.className = 'action-btn-icon';\r\n        if(iconId){\r\n            const icon = this.game.getCollections().icons[iconId];\r\n            if(icon && icon.filePath){\r\n                const img = document.createElement('img');\r\n                img.src = `./${icon.filePath}`;\r\n                iconEl.append(img);\r\n            } else {\r\n                iconEl.textContent =  '';\r\n            }\r\n        } else {\r\n            iconEl.textContent =  '';\r\n        }\r\n\r\n        \r\n        btn.appendChild(iconEl);\r\n        let costTxt = ` ${cost}`;\r\n        if (lockReason) {\r\n            costTxt = lockReason;\r\n        } \r\n        btn.title = `${title} ${costTxt}`;\r\n        \r\n\r\n        if (!locked) {\r\n            btn.addEventListener('click', onClick);\r\n        }\r\n\r\n        return btn;\r\n    }\r\n\r\n    isBuildingLocked(buildingId, building) {\r\n        return this.game.state.playerGold < building.value ||\r\n               (building.requires && !this.hasRequirements(building.requires));\r\n    }\r\n\r\n    getLockReason(buildingId, building) {\r\n        if (this.game.state.playerGold < building.value) return \"Can't afford\";\r\n        if (building.requires && !this.hasRequirements(building.requires)) {\r\n            return 'Missing requirements';\r\n        }\r\n        return null;\r\n    }\r\n\r\n    hasRequirements(requirements) {\r\n        if (requirements.townHallLevel) {\r\n            if (this.townHallLevel < requirements.townHallLevel) return false;\r\n        }\r\n        if (requirements.buildings) {\r\n            for (const reqBuilding of requirements.buildings) {\r\n                if (!this.ownedBuildings.has(reqBuilding)) return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    addBuilding(buildingId, entityId){\r\n        if(!this.ownedBuildings.has(buildingId)){\r\n            this.ownedBuildings.set(buildingId, [entityId]);\r\n        } else {\r\n            this.ownedBuildings.get(buildingId).push(entityId)            \r\n        }\r\n\r\n        this.buildingProductionProgress.set(entityId, 0);\r\n        this.buildingUpgrades.set(buildingId, new Set());        \r\n    }\r\n\r\n    purchaseUnit(unitId, unit) {\r\n        const buildingId = this.game.state.selectedEntity.entityId;\r\n        const placementId = this.getBuildingPlacementId(buildingId);\r\n        \r\n        if (!placementId) {\r\n            console.log('no building selected');\r\n            this.showNotification('No building selected!', 'error');\r\n            return;\r\n        }\r\n\r\n        const buildTime = unit.buildTime || 1;\r\n        const productionProgress = this.buildingProductionProgress.get(buildingId);\r\n        const remainingCapacity = 1 - productionProgress;\r\n        \r\n        if (buildTime > remainingCapacity + 0.001) {\r\n            this.showNotification(`Not enough production capacity! Need ${buildTime.toFixed(1)} rounds`, 'error');\r\n            return;\r\n        }\r\n\r\n        unit.id = unitId;\r\n        unit.collection = 'units';\r\n        const placementPos = this.findBuildingPlacementPosition(placementId, unit);\r\n        if (!placementPos) {\r\n            console.log('no valid placement');\r\n            this.showNotification('No valid placement near building!', 'error');\r\n            return;\r\n        }\r\n        const placement = this.game.gameManager.call('createPlacementData', placementPos, unit, this.game.state.mySide);\r\n\r\n        this.game.networkManager.submitPlacement(placement, (success, response) => {\r\n            if(success){\r\n                const newProgress = productionProgress + buildTime;\r\n                this.buildingProductionProgress.set(buildingId, newProgress);\r\n                this.game.gameManager.call('placeSquadOnBattlefield', placement);\r\n            }\r\n        });       \r\n    }\r\n\r\n    findBuildingPlacementPosition(placementId, unitDef) {\r\n        const buildingGridPos = this.getBuildingGridPosition(placementId);\r\n        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n        if (!buildingGridPos) return null;\r\n\r\n        const gridSystem = this.game.gridSystem;\r\n        const placementSystem = this.game.placementSystem;\r\n        if (!gridSystem || !placementSystem) return null;\r\n\r\n        const buildingCells = placement.cells || [];\r\n        const buildingCellSet = new Set(buildingCells.map(cell => `${cell.x},${cell.z}`));\r\n\r\n        const searchRadius = 12;\r\n        const spiralOffsets = this.generateSpiralOffsets(searchRadius);\r\n\r\n        for (const offset of spiralOffsets) {\r\n            const testPos = {\r\n                x: buildingGridPos.x + offset.x,\r\n                z: buildingGridPos.z + offset.z\r\n            };\r\n            \r\n            const testCellKey = `${testPos.x},${testPos.z}`;\r\n            if (buildingCellSet.has(testCellKey)) {\r\n                continue;\r\n            }\r\n            \r\n            const unitSquadData = this.game.squadManager.getSquadData(unitDef);\r\n            const unitCells = this.game.squadManager.getSquadCells(testPos, unitSquadData);\r\n            \r\n            const overlapsBuilding = unitCells.some(cell => \r\n                buildingCellSet.has(`${cell.x},${cell.z}`)\r\n            );\r\n            \r\n            if (overlapsBuilding) {\r\n                continue;\r\n            }\r\n\r\n            const worldPos = gridSystem.gridToWorld(testPos.x, testPos.z);\r\n            if (placementSystem.isValidGridPlacement(worldPos, unitDef)) {\r\n                return testPos;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    generateSpiralOffsets(maxRadius) {\r\n        const offsets = [];\r\n        let x = 0, z = 0;\r\n        let dx = 0, dz = -1;\r\n        \r\n        for (let i = 0; i < (maxRadius * 2) * (maxRadius * 2); i++) {\r\n            if ((-maxRadius < x && x <= maxRadius) && (-maxRadius < z && z <= maxRadius)) {\r\n                offsets.push({ x, z });\r\n            }\r\n            \r\n            if (x === z || (x < 0 && x === -z) || (x > 0 && x === 1 - z)) {\r\n                const temp = dx;\r\n                dx = -dz;\r\n                dz = temp;\r\n            }\r\n            \r\n            x += dx;\r\n            z += dz;\r\n        }\r\n        \r\n        return offsets;\r\n    }\r\n\r\n    getBuildingPlacementId(buildingId) {\r\n        const state = this.game.state;\r\n        const mySide = state.mySide;\r\n        const placements = this.game.gameManager.call('getPlacementsForSide', mySide);\r\n        if (!placements) return null;\r\n\r\n        for (const [placementIndex, placement] of Object.entries(placements)) {\r\n            for(const squadUnit of placement.squadUnits){\r\n                if (squadUnit === buildingId) {\r\n                    return placement.placementId;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getBuildingGridPosition(placementId) {\r\n        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n        console.log('got placement', placement);\r\n        return placement.gridPosition;\r\n    }\r\n\r\n    purchaseUpgrade(upgradeId, upgrade) {\r\n        this.game.networkManager.purchaseUpgrade({ \r\n            upgradeId, \r\n            buildingId: this.game.state.selectedEntity.entityId \r\n        }, (success, response) => {\r\n            if (success) {\r\n                if (!this.buildingUpgrades.has(this.game.state.selectedEntity.entityId)) {\r\n                    this.buildingUpgrades.set(this.game.state.selectedEntity.entityId, new Set());\r\n                }\r\n                this.buildingUpgrades.get(this.game.state.selectedEntity.entityId).add(upgradeId);\r\n                this.game.state.playerGold -= upgrade.value;\r\n                this.applyUpgradeEffects(this.game.state.mySide, upgrade);\r\n                this.showNotification(`${upgrade.title} purchased!`, 'success');\r\n            }\r\n        });\r\n    }\r\n\r\n    applyUpgradeEffects(team, upgrade) {\r\n        if (upgrade.effects) {\r\n            upgrade.effects.forEach(effectId => {\r\n                const effect = this.game.getCollections().effects[effectId];\r\n                if (effect) {\r\n                    effect.id = effectId;\r\n                    this.applyEffect(team, effect);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    applyEffect(team, effectData) {\r\n        if(!this.game.state.teams){\r\n            this.game.state.teams = {};\r\n        }\r\n        if(!this.game.state.teams[team]) {\r\n            this.game.state.teams[team] = {};\r\n        } \r\n        if(!this.game.state.teams[team].effects) {\r\n            this.game.state.teams[team].effects = {};\r\n        }\r\n        this.game.state.teams[team].effects[effectData.id] = effectData;\r\n    }\r\n\r\n    onPlacementPhaseStart() {\r\n        this.ownedBuildings.keys().forEach(buildingType => {\r\n            this.ownedBuildings.get(buildingType).forEach((buildingEntityId) => {\r\n                this.buildingProductionProgress.set(buildingEntityId, 0);\r\n            });\r\n        });\r\n    }\r\n\r\n    createExperiencePanel() {\r\n        const container = document.getElementById('unitPromotions');\r\n        if (!container) return;\r\n\r\n        container.innerHTML = '';\r\n\r\n        const squadsReadyToLevelUp = this.game.gameManager.call('getSquadsReadyToLevelUp');\r\n        \r\n        if (squadsReadyToLevelUp.length === 0) return;\r\n\r\n        squadsReadyToLevelUp.forEach(squad => {\r\n            const panel = this.createExperienceCard(squad);\r\n            if (panel) {\r\n                container.appendChild(panel);\r\n            }\r\n        });\r\n    }\r\n\r\n    createExperienceCard(squad) {\r\n        const currentUnitType = this.getCurrentUnitType(squad.placementId, squad.team);\r\n        if (!currentUnitType) return null;\r\n\r\n        const hasSpecializations = currentUnitType.specUnits && currentUnitType.specUnits.length > 0;\r\n        const isSpecializationLevel = (squad.level) == 2;\r\n        const canSpecialize = isSpecializationLevel && hasSpecializations;\r\n        \r\n        const card = document.createElement('div');\r\n        card.className = 'experience-panel';\r\n\r\n        if (canSpecialize) {\r\n            const shimmer = document.createElement('div');\r\n            shimmer.classList.add(\"shimmer\");\r\n            card.appendChild(shimmer);\r\n        }\r\n\r\n        const currentLevelText = ` (Lvl ${squad.level})`;\r\n        const nextLevelText = canSpecialize ? ' Ascend!' : ` Level ${squad.level + 1}`;\r\n\r\n        const header = document.createElement('div');\r\n        header.className = 'experience-header';\r\n\r\n        const unitIcon = document.createElement('div');\r\n        unitIcon.className = 'experience-unit-icon';\r\n        unitIcon.textContent = currentUnitType.icon || '';\r\n        header.appendChild(unitIcon);\r\n\r\n        const info = document.createElement('div');\r\n        info.className = 'experience-info';\r\n\r\n        const title = document.createElement('div');\r\n        title.className = 'experience-title';\r\n        title.textContent = this.getSquadDisplayName(squad.placementId);\r\n        info.appendChild(title);\r\n\r\n        const subtitle = document.createElement('div');\r\n        subtitle.className = 'experience-subtitle';\r\n        subtitle.textContent = `${currentUnitType.title}${currentLevelText}`;\r\n        info.appendChild(subtitle);\r\n\r\n        header.appendChild(info);\r\n        card.appendChild(header);\r\n\r\n        const progress = document.createElement('div');\r\n        progress.className = 'experience-progress';\r\n\r\n        const progressBar = document.createElement('div');\r\n        progressBar.className = 'experience-progress-bar';\r\n\r\n        const progressFill = document.createElement('div');\r\n        progressFill.className = 'experience-progress-fill';\r\n        progressFill.style.width = '100%';\r\n        progressBar.appendChild(progressFill);\r\n\r\n        progress.appendChild(progressBar);\r\n\r\n        const xpText = document.createElement('div');\r\n        xpText.className = 'experience-xp-text';\r\n        xpText.textContent = 'Ready to advance!';\r\n        progress.appendChild(xpText);\r\n\r\n        card.appendChild(progress);\r\n\r\n        const buttonContainer = document.createElement('div');\r\n        buttonContainer.className = 'experience-buttons';\r\n\r\n        if (canSpecialize) {\r\n            const specBtn = document.createElement('button');\r\n            specBtn.className = 'btn btn-primary experience-btn';\r\n            specBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;\r\n            specBtn.onclick = () => {\r\n                this.game.gameManager.call('showSpecializationSelection',\r\n                    squad.placementId,\r\n                    squad,\r\n                    squad.levelUpCost\r\n                );\r\n            };\r\n            buttonContainer.appendChild(specBtn);\r\n        } else {\r\n            const levelUpBtn = document.createElement('button');\r\n            levelUpBtn.className = 'btn btn-primary experience-btn';\r\n            levelUpBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;\r\n            levelUpBtn.onclick = () => {\r\n                this.game.gameManager.call('levelUpSquad', squad.placementId, squad.team);\r\n            };\r\n            buttonContainer.appendChild(levelUpBtn);\r\n        }\r\n\r\n        card.appendChild(buttonContainer);\r\n        return card;\r\n    }\r\n\r\n    getCurrentUnitType(placementId, team) {\r\n        const state = this.game.state;\r\n        const placement = state.placements?.[team]?.[placementId];\r\n        if (!placement) return null;\r\n        \r\n        const UnitTypes = this.game.getCollections().units;\r\n        return placement.unitType ? UnitTypes[placement.unitType] : null;\r\n    }\r\n\r\n    getSquadDisplayName(placementId) {\r\n        const match = placementId.match(/^([a-z]+)_(\\d+)$/);\r\n        if (match) {\r\n            const side = match[1];\r\n            const index = parseInt(match[2], 10);\r\n            const sideLabel = side === 'left' ? 'Left' : side === 'right' ? 'Right' : side === 'center' ? 'Center' : 'Unknown';\r\n            return `${sideLabel} Squad ${index + 1}`;\r\n        }\r\n        return placementId;\r\n    }\r\n\r\n    showNotification(message, type) {\r\n        if (this.uiEnhancements) {\r\n            this.uiEnhancements.showNotification(message, type);\r\n        } \r\n    }\r\n\r\n    update() {\r\n        const state = this.game.state;\r\n        const inPlacementPhase = state.phase === 'placement';\r\n\r\n        if (inPlacementPhase) {\r\n            if (this.game.state.now - this.lastExperienceUpdate > 2) {\r\n                const squadsReadyToLevelUp = this.game.gameManager.call('getSquadsReadyToLevelUp');\r\n                const hasReadySquads = squadsReadyToLevelUp && squadsReadyToLevelUp.length > 0;\r\n                const hasExperiencePanel = document.querySelector('.experience-panel') !== null;\r\n\r\n                if (hasReadySquads !== hasExperiencePanel) {\r\n                    this.createExperiencePanel();\r\n                }\r\n\r\n                this.lastExperienceUpdate = this.game.state.now;\r\n            }\r\n        }\r\n    }\r\n\r\n    reset() {\r\n        this.clearSelectedEntity();\r\n    }\r\n\r\n  \r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ShopSystem.js",
        "fileName": "ShopSystem"
      },
      "UISystem": {
        "script": "class UISystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.uiSystem = this;        \r\n        // Initialize subsystems\r\n        GUTS.NotificationSystem.initialize();\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('showNotification', this.showNotification.bind(this));\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // Delegate to input handler\r\n        this.game.inputManager.setup();\r\n    }\r\n    \r\n    start() {\r\n        this.game.gameManager.call('initializeParticleSystem');\r\n        this.game.gameManager.call('initializeEffectsSystem');\r\n        // Welcome messages\r\n    }\r\n    \r\n    update() {\r\n        const readyButton = document.getElementById('readyButton');\r\n        if (this.game.state.phase === 'placement') {\r\n            readyButton.disabled = false;\r\n            readyButton.textContent = this.game.state.playerReady ? 'Waiting for battle...' : 'Ready for Battle!';\r\n        } else {\r\n            readyButton.disabled = true;\r\n            readyButton.textContent = 'Battle in Progress';\r\n        }\r\n    }    \r\n    // Get reference to game state\r\n    getGameState() { return this.game.state; }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UISystem.js",
        "fileName": "UISystem"
      },
      "TeamHealthSystem": {
        "script": "class TeamHealthSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.teamHealthSystem = this;\r\n        \r\n        \r\n        // Team health configuration\r\n        this.MAX_TEAM_HEALTH = 2500;\r\n        this.teamHealth = {\r\n            left: this.MAX_TEAM_HEALTH,\r\n            right: this.MAX_TEAM_HEALTH\r\n        };\r\n        \r\n        // Track if we've already processed this round's result\r\n        this.roundProcessed = false;\r\n        \r\n        if(!this.game.isServer){\r\n            console.log('this.game', this.game);\r\n            this.initializeUI();\r\n        }\r\n    }\r\n    \r\n    initializeUI() {\r\n        // Delay creation to ensure DOM is ready\r\n        setTimeout(() => {\r\n            this.updateHealthDisplay();\r\n        }, 100);\r\n    }\r\n    \r\n    updateHealthDisplay() {\r\n        const playerFill = document.getElementById('playerHealthFill');\r\n        const playerText = document.getElementById('playerHealthText');\r\n        const opponentFill = document.getElementById('opponentHealthFill');\r\n        const opponentText = document.getElementById('opponentHealthText');\r\n        \r\n        let myHealth = this.teamHealth[this.game.state.mySide] || this.MAX_TEAM_HEALTH;\r\n        let opponentHealth = this.teamHealth[this.game.state.mySide == 'left' ? 'right' : 'left'] || this.MAX_TEAM_HEALTH;\r\n        if (playerFill && playerText) {\r\n            const playerPercent = (myHealth / this.MAX_TEAM_HEALTH) * 100;\r\n            playerFill.style.width = `${playerPercent}%`;\r\n            playerText.textContent = `${myHealth}/${this.MAX_TEAM_HEALTH}`;\r\n        }\r\n        \r\n        if (opponentFill && opponentText) {\r\n            const opponentPercent = (opponentHealth / this.MAX_TEAM_HEALTH) * 100;\r\n            opponentFill.style.width = `${opponentPercent}%`;\r\n            opponentText.textContent = `${opponentHealth}/${this.MAX_TEAM_HEALTH}`;\r\n        }\r\n    }\r\n    \r\n    onBattleStart() {\r\n        this.roundProcessed = false;\r\n     \r\n    }\r\n    \r\n    // Apply damage when PhaseSystem tells us a round ended\r\n    applyRoundDamage(winningTeam, survivingUnits) {\r\n        \r\n        // Calculate damage based on surviving squads' base values\r\n        const damageResult = this.calculateSquadBasedDamage(survivingUnits);\r\n        const losingTeam = winningTeam === 'left' ? 'right' : 'left';\r\n        \r\n        // Apply damage to losing team\r\n        this.dealDamageToTeam(losingTeam, damageResult.totalDamage);\r\n        \r\n        // Return result object\r\n        return {\r\n            result: winningTeam === this.game.state.mySide ? 'victory' : 'defeat',\r\n            winningTeam: winningTeam,\r\n            losingTeam: losingTeam,\r\n            damage: damageResult.totalDamage,\r\n            survivingSquads: damageResult.survivingSquads,\r\n            gameOver: this.teamHealth[losingTeam] <= 0,\r\n            remainingHealth: {\r\n                left: this.teamHealth.left,\r\n                right: this.teamHealth.right\r\n            }\r\n        };\r\n    }\r\n    \r\n    // Apply no damage for draws\r\n    applyRoundDraw() {\r\n        if (this.roundProcessed) return null;\r\n        this.roundProcessed = true;\r\n\r\n        \r\n        // Return draw result\r\n        return {\r\n            result: 'draw',\r\n            winningTeam: null,\r\n            losingTeam: null,\r\n            damage: 0,\r\n            gameOver: false,\r\n            remainingHealth: {\r\n                left: this.teamHealth.left,\r\n                right: this.teamHealth.right\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Calculate damage based on squads, not individual units\r\n     * If ANY units from a squad survive, the entire squad's base value counts as damage\r\n     * @param {Array} survivingUnits - Array of surviving unit entity IDs\r\n     * @returns {Object} Damage calculation results\r\n     */\r\n    calculateSquadBasedDamage(survivingUnits) {\r\n        const squadMap = new Map(); // squadId -> {unitType, survivors, totalUnits}\r\n        let totalDamage = 0;\r\n        let survivingSquadCount = 0;\r\n        const squadDetails = [];\r\n        if(!survivingUnits){ \r\n            return {\r\n                totalDamage: 0,\r\n                survivingSquads: 0,\r\n                squadDetails: []\r\n            };\r\n        }\r\n        // Group surviving units by their squad placement ID\r\n        survivingUnits.forEach(unitId => {\r\n            // Find which squad this unit belongs to\r\n            const squadInfo = this.findSquadForUnit(unitId);\r\n            if (squadInfo) {\r\n                const { placementId, unitType } = squadInfo;\r\n                \r\n                if (!squadMap.has(placementId)) {\r\n                    squadMap.set(placementId, {\r\n                        unitType: unitType,\r\n                        survivors: 0,\r\n                        totalUnits: this.getOriginalSquadSize(placementId),\r\n                        placementId: placementId\r\n                    });\r\n                }\r\n                \r\n                squadMap.get(placementId).survivors++;\r\n            }\r\n        });\r\n        \r\n        // Calculate damage for each squad that has survivors\r\n        squadMap.forEach((squadData, placementId) => {\r\n            if (squadData.survivors > 0) {\r\n                // Entire squad's base value counts as damage\r\n                const squadBaseDamage = squadData.unitType.value || 50;\r\n                totalDamage += squadBaseDamage;\r\n                survivingSquadCount++;\r\n                \r\n                squadDetails.push({\r\n                    name: squadData.unitType.title || squadData.unitType.id || 'Unknown Squad',\r\n                    damage: squadBaseDamage,\r\n                    survivingUnits: squadData.survivors,\r\n                    totalUnits: squadData.totalUnits,\r\n                    placementId: placementId\r\n                });\r\n                \r\n            }\r\n        });\r\n        \r\n        return {\r\n            totalDamage: totalDamage,\r\n            survivingSquads: survivingSquadCount,\r\n            squadDetails: squadDetails\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Find which squad a unit belongs to\r\n     * @param {number} unitId - Unit entity ID\r\n     * @returns {Object|null} Squad info or null\r\n     */\r\n    findSquadForUnit(unitId) {\r\n        // Check with experience system first (most reliable)\r\n        const squadData = this.game.gameManager.call('findSquadByUnitId', unitId);\r\n        if (squadData) {\r\n            const unitType = this.getCurrentUnitTypeForSquad(squadData.placementId);\r\n            return {\r\n                placementId: squadData.placementId,\r\n                unitType: unitType || { value: squadData.squadValue, title: 'Unknown', id: 'unknown' }\r\n            };\r\n        }\r\n\r\n        // Fallback: search placement system\r\n        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];\r\n        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];\r\n        const allPlacements = [...playerPlacements, ...opponentPlacements];\r\n\r\n        for (const placement of allPlacements) {\r\n            if (placement.squadUnits) {\r\n                const unitMatch = placement.squadUnits.find(entityId => entityId === unitId);\r\n                if (unitMatch) {\r\n                    return {\r\n                        placementId: placement.placementId,\r\n                        unitType: placement.unitType\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        // Last resort: use unit type component directly\r\n        const unitTypeComponent = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);\r\n        if (unitTypeComponent) {\r\n            return {\r\n                placementId: `unknown_${unitId}`,\r\n                unitType: {\r\n                    value: unitTypeComponent.value || 50,\r\n                    title: unitTypeComponent.type || 'Unknown Unit',\r\n                    id: unitTypeComponent.id || 'unknown'\r\n                }\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Get the current unit type for a squad (handles specializations)\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {Object|null} Current unit type\r\n     */\r\n    getCurrentUnitTypeForSquad(placementId) {\r\n        const unitType = this.game.gameManager.call('getCurrentUnitTypeForSquad', placementId);\r\n        if (unitType) {\r\n            return unitType;\r\n        }\r\n\r\n        // Fallback to placement system\r\n        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];\r\n        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];\r\n        const placement = playerPlacements.find(p => p.placementId === placementId) ||\r\n                         opponentPlacements.find(p => p.placementId === placementId);\r\n        return placement ? placement.unitType : null;\r\n    }\r\n    \r\n    /**\r\n     * Get the original size of a squad when it was placed\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {number} Original squad size\r\n     */\r\n    getOriginalSquadSize(placementId) {\r\n        // Check experience system first\r\n        const squadData = this.game.gameManager.call('getSquadExperienceData', placementId);\r\n        if (squadData) {\r\n            return squadData.totalUnitsInSquad || squadData.squadSize;\r\n        }\r\n\r\n        // Fallback to placement system\r\n        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];\r\n        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];\r\n        const placement = playerPlacements.find(p => p.placementId === placementId) ||\r\n                         opponentPlacements.find(p => p.placementId === placementId);\r\n        if (placement) {\r\n            return placement.squadUnits ? placement.squadUnits.length : 1;\r\n        }\r\n\r\n        return 1; // Default fallback\r\n    }\r\n    \r\n    dealDamageToTeam(team, damage) {\r\n        this.teamHealth[team] = Math.max(0, this.teamHealth[team] - damage);\r\n        if(!this.game.isServer){\r\n            this.updateHealthDisplay();\r\n            this.showDamageEffect(team, damage);\r\n        }\r\n    }\r\n    \r\n    showDamageEffect(team, damage) {\r\n        // Create floating damage text\r\n        const damageText = document.createElement('div');\r\n        damageText.className = `damage-popup ${team}-damage`;\r\n        damageText.textContent = `-${damage}`;\r\n        \r\n        // Position based on team\r\n        const healthBar = document.querySelector(`.${team}-health`);\r\n        if (healthBar) {\r\n            const rect = healthBar.getBoundingClientRect();\r\n            damageText.style.position = 'fixed';\r\n            damageText.style.left = `${rect.left + rect.width / 2}px`;\r\n            damageText.style.top = `${rect.top}px`;\r\n            damageText.style.zIndex = '1000';\r\n            \r\n            document.body.appendChild(damageText);\r\n            \r\n            // Animate and remove\r\n            setTimeout(() => {\r\n                if (damageText.parentNode) {\r\n                    damageText.parentNode.removeChild(damageText);\r\n                }\r\n            }, 2000);\r\n        }\r\n    }\r\n    \r\n    resetTeamHealth() {\r\n        this.teamHealth.left = this.MAX_TEAM_HEALTH;\r\n        this.teamHealth.right = this.MAX_TEAM_HEALTH;\r\n        this.roundProcessed = false;\r\n        this.updateHealthDisplay();\r\n    }\r\n    \r\n    getTeamHealth(team) {\r\n        return this.teamHealth[team] || 0;\r\n    }\r\n    \r\n    getHealthPercentage(team) {\r\n        return (this.teamHealth[team] / this.MAX_TEAM_HEALTH) * 100;\r\n    }\r\n    \r\n    // Get health status for UI\r\n    getHealthStatus() {\r\n        return {\r\n            left: {\r\n                current: this.teamHealth.left,\r\n                max: this.MAX_TEAM_HEALTH,\r\n                percentage: this.getHealthPercentage('left')\r\n            },\r\n            right: {\r\n                current: this.teamHealth.right,\r\n                max: this.MAX_TEAM_HEALTH,\r\n                percentage: this.getHealthPercentage('right')\r\n            }\r\n        };\r\n    }\r\n\r\n    getLeftHealth() {\r\n        return this.teamHealth.left || 0;\r\n    }\r\n\r\n    // Method for multiplayer compatibility - returns current right health  \r\n    getRightHealth() {\r\n        return this.teamHealth.right || 0;\r\n    }\r\n\r\n    // Method to set left health (for multiplayer server updates)\r\n    setLeftHealth(health) {\r\n        this.teamHealth.left = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));\r\n        this.updateHealthDisplay();\r\n    }\r\n\r\n    // Method to set right health (for multiplayer server updates)\r\n    setRightHealth(health) {\r\n        this.teamHealth.right = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));\r\n        this.updateHealthDisplay();\r\n    }\r\n\r\n    // Multiplayer-specific method to sync both team healths from server\r\n    syncHealthFromServer(leftHealth, rightHealth) {\r\n        this.teamHealth.left = Math.max(0, Math.min(leftHealth, this.MAX_TEAM_HEALTH));\r\n        this.teamHealth.right = Math.max(0, Math.min(rightHealth, this.MAX_TEAM_HEALTH));\r\n        this.updateHealthDisplay();\r\n    }\r\n\r\n    // Check if either team is eliminated (for multiplayer game end conditions)\r\n    isGameOver() {\r\n        return this.teamHealth.left <= 0 || this.teamHealth.right <= 0;\r\n    }\r\n\r\n    // Get the winning team (for multiplayer results)\r\n    getWinningTeam() {\r\n        if (this.teamHealth.left <= 0) return 'right';\r\n        if (this.teamHealth.right <= 0) return 'left';\r\n        return null; // No winner yet\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TeamHealthSystem.js",
        "fileName": "TeamHealthSystem"
      },
      "UnitRadiusSystem": {
        "script": "class UnitRadiusSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.unitRadiusSystem = this;        \r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        this.debugCircles = new Map(); // entityId -> { sizeCircle, attackCircle }\r\n        this.enabled = false; // Toggle this to show/hide circles\r\n        \r\n        // Visual configuration\r\n        this.SIZE_CIRCLE_COLOR = 0x00ff00;      // Green for unit size\r\n        this.ATTACK_CIRCLE_COLOR = 0xff0000;    // Red for attack range\r\n        this.CIRCLE_OPACITY = 0.3;\r\n        this.CIRCLE_LINE_WIDTH = 2;\r\n    }\r\n    \r\n    update() {\r\n        if (!this.enabled ) return;\r\n        if(this.game.state.phase !== 'battle') {\r\n            this.hideAllCircles();\r\n            return;\r\n        }\r\n        \r\n        const entities = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION, \r\n            this.componentTypes.UNIT_TYPE\r\n        );\r\n        \r\n        entities.forEach(entityId => {\r\n            this.updateEntityCircles(entityId);\r\n        });\r\n        \r\n        // Clean up circles for destroyed entities\r\n        this.cleanupDestroyedEntities(entities);\r\n    }\r\n    \r\n    updateEntityCircles(entityId) {\r\n        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);\r\n        const combat = this.game.getComponent(entityId, this.componentTypes.COMBAT);\r\n        \r\n        if (!pos || !collision) return;\r\n        \r\n        // Get or create debug circles for this entity\r\n        let circles = this.debugCircles.get(entityId);\r\n        if (!circles) {\r\n            circles = this.createDebugCircles(entityId);\r\n            this.debugCircles.set(entityId, circles);\r\n        }\r\n        \r\n        if (!circles.sizeCircle || !circles.attackCircle) {\r\n            return;\r\n        }\r\n        \r\n        // Update positions\r\n        circles.sizeCircle.position.set(pos.x, pos.y + 50, pos.z); // y=1 to avoid z-fighting\r\n        circles.attackCircle.position.set(pos.x, pos.y + 60, pos.z); // y=2 to be above size circle\r\n        \r\n        // Update sizes\r\n        const unitRadius = this.getUnitRadius(collision);\r\n        const attackRange = this.getAttackRange(combat, collision);\r\n        \r\n        //console.log(`Entity ${entityId}: unitRadius=${unitRadius}, attackRange=${attackRange}, pos=(${pos.x}, ${pos.y})`);\r\n        \r\n        // Scale the circles - base circle is 50 units radius, so scale accordingly\r\n        circles.sizeCircle.scale.setScalar(unitRadius / 50);\r\n        circles.attackCircle.scale.setScalar(attackRange / 50);\r\n        \r\n        // Always show size circle\r\n        circles.sizeCircle.visible = true;\r\n        \r\n        // Show/hide attack circle based on entity state\r\n        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);\r\n        if (aiState && (aiState.state === 'attacking' || aiState.state === 'chasing')) {\r\n            circles.attackCircle.visible = true;\r\n            if (aiState.state === 'attacking') {\r\n                circles.attackCircle.material.color.setHex(0xff0000); // Bright red when attacking\r\n            } else {\r\n                circles.attackCircle.material.color.setHex(0xffaa00); // Orange when chasing\r\n            }\r\n        } else {\r\n            circles.attackCircle.visible = true; // Show it anyway for debugging\r\n            circles.attackCircle.material.color.setHex(0x0000ff); // Blue when idle\r\n        }\r\n    }\r\n    \r\n    createDebugCircles(entityId) {\r\n        const scene = this.game.gameManager.call('getWorldScene');\r\n        if (!scene) {\r\n            console.error('No scene found!');\r\n            return { sizeCircle: null, attackCircle: null };\r\n        }\r\n\r\n        // Create size circle (unit radius)\r\n        const sizeGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring\r\n        const sizeMaterial = new THREE.MeshBasicMaterial({\r\n            color: this.SIZE_CIRCLE_COLOR,\r\n            transparent: true,\r\n            opacity: this.CIRCLE_OPACITY,\r\n            side: THREE.DoubleSide\r\n        });\r\n        const sizeCircle = new THREE.Mesh(sizeGeometry, sizeMaterial);\r\n        sizeCircle.rotation.x = -Math.PI / 2; // Lay flat on ground\r\n\r\n        // Create attack range circle\r\n        const attackGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring\r\n        const attackMaterial = new THREE.MeshBasicMaterial({\r\n            color: this.ATTACK_CIRCLE_COLOR,\r\n            transparent: true,\r\n            opacity: this.CIRCLE_OPACITY,\r\n            side: THREE.DoubleSide\r\n        });\r\n        const attackCircle = new THREE.Mesh(attackGeometry, attackMaterial);\r\n        attackCircle.rotation.x = -Math.PI / 2; // Lay flat on ground\r\n\r\n        // Add to scene\r\n        scene.add(sizeCircle);\r\n        scene.add(attackCircle);\r\n\r\n        return { sizeCircle, attackCircle };\r\n    }\r\n    \r\n    getUnitRadius(collision) {\r\n        // Use the same logic as your MovementSystem\r\n        if (collision && collision.radius) {\r\n            return collision.radius; \r\n        }\r\n        \r\n        return 0.1;\r\n    }\r\n    \r\n    getAttackRange(combat, collision) {\r\n        if (!combat) return 0;\r\n        \r\n        const unitRadius = this.getUnitRadius(collision);\r\n        const attackRange = Math.max(combat.range, unitRadius);\r\n        \r\n        return attackRange;\r\n    }\r\n    \r\n    cleanupDestroyedEntities(activeEntities) {\r\n        const activeIds = new Set(activeEntities);\r\n        const scene = this.game.gameManager.call('getWorldScene');\r\n\r\n        for (const [entityId, circles] of this.debugCircles) {\r\n            if (!activeIds.has(entityId)) {\r\n                // Remove from scene\r\n                if (circles.sizeCircle && scene) {\r\n                    scene.remove(circles.sizeCircle);\r\n                    circles.sizeCircle.geometry.dispose();\r\n                    circles.sizeCircle.material.dispose();\r\n                }\r\n                if (circles.attackCircle && scene) {\r\n                    scene.remove(circles.attackCircle);\r\n                    circles.attackCircle.geometry.dispose();\r\n                    circles.attackCircle.material.dispose();\r\n                }\r\n\r\n                // Remove from map\r\n                this.debugCircles.delete(entityId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    hideAllCircles() {\r\n        for (const [entityId, circles] of this.debugCircles) {\r\n            if (circles.sizeCircle) circles.sizeCircle.visible = false;\r\n            if (circles.attackCircle) circles.attackCircle.visible = false;\r\n        }\r\n    }\r\n    \r\n    showAllCircles() {\r\n        for (const [entityId, circles] of this.debugCircles) {\r\n            if (circles.sizeCircle) circles.sizeCircle.visible = true;\r\n            if (circles.attackCircle) circles.attackCircle.visible = true;\r\n        }\r\n    }\r\n    \r\n    toggle() {\r\n        this.enabled = !this.enabled;\r\n        if (this.enabled) {\r\n            this.showAllCircles();\r\n        } else {\r\n            this.hideAllCircles();\r\n        }\r\n        console.log(`Unit debug circles ${this.enabled ? 'enabled' : 'disabled'}`);\r\n    }\r\n    \r\n    cleanup() {\r\n        this.hideAllCircles();\r\n        this.cleanupDestroyedEntities([]);\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitRadiusSystem.js",
        "fileName": "UnitRadiusSystem"
      },
      "WorldSystem": {
        "script": "class WorldSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.worldSystem = this;\r\n        \r\n        this.initialized = false;\r\n        \r\n        // Core Three.js components\r\n        this.scene = null;\r\n        this.camera = null;\r\n        this.renderer = null;\r\n        this.composer = null;\r\n        \r\n        // Terrain and world objects\r\n        this.ground = null;\r\n        this.groundTexture = null;\r\n        this.groundCanvas = null;\r\n        this.groundCtx = null;\r\n        this.grass = null;\r\n        this.liquidMeshes = [];\r\n        \r\n        // Extension planes\r\n        this.extensionPlanes = [];\r\n        \r\n        // Terrain canvas for tile mapping\r\n        this.terrainCanvas = null;\r\n        this.terrainCtx = null;\r\n        \r\n        // Lighting\r\n        this.ambientLight = null;\r\n        this.directionalLight = null;\r\n        this.hemisphereLight = null;\r\n        \r\n        // Uniforms for shaders\r\n        this.uniforms = {};\r\n        \r\n        // World data\r\n        this.level = null;\r\n        this.world = null;\r\n        this.tileMap = null;\r\n        this.heightMapData = null;\r\n        // Settings from collections\r\n        this.lightingSettings = null;\r\n        this.shadowSettings = null;\r\n        this.fogSettings = null;\r\n        this.heightMapSettings = null;\r\n        this.cameraSettings = null;\r\n        \r\n        // Timing\r\n        this.clock = new THREE.Clock();\r\n        this.timer = 0;\r\n        this.terrainRendered = false;\r\n\r\n        // Controls\r\n        this.controls = null;\r\n\r\n        // Window resize handler\r\n        this.onWindowResizeHandler = this.onWindowResize.bind(this);\r\n    }\r\n\r\n    init() {\r\n        if (this.initialized) return;\r\n\r\n        this.game.gameManager.register('getTerrainHeightAtPosition', this.getTerrainHeightAtPosition.bind(this));\r\n        this.game.gameManager.register('getWorldScene', this.getScene.bind(this));\r\n        this.game.gameManager.register('getWorldExtendedSize', () => this.extendedSize);\r\n        this.game.gameManager.register('getGroundTexture', () => this.groundTexture);\r\n\r\n        this.initializeThreeJS();\r\n\r\n        this.loadWorldData();\r\n    }\r\n\r\n    getScene() {\r\n        return this.scene;\r\n    }\r\n\r\n    initializeThreeJS() {\r\n        const gameCanvas = document.getElementById('gameCanvas');\r\n        if (!gameCanvas) {\r\n            console.error('WorldRenderSystem: gameCanvas not found!');\r\n            return;\r\n        }\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.uiScene = new THREE.Scene();\r\n        const currentLevel = this.game.state?.level || 'level1';\r\n        this.level = this.game.getCollections().levels?.[currentLevel];\r\n        this.world = this.game.getCollections().worlds[this.level.world];\r\n        this.cameraData = this.game.getCollections().cameras[this.world.camera]; \r\n        const width = window.innerWidth;\r\n        const height = window.innerHeight; \r\n      // Camera setup\r\n        if(this.cameraData.fov){\r\n            this.camera = new THREE.PerspectiveCamera(\r\n                this.cameraData.fov,\r\n                width / height,\r\n                this.cameraData.near,\r\n                this.cameraData.far\r\n            );\r\n        } else if(this.cameraData.zoom){\r\n            this.camera = new THREE.OrthographicCamera(\r\n                width / - 2, \r\n                width / 2, \r\n                height / 2, \r\n                height / - 2, \r\n                this.cameraData.near,\r\n                this.cameraData.far\r\n            );\r\n            this.camera.zoom = this.cameraData.zoom;\r\n            this.camera.updateProjectionMatrix();\r\n        }\r\n\r\n        this.renderer = new THREE.WebGLRenderer({ \r\n            canvas: gameCanvas,\r\n            antialias: false,\r\n            alpha: true\r\n        });\r\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\r\n        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        \r\n        window.addEventListener('resize', this.onWindowResizeHandler);\r\n        \r\n        this.game.camera = this.camera;\r\n        this.game.scene = this.scene;\r\n        this.game.uiScene = this.uiScene;\r\n        this.game.renderer = this.renderer;\r\n    }\r\n\r\n    initializeTerrainCanvas() {\r\n        this.terrainCanvas = document.createElement('canvas');\r\n        this.terrainCanvas.width = 700;\r\n        this.terrainCanvas.height = 500;\r\n        this.terrainCtx = this.terrainCanvas.getContext('2d');\r\n    }\r\n\r\n    loadWorldData() {\r\n        const collections = this.game.getCollections();\r\n        if (!collections) {\r\n            console.error('WorldRenderSystem: No collections found');\r\n            return;\r\n        }\r\n\r\n        const currentLevel = this.game.state?.level || 'level1';\r\n        this.level = collections.levels?.[currentLevel];\r\n        \r\n        if (!this.level) {\r\n            console.error(`WorldRenderSystem: Level '${currentLevel}' not found`);\r\n            return;\r\n        }\r\n\r\n        this.world = collections.worlds?.[this.level.world];\r\n        if (!this.world) {\r\n            console.error(`WorldRenderSystem: World '${this.level.world}' not found`);\r\n            return;\r\n        }\r\n\r\n        this.lightingSettings = collections.lightings?.[this.world.lighting];\r\n        this.shadowSettings = collections.shadows?.[this.world.shadow];\r\n        this.fogSettings = collections.fogs?.[this.world.fog];\r\n        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];\r\n        this.cameraSettings = collections.cameras?.[this.world.camera];\r\n        this.heightStep = this.heightMapSettings.heightStep;\r\n        this.tileMap = this.level.tileMap;\r\n\r\n        // Calculate world dimensions\r\n        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;\r\n        this.extensionSize = this.world.extensionSize || 0;\r\n        this.extendedSize = this.terrainSize + 2 * this.extensionSize;\r\n        this.heightMapResolution = this.extendedSize / (this.heightMapSettings?.resolutionDivisor || 1);\r\n        \r\n        this.renderer.shadowMap.enabled = this.shadowSettings?.enabled;\r\n    }\r\n\r\n    onGameStarted() {      \r\n        this.initializeTerrainCanvas();\r\n\r\n        if (this.world?.backgroundColor) {\r\n            this.scene.background = new THREE.Color(this.world.backgroundColor);\r\n        }\r\n\r\n        this.setupFog();\r\n        this.setupLighting();\r\n        this.setupCamera();\r\n        this.setupGround();\r\n        \r\n        this.createExtensionPlanes();\r\n        \r\n        if (this.tileMap?.terrainMap) {\r\n            this.renderTerrain();\r\n        } else {\r\n            console.warn('WorldRenderSystem: No terrain map available during setup');\r\n        }\r\n        \r\n        this.initialized = true;  \r\n    }\r\n\r\n    setupFog() {\r\n        if (this.fogSettings?.enabled) {\r\n            this.scene.fog = new THREE.FogExp2(\r\n                this.fogSettings.color, \r\n                this.fogSettings.density\r\n            );\r\n        }\r\n    }\r\n\r\n    setupLighting() {\r\n        if (!this.lightingSettings) {\r\n            this.lightingSettings = {\r\n                ambientColor: '#404040',\r\n                ambientIntensity: 0.6,\r\n                directionalColor: '#ffffff',\r\n                directionalIntensity: 1.0,\r\n                skyColor: '#87CEEB',\r\n                groundColor: '#ffffff',\r\n                hemisphereIntensity: 0.4\r\n            };\r\n        }\r\n\r\n        this.ambientLight = new THREE.AmbientLight(\r\n            this.lightingSettings.ambientColor,\r\n            this.lightingSettings.ambientIntensity\r\n        );\r\n        this.scene.add(this.ambientLight);\r\n\r\n        this.directionalLight = new THREE.DirectionalLight(\r\n            this.lightingSettings.directionalColor,\r\n            this.lightingSettings.directionalIntensity\r\n        );\r\n        if(this.lightingSettings.direction){\r\n            this.lightingSettings.direction = JSON.parse(this.lightingSettings.direction);\r\n            this.directionalLight.position.set(\r\n                -this.lightingSettings.direction.x * this.extendedSize,  \r\n                -this.lightingSettings.direction.y * this.extendedSize, \r\n                -this.lightingSettings.direction.z * this.extendedSize\r\n            );\r\n        }\r\n\r\n        this.directionalLight.castShadow = this.shadowSettings?.enabled || false;\r\n\r\n        if (this.shadowSettings?.enabled) {\r\n            this.directionalLight.shadow.mapSize.width = this.shadowSettings.mapSize;\r\n            this.directionalLight.shadow.mapSize.height = this.shadowSettings.mapSize;\r\n            this.directionalLight.shadow.camera.near = 0.5;\r\n            this.directionalLight.shadow.camera.far = 20000;\r\n            this.directionalLight.shadow.bias = this.shadowSettings.bias;\r\n            this.directionalLight.shadow.normalBias = this.shadowSettings.normalBias;\r\n            this.directionalLight.shadow.radius = this.shadowSettings.radius;\r\n\r\n            const d = this.extendedSize * 0.75;\r\n            this.directionalLight.shadow.camera.left = -d;\r\n            this.directionalLight.shadow.camera.right = d;\r\n            this.directionalLight.shadow.camera.top = d;\r\n            this.directionalLight.shadow.camera.bottom = -d;\r\n\r\n            this.directionalLight.target.position.set(\r\n                0, \r\n                0, \r\n                0\r\n            );\r\n            this.directionalLight.target.updateMatrixWorld();\r\n            this.directionalLight.shadow.camera.updateProjectionMatrix();\r\n        }\r\n\r\n        this.scene.add(this.directionalLight);\r\n        this.scene.add(this.directionalLight.target);\r\n\r\n        this.hemisphereLight = new THREE.HemisphereLight(\r\n            this.lightingSettings.skyColor,\r\n            this.lightingSettings.groundColor,\r\n            this.lightingSettings.hemisphereIntensity\r\n        );\r\n        this.scene.add(this.hemisphereLight);\r\n\r\n    }\r\n\r\n    postAllInit(){\r\n        \r\n        this.setupPostProcessing();\r\n    }\r\n\r\n    setupPostProcessing() {\r\n        const gameConfig = this.game.getCollections()?.configs?.game;\r\n        if (!gameConfig) return;\r\n\r\n        const pixelSize = gameConfig.pixelSize || 1;\r\n        this.game.gameManager.call('registerPostProcessingPass', 'render', {\r\n            enabled: true,\r\n            create: () => {\r\n                return {\r\n                    enabled: true,\r\n                    needsSwap: true,\r\n                    clear: true,\r\n                    renderToScreen: false,\r\n                    \r\n                    render: (renderer, writeBuffer, readBuffer, deltaTime, maskActive) => {\r\n                        renderer.setRenderTarget(writeBuffer);\r\n                        renderer.clear(true, true, true); // Clear color, depth, and stencil\r\n                        renderer.render(this.scene, this.camera);\r\n                    },\r\n                    \r\n                    setSize: (width, height) => {\r\n                        // No-op\r\n                    }\r\n                };\r\n            }\r\n        });\r\n        // Register pixel pass\r\n        this.game.gameManager.call('registerPostProcessingPass', 'pixel', {\r\n            enabled: pixelSize !== 1,\r\n            create: () => {\r\n                const pixelPass = new THREE_.RenderPixelatedPass(pixelSize, this.scene, this.camera);\r\n                pixelPass.enabled = pixelSize !== 1;\r\n                pixelPass.normalEdgeStrength = 0;\r\n                return pixelPass;\r\n            }\r\n        });\r\n\r\n        // Register output pass (always last)\r\n        this.game.gameManager.call('registerPostProcessingPass', 'output', {\r\n            enabled: true,\r\n            create: () => {\r\n                return new THREE_.OutputPass();\r\n            }\r\n        });\r\n        \r\n        console.log('[WorldSystem] Registered post-processing passes');\r\n    }\r\n\r\n    setupCamera() {\r\n        if (!this.cameraSettings) {\r\n            this.cameraSettings = {\r\n                position: '{\"x\":0,\"y\":200,\"z\":300}',\r\n                lookAt: '{\"x\":0,\"y\":0,\"z\":0}',\r\n                fov: 60,\r\n                near: 1,\r\n                far: 30000\r\n            };\r\n        }\r\n\r\n        const cameraPos = JSON.parse(this.cameraSettings.position);\r\n       // this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);\r\n\r\n        const lookAt = JSON.parse(this.cameraSettings.lookAt);\r\n       // this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);\r\n\r\n        if (this.cameraSettings.fov && this.camera.isPerspectiveCamera) {\r\n            this.camera.fov = this.cameraSettings.fov;\r\n            this.camera.near = this.cameraSettings.near || 0.1;\r\n            this.camera.far = this.cameraSettings.far || 30000;\r\n            this.camera.updateProjectionMatrix();\r\n        }\r\n\r\n       // this.setupOrbitControls(lookAt);\r\n\r\n     \r\n    }\r\n\r\n    setupOrbitControls(lookAt) {\r\n        if (typeof THREE_.OrbitControls === 'undefined') {\r\n            console.warn('WorldRenderSystem: THREE.OrbitControls not found.');\r\n            return;\r\n        }\r\n\r\n        this.controls = new THREE_.OrbitControls(this.camera, this.renderer.domElement);\r\n        this.controls.mouseButtons = {\r\n            LEFT: null,                           // Disable left click\r\n            MIDDLE: THREE.MOUSE.ROTATE,          // Middle mouse for rotation\r\n            RIGHT: THREE.MOUSE.PAN               // Right mouse for panning (optional)\r\n        };\r\n        this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);\r\n        this.controls.maxPolarAngle = Math.PI / 2.05;\r\n        this.controls.minPolarAngle = 0.1;\r\n        this.controls.enableDamping = true;\r\n        this.controls.dampingFactor = 0.05;\r\n        this.controls.screenSpacePanning = false;\r\n        this.controls.minDistance = 50;\r\n        this.controls.maxDistance = 1000;\r\n        \r\n        this.controls.update();\r\n        \r\n    }\r\n\r\n    setupGround() {\r\n        if (!this.tileMap) {\r\n            console.warn('WorldRenderSystem: No tile map found');\r\n            return;\r\n        }\r\n\r\n        this.groundCanvas = document.createElement('canvas');\r\n        this.groundCanvas.width = this.extendedSize;\r\n        this.groundCanvas.height = this.extendedSize;\r\n        this.groundCtx = this.groundCanvas.getContext('2d');\r\n\r\n        // Fill extension area with sprite texture pattern instead of solid color\r\n        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;\r\n        const tileMapper = this.game.terrainTileMapper;\r\n\r\n        if (tileMapper && tileMapper.layerSpriteSheets && tileMapper.layerSpriteSheets[extensionTerrainType]) {\r\n            // Use the Full sprite (index 0) from the extension terrain type\r\n            const fullSprite = tileMapper.layerSpriteSheets[extensionTerrainType].sprites[0];\r\n\r\n            if (fullSprite) {\r\n                // Tile the sprite across the entire ground canvas\r\n                const spriteSize = fullSprite.width;\r\n                for (let y = 0; y < this.extendedSize; y += spriteSize) {\r\n                    for (let x = 0; x < this.extendedSize; x += spriteSize) {\r\n                        this.groundCtx.drawImage(fullSprite, x, y);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this.groundTexture = new THREE.CanvasTexture(this.groundCanvas);\r\n        this.groundTexture.wrapS = THREE.ClampToEdgeWrapping;\r\n        this.groundTexture.wrapT = THREE.ClampToEdgeWrapping;\r\n        this.groundTexture.minFilter = THREE.NearestFilter;\r\n        this.groundTexture.magFilter = THREE.NearestFilter;\r\n\r\n        const segments = this.heightMapResolution || 1;\r\n        const groundGeometry = new THREE.PlaneGeometry(\r\n            this.extendedSize,\r\n            this.extendedSize,\r\n            segments,\r\n            segments\r\n        );\r\n\r\n        this.groundVertices = groundGeometry.attributes.position;\r\n        const groundMaterial = new THREE.MeshStandardMaterial({\r\n            map: this.groundTexture,\r\n            side: THREE.DoubleSide,\r\n            metalness: 0.0,\r\n            roughness: 1\r\n        });\r\n\r\n        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);\r\n        this.ground.rotation.x = -Math.PI / 2;\r\n        // Center the ground at origin instead of offset\r\n        this.ground.position.set(0, 0, 0);\r\n        this.ground.receiveShadow = true;\r\n        this.ground.castShadow = true;\r\n\r\n        this.scene.add(this.ground);\r\n\r\n        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);\r\n    }\r\n\r\n    createExtensionPlanes() {\r\n        if (!this.tileMap) return;\r\n\r\n        // Get the extension terrain type\r\n        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;\r\n\r\n        // Extension settings\r\n        const extensionDistance = 19000; // How far the planes extend\r\n        const detailedGroundSize = this.extendedSize; // Size of your existing detailed ground\r\n        const halfDetailedSize = detailedGroundSize / 2;\r\n\r\n        // Get the sprite texture for the extension terrain type\r\n        const tileMapper = this.game.terrainTileMapper;\r\n        let extensionTexture;\r\n\r\n        if (tileMapper && tileMapper.layerSpriteSheets && tileMapper.layerSpriteSheets[extensionTerrainType]) {\r\n            // Use the Full sprite (index 0) from the extension terrain type\r\n            const fullSprite = tileMapper.layerSpriteSheets[extensionTerrainType].sprites[0];\r\n\r\n            if (fullSprite) {\r\n                // Create texture from the sprite canvas\r\n                extensionTexture = new THREE.CanvasTexture(fullSprite);\r\n                extensionTexture.wrapS = THREE.RepeatWrapping;\r\n                extensionTexture.wrapT = THREE.RepeatWrapping;\r\n                extensionTexture.minFilter = THREE.NearestFilter;\r\n                extensionTexture.magFilter = THREE.NearestFilter;\r\n            }\r\n        }\r\n\r\n        // Fallback to solid color if sprite not available\r\n        if (!extensionTexture) {\r\n            const terrainTypes = this.tileMap.terrainTypes || [];\r\n            let bgColor = terrainTypes[extensionTerrainType]?.color;\r\n\r\n            if (bgColor?.paletteColor && this.game.palette) {\r\n                bgColor = this.game.palette[bgColor.paletteColor];\r\n            }\r\n\r\n            const extensionColor = bgColor || '#333333';\r\n            const extensionCanvas = document.createElement('canvas');\r\n            extensionCanvas.width = 1;\r\n            extensionCanvas.height = 1;\r\n            const extensionCtx = extensionCanvas.getContext('2d');\r\n            extensionCtx.fillStyle = extensionColor;\r\n            extensionCtx.fillRect(0, 0, 1, 1);\r\n\r\n            extensionTexture = new THREE.CanvasTexture(extensionCanvas);\r\n            extensionTexture.wrapS = THREE.RepeatWrapping;\r\n            extensionTexture.wrapT = THREE.RepeatWrapping;\r\n            extensionTexture.minFilter = THREE.NearestFilter;\r\n            extensionTexture.magFilter = THREE.NearestFilter;\r\n        }\r\n\r\n        // Create material for extension planes with repeating texture\r\n        const extensionMaterial = new THREE.MeshStandardMaterial({\r\n            map: extensionTexture,\r\n            side: THREE.DoubleSide,\r\n            metalness: 0.0,\r\n            roughness: 0.8,\r\n            fog: false\r\n        });\r\n        \r\n        // Store extension planes for cleanup\r\n        this.extensionPlanes = [];\r\n    \r\n        const extensionHeight = extensionTerrainType * this.heightStep;\r\n\r\n        // 1. North plane (positive Z)\r\n        const northGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);\r\n        const northPlane = new THREE.Mesh(northGeometry, extensionMaterial.clone());\r\n        northPlane.rotation.x = -Math.PI / 2;\r\n        northPlane.position.set(0, extensionHeight, halfDetailedSize + extensionDistance / 2);\r\n        northPlane.receiveShadow = true;\r\n        this.scene.add(northPlane);\r\n        this.extensionPlanes.push(northPlane);\r\n        \r\n        // 2. South plane (negative Z)\r\n        const southGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);\r\n        const southPlane = new THREE.Mesh(southGeometry, extensionMaterial.clone());\r\n        southPlane.rotation.x = -Math.PI / 2;\r\n        southPlane.position.set(0, extensionHeight, -halfDetailedSize - extensionDistance / 2);\r\n        southPlane.receiveShadow = true;\r\n        this.scene.add(southPlane);\r\n        this.extensionPlanes.push(southPlane);\r\n        \r\n        // 3. East plane (positive X)\r\n        const eastGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);\r\n        const eastPlane = new THREE.Mesh(eastGeometry, extensionMaterial.clone());\r\n        eastPlane.rotation.x = -Math.PI / 2;\r\n        eastPlane.position.set(halfDetailedSize + extensionDistance / 2, extensionHeight, 0);\r\n        eastPlane.receiveShadow = true;\r\n        this.scene.add(eastPlane);\r\n        this.extensionPlanes.push(eastPlane);\r\n        \r\n        // 4. West plane (negative X)  \r\n        const westGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);\r\n        const westPlane = new THREE.Mesh(westGeometry, extensionMaterial.clone());\r\n        westPlane.rotation.x = -Math.PI / 2;\r\n        westPlane.position.set(-halfDetailedSize - extensionDistance / 2, extensionHeight, 0);\r\n        westPlane.receiveShadow = true;\r\n        this.scene.add(westPlane);\r\n        this.extensionPlanes.push(westPlane);\r\n        \r\n    }\r\n\r\n    renderTerrain() {\r\n        if (!this.tileMap?.terrainMap) {\r\n            console.warn('WorldRenderSystem: No terrain map data found');\r\n            return;\r\n        }\r\n\r\n        \r\n        // Clear terrain canvas\r\n        this.terrainCtx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);\r\n        \r\n        // Draw terrain tiles\r\n        this.drawTerrainTiles(this.tileMap.terrainMap);\r\n        \r\n        // Update ground texture with terrain data\r\n        this.updateGroundTexture();\r\n        \r\n        this.terrainRendered = true;\r\n        \r\n    }\r\n\r\n    drawTerrainTiles(terrainMap) {\r\n        // NEW: Pass heightMap if available (now in tileMap)\r\n        const heightMap = this.tileMap?.heightMap || null;\r\n        this.game.terrainTileMapper.draw(terrainMap, heightMap);\r\n    }\r\n\r\n    updateGroundTexture() {\r\n        if (!this.terrainCanvas) {\r\n            console.warn('WorldRenderSystem: No terrain canvas available for ground texture update');\r\n            return;\r\n        }\r\n\r\n        // Draw terrain data onto ground canvas\r\n        this.groundCtx.drawImage(\r\n            this.game.terrainTileMapper.canvas, \r\n            this.extensionSize, \r\n            this.extensionSize\r\n        );\r\n        this.groundTexture.needsUpdate = true;\r\n        \r\n        if (this.heightMapSettings?.enabled) {\r\n            this.updateHeightMap();\r\n        }\r\n        \r\n        // Generate liquid surfaces\r\n        if (this.tileMap?.terrainTypes) {\r\n            this.generateLiquidSurfaceMesh(0); // Water\r\n            this.generateLiquidSurfaceMesh(1); // Lava/other liquid\r\n        }\r\n\r\n        // Add grass\r\n       // this.addGrassToTerrain();\r\n\r\n        // Render environment objects\r\n        this.renderEnvironmentObjects();\r\n    }\r\n\r\n\r\n    renderEnvironmentObjects() {\r\n        if (!this.scene || !this.tileMap.environmentObjects || this.tileMap.environmentObjects.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Create entities for each environment object\r\n        this.tileMap.environmentObjects.forEach(obj => {\r\n            this.createEnvironmentEntity(obj);\r\n        });\r\n    }\r\n\r\n    createEnvironmentEntity(envObj) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n\r\n        const unitType = this.game.getCollections().worldObjects[envObj.type];\r\n        unitType.collection = \"worldObjects\";\r\n        unitType.id = envObj.type;\r\n        // Calculate world position (matching your existing offset logic)\r\n        const worldX = (envObj.x + this.extensionSize) - this.extendedSize / 2;\r\n        const worldZ = (envObj.y + this.extensionSize) - this.extendedSize / 2;\r\n        \r\n        // Get terrain height\r\n        let height = 0;\r\n        if (this.heightMapSettings?.enabled) {\r\n            height = this.game.gameManager.call('getTerrainHeightAtPosition', worldX, worldZ);\r\n        }\r\n\r\n        // Create entity with unique ID\r\n        const entityId = this.game.createEntity(`env_${envObj.type}_${envObj.x}_${envObj.y}`);\r\n        \r\n        // Add Position component\r\n        this.game.addComponent(entityId, ComponentTypes.POSITION, \r\n            Components.Position(worldX, height, worldZ));\r\n                \r\n        // Add Renderable component\r\n        this.game.addComponent(entityId, ComponentTypes.RENDERABLE, \r\n            Components.Renderable('worldObjects', envObj.type, 1024));\r\n        \r\n        // Add Animation component for rotation and scale\r\n        const rotation = Math.random() * Math.PI * 2;\r\n        const scale = (0.8 + Math.random() * 0.4) * (envObj.type === 'rock' ? 1 : 50);\r\n        this.game.addComponent(entityId, ComponentTypes.ANIMATION, \r\n            Components.Animation(scale, rotation, 0));\r\n        \r\n        // Add Facing component for rotation\r\n        this.game.addComponent(entityId, ComponentTypes.FACING, \r\n            Components.Facing(rotation));\r\n        \r\n         this.game.addComponent(entityId, ComponentTypes.UNIT_TYPE, \r\n            Components.UnitType(\r\n                unitType\r\n            ));\r\n        \r\n        // Add Team component (neutral for environment objects)\r\n        this.game.addComponent(entityId, ComponentTypes.TEAM, \r\n            Components.Team('neutral'));\r\n\r\n        console.log('created tree');\r\n        this.game.triggerEvent('onEntityPositionUpdated', entityId);\r\n    }\r\n\r\n    onWindowResize() {\r\n        if (!this.camera || !this.renderer) return;\r\n        \r\n        const width = window.innerWidth;\r\n        const height = window.innerHeight;\r\n\r\n        this.camera.aspect = width / height;\r\n        this.camera.updateProjectionMatrix();\r\n        this.renderer.setSize(width, height);\r\n        \r\n        if (this.composer) {\r\n            this.composer.setSize(width, height);\r\n        }\r\n    }\r\n\r\n    update() {\r\n        if (!this.initialized) return;\r\n\r\n        this.timer += this.game.state.deltaTime;\r\n\r\n        if (this.controls) {\r\n            this.controls.update();\r\n        }\r\n\r\n        for (const key in this.uniforms) {\r\n            if (this.uniforms[key].time) {\r\n                this.uniforms[key].time.value = this.timer;\r\n            }\r\n        }\r\n\r\n        this.render();\r\n    }\r\n\r\n    render() {\r\n        if (!this.scene || !this.camera || !this.renderer) {\r\n            console.warn('WorldRenderSystem: Missing components for rendering');\r\n            return;\r\n        }\r\n\r\n        const composer = this.game.gameManager.call('getPostProcessingComposer');\r\n        if (composer) {\r\n            this.game.gameManager.call('renderPostProcessing');\r\n        } else {\r\n            this.renderer.render(this.scene, this.camera);\r\n        }\r\n    }\r\n\r\n    updateHeightMap() {\r\n        if (!this.heightMapSettings.enabled || !this.game.terrainTileMapper.heightMapCanvas) {\r\n            console.warn('Height map not available from TileMapper');\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const heightMapCanvas = this.game.terrainTileMapper.heightMapCanvas;\r\n            const heightMapCtx = heightMapCanvas.getContext('2d', { willReadFrequently: true });\r\n            \r\n            // Get the height map image data directly from TileMapper\r\n            const heightMapImageData = heightMapCtx.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height);\r\n            const heightData = heightMapImageData.data;\r\n\r\n            this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);\r\n\r\n            // Set extension area to extension terrain height\r\n            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;\r\n            const extensionHeight = extensionTerrainType * this.heightStep;\r\n\r\n            // Initialize all points with extension height\r\n            for (let z = 0; z < this.extendedSize; z++) {\r\n                for (let x = 0; x < this.extendedSize; x++) {\r\n                    this.heightMapData[z * this.extendedSize + x] = extensionHeight;\r\n                }\r\n            }\r\n\r\n            // Process the actual terrain area using height map data\r\n            const scaleX = heightMapCanvas.width / this.terrainSize;\r\n            const scaleZ = heightMapCanvas.height / this.terrainSize;\r\n\r\n            for (let z = 0; z < this.terrainSize; z++) {\r\n                for (let x = 0; x < this.terrainSize; x++) {\r\n                    // Sample from height map\r\n                    const heightMapX = Math.floor(x * scaleX);\r\n                    const heightMapZ = Math.floor(z * scaleZ);\r\n                    \r\n                    const pixelIndex = (heightMapZ * heightMapCanvas.width + heightMapX) * 4;\r\n                    const heightValue = heightData[pixelIndex]; // Red channel (grayscale)\r\n                    \r\n                    // Convert grayscale value back to height index\r\n                    const heightIndex = Math.floor(heightValue / 32); // Inverse of scaling in TileMapper\r\n                    let height = heightIndex * this.heightStep;\r\n\r\n                    // Check neighboring pixels for cliff smoothing if needed\r\n                    let neighborCheckDist = this.heightMapSettings.resolutionDivisor || 1;\r\n                    const neighbors = [\r\n                        { x: x - neighborCheckDist, z: z },   // left\r\n                        { x: x + neighborCheckDist, z: z },   // right\r\n                        { x: x, z: z - neighborCheckDist },   // top\r\n                        { x: x, z: z + neighborCheckDist },   // bottom\r\n                        { x: x - neighborCheckDist, z: z - neighborCheckDist }, // top-left\r\n                        { x: x + neighborCheckDist, z: z - neighborCheckDist }, // top-right\r\n                        { x: x - neighborCheckDist, z: z + neighborCheckDist }, // bottom-left\r\n                        { x: x + neighborCheckDist, z: z + neighborCheckDist }  // bottom-right\r\n                    ];\r\n\r\n                    let lowestNeighborHeight = height;\r\n                    for (const neighbor of neighbors) {\r\n                        if (neighbor.x >= 0 && neighbor.x < this.terrainSize && \r\n                            neighbor.z >= 0 && neighbor.z < this.terrainSize) {\r\n                            \r\n                            const neighborHMapX = Math.floor(neighbor.x * scaleX);\r\n                            const neighborHMapZ = Math.floor(neighbor.z * scaleZ);\r\n                            const neighborIndex = (neighborHMapZ * heightMapCanvas.width + neighborHMapX) * 4;\r\n                            const neighborHeightValue = heightData[neighborIndex];\r\n                            const neighborHeightIndex = Math.floor(neighborHeightValue / 32);\r\n                            const neighborHeight = neighborHeightIndex * this.heightStep;\r\n                            \r\n                            if (neighborHeight < lowestNeighborHeight) {\r\n                                lowestNeighborHeight = neighborHeight;\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    // Use the lowest neighbor height for cliff smoothing\r\n                    height = lowestNeighborHeight;\r\n                    // Set height in extended coordinate system\r\n                    const extX = x + this.extensionSize;\r\n                    const extZ = z + this.extensionSize;\r\n                    this.heightMapData[extZ * this.extendedSize + extX] = height;\r\n                }\r\n            }\r\n\r\n            this.applyHeightMapToGeometry();\r\n\r\n        } catch (e) {\r\n            console.warn('Failed to update height map from TileMapper:', e);\r\n        }\r\n    }\r\n    findClosestTerrainType(r, g, b, terrainTypeColors) {\r\n        let minDistance = Infinity;\r\n        let bestTypeIndex = null;\r\n        const toleranceSquared = 36;\r\n\r\n        for (const [colorKey, typeIndex] of Object.entries(terrainTypeColors)) {\r\n            const [cr, cg, cb] = colorKey.split(',').map(Number);\r\n            const distance = ((r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2);\r\n            \r\n            if (distance < minDistance && distance < toleranceSquared) {\r\n                minDistance = distance;\r\n                bestTypeIndex = typeIndex;\r\n            }\r\n        }\r\n\r\n        return bestTypeIndex;\r\n    }\r\n\r\n    createTerrainTypeColorMap() {\r\n        const colorMap = {};\r\n        const terrainTypes = this.tileMap.terrainTypes || [];\r\n\r\n        for (let i = 0; i < terrainTypes.length; i++) {\r\n            const terrainType = terrainTypes[i];\r\n            let color = terrainType.color || {};\r\n\r\n            if (color.paletteColor && this.game.palette) {\r\n                const hexColor = this.game.palette[color.paletteColor];\r\n                if (hexColor) {\r\n                    const r = parseInt(hexColor.slice(1, 3), 16);\r\n                    const g = parseInt(hexColor.slice(3, 5), 16);\r\n                    const b = parseInt(hexColor.slice(5, 7), 16);\r\n                    colorMap[`${r},${g},${b}`] = i;\r\n                }\r\n            } else {\r\n                const hexColor = color;\r\n                if (hexColor) {\r\n                    const r = parseInt(hexColor.slice(1, 3), 16);\r\n                    const g = parseInt(hexColor.slice(3, 5), 16);\r\n                    const b = parseInt(hexColor.slice(5, 7), 16);\r\n                    colorMap[`${r},${g},${b}`] = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        return colorMap;\r\n    }\r\n\r\n    applyHeightMapToGeometry() {\r\n        if (!this.ground || !this.groundVertices) return;\r\n\r\n        const positions = this.groundVertices.array;\r\n        const geometry = this.ground.geometry;\r\n        const segments = this.heightMapResolution;\r\n        const verticesPerRow = segments + 1;\r\n\r\n        // First pass: Update vertex heights\r\n        for (let z = 0; z < verticesPerRow; z++) {\r\n            for (let x = 0; x < verticesPerRow; x++) {\r\n                const vertexIndex = (z * verticesPerRow + x);\r\n                const idx = vertexIndex * 3;\r\n\r\n                const nx = x / segments;\r\n                const nz = z / segments;\r\n\r\n                const terrainX = Math.floor(nx * (this.extendedSize));\r\n                const terrainZ = Math.floor(nz * (this.extendedSize));\r\n\r\n                const heightIndex = terrainZ * this.extendedSize + terrainX;\r\n                const height = this.heightMapData[heightIndex] || 0;\r\n\r\n                positions[idx + 2] = height;\r\n            }\r\n        }\r\n\r\n        this.groundVertices.needsUpdate = true;\r\n        geometry.computeVertexNormals();\r\n        \r\n        // Second pass: Generate cliff entities using TileMap analysis\r\n        this.generateCliffEntities();\r\n    }\r\n\r\n    generateCliffEntities() {\r\n        if (!this.heightMapData || !this.tileMap?.terrainMap || !this.game.terrainTileMapper) return;\r\n\r\n        const terrainMap = this.tileMap.terrainMap;\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const rows = terrainMap.length;\r\n        const cols = terrainMap[0].length;\r\n\r\n        const mapAnalysis = this.game.terrainTileMapper.analyzeMap();\r\n\r\n        mapAnalysis.forEach((tile, index) => {\r\n            const x = (index % cols);\r\n            const z = Math.floor(index / cols);\r\n\r\n            // Use heightAnalysis for cliff placement (cliffs are based on height differences)\r\n            const heightAnalysis = tile.heightAnalysis;\r\n\r\n            // Only process tiles that have lower neighbors (cliff edges)\r\n            if (heightAnalysis.neighborLowerCount > 0 || heightAnalysis.cornerLowerCount > 0) {\r\n                this.placeCliffAtomsForTile(x, z, heightAnalysis, gridSize);\r\n            }\r\n        });\r\n    }\r\n\r\n    placeCliffAtomsForTile(x, z, heightAnalysis, gridSize) {\r\n\r\n        if(this.game.gameManager.call('hasRampAt', x, z)){\r\n            return;\r\n        }\r\n        // Convert grid coordinates to world coordinates\r\n        const worldX = (x * gridSize + this.extensionSize) - this.extendedSize / 2;\r\n        const worldZ = (z * gridSize + this.extensionSize) - this.extendedSize / 2;\r\n        const offset = 0;\r\n        const halfOffset = offset / 2;\r\n        const halfGrid = gridSize / 2 + halfOffset;\r\n        const quarterGrid = gridSize / 4 + halfOffset / 2; // Center of each quadrant\r\n\r\n\r\n        // Calculate cliff bottom height\r\n        let cliffBottomHeightIndex = heightAnalysis.heightIndex - 2;\r\n        if (heightAnalysis.neighborLowerCount == 0 && heightAnalysis.cornerLowerCount == 0) {\r\n            cliffBottomHeightIndex += 1;\r\n        }\r\n        const cliffHeight = cliffBottomHeightIndex * this.heightStep;\r\n\r\n        // Array to store atom placements\r\n        const atomPlacements = [];\r\n\r\n        // Helper function to add atom\r\n        const addAtom = (type, localX, localZ, rotation) => {\r\n            atomPlacements.push({\r\n                type,\r\n                x: worldX + localX - halfOffset,\r\n                z: worldZ + localZ - halfOffset,\r\n                rotation\r\n            });\r\n        };\r\n\r\n        // Track which quadrants are occupied by corners\r\n        const topLeftOccupied = (heightAnalysis.topLess && heightAnalysis.leftLess) ||\r\n                                (heightAnalysis.cornerTopLeftLess && !heightAnalysis.topLess && !heightAnalysis.leftLess);\r\n        const topRightOccupied = (heightAnalysis.topLess && heightAnalysis.rightLess) ||\r\n                                (heightAnalysis.cornerTopRightLess && !heightAnalysis.topLess && !heightAnalysis.rightLess);\r\n        const botLeftOccupied = (heightAnalysis.botLess && heightAnalysis.leftLess) ||\r\n                                (heightAnalysis.cornerBottomLeftLess && !heightAnalysis.botLess && !heightAnalysis.leftLess);\r\n        const botRightOccupied = (heightAnalysis.botLess && heightAnalysis.rightLess) ||\r\n                                (heightAnalysis.cornerBottomRightLess && !heightAnalysis.botLess && !heightAnalysis.rightLess);\r\n\r\n        // Place corners first (they take priority) - CENTERED in their quadrants\r\n        // Outer corners\r\n        if (heightAnalysis.topLess && heightAnalysis.leftLess) {\r\n            addAtom('atom_one', quarterGrid, quarterGrid, 0);\r\n        }\r\n\r\n        if (heightAnalysis.topLess && heightAnalysis.rightLess) {\r\n            addAtom('atom_one', quarterGrid * 3, quarterGrid, Math.PI / 2);\r\n        }\r\n\r\n        if (heightAnalysis.botLess && heightAnalysis.leftLess) {\r\n            addAtom('atom_one', quarterGrid, quarterGrid * 3, -Math.PI / 2);\r\n        }\r\n\r\n        if (heightAnalysis.botLess && heightAnalysis.rightLess) {\r\n            addAtom('atom_one', quarterGrid * 3, quarterGrid * 3, Math.PI);\r\n        }\r\n\r\n        // Inner corners - CENTERED in their quadrants\r\n        if (heightAnalysis.cornerTopLeftLess && !heightAnalysis.topLess && !heightAnalysis.leftLess) {\r\n            addAtom('atom_three', quarterGrid, quarterGrid, 0);\r\n        }\r\n\r\n        if (heightAnalysis.cornerTopRightLess && !heightAnalysis.topLess && !heightAnalysis.rightLess) {\r\n            addAtom('atom_three', quarterGrid * 3, quarterGrid, Math.PI / 2);\r\n        }\r\n\r\n        if (heightAnalysis.cornerBottomLeftLess && !heightAnalysis.botLess && !heightAnalysis.leftLess) {\r\n            addAtom('atom_three', quarterGrid, quarterGrid * 3, -Math.PI / 2);\r\n        }\r\n\r\n        if (heightAnalysis.cornerBottomRightLess && !heightAnalysis.botLess && !heightAnalysis.rightLess) {\r\n            addAtom('atom_three', quarterGrid * 3, quarterGrid * 3, Math.PI);\r\n        }\r\n\r\n        // Place edges in empty quadrants - CENTERED in their quadrants\r\n        // Top edge uses top-left and top-right quadrants\r\n        if (heightAnalysis.topLess) {\r\n            if (!topLeftOccupied) {\r\n                addAtom('atom_two', quarterGrid, quarterGrid, Math.PI / 2);\r\n            }\r\n            if (!topRightOccupied) {\r\n                addAtom('atom_two', quarterGrid * 3, quarterGrid, Math.PI / 2);\r\n            }\r\n        }\r\n\r\n        // Bottom edge uses bottom-left and bottom-right quadrants\r\n        if (heightAnalysis.botLess) {\r\n            if (!botLeftOccupied) {\r\n                addAtom('atom_two', quarterGrid, quarterGrid * 3, -Math.PI / 2);\r\n            }\r\n            if (!botRightOccupied) {\r\n                addAtom('atom_two', quarterGrid * 3, quarterGrid * 3, -Math.PI / 2);\r\n            }\r\n        }\r\n\r\n        // Left edge uses top-left and bottom-left quadrants\r\n        if (heightAnalysis.leftLess) {\r\n            if (!topLeftOccupied) {\r\n                addAtom('atom_two', quarterGrid, quarterGrid, 0);\r\n            }\r\n            if (!botLeftOccupied) {\r\n                addAtom('atom_two', quarterGrid, quarterGrid * 3, 0);\r\n            }\r\n        }\r\n\r\n        // Right edge uses top-right and bottom-right quadrants\r\n        if (heightAnalysis.rightLess) {\r\n            if (!topRightOccupied) {\r\n                addAtom('atom_two', quarterGrid * 3, quarterGrid, Math.PI);\r\n            }\r\n            if (!botRightOccupied) {\r\n                addAtom('atom_two', quarterGrid * 3, quarterGrid * 3, Math.PI);\r\n            }\r\n        }\r\n\r\n        // Create entities for all atoms\r\n        atomPlacements.forEach(atom => {\r\n            this.createCliffEntity(atom.type, atom.x, cliffHeight, atom.z, atom.rotation);\r\n        });\r\n    }\r\n\r\n\r\n    resetCliffs() {\r\n        this.destroyAllCliffs();\r\n        this.generateCliffEntities();\r\n    }\r\n\r\n    destroyAllCliffs() {\r\n        const cliffs = this.game.getEntitiesWith('cliff');\r\n        cliffs.forEach((cliff) => {\r\n            this.game.destroyEntity(cliff);\r\n        });\r\n    }\r\n\r\n    createCliffEntity(type, worldX, worldY, worldZ, rotation) {\r\n        const cliffsType = \"cliffs\";\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const Components = this.game.componentManager.getComponents();\r\n\r\n        const unitType = this.game.getCollections()[cliffsType]?.[type];\r\n        if (!unitType) {\r\n            console.warn(`Cliff type ${type} not found in cliffs collection`);\r\n            return;\r\n        }\r\n\r\n        unitType.collection = cliffsType;\r\n        unitType.id = type;        \r\n\r\n        // Create entity with unique ID\r\n        const entityId = this.game.createEntity(`${cliffsType}_${type}_${Math.round(worldX)}_${Math.round(worldZ)}_${Math.random()}`);\r\n\r\n        // Add Position component\r\n        this.game.addComponent(entityId, ComponentTypes.POSITION, \r\n            Components.Position(worldX, worldY, worldZ));\r\n\r\n        // Add Renderable component\r\n        this.game.addComponent(entityId, ComponentTypes.RENDERABLE, \r\n            Components.Renderable(cliffsType, type, 1024));\r\n\r\n        // Add Animation component for rotation and scale\r\n        this.game.addComponent(entityId, ComponentTypes.ANIMATION, \r\n            Components.Animation(1, rotation, 0));\r\n\r\n        // Add Facing component for rotation\r\n        this.game.addComponent(entityId, ComponentTypes.FACING, \r\n            Components.Facing(rotation));\r\n\r\n        // Add UnitType component\r\n        this.game.addComponent(entityId, ComponentTypes.UNIT_TYPE, \r\n            Components.UnitType(unitType));\r\n\r\n        // Add Team component (neutral for cliffs)\r\n        this.game.addComponent(entityId, ComponentTypes.TEAM, \r\n            Components.Team('cliff'));\r\n\r\n        this.game.addComponent(entityId, \"cliff\", { type });\r\n\r\n        this.game.triggerEvent('onEntityPositionUpdated', entityId);\r\n    }\r\n\r\n    generateLiquidSurfaceMesh(terrainType) {\r\n        const terrainMap = this.tileMap.terrainMap;\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const rows = terrainMap.length;\r\n        const cols = terrainMap[0].length;\r\n        \r\n        // Arrays to store vertices, indices, and UVs for the BufferGeometry\r\n        const vertices = [];\r\n        const indices = [];\r\n        const uvs = [];\r\n        \r\n        // Amount to extend the perimeter (e.g., 10% of gridSize)\r\n        const extensionAmount = gridSize * 0.25; // Adjust as needed        \r\n\r\n        // Calculate centering offset to match ground positioning\r\n        const terrainWorldWidth = cols * gridSize;\r\n        const terrainWorldHeight = rows * gridSize;\r\n        const centerOffsetX = -terrainWorldWidth / 2;\r\n        const centerOffsetZ = -terrainWorldHeight / 2;\r\n\r\n        // Helper function to check if a tile is a water tile\r\n        const isWaterTile = (x, z) => {\r\n            if (x < 0 || x >= cols || z < 0 || z >= rows) return false;\r\n            return terrainMap[z][x] === terrainType;\r\n        };\r\n        \r\n        // Step 1: Generate a grid of vertices, but only for positions needed by water tiles\r\n        const usedPositions = new Set();\r\n        for (let z = 0; z < rows; z++) {\r\n            for (let x = 0; x < cols; x++) {\r\n                if (terrainMap[z][x] === terrainType) {\r\n                    usedPositions.add(`${x},${z}`);     // Bottom-left\r\n                    usedPositions.add(`${x + 1},${z}`); // Bottom-right\r\n                    usedPositions.add(`${x + 1},${z + 1}`); // Bottom-right in your view (+z is south)\r\n                    usedPositions.add(`${x},${z + 1}`); // Top-left\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Step 2: Create vertices for all used positions and store their original positions\r\n        const positionToVertexIndex = new Map();\r\n        const originalPositions = []; // Store original (x, z) for each vertex\r\n        let vertexIndex = 0;\r\n        for (const pos of usedPositions) {\r\n            const [x, z] = pos.split(',').map(Number);\r\n            positionToVertexIndex.set(pos, vertexIndex++);\r\n            \r\n            // Apply centering offset to match ground positioning\r\n            const worldX = x * gridSize + centerOffsetX;\r\n            const worldZ = z * gridSize + centerOffsetZ;\r\n            \r\n            vertices.push(worldX, 0.1, worldZ);\r\n            originalPositions.push([x, z]); // Store original grid position\r\n            uvs.push(x, z); // UVs based on grid position\r\n        }\r\n        \r\n        // Step 3: Generate indices for water tiles, connecting them into a single mesh\r\n        for (let z = 0; z < rows; z++) {\r\n            for (let x = 0; x < cols; x++) {\r\n                if (terrainMap[z][x] === terrainType) {\r\n                    const bl = positionToVertexIndex.get(`${x},${z}`);\r\n                    const br = positionToVertexIndex.get(`${x + 1},${z}`);\r\n                    const tr = positionToVertexIndex.get(`${x + 1},${z + 1}`); // Bottom-right in your view\r\n                    const tl = positionToVertexIndex.get(`${x},${z + 1}`);\r\n\r\n                    indices.push(bl, br, tl);\r\n                    indices.push(br, tr, tl);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Step 4: Identify perimeter vertices and their extension directions\r\n        const perimeterExtensions = new Map(); // Map vertexIndex to { extendLeft, extendRight, extendUp, extendDown }\r\n        for (let z = 0; z < rows; z++) {\r\n            for (let x = 0; x < cols; x++) {\r\n                if (terrainMap[z][x] === terrainType) {\r\n                    const isLeftEdge = !isWaterTile(x - 1, z);\r\n                    const isRightEdge = !isWaterTile(x + 1, z);\r\n                    const isBottomEdge = !isWaterTile(x, z - 1); // North\r\n                    const isTopEdge = !isWaterTile(x, z + 1);    // South\r\n\r\n                    // Bottom-left vertex (x, z)\r\n                    if (isLeftEdge || isBottomEdge) {\r\n                        const vIdx = positionToVertexIndex.get(`${x},${z}`);\r\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\r\n                        const ext = perimeterExtensions.get(vIdx);\r\n                        if (isLeftEdge) ext.extendLeft = true;\r\n                        if (isBottomEdge) ext.extendUp = true; // North\r\n                    }\r\n\r\n                    // Bottom-right vertex (x + 1, z)\r\n                    if (isRightEdge || isBottomEdge) {\r\n                        const vIdx = positionToVertexIndex.get(`${x + 1},${z}`);\r\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\r\n                        const ext = perimeterExtensions.get(vIdx);\r\n                        if (isRightEdge) ext.extendRight = true;\r\n                        if (isBottomEdge) ext.extendUp = true; // North\r\n                    }\r\n\r\n                    // Top-right vertex (x + 1, z + 1) - Bottom-right in your view\r\n                    if (isRightEdge || isTopEdge) {\r\n                        const vIdx = positionToVertexIndex.get(`${x + 1},${z + 1}`);\r\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\r\n                        const ext = perimeterExtensions.get(vIdx);\r\n                        if (isRightEdge) ext.extendRight = true;\r\n                        if (isTopEdge) ext.extendDown = true; // South\r\n                    }\r\n\r\n                    // Top-left vertex (x, z + 1)\r\n                    if (isLeftEdge || isTopEdge) {\r\n                        const vIdx = positionToVertexIndex.get(`${x},${z + 1}`);\r\n                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });\r\n                        const ext = perimeterExtensions.get(vIdx);\r\n                        if (isLeftEdge) ext.extendLeft = true;\r\n                        if (isTopEdge) ext.extendDown = true; // South\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Step 5: Apply perimeter extensions\r\n        perimeterExtensions.forEach((ext, vertexIndex) => {\r\n            const idx = vertexIndex * 3;\r\n            const [origX, origZ] = originalPositions[vertexIndex];     \r\n\r\n            if (ext.extendLeft) vertices[idx] -= extensionAmount; // Extend left\r\n            if (ext.extendRight) vertices[idx] += extensionAmount; // Extend right\r\n            if (ext.extendUp) vertices[idx + 2] -= extensionAmount; // Extend north (decrease z)\r\n            if (ext.extendDown) vertices[idx + 2] += extensionAmount; // Extend south (increase z)\r\n\r\n       \r\n        });\r\n        \r\n        // Step 6: Create the BufferGeometry\r\n        const geometry = new THREE.BufferGeometry();\r\n        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\r\n        geometry.setIndex(indices);\r\n        geometry.computeVertexNormals(); // For lighting\r\n        \r\n        // Parse the hex color to RGB\r\n        const parseHexColor = (hex) => {\r\n            const r = parseInt(hex.slice(1, 3), 16) / 255;\r\n            const g = parseInt(hex.slice(3, 5), 16) / 255;\r\n            const b = parseInt(hex.slice(5, 7), 16) / 255;\r\n            return { r, g, b };\r\n        };\r\n        \r\n        const waterShader = this.game.getCollections().shaders[this.level.waterShader];\r\n        \r\n        // Use the hex color in a ShaderMaterial\r\n        this.uniforms[terrainType] = JSON.parse(waterShader.uniforms);\r\n        let vectorizeProps = JSON.parse(waterShader.vectors);\r\n        vectorizeProps.forEach((prop => {\r\n            if (this.uniforms[terrainType][prop]) {\r\n                if( prop.toLowerCase().endsWith(\"color\")){\r\n                    const colorToUse = this.tileMap.terrainTypes[terrainType].color;\r\n                    const { r, g, b } = parseHexColor(colorToUse);\r\n                    this.uniforms[terrainType][prop].value = new THREE.Vector3(r, g, b);\r\n                } else {\r\n                    let arr = this.uniforms[terrainType][prop].value;\r\n                    this.uniforms[terrainType][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);\r\n                }\r\n            }\r\n        }));\r\n        \r\n        this.uniforms[terrainType].fogColor = { value: new THREE.Color(this.fogSettings.color) };\r\n        this.uniforms[terrainType].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;\r\n        \r\n        // Reference the uniforms\r\n        const uniforms = this.uniforms[terrainType];\r\n        \r\n        // Create the shader material\r\n        const material = new THREE.ShaderMaterial({\r\n            uniforms: uniforms,\r\n            vertexShader: waterShader.vertexScript,\r\n            fragmentShader: waterShader.fragmentScript,\r\n            side: THREE.DoubleSide,\r\n            transparent: true\r\n        });\r\n\r\n        // Replace the MeshBasicMaterial with this ShaderMaterial in the mesh creation\r\n        const waterMesh = new THREE.Mesh(geometry, material);        \r\n        waterMesh.position.y = (terrainType + 1) * this.heightMapSettings.heightStep;\r\n        \r\n        // No additional position offset needed since vertices are already centered\r\n        waterMesh.position.x = 0;\r\n        waterMesh.position.z = 0;\r\n        \r\n        this.scene.add(waterMesh);\r\n        this.liquidMeshes.push(waterMesh);\r\n\r\n    }\r\n\r\n    addGrassToTerrain() {\r\n        const bladeWidth = 12;\r\n        const bladeHeight = 18;\r\n        const grassGeometry = this.createCurvedBladeGeometry(bladeWidth, bladeHeight);\r\n        grassGeometry.translate(0, bladeHeight / 2, 0);\r\n        const grassCount = 50000;\r\n\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const phases = new Float32Array(grassCount);\r\n        for (let i = 0; i < grassCount; i++) {\r\n            phases[i] = Math.random() * Math.PI * 2;\r\n        }\r\n        grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(phases, 1));\r\n\r\n        const grassTexture = this.createGrassTexture();\r\n        const grassShader = this.game.getCollections().shaders[this.level.grassShader];\r\n        this.uniforms['grass'] = JSON.parse(grassShader.uniforms);\r\n        \r\n        this.uniforms['grass'].windDirection = { value: new THREE.Vector2(this.uniforms['grass'].windDirection.value[0], this.uniforms['grass'].windDirection.value[1]).normalize()};\r\n        this.uniforms['grass'].map = { value: grassTexture };\r\n        this.uniforms['grass'].fogColor = { value: new THREE.Color(this.fogSettings.color) };\r\n        this.uniforms['grass'].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;\r\n        const lightDirection = new THREE.Vector3();\r\n        lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);\r\n        lightDirection.normalize();\r\n\r\n        this.uniforms['grass'].skyColor =  { value: new THREE.Color(this.lightingSettings.skyColor) }; // HemisphereLight sky color\r\n        this.uniforms['grass'].groundColor = { value: new THREE.Color(this.lightingSettings.groundColor) }; // HemisphereLight ground color\r\n        this.uniforms['grass'].hemisphereIntensity = { value: this.lightingSettings.hemisphereIntensity };\r\n\r\n        const uniforms = this.uniforms['grass'];\r\n        this.grassMaterial = new THREE.ShaderMaterial({\r\n            vertexShader: grassShader.vertexScript,\r\n            fragmentShader: grassShader.fragmentScript,\r\n            uniforms: uniforms,\r\n            transparent: true\r\n        });\r\n\r\n        this.grassShader = this.grassMaterial;\r\n        \r\n        grassGeometry.computeVertexNormals(); \r\n        const grass = new THREE.InstancedMesh(grassGeometry, this.grassMaterial, grassCount);\r\n        grass.castShadow = true;\r\n        grass.receiveShadow = false;\r\n\r\n        const dummy = new THREE.Object3D();\r\n        const grassArea = this.extendedSize;  \r\n        const ctx = this.groundCanvas.getContext('2d');\r\n        const terrainData = ctx.getImageData(0, 0, this.groundCanvas.width, this.groundCanvas.height).data;\r\n\r\n        // Create a density map for grass placement\r\n        const densityMap = new Float32Array(this.extendedSize * this.extendedSize);\r\n        for (let z = 0; z < this.extendedSize; z++) {\r\n            for (let x = 0; x < this.extendedSize; x++) {\r\n                // Check current pixel for green dominance\r\n                const pixelIndex = (z * this.groundCanvas.width + x) * 4;\r\n                const isGreenDominant = (pixel) => {\r\n                    const r = terrainData[pixel];\r\n                    const g = terrainData[pixel + 1];\r\n                    const b = terrainData[pixel + 2];\r\n                    return g > r && g > b;\r\n                };\r\n\r\n                // Only set density if current pixel and all neighbors are green\r\n                if (isGreenDominant(pixelIndex)) {\r\n                    // Check 8 neighboring pixels\r\n                    let checkDist = Math.ceil(gridSize / 10);\r\n                    const neighbors = [\r\n                        [-checkDist, -checkDist], [0, -checkDist], [checkDist, -checkDist],\r\n                        [-checkDist,  0],                           [checkDist,  0],\r\n                        [-checkDist,  checkDist], [0,  checkDist], [checkDist,  checkDist]\r\n                    ];\r\n\r\n                    let allNeighborsGreen = true;\r\n                    for (const [dx, dz] of neighbors) {\r\n                        const nx = x + dx;\r\n                        const nz = z + dz;\r\n                        \r\n                        // Skip if neighbor is outside bounds\r\n                        if (nx < 0 || nx >= this.extendedSize || nz < 0 || nz >= this.extendedSize) {\r\n                            allNeighborsGreen = false;\r\n                            break;\r\n                        }\r\n\r\n                        const neighborIndex = (nz * this.groundCanvas.width + nx) * 4;\r\n                        if (!isGreenDominant(neighborIndex)) {\r\n                            allNeighborsGreen = false;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    densityMap[z * this.extendedSize + x] = allNeighborsGreen ? 1 : 0;\r\n                } else {\r\n                    densityMap[z * this.extendedSize + x] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Place grass based on density\r\n        let placed = 0;\r\n        for (let i = 0; i < grassCount * 2 && placed < grassCount; i++) {\r\n            const x = Math.floor(Math.random() * grassArea);\r\n            const z = Math.floor(Math.random() * grassArea);\r\n            if (densityMap[z * this.extendedSize + x] > 0) {\r\n                const rotationY = Math.random() * Math.PI * 2;\r\n                const scale = 0.7 + Math.random() * 0.5;\r\n                let height = this.heightMapSettings.enabled\r\n                    ? this.heightMapData[Math.min(z, this.extendedSize - 1) * this.extendedSize + Math.min(x, this.extendedSize - 1)] || 0\r\n                    : 0;\r\n                dummy.position.set(x - grassArea / 2 , height - bladeHeight, z - grassArea / 2);\r\n                dummy.rotation.set(0, rotationY, 0);\r\n                dummy.scale.set(scale, scale, scale);\r\n                dummy.updateMatrix();\r\n                grass.setMatrixAt(placed++, dummy.matrix);\r\n            }\r\n        }\r\n\r\n        grass.instanceMatrix.needsUpdate = true;\r\n        this.scene.add(grass);\r\n        this.grass = grass;\r\n    }\r\n    \r\n    createCurvedBladeGeometry(width = 0.1, height = 1) {\r\n        const shape = new THREE.Shape();\r\n        shape.moveTo(0, 0);\r\n        shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);\r\n    \r\n        const shapeGeom = new THREE.ShapeGeometry(shape, 12);\r\n        const positions = shapeGeom.attributes.position.array;\r\n        const uvs = shapeGeom.attributes.uv.array;\r\n        const vertexCount = positions.length / 3;\r\n    \r\n        const newUVs = new Float32Array(uvs.length);\r\n        const newNormals = new Float32Array(positions.length);\r\n    \r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const posIndex = i * 3;\r\n            const uvIndex = i * 2;\r\n            const x = positions[posIndex];\r\n            const y = positions[posIndex + 1];\r\n            const normalizedY = y / height;\r\n    \r\n            newUVs[uvIndex] = uvs[uvIndex];\r\n            newUVs[uvIndex + 1] = normalizedY;\r\n    \r\n            // Compute normal: approximate outward direction along curve\r\n            const t = y / height; // Parameter along curve\r\n            const curveX = width * 0.5 * (1 - t); // Quadratic curve approximation\r\n            const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();\r\n            const normal = new THREE.Vector2(-tangent.y, tangent.x); // Perpendicular to tangent\r\n            newNormals[posIndex] = normal.x;\r\n            newNormals[posIndex + 1] = 0;\r\n            newNormals[posIndex + 2] = normal.y;\r\n        }\r\n    \r\n        shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));\r\n        shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));\r\n        return shapeGeom;\r\n    }\r\n\r\n    createGrassTexture() {\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = 4;\r\n        canvas.height = 32;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\r\n        gradient.addColorStop(0.0, this.game.palette[\"greenMColor\"]);\r\n        gradient.addColorStop(0.8, this.game.palette[\"greenMColor\"]);\r\n        gradient.addColorStop(1.0, this.game.palette[\"redLColor\"]);\r\n\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n        const texture = new THREE.CanvasTexture(canvas);\r\n        texture.wrapS = THREE.RepeatWrapping;\r\n        texture.wrapT = THREE.ClampToEdgeWrapping;\r\n        texture.magFilter = THREE.NearestFilter;\r\n        texture.minFilter = THREE.NearestFilter;\r\n        return texture;\r\n    }\r\n\r\n    // Utility methods for external systems\r\n    setControlsEnabled(enabled) {\r\n        if (this.controls) {\r\n            this.controls.enabled = enabled;\r\n        }\r\n    }\r\n\r\n    resetCamera() {\r\n        if (!this.cameraSettings) return;\r\n\r\n        const cameraPos = JSON.parse(this.cameraSettings.position);\r\n        const lookAt = JSON.parse(this.cameraSettings.lookAt);\r\n\r\n        if (this.controls) {\r\n            this.controls.reset();\r\n            this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);\r\n            this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);\r\n            this.controls.update();\r\n        } else {\r\n         //   this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);\r\n        //    this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);\r\n        }\r\n\r\n    }\r\n\r\n    // Terrain update methods for dynamic changes\r\n    updateTerrain() {\r\n        this.terrainRendered = false;\r\n        this._cachedColorMap = null;\r\n        this.renderTerrain();\r\n    }\r\n\r\n    destroy() {\r\n\r\n        // Clean up extension planes\r\n        if (this.extensionPlanes) {\r\n            this.extensionPlanes.forEach(plane => {\r\n                this.scene.remove(plane);\r\n                plane.geometry?.dispose();\r\n                plane.material?.dispose();\r\n            });\r\n            this.extensionPlanes = [];\r\n        }\r\n\r\n        // Clean up ground\r\n        if (this.ground) {\r\n            this.scene.remove(this.ground);\r\n            this.ground.geometry?.dispose();\r\n            this.ground.material?.dispose();\r\n        }\r\n\r\n        // Clean up grass\r\n        if (this.grass) {\r\n            this.scene.remove(this.grass);\r\n            this.grass.geometry?.dispose();\r\n            this.grass.material?.dispose();\r\n        }\r\n\r\n        // Clean up liquid meshes\r\n        this.liquidMeshes.forEach(mesh => {\r\n            this.scene.remove(mesh);\r\n            mesh.geometry?.dispose();\r\n            mesh.material?.dispose();\r\n        });\r\n        this.liquidMeshes = [];\r\n\r\n        // Clean up textures\r\n        this.groundTexture?.dispose();\r\n\r\n        // Clean up lights\r\n        if (this.ambientLight) this.scene.remove(this.ambientLight);\r\n        if (this.directionalLight) {\r\n            this.scene.remove(this.directionalLight);\r\n            this.scene.remove(this.directionalLight.target);\r\n        }\r\n        if (this.hemisphereLight) this.scene.remove(this.hemisphereLight);\r\n\r\n        // Clean up Three.js core\r\n        if (this.renderer) {\r\n            this.renderer.dispose();\r\n        }\r\n\r\n        // Clean up composer\r\n        if (this.composer) {\r\n            this.composer.dispose();\r\n        }\r\n\r\n        // Clean up orbit controls\r\n        if (this.controls) {\r\n            this.controls.dispose();\r\n            this.controls = null;\r\n        }\r\n\r\n        // Remove event listeners\r\n        window.removeEventListener('resize', this.onWindowResizeHandler);\r\n\r\n        // Clear references\r\n        this.groundCanvas = null;\r\n        this.terrainCanvas = null;\r\n        this.scene = null;\r\n        this.camera = null;\r\n        this.renderer = null;\r\n        this.composer = null;\r\n\r\n        this.initialized = false;\r\n    }\r\n\r\n    // Add this method to the WorldSystem class\r\n\r\n    getTerrainHeightAtPosition(worldX, worldZ) {\r\n        // Check if height map is available and enabled\r\n        if (!this.heightMapData || !this.heightMapSettings?.enabled) {\r\n            return 0; // Fallback to flat ground\r\n        }\r\n        \r\n        // Convert world coordinates to height map coordinates\r\n        // The ground is centered at origin, so we need to offset by half the extended size\r\n        const heightMapX = Math.floor(worldX + this.extendedSize / 2);\r\n        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);\r\n        \r\n        // Ensure coordinates are within bounds\r\n        if (heightMapX < 0 || heightMapX >= this.extendedSize || heightMapZ < 0 || heightMapZ >= this.extendedSize) {\r\n            // Outside terrain bounds, use extension terrain height\r\n            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;\r\n            return extensionTerrainType * this.heightStep;\r\n        }\r\n        \r\n        // Get height from height map\r\n        const heightIndex = heightMapZ * this.extendedSize + heightMapX;\r\n        return this.heightMapData[heightIndex] || 0;\r\n    }\r\n\r\n    // Optional: Add bilinear interpolation for smoother height transitions\r\n    getTerrainHeightAtPositionSmooth(worldX, worldZ) {\r\n        // Check if height map is available and enabled\r\n        if (!this.heightMapData || !this.heightMapSettings?.enabled) {\r\n            return 0; // Fallback to flat ground\r\n        }\r\n        \r\n        // Convert world coordinates to height map coordinates (with decimal precision)\r\n        const heightMapX = worldX + this.extendedSize / 2;\r\n        const heightMapZ = worldZ + this.extendedSize / 2;\r\n        \r\n        // Get the four surrounding grid points\r\n        const x0 = Math.floor(heightMapX);\r\n        const x1 = x0 + 1;\r\n        const z0 = Math.floor(heightMapZ);\r\n        const z1 = z0 + 1;\r\n        \r\n        // Get fractional parts for interpolation\r\n        const fx = heightMapX - x0;\r\n        const fz = heightMapZ - z0;\r\n        \r\n        // Helper function to get height at specific grid point\r\n        const getHeightAt = (x, z) => {\r\n            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {\r\n                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;\r\n                return extensionTerrainType * this.heightStep;\r\n            }\r\n            const heightIndex = z * this.extendedSize + x;\r\n            return this.heightMapData[heightIndex] || 0;\r\n        };\r\n        \r\n        // Get heights at the four corners\r\n        const h00 = getHeightAt(x0, z0);\r\n        const h10 = getHeightAt(x1, z0);\r\n        const h01 = getHeightAt(x0, z1);\r\n        const h11 = getHeightAt(x1, z1);\r\n        \r\n        // Bilinear interpolation\r\n        const h0 = h00 * (1 - fx) + h10 * fx;\r\n        const h1 = h01 * (1 - fx) + h11 * fx;\r\n        return h0 * (1 - fz) + h1 * fz;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/WorldSystem.js",
        "fileName": "WorldSystem"
      },
      "AISystem": {
        "script": "class AISystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.aiSystem = this;\r\n        this.entityAIControllers = new Map();\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('getAIControllerData', this.getAIControllerData.bind(this));\r\n        this.game.gameManager.register('setAIControllerData', this.setAIControllerData.bind(this));\r\n        this.game.gameManager.register('setCurrentAIController', this.setCurrentAIController.bind(this));\r\n        this.game.gameManager.register('getCurrentAIController', this.getCurrentAIController.bind(this));\r\n        this.game.gameManager.register('getCurrentAIControllerId', this.getCurrentAIControllerId.bind(this));\r\n        this.game.gameManager.register('removeAIController', this.removeAIController.bind(this));\r\n        this.game.gameManager.register('removeCurrentAIController', this.removeCurrentAIController.bind(this));\r\n        this.game.gameManager.register('hasAIControllerData', this.hasAIControllerData.bind(this));\r\n    }\r\n\r\n    setAIControllerData(entityId, aiControllerId, data, overwriteControllerId = true) {\r\n        let entityControllersMap = this.getEntityAIControllers(entityId);\r\n        if(overwriteControllerId) {\r\n            data.aiControllerId = aiControllerId;\r\n        }\r\n        entityControllersMap.set(aiControllerId, data);\r\n    }\r\n\r\n    hasAIControllerData(entityId, aiControllerId){\r\n        let entityControllersMap = this.getEntityAIControllers(entityId);\r\n        const CT = this.game.componentManager.getComponents();        \r\n        return entityControllersMap.has(aiControllerId);\r\n    }\r\n\r\n    getAIControllerData(entityId, aiControllerId) {\r\n        let entityControllersMap = this.getEntityAIControllers(entityId);\r\n        const CT = this.game.componentManager.getComponents();        \r\n        return entityControllersMap.get(aiControllerId) || CT.AIState('idle');\r\n    }\r\n\r\n    setCurrentAIController(entityId, aiControllerId, data) {        \r\n        this.setAIControllerData(entityId, aiControllerId, data);\r\n        this.setAIControllerData(entityId, \"AISystem\", data, false);\r\n\r\n        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);\r\n        aiState.targetPosition = data.targetPosition;\r\n        aiState.target = data.target;\r\n        aiState.meta = data.meta;\r\n        aiState.aiControllerId = aiControllerId;\r\n    }\r\n\r\n    getCurrentAIController(entityId) {\r\n        return this.getAIControllerData(entityId, \"AISystem\");\r\n    }\r\n\r\n    getCurrentAIControllerId(entityId) {\r\n        return this.getAIControllerData(entityId, \"AISystem\").aiControllerId;\r\n    }\r\n\r\n    removeAIController(entityId, aiControllerId){\r\n        let entityControllersMap = this.getEntityAIControllers(entityId);\r\n        entityControllersMap.delete(aiControllerId);\r\n    }\r\n\r\n    removeCurrentAIController(entityId){    \r\n        const currentAiControllerId = this.getCurrentAIControllerId();\r\n        this.removeAIController(entityId, currentAiControllerId);\r\n        const CT = this.game.componentManager.getComponents();        \r\n        this.setAIControllerData(entityId, \"AISystem\", CT.AIState('idle'), false);\r\n    }\r\n\r\n    getEntityAIControllers(entityId) {\r\n        let entityControllersMap = this.entityAIControllers.get(entityId);\r\n        if(!entityControllersMap){\r\n            entityControllersMap = new Map();\r\n            this.entityAIControllers.set(entityId, entityControllersMap);\r\n        }\r\n        return entityControllersMap;\r\n    }\r\n\r\n    entityDestroyed(entityId) {\r\n        this.entityAIControllers.delete(entityId);\r\n    }\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AISystem.js",
        "fileName": "AISystem"
      },
      "DeathSystem": {
        "script": "class DeathSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.deathSystem = this;\r\n    }\r\n    \r\n    update() {\r\n        // Get all entities with death state\r\n        const dyingEntities = this.game.getEntitiesWith(this.componentTypes.DEATH_STATE);\r\n        dyingEntities.forEach(entityId => {\r\n            const deathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n        \r\n            if (deathState.isDying) {\r\n                const timeSinceDeath = this.game.state.now - deathState.deathStartTime;\r\n                \r\n                // Remove health (corpses can't be damaged)\r\n                if (this.game.hasComponent(entityId, this.componentTypes.HEALTH)) {\r\n                    this.game.removeComponent(entityId, this.componentTypes.HEALTH);\r\n                }\r\n                \r\n                // Remove velocity (corpses don't move)\r\n                if (this.game.hasComponent(entityId, this.componentTypes.VELOCITY)) {\r\n                    this.game.removeComponent(entityId, this.componentTypes.VELOCITY);\r\n                }\r\n                \r\n                const timerExpired = timeSinceDeath >= deathState.deathAnimationDuration * 0.975;\r\n                \r\n                if (timerExpired) {\r\n                    console.log(entityId, \"DIED\");\r\n                    if(unitType && unitType.collection == \"buildings\"){\r\n                        this.destroyBuilding(entityId);\r\n                    } else {\r\n                        this.convertToCorpse(entityId);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n    destroyBuilding(entityId) {\r\n        this.game.triggerEvent('onDestroyBuilding', entityId);\r\n        this.game.destroyEntity(entityId);  \r\n        return { success: true };\r\n    }\r\n    \r\n    convertToCorpse(entityId) {\r\n        const Components = this.game.componentManager.getComponents();\r\n        \r\n        // Get current components before conversion\r\n        const position = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n        const renderable = this.game.getComponent(entityId, this.componentTypes.RENDERABLE);\r\n        \r\n        if (!position || !unitType || !team) return;\r\n\r\n        // CRITICAL: Notify AnimationSystem FIRST to set corpse state\r\n        if(this.game.gameManager.has('setCorpseAnimation')){\r\n            this.game.gameManager.call('setCorpseAnimation', entityId);\r\n        }\r\n\r\n        // Remove death state\r\n        this.game.removeComponent(entityId, this.componentTypes.DEATH_STATE);        \r\n        \r\n        this.game.triggerEvent('onUnitKilled', entityId);\r\n        // Add corpse component\r\n        this.game.addComponent(entityId, this.componentTypes.CORPSE, Components.Corpse(\r\n            { ...unitType }, \r\n            (this.game.state.now || 0), \r\n            team.team\r\n        ));\r\n        \r\n    }\r\n    \r\n    // Rest of your existing methods remain the same...\r\n    getCorpsesInRange(position, range, teamFilter = null) {\r\n        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);\r\n        const nearbyCorpses = [];\r\n        \r\n        corpses.forEach(corpseId => {\r\n            const corpsePos = this.game.getComponent(corpseId, this.componentTypes.POSITION);\r\n            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);\r\n            \r\n            if (!corpsePos || !corpse) return;\r\n            \r\n            // Check team filter if specified\r\n            if (teamFilter && corpse.teamAtDeath !== teamFilter) return;\r\n            \r\n            // Check distance\r\n            const dx = corpsePos.x - position.x;\r\n            const dz = corpsePos.z - position.z;\r\n            const distance = Math.sqrt(dx * dx + dz * dz);\r\n            \r\n            if (distance <= range) {\r\n                nearbyCorpses.push({\r\n                    entityId: corpseId,\r\n                    position: corpsePos,\r\n                    corpse: corpse,\r\n                    distance: distance\r\n                });\r\n            }\r\n        });\r\n        \r\n        return nearbyCorpses;\r\n    }\r\n    \r\n    consumeCorpse(corpseId) {\r\n        // Remove corpse from battlefield (for abilities that consume corpses)\r\n        const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);\r\n        if (!corpse) return null;\r\n        \r\n        // Return corpse data for the ability to use\r\n        const corpseData = { ...corpse };\r\n        \r\n        // Destroy the corpse entity\r\n        this.game.destroyEntity(corpseId);\r\n        \r\n        return corpseData;\r\n    }\r\n    \r\n    getAllCorpses() {\r\n        return this.game.getEntitiesWith(this.componentTypes.CORPSE);\r\n    }\r\n    \r\n    getCorpsesByTeam(team) {\r\n        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);\r\n        return corpses.filter(corpseId => {\r\n            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);\r\n            return corpse && corpse.teamAtDeath === team;\r\n        });\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DeathSystem.js",
        "fileName": "DeathSystem"
      },
      "EquipmentSystem": {
        "script": "class EquipmentSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.equipmentSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        this.entityEquipment = new Map();\r\n        this.equipmentCache = new Map();\r\n        this.equipmentBatches = new Map();\r\n        this.equipmentInstances = new Map();\r\n        \r\n        this.scaleFactor = 32;\r\n        this.DEFAULT_CAPACITY = 128;\r\n        this.bonePrefix = 'mixamorig';\r\n        \r\n        this.boneNameMappings = {\r\n            default: {\r\n                mainHand: ['RightHand', 'Hand_R', 'hand_R', 'R_Hand'],\r\n                offHand: ['LeftHand', 'Hand_L', 'hand_L', 'L_Hand'],\r\n                head: ['Head', 'head', 'Head_M'],\r\n                chest: ['Spine2', 'spine2', 'Chest', 'chest'],\r\n                back: ['Spine', 'spine', 'Back', 'back']\r\n            }\r\n        };\r\n        \r\n        this.slotDefaultOffsets = {\r\n            mainHand: { x: 0, y: 0, z: 0 },\r\n            offHand: { x: 0, y: 0, z: 0 },\r\n            head: { x: 0, y: 0.15, z: 0 },\r\n            chest: { x: 0, y: 0, z: 0 },\r\n            back: { x: 0, y: 0, z: -0.2 }\r\n        };\r\n        \r\n        console.log('[Equipment] System initialized with bone attachment texture');\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('getItemData', this.getItemData.bind(this));\r\n    }\r\n\r\n    getItemData(itemId) {\r\n        if (!itemId) return null;\r\n        const collections = this.game.getCollections();\r\n        return collections.items?.[itemId] || null;\r\n    }\r\n\r\n    update() {\r\n        const entities = this.game.getEntitiesWith(\r\n            this.componentTypes.EQUIPMENT,\r\n            this.componentTypes.POSITION\r\n        );\r\n        \r\n        entities.forEach(entityId => {\r\n            this.updateEntityEquipment(entityId);\r\n        });\r\n        \r\n        this.cleanupRemovedEntities(entities);\r\n    }\r\n    \r\n    updateEntityEquipment(entityId) {\r\n        const equipmentData = this.equipmentInstances.get(entityId);\r\n        if (!equipmentData) return;\r\n        \r\n        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        const facing = this.game.getComponent(entityId, this.componentTypes.FACING);\r\n        \r\n        if (!pos) return;\r\n        \r\n        const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);\r\n        if (!unitInstance) return;\r\n        \r\n        const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);\r\n        if (!unitBatch) return;\r\n        \r\n        for (const [slotType, equipInstance] of equipmentData.entries()) {\r\n            this.updateEquipmentTransformWithBone(\r\n                equipInstance, \r\n                pos, \r\n                facing, \r\n                unitBatch,\r\n                unitInstance\r\n            );\r\n        }\r\n    }\r\n    \r\n    sampleAttachmentMatrix(attachmentTexture, cols, rows, rowIndex, attachmentBoneIndex) {\r\n        if (!attachmentTexture?.image?.data) return null;\r\n        \r\n        const textureData = attachmentTexture.image.data;\r\n        const boneColStart = attachmentBoneIndex * 4;\r\n        \r\n        const matrix = new THREE.Matrix4();\r\n        const elements = matrix.elements;\r\n        \r\n        for (let col = 0; col < 4; col++) {\r\n            const pixelX = Math.floor(boneColStart + col);\r\n            const pixelY = Math.floor(rowIndex);\r\n            \r\n            if (pixelX >= cols || pixelY >= rows || pixelY < 0) {\r\n                return null;\r\n            }\r\n            \r\n            const pixelIndex = (pixelY * cols + pixelX) * 4;\r\n            \r\n            elements[col * 4 + 0] = textureData[pixelIndex + 0];\r\n            elements[col * 4 + 1] = textureData[pixelIndex + 1];\r\n            elements[col * 4 + 2] = textureData[pixelIndex + 2];\r\n            elements[col * 4 + 3] = textureData[pixelIndex + 3];\r\n        }\r\n        \r\n        return matrix;\r\n    }\r\n        \r\n    updateEquipmentTransformWithBone(equipInstance, pos, facing, unitBatch, unitInstance) {\r\n        const batch = this.equipmentBatches.get(equipInstance.batchKey);\r\n        if (!batch || equipInstance.instanceIndex === null) return;\r\n        \r\n        if (!unitBatch?.meta?.attachmentTexture) return;\r\n        \r\n        const clipIndex = unitBatch.attributes.clipIndex.array[unitInstance.instanceIndex];\r\n        const animTime = unitBatch.attributes.animTime.array[unitInstance.instanceIndex];\r\n        \r\n        if (clipIndex === undefined || animTime === undefined) return;\r\n        \r\n        const clipInfo = unitBatch.meta.clips[clipIndex];\r\n        if (!clipInfo) return;\r\n        \r\n        const fps = unitBatch.meta.fps || 30;\r\n        const frame = Math.floor((animTime * fps) % clipInfo.frames);\r\n        const rowIndex = clipInfo.startRow + frame;\r\n        \r\n        const attachmentBoneIndex = equipInstance.attachmentBoneIndex;\r\n        if (attachmentBoneIndex === undefined || attachmentBoneIndex < 0) return;\r\n        \r\n        const skinningMatrix = this.sampleAttachmentMatrix(\r\n            unitBatch.meta.attachmentTexture,\r\n            unitBatch.meta.attachmentTexture.image.width,\r\n            unitBatch.meta.attachmentTexture.image.height,\r\n            rowIndex,\r\n            attachmentBoneIndex\r\n        );\r\n        \r\n        if (!skinningMatrix) return;\r\n        \r\n        const skeleton = unitBatch.meta.skeleton;\r\n        const originalBoneIndex = unitBatch.meta.attachmentBones[attachmentBoneIndex].index;\r\n        const bindInverse = skeleton.boneInverses[originalBoneIndex];\r\n\r\n        const bindPose = new THREE.Matrix4().copy(bindInverse).invert();\r\n        const boneWorldLocal = new THREE.Matrix4().multiplyMatrices(skinningMatrix, bindPose);\r\n        \r\n        const bonePos = new THREE.Vector3();\r\n        const boneQuat = new THREE.Quaternion();\r\n        const boneScale = new THREE.Vector3();\r\n        boneWorldLocal.decompose(bonePos, boneQuat, boneScale);\r\n        \r\n        const baseScale = unitBatch.meta.baseScale || new THREE.Vector3(1, 1, 1);\r\n        const basePosition = unitBatch.meta.basePos || new THREE.Vector3(0, 0, 0);\r\n        \r\n        bonePos.multiply(baseScale);\r\n        bonePos.multiplyScalar(this.scaleFactor);\r\n        \r\n        const slotDefaults = this.slotDefaultOffsets[equipInstance.slotType] || { x: 0, y: 0, z: 0 };\r\n        const offsetVec = new THREE.Vector3(\r\n            slotDefaults.x,\r\n            slotDefaults.y,\r\n            slotDefaults.z\r\n        );\r\n        \r\n        if (equipInstance.attachmentData?.offset) {\r\n            offsetVec.x += (equipInstance.attachmentData.offset.x * 0.5);\r\n            offsetVec.y += (equipInstance.attachmentData.offset.y * 0.5);\r\n            offsetVec.z += (equipInstance.attachmentData.offset.z * 0.5);\r\n        }\r\n        const boneRotation = boneQuat.clone();\r\n        if (equipInstance.attachmentData?.rotation) {\r\n            const offsetRot = new THREE.Quaternion();\r\n            offsetRot.setFromEuler(new THREE.Euler(\r\n                (equipInstance.attachmentData.rotation.x) * Math.PI / 180,\r\n                (equipInstance.attachmentData.rotation.y) * Math.PI / 180,\r\n                (equipInstance.attachmentData.rotation.z) * Math.PI / 180,\r\n                'XYZ'\r\n            ));\r\n            boneRotation.multiply(offsetRot);\r\n        }\r\n        \r\n        offsetVec.applyQuaternion(boneRotation);\r\n        bonePos.add(offsetVec);\r\n        \r\n        const rotationY = facing ? (-facing.angle + Math.PI / 2) : (Math.PI / 2);\r\n        const worldRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);\r\n        \r\n        bonePos.applyQuaternion(worldRotation);\r\n        \r\n        const worldPos = new THREE.Vector3(\r\n            pos.x + basePosition.x * this.scaleFactor,\r\n            (pos.y || 0) + basePosition.y * this.scaleFactor,\r\n            pos.z + basePosition.z * this.scaleFactor\r\n        );\r\n        bonePos.add(worldPos);\r\n        \r\n        const finalRotation = new THREE.Quaternion().multiplyQuaternions(worldRotation, boneRotation);\r\n        \r\n        const finalScale = new THREE.Vector3(this.scaleFactor * 0.25, this.scaleFactor * 0.25, this.scaleFactor * 0.25);\r\n        \r\n        const matrix = new THREE.Matrix4();\r\n        matrix.compose(bonePos, finalRotation, finalScale);\r\n        \r\n        batch.mesh.setMatrixAt(equipInstance.instanceIndex, matrix);\r\n        batch.mesh.instanceMatrix.needsUpdate = true;\r\n    }\r\n    \r\n    findAttachmentBoneIndex(attachmentBones, boneName) {\r\n        if (!attachmentBones) return -1;\r\n        \r\n        for (let i = 0; i < attachmentBones.length; i++) {\r\n            const bone = attachmentBones[i];\r\n            if (bone.name === boneName || \r\n                bone.name.replace(this.bonePrefix, '') === boneName ||\r\n                bone.name.includes(boneName)) {\r\n                console.log(`[Equipment] Found attachment bone \"${boneName}\" at index ${i} (original: ${bone.index})`);\r\n                return i;\r\n            }\r\n        }\r\n        \r\n        console.warn(`[Equipment] Attachment bone not found: ${boneName}`);\r\n        return -1;\r\n    }\r\n   \r\n    async equipItem(entityId, slotData, itemData) {\r\n        return false;\r\n        // const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);\r\n        // const slotType = slotData.slot;\r\n        // if (!equipment) return false;\r\n        \r\n        // if (equipment.slots[slotType]) {\r\n        //     await this.unequipItem(entityId, slotType);\r\n        // }\r\n        \r\n        // const spawnType = slotData.item;\r\n        // const equipmentModel = await this.loadEquipmentModel(spawnType);\r\n        // if (!equipmentModel) return false;\r\n        \r\n        // const batchKey = `equipment_${spawnType}`;\r\n        // let batch = this.equipmentBatches.get(batchKey);\r\n        \r\n        // if (!batch) {\r\n        //     batch = this.createEquipmentBatch(batchKey, equipmentModel);\r\n        //     if (!batch) return false;\r\n        // }\r\n        \r\n        // const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);\r\n        // if (!unitInstance) return false;\r\n        \r\n        // const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);\r\n        // if (!unitBatch?.meta?.attachmentBones) {\r\n        //     console.error('[Equipment] Unit has no attachment bone data');\r\n        //     return false;\r\n        // }\r\n        \r\n        // const boneNames = this.boneNameMappings.default[slotType];\r\n        // let attachmentBoneIndex = -1;\r\n        \r\n        // for (const boneName of boneNames) {\r\n        //     attachmentBoneIndex = this.findAttachmentBoneIndex(unitBatch.meta.attachmentBones, boneName);\r\n        //     if (attachmentBoneIndex >= 0) break;\r\n        // }\r\n        \r\n        // if (attachmentBoneIndex < 0) {\r\n        //     console.error(`[Equipment] No valid attachment bone found for slot ${slotType}`);\r\n        //     return false;\r\n        // }\r\n        \r\n        // const instanceIndex = this.allocateEquipmentInstance(batch);\r\n        // if (instanceIndex === null) return false;\r\n        \r\n        // const equipInstance = {\r\n        //     batchKey,\r\n        //     instanceIndex,\r\n        //     slotType,\r\n        //     attachmentBoneIndex,\r\n        //     attachmentData: slotData.attachmentData\r\n        // };\r\n        \r\n        // if (!this.equipmentInstances.has(entityId)) {\r\n        //     this.equipmentInstances.set(entityId, new Map());\r\n        // }\r\n        // this.equipmentInstances.get(entityId).set(slotType, equipInstance);\r\n        \r\n        // if (!this.entityEquipment.has(entityId)) {\r\n        //     this.entityEquipment.set(entityId, new Map());\r\n        // }\r\n        \r\n        // this.entityEquipment.get(entityId).set(slotType, {\r\n        //     itemData,\r\n        //     spawnType,\r\n        //     instanceIndex,\r\n        //     batchKey\r\n        // });\r\n        \r\n        // equipment.slots[slotType] = {\r\n        //     itemData,\r\n        //     equippedItem: itemData\r\n        // };\r\n        \r\n        // console.log(`[Equipment] Equipped ${spawnType} to entity ${entityId} slot ${slotType} attachment bone ${attachmentBoneIndex}`);\r\n        // return true;\r\n    }\r\n    \r\n    createEquipmentBatch(batchKey, equipmentModel) {\r\n        let geometry = null;\r\n        let material = null;\r\n            \r\n        equipmentModel.updateMatrixWorld(true);\r\n\r\n        equipmentModel.traverse(child => {\r\n            if (child.isMesh && !geometry) {\r\n                geometry = child.geometry.clone();\r\n                child.updateMatrixWorld(true);\r\n                geometry.applyMatrix4(child.matrixWorld);\r\n                material = child.material.clone();\r\n            }\r\n        });\r\n        \r\n        if (!geometry || !material) return null;\r\n        \r\n        material.metalness = material.metalness || 0;\r\n        material.roughness = material.roughness || 1;\r\n        \r\n        const instancedMesh = new THREE.InstancedMesh(geometry, material, this.DEFAULT_CAPACITY);\r\n        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\r\n        instancedMesh.castShadow = true;\r\n        instancedMesh.receiveShadow = true;\r\n        instancedMesh.frustumCulled = false;\r\n        \r\n        const hiddenMatrix = new THREE.Matrix4();\r\n        hiddenMatrix.makeTranslation(0, -10000, 0);\r\n        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));\r\n        \r\n        for (let i = 0; i < this.DEFAULT_CAPACITY; i++) {\r\n            instancedMesh.setMatrixAt(i, hiddenMatrix);\r\n        }\r\n        instancedMesh.instanceMatrix.needsUpdate = true;\r\n        \r\n        if (this.game.scene) {\r\n            this.game.scene.add(instancedMesh);\r\n        }\r\n        \r\n        const batch = {\r\n            mesh: instancedMesh,\r\n            capacity: this.DEFAULT_CAPACITY,\r\n            count: 0,\r\n            availableIndices: Array.from({ length: this.DEFAULT_CAPACITY }, (_, i) => i),\r\n            usedIndices: new Set()\r\n        };\r\n        \r\n        this.equipmentBatches.set(batchKey, batch);\r\n        return batch;\r\n    }\r\n    \r\n    allocateEquipmentInstance(batch) {\r\n        if (batch.availableIndices.length === 0) return null;\r\n        const instanceIndex = batch.availableIndices.shift();\r\n        batch.usedIndices.add(instanceIndex);\r\n        batch.count++;\r\n        return instanceIndex;\r\n    }\r\n    \r\n    releaseEquipmentInstance(batch, instanceIndex) {\r\n        if (!batch.usedIndices.has(instanceIndex)) return;\r\n        \r\n        const hiddenMatrix = new THREE.Matrix4();\r\n        hiddenMatrix.makeTranslation(0, -10000, 0);\r\n        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));\r\n        batch.mesh.setMatrixAt(instanceIndex, hiddenMatrix);\r\n        batch.mesh.instanceMatrix.needsUpdate = true;\r\n        \r\n        batch.usedIndices.delete(instanceIndex);\r\n        batch.availableIndices.push(instanceIndex);\r\n        batch.count--;\r\n    }\r\n    \r\n    async unequipItem(entityId, slotType) {\r\n        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);\r\n        if (!equipment || !equipment.slots[slotType]) return true;\r\n        \r\n        const equipInstance = this.equipmentInstances.get(entityId)?.get(slotType);\r\n        \r\n        if (equipInstance) {\r\n            const batch = this.equipmentBatches.get(equipInstance.batchKey);\r\n            if (batch) {\r\n                this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);\r\n            }\r\n            this.equipmentInstances.get(entityId)?.delete(slotType);\r\n        }\r\n        \r\n        const entityEquip = this.entityEquipment.get(entityId);\r\n        if (entityEquip) {\r\n            entityEquip.delete(slotType);\r\n        }\r\n        \r\n        equipment.slots[slotType] = null;\r\n        return true;\r\n    }\r\n    \r\n    async loadEquipmentModel(spawnType) {\r\n        const cacheKey = `items_${spawnType}`;\r\n        \r\n        if (this.equipmentCache.has(cacheKey)) {\r\n            return this.equipmentCache.get(cacheKey).clone();\r\n        }\r\n        \r\n        try {\r\n            const model = this.game.modelManager.getModel(\"items\", spawnType);\r\n            \r\n            if (model) {\r\n                model.traverse(child => {\r\n                    if (child.isMesh) {\r\n                        child.castShadow = true;\r\n                        child.receiveShadow = true;\r\n                        if (child.material) {\r\n                            child.material.metalness = child.material.metalness || 0;\r\n                            child.material.roughness = child.material.roughness || 1;\r\n                        }\r\n                    }\r\n                });\r\n                \r\n                this.equipmentCache.set(cacheKey, model);\r\n                return model.clone();\r\n            }\r\n        } catch (error) {\r\n            console.error(`Error loading equipment model ${cacheKey}:`, error);\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    cleanupRemovedEntities(activeEntities) {\r\n        const activeSet = new Set(activeEntities);\r\n        \r\n        for (const [entityId, equipmentMap] of this.equipmentInstances.entries()) {\r\n            if (!activeSet.has(entityId)) {\r\n                for (const [slotType, equipInstance] of equipmentMap.entries()) {\r\n                    const batch = this.equipmentBatches.get(equipInstance.batchKey);\r\n                    if (batch) {\r\n                        this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);\r\n                    }\r\n                }\r\n                this.equipmentInstances.delete(entityId);\r\n                this.entityEquipment.delete(entityId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    destroy() {\r\n        for (const [batchKey, batch] of this.equipmentBatches.entries()) {\r\n            if (batch.mesh) {\r\n                if (this.game.scene) {\r\n                    this.game.scene.remove(batch.mesh);\r\n                }\r\n                batch.mesh.geometry.dispose();\r\n                if (Array.isArray(batch.mesh.material)) {\r\n                    batch.mesh.material.forEach(mat => mat.dispose());\r\n                } else {\r\n                    batch.mesh.material.dispose();\r\n                }\r\n            }\r\n        }\r\n        \r\n        for (const [key, model] of this.equipmentCache.entries()) {\r\n            model.traverse(child => {\r\n                if (child.geometry) child.geometry.dispose();\r\n                if (child.material) {\r\n                    if (Array.isArray(child.material)) {\r\n                        child.material.forEach(mat => mat.dispose());\r\n                    } else {\r\n                        child.material.dispose();\r\n                    }\r\n                }\r\n            });\r\n        }\r\n        \r\n        this.equipmentBatches.clear();\r\n        this.equipmentInstances.clear();\r\n        this.entityEquipment.clear();\r\n        this.equipmentCache.clear();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EquipmentSystem.js",
        "fileName": "EquipmentSystem"
      },
      "GoldMineSystem": {
        "script": "class GoldMineSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.goldMineSystem = this;\r\n        this.goldVeinLocations = [];\r\n        this.claimedGoldMines = new Map();\r\n        \r\n        console.log('[GoldMineSystem] Initialized', this.game.isServer ? '(SERVER)' : '(CLIENT)');\r\n    }\r\n\r\n    init(params) {\r\n        this.params = params || {};\r\n\r\n        this.game.gameManager.register('buildGoldMine', this.buildGoldMine.bind(this));\r\n        this.game.gameManager.register('isValidGoldMinePlacement', this.isValidGoldMinePlacement.bind(this));\r\n        this.game.gameManager.register('getGoldVeinLocations', () => this.goldVeinLocations);\r\n\r\n        this.findGoldVeinLocations();\r\n        console.log('[GoldMineSystem] Init complete. Found', this.goldVeinLocations.length, 'gold veins');\r\n    }\r\n\r\n    findGoldVeinLocations() {\r\n        const tileMap = this.game.terrainSystem?.tileMap;\r\n        if (!tileMap?.environmentObjects) {\r\n            console.warn('[GoldMineSystem] No environment objects found');\r\n            return;\r\n        }\r\n\r\n        const extensionSize = this.game.terrainSystem?.extensionSize || 0;\r\n        const extendedSize = this.game.terrainSystem?.extendedSize || 0;\r\n\r\n        this.goldVeinLocations = tileMap.environmentObjects\r\n            .filter(obj => obj.type === 'goldVein')\r\n            .map(obj => {\r\n                const worldX = (obj.x + extensionSize) - extendedSize / 2;\r\n                const worldZ = (obj.y + extensionSize) - extendedSize / 2;\r\n\r\n                const gridPos = this.game.gameManager.call('convertWorldToGridPosition', worldX, worldZ);\r\n\r\n                // Gold veins use placementGridWidth which is already in placement grid units\r\n                // But we need to match how buildings calculate their cells (footprintWidth * 2)\r\n                // Since gold veins have placementGridWidth=2, and buildings have footprintWidth=2,\r\n                // we need to convert: footprintWidth * 2 = 2 * 2 = 4 placement grid cells\r\n                const veinPlacementGridWidth = obj.placementGridWidth || 2;\r\n                const veinPlacementGridHeight = obj.placementGridHeight || 2;\r\n                // Convert to match building footprint calculation\r\n                const gridWidth = veinPlacementGridWidth * 2;\r\n                const gridHeight = veinPlacementGridHeight * 2;\r\n\r\n                const cells = this.calculateGoldVeinCells(gridPos, gridWidth, gridHeight);\r\n\r\n                return {\r\n                    x: obj.x,\r\n                    y: obj.y,\r\n                    worldX: worldX,\r\n                    worldZ: worldZ,\r\n                    gridPos: gridPos,\r\n                    gridWidth: gridWidth,  // 4 (placement grid cells)\r\n                    gridHeight: gridHeight,  // 4 (placement grid cells)\r\n                    cells: cells,\r\n                    claimed: false,\r\n                    claimedBy: null,\r\n                    instanceIndex: null,\r\n                    originalIndex: tileMap.environmentObjects.indexOf(obj)\r\n                };\r\n            });\r\n\r\n        console.log('[GoldMineSystem] Found gold veins:', this.goldVeinLocations);\r\n\r\n        if (!this.game.isServer) {\r\n            this.mapGoldVeinInstances();\r\n        }\r\n    }\r\n\r\n    calculateGoldVeinCells(gridPos, gridWidth, gridHeight) {\r\n        const cells = [];\r\n        const startX = gridPos.x - Math.round(gridWidth / 2);\r\n        const startZ = gridPos.z - Math.round(gridHeight / 2);\r\n\r\n        for (let z = 0; z < gridHeight; z++) {\r\n            for (let x = 0; x < gridWidth; x++) {\r\n                cells.push({\r\n                    x: startX + x,\r\n                    z: startZ + z\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n    isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight) {\r\n        const buildingCells = this.calculateGoldVeinCells(gridPos, buildingGridWidth, buildingGridHeight);\r\n\r\n        for (const vein of this.goldVeinLocations) {\r\n            if (vein.claimed) continue;\r\n\r\n            if (this.cellsMatch(buildingCells, vein.cells)) {\r\n                return { valid: true, vein: vein };\r\n            }\r\n        }\r\n\r\n        return { valid: false };\r\n    }\r\n\r\n    cellsMatch(cells1, cells2) {\r\n        if (cells1.length !== cells2.length) return false;\r\n\r\n        const cellSet = new Set(cells2.map(c => `${c.x},${c.z}`));\r\n        \r\n        for (const cell of cells1) {\r\n            if (!cellSet.has(`${cell.x},${cell.z}`)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    mapGoldVeinInstances() {\r\n        if (!this.game.gameManager.call('getWorldScene')) {\r\n            console.warn('[GoldMineSystem] No scene available for mapping instances');\r\n            return;\r\n        }\r\n\r\n        const goldVeinInstancedMeshes = [];\r\n        this.game.gameManager.call('getWorldScene').traverse(child => {\r\n            if (child instanceof THREE.InstancedMesh && child.userData.objectType === 'goldVein') {\r\n                goldVeinInstancedMeshes.push(child);\r\n            }\r\n        });\r\n\r\n        let globalIndex = 0;\r\n        for (const vein of this.goldVeinLocations) {\r\n            vein.instanceIndex = globalIndex;\r\n            vein.instancedMeshes = goldVeinInstancedMeshes;\r\n            globalIndex++;\r\n        }\r\n    }\r\n\r\n    buildGoldMine(entityId, team, gridPos, buildingGridWidth, buildingGridHeight) {\r\n\r\n        const validation = this.isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight);\r\n        if (!validation.valid) {\r\n            console.warn('[GoldMineSystem] Invalid placement - no matching unclaimed vein');\r\n            return { success: false, error: 'Must be placed on a gold vein' };\r\n        }\r\n\r\n        const vein = validation.vein;\r\n\r\n        vein.claimed = true;\r\n        vein.claimedBy = team;\r\n\r\n        let mineModel = null;\r\n        if (!this.game.isServer) {\r\n            mineModel = this.replaceVeinWithMine(vein);\r\n        }\r\n\r\n        this.claimedGoldMines.set(entityId, {\r\n            entityId: entityId,\r\n            position: { x: vein.x, z: vein.y },\r\n            worldPosition: { x: vein.worldX, z: vein.worldZ },\r\n            gridPos: vein.gridPos,\r\n            cells: vein.cells,\r\n            veinIndex: vein.originalIndex,\r\n            veinData: vein,\r\n            team: team,\r\n            model: mineModel\r\n        });\r\n\r\n        return { success: true };\r\n    }\r\n\r\n    destroyGoldMine(entityId) {\r\n        const goldMine = this.claimedGoldMines.get(entityId);\r\n        if (!goldMine) {\r\n            return { success: false, error: 'No gold mine to destroy' };\r\n        }\r\n\r\n        // Clear any miners targeting this mine\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);\r\n        \r\n        for (const minerEntityId of miners) {\r\n            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);\r\n            if (miningState && miningState.targetMineEntityId === entityId) {\r\n                miningState.targetMineEntityId = null;\r\n                miningState.targetMinePosition = null;\r\n                miningState.waitingPosition = null;\r\n                miningState.state = 'idle';\r\n            }\r\n        }\r\n\r\n        if (!this.game.isServer) {\r\n            console.log('[GoldMineSystem] CLIENT: Restoring vein');\r\n            this.restoreVein(goldMine.veinData);\r\n        } else {\r\n            console.log('[GoldMineSystem] SERVER: Releasing mine claim');\r\n            goldMine.veinData.claimed = false;\r\n            goldMine.veinData.claimedBy = null;\r\n        }\r\n        \r\n        this.claimedGoldMines.delete(entityId);\r\n\r\n        console.log('[GoldMineSystem] Gold mine destroyed. Remaining mines:', this.claimedGoldMines.size);\r\n        return { success: true };\r\n    }\r\n\r\n    // Check if a mine is currently occupied by looking at component states\r\n    isMineOccupied(mineEntityId) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);\r\n        \r\n        for (const minerEntityId of miners) {\r\n            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);\r\n            if (miningState && \r\n                miningState.targetMineEntityId === mineEntityId && \r\n                miningState.state === 'mining') {\r\n                return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n    // Get the current miner at a mine by checking component states\r\n    getCurrentMiner(mineEntityId) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);\r\n        \r\n        for (const minerEntityId of miners) {\r\n            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);\r\n            if (miningState && \r\n                miningState.targetMineEntityId === mineEntityId && \r\n                miningState.state === 'mining') {\r\n                return minerEntityId;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    // Get all miners in queue (waiting_at_mine state) for a specific mine\r\n    getMinersInQueue(mineEntityId) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);\r\n        const queuedMiners = [];\r\n        \r\n        for (const minerEntityId of miners) {\r\n            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);\r\n            if (miningState && \r\n                miningState.targetMineEntityId === mineEntityId && \r\n                miningState.state === 'waiting_at_mine') {\r\n                queuedMiners.push(minerEntityId);\r\n            }\r\n        }\r\n        \r\n        return queuedMiners;\r\n    }\r\n\r\n    // Get queue position for a specific miner\r\n    getQueuePosition(mineEntityId, minerEntityId) {\r\n        const queue = this.getMinersInQueue(mineEntityId);\r\n        return queue.indexOf(minerEntityId);\r\n    }\r\n\r\n    // Check if a miner is next in queue\r\n    isNextInQueue(mineEntityId, minerEntityId) {\r\n        const queue = this.getMinersInQueue(mineEntityId);\r\n        return queue.length > 0 && queue[0] === minerEntityId;\r\n    }\r\n\r\n    // Process next miner in queue when mine becomes available\r\n    processNextInQueue(mineEntityId) {\r\n        const queue = this.getMinersInQueue(mineEntityId);\r\n        \r\n        if (queue.length === 0) {\r\n            return;\r\n        }\r\n        \r\n        const nextMinerId = queue[0];\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const miningState = this.game.getComponent(nextMinerId, ComponentTypes.MINING_STATE);\r\n        \r\n        if (miningState && miningState.state === 'waiting_at_mine') {\r\n            const aiState = this.game.getComponent(nextMinerId, ComponentTypes.AI_STATE);\r\n            const pos = this.game.getComponent(nextMinerId, ComponentTypes.POSITION);\r\n            const vel = this.game.getComponent(nextMinerId, ComponentTypes.VELOCITY);\r\n            \r\n            if (pos && vel && miningState.targetMinePosition) {\r\n                miningState.waitingPosition = null;\r\n                \r\n                pos.x = miningState.targetMinePosition.x;\r\n                pos.z = miningState.targetMinePosition.z;\r\n                vel.vx = 0;\r\n                vel.vz = 0;\r\n                \r\n                miningState.state = 'mining';\r\n                miningState.miningStartTime = this.game.state.now;\r\n                \r\n                if (aiState) {\r\n                    aiState.state = 'idle';\r\n                    aiState.targetPosition = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    replaceVeinWithMine(vein) {\r\n        return;\r\n        // if (vein.instancedMeshes && vein.instanceIndex !== null) {\r\n        //     vein.instancedMeshes.forEach(mesh => {\r\n        //         const matrix = new THREE.Matrix4();\r\n        //         const position = new THREE.Vector3(0, -10000, 0);\r\n        //         matrix.makeTranslation(position.x, position.y, position.z);\r\n        //         matrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));\r\n        //         mesh.setMatrixAt(vein.instanceIndex, matrix);\r\n        //         mesh.instanceMatrix.needsUpdate = true;\r\n        //     });\r\n        // } \r\n    }\r\n\r\n    restoreVein(vein) {\r\n        // if (vein.instancedMeshes && vein.instanceIndex !== null) {\r\n        //     const extensionSize = this.game.terrainSystem?.extensionSize || 0;\r\n        //     const extendedSize = this.game.terrainSystem?.extendedSize || 0;\r\n        //     const heightMapSettings = this.game.worldSystem?.heightMapSettings;\r\n            \r\n        //     let height = 0;\r\n        //     if (heightMapSettings?.enabled) {\r\n        //         height = heightMapSettings.heightStep * this.game.terrainSystem.tileMap.extensionTerrainType;\r\n        //     }\r\n\r\n        //     const worldX = (vein.x + extensionSize) - extendedSize / 2;\r\n        //     const worldZ = (vein.y + extensionSize) - extendedSize / 2;\r\n\r\n        //     const dummy = new THREE.Object3D();\r\n        //     dummy.position.set(worldX, height, worldZ);\r\n        //     dummy.rotation.y = Math.random() * Math.PI * 2;\r\n        //     dummy.scale.set(50, 50, 50);\r\n        //     dummy.updateMatrix();\r\n\r\n        //     vein.instancedMeshes.forEach(mesh => {\r\n        //         const matrix = new THREE.Matrix4();\r\n        //         matrix.copy(dummy.matrix);\r\n        //         if (mesh.userData.relativeMatrix) {\r\n        //             matrix.multiply(mesh.userData.relativeMatrix);\r\n        //         }\r\n        //         mesh.setMatrixAt(vein.instanceIndex, matrix);\r\n        //         mesh.instanceMatrix.needsUpdate = true;\r\n        //     });            \r\n        // }\r\n\r\n        vein.claimed = false;\r\n        vein.claimedBy = null;\r\n    }\r\n\r\n    \r\n    onBattleEnd() {\r\n        const entities = this.game.getEntitiesWith(this.game.componentTypes.MINING_STATE);        \r\n        entities.forEach(entityId => {\r\n            const miningState = this.game.getComponent(entityId, this.game.componentTypes.MINING_STATE);\r\n            if (miningState) {\r\n                miningState.miningStartTime = 0;\r\n                miningState.depositStartTime = 0;\r\n            }\r\n        });\r\n    }\r\n\r\n    onDestroyBuilding(entityId){\r\n        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);\r\n        if (unitType.id === 'goldMine') {\r\n            this.game.goldMineSystem.destroyGoldMine(entityId);\r\n        } \r\n    }\r\n\r\n    reset() {\r\n        \r\n        if (!this.game.isServer) {\r\n            for (const [entityId, goldMine] of this.claimedGoldMines) {\r\n                this.restoreVein(goldMine.veinData, goldMine.model);\r\n            }\r\n        } else {\r\n            for (const [entityId, goldMine] of this.claimedGoldMines) {\r\n                goldMine.veinData.claimed = false;\r\n                goldMine.veinData.claimedBy = null;\r\n            }\r\n        }\r\n        \r\n        this.claimedGoldMines.clear();\r\n        \r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GoldMineSystem.js",
        "fileName": "GoldMineSystem"
      },
      "LifetimeSystem": {
        "script": "class LifetimeSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.lifetimeSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        // Configuration\r\n        this.CHECK_INTERVAL = 0.1; // Check lifetimes every 100ms for performance\r\n        this.lastCheck = 0;\r\n        \r\n        // Track entities with custom destruction callbacks\r\n        this.destructionCallbacks = new Map(); // entityId -> callback function\r\n        \r\n        // Track entities that should fade out before destruction\r\n        this.fadeOutEntities = new Map(); // entityId -> fade data\r\n        \r\n        // Statistics\r\n        this.stats = {\r\n            entitiesDestroyed: 0,\r\n            entitiesExpired: 0,\r\n            entitiesFaded: 0\r\n        };\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('addLifetime', this.addLifetime.bind(this));\r\n        this.game.gameManager.register('destroyEntityImmediately', this.destroyEntityImmediately.bind(this));\r\n        this.game.gameManager.register('extendLifetime', this.extendLifetime.bind(this));\r\n    }\r\n\r\n    update() {        \r\n        // Only check periodically for performance\r\n        if (this.game.state.now - this.lastCheck < this.CHECK_INTERVAL) return;\r\n        this.lastCheck = this.game.state.now;\r\n        \r\n        // Get all entities with lifetime components\r\n        const lifetimeEntities = this.game.getEntitiesWith(this.componentTypes.LIFETIME);\r\n        \r\n        lifetimeEntities.forEach(entityId => {\r\n            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n            if (!lifetime) return;\r\n            \r\n            const age = (this.game.state.now - lifetime.startTime);\r\n            \r\n            // Check if entity has expired\r\n            if (age >= lifetime.duration) {\r\n                this.handleExpiredEntity(entityId, lifetime);\r\n            } \r\n        });\r\n    }\r\n    \r\n    // =============================================\r\n    // ENTITY EXPIRATION HANDLING\r\n    // =============================================\r\n    \r\n    handleExpiredEntity(entityId, lifetime) {\r\n        // Call custom destruction callback if registered\r\n        const callback = this.destructionCallbacks.get(entityId);\r\n        if (callback) {\r\n            try {\r\n                callback(entityId, lifetime);\r\n            } catch (error) {\r\n                console.warn(`Lifetime destruction callback error for entity ${entityId}:`, error);\r\n            }\r\n            this.destructionCallbacks.delete(entityId);\r\n        }\r\n        \r\n        // Special handling for different entity types\r\n        this.handleSpecialEntityTypes(entityId, lifetime);\r\n        \r\n        // Create destruction effects if specified\r\n        this.createDestructionEffects(entityId, lifetime);\r\n        \r\n        // Log destruction if enabled\r\n        this.logEntityDestruction(entityId, lifetime);\r\n        \r\n        // Remove from fade tracking\r\n        this.fadeOutEntities.delete(entityId);\r\n        \r\n        // Destroy the entity\r\n        this.game.destroyEntity(entityId);\r\n        \r\n        // Update statistics\r\n        this.stats.entitiesDestroyed++;\r\n        this.stats.entitiesExpired++;\r\n    }\r\n    \r\n    handleSpecialEntityTypes(entityId, lifetime) {\r\n        // Handle projectiles\r\n        if (this.game.hasComponent(entityId, this.componentTypes.PROJECTILE)) {\r\n            // Clean up projectile-specific data \r\n            this.game.gameManager.call('deleteProjectileTrail', entityId);\r\n            \r\n        }\r\n        \r\n        // Handle summons\r\n        if (this.game.hasComponent(entityId, this.componentTypes.SUMMONED)) {\r\n            this.handleSummonExpiration(entityId);\r\n        }\r\n        \r\n        // Handle mirror images\r\n        if (this.game.hasComponent(entityId, this.componentTypes.MIRROR_IMAGE)) {\r\n            this.handleMirrorImageExpiration(entityId);\r\n        }\r\n        \r\n        // Handle traps\r\n        if (this.game.hasComponent(entityId, this.componentTypes.TRAP)) {\r\n            this.handleTrapExpiration(entityId);\r\n        }\r\n        \r\n        // Handle temporary effects\r\n        if (this.game.hasComponent(entityId, this.componentTypes.TEMPORARY_EFFECT)) {\r\n            this.handleTemporaryEffectExpiration(entityId);\r\n        }\r\n        \r\n        // Handle mind controlled entities\r\n        if (this.game.hasComponent(entityId, this.componentTypes.MIND_CONTROLLED)) {\r\n            this.handleMindControlExpiration(entityId);\r\n        }\r\n        \r\n        // Handle thorns effect\r\n        if (this.game.thornsEntities && this.game.thornsEntities.has(entityId)) {\r\n            this.game.thornsEntities.delete(entityId);\r\n        }\r\n    }\r\n    \r\n    handleSummonExpiration(entityId) {\r\n        const summonPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (summonPos) {\r\n            // Create disappearing effect\r\n            this.game.gameManager.call('createParticleEffect',\r\n                summonPos.x, summonPos.y, summonPos.z,\r\n                'magic',\r\n                { count: 3, color: 0x9370DB, scaleMultiplier: 1.5 }\r\n            );\r\n        }\r\n\r\n    }\r\n    \r\n    handleMirrorImageExpiration(entityId) {\r\n        const imagePos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (imagePos) {\r\n            // Create shimmering dissolution effect\r\n            this.game.gameManager.call('createParticleEffect',\r\n                imagePos.x, imagePos.y, imagePos.z,\r\n                'magic',\r\n                { count: 3, color: 0x6495ED, scaleMultiplier: 1.2 }\r\n            );\r\n        }\r\n    }\r\n    \r\n    handleTrapExpiration(entityId) {\r\n        const trapPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (trapPos) {\r\n            // Create fizzling effect for expired trap\r\n            this.game.gameManager.call('createParticleEffect',\r\n                trapPos.x, trapPos.y, trapPos.z,\r\n                'magic',\r\n                { count: 3, color: 0x696969, scaleMultiplier: 0.8 }\r\n            );\r\n        }\r\n\r\n\r\n    }\r\n    \r\n    handleTemporaryEffectExpiration(entityId) {\r\n        // For visual effect entities, just let them fade naturally\r\n        const effectPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (effectPos) {\r\n            this.game.gameManager.call('createParticleEffect',\r\n                effectPos.x, effectPos.y, effectPos.z,\r\n                'magic',\r\n                { count: 3, color: 0xFFFFFF, scaleMultiplier: 0.5 }\r\n            );\r\n        }\r\n    }\r\n    \r\n    handleMindControlExpiration(entityId) {\r\n        const mindControl = this.game.getComponent(entityId, this.componentTypes.MIND_CONTROLLED);\r\n        const targetTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);\r\n        const targetPos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        \r\n        if (mindControl && targetTeam) {\r\n            // Restore original team\r\n            targetTeam.team = mindControl.originalTeam;\r\n            \r\n            // Clear AI target\r\n            const targetAI = this.game.getComponent(entityId, this.componentTypes.AI_STATE);\r\n            if (targetAI && targetAI.aiBehavior) {\r\n                targetAI.target = null;\r\n                targetAI.targetPosition = null;\r\n                targetAI.path = [];\r\n                targetAI.meta = {};\r\n            }\r\n            \r\n            // Visual effect\r\n            if (targetPos) {\r\n                this.game.gameManager.call('createParticleEffect',\r\n                    targetPos.x, targetPos.y, targetPos.z,\r\n                    'magic',\r\n                    { count: 3, color: 0xDA70D6, scaleMultiplier: 1.0 }\r\n                );\r\n            }\r\n            \r\n            // Remove mind control component\r\n            this.game.removeComponent(entityId, this.componentTypes.MIND_CONTROLLED);\r\n            \r\n          \r\n        }\r\n    }\r\n\r\n    \r\n    // =============================================\r\n    // DESTRUCTION EFFECTS\r\n    // =============================================\r\n    \r\n    createDestructionEffects(entityId, lifetime) {\r\n        if (!lifetime.destructionEffect) return;\r\n\r\n        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n        if (!pos) return;\r\n\r\n        const effectConfig = lifetime.destructionEffect;\r\n\r\n        // Create particle effect\r\n        this.game.gameManager.call('createParticleEffect',\r\n            pos.x, pos.y, pos.z,\r\n            effectConfig.type || 'magic',\r\n            {\r\n                count: effectConfig.count || 3,\r\n                color: effectConfig.color || 0xFFFFFF,\r\n                scaleMultiplier: effectConfig.scaleMultiplier || 1.0,\r\n                speedMultiplier: effectConfig.speedMultiplier || 1.0\r\n            }\r\n        );\r\n\r\n        // Screen effects if specified\r\n        if (effectConfig.screenShake) {\r\n            this.game.gameManager.call('playScreenShake',\r\n                effectConfig.screenShake.duration || 0.2,\r\n                effectConfig.screenShake.intensity || 1\r\n            );\r\n        }\r\n\r\n        if (effectConfig.screenFlash) {\r\n            this.game.gameManager.call('playScreenFlash',\r\n                effectConfig.screenFlash.color || '#FFFFFF',\r\n                effectConfig.screenFlash.duration || 0.2\r\n            );\r\n        }\r\n    }\r\n    \r\n    // =============================================\r\n    // PUBLIC API METHODS\r\n    // =============================================\r\n    \r\n    /**\r\n     * Add a lifetime component to an entity\r\n     * @param {number} entityId - Entity to add lifetime to\r\n     * @param {number} duration - Duration in seconds\r\n     * @param {Object} options - Additional options\r\n     */\r\n    addLifetime(entityId, duration, options = {}) {\r\n        \r\n        const lifetimeData = {\r\n            duration: duration,\r\n            startTime: this.game.state.now,\r\n            fadeOutDuration: options.fadeOutDuration || 0,\r\n            destructionEffect: options.destructionEffect || null,\r\n            onDestroy: options.onDestroy || null\r\n        };\r\n        \r\n        this.game.addComponent(entityId, this.componentTypes.LIFETIME, lifetimeData);\r\n        \r\n        // Register destruction callback if provided\r\n        if (options.onDestroy && typeof options.onDestroy === 'function') {\r\n            this.destructionCallbacks.set(entityId, options.onDestroy);\r\n        }\r\n        \r\n        return entityId;\r\n    }\r\n    \r\n    /**\r\n     * Extend the lifetime of an entity\r\n     * @param {number} entityId - Entity to extend\r\n     * @param {number} additionalDuration - Additional time in seconds\r\n     */\r\n    extendLifetime(entityId, additionalDuration) {\r\n        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n        if (lifetime) {\r\n            lifetime.duration += additionalDuration;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Reduce the lifetime of an entity\r\n     * @param {number} entityId - Entity to reduce\r\n     * @param {number} reductionAmount - Time to reduce in seconds\r\n     */\r\n    reduceLifetime(entityId, reductionAmount) {\r\n        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n        if (lifetime) {\r\n            lifetime.duration = Math.max(0, lifetime.duration - reductionAmount);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Get remaining lifetime of an entity\r\n     * @param {number} entityId - Entity to check\r\n     * @returns {number} Remaining time in seconds, or -1 if no lifetime component\r\n     */\r\n    getRemainingLifetime(entityId) {\r\n        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n        if (lifetime) {\r\n            const age = (this.game.state.now - lifetime.startTime);\r\n            return Math.max(0, (lifetime.duration) - age);\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    /**\r\n     * Check if an entity will expire soon\r\n     * @param {number} entityId - Entity to check\r\n     * @param {number} threshold - Time threshold in seconds\r\n     * @returns {boolean} True if entity will expire within threshold\r\n     */\r\n    willExpireSoon(entityId, threshold = 5.0) {\r\n        const remaining = this.getRemainingLifetime(entityId);\r\n        return remaining >= 0 && remaining <= threshold;\r\n    }\r\n    \r\n    /**\r\n     * Remove lifetime component from an entity (makes it permanent)\r\n     * @param {number} entityId - Entity to make permanent\r\n     */\r\n    makeEntityPermanent(entityId) {\r\n        if (this.game.hasComponent(entityId, this.componentTypes.LIFETIME)) {\r\n            this.game.removeComponent(entityId, this.componentTypes.LIFETIME);\r\n            this.destructionCallbacks.delete(entityId);\r\n            this.fadeOutEntities.delete(entityId);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Force immediate destruction of an entity with lifetime\r\n     * @param {number} entityId - Entity to destroy\r\n     * @param {boolean} triggerEffects - Whether to trigger destruction effects\r\n     */\r\n    destroyEntityImmediately(entityId, triggerEffects = true) {\r\n        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n        if (lifetime) {\r\n            if (triggerEffects) {\r\n                this.handleExpiredEntity(entityId, lifetime);\r\n            } else {\r\n                this.destructionCallbacks.delete(entityId);\r\n                this.fadeOutEntities.delete(entityId);\r\n                this.game.destroyEntity(entityId);\r\n                this.stats.entitiesDestroyed++;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Register a custom destruction callback for an entity\r\n     * @param {number} entityId - Entity to register callback for\r\n     * @param {Function} callback - Function to call on destruction\r\n     */\r\n    registerDestructionCallback(entityId, callback) {\r\n        if (typeof callback === 'function') {\r\n            this.destructionCallbacks.set(entityId, callback);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get all entities with lifetime components\r\n     * @returns {Array} Array of entity IDs\r\n     */\r\n    getAllLifetimeEntities() {\r\n        return this.game.getEntitiesWith(this.componentTypes.LIFETIME);\r\n    }\r\n    \r\n    /**\r\n     * Get entities that will expire within a time threshold\r\n     * @param {number} threshold - Time threshold in seconds\r\n     * @returns {Array} Array of entity IDs\r\n     */\r\n    getExpiringEntities(threshold = 5.0) {\r\n        const expiringEntities = [];\r\n        \r\n        const lifetimeEntities = this.getAllLifetimeEntities();\r\n        \r\n        lifetimeEntities.forEach(entityId => {\r\n            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);\r\n            if (lifetime) {\r\n                const age = (this.game.state.now - lifetime.startTime);\r\n                const remaining = lifetime.duration - age;\r\n                \r\n                if (remaining <= threshold && remaining > 0) {\r\n                    expiringEntities.push(entityId);\r\n                }\r\n            }\r\n        });\r\n        \r\n        return expiringEntities;\r\n    }\r\n    \r\n    // =============================================\r\n    // LOGGING AND STATISTICS\r\n    // =============================================\r\n    \r\n    logEntityDestruction(entityId, lifetime) {\r\n       \r\n    }\r\n    \r\n    getStatistics() {\r\n        return { ...this.stats };\r\n    }\r\n    \r\n    resetStatistics() {\r\n        this.stats.entitiesDestroyed = 0;\r\n        this.stats.entitiesExpired = 0;\r\n        this.stats.entitiesFaded = 0;\r\n    }\r\n    \r\n    // =============================================\r\n    // SYSTEM MANAGEMENT\r\n    // =============================================\r\n    \r\n    destroy() {\r\n        // Clean up all tracking maps\r\n        this.destructionCallbacks.clear();\r\n        this.fadeOutEntities.clear();\r\n        this.resetStatistics();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/LifetimeSystem.js",
        "fileName": "LifetimeSystem"
      },
      "MultiplayerUISystem": {
        "script": "class MultiplayerUISystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.uiSystem = this;\r\n        \r\n        // State tracking\r\n        this.currentScreen = null;\r\n        this.gameState = null;\r\n        this.config = {\r\n            maxSquadsPerRound: 2,\r\n            numBackgrounds: 5\r\n        };\r\n    }\r\n\r\n    // GUTS Manager Interface\r\n    init(params) {\r\n        this.params = params || {};\r\n        this.initializeUI();\r\n    }\r\n\r\n    initializeUI() {\r\n        let randomBG = Math.floor(Math.random() * (this.config.numBackgrounds + 1));\r\n        document.body.classList.add(`bg${randomBG}`);\r\n        // Add multiplayer UI elements to existing interface\r\n        const multiplayerHTML = `\r\n            <div id=\"multiplayerHUD\" style=\"display: none; position: absolute; top: 10px; right: 330px; z-index: 1000;\">\r\n                <div class=\"opponent-info\">\r\n                    <h4>Opponent</h4>\r\n                    <div class=\"opponent-stats\">\r\n                        <div>Name: <span id=\"opponentName\">-</span></div>\r\n                        <div>Health: <span id=\"opponentHealth\">100</span></div>\r\n                        <div>Gold: <span id=\"opponentGold\">-</span></div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            \r\n            <div id=\"multiplayerNotifications\" style=\"position: fixed; top: 50px; left: 50%; transform: translateX(-50%); z-index: 2000;\">\r\n                <!-- Notifications appear here -->\r\n            </div>\r\n        `;\r\n        \r\n        document.body.insertAdjacentHTML('beforeend', multiplayerHTML);\r\n    }\r\n\r\n    handleMultiplayerModeSelection(mode) {\r\n        // Create setup dialog for multiplayer\r\n        const setupDialog = document.createElement('div');\r\n        setupDialog.className = 'multiplayer-setup-dialog modal';\r\n\r\n        const interfaceConfig = this.game.getCollections().interfaces[mode.interfaceId]\r\n        setupDialog.innerHTML = interfaceConfig?.html || `Interface ${mode.interfaceId} not found`;\r\n\r\n        document.body.appendChild(setupDialog);\r\n        this.setupMultiplayerDialogEvents(setupDialog, mode);\r\n    }\r\n\r\n    setupMultiplayerDialogEvents(dialog, mode) {\r\n        const playerNameInput = dialog.querySelector('#playerName');\r\n        const quickMatchBtn = dialog.querySelector('#quickMatchBtn');\r\n        const createRoomBtn = dialog.querySelector('#createRoomBtn');\r\n        const joinRoomBtn = dialog.querySelector('#joinRoomBtn');\r\n        const roomIdInput = dialog.querySelector('#roomIdInput');\r\n        const cancelBtn = dialog.querySelector('#cancelMultiplayerBtn');\r\n\r\n        const getPlayerName = () => playerNameInput.value.trim() || 'Player';\r\n\r\n        if (quickMatchBtn) {\r\n            quickMatchBtn.addEventListener('click', () => {\r\n                this.game.networkManager.startQuickMatch(getPlayerName());\r\n                dialog.remove();\r\n            });\r\n        }\r\n\r\n        if (createRoomBtn) {\r\n            createRoomBtn.addEventListener('click', () => {\r\n                this.game.networkManager.createRoom(getPlayerName(), mode.maxPlayers);\r\n                dialog.remove();\r\n            });\r\n        }\r\n\r\n        if (joinRoomBtn) {\r\n            joinRoomBtn.addEventListener('click', () => {\r\n                const roomId = roomIdInput.value.trim().toUpperCase();\r\n                if (roomId) {\r\n                    this.game.networkManager.joinRoom(roomId, getPlayerName());\r\n                    dialog.remove();\r\n                } else {\r\n                    this.showNotification('Please enter a Room ID', 'error');\r\n                }\r\n            });\r\n        }\r\n\r\n        if (cancelBtn) {\r\n            cancelBtn.addEventListener('click', () => {\r\n                dialog.remove();\r\n            });\r\n        }\r\n\r\n        playerNameInput.focus();\r\n        playerNameInput.select();\r\n    }\r\n\r\n    toggleReady() {\r\n        // Disable button while updating\r\n        const btn = document.getElementById('player1ReadyBtn');\r\n        if (btn) {\r\n            btn.disabled = true;\r\n            btn.textContent = 'Updating...';\r\n        }\r\n        this.game.networkManager.toggleReady(() => {\r\n        });\r\n    }\r\n    leaveRoom() {\r\n        this.game.networkManager.leaveRoom();\r\n        this.exitToMainMenu();\r\n    }\r\n\r\n\r\n    setupEventListeners() {\r\n        // Store bound handlers to enable proper cleanup\r\n        if (!this.boundHandlers) {\r\n            this.boundHandlers = {\r\n                readyClick: this.toggleReady.bind(this),\r\n                leaveClick: this.leaveRoom.bind(this)\r\n            };\r\n        }\r\n\r\n        // Clean up any existing listeners\r\n        const readyBtn = document.getElementById('player1ReadyBtn');\r\n        const leaveBtn = document.getElementById('leaveLobbyBtn');\r\n\r\n        if (readyBtn) {\r\n            // Remove old listener if it exists\r\n            readyBtn.removeEventListener('click', this.boundHandlers.readyClick);\r\n            // Add new listener\r\n            readyBtn.addEventListener('click', this.boundHandlers.readyClick);\r\n        } \r\n\r\n        if (leaveBtn) {\r\n            leaveBtn.removeEventListener('click', this.boundHandlers.leaveClick);\r\n            leaveBtn.addEventListener('click', this.boundHandlers.leaveClick);\r\n        }\r\n    }\r\n\r\n    showLobby(gameState, roomId) {\r\n        this.currentScreen = 'lobby';\r\n        this.roomId = roomId;\r\n          \r\n        // Show lobby screen\r\n        document.querySelectorAll('.screen').forEach(screen => {\r\n            screen.classList.remove('active');\r\n        });\r\n        document.getElementById('multiplayerLobby').classList.add('active');\r\n\r\n        this.updateLobby(gameState);\r\n    }\r\n\r\n    updateLobby(gameState) {\r\n        if (!gameState) return;\r\n\r\n        const myPlayerId = this.game.clientNetworkManager.playerId;\r\n        \r\n        // Update room ID\r\n        const lobbyRoomId = document.getElementById('lobbyRoomId');\r\n        if (lobbyRoomId) {\r\n            lobbyRoomId.textContent = this.roomId || '------';\r\n        }\r\n        \r\n        // Update player count\r\n        const playerCount = document.getElementById('playerCount');\r\n        if (playerCount) {\r\n            playerCount.textContent = gameState.players?.length || 0;\r\n        }\r\n\r\n        // Update player cards\r\n        if (gameState.players) {\r\n            const myPlayer = gameState.players.find(p => p.id === myPlayerId);\r\n            const opponent = gameState.players.find(p => p.id !== myPlayerId);\r\n\r\n            // Update my player card (Player 1)\r\n            if (myPlayer) {\r\n                const player1Name = document.getElementById('player1Name');\r\n                const player1Status = document.getElementById('player1Status');\r\n                const player1ReadyBtn = document.getElementById('player1ReadyBtn');\r\n                const player1Info = document.getElementById('player1Info');\r\n\r\n                if (player1Name) {\r\n                    player1Name.textContent = `${myPlayer.name} (You)${myPlayer.isHost ? ' - Host' : ''}`;\r\n                }\r\n                if (player1Status) {\r\n                    player1Status.textContent = myPlayer.ready ? ' Ready for Battle!' : ' Preparing...';\r\n                    player1Status.className = `player-status ${myPlayer.ready ? 'ready' : 'waiting'}`;\r\n                }\r\n                if (player1ReadyBtn) {\r\n                    player1ReadyBtn.disabled = false;\r\n                    player1ReadyBtn.textContent = myPlayer.ready ? ' CANCEL READY' : ' READY FOR BATTLE';\r\n                    player1ReadyBtn.className = myPlayer.ready ? 'ready-btn ready-state' : 'ready-btn';\r\n                }\r\n                if (player1Info) {\r\n                    player1Info.className = `player-card ${myPlayer.ready ? 'ready' : 'waiting'}`;\r\n                }\r\n            }\r\n\r\n            // Update opponent card (Player 2)\r\n            if (opponent) {\r\n                const player2Name = document.getElementById('player2Name');\r\n                const player2Status = document.getElementById('player2Status');\r\n                const player2Info = document.getElementById('player2Info');\r\n\r\n                if (player2Info) {\r\n                    player2Info.style.display = 'block';\r\n                    player2Info.className = `player-card ${opponent.ready ? 'ready' : 'waiting'}`;\r\n                }\r\n                if (player2Name) {\r\n                    player2Name.textContent = `${opponent.name}${opponent.isHost ? ' - Host' : ''}`;\r\n                }\r\n                if (player2Status) {\r\n                    player2Status.textContent = opponent.ready ? ' Ready for Battle!' : ' Preparing...';\r\n                    player2Status.className = `player-status ${opponent.ready ? 'ready' : 'waiting'}`;\r\n                }\r\n            } else {\r\n                // Hide opponent card if no second player\r\n                const player2Info = document.getElementById('player2Info');\r\n                if (player2Info) {\r\n                    player2Info.style.display = 'none';\r\n                }\r\n            }\r\n\r\n            // Update start game button (only for host)\r\n            const startBtn = document.getElementById('startGameBtn');\r\n            if (startBtn && myPlayer?.isHost) {\r\n                const allReady = gameState.players.every(p => p.ready);\r\n                const canStart = gameState.players.length === 2 && allReady;\r\n                \r\n                startBtn.style.display = gameState.players.length === 2 ? 'block' : 'none';\r\n                startBtn.disabled = !canStart;\r\n                startBtn.textContent = allReady ? ' COMMENCE WAR' : 'Waiting for Ready';\r\n            }\r\n\r\n            // Update lobby status message\r\n            const statusMsg = document.getElementById('lobbyStatusMessage');\r\n            if (statusMsg) {\r\n                if (gameState.players.length === 1) {\r\n                    statusMsg.textContent = 'Waiting for worthy opponents...';\r\n                } else if (gameState.players.length === 2) {\r\n                    const allReady = gameState.players.every(p => p.ready);\r\n                    statusMsg.textContent = allReady ? \r\n                        'All warriors ready! Prepare for battle!' : \r\n                        'Opponent found! Awaiting ready status...';\r\n                }\r\n            }\r\n        }\r\n\r\n        // Set up event listeners after DOM is updated\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    onGameStarted(data) {\r\n\r\n        this.currentScreen = 'game';\r\n        \r\n        // Hide lobby, show game\r\n        document.getElementById('multiplayerLobby')?.classList.remove('active');\r\n        document.getElementById('gameScreen')?.classList.add('active');\r\n        \r\n        \r\n    }\r\n\r\n    showNotification(message, type = 'info', duration = 4000) {\r\n        const notification = document.createElement('div');\r\n        notification.textContent = message;\r\n        \r\n        const colors = {\r\n            info: '#00aaff',\r\n            success: '#00ff00',\r\n            warning: '#ffaa00',\r\n            error: '#ff4444'\r\n        };\r\n        \r\n        const color = colors[type] || colors.info;\r\n        notification.style.cssText = `\r\n            background: rgba(0, 0, 0, 0.9); border: 2px solid ${color};\r\n            color: ${color}; padding: 12px 16px; border-radius: 6px;\r\n            margin-bottom: 8px; font-weight: bold; pointer-events: auto; cursor: pointer;\r\n        `;\r\n        \r\n        notification.onclick = () => notification.remove();\r\n        \r\n        const container = document.getElementById('multiplayerNotifications') || document.body;\r\n        container.appendChild(notification);\r\n        \r\n        setTimeout(() => {\r\n            if (notification.parentElement) {\r\n                notification.remove();\r\n            }\r\n        }, duration);\r\n    }\r\n    \r\n    start() {\r\n        this.game.gameManager.call('initializeParticleSystem');\r\n        this.game.gameManager.call('initializeEffectsSystem');\r\n    }\r\n\r\n    exitToMainMenu() {\r\n        this.currentScreen = null;\r\n        this.roomId = null;\r\n        this.isHost = false;\r\n        this.gameState = null;\r\n\r\n        if (this.game.screenManager?.showMainMenu) {\r\n            this.game.screenManager.showMainMenu();\r\n        } else {\r\n            window.location.reload();\r\n        }\r\n    }\r\n\r\n \r\n    dispose() {\r\n        this.networkUnsubscribers.forEach(unsubscribe => {\r\n            if (typeof unsubscribe === 'function') {\r\n                unsubscribe();\r\n            }\r\n        });\r\n        this.networkUnsubscribers = [];\r\n        \r\n    }\r\n    onPlacementPhaseStart() {\r\n        const state = this.game.state;\r\n        state.phase = 'placement';\r\n        state.phaseTimeLeft = null; // No timer in multiplayer\r\n        state.playerReady = false;\r\n        state.enemyPlacementComplete = false; // Actually opponent placement\r\n        state.roundEnding = false;          \r\n    }\r\n    \r\n    onBattleEnd() {\r\n\r\n            \r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const entitiesToDestroy = new Set();\r\n        \r\n        [\r\n            ComponentTypes.CORPSE\r\n        ].forEach(componentType => {\r\n            const entities = this.game.getEntitiesWith(componentType);\r\n            entities.forEach(id => entitiesToDestroy.add(id));\r\n        });\r\n        \r\n        entitiesToDestroy.forEach(entityId => {\r\n            try {\r\n                this.game.destroyEntity(entityId); \r\n            } catch (error) {\r\n                console.warn(`Error destroying entity ${entityId}:`, error);\r\n            }\r\n        });\r\n        \r\n        \r\n    }\r\n       \r\n    startVictoryCelebration(victoriousUnits) {\r\n        // Determine which team won\r\n        const firstUnit = victoriousUnits[0];\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const team = this.game.getComponent(firstUnit, ComponentTypes.TEAM);\r\n        const teamType = team?.team || 'player';\r\n\r\n        victoriousUnits.forEach(entityId => {\r\n            this.game.gameManager.call('startCelebration', entityId, teamType);\r\n        });\r\n    }\r\n\r\n    update() {\r\n        this.updatePhaseUI();\r\n        this.updateGoldDisplay();\r\n        this.updateRoundDisplay();\r\n        this.updateSideDisplay();\r\n    }\r\n\r\n    handleRoundResult(roundResult) {\r\n        const state = this.game.state;\r\n        state.phase = 'ended'; \r\n    }\r\n\r\n    updatePhaseUI() {\r\n        const state = this.game.state;\r\n        \r\n        // Update round number\r\n \r\n         \r\n        // Update phase status\r\n        const phaseStatusEl = document.getElementById('phaseStatus');\r\n        if (phaseStatusEl) {\r\n            if (state.phase === 'placement') {\r\n                if (state.playerReady) {\r\n                    phaseStatusEl.textContent = 'Army deployed! Waiting for opponent...';\r\n                } else {\r\n                    phaseStatusEl.textContent = 'Deploy your units and get ready!';\r\n                }\r\n            } else if (state.phase === 'battle') {\r\n                phaseStatusEl.textContent = 'Battle in progress! Watch your units fight!';\r\n            }\r\n        }\r\n    }\r\n    \r\n    updateGoldDisplay() {\r\n        const goldDisplay = document.getElementById('playerGold');\r\n        if (goldDisplay) {\r\n            goldDisplay.textContent = this.game.state.playerGold || 0;\r\n        }\r\n    }\r\n    \r\n    updateRoundDisplay() {\r\n        const roundNumberEl = document.getElementById('currentRound');\r\n        if (roundNumberEl) {\r\n            roundNumberEl.textContent = this.game.state.round || 1;\r\n        }\r\n    }\r\n    updateSideDisplay() {\r\n        const sideDisplay = document.getElementById('playerSide');\r\n        if (sideDisplay) {\r\n            sideDisplay.textContent = this.game.state.mySide || 0;\r\n        }\r\n    }\r\n   \r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerUISystem.js",
        "fileName": "MultiplayerUISystem"
      },
      "SupplySystem": {
        "script": "class SupplySystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.supplySystem = this;\r\n        this.supplyElement = null;\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('getCurrentSupply', this.getCurrentSupply.bind(this));\r\n        this.game.gameManager.register('getCurrentPopulation', this.getCurrentPopulation.bind(this));\r\n        this.game.gameManager.register('canAffordSupply', this.canAffordSupply.bind(this));\r\n        if(!this.game.isServer){\r\n            this.supplyElement = document.getElementById('playerSupplies');\r\n        }\r\n        \r\n    }\r\n\r\n    updateSupplyDisplay() {\r\n        if (!this.supplyElement) return;\r\n\r\n        const team = this.game.state.mySide;\r\n        if (!team) return;\r\n\r\n        const currentPop = this.getCurrentPopulation(team);\r\n        const currentSupply = this.getCurrentSupply(team);\r\n\r\n        const isAtLimit = currentPop >= currentSupply;\r\n\r\n        this.supplyElement.innerHTML = `${currentPop}/${currentSupply}`;\r\n    }\r\n\r\n    update() {\r\n        if(this.game.isServer) return;\r\n        if (this.game.state.phase === 'placement') {\r\n            this.updateSupplyDisplay();\r\n        }\r\n    }\r\n\r\n    getCurrentSupply(team) {\r\n        const placements = this.game.gameManager.call('getPlacementsForSide', team);\r\n        if (!placements) return 0;\r\n\r\n        let totalSupply = 0;\r\n\r\n        placements.forEach(placement => {     \r\n            if(placement.unitType.supplyProvided){      \r\n                totalSupply += placement.unitType.supplyProvided;            \r\n            }\r\n        });\r\n        return totalSupply;\r\n    }\r\n\r\n\r\n    getCurrentPopulation(team) {\r\n        const placements = this.game.gameManager.call('getPlacementsForSide', team);\r\n        if (!placements) return 0;\r\n\r\n        let totalPopulation = 0;\r\n\r\n        placements.forEach(placement => {     \r\n            if(placement.unitType.supplyCost){      \r\n                totalPopulation += placement.unitType.supplyCost;            \r\n            }\r\n        });\r\n        return totalPopulation;\r\n    }\r\n\r\n    canAffordSupply(team, unitType) {\r\n        const currentPop = this.getCurrentPopulation(team);\r\n        const currentSupply = this.getCurrentSupply(team);\r\n        const supplyCost = unitType.supplyCost || 0;\r\n\r\n        return (currentPop + supplyCost) <= currentSupply;\r\n    }\r\n\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SupplySystem.js",
        "fileName": "SupplySystem"
      },
      "ServerBattlePhaseSystem": {
        "script": "class ServerBattlePhaseSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.engine = this.game.app;    \r\n        this.game.serverBattlePhaseSystem = this;\r\n        this.serverNetworkManager = this.engine.serverNetworkManager;\r\n        \r\n        // Battle configuration\r\n        this.maxBattleDuration = 30; // 90 seconds max\r\n        this.minBattleDuration = 29;\r\n        this.currentBattleTime = 0;\r\n        // Battle state tracking\r\n        this.battleResults = new Map();\r\n        this.createdSquads = new Map();\r\n        this.maxRounds = 5;\r\n        this.baseGoldPerRound = 50;\r\n    }\r\n\r\n    init(params) {\r\n        this.params = params || {};\r\n\r\n        this.game.gameManager.register('startBattle', this.startBattle.bind(this));\r\n        this.game.gameManager.register('spawnSquadFromPlacement', this.spawnSquadFromPlacement.bind(this));\r\n    }\r\n\r\n    startBattle(room) {\r\n        try {\r\n\r\n            this.game.state.isPaused = false;\r\n            // Change room phase\r\n            this.game.state.phase = 'battle';\r\n            \r\n            return { success: true };\r\n            \r\n        } catch (error) {\r\n            console.error('Error in startBattle:', error);\r\n            return { success: false, error: error.message };\r\n        }\r\n    }\r\n    spawnSquadFromPlacement(playerId, placement) {\r\n        try {\r\n            const player = this.game.room.getPlayer(playerId);\r\n            \r\n            if (!this.game.unitCreationManager) {\r\n                throw new Error('Unit creation manager not available');\r\n            }\r\n            \r\n            // Get placements from placement phase manager\r\n            const placementManager = this.game.placementSystem;\r\n            if (!placementManager) {\r\n                throw new Error('Placement phase manager not available');\r\n            }\r\n            let createdSquad = null;\r\n      \r\n            // Create squads using unit creation manager\r\n            createdSquad = this.game.unitCreationManager.createSquadFromPlacement(\r\n                placement,\r\n                player.stats.side,\r\n                playerId\r\n            );\r\n\r\n            if(!createdSquad){\r\n                console.log(\"Failed to create squads\");\r\n                return { success: false };\r\n            } else {\r\n                // Store created squads for tracking\r\n                let playerSquads = this.createdSquads.get(playerId);\r\n                if(playerSquads){\r\n                    playerSquads.push(createdSquad);\r\n                } else {\r\n                    playerSquads = [createdSquad];                    \r\n                }\r\n                this.createdSquads.set(playerId, playerSquads);\r\n                return { success: true, squad: createdSquad };\r\n            }\r\n            \r\n        } catch (error) {\r\n            console.error('Error spawning units from placements:', error);\r\n            return { success: false, error: `Failed to spawn units: ${error.message}` };\r\n        }\r\n    }\r\n\r\n    // Called by game update loop to check for battle end\r\n    update() {\r\n        if (this.game.state?.phase !== 'battle') {\r\n            return;\r\n        }\r\n        this.currentBattleTime += this.game.state.deltaTime;\r\n        // Check for battle end conditions\r\n        this.checkForBattleEnd();\r\n    }\r\n\r\n    checkForBattleEnd() {\r\n        if (!this.game.componentManager) return;\r\n        \r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const allBattleEntities = this.game.getEntitiesWith(\r\n            ComponentTypes.TEAM,\r\n            ComponentTypes.HEALTH,\r\n            ComponentTypes.UNIT_TYPE\r\n        );\r\n\r\n        const aliveEntities = allBattleEntities.filter(entityId => {\r\n            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n            const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);\r\n            return health && health.current > 0 && (!deathState || !deathState.isDying);\r\n        });\r\n\r\n        const teams = new Map();\r\n        for (const entityId of aliveEntities) {\r\n            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n            if (team) {\r\n                if (!teams.has(team.team)) {\r\n                    teams.set(team.team, []);\r\n                }\r\n                teams.get(team.team).push(entityId);\r\n            }\r\n        }\r\n        const aliveTeams = Array.from(teams.keys());\r\n           \r\n        const noCombatActive = this.checkNoCombatActive(aliveEntities);\r\n        const allUnitsAtTarget = this.checkAllUnitsAtTargetPosition(aliveEntities);\r\n        \r\n        if( this.currentBattleTime < this.minBattleDuration){\r\n            return;\r\n        }\r\n        if( this.currentBattleTime > this.maxBattleDuration){\r\n            this.endBattle(this.game.room, null);\r\n            return;\r\n        }\r\n\r\n        if (aliveEntities.length === 0) {\r\n            console.log('no alive entities');\r\n            this.endBattle(this.game.room, null);\r\n            return;\r\n        }\r\n        \r\n        if (aliveTeams.length === 1 && allUnitsAtTarget) {\r\n            console.log('aliveTeams length is 1', aliveTeams, aliveEntities);\r\n            console.log('all entities', allBattleEntities);\r\n            console.log('aliveEntities', aliveEntities);\r\n            this.endBattle(this.game.room, aliveTeams[0]);\r\n            return;\r\n        }\r\n     \r\n        if (noCombatActive && allUnitsAtTarget) {\r\n            console.log('no combat active and all units at target');\r\n            this.endBattle(this.game.room, null);\r\n        }\r\n    }\r\n\r\n    checkNoCombatActive(aliveEntities) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        for (const entityId of aliveEntities) {\r\n            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);\r\n         //   console.log(entityId, 'currentTarget', aiState.target);\r\n            if (aiState && aiState.target) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    checkAllUnitsAtTargetPosition(aliveEntities) {\r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const TARGET_POSITION_THRESHOLD = 20;\r\n        \r\n        for (const entityId of aliveEntities) {\r\n            const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);\r\n            const targetPos = aiState?.targetPosition;\r\n\r\n            if (!pos || !targetPos) {\r\n                continue;\r\n            }\r\n            const distance = Math.sqrt(\r\n                Math.pow(targetPos.x - pos.x, 2) + \r\n                Math.pow(targetPos.z - pos.z, 2)\r\n            );\r\n  \r\n            if (distance > TARGET_POSITION_THRESHOLD) {\r\n                return false;\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    endBattle(room, winner = null, reason = 'unknown') {\r\n\r\n        this.game.triggerEvent('onBattleEnd');        \r\n        const playerStats = this.getPlayerStats(room);\r\n        let battleResult = {\r\n            winner: winner,\r\n            reason: reason,\r\n            round: this.game.state.round,\r\n            survivingUnits: this.getSurvivingUnits(),\r\n            playerStats: playerStats\r\n        };\r\n        \r\n        const entitySync = this.serializeAllEntities();\r\n        // Broadcast with updated health values\r\n        this.serverNetworkManager.broadcastToRoom(room.id, 'BATTLE_END', {\r\n            result: battleResult,\r\n            gameState: room.getGameState(), // This will also have updated player health\r\n            entitySync: entitySync\r\n        });\r\n        // Check for game end or continue to next round\r\n        if (this.shouldEndGame(room)) {\r\n            this.endGame(room);\r\n        } else {\r\n            this.game.state.round += 1;\r\n            // Transition back to placement phase\r\n            this.game.state.phase = 'placement';\r\n            // Reset placement ready states\r\n            for (const [playerId, player] of room.players) {\r\n                player.placementReady = false;\r\n            }\r\n            this.game.triggerEvent('onPlacementPhaseStart');\r\n        }\r\n    }\r\n\r\n\r\n    serializeAllEntities() {\r\n        const serialized = {};\r\n        \r\n        for (const [entityId, componentTypes] of this.game.entities) {\r\n            serialized[entityId] = {};\r\n            \r\n            for (const componentType of componentTypes) {\r\n                const component = this.game.getComponent(entityId, componentType);\r\n                if (component) {\r\n                    serialized[entityId][componentType] = JSON.parse(JSON.stringify(component));\r\n                }\r\n            }\r\n        }\r\n        \r\n        return serialized;\r\n    }\r\n    calculateRoundGold(round) {\r\n        return this.baseGoldPerRound + (round * this.baseGoldPerRound);\r\n    }\r\n    getSurvivingUnits() {\r\n        const survivors = {};\r\n        \r\n        // Count surviving units from created squads\r\n        for (const [playerId, squads] of this.createdSquads) {\r\n            let survivingCount = 0;\r\n            let sideSurvivors = [];\r\n            for (const squad of squads) {\r\n                if (squad.squadUnits && this.game.componentManager) {\r\n                    const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n                    \r\n                    for (const entityId of squad.squadUnits) {\r\n                        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n                        const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);\r\n                  \r\n                        if (health && health.current > 0 && (!deathState || !deathState.isDying)) {\r\n                            sideSurvivors.push(entityId);\r\n                            survivingCount++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            survivors[playerId] = sideSurvivors;\r\n        }\r\n        \r\n        return survivors;\r\n    }\r\n\r\n    getPlayerStats(room) {\r\n        const stats = {};\r\n        for (const [playerId, player] of room.players) {\r\n            stats[playerId] = {\r\n                name: player.name,\r\n                stats: player.stats\r\n            };\r\n        }\r\n        return stats;\r\n    }\r\n\r\n    shouldEndGame(room) {\r\n        const alivePlayers = Array.from(room.players.values()).filter(p => (p.stats.health) > 0);\r\n        return alivePlayers.length <= 1;\r\n    }\r\n\r\n  \r\n    addGoldForTeam(goldAmt, team){\r\n        for (const [playerId, player] of room.players) {\r\n            if(player.side == team){\r\n                player.stats.gold = player.stats.gold + goldAmt;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    endGame(room) {\r\n        this.game.state.phase = 'ended';\r\n        \r\n        // Determine final winner\r\n        let finalWinner = null;\r\n        let maxHealth = -1;\r\n        \r\n        for (const [playerId, player] of room.players) {\r\n            const health = player.stats.health;\r\n            if (health > maxHealth) {\r\n                maxHealth = health;\r\n                finalWinner = playerId;\r\n            }\r\n        }\r\n        \r\n        const gameResult = {\r\n            winner: finalWinner,\r\n            finalStats: this.getPlayerStats(room),\r\n            totalRounds: this.game.state.round\r\n        };\r\n        \r\n        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_END', {\r\n            result: gameResult,\r\n            gameState: room.getGameState()\r\n        });\r\n        \r\n        // Mark room as inactive after delay\r\n        setTimeout(() => {\r\n            room.isActive = false;\r\n        }, 10000);\r\n    }\r\n\r\n    onBattleEnd() {\r\n\r\n        if (!this.game.componentManager) return;\r\n        \r\n        this.currentBattleTime = 0;\r\n        \r\n        const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n        const entitiesToDestroy = new Set();\r\n        \r\n        // Collect battle entities (but not players)\r\n        [\r\n            ComponentTypes.CORPSE\r\n        ].forEach(componentType => {\r\n            const entities = this.game.getEntitiesWith(componentType);\r\n            entities.forEach(id => {\r\n                entitiesToDestroy.add(id);                \r\n            });\r\n        });\r\n        \r\n        // Destroy entities\r\n        entitiesToDestroy.forEach(entityId => {\r\n            try {\r\n                this.game.destroyEntity(entityId);\r\n            } catch (error) {\r\n                console.warn(`Error destroying entity ${entityId}:`, error);\r\n            }\r\n        });\r\n  \r\n        // Clear squad references\r\n        this.createdSquads.clear();\r\n    }\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerBattlePhaseSystem.js",
        "fileName": "ServerBattlePhaseSystem"
      },
      "SquadExperienceSystem": {
        "script": "class SquadExperienceSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.squadExperienceSystem = this;\r\n        \r\n        // Squad experience tracking\r\n        this.squadExperience = new Map(); // placementId -> experience data\r\n        this.savedSquadExperience = new Map(); // placementId -> saved experience data\r\n        \r\n        // Experience configuration\r\n        this.config = {\r\n            experiencePerLevel: 15,     // Base experience needed per level\r\n            maxLevel: 10,                // Maximum squad level\r\n            levelUpCostRatio: 0.5,       // Cost to level up = squad value * ratio\r\n            experienceMultiplier: 1.0,   // Global experience gain multiplier\r\n            baselineXPPerSecond: 1,   // tune: ~13% of a cheap units value per 10s\r\n            baselineXPCombatOnly: true  // only tick during combat phase\r\n        };\r\n        \r\n        // Level bonuses (applied to all units in squad)\r\n        this.levelBonuses = {\r\n            1: { hp: 1.0, damage: 1.0, name: \"Rookie\" },            \r\n            2: { hp: 1.15, damage: 1.15, name: \"Veteran\" },\r\n            3: { hp: 1.3, damage: 1.3, name: \"Ascended\" },\r\n            4: { hp: 1.4, damage: 1.4, name: \"Elite\" },\r\n            5: { hp: 1.5, damage: 1.5, name: \"Champion\" },\r\n            6: { hp: 1.6, damage: 1.6, name: \"Legendary\" },\r\n            7: { hp: 1.7, damage: 1.7, name: \"Mythic\" },\r\n            8: { hp: 1.8, damage: 1.8, name: \"Divine\" },\r\n            9: { hp: 1.9, damage: 1.9, name: \"Transcendent\" },\r\n            10: { hp: 2.0, damage: 2.0, name: \"Godlike\" }\r\n        };\r\n        \r\n        // UI update throttling\r\n        this.lastUIUpdate = 0;\r\n        this.UI_UPDATE_INTERVAL = 500; // Update UI every 500ms\r\n\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('canAffordLevelUp', this.canAffordLevelUp.bind(this));\r\n        this.game.gameManager.register('applySpecialization', this.applySpecialization.bind(this));\r\n        this.game.gameManager.register('levelUpSquad', this.levelUpSquad.bind(this));\r\n        this.game.gameManager.register('getLevelUpCost', this.getLevelUpCost.bind(this));\r\n        this.game.gameManager.register('initializeSquad', this.initializeSquad.bind(this));\r\n        this.game.gameManager.register('removeSquad', this.removeSquad.bind(this));\r\n        this.game.gameManager.register('getSquadsReadyToLevelUp', this.getSquadsReadyToLevelUp.bind(this));\r\n        this.game.gameManager.register('showSpecializationSelection', this.showSpecializationSelection.bind(this));\r\n        this.game.gameManager.register('findSquadByUnitId', this.findSquadByUnitId.bind(this));\r\n        this.game.gameManager.register('getCurrentUnitType', this.getCurrentUnitType.bind(this));\r\n        this.game.gameManager.register('getSquadInfo', this.getSquadInfo.bind(this));\r\n        this.game.gameManager.register('resetSquadExperience', this.reset.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Initialize experience tracking for a new squad\r\n     * @param {string} placementId - Unique placement identifier\r\n     * @param {Object} unitType - Unit type definition (not squadData)\r\n     * @param {Array} unitIds - Array of entity IDs in the squad\r\n     * @param {string} team - Team identifier\r\n     */\r\n    initializeSquad(placementId, unitType, unitIds, team) {\r\n        // Check if we already have experience data for this placement ID\r\n        const existingData = this.squadExperience.get(placementId);\r\n        if (existingData) {\r\n       \r\n            // Update unit IDs and size for respawned squad\r\n            existingData.unitIds = [...unitIds];\r\n            existingData.squadSize = unitIds.length;\r\n            \r\n            // Apply level bonuses to new units\r\n            this.applyLevelBonuses(placementId);\r\n            return existingData;\r\n        }\r\n        \r\n        // Create new squad data\r\n        const squadValue = this.calculateSquadValue(unitType);\r\n        \r\n        const experienceData = {\r\n            placementId: placementId,\r\n            level: 1,\r\n            experience: 0,\r\n            experienceToNextLevel: this.calculateExperienceNeeded(0),\r\n            squadValue: squadValue,\r\n            unitIds: [...unitIds],\r\n            team: team,\r\n            squadSize: unitIds.length,\r\n            canLevelUp: false,\r\n            totalUnitsInSquad: unitIds.length, // Just use actual unit count\r\n            lastExperienceGain: 0,\r\n            creationTime: this.game.state.now\r\n        };\r\n        \r\n        this.squadExperience.set(placementId, experienceData);\r\n        \r\n        // Try to restore saved experience for player squads\r\n  \r\n        this.restoreSquadExperience(placementId, experienceData);\r\n        \r\n        // Apply initial bonuses if any\r\n        this.applyLevelBonuses(placementId);\r\n         return experienceData;\r\n    }\r\n    /**\r\n     * Add experience to a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     * @param {number} experience - Experience to add\r\n     */\r\n    addExperience(placementId, experience) {\r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (!squadData) return;\r\n        \r\n        // Don't gain experience if already at max level or ready to level up\r\n        if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) {\r\n            return;\r\n        }\r\n        \r\n        squadData.experience += experience;\r\n        squadData.lastExperienceGain = this.game.state.now;\r\n        \r\n        // Check if squad can level up\r\n        if (squadData.experience >= squadData.experienceToNextLevel) {\r\n            squadData.canLevelUp = true;\r\n            // Stop gaining experience until manually leveled up\r\n            squadData.experience = squadData.experienceToNextLevel;\r\n                \r\n        }\r\n        \r\n        // Update UI periodically\r\n        if (this.game.state.now - this.lastUIUpdate > this.UI_UPDATE_INTERVAL) {\r\n            this.updateSquadUI();\r\n            this.lastUIUpdate = this.game.state.now;\r\n        }\r\n    }\r\n    getLevelUpCost(placementId){\r\n        \r\n        const squadData = this.squadExperience.get(placementId);\r\n        if(squadData){\r\n            const levelUpCost = this.getLevelUpCostBySquadValue(squadData.squadValue)\r\n\r\n            return levelUpCost;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    getLevelUpCostBySquadValue(squadValue){\r\n        return Math.floor(squadValue * this.config.levelUpCostRatio);\r\n    }\r\n    canAffordLevelUp(placementId, playerGold){\r\n                \r\n        const levelUpCost = this.getLevelUpCost(placementId);\r\n\r\n         if (levelUpCost < 0 || playerGold < levelUpCost) {    \r\n            return false;\r\n         }\r\n         return true;\r\n    }\r\n    /**\r\n     * Level up a squad (only during placement phase)\r\n     * @param {string} placementId - Squad placement ID\r\n     * @param {string} specializationId - Optional specialization unit ID (for level 3+)\r\n     * @returns {boolean} Success status\r\n     */\r\n    async levelUpSquad(placementId, specializationId = null, playerId = null, callback) {\r\n        if (this.game.state.phase !== 'placement') {\r\n            console.log(\"incorrect phase to level up\");\r\n            callback(false);\r\n        }\r\n        \r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (!squadData || !squadData.canLevelUp) {\r\n            console.log(\"squad cant level up\", placementId, squadData, this.squadExperience);\r\n            callback(false);\r\n        };        \r\n                        \r\n        // Check for specialization selection UI (unchanged)\r\n        const isSpecializationLevel = squadData.level >= 2;\r\n        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);\r\n        const hasSpecializations = currentUnitType && currentUnitType.specUnits && currentUnitType.specUnits.length > 0;\r\n        if (!this.game.isServer && isSpecializationLevel && hasSpecializations && !specializationId) {\r\n            this.showSpecializationSelection(placementId, squadData, callback);\r\n            console.log('showing spec selection');\r\n            return;\r\n        }\r\n        \r\n        \r\n        try {\r\n            if (!this.game.isServer) {\r\n                // Handle specialization case\r\n                if (specializationId && isSpecializationLevel && hasSpecializations) {\r\n                    const success = await this.makeNetworkCall('LEVEL_SQUAD', \r\n                        { placementId, specializationId }, 'SQUAD_LEVELED');\r\n       \r\n                    if (!success) {\r\n                        console.log('no success making network call apply_spec or level_squad');\r\n                        callback(false);\r\n                    } \r\n                    this.applySpecialization(placementId, specializationId, playerId);\r\n                } else {\r\n                    // Handle regular level up\r\n                    const success = await this.makeNetworkCall('LEVEL_SQUAD', \r\n                        { placementId }, 'SQUAD_LEVELED');\r\n                    \r\n                    if (!success) {\r\n                        console.log('no success making network call level_squad');\r\n                        callback(false);\r\n                    }\r\n                }\r\n            } \r\n                \r\n            // Deduct cost optimistically\r\n            callback(this.finishLevelingSquad(squadData, placementId, specializationId));\r\n            \r\n        } catch (error) {\r\n            // Refund gold on any error\r\n            console.log('failed to level squad', error);\r\n            callback(false);\r\n        }\r\n    }\r\n\r\n    // Helper method to promisify network calls\r\n    makeNetworkCall(action, data, expectedResponse) {\r\n        return new Promise((resolve, reject) => {\r\n            this.game.clientNetworkManager.call(action, data, expectedResponse, (responseData, error) => {\r\n                if(responseData && responseData.success) {\r\n                    resolve(responseData);\r\n                } else {\r\n                    reject(error);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    finishLevelingSquad(squadData, placementId, specializationId) {\r\n        console.log('finishLevelingSquad');\r\n        // Level up\r\n        squadData.level++;\r\n        squadData.experience = 0;\r\n        squadData.experienceToNextLevel = this.calculateExperienceNeeded(squadData.level);\r\n        squadData.canLevelUp = false;\r\n        \r\n        // Apply level bonuses to all units in squad\r\n        this.applyLevelBonuses(placementId);\r\n        \r\n        const levelUpCost = this.getLevelUpCost(placementId);  \r\n        this.game.state.playerGold -= levelUpCost;\r\n            \r\n        console.log('leveling squad for cost', placementId, levelUpCost);\r\n        // Visual effects\r\n        squadData.unitIds.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);\r\n            if (pos) {\r\n                const effectType = specializationId ? 'magic' : 'heal';\r\n                this.game.gameManager.call('createParticleEffect',\r\n                    pos.x, pos.y + 20, pos.z,\r\n                    effectType,\r\n                    { count: 3, speedMultiplier: specializationId ? 1.5 : 1.2 }\r\n                );\r\n            }\r\n        });\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Apply specialization transformation to a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     * @param {string} specializationId - Specialization unit type ID\r\n     * @returns {boolean} Success status\r\n     */\r\n    applySpecialization(placementId, specializationId, playerId) {\r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (!squadData) return false;\r\n        \r\n        // Get the specialization unit type\r\n        const collections = this.game.getCollections();\r\n        if (!collections || !collections.units || !collections.units[specializationId]) {\r\n            console.error(`Specialization unit type ${specializationId} not found`);\r\n            return false;\r\n        }\r\n        \r\n        const specializationUnitType = collections.units[specializationId];\r\n        \r\n        // Find the placement in PlacementSystem to update the unit type\r\n        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n        if (!placement) {\r\n            console.error(`Placement ${placementId} not found`);\r\n            return false;\r\n        }\r\n        \r\n        // Update the placement's unit type\r\n        const oldUnitType = placement.unitType;\r\n        placement.unitType = { id: specializationId, ...specializationUnitType };\r\n        \r\n        // Recreate all units in the squad with the new unit type\r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        const newUnitIds = [];\r\n        \r\n        console.log('applying specialization to ', squadData, squadData.unitIds);\r\n        console.log('placement', placement);\r\n        // Store positions of old units\r\n        const positions = [];\r\n        squadData.unitIds.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, componentTypes.POSITION);\r\n            if (pos) {\r\n                positions.push({ x: pos.x, y: pos.y, z: pos.z });\r\n            }\r\n            // Destroy old unit\r\n            if (this.game.destroyEntity) {\r\n                this.game.destroyEntity(entityId);\r\n            }\r\n        });\r\n        \r\n        // Create new specialized units at the same positions\r\n        positions.forEach(pos => {\r\n            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);\r\n            const unitY = terrainHeight !== null ? terrainHeight : pos.y;\r\n            \r\n            const entityId = this.game.unitCreationManager.create(\r\n                pos.x, unitY, pos.z, \r\n                placement.targetPosition,\r\n                placement, \r\n                squadData.team\r\n            );\r\n            console.log('created new unit', placement.unitType, entityId);\r\n            newUnitIds.push(entityId);\r\n        });\r\n        \r\n        // Update squad data with new unit IDs\r\n        squadData.unitIds = newUnitIds;\r\n        \r\n        // Update squad value based on new unit type\r\n        squadData.squadValue = this.calculateSquadValue(placement.unitType);\r\n\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Show specialization selection UI\r\n     * @param {string} placementId - Squad placement ID\r\n     * @param {Object} squadData - Squad experience data\r\n     */\r\n    showSpecializationSelection(placementId, squadData, callback) {\r\n        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);\r\n        if (!currentUnitType || !currentUnitType.specUnits) return;\r\n        \r\n        const collections = this.game.getCollections();\r\n        if (!collections || !collections.units) return;\r\n        \r\n        // Create specialization selection modal\r\n        const modal = document.createElement('div');\r\n        modal.className = 'specialization-modal';\r\n        modal.style.cssText = `\r\n            position: fixed; top: 0; left: 0; width: 100%; height: 100%;\r\n            background: rgba(0, 0, 0, 0.8); z-index: 10000;\r\n            display: flex; justify-content: center; align-items: center;\r\n        `;\r\n        \r\n        const content = document.createElement('div');\r\n        content.style.cssText = `\r\n            background: linear-gradient(145deg, #1a1a2e, #16213e);\r\n            border: 2px solid #ffaa00; border-radius: 10px;\r\n            padding: 20px; max-width: 600px; width: 90%;\r\n            color: #fff; text-align: center;\r\n        `;\r\n        \r\n        const squadName = this.getSquadDisplayName(placementId);\r\n        content.innerHTML = `\r\n            <h3 style=\"color: #ffaa00; margin-bottom: 15px;\"> SPECIALIZATION AVAILABLE! </h3>\r\n            <p style=\"margin-bottom: 20px;\">Choose a specialization for your ${squadName}:</p>\r\n            <div id=\"specialization-options\" style=\"margin-bottom: 20px;\"></div>\r\n            <button id=\"cancel-specialization\" style=\"\r\n                background: #666; color: #fff; border: none; padding: 8px 16px;\r\n                border-radius: 4px; cursor: pointer; margin-right: 10px;\r\n            \">Cancel</button>\r\n        `;\r\n        \r\n        modal.appendChild(content);\r\n        \r\n        // Add specialization options\r\n        const optionsContainer = content.querySelector('#specialization-options');\r\n        currentUnitType.specUnits.forEach(specId => {\r\n            const specUnit = collections.units[specId];\r\n            if (specUnit) {\r\n                const optionButton = document.createElement('button');\r\n                optionButton.style.cssText = `\r\n                    display: block; width: 100%; margin: 8px 0; padding: 12px;\r\n                    background: linear-gradient(135deg, #006600, #008800);\r\n                    color: white; border: 1px solid #00aa00; border-radius: 4px;\r\n                    cursor: pointer; transition: all 0.2s ease;\r\n                `;\r\n                \r\n                const squadValue = this.calculateSquadValue(specUnit);\r\n                const levelUpCost = this.getLevelUpCostBySquadValue(squadValue);\r\n                optionButton.innerHTML = `\r\n                    <strong>${specUnit.title || specId}</strong><br>\r\n                    <small style=\"opacity: 0.8;\">${specUnit.hp || 100} HP, ${specUnit.damage || 10} DMG - Cost: ${levelUpCost}g</small>\r\n                `;\r\n                \r\n                optionButton.addEventListener('click', () => {\r\n                    document.body.removeChild(modal);\r\n                    this.levelUpSquad(placementId, specId, null, callback);\r\n                });\r\n                \r\n                optionButton.addEventListener('mouseenter', () => {\r\n                    optionButton.style.background = 'linear-gradient(135deg, #008800, #00aa00)';\r\n                    optionButton.style.transform = 'translateY(-2px)';\r\n                });\r\n                \r\n                optionButton.addEventListener('mouseleave', () => {\r\n                    optionButton.style.background = 'linear-gradient(135deg, #006600, #008800)';\r\n                    optionButton.style.transform = 'translateY(0)';\r\n                });\r\n                \r\n                optionsContainer.appendChild(optionButton);\r\n            }\r\n        });\r\n        \r\n        // Cancel button\r\n        content.querySelector('#cancel-specialization').addEventListener('click', () => {\r\n            document.body.removeChild(modal);\r\n        });\r\n        \r\n        // Close on escape\r\n        const escHandler = (e) => {\r\n            if (e.key === 'Escape') {\r\n                document.body.removeChild(modal);\r\n                document.removeEventListener('keydown', escHandler);\r\n            }\r\n        };\r\n        document.addEventListener('keydown', escHandler);\r\n        \r\n        document.body.appendChild(modal);\r\n    }\r\n    \r\n    /**\r\n     * Get the current unit type for a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {Object|null} Unit type or null if not found\r\n     */\r\n    getCurrentUnitType(placementId, side) {\r\n        const placements = this.game.gameManager.call('getPlacementsForSide', side);\r\n        if(placements){\r\n            const placement = placements.find(p => p.placementId === placementId);\r\n            return placement ? placement.unitType : null;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Apply level bonuses to all units in a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     */\r\n    applyLevelBonuses(placementId) {\r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (!squadData || squadData.level <= 1) {\r\n            return;\r\n        }\r\n        \r\n        const bonuses = this.levelBonuses[squadData.level];\r\n        if (!bonuses) {\r\n            return;\r\n        }\r\n        \r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        squadData.unitIds.forEach(entityId => {\r\n            const unitType = this.game.getComponent(entityId, componentTypes.UNIT_TYPE);\r\n            if (unitType) {\r\n                const baseUnitData = this.game.getCollections().units[unitType.id];\r\n            \r\n                // Apply health bonus\r\n                const health = this.game.getComponent(entityId, componentTypes.HEALTH);\r\n                if (health && bonuses.hp > 1) {\r\n                    const newMaxHealth = Math.floor(baseUnitData.hp * bonuses.hp);\r\n                    const healthIncrease = newMaxHealth - health.max;\r\n                    health.max = newMaxHealth;\r\n                    health.current += healthIncrease; // Also increase current health\r\n                }\r\n                \r\n                // Apply damage bonus\r\n                const combat = this.game.getComponent(entityId, componentTypes.COMBAT);\r\n                if (combat && bonuses.damage > 1) {\r\n                    combat.damage = Math.floor(baseUnitData.damage * bonuses.damage);\r\n                }\r\n                \r\n                // Visual indicator (flash effect)\r\n                const animation = this.game.getComponent(entityId, componentTypes.ANIMATION);\r\n                if (animation) {\r\n                    animation.flash = 0.8;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Calculate total health of all units in a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {number} Total health\r\n     */\r\n    calculateSquadTotalHealth(placementId) {\r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (!squadData) return 100; // Default fallback\r\n        \r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        let totalHealth = 0;\r\n        \r\n        squadData.unitIds.forEach(entityId => {\r\n            const health = this.game.getComponent(entityId, componentTypes.HEALTH);\r\n            if (health) {\r\n                totalHealth += health.max;\r\n            }\r\n        });\r\n        \r\n        return Math.max(1, totalHealth); // Avoid division by zero\r\n    }\r\n    \r\n    /**\r\n     * Calculate squad value based on unit type\r\n     * @param {Object} unitType - Unit type definition\r\n     * @returns {number} Squad value (just the unit's base cost)\r\n     */\r\n    calculateSquadValue(unitType) {\r\n        return unitType.value || 0;\r\n    }\r\n    \r\n    /**\r\n     * Calculate experience needed for next level\r\n     * @param {number} currentLevel - Current level\r\n     * @returns {number} Experience needed\r\n     */\r\n    calculateExperienceNeeded(currentLevel) {\r\n        // Exponential scaling: level 1 = 100, level 2 = 150, level 3 = 225, etc.\r\n        return Math.floor(this.config.experiencePerLevel * Math.pow(1.5, currentLevel));\r\n    }\r\n    \r\n    /**\r\n     * Find squad data by unit entity ID\r\n     * @param {number} entityId - Unit entity ID\r\n     * @returns {Object|null} Squad experience data\r\n     */\r\n    findSquadByUnitId(entityId) {\r\n        for (const [placementId, squadData] of this.squadExperience.entries()) {\r\n            if (squadData.unitIds.includes(entityId)) {\r\n                return squadData;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Get display name for a squad\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {string} Display name\r\n     */\r\n    getSquadDisplayName(placementId) {\r\n        // Try to get the name from placement system\r\n        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide);\r\n        if (playerPlacements) {\r\n            const placement = playerPlacements.find(p => p.placementId === placementId);\r\n            if (placement && placement.unitType) {\r\n                return placement.unitType.title || placement.unitType.id || 'Squad';\r\n            }\r\n        }\r\n\r\n        const enemyPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide === 'left' ? 'right' : 'left');\r\n        if (enemyPlacements) {\r\n            const enemyPlacement = enemyPlacements.find(p => p.placementId === placementId);\r\n            if (enemyPlacement && enemyPlacement.unitType) {\r\n                return enemyPlacement.unitType.title || enemyPlacement.unitType.id || 'Enemy Squad';\r\n            }\r\n        }\r\n\r\n        return `Squad ${placementId.slice(-4)}`;\r\n    }\r\n    \r\n    /**\r\n     * Get level bonus name\r\n     * @param {number} level - Squad level\r\n     * @returns {string} Bonus name\r\n     */\r\n    getLevelBonusName(level) {\r\n        return this.levelBonuses[level]?.name || '';\r\n    }\r\n    \r\n    /**\r\n     * Update squad experience UI\r\n     */\r\n    updateSquadUI() {\r\n        // This method could update a dedicated squad experience panel\r\n        // For now, we'll just ensure the shop system can access this data\r\n        this.game.gameManager.call('updateSquadExperience');\r\n    }\r\n    \r\n    /**\r\n     * Get all player squads that can level up\r\n     * @returns {Array} Array of squad data that can level up\r\n     */\r\n    getSquadsReadyToLevelUp() {\r\n        const readySquads = [];\r\n        \r\n        for (const [placementId, squadData] of this.squadExperience.entries()) {\r\n            if (squadData.canLevelUp && squadData.team == this.game.state.mySide) {\r\n                readySquads.push({\r\n                    ...squadData,\r\n                    displayName: this.getSquadDisplayName(placementId),\r\n                    levelUpCost: Math.floor(squadData.squadValue * this.config.levelUpCostRatio),\r\n                    nextLevelName: this.getLevelBonusName(squadData.level + 1)\r\n                });\r\n            }\r\n        }\r\n        \r\n        return readySquads;\r\n    }\r\n    \r\n    /**\r\n     * Get squad experience info for display\r\n     * @param {string} placementId - Squad placement ID\r\n     * @returns {Object} Experience info\r\n     */\r\n    getSquadInfo(placementId) {\r\n        return this.squadExperience.get(placementId);        \r\n    }\r\n\r\n    setSquadInfo(placementId, placementExperience){\r\n        if(placementExperience){\r\n            this.squadExperience.set(placementId, placementExperience);\r\n            console.log('applying opponent level bonuses', placementId);\r\n            this.applyLevelBonuses(placementId);\r\n        }\r\n    }\r\n\r\n    getExperienceFromPlacements(placements){\r\n        let experience = {};\r\n        placements.forEach((placement) => {\r\n            experience[placement.placementId] = this.getSquadInfo(placement.placementId)\r\n        });\r\n        return experience;\r\n    }\r\n    \r\n    /**\r\n     * Clean up squad data when units are destroyed\r\n     * MODIFIED: Only remove on explicit request, not automatic cleanup\r\n     * @param {string} placementId - Squad placement ID\r\n     */\r\n    removeSquad(placementId) {\r\n        const squadData = this.squadExperience.get(placementId);\r\n        if (squadData) {\r\n           this.squadExperience.delete(placementId);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Update method called each frame\r\n     */\r\n    update() {\r\n\r\n        this.tickBaselineXP();\r\n    }\r\n    tickBaselineXP() {\r\n        // Optional: restrict to combat only\r\n        if (this.config.baselineXPCombatOnly && this.game?.state?.phase !== 'battle') return;\r\n\r\n        for (const [placementId, squadData] of this.squadExperience.entries()) {\r\n            // Respect caps: no gain if at max or waiting for manual level-up\r\n            if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) continue;\r\n\r\n            const unitsAliveInSquad = this.unitsAliveInSquad(squadData);\r\n            if (unitsAliveInSquad > 0) {\r\n                const squadLivingRatio = unitsAliveInSquad / squadData.totalUnitsInSquad;                \r\n                const xp = squadLivingRatio * this.config.baselineXPPerSecond * this.game.state.deltaTime * this.config.experienceMultiplier;\r\n                if (xp > 0) this.addExperience(placementId, xp);\r\n            }\r\n        }\r\n    }\r\n    unitsAliveInSquad(squadData) {\r\n        if (!squadData || !squadData.unitIds?.length) return 0;\r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        let count = 0;\r\n        for (const id of squadData.unitIds) {\r\n            const h = this.game.getComponent(id, componentTypes.HEALTH);\r\n            if (h && h.current > 0) count++;\r\n        }\r\n        return count;\r\n    }\r\n    /**\r\n     * Clean up experience data for squads with dead/missing units\r\n     * MODIFIED: Never remove experience data, just update unit lists\r\n     */\r\n    onPlacementPhaseStart() {\r\n        \r\n        this.saveSquadExperience();\r\n        \r\n        const componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        for (const [placementId, squadData] of this.squadExperience.entries()) {\r\n            const validUnits = squadData.unitIds.filter(entityId => {\r\n                const health = this.game.getComponent(entityId, componentTypes.HEALTH);\r\n                return health && health.current > 0;\r\n            });\r\n            \r\n            if (validUnits.length < squadData.unitIds.length) {             \r\n                squadData.unitIds = validUnits;\r\n                squadData.squadSize = validUnits.length;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Reset all experience data (for new game)\r\n     */\r\n    reset() {\r\n        this.squadExperience.clear();\r\n        this.savedSquadExperience.clear();\r\n    }\r\n\r\n    /**\r\n     * Save player squad experience before round cleanup\r\n     */\r\n    saveSquadExperience() {\r\n        this.savedSquadExperience = new Map();\r\n        \r\n        for (const [placementId, squadData] of this.squadExperience.entries()) {\r\n\r\n            // Save the experience data\r\n            this.savedSquadExperience.set(placementId, {\r\n                level: squadData.level,\r\n                experience: squadData.experience,\r\n                experienceToNextLevel: squadData.experienceToNextLevel,\r\n                canLevelUp: squadData.canLevelUp,\r\n                squadValue: squadData.squadValue,\r\n                totalUnitsInSquad: squadData.totalUnitsInSquad\r\n            });\r\n            \r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restore saved player experience to a respawned squad\r\n     */\r\n    restoreSquadExperience(placementId, squadData) {\r\n        const saved = this.savedSquadExperience.get(placementId);\r\n        if (saved) {\r\n            squadData.level = saved.level;\r\n            squadData.experience = saved.experience;\r\n            squadData.experienceToNextLevel = saved.experienceToNextLevel;\r\n            squadData.canLevelUp = saved.canLevelUp;\r\n            \r\n          \r\n            // Apply level bonuses if squad has levels\r\n            if (squadData.level > 0) {\r\n                this.applyLevelBonuses(placementId);\r\n            }\r\n            \r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Get debug information\r\n     * @returns {Object} Debug info\r\n     */\r\n    getDebugInfo() {\r\n        const squads = Array.from(this.squadExperience.values());\r\n        return {\r\n            totalSquads: squads.length,\r\n            leftSquads: squads.filter(s => s.team === 'left').length,\r\n            rightSquads: squads.filter(s => s.team === 'right').length,\r\n            squadsReadyToLevelUp: squads.filter(s => s.canLevelUp).length,\r\n            averageLevel: squads.length > 0 ? squads.reduce((sum, s) => sum + s.level, 0) / squads.length : 0,\r\n            maxLevel: Math.max(0, ...squads.map(s => s.level))\r\n        };\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SquadExperienceSystem.js",
        "fileName": "SquadExperienceSystem"
      },
      "UnitOrderSystem": {
        "script": "class UnitOrderSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game = game;\r\n        this.game.unitOrderSystem = this;\r\n\r\n        this.CT = this.game.componentManager.getComponentTypes();\r\n\r\n        this.isTargeting = false;\r\n        this.isForceMove = false;\r\n        this.pendingCallbacks = 0;\r\n\r\n        this._onCanvasClick = this._onCanvasClick.bind(this);\r\n       // this._onCanvasMouseMove = this._onCanvasMouseMove.bind(this);\r\n\r\n        this.cursorWhenTargeting = 'crosshair';\r\n        this.pingEffect = { count: 12, color: 0x00ff00 };\r\n        this.temporaryOpponentMoveOrders = new Map();\r\n        this.targetingPreview = new GUTS.PlacementPreview(this.game);\r\n        this.targetingPreview.updateConfig({\r\n            cellOpacity: 0.3,\r\n            borderOpacity: 0.6\r\n        });\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('getTemporaryOpponentMoveOrders', () => this.temporaryOpponentMoveOrders);\r\n        this.game.gameManager.register('deleteTemporaryOpponentMoveOrder', (placementId) => {\r\n            this.temporaryOpponentMoveOrders.delete(placementId);\r\n        });\r\n    }\r\n\r\n    showSquadActionPanel(placementId) {\r\n        const actionPanel = document.getElementById('actionPanel');\r\n        if (!actionPanel) return;\r\n\r\n\r\n        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n        \r\n        actionPanel.innerHTML = \"\";\r\n          \r\n        \r\n        const firstUnit = placement.squadUnits[0];\r\n        const unitType = firstUnit ? this.game.getComponent(firstUnit, this.CT.UNIT_TYPE) : null;\r\n        \r\n        let squadPanel = document.createElement('div');\r\n        squadPanel.id = 'squadActionPanel';\r\n        \r\n        actionPanel.appendChild(squadPanel);\r\n        \r\n        this.displayActionSet(null, squadPanel, firstUnit, unitType);\r\n    }\r\n\r\n    displayActionSet(actionSetId, panel, selectedUnitId, unitType) {\r\n        panel.innerHTML = ``;\r\n        const actionSection = document.createElement('div');\r\n        actionSection.className = 'action-section';\r\n\r\n        const grid = document.createElement('div');\r\n        grid.className = 'action-grid';\r\n        \r\n        let actions = [];\r\n\r\n        if(!unitType.actionSet){\r\n            if(unitType.collection == 'units'){\r\n                unitType.actionSet = 'defaultUnitActions';\r\n            } \r\n        } \r\n\r\n        if(actionSetId || unitType.actionSet){\r\n            if(!actionSetId) {\r\n                actionSetId = unitType.actionSet;\r\n            }\r\n            let currentActionSet = this.game.getCollections().actionSets[actionSetId];\r\n            if(currentActionSet.actions){\r\n                actions = currentActionSet.actions;\r\n                const actionsCollection = this.game.getCollections().actions;\r\n                actions.forEach((actionId) => {\r\n                    let action = actionsCollection[actionId];\r\n                    const btn = this.createActionButton(action, panel, selectedUnitId, unitType);\r\n                    grid.appendChild(btn);\r\n                });\r\n            } else if(currentActionSet.buildings){\r\n                const buildings = this.game.getCollections().buildings;\r\n                currentActionSet.buildings.forEach(buildingId => {\r\n                    if (buildingId === 'underConstruction') return;\r\n                    \r\n                    const building = buildings[buildingId];            \r\n                    if (!building.buildTime) building.buildTime = 1;\r\n                    \r\n                    building.id = buildingId;\r\n                    building.collection = \"buildings\";\r\n                    const canAfford = this.game.state.playerGold >= (building.value || 0);\r\n                    const isLocked = this.game.shopSystem?.isBuildingLocked(buildingId, building);\r\n                    const lockReason = this.game.shopSystem?.getLockReason(buildingId, building);\r\n                    \r\n                    const btn = this.createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId);\r\n                    grid.appendChild(btn);\r\n                });\r\n            }\r\n        }\r\n        actionSection.appendChild(grid);\r\n    \r\n        panel.appendChild(actionSection);\r\n    }\r\n\r\n    createActionButton(action, panel, selectedUnitId, unitType) {\r\n        const btn = document.createElement('button');\r\n        btn.className = 'action-btn';\r\n        btn.title = `${action.title}`;\r\n\r\n        const iconEl = document.createElement('div');\r\n        iconEl.className = 'action-btn-icon';\r\n        if(action.icon){\r\n            const icon = this.game.getCollections().icons[action.icon];\r\n            if(icon && icon.filePath){\r\n                const img = document.createElement('img');\r\n                img.src = `./${icon.filePath}`;\r\n                iconEl.append(img);\r\n            } else {\r\n                iconEl.textContent =  '';\r\n            }\r\n        } else {\r\n            iconEl.textContent =  '';\r\n        }\r\n        btn.append(iconEl);\r\n\r\n        if(action.order){\r\n            btn.addEventListener('click', () => {\r\n                this[action.order]();\r\n            });\r\n        } else if(action.actionSet){\r\n            btn.addEventListener('click', () => {\r\n                this.displayActionSet(action.actionSet, panel, selectedUnitId, unitType);\r\n            });\r\n        }\r\n        return btn;\r\n    }\r\n\r\n    createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId) {\r\n        const btn = document.createElement('button');\r\n        btn.className = 'action-btn';\r\n        btn.title = `${building.title} ${building.value}`;\r\n        const locked = isLocked || !canAfford;\r\n        if (locked) {\r\n            btn.style.opacity = '0.5';\r\n            btn.style.cursor = 'not-allowed';\r\n            btn.title = `${building.title} ${lockReason}`;\r\n        }\r\n        \r\n        const iconEl = document.createElement('div');\r\n        iconEl.className = 'action-btn-icon';\r\n        if(building.icon){\r\n            const icon = this.game.getCollections().icons[building.icon];\r\n            if(icon && icon.filePath){\r\n                const img = document.createElement('img');\r\n                img.src = `./${icon.filePath}`;\r\n                iconEl.append(img);\r\n            } else {\r\n                iconEl.textContent =  '';\r\n            }\r\n        } else {\r\n            iconEl.textContent =  '';\r\n        }\r\n        btn.append(iconEl);\r\n\r\n        if (!locked) {\r\n            btn.addEventListener('click', () => {\r\n                this.activateBuildingPlacement(building, selectedUnitId);\r\n            });\r\n            \r\n            btn.addEventListener('mouseenter', () => {\r\n                btn.style.border = '2px solid var(--primary-gold)';\r\n                btn.style.transform = 'translateY(-2px)';\r\n            });\r\n            \r\n            btn.addEventListener('mouseleave', () => {\r\n                btn.style.border = '2px solid rgba(255, 170, 0, 0.3)';\r\n                btn.style.transform = 'translateY(0)';\r\n            });\r\n        }\r\n\r\n        return btn;\r\n    }\r\n\r\n    activateBuildingPlacement(building, selectedUnitId) {\r\n        this.game.state.selectedUnitType = {...building};\r\n        \r\n        this.game.state.peasantBuildingPlacement = {\r\n            peasantId: selectedUnitId,\r\n            buildTime: building.buildTime\r\n        };\r\n        \r\n        this.stopTargeting();\r\n        \r\n        this.game.triggerEvent('onActivateBuildingPlacement', this.game.state.selectedUnitType);\r\n    }\r\n    moveOrderAction() {\r\n        this.startTargeting({preventEnemiesInRangeCheck: true});\r\n    }\r\n\r\n    startTargeting(meta = {}) {\r\n        this.stopTargeting();\r\n        if(this.game.state.phase != 'placement') return;\r\n        this.isTargeting = true;\r\n        this.orderMeta = meta;\r\n        this.pendingCallbacks = 0;\r\n\r\n        const canvas = this.game.canvas;\r\n        if (canvas) {\r\n            canvas.addEventListener('contextmenu', this._onCanvasClick, { once: true });\r\n           // canvas.addEventListener('mousemove', this._onCanvasMouseMove);\r\n        }\r\n\r\n    }\r\n\r\n    stopTargeting() {\r\n        if (!this.isTargeting) return;\r\n        this.isTargeting = false;\r\n\r\n        const canvas = this.game.canvas;\r\n        if (canvas) {\r\n            canvas.removeEventListener('contextmenu', this._onCanvasClick, { once: true });\r\n       //     canvas.removeEventListener('mousemove', this._onCanvasMouseMove);\r\n        }\r\n        \r\n        this.targetingPreview.clear();\r\n    }\r\n\r\n    holdPosition() {\r\n        this.stopTargeting();\r\n\r\n        let placementIds = this.game.gameManager.call('getSelectedSquads') || [];\r\n        \r\n        if (!placementIds || placementIds.length === 0) {\r\n            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);\r\n            return;\r\n        }\r\n        placementIds.forEach((placementId) => {\r\n            const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n            placement.squadUnits.forEach((unitId) => {\r\n                const position = this.game.getComponent(unitId, this.CT.POSITION);\r\n                const aiState = this.game.getComponent(unitId, this.CT.AI_STATE);\r\n                if (this.game.effectsSystem && position) {\r\n                    this.game.gameManager.call('createParticleEffect', position.x, 0, position.z, 'magic', { ...this.pingEffect });\r\n                }\r\n                let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, \"UnitOrderSystem\");\r\n                currentOrderAI.targetPosition = position;\r\n                currentOrderAI.path = [];\r\n                currentOrderAI.meta = {\r\n                    allowMovement: false\r\n                };\r\n                this.game.gameManager.call('setCurrentAIController', unitId, \"UnitOrderSystem\", currentOrderAI);   \r\n            });\r\n        });\r\n        \r\n    }\r\n\r\n    onKeyDown(key) {\r\n        if (key === 'Escape' && this.isTargeting) {\r\n            this.game.uiSystem?.showNotification(' Targeting canceled', 'warning', 800);\r\n            this.stopTargeting();\r\n        }\r\n    }\r\n    onUnitSelected(entityId){\r\n        const unitType = this.game.getComponent(entityId, this.CT.UNIT_TYPE);\r\n        if(unitType.collection == \"units\") {\r\n            const placement = this.game.getComponent(entityId, this.CT.PLACEMENT);        \r\n            const placementId = placement.placementId;\r\n            this.showSquadActionPanel(placementId);   \r\n            this.startTargeting();     \r\n        } else {\r\n            this.stopTargeting();\r\n        }\r\n        this.showMoveTargets();\r\n    }\r\n    showMoveTargets() {\r\n        this.targetingPreview.clear();\r\n        const placementIds = this.game.gameManager.call('getSelectedSquads') || [];\r\n        const targetPositions = [];\r\n        placementIds.forEach((placementId) => {\r\n            const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n            placement.squadUnits.forEach((entityId) => {                \r\n                const aiState = this.game.getComponent(entityId, this.CT.AI_STATE);   \r\n                if(aiState.targetPosition && aiState.aiControllerId == \"UnitOrderSystem\"){\r\n                    targetPositions.push(aiState.targetPosition);\r\n                }\r\n            });            \r\n        });\r\n\r\n        this.targetingPreview.showAtWorldPositions(targetPositions, true);\r\n    }\r\n    // _onCanvasMouseMove(event) {\r\n    //     if (!this.isTargeting) return;\r\n\r\n    //     const canvas = this.game.canvas;\r\n    //     if (!canvas) {\r\n    //         this.stopTargeting();\r\n    //         this.targetingPreview.clear();\r\n    //         return;\r\n    //     }\r\n\r\n    //     const rect = canvas.getBoundingClientRect();\r\n    //     const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n    //     const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n    //     const worldPos = this.game.placementSystem?.getWorldPositionFromMouse?.(event, mouseX, mouseY);\r\n    //     if (!worldPos) {\r\n    //         this.game.uiSystem?.showNotification('Could not find ground under cursor.', 'error', 1000);\r\n    //         this.targetingPreview.clear();\r\n    //         this.stopTargeting();\r\n    //         return;\r\n    //     }\r\n    //     const placementIds = this.game.selectedUnitSystem.getSelectedSquads() || [];\r\n    //     let isBuilding = false;\r\n    //     placementIds.forEach((placementId) => {\r\n    //         const placement = this.game.placementSystem.getPlacementById(placementId);\r\n    //         if(placement.unitType.collection == \"buildings\"){\r\n    //             isBuilding = true;\r\n    //         }\r\n    //         targetPositions.push(placement.targetPosition);\r\n    //     });\r\n    //     if(isBuilding){\r\n    //         const targetPosition = { x: worldPos.x, z: worldPos.z };\r\n    //         const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);\r\n    //         this.targetingPreview.showAtWorldPositions(targetPositions, true);\r\n    //     }\r\n    // }\r\n\r\n    _onCanvasClick(event) {\r\n        if (!this.isTargeting) return;\r\n\r\n        const canvas = this.game.canvas;\r\n        if (!canvas) {\r\n            this.stopTargeting();\r\n            return;\r\n        }\r\n\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n\r\n        const worldPos = this.game.placementSystem?.getWorldPositionFromMouse?.(event, mouseX, mouseY);\r\n        if (!worldPos) {\r\n            this.game.uiSystem?.showNotification('Could not find ground under cursor.', 'error', 1000);\r\n            this.stopTargeting();\r\n            return;\r\n        }\r\n\r\n        let placementIds = this.game.gameManager.call('getSelectedSquads') || [];\r\n        \r\n        if (!placementIds || placementIds.length === 0) {\r\n            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);\r\n            this.stopTargeting();\r\n            return;\r\n        }\r\n\r\n        const targetPosition = { x: worldPos.x, y: 0, z: worldPos.z };\r\n\r\n        if (this.game.effectsSystem) {\r\n            this.game.gameManager.call('createParticleEffect', worldPos.x, 0, worldPos.z, 'magic', { ...this.pingEffect });\r\n        }\r\n\r\n        this.issueMoveOrders(placementIds, targetPosition);\r\n    }\r\n\r\n    issueMoveOrders(placementIds, targetPosition) {\r\n        if(this.game.state.phase != \"placement\") {\r\n            return;\r\n        };\r\n        const meta = { ...this.orderMeta };        \r\n        this.orderMeta = {};\r\n        const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);\r\n        this.game.networkManager.setSquadTargets(\r\n            { placementIds, targetPositions, meta },\r\n            (success) => {\r\n                if (success) {\r\n                    for(let i = 0; i < placementIds.length; i++){\r\n                        let placementId = placementIds[i];\r\n                        const targetPosition = targetPositions[i];\r\n                        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n                        placement.squadUnits.forEach((unitId) => {\r\n                            if (this.game.effectsSystem && targetPosition) {\r\n                                this.game.gameManager.call('createParticleEffect', targetPosition.x, 0, targetPosition.z, 'magic', { ...this.pingEffect });\r\n                            }\r\n                            if(targetPosition){\r\n                                let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, \"UnitOrderSystem\");\r\n                                currentOrderAI.targetPosition = targetPosition;\r\n                                currentOrderAI.path = [];\r\n                                if(unitId == \"peasant_1224_1368_right_1\"){\r\n                                    console.log(\"issueMoveOrders\");\r\n                                }\r\n                                currentOrderAI.meta = meta;\r\n                                this.game.gameManager.call('setCurrentAIController', unitId, \"UnitOrderSystem\", currentOrderAI);   \r\n                            }\r\n                        });\r\n                                \r\n                    }       \r\n                    this.startTargeting();   \r\n                    this.showMoveTargets();           \r\n                }                \r\n            }\r\n        );\r\n    }\r\n\r\n    getFormationTargetPositions(targetPosition, placementIds){\r\n        let targetPositions = [];\r\n        // Use placement grid size (half of terrain grid) for unit formation spacing\r\n        const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;\r\n        const unitPadding = 1;\r\n\r\n        for(let i = 0; i < placementIds.length; i++){\r\n            targetPositions.push({\r\n                x: targetPosition.x,\r\n                z: i % 2 == 0 ? targetPosition.z + i * placementGridSize * unitPadding : targetPosition.z - i * placementGridSize * unitPadding\r\n            });\r\n        }\r\n        return targetPositions;\r\n    }\r\n\r\n    applySquadTargetPosition(placementId, targetPosition, meta) {\r\n        const placement = this.game.gameManager.call('getPlacementById', placementId);\r\n        if(!placement){\r\n            this.temporaryOpponentMoveOrders.set(placementId, { targetPosition: targetPosition, meta: meta });\r\n            return;\r\n        }\r\n        placement.targetPosition = targetPosition;\r\n        placement.squadUnits.forEach((unitId) => {\r\n            if(targetPosition){\r\n                let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, \"UnitOrderSystem\");\r\n                currentOrderAI.targetPosition = targetPosition;\r\n                currentOrderAI.path = [];\r\n                if(unitId == \"peasant_1224_1368_right_1\"){\r\n                    console.log(\"applySquadTargetPosition\");\r\n                }\r\n                currentOrderAI.meta = meta;\r\n                this.game.gameManager.call('setCurrentAIController', unitId, \"UnitOrderSystem\", currentOrderAI);   \r\n            }            \r\n        });            \r\n    }\r\n\r\n    applySquadsTargetPositions(placementIds, targetPositions, meta) {     \r\n        for(let i = 0; i < placementIds.length; i++){  \r\n            let placementId = placementIds[i];\r\n            let targetPosition = targetPositions[i];\r\n            this.applySquadTargetPosition(placementId, targetPosition, meta);\r\n        }\r\n    }\r\n    onBattleStart() {\r\n        this.stopTargeting();\r\n    }\r\n    onDeSelectAll() {        \r\n        this.targetingPreview.clear();\r\n    }\r\n\r\n    destroy() {\r\n        this.stopTargeting();\r\n        if (this.targetingPreview) {\r\n            this.targetingPreview.dispose();\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitOrderSystem.js",
        "fileName": "UnitOrderSystem"
      },
      "ArmyDisplaySystem": {
        "script": "class ArmyDisplaySystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);  \r\n        this.game.armyDisplaySystem = this;\r\n        this.updateInterval = null;\r\n        this.lastUpdateData = null;\r\n    }\r\n    \r\n    initialize() {\r\n        this.addArmyDisplayCSS();\r\n        this.setupUpdateLoop();\r\n    }\r\n    \r\n    setupUpdateLoop() {\r\n        // Update army display every 500ms to avoid performance issues\r\n        this.updateInterval = setInterval(() => {\r\n            this.update();\r\n        }, 500);\r\n    }\r\n    \r\n    update() {\r\n        const playerArmy = document.getElementById('playerArmy');\r\n        const enemyArmy = document.getElementById('enemyArmy');\r\n        \r\n        if (!playerArmy || !enemyArmy) return;\r\n        \r\n        const armyData = this.getArmyData();\r\n        \r\n        // Only update if data has changed to avoid unnecessary DOM manipulation\r\n        if (this.hasDataChanged(armyData)) {\r\n            this.displayArmy(playerArmy, armyData.playerUnits, 'player');\r\n            this.displayArmy(enemyArmy, armyData.enemyUnits, 'enemy');\r\n            this.lastUpdateData = armyData;\r\n        }\r\n        \r\n        this.updateArmyStats(armyData);\r\n    }\r\n    \r\n    hasDataChanged(newData) {\r\n        if (!this.lastUpdateData) return true;\r\n        \r\n        return (\r\n            JSON.stringify(newData.playerUnits) !== JSON.stringify(this.lastUpdateData.playerUnits) ||\r\n            JSON.stringify(newData.enemyUnits) !== JSON.stringify(this.lastUpdateData.enemyUnits)\r\n        );\r\n    }\r\n    \r\n    getArmyData() {\r\n        try {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const allUnits = this.game.getEntitiesWith(\r\n                ComponentTypes.TEAM, \r\n                ComponentTypes.UNIT_TYPE, \r\n                ComponentTypes.HEALTH\r\n            ) || [];\r\n            \r\n            const playerUnits = [];\r\n            const enemyUnits = [];\r\n            \r\n            allUnits.forEach(entityId => {\r\n                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n                const unitType = this.game.getComponent(entityId, ComponentTypes.UNIT_TYPE);\r\n                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);\r\n                const combat = this.game.getComponent(entityId, ComponentTypes.COMBAT);\r\n                \r\n                const unitInfo = {\r\n                    id: entityId,\r\n                    type: unitType?.type || 'Unknown',\r\n                    name: unitType?.name || unitType?.type || 'Unit',\r\n                    health: health?.current || 0,\r\n                    maxHealth: health?.max || 1,\r\n                    position: position ? { x: position.x, z: position.z } : null,\r\n                    damage: combat?.damage || 0,\r\n                    status: this.getUnitStatus(entityId)\r\n                };\r\n                \r\n                if (team?.team === 'player') {\r\n                    playerUnits.push(unitInfo);\r\n                } else if (team?.team === 'enemy') {\r\n                    enemyUnits.push(unitInfo);\r\n                }\r\n            });\r\n            \r\n            // Sort by health percentage (wounded units first, then by position)\r\n            const sortUnits = (units) => {\r\n                return units.sort((a, b) => {\r\n                    const healthPercentA = a.health / a.maxHealth;\r\n                    const healthPercentB = b.health / b.maxHealth;\r\n                    \r\n                    // Wounded units first\r\n                    if (healthPercentA < 1 && healthPercentB >= 1) return -1;\r\n                    if (healthPercentB < 1 && healthPercentA >= 1) return 1;\r\n                    \r\n                    // Then sort by position (front to back)\r\n                    if (a.position && b.position) {\r\n                        return a.position.x - b.position.x;\r\n                    }\r\n                    \r\n                    return 0;\r\n                });\r\n            };\r\n            \r\n            return {\r\n                playerUnits: sortUnits(playerUnits),\r\n                enemyUnits: sortUnits(enemyUnits)\r\n            };\r\n        } catch (error) {\r\n            console.warn('Error getting army data:', error);\r\n            return { playerUnits: [], enemyUnits: [] };\r\n        }\r\n    }\r\n    \r\n    getUnitStatus(entityId) {\r\n        try {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);\r\n            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n            \r\n            if (health?.current <= 0) return 'dead';\r\n            if (aiState?.state === 'attacking') return 'attacking';\r\n            if (aiState?.state === 'moving') return 'moving';\r\n            if (aiState?.state === 'idle') return 'idle';\r\n            \r\n            return 'unknown';\r\n        } catch (error) {\r\n            return 'unknown';\r\n        }\r\n    }\r\n    \r\n    displayArmy(container, units, armyType) {\r\n        // Clear container\r\n        container.innerHTML = '';\r\n        \r\n        if (units.length === 0) {\r\n            this.displayEmptyArmy(container, armyType);\r\n            return;\r\n        }\r\n        \r\n        // Create army header\r\n        this.createArmyHeader(container, units, armyType);\r\n        \r\n        // Display units\r\n        units.forEach((unit, index) => {\r\n            const unitElement = this.createUnitElement(unit, index, armyType);\r\n            container.appendChild(unitElement);\r\n        });\r\n    }\r\n    \r\n    displayEmptyArmy(container, armyType) {\r\n        const emptyDiv = document.createElement('div');\r\n        emptyDiv.className = 'army-empty';\r\n        emptyDiv.innerHTML = `\r\n            <div class=\"empty-icon\">${armyType === 'player' ? '' : ''}</div>\r\n            <div class=\"empty-text\">\r\n                ${armyType === 'player' ? 'No units deployed' : 'Enemy preparing...'}\r\n            </div>\r\n        `;\r\n        container.appendChild(emptyDiv);\r\n    }\r\n    \r\n    createArmyHeader(container, units, armyType) {\r\n        const header = document.createElement('div');\r\n        header.className = `army-header army-header-${armyType}`;\r\n        \r\n        const totalHealth = units.reduce((sum, unit) => sum + unit.health, 0);\r\n        const maxHealth = units.reduce((sum, unit) => sum + unit.maxHealth, 0);\r\n        const healthPercent = maxHealth > 0 ? Math.round((totalHealth / maxHealth) * 100) : 0;\r\n        \r\n        const aliveCount = units.filter(unit => unit.health > 0).length;\r\n        \r\n        header.innerHTML = `\r\n            <div class=\"army-summary\">\r\n                <span class=\"unit-count\">${aliveCount}/${units.length} Units</span>\r\n                <span class=\"health-percent ${this.getHealthPercentClass(healthPercent)}\">${healthPercent}% HP</span>\r\n            </div>\r\n            <div class=\"army-health-bar\">\r\n                <div class=\"health-bar-fill\" style=\"width: ${healthPercent}%\"></div>\r\n            </div>\r\n        `;\r\n        \r\n        container.appendChild(header);\r\n    }\r\n    \r\n    createUnitElement(unit, index, armyType) {\r\n        const unitDiv = document.createElement('div');\r\n        unitDiv.className = `army-unit army-unit-${armyType}`;\r\n        unitDiv.dataset.unitId = unit.id;\r\n        \r\n        const healthPercent = unit.health / unit.maxHealth;\r\n        const healthClass = this.getHealthClass(healthPercent);\r\n        const statusIcon = this.getStatusIcon(unit.status);\r\n        \r\n        unitDiv.innerHTML = `\r\n            <div class=\"unit-info\">\r\n                <div class=\"unit-name-row\">\r\n                    <span class=\"unit-name\">${unit.name}</span>\r\n                    <span class=\"unit-status\">${statusIcon}</span>\r\n                </div>\r\n                <div class=\"unit-health-row\">\r\n                    <span class=\"unit-health ${healthClass}\">${unit.health}/${unit.maxHealth}</span>\r\n                    <span class=\"unit-damage\">${unit.damage}</span>\r\n                </div>\r\n                <div class=\"unit-health-bar\">\r\n                    <div class=\"health-bar-fill ${healthClass}\" \r\n                         style=\"width: ${Math.max(0, healthPercent * 100)}%\"></div>\r\n                </div>\r\n            </div>\r\n        `;\r\n        \r\n        // Add click handler for unit selection/info\r\n        unitDiv.addEventListener('click', () => {\r\n            this.showUnitDetails(unit, armyType);\r\n        });\r\n        \r\n        // Add hover effects\r\n        unitDiv.addEventListener('mouseenter', () => {\r\n            this.highlightUnit(unit.id);\r\n        });\r\n        \r\n        unitDiv.addEventListener('mouseleave', () => {\r\n            this.unhighlightUnit(unit.id);\r\n        });\r\n        \r\n        return unitDiv;\r\n    }\r\n    \r\n    getHealthClass(healthPercent) {\r\n        if (healthPercent <= 0) return 'health-dead';\r\n        if (healthPercent <= 0.25) return 'health-critical';\r\n        if (healthPercent <= 0.5) return 'health-wounded';\r\n        if (healthPercent <= 0.75) return 'health-damaged';\r\n        return 'health-full';\r\n    }\r\n    \r\n    getHealthPercentClass(percent) {\r\n        if (percent <= 25) return 'health-critical';\r\n        if (percent <= 50) return 'health-wounded';\r\n        if (percent <= 75) return 'health-damaged';\r\n        return 'health-full';\r\n    }\r\n    \r\n    getStatusIcon(status) {\r\n        const icons = {\r\n            attacking: '',\r\n            moving: '',\r\n            idle: '',\r\n            dead: '',\r\n            unknown: ''\r\n        };\r\n        return icons[status] || icons.unknown;\r\n    }\r\n    \r\n    showUnitDetails(unit, armyType) {\r\n        const details = `\r\n            <h3>${unit.name} Details</h3>\r\n            <div class=\"unit-details\">\r\n                <div class=\"detail-row\">\r\n                    <span>Health:</span>\r\n                    <span class=\"${this.getHealthClass(unit.health / unit.maxHealth)}\">\r\n                        ${unit.health}/${unit.maxHealth}\r\n                    </span>\r\n                </div>\r\n                <div class=\"detail-row\">\r\n                    <span>Damage:</span>\r\n                    <span>${unit.damage}</span>\r\n                </div>\r\n                <div class=\"detail-row\">\r\n                    <span>Status:</span>\r\n                    <span>${this.getStatusIcon(unit.status)} ${unit.status}</span>\r\n                </div>\r\n                ${unit.position ? `\r\n                <div class=\"detail-row\">\r\n                    <span>Position:</span>\r\n                    <span>(${unit.position.x.toFixed(1)}, ${unit.position.z.toFixed(1)})</span>\r\n                </div>\r\n                ` : ''}\r\n            </div>\r\n        `;\r\n\r\n        // Use the input handler to show modal\r\n        this.game.gameManager.call('showModal', `${armyType === 'player' ? '' : ''} Unit Info`, details);\r\n    }\r\n    \r\n    highlightUnit(unitId) {\r\n        // Visual highlight on the battlefield (could integrate with effects system)\r\n        if (this.game.effectsSystem) {\r\n            // Get unit position and show highlight effect\r\n            try {\r\n                const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n                const position = this.game.getComponent(unitId, ComponentTypes.POSITION);\r\n                if (position) {\r\n                    // Convert world position to screen position and show highlight\r\n                    // This is a placeholder - actual implementation would depend on rendering system\r\n                    console.log(`Highlighting unit ${unitId} at position (${position.x}, ${position.z})`);\r\n                }\r\n            } catch (error) {\r\n                console.warn('Could not highlight unit:', error);\r\n            }\r\n        }\r\n    }\r\n    \r\n    unhighlightUnit(unitId) {\r\n        // Remove highlight\r\n        console.log(`Unhighlighting unit ${unitId}`);\r\n    }\r\n    \r\n    updateArmyStats(armyData) {\r\n        this.updateArmyStrength(armyData);\r\n        this.updateArmyComposition(armyData);\r\n    }\r\n    \r\n    updateArmyStrength(armyData) {\r\n        // Update army strength indicators\r\n        const playerStrength = this.calculateArmyStrength(armyData.playerUnits);\r\n        const enemyStrength = this.calculateArmyStrength(armyData.enemyUnits);\r\n        \r\n        // Update strength displays if they exist\r\n        const playerStrengthEl = document.getElementById('playerArmyStrength');\r\n        const enemyStrengthEl = document.getElementById('enemyArmyStrength');\r\n        \r\n        if (playerStrengthEl) {\r\n            playerStrengthEl.textContent = playerStrength;\r\n            playerStrengthEl.className = this.getStrengthClass(playerStrength);\r\n        }\r\n        \r\n        if (enemyStrengthEl) {\r\n            enemyStrengthEl.textContent = enemyStrength;\r\n            enemyStrengthEl.className = this.getStrengthClass(enemyStrength);\r\n        }\r\n    }\r\n    \r\n    calculateArmyStrength(units) {\r\n        return units.reduce((total, unit) => {\r\n            const healthFactor = unit.health / unit.maxHealth;\r\n            return total + (unit.damage * healthFactor);\r\n        }, 0);\r\n    }\r\n    \r\n    getStrengthClass(strength) {\r\n        if (strength >= 100) return 'strength-very-high';\r\n        if (strength >= 75) return 'strength-high';\r\n        if (strength >= 50) return 'strength-medium';\r\n        if (strength >= 25) return 'strength-low';\r\n        return 'strength-very-low';\r\n    }\r\n    \r\n    updateArmyComposition(armyData) {\r\n        // Update army composition displays\r\n        const playerComposition = this.analyzeComposition(armyData.playerUnits);\r\n        const enemyComposition = this.analyzeComposition(armyData.enemyUnits);\r\n        \r\n        // Could update composition indicators here\r\n        console.log('Player composition:', playerComposition);\r\n        console.log('Enemy composition:', enemyComposition);\r\n    }\r\n    \r\n    analyzeComposition(units) {\r\n        const composition = {};\r\n        units.forEach(unit => {\r\n            composition[unit.type] = (composition[unit.type] || 0) + 1;\r\n        });\r\n        return composition;\r\n    }\r\n    \r\n    addArmyDisplayCSS() {\r\n        if (document.querySelector('#army-display-styles')) return;\r\n        \r\n        const style = document.createElement('style');\r\n        style.id = 'army-display-styles';\r\n        style.textContent = `\r\n            .army-empty {\r\n                text-align: center; padding: 2rem; color: #666;\r\n            }\r\n            \r\n            .empty-icon {\r\n                font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.5;\r\n            }\r\n            \r\n            .empty-text {\r\n                font-size: 0.9rem; opacity: 0.7;\r\n            }\r\n            \r\n            .army-header {\r\n                background: rgba(255, 255, 255, 0.05);\r\n                padding: 0.8rem; margin-bottom: 0.5rem;\r\n                border-radius: 5px; border-left: 3px solid;\r\n            }\r\n            \r\n            .army-header-player { border-left-color: #00ff00; }\r\n            .army-header-enemy { border-left-color: #ff4444; }\r\n            \r\n            .army-summary {\r\n                display: flex; justify-content: space-between;\r\n                align-items: center; margin-bottom: 0.5rem;\r\n            }\r\n            \r\n            .unit-count {\r\n                font-weight: bold; color: #ccc;\r\n            }\r\n            \r\n            .health-percent {\r\n                font-weight: bold; font-size: 0.9rem;\r\n            }\r\n            \r\n            .army-health-bar {\r\n                height: 4px; background: #333; border-radius: 2px; overflow: hidden;\r\n            }\r\n            \r\n            .health-bar-fill {\r\n                height: 100%; transition: width 0.3s ease;\r\n            }\r\n            \r\n            .army-unit {\r\n                background: rgba(255, 255, 255, 0.03);\r\n                border: 1px solid transparent;\r\n                border-radius: 4px; padding: 0.6rem;\r\n                margin: 0.3rem 0; cursor: pointer;\r\n                transition: all 0.2s ease;\r\n            }\r\n            \r\n            .army-unit:hover {\r\n                background: rgba(255, 255, 255, 0.08);\r\n                border-color: rgba(255, 255, 255, 0.2);\r\n                transform: translateX(2px);\r\n            }\r\n            \r\n            .army-unit-player:hover { border-left-color: #00ff00; }\r\n            .army-unit-enemy:hover { border-left-color: #ff4444; }\r\n            \r\n            .unit-info {\r\n                font-size: 0.85rem;\r\n            }\r\n            \r\n            .unit-name-row, .unit-health-row {\r\n                display: flex; justify-content: space-between;\r\n                align-items: center; margin-bottom: 0.3rem;\r\n            }\r\n            \r\n            .unit-name {\r\n                font-weight: bold; color: #ccc;\r\n            }\r\n            \r\n            .unit-status {\r\n                opacity: 0.8;\r\n            }\r\n            \r\n            .unit-health {\r\n                font-weight: bold;\r\n            }\r\n            \r\n            .unit-damage {\r\n                font-size: 0.8rem; opacity: 0.8;\r\n            }\r\n            \r\n            .unit-health-bar {\r\n                height: 3px; background: #333;\r\n                border-radius: 2px; overflow: hidden;\r\n            }\r\n            \r\n            /* Health color classes */\r\n            .health-full, .health-full .health-bar-fill { color: #00ff00; background-color: #00ff00; }\r\n            .health-damaged, .health-damaged .health-bar-fill { color: #88ff88; background-color: #88ff88; }\r\n            .health-wounded, .health-wounded .health-bar-fill { color: #ffff00; background-color: #ffff00; }\r\n            .health-critical, .health-critical .health-bar-fill { color: #ff8800; background-color: #ff8800; }\r\n            .health-dead, .health-dead .health-bar-fill { color: #ff0000; background-color: #ff0000; opacity: 0.5; }\r\n            \r\n            /* Strength classes */\r\n            .strength-very-high { color: #00ff88; }\r\n            .strength-high { color: #88ff88; }\r\n            .strength-medium { color: #ffff88; }\r\n            .strength-low { color: #ff8888; }\r\n            .strength-very-low { color: #ff4444; }\r\n            \r\n            /* Unit details modal content */\r\n            .unit-details {\r\n                font-family: monospace;\r\n            }\r\n            \r\n            .detail-row {\r\n                display: flex; justify-content: space-between;\r\n                padding: 0.5rem 0; border-bottom: 1px solid #333;\r\n            }\r\n            \r\n            .detail-row:last-child {\r\n                border-bottom: none;\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n    \r\n    cleanup() {\r\n        if (this.updateInterval) {\r\n            clearInterval(this.updateInterval);\r\n        }\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ArmyDisplaySystem.js",
        "fileName": "ArmyDisplaySystem"
      },
      "EffectsSystem": {
        "script": "class EffectsSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game); \r\n        this.game.effectsSystem = this;\r\n        \r\n        // Screen effect tracking\r\n        this.screenEffects = [];\r\n        this.shakeActive = false;\r\n        this.flashActive = false;\r\n        \r\n        // UI notifications\r\n        this.notifications = [];\r\n        \r\n        // Single array for all active effects with unified update loop\r\n        this.activeEffects = [];\r\n        \r\n        // Object pools for reuse\r\n        this.geometryPool = new Map(); // type -> geometry[]\r\n        this.materialPool = new Map(); // key -> material[]\r\n        this.effectPool = []; // Reusable effect objects        \r\n        this.activeAuras = new Map();\r\n        \r\n        // Batching system\r\n        this.batchedEffects = new Map(); // type -> effects[]\r\n        \r\n        this.effectOffset = { x: 0, y: 75, z: 0 };\r\n        this.shakeData = null;\r\n        this.flashData = null;\r\n        // Performance tracking\r\n        this.stats = {\r\n            activeEffects: 0,\r\n            pooledObjects: 0\r\n        };\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('createParticleEffect', this.createParticleEffect.bind(this));\r\n        this.game.gameManager.register('clearAllEffects', this.clearAllEffects.bind(this));\r\n        this.game.gameManager.register('showNotification', this.showNotification.bind(this));\r\n        this.game.gameManager.register('createLineEffect', this.createLineEffect.bind(this));\r\n        this.game.gameManager.register('createLightningBolt', this.createLightningBolt.bind(this));\r\n        this.game.gameManager.register('createEnergyBeam', this.createEnergyBeam.bind(this));\r\n        this.game.gameManager.register('playScreenShake', this.playScreenShake.bind(this));\r\n        this.game.gameManager.register('playScreenFlash', this.playScreenFlash.bind(this));\r\n        this.game.gameManager.register('initializeEffectsSystem', this.initialize.bind(this));\r\n    }\r\n\r\n    initialize() {\r\n        this.addEffectsCSS();\r\n        console.log('EffectsSystem initialized');\r\n    }\r\n    \r\n    // Batch process all effects using game time\r\n    updateAllEffects() {\r\n        if (!this.game.state) return;\r\n        \r\n        const currentTime = this.game.state.now;\r\n        if (!currentTime) return;\r\n        \r\n        const toRemove = [];\r\n        \r\n        for (let i = this.activeEffects.length - 1; i >= 0; i--) {\r\n            const effect = this.activeEffects[i];\r\n            const elapsed = currentTime - effect.startTime;\r\n            const progress = elapsed / effect.duration;\r\n            \r\n            if (progress >= 1) {\r\n                toRemove.push(i);\r\n                continue;\r\n            }\r\n            \r\n            this.updateEffect(effect, elapsed, progress);\r\n        }\r\n        \r\n        // Remove completed effects and return to pool\r\n        toRemove.forEach(index => {\r\n            const effect = this.activeEffects[index];\r\n            this.recycleEffect(effect);\r\n            this.activeEffects.splice(index, 1);\r\n        });\r\n        \r\n        this.stats.activeEffects = this.activeEffects.length;\r\n    }\r\n    \r\n    updateEffect(effect, elapsed, progress) {\r\n        const { material, animation } = effect;\r\n        \r\n        // Batch similar updates together\r\n        switch (effect?.animationType) {\r\n            case 'flicker':\r\n                this.updateFlickerEffect(effect, elapsed, animation);\r\n                break;\r\n            case 'pulse':\r\n                this.updatePulseEffect(effect, elapsed, animation);\r\n                break;\r\n            case 'fade':\r\n                this.updateFadeEffect(effect, progress, animation);\r\n                break;\r\n        }\r\n    }\r\n    \r\n    updateFlickerEffect(effect, elapsed, animation) {\r\n        if (animation?.flickerCount > 0 && effect?.flickerCount < animation?.flickerCount) {\r\n            if (elapsed % animation.flickerSpeed < animation.flickerSpeed / 2) {\r\n                if (animation.opacityFlicker) {\r\n                    effect.material.opacity = Math.random() * 0.6 + 0.4;\r\n                }\r\n                if (animation.colorFlicker) {\r\n                    const colors = [0x00ddff, 0x88aaff, 0xaaffff];\r\n                    effect.material.color.setHex(colors[Math.floor(Math.random() * colors.length)]);\r\n                }\r\n                effect.flickerCount++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    updatePulseEffect(effect, elapsed, animation) {\r\n        if (animation?.pulseEffect) {\r\n            const pulseIntensity = Math.sin(elapsed * 0.01) * 0.3 + 0.7;\r\n            effect.material.opacity = pulseIntensity;\r\n        }\r\n    }\r\n    \r\n    updateFadeEffect(effect, progress, animation) {\r\n        if (animation?.fadeOut && progress > 0.7) {\r\n            const fadeProgress = (progress - 0.7) / 0.3;\r\n            effect.material.opacity = effect.originalOpacity * (1 - fadeProgress);\r\n        }\r\n    }\r\n    \r\n    // Object pooling system\r\n    getPooledGeometry(type, points) {\r\n        const poolKey = `${type}_${points.length}`;\r\n        let pool = this.geometryPool.get(poolKey);\r\n        \r\n        if (!pool) {\r\n            pool = [];\r\n            this.geometryPool.set(poolKey, pool);\r\n        }\r\n        \r\n        if (pool.length > 0) {\r\n            const geometry = pool.pop();\r\n            geometry.setFromPoints(points);\r\n            geometry.computeBoundingSphere();\r\n            return geometry;\r\n        }\r\n        \r\n        return new THREE.BufferGeometry().setFromPoints(points);\r\n    }\r\n    \r\n    getPooledMaterial(config) {\r\n        const poolKey = `${config.color}_${config.linewidth}_${config.blending}`;\r\n        let pool = this.materialPool.get(poolKey);\r\n        \r\n        if (!pool) {\r\n            pool = [];\r\n            this.materialPool.set(poolKey, pool);\r\n        }\r\n        \r\n        if (pool.length > 0) {\r\n            const material = pool.pop();\r\n            material.opacity = config.opacity || 1.0;\r\n            material.color.setHex(config.color || 0xffffff);\r\n            return material;\r\n        }\r\n        \r\n        return new THREE.LineBasicMaterial({\r\n            color: config.color || 0xffffff,\r\n            linewidth: config.linewidth || 2,\r\n            transparent: true,\r\n            opacity: config.opacity || 1.0,\r\n            blending: config.blending || THREE.AdditiveBlending\r\n        });\r\n    }\r\n    \r\n    getPooledEffect() {\r\n        if (this.effectPool.length > 0) {\r\n            return this.effectPool.pop();\r\n        }\r\n        \r\n        return {\r\n            line: null,\r\n            geometry: null,\r\n            material: null,\r\n            startTime: 0,\r\n            duration: 0,\r\n            flickerCount: 0,\r\n            originalOpacity: 1,\r\n            animationType: null\r\n        };\r\n    }\r\n    \r\n    recycleEffect(effect) {\r\n        if (!effect) return;\r\n        \r\n        try {\r\n            // Remove from scene\r\n            if (this.game?.scene && effect.line) {\r\n                this.game.scene.remove(effect.line);\r\n            }\r\n            \r\n            // Return to pools\r\n            if (effect.geometry) {\r\n                const poolKey = `${effect.type}_${effect.geometry.attributes.position.count}`;\r\n                let pool = this.geometryPool.get(poolKey);\r\n                if (!pool) {\r\n                    pool = [];\r\n                    this.geometryPool.set(poolKey, pool);\r\n                }\r\n                if (pool.length < 10) { // Limit pool size\r\n                    pool.push(effect.geometry);\r\n                }\r\n            }\r\n            \r\n            if (effect.material) {\r\n                const poolKey = `${effect.material.color.getHex()}_${effect.material.linewidth}_${effect.material.blending}`;\r\n                let pool = this.materialPool.get(poolKey);\r\n                if (!pool) {\r\n                    pool = [];\r\n                    this.materialPool.set(poolKey, pool);\r\n                }\r\n                if (pool.length < 10) { // Limit pool size\r\n                    pool.push(effect.material);\r\n                }\r\n            }\r\n            \r\n            // Reset effect object and return to pool\r\n            effect.line = null;\r\n            effect.geometry = null;\r\n            effect.material = null;\r\n            effect.startTime = 0;\r\n            effect.duration = 0;\r\n            effect.flickerCount = 0;\r\n            effect.originalOpacity = 1;\r\n            effect.animationType = null;\r\n            \r\n            if (this.effectPool.length < 50) { // Limit pool size\r\n                this.effectPool.push(effect);\r\n            }\r\n            \r\n        } catch (e) {\r\n            console.warn('recycleEffect error:', e);\r\n        }\r\n    }\r\n    \r\n    // Main line effect creation (same interface, better performance)\r\n    createLineEffect(config) {\r\n        if (!this.game.scene) return null;\r\n        \r\n        const {\r\n            startPos,\r\n            endPos,\r\n            type = 'lightning',\r\n            style = {},\r\n            animation = {}\r\n        } = config;\r\n        \r\n        const lineConfig = this.getLineEffectConfig(type);\r\n        const mergedStyle = { ...lineConfig.style, ...style };\r\n        const mergedAnimation = { ...lineConfig.animation, ...animation };\r\n        \r\n        // Generate path based on type\r\n        const points = this.generateLinePath(startPos, endPos, type, mergedStyle);\r\n        \r\n        // Use pooled objects\r\n        const geometry = this.getPooledGeometry(type, points);\r\n        const material = this.getPooledMaterial(mergedStyle);\r\n        const effect = this.getPooledEffect();\r\n        \r\n        // Create line object\r\n        const lineEffect = new THREE.Line(geometry, material);\r\n        this.game.scene.add(lineEffect);\r\n        \r\n        // Setup effect tracking\r\n        effect.line = lineEffect;\r\n        effect.geometry = geometry;\r\n        effect.material = material;\r\n        effect.startTime = this.game.state.now;\r\n        effect.duration = mergedAnimation.duration || 1000;\r\n        effect.originalOpacity = material.opacity;\r\n        effect.type = type;\r\n        \r\n        // Determine animation type for efficient batching\r\n        if (mergedAnimation.flickerCount > 0) {\r\n            effect.animationType = 'flicker';\r\n        } else if (mergedAnimation.pulseEffect) {\r\n            effect.animationType = 'pulse';\r\n        } else if (mergedAnimation.fadeOut) {\r\n            effect.animationType = 'fade';\r\n        }\r\n        \r\n        this.activeEffects.push(effect);\r\n        \r\n        return effect;\r\n    }\r\n    \r\n    // Batch creation for multiple effects\r\n    createBatchedEffects(effects) {\r\n        const results = [];\r\n        \r\n        for (const config of effects) {\r\n            const effect = this.createLineEffect(config);\r\n            if (effect) {\r\n                results.push(effect);\r\n            }\r\n        }\r\n        \r\n        return results;\r\n    }\r\n    \r\n    // Keep existing interface methods unchanged\r\n    createLightningBolt(startPos, endPos, options = {}) {\r\n        return this.createLineEffect({\r\n            startPos,\r\n            endPos,\r\n            type: 'lightning',\r\n            style: options.style || {},\r\n            animation: options.animation || {}\r\n        });\r\n    }\r\n    \r\n    createEnergyBeam(startPos, endPos, options = {}) {\r\n        return this.createLineEffect({\r\n            startPos,\r\n            endPos,\r\n            type: 'beam',\r\n            style: options.style || {},\r\n            animation: options.animation || {}\r\n        });\r\n    }\r\n    \r\n    createMagicArc(startPos, endPos, options = {}) {\r\n        return this.createLineEffect({\r\n            startPos,\r\n            endPos,\r\n            type: 'arc',\r\n            style: options.style || {},\r\n            animation: options.animation || {}\r\n        });\r\n    }\r\n    \r\n    createChainLink(startPos, endPos, options = {}) {\r\n        return this.createLineEffect({\r\n            startPos,\r\n            endPos,\r\n            type: 'chain',\r\n            style: options.style || {},\r\n            animation: options.animation || {}\r\n        });\r\n    }\r\n    \r\n    // Line effect configuration (unchanged)\r\n    getLineEffectConfig(type) {\r\n        const configs = {\r\n            lightning: {\r\n                style: {\r\n                    color: 0x88aaff,\r\n                    linewidth: 3,\r\n                    opacity: 0.9,\r\n                    blending: THREE.AdditiveBlending,\r\n                    segments: 8,\r\n                    deviation: 15,\r\n                    jaggedIntensity: 1.2\r\n                },\r\n                animation: {\r\n                    duration: 0.3,\r\n                    flickerCount: 3,\r\n                    flickerSpeed: 50,\r\n                    opacityFlicker: true,\r\n                    colorFlicker: true,\r\n                    fadeOut: true\r\n                }\r\n            },\r\n            beam: {\r\n                style: {\r\n                    color: 0xff4444,\r\n                    linewidth: 4,\r\n                    opacity: 0.8,\r\n                    blending: THREE.AdditiveBlending,\r\n                    segments: 3,\r\n                    deviation: 2,\r\n                    jaggedIntensity: 0.1\r\n                },\r\n                animation: {\r\n                    duration: 0.5,\r\n                    pulseEffect: true,\r\n                    fadeOut: true\r\n                }\r\n            },\r\n            arc: {\r\n                style: {\r\n                    color: 0x44ff44,\r\n                    linewidth: 2,\r\n                    opacity: 0.7,\r\n                    blending: THREE.AdditiveBlending,\r\n                    segments: 12,\r\n                    deviation: 25,\r\n                    jaggedIntensity: 0.3,\r\n                    arcHeight: 30\r\n                },\r\n                animation: {\r\n                    duration: 0.8,\r\n                    fadeOut: true\r\n                }\r\n            },\r\n            chain: {\r\n                style: {\r\n                    color: 0xffaa00,\r\n                    linewidth: 3,\r\n                    opacity: 0.9,\r\n                    blending: THREE.AdditiveBlending,\r\n                    segments: 6,\r\n                    deviation: 8,\r\n                    jaggedIntensity: 0.8\r\n                },\r\n                animation: {\r\n                    duration: 0.6,\r\n                    flickerCount: 2,\r\n                    flickerSpeed: 80,\r\n                    fadeOut: true\r\n                }\r\n            }\r\n        };\r\n        \r\n        return configs[type] || configs.lightning;\r\n    }\r\n    \r\n    // Path generation (unchanged but more efficient)\r\n    generateLinePath(start, end, type, style) {\r\n        const points = [start.clone()];\r\n        const segments = style.segments || 5;\r\n        const deviation = style.deviation || 10;\r\n        const jaggedIntensity = style.jaggedIntensity || 1;\r\n        \r\n        // Different path generation based on type\r\n        if (type === 'arc') {\r\n            return this.generateArcPath(start, end, style.arcHeight || 20, segments);\r\n        }\r\n        \r\n        for (let i = 1; i < segments; i++) {\r\n            const t = i / segments;\r\n            const basePos = start.clone().lerp(end, t);\r\n            \r\n            // Add jagged deviation\r\n            if (deviation > 0 && jaggedIntensity > 0) {\r\n                const actualDeviation = deviation * jaggedIntensity;\r\n                basePos.x += (Math.random() - 0.5) * actualDeviation;\r\n                basePos.y += (Math.random() - 0.5) * actualDeviation * 0.5;\r\n                basePos.z += (Math.random() - 0.5) * actualDeviation;\r\n            }\r\n            \r\n            points.push(basePos);\r\n        }\r\n        \r\n        points.push(end.clone());\r\n        return points;\r\n    }\r\n    \r\n    generateArcPath(start, end, height, segments) {\r\n        const points = [];\r\n        const midPoint = start.clone().lerp(end, 0.5);\r\n        midPoint.y += height;\r\n        \r\n        for (let i = 0; i <= segments; i++) {\r\n            const t = i / segments;\r\n            const point = this.quadraticBezier(start, midPoint, end, t);\r\n            points.push(point);\r\n        }\r\n        \r\n        return points;\r\n    }\r\n    \r\n    quadraticBezier(p0, p1, p2, t) {\r\n        const point = new THREE.Vector3();\r\n        point.x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;\r\n        point.y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;\r\n        point.z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z + t * t * p2.z;\r\n        return point;\r\n    }\r\n    \r\n    // Clear effects efficiently\r\n    clearAllEffects() {\r\n        // Clear all active line effects\r\n        for (const effect of this.activeEffects) {\r\n            this.recycleEffect(effect);\r\n        }\r\n        this.activeEffects = [];\r\n        \r\n        // Clear all active auras\r\n        if (this.activeAuras) {\r\n            this.activeAuras.clear();\r\n        }\r\n\r\n        // Clear particle effects\r\n        this.game.gameManager.call('clearAllParticles');\r\n\r\n        // Clear notifications\r\n        this.notifications.forEach(notification => {\r\n            this.removeNotification(notification);\r\n        });\r\n        \r\n        this.shakeActive = false;\r\n        this.flashActive = false;\r\n    }\r\n    \r\n    // Force cleanup with pool clearing\r\n    forceCleanup() {\r\n        this.clearAllEffects();\r\n        \r\n        // Clear pools\r\n        for (const [key, pool] of this.geometryPool) {\r\n            pool.forEach(geo => geo.dispose());\r\n            pool.length = 0;\r\n        }\r\n        \r\n        for (const [key, pool] of this.materialPool) {\r\n            pool.forEach(mat => mat.dispose());\r\n            pool.length = 0;\r\n        }\r\n        \r\n        this.effectPool.length = 0;\r\n        this.stats.pooledObjects = 0;\r\n    }\r\n    \r\n    // Performance monitoring\r\n    getPerformanceStats() {\r\n        const poolSize = Array.from(this.geometryPool.values()).reduce((sum, pool) => sum + pool.length, 0) +\r\n                        Array.from(this.materialPool.values()).reduce((sum, pool) => sum + pool.length, 0) +\r\n                        this.effectPool.length;\r\n        \r\n        this.stats.pooledObjects = poolSize;\r\n        \r\n        return {\r\n            ...this.stats,\r\n            memoryUsage: {\r\n                geometryPools: this.geometryPool.size,\r\n                materialPools: this.materialPool.size,\r\n                effectPool: this.effectPool.length\r\n            }\r\n        };\r\n    }\r\n    \r\n    // Keep all existing particle and screen effect methods unchanged\r\n    getEffectConfig(effectType) {\r\n        const configs = {\r\n            victory: {\r\n                count: 5,\r\n                shape: 'star',\r\n                color: 0x00ff00,\r\n                colorRange: { start: 0x00ff00, end: 0xffff00 },\r\n                lifetime: 1.5,\r\n                velocity: { speed: 8, spread: 0.5, pattern: 'burst' },\r\n                scale: 2,\r\n                scaleVariation: 0.3,\r\n                physics: { gravity: -0.5, drag: 0.99 },\r\n                rotation: { enabled: true, speed: 5 },\r\n                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n            },\r\n            defeat: {\r\n                count: 8,\r\n                shape: 'spark',\r\n                color: 0xff0000,\r\n                colorRange: { start: 0xff0000, end: 0x440000 },\r\n                lifetime: 2,\r\n                velocity: { speed: 6, spread: 0.8, pattern: 'burst' },\r\n                scale: 1.5,\r\n                scaleVariation: 0.4,\r\n                physics: { gravity: 0.3, drag: 0.95 },\r\n                rotation: { enabled: true, speed: 3 },\r\n                visual: { fadeOut: true, scaleOverTime: false, blending: 'normal' }\r\n            },\r\n            levelup: {\r\n                count: 12,\r\n                shape: 'glow',\r\n                color: 0xffaa00,\r\n                colorRange: { start: 0xffaa00, end: 0xffffff },\r\n                lifetime: 2.5,\r\n                velocity: { speed: 4, spread: 0.3, pattern: 'fountain' },\r\n                scale: 3,\r\n                scaleVariation: 0.2,\r\n                physics: { gravity: -0.2, drag: 0.98 },\r\n                rotation: { enabled: false },\r\n                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n            }\r\n        };\r\n        \r\n        return configs[effectType] || configs.victory;\r\n    }\r\n    \r\n    // Screen effects (unchanged)\r\n    playScreenShake(duration = 0.3, intensity = 2) {\r\n        if (this.shakeActive) return;\r\n        \r\n        const gameContainer = document.getElementById('gameContainer');\r\n        if (!gameContainer) return;\r\n        \r\n        this.shakeActive = true;\r\n        this.shakeData = {\r\n            startTime: this.game.state.now,\r\n            duration: duration, \r\n            intensity: intensity,\r\n            originalTransform: gameContainer.style.transform\r\n        };\r\n    }\r\n\r\n    playScreenFlash(color = '#ffffff', duration = 0.3) {\r\n        // Disabled for now\r\n        // if (this.flashActive) return;\r\n        // return;\r\n        // this.flashActive = true;\r\n        // const flash = document.createElement('div');\r\n        // flash.className = 'screen-flash';\r\n        // flash.style.cssText = `\r\n        //     position: fixed;\r\n        //     top: 0;\r\n        //     left: 0;\r\n        //     width: 100%;\r\n        //     height: 100%;\r\n        //     background-color: ${color};\r\n        //     pointer-events: none;\r\n        //     z-index: 999;\r\n        //     opacity: 0.6;\r\n        // `;\r\n        \r\n        // document.body.appendChild(flash);\r\n        \r\n        // // Store flash data for game loop processing\r\n        // this.flashData = {\r\n        //     element: flash,\r\n        //     startTime: this.game.state.now,\r\n        //     duration: duration,\r\n        //     startOpacity: 0.6\r\n        // };\r\n    }\r\n    \r\n    // Particle effects - delegate to particle system\r\n    createParticleEffect(x, y, z, type, options = {}) {\r\n        // Convert to the config format that ParticleSystem.createParticles expects\r\n        const config = {\r\n            position: new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z),\r\n            count: options.count || 3,\r\n            shape: options.shape || 'circle',\r\n            color: options.color || 0xffffff,\r\n            colorRange: options.colorRange || null,\r\n            lifetime: options.lifetime || 1.5,\r\n            velocity: options.velocity || { speed: 5, spread: 1, pattern: 'burst' },\r\n            scale: (options.scaleMultiplier || 1) * 1.0,\r\n            scaleVariation: options.scaleVariation || 0.5,\r\n            physics: options.physics || { gravity: 0.5, drag: 0.98 },\r\n            rotation: options.rotation || { enabled: false, speed: 0 },\r\n            visual: options.visual || { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n        };\r\n\r\n        this.game.gameManager.call('createParticles', config);\r\n    }\r\n    \r\n    showVictoryEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'victory', options);\r\n        this.playScreenFlash('#44ff44', 0.3);\r\n        this.showGameNotification('Victory!', 'You won!', 'success', 2000);\r\n    }\r\n    \r\n    showDefeatEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'defeat', options);\r\n        this.playScreenFlash('#ff4444', 0.5);\r\n        this.showGameNotification('Defeat!', 'You lost!', 'error', 2000);\r\n    }\r\n    \r\n    showExplosionEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'explosion', options);\r\n        this.playScreenShake(0.2, 3);\r\n    }\r\n    \r\n    showHealEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'heal', options);\r\n    }\r\n    \r\n    showMagicEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'magic', options);\r\n    }\r\n    \r\n    showDamageEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'damage', options);\r\n    }\r\n    \r\n    showLevelUpEffect(x, y, z, options = {}) {\r\n        this.createParticleEffect(x, y, z, 'levelup', options);\r\n        this.playScreenShake(0.4, 1);\r\n        this.showGameNotification('Level Up!', 'Character advanced!', 'success', 3000);\r\n    }\r\n    \r\n    // Missing method that abilities are calling\r\n    createAuraEffect(x, y, z, type, duration) {\r\n        if (!this.game.particleSystem) return;\r\n        const auraId = `aura_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n        const startTime = this.game.state.now;\r\n        const position = new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z);\r\n        \r\n        // Create aura configuration\r\n        const config = this.getEffectConfig(type);\r\n        const auraData = {\r\n            id: auraId,\r\n            position: position.clone(),\r\n            type: type,\r\n            startTime: startTime,\r\n            duration: duration,\r\n            lastParticleTime: startTime,\r\n            particleInterval: 1, // 1 second between particle bursts\r\n            isActive: true,\r\n            config: {\r\n                count: 4,\r\n                shape: 'circle',\r\n                color: config.color || 0xffffff,\r\n                colorRange: config.colorRange || null,\r\n                lifetime: 2.0,\r\n                velocity: { speed: 2, spread: 0.8, pattern: 'burst' },\r\n                scale: (config.scale || 1) * 0.8,\r\n                scaleVariation: 0.3,\r\n                physics: { gravity: -0.1, drag: 0.98 },\r\n                rotation: { enabled: true, speed: 1 },\r\n                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n            }\r\n        };\r\n        \r\n        // Add to active auras tracking\r\n        if (!this.activeAuras) {\r\n            this.activeAuras = new Map();\r\n        }\r\n        this.activeAuras.set(auraId, auraData);\r\n        \r\n        return auraId;\r\n    }\r\n    \r\n    // Missing methods that were in the original EffectsSystem\r\n    showNotification(message, type = 'info', duration = 3000) {\r\n        const notification = document.createElement('div');\r\n        notification.className = `game-notification notification-${type}`;\r\n        notification.textContent = message;\r\n        notification.style.cssText = `\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            padding: 1rem 1.5rem;\r\n            border-radius: 8px;\r\n            color: white;\r\n            font-family: 'Courier New', monospace;\r\n            font-weight: bold;\r\n            z-index: 1000;\r\n            animation: notificationSlideIn 0.5s ease-out;\r\n            max-width: 300px;\r\n            word-wrap: break-word;\r\n        `;\r\n        \r\n        switch (type) {\r\n            case 'victory':\r\n                notification.style.background = 'linear-gradient(145deg, #001100, #003300)';\r\n                notification.style.border = '2px solid #00ff00';\r\n                notification.style.color = '#00ff00';\r\n                notification.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.5)';\r\n                break;\r\n            case 'defeat':\r\n                notification.style.background = 'linear-gradient(145deg, #110000, #330000)';\r\n                notification.style.border = '2px solid #ff0000';\r\n                notification.style.color = '#ff4444';\r\n                notification.style.textShadow = '0 0 10px rgba(255, 68, 68, 0.5)';\r\n                break;\r\n            case 'levelup':\r\n                notification.style.background = 'linear-gradient(145deg, #111100, #333300)';\r\n                notification.style.border = '2px solid #ffd700';\r\n                notification.style.color = '#ffd700';\r\n                notification.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.5)';\r\n                break;\r\n            default:\r\n                notification.style.background = 'linear-gradient(145deg, #001122, #003344)';\r\n                notification.style.border = '2px solid #00aaff';\r\n                notification.style.color = '#00aaff';\r\n                notification.style.textShadow = '0 0 10px rgba(0, 170, 255, 0.5)';\r\n        }\r\n        \r\n        document.body.appendChild(notification);\r\n        this.notifications.push(notification);\r\n        this.repositionNotifications();\r\n        \r\n        setTimeout(() => {\r\n            this.removeNotification(notification);\r\n        }, duration);\r\n    }\r\n    \r\n    showGameNotification(title, message, type = 'info', duration = 3000) {\r\n        const notification = document.createElement('div');\r\n        notification.className = `game-notification notification-${type}`;\r\n        notification.innerHTML = `\r\n            <div style=\"font-weight: bold; margin-bottom: 5px;\">${title}</div>\r\n            <div>${message}</div>\r\n        `;\r\n        \r\n        notification.style.cssText = `\r\n            position: fixed;\r\n            top: 20px;\r\n            right: 20px;\r\n            background: rgba(0, 0, 0, 0.8);\r\n            color: white;\r\n            padding: 15px;\r\n            border-radius: 8px;\r\n            border-left: 4px solid ${this.getNotificationColor(type)};\r\n            max-width: 300px;\r\n            z-index: 1001;\r\n            animation: notificationSlideIn 0.3s ease-out;\r\n        `;\r\n        \r\n        document.body.appendChild(notification);\r\n        this.notifications.push(notification);\r\n        \r\n        setTimeout(() => {\r\n            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';\r\n            setTimeout(() => {\r\n                if (document.body.contains(notification)) {\r\n                    document.body.removeChild(notification);\r\n                    const index = this.notifications.indexOf(notification);\r\n                    if (index > -1) {\r\n                        this.notifications.splice(index, 1);\r\n                    }\r\n                }\r\n            }, 300);\r\n        }, duration);\r\n    }\r\n    \r\n    getNotificationColor(type) {\r\n        const colors = {\r\n            info: '#4444ff',\r\n            success: '#44ff44',\r\n            warning: '#ffaa00',\r\n            error: '#ff4444'\r\n        };\r\n        return colors[type] || '#4444ff';\r\n    }\r\n    \r\n    removeNotification(notification) {\r\n        if (document.body.contains(notification)) {\r\n            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';\r\n            setTimeout(() => {\r\n                if (document.body.contains(notification)) {\r\n                    document.body.removeChild(notification);\r\n                }\r\n                const index = this.notifications.indexOf(notification);\r\n                if (index > -1) {\r\n                    this.notifications.splice(index, 1);\r\n                }\r\n                this.repositionNotifications();\r\n            }, 300);\r\n        }\r\n    }\r\n    \r\n    repositionNotifications() {\r\n        this.notifications.forEach((notification, index) => {\r\n            notification.style.top = `${20 + index * 80}px`;\r\n        });\r\n    }\r\n    \r\n    getDamageColor(type) {\r\n        switch (type) {\r\n            case 'heal': return 0x00ff88;\r\n            case 'critical': return 0xff0044;\r\n            case 'poison': return 0x8a2be2;\r\n            case 'fire': return 0xff4400;\r\n            case 'cold': return 0x00bfff;\r\n            case 'lightning': return 0xffff00;\r\n            case 'divine': return 0xffd700;\r\n            default: return 0xff4444;\r\n        }\r\n    }\r\n    \r\n    addEffectsCSS() {\r\n        const style = document.createElement('style');\r\n        style.id = 'effects-styles';\r\n        style.textContent = `\r\n            .screen-flash {\r\n                transition: opacity 0.3s ease-out;\r\n            }\r\n            \r\n            @keyframes battleStartTransition {\r\n                0% { transform: translateX(-100%); }\r\n                100% { transform: translateX(100%); }\r\n            }\r\n            \r\n            @keyframes flashFade {\r\n                0% { opacity: 0.6; }\r\n                100% { opacity: 0; }\r\n            }\r\n            \r\n            @keyframes notificationSlideIn {\r\n                from { \r\n                    transform: translateX(100%);\r\n                    opacity: 0; \r\n                }\r\n                to { \r\n                    transform: translateX(0);\r\n                    opacity: 1; \r\n                }\r\n            }\r\n            \r\n            @keyframes notificationSlideOut {\r\n                from { \r\n                    transform: translateX(0);\r\n                    opacity: 1; \r\n                }\r\n                to { \r\n                    transform: translateX(100%);\r\n                    opacity: 0; \r\n                }\r\n            }\r\n            \r\n            .game-notification {\r\n                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);\r\n                backdrop-filter: blur(5px);\r\n            }\r\n        `;\r\n        document.head.appendChild(style);\r\n    }\r\n    \r\n    // Main update method called by game loop\r\n    update() {\r\n        this.updateAllEffects();\r\n        this.updateAuras(); \r\n        this.updateScreenEffects();\r\n    }\r\n    \r\n    updateAuras() {\r\n        if (!this.activeAuras || !this.game.state) return;\r\n        \r\n        const currentTime = this.game.state.now;\r\n        const aurasToRemove = [];\r\n        \r\n        for (const [auraId, auraData] of this.activeAuras) {\r\n            const elapsed = currentTime - auraData.startTime;\r\n            \r\n            // Check if aura has expired\r\n            if (elapsed >= auraData.duration) {\r\n                aurasToRemove.push(auraId);\r\n                continue;\r\n            }\r\n            \r\n            // Check if it's time to create new particles\r\n            const timeSinceLastParticle = currentTime - auraData.lastParticleTime;\r\n            if (timeSinceLastParticle >= auraData.particleInterval) {\r\n                this.createAuraParticles(auraData);\r\n                auraData.lastParticleTime = currentTime;\r\n            }\r\n        }\r\n        \r\n        // Remove expired auras\r\n        aurasToRemove.forEach(auraId => {\r\n            this.activeAuras.delete(auraId);\r\n        });\r\n    }\r\n    \r\n    updateScreenEffects() {\r\n        // Handle screen shake\r\n        if (this.shakeActive && this.shakeData) {\r\n            const gameContainer = document.getElementById('gameContainer');\r\n            if (!gameContainer) {\r\n                this.shakeActive = false;\r\n                return;\r\n            }\r\n            \r\n            const elapsed = this.game.state.now - this.shakeData.startTime;\r\n            const progress = elapsed / this.shakeData.duration;\r\n            \r\n            if (progress >= 1) {\r\n                gameContainer.style.transform = this.shakeData.originalTransform;\r\n                this.shakeActive = false;\r\n                this.shakeData = null;\r\n            } else {\r\n                const diminishingIntensity = this.shakeData.intensity * (1 - progress);\r\n                const shakeX = (Math.random() - 0.5) * diminishingIntensity;\r\n                const shakeY = (Math.random() - 0.5) * diminishingIntensity;\r\n                gameContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`;\r\n            }\r\n        }\r\n        \r\n        // Handle screen flash\r\n        if (this.flashActive && this.flashData) {\r\n            const elapsed = this.game.state.now - this.flashData.startTime;\r\n            const progress = elapsed / this.flashData.duration;\r\n            \r\n            if (progress >= 1) {\r\n                // Flash finished\r\n                if (document.body.contains(this.flashData.element)) {\r\n                    document.body.removeChild(this.flashData.element);\r\n                }\r\n                this.flashActive = false;\r\n                this.flashData = null;\r\n            } else {\r\n                // Fade out the flash\r\n                const opacity = this.flashData.startOpacity * (1 - progress);\r\n                this.flashData.element.style.opacity = opacity;\r\n            }\r\n        }\r\n    }\r\n    \r\n    createAuraParticles(auraData) {\r\n        const particleConfig = {\r\n            position: auraData.position,\r\n            ...auraData.config\r\n        };\r\n\r\n        this.game.gameManager.call('createParticles', particleConfig);\r\n    }\r\n    \r\n    destroy() {\r\n        this.forceCleanup();\r\n        \r\n        // Clean up damage number system\r\n        if (this.damageNumberMesh) {\r\n            this.game.scene.remove(this.damageNumberMesh);\r\n            this.damageTextGeometry.dispose();\r\n            this.damageTextMaterial.dispose();\r\n            this.damageTexture.dispose();\r\n        }\r\n        \r\n        const styleElement = document.querySelector('#effects-styles');\r\n        if (styleElement) {\r\n            styleElement.remove();\r\n        }\r\n        \r\n        console.log('EffectsSystem destroyed');\r\n    }\r\n    \r\n    entityDestroyed(entityId) {\r\n        // Clean up any auras associated with this entity\r\n        if (this.activeAuras) {\r\n            const aurasToRemove = [];\r\n            for (const [auraId, auraData] of this.activeAuras) {\r\n                if (auraData.sourceEntityId === entityId || auraData.targetEntityId === entityId) {\r\n                    aurasToRemove.push(auraId);\r\n                }\r\n            }\r\n            aurasToRemove.forEach(auraId => this.activeAuras.delete(auraId));\r\n        }\r\n        \r\n        // Clean up any particle effects tracking\r\n        if (this.entityEffects) {\r\n            this.entityEffects.delete(entityId);\r\n        }\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EffectsSystem.js",
        "fileName": "EffectsSystem"
      },
      "GridSystem": {
        "script": "class GridSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.gridSystem = this;\r\n        \r\n        this.state = new Map();\r\n\r\n        // NEW: track which half each team owns\r\n        this.teamSides = { player: 'left', enemy: 'right' };\r\n        this.leftBounds = null;\r\n        this.rightBounds = null;\r\n    }\r\n    \r\n    init() {\r\n        this.game.gameManager.register('getNearbyUnits', this.getNearbyUnits.bind(this));\r\n        this.game.gameManager.register('convertGridToWorldPosition', this.gridToWorld.bind(this));\r\n        this.game.gameManager.register('convertWorldToGridPosition', this.worldToGrid.bind(this));\r\n        this.game.gameManager.register('isValidGridPlacement', this.isValidGridPlacement.bind(this));\r\n        this.game.gameManager.register('reserveGridCells', this.occupyCells.bind(this));\r\n        this.game.gameManager.register('releaseGridCells', this.freeCells.bind(this));\r\n        this.game.gameManager.register('getUnitGridCells', this.getUnitCells.bind(this));\r\n\r\n        const collections = this.game.getCollections();\r\n\r\n        const terrainGridSize = collections.configs.game.gridSize;\r\n        const placementGridSize = terrainGridSize / 2; // Placement grid is always half the terrain grid\r\n        const currentLevel = collections.configs.state.level;\r\n        const terrainSize = collections.levels[currentLevel]?.tileMap?.size * terrainGridSize;\r\n\r\n        this.cellSize = placementGridSize;\r\n        this.terrainGridSize = terrainGridSize;\r\n        this.showGrid = true;\r\n        this.snapToGrid = true;\r\n        this.highlightValidCells = true;\r\n        \r\n        this.dimensions = {\r\n            width: Math.floor(terrainSize / placementGridSize),\r\n            height: Math.floor(terrainSize / placementGridSize),\r\n            cellSize: placementGridSize,\r\n            startX: -terrainSize / 2,\r\n            startZ: -terrainSize / 2\r\n        };\r\n        console.log(\"dimensions\", this.dimensions);\r\n        \r\n        this.gridVisualization = null;\r\n\r\n        // Compute half-splits once\r\n        const half = Math.floor(this.dimensions.width / 2);\r\n        this.leftBounds = {\r\n            minX: 0,\r\n            maxX: half - 1,\r\n            minZ: 0,\r\n            maxZ: this.dimensions.height - 1\r\n        };\r\n        this.rightBounds = {\r\n            minX: half,\r\n            maxX: this.dimensions.width - 1,\r\n            minZ: 0,\r\n            maxZ: this.dimensions.height - 1\r\n        };\r\n\r\n        // Default: player=left, enemy=right (can be swapped later)\r\n        this.playerBounds = this.leftBounds;\r\n        this.enemyBounds  = this.rightBounds;\r\n        \r\n        // Pre-calculate world bounds for faster collision detection\r\n        this.worldBounds = {\r\n            minX: this.dimensions.startX,\r\n            maxX: this.dimensions.startX + (this.dimensions.width * placementGridSize),\r\n            minZ: this.dimensions.startZ,\r\n            maxZ: this.dimensions.startZ + (this.dimensions.height * placementGridSize)\r\n        };\r\n    }\r\n\r\n    // NEW: set which half each team owns (call this when you learn sides from the server)\r\n    setTeamSides(sides) {\r\n        if (sides?.player === 'left' || sides?.player === 'right') {\r\n            this.teamSides.player = sides.player;\r\n        }\r\n        if (sides?.enemy === 'left' || sides?.enemy === 'right') {\r\n            this.teamSides.enemy = sides.enemy;\r\n        }\r\n\r\n        // Point player/enemy bounds at the correct half\r\n        this.playerBounds = (this.teamSides.player === 'left') ? this.leftBounds : this.rightBounds;\r\n        this.enemyBounds  = (this.teamSides.enemy  === 'left') ? this.leftBounds : this.rightBounds;\r\n\r\n    }\r\n    \r\n    createVisualization(scene) {\r\n        if (this.gridVisualization) {\r\n            scene.remove(this.gridVisualization);\r\n        }\r\n        \r\n        const group = new THREE.Group();\r\n        const { width, height, cellSize, startX, startZ } = this.dimensions;\r\n        \r\n        // Use BufferGeometry for better performance\r\n        const linePositions = [];\r\n        \r\n        // Vertical lines\r\n        for (let x = 0; x <= width; x++) {\r\n            const worldX = startX + (x * cellSize);\r\n            linePositions.push(\r\n                worldX, 1, startZ,\r\n                worldX, 1, startZ + (height * cellSize)\r\n            );\r\n        }\r\n        \r\n        // Horizontal lines\r\n        for (let z = 0; z <= height; z++) {\r\n            const worldZ = startZ + (z * cellSize);\r\n            linePositions.push(\r\n                startX, 1, worldZ,\r\n                startX + (width * cellSize), 1, worldZ\r\n            );\r\n        }\r\n        \r\n        const lineGeometry = new THREE.BufferGeometry();\r\n        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));\r\n        \r\n        const lineMaterial = new THREE.LineBasicMaterial({ \r\n            color: 0x444444, \r\n            transparent: true, \r\n            opacity: 0.3 \r\n        });\r\n        \r\n        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);\r\n        group.add(lines);\r\n        \r\n        // Center divider line\r\n        const dividerPositions = [\r\n            startX + (width * cellSize / 2), 2, startZ,\r\n            startX + (width * cellSize / 2), 2, startZ + (height * cellSize)\r\n        ];\r\n        \r\n        const dividerGeometry = new THREE.BufferGeometry();\r\n        dividerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dividerPositions, 3));\r\n        \r\n        const dividerMaterial = new THREE.LineBasicMaterial({ \r\n            color: 0xff0000, \r\n            transparent: true, \r\n            opacity: 0.5 \r\n        });\r\n        \r\n        const dividerLine = new THREE.LineSegments(dividerGeometry, dividerMaterial);\r\n        group.add(dividerLine);\r\n        \r\n        this.gridVisualization = group;\r\n        scene.add(this.gridVisualization);\r\n    }\r\n    \r\n    worldToGrid(worldX, worldZ) {\r\n        const { cellSize, startX, startZ } = this.dimensions;\r\n        return {\r\n            x: Math.floor((worldX - startX) / cellSize),\r\n            z: Math.floor((worldZ - startZ) / cellSize)\r\n        };\r\n    }\r\n    \r\n    gridToWorld(gridX, gridZ) {\r\n        const { cellSize, startX, startZ } = this.dimensions;\r\n        return {\r\n            x: startX + (gridX * cellSize),\r\n            z: startZ + (gridZ * cellSize)\r\n        };\r\n    }\r\n    \r\n    // OPTIMIZED: Early bounds checking\r\n    isValidPosition(gridPos) {\r\n        return gridPos.x >= 0 && gridPos.x < this.dimensions.width &&\r\n               gridPos.z >= 0 && gridPos.z < this.dimensions.height;\r\n    }\r\n\r\n    isValidGridPlacement(cells, team) {\r\n        if (!cells || cells.length === 0) return false;\r\n        \r\n        for (const cell of cells) {\r\n            const key = `${cell.x},${cell.z}`;\r\n            const cellState = this.state.get(key);\r\n            if (cellState && cellState.occupied) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        \r\n        return true;\r\n    }\r\n\r\n    getUnitCells(entityId) {\r\n\r\n        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);\r\n        const pos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);\r\n\r\n        if(!unitType) return null;\r\n        const cells = [];\r\n\r\n        // For buildings, convert footprint (terrain grid units) to placement grid cells\r\n        // For units, use placementGridWidth/Height directly (already in placement grid units)\r\n        let placementGridWidth, placementGridHeight;\r\n\r\n        if (unitType.collection === 'buildings') {\r\n            // Buildings use footprint in terrain grid units, convert to placement grid cells (2x)\r\n            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 1;\r\n            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 1;\r\n            placementGridWidth = footprintWidth * 2;\r\n            placementGridHeight = footprintHeight * 2;\r\n        } else {\r\n            // Units use placement grid units directly\r\n            placementGridWidth = unitType.placementGridWidth || 1;\r\n            placementGridHeight = unitType.placementGridHeight || 1;\r\n        }\r\n\r\n        const gridPos = this.worldToGrid(pos.x, pos.z);\r\n        // Calculate starting position to center the formation\r\n        const startX = gridPos.x - Math.floor(placementGridWidth / 2);\r\n        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);\r\n        for (let x = 0; x < placementGridWidth; x++) {\r\n            for (let z = 0; z < placementGridHeight; z++) {\r\n                cells.push({\r\n                    x: startX + x,\r\n                    z: startZ + z\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n    getNearbyUnits(pos, radius, excludeEntityId = null, collection = null) {\r\n        const gridPos = this.worldToGrid(pos.x, pos.z);\r\n        const cellRadius = Math.ceil(radius / this.cellSize);\r\n        \r\n        const nearbyUnits = [];\r\n        const radiusSq = radius * radius;\r\n        const seen = new Set(); // Prevent duplicates\r\n\r\n        for (let gz = gridPos.z - cellRadius; gz <= gridPos.z + cellRadius; gz++) {\r\n            for (let gx = gridPos.x - cellRadius; gx <= gridPos.x + cellRadius; gx++) {\r\n                if (!this.isValidPosition({ x: gx, z: gz })) continue;\r\n                \r\n                const cellState = this.getCellState(gx, gz);\r\n                if (!cellState?.entities?.length) continue;\r\n\r\n                for (const entityId of cellState.entities) {\r\n                    if (entityId === excludeEntityId || seen.has(entityId)) continue;\r\n\r\n                    const entityPos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);\r\n                    const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);\r\n                    \r\n                    if (!entityPos || !unitType) continue;\r\n\r\n                    const dx = entityPos.x - pos.x;\r\n                    const dz = entityPos.z - pos.z;\r\n                    const distSq = dx * dx + dz * dz;\r\n                    \r\n                    if(collection && unitType.collection != collection) continue;\r\n\r\n                    if (distSq <= radiusSq) {\r\n                        seen.add(entityId);\r\n                        nearbyUnits.push({\r\n                            x: entityPos.x,\r\n                            z: entityPos.z,\r\n                            y: entityPos.y,\r\n                            id: entityId,\r\n                            ...unitType\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return nearbyUnits.sort((a, b) => a.id.localeCompare(b.id));\r\n    }\r\n\r\n    onEntityPositionUpdated(entityId) {\r\n        const cells = this.getUnitCells(entityId);\r\n        this.freeCells(entityId);\r\n        this.occupyCells(cells, entityId);\r\n    }\r\n\r\n    occupyCells(cells, entityId) {       \r\n        for (const cell of cells) {\r\n            const key = `${cell.x},${cell.z}`;\r\n            let cellState = this.state.get(key);\r\n\r\n            if (!cellState) {\r\n                cellState = { occupied: true, entities: [] };\r\n                this.state.set(key, cellState);\r\n            }\r\n\r\n            // Add entity if not already present\r\n            if (!cellState.entities.includes(entityId)) {\r\n                cellState.entities.push(entityId);\r\n            }\r\n            cellState.entities.sort((a, b) => a.localeCompare(b));     \r\n        }           \r\n    }\r\n        \r\n    freeCells(entityId) {\r\n        for (const [key, cellState] of this.state.entries()) {\r\n            if (cellState.entities.includes(entityId)) {\r\n                cellState.entities = cellState.entities.filter(id => id !== entityId);\r\n                \r\n                // Clean up empty cell\r\n                if (cellState.entities.length === 0) {\r\n                    this.state.delete(key);\r\n                } else {                    \r\n                    cellState.entities.sort((a, b) => a.localeCompare(b));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        console.log('grid system cleared');\r\n        this.state.clear();\r\n    }\r\n    \r\n    toggleVisibility(scene) {\r\n        this.showGrid = !this.showGrid;\r\n        \r\n        if (this.showGrid) {\r\n            this.createVisualization(scene);\r\n        } else if (this.gridVisualization) {\r\n            scene.remove(this.gridVisualization);\r\n            this.gridVisualization = null;\r\n        }\r\n    }\r\n    \r\n    getBounds(team) {\r\n        // Keep API compatibility; these references are updated by setTeamSides()\r\n        return team === 'right' ? this.rightBounds : this.leftBounds;\r\n    }\r\n        \r\n    getCellState(gridX, gridZ) {\r\n        return this.state.get(`${gridX},${gridZ}`);\r\n    }\r\n\r\n    getOccupiedCells() {\r\n        return Array.from(this.state.entries()).map(([key, value]) => {\r\n            const [x, z] = key.split(',').map(Number);\r\n            return { x, z, ...value };\r\n        });\r\n    }\r\n    \r\n    getGridInfo() {\r\n        return {\r\n            dimensions: this.dimensions,\r\n            leftBounds: this.leftBounds,\r\n            rightBounds: this.rightBounds,\r\n            teamSides: { ...this.teamSides },\r\n            occupiedCells: this.getOccupiedCells(),\r\n            totalCells: this.dimensions.width * this.dimensions.height,\r\n            occupiedCount: this.state.size\r\n        };\r\n    }\r\n    \r\n    // OPTIMIZED: Batch cell queries for better performance\r\n    areCellsOccupied(cells) {\r\n        for (const cell of cells) {\r\n            const key = `${cell.x},${cell.z}`;\r\n            if (this.state.has(key)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    onDestroyBuilding(entityId){ \r\n        this.freeCells(entityId);\r\n    }\r\n\r\n    onUnitKilled(entityId){  \r\n        this.freeCells(entityId);\r\n    }\r\n\r\n    \r\n    // OPTIMIZED: Fast world bounds check\r\n    isInWorldBounds(worldX, worldZ) {\r\n        return worldX >= this.worldBounds.minX && worldX <= this.worldBounds.maxX &&\r\n               worldZ >= this.worldBounds.minZ && worldZ <= this.worldBounds.maxZ;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GridSystem.js",
        "fileName": "GridSystem"
      },
      "PostProcessingSystem": {
        "script": "class PostProcessingSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.postProcessingSystem = this;\r\n        \r\n        this.composer = null;\r\n        this.passes = new Map();\r\n        this.passOrder = ['render', 'pixel', 'fog', 'output'];\r\n    }\r\n\r\n    init(params = {}) {\r\n        this.params = params;\r\n\r\n        this.game.gameManager.register('registerPostProcessingPass', this.registerPass.bind(this));\r\n        this.game.gameManager.register('removePostProcessingPass', this.removePass.bind(this));\r\n        this.game.gameManager.register('renderPostProcessing', this.render.bind(this));\r\n        this.game.gameManager.register('getPostProcessingComposer', this.getPostProcessingComposer.bind(this));\r\n    }\r\n\r\n    postAllInit() {\r\n        \r\n        if (!this.game.renderer || !this.game.scene || !this.game.camera) {\r\n            console.error('[PostProcessingSystem] Missing renderer, scene, or camera in postAllInit');\r\n            return;\r\n        }\r\n        \r\n        \r\n        this.composer = new THREE_.EffectComposer(this.game.renderer);\r\n        \r\n        // Create depth textures for both render targets\r\n        const depthTexture1 = new THREE.DepthTexture();\r\n        depthTexture1.format = THREE.DepthFormat;\r\n        depthTexture1.type   = THREE.UnsignedIntType; // 24/32-bit depth\r\n\r\n        const depthTexture2 = new THREE.DepthTexture();\r\n        depthTexture2.format = THREE.DepthFormat;\r\n        depthTexture2.type   = THREE.UnsignedIntType;\r\n\r\n        this.composer.renderTarget1.depthTexture = depthTexture1;\r\n        this.composer.renderTarget1.depthBuffer  = true;\r\n        this.composer.renderTarget2.depthTexture = depthTexture2;\r\n        this.composer.renderTarget2.depthBuffer  = true;\r\n\r\n        // Make sure sizes are synced after attaching:\r\n        const size = this.game.renderer.getSize(new THREE.Vector2());\r\n        this.composer.setSize(size.x, size.y);\r\n        \r\n        if (this.passes.size > 0) {\r\n            this.rebuildComposer();\r\n        }\r\n        \r\n    }\r\n\r\n    getPostProcessingComposer() {\r\n        return this.composer;\r\n    }\r\n\r\n    registerPass(name, passConfig) {\r\n        \r\n        if (this.passes.has(name)) {\r\n            console.warn(`[PostProcessingSystem] Pass ${name} already exists, replacing`);\r\n        }\r\n        \r\n        this.passes.set(name, passConfig);\r\n        \r\n        if (this.composer) {\r\n            this.rebuildComposer();\r\n        } \r\n    }\r\n\r\n    removePass(name) {\r\n        \r\n        if (this.passes.has(name)) {\r\n            const passConfig = this.passes.get(name);\r\n            if (passConfig.dispose) {\r\n                passConfig.dispose();\r\n            }\r\n            this.passes.delete(name);\r\n            \r\n            if (this.composer) {\r\n                this.rebuildComposer();\r\n            }\r\n        }\r\n    }\r\n\r\n    rebuildComposer() {\r\n        if (!this.composer) {\r\n            console.warn('[PostProcessingSystem] Composer not initialized yet');\r\n            return;\r\n        }\r\n        \r\n        \r\n        this.composer.passes = [];\r\n        \r\n        for (const passName of this.passOrder) {\r\n            const passConfig = this.passes.get(passName);\r\n            \r\n            if (!passConfig) continue;\r\n            \r\n            if (passConfig.enabled === false) {\r\n                continue;\r\n            }\r\n            \r\n            if (typeof passConfig.create === 'function') {\r\n                const pass = passConfig.create();\r\n                this.composer.addPass(pass);\r\n            } else if (passConfig.pass) {\r\n                this.composer.addPass(passConfig.pass);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    render() {\r\n        if (this.composer) {\r\n            // Render main scene with all post-processing (including fog)\r\n            this.composer.render();\r\n            \r\n            if (this.game.uiScene) {\r\n                this.game.renderer.autoClear = false;  // Don't clear the screen    \r\n                this.game.renderer.clearDepth();             \r\n                this.game.renderer.render(this.game.uiScene, this.game.camera);\r\n                this.game.renderer.autoClear = true;   // Reset for next frame\r\n            }\r\n        }\r\n    }\r\n\r\n    setSize(width, height) {\r\n        if (this.composer) {\r\n            this.composer.setSize(width, height);\r\n        }\r\n    }\r\n\r\n    dispose() {\r\n        if (this.composer) {\r\n            this.composer.passes.forEach(pass => {\r\n                if (pass.dispose) pass.dispose();\r\n            });\r\n        }\r\n        this.passes.clear();\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PostProcessingSystem.js",
        "fileName": "PostProcessingSystem"
      },
      "TerrainSystem": {
        "script": "class TerrainSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.terrainSystem = this;\r\n        \r\n        this.initialized = false;\r\n        \r\n        // Core terrain data\r\n        this.level = null;\r\n        this.world = null;\r\n        this.tileMap = null;\r\n        this.heightMapData = null;\r\n        \r\n        // Settings from collections\r\n        this.heightMapSettings = null;\r\n        \r\n        // Terrain dimensions\r\n        this.terrainSize = 0;\r\n        this.extensionSize = 0;\r\n        this.extendedSize = 0;\r\n        this.heightStep = 0;\r\n        \r\n        // Height map canvas for processing (lightweight)\r\n        this.heightMapCanvas = null;\r\n        this.heightMapCtx = null;\r\n    }\r\n\r\n    init() {\r\n        if (this.initialized) return;\r\n\r\n        this.game.gameManager.register('getTerrainHeightAtPosition', this.getTerrainHeightAtPosition.bind(this));\r\n        this.game.gameManager.register('getTerrainSize', () => this.terrainSize);\r\n        this.game.gameManager.register('getTerrainTypeAtPosition', this.getTerrainTypeAtPosition.bind(this));\r\n        this.game.gameManager.register('getTileMapTerrainType', this.getTileMapTerrainType.bind(this));\r\n        this.game.gameManager.register('getTerrainTypeAtGridPosition', this.getTerrainTypeAtGridPosition.bind(this));\r\n\r\n        // Load world data\r\n        this.loadWorldData();\r\n\r\n        // Initialize height map processing\r\n        this.initializeHeightMapProcessing();\r\n\r\n        this.initialized = true;\r\n    }\r\n\r\n    loadWorldData() {\r\n        const collections = this.game.getCollections();\r\n        if (!collections) {\r\n            console.error('TerrainSystem: No collections found');\r\n            return;\r\n        }\r\n\r\n        const currentLevel = this.game.state?.level || 'level1';\r\n        this.level = collections.levels?.[currentLevel];\r\n        \r\n        if (!this.level) {\r\n            console.error(`TerrainSystem: Level '${currentLevel}' not found`);\r\n            return;\r\n        }\r\n\r\n        this.world = collections.worlds?.[this.level.world];\r\n        if (!this.world) {\r\n            console.error(`TerrainSystem: World '${this.level.world}' not found`);\r\n            return;\r\n        }\r\n\r\n        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];\r\n        this.heightStep = this.heightMapSettings?.heightStep || 10;\r\n        this.tileMap = this.level.tileMap;\r\n\r\n        // Calculate world dimensions\r\n        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;\r\n        this.extensionSize = this.world.extensionSize || 0;\r\n        this.extendedSize = this.terrainSize + 2 * this.extensionSize;\r\n    }\r\n\r\n    initializeHeightMapProcessing() {\r\n        if (!this.heightMapSettings?.enabled) {\r\n            console.log('TerrainSystem: Height map disabled, using flat terrain');\r\n            return;\r\n        }\r\n\r\n        // Check if we're running in a browser environment\r\n        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\r\n        \r\n        if (isBrowser) {\r\n            // Create a small canvas for height map processing\r\n            this.heightMapCanvas = document.createElement('canvas');\r\n            this.heightMapCanvas.width = this.terrainSize;\r\n            this.heightMapCanvas.height = this.terrainSize;\r\n            this.heightMapCtx = this.heightMapCanvas.getContext('2d');\r\n            this.processHeightMapFromCanvas();\r\n        } else {\r\n            // For server-side, we'll work directly with the terrain data\r\n            console.log('TerrainSystem: Running in server mode, using data-only height processing');\r\n            this.processHeightMapFromData();\r\n        }\r\n    }\r\n\r\n    processHeightMapFromData() {\r\n        if (!this.tileMap?.terrainMap) {\r\n            console.warn('TerrainSystem: No terrain map data available');\r\n            return;\r\n        }\r\n\r\n        // Initialize height map data array\r\n        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);\r\n\r\n        // Check if we have a separate heightMap in the tileMap\r\n        const hasHeightMap = this.tileMap.heightMap && this.tileMap.heightMap.length > 0;\r\n\r\n        // Set extension area height\r\n        let extensionHeight;\r\n        if (hasHeightMap) {\r\n            // Use extension height from tileMap if available\r\n            extensionHeight = (this.tileMap.extensionHeight || 0) * this.heightStep;\r\n        } else {\r\n            // Fall back to old behavior: derive from terrain type\r\n            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;\r\n            extensionHeight = extensionTerrainType * this.heightStep;\r\n        }\r\n\r\n        // Initialize all points with extension height\r\n        for (let z = 0; z < this.extendedSize; z++) {\r\n            for (let x = 0; x < this.extendedSize; x++) {\r\n                this.heightMapData[z * this.extendedSize + x] = extensionHeight;\r\n            }\r\n        }\r\n\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n\r\n        if (hasHeightMap) {\r\n            // NEW: Use separate heightMap data from tileMap\r\n            const heightData = this.tileMap.heightMap;\r\n\r\n            for (let z = 0; z < heightData.length; z++) {\r\n                for (let x = 0; x < heightData[z].length; x++) {\r\n                    const heightLevel = heightData[z][x];\r\n                    const height = heightLevel * this.heightStep;\r\n\r\n                    // Map terrain coordinates to extended coordinates\r\n                    const extX = x * gridSize + this.extensionSize;\r\n                    const extZ = z * gridSize + this.extensionSize;\r\n\r\n                    // Apply height to a region around this tile\r\n                    const halfGrid = Math.floor(gridSize / 2);\r\n                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {\r\n                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {\r\n                            const finalX = extX + dx;\r\n                            const finalZ = extZ + dz;\r\n\r\n                            if (finalX >= 0 && finalX < this.extendedSize &&\r\n                                finalZ >= 0 && finalZ < this.extendedSize) {\r\n\r\n                                const heightIndex = finalZ * this.extendedSize + finalX;\r\n                                this.heightMapData[heightIndex] = height;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            console.log(`TerrainSystem: Processed height map from separate heightMap data - ${this.extendedSize}x${this.extendedSize}`);\r\n        } else {\r\n            // OLD: Derive heights from terrain types (backwards compatibility)\r\n            const terrainMap = this.tileMap.terrainMap;\r\n\r\n            for (let z = 0; z < terrainMap.length; z++) {\r\n                for (let x = 0; x < terrainMap[z].length; x++) {\r\n                    const terrainType = terrainMap[z][x];\r\n                    const height = terrainType * this.heightStep;\r\n\r\n                    // Map terrain coordinates to extended coordinates\r\n                    const extX = x * gridSize + this.extensionSize;\r\n                    const extZ = z * gridSize + this.extensionSize;\r\n\r\n                    // Apply height to a region around this tile\r\n                    const halfGrid = Math.floor(gridSize / 2);\r\n                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {\r\n                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {\r\n                            const finalX = extX + dx;\r\n                            const finalZ = extZ + dz;\r\n\r\n                            if (finalX >= 0 && finalX < this.extendedSize &&\r\n                                finalZ >= 0 && finalZ < this.extendedSize) {\r\n\r\n                                const heightIndex = finalZ * this.extendedSize + finalX;\r\n                                this.heightMapData[heightIndex] = height;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            console.log(`TerrainSystem: Processed height map from terrain type data (legacy) - ${this.extendedSize}x${this.extendedSize}`);\r\n        }\r\n    }\r\n\r\n    processHeightMapFromCanvas() {\r\n        // This method would be used if running client-side with canvas support\r\n        // For now, fall back to data processing\r\n        this.processHeightMapFromData();\r\n    }\r\n\r\n    getTileMapTerrainType(terrainTypeId){\r\n        if(this.tileMap.terrainTypes.length > terrainTypeId && terrainTypeId >= 0){\r\n            return this.tileMap.terrainTypes[terrainTypeId];\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Get terrain height at world position\r\n     * @param {number} worldX - World X coordinate  \r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {number} Terrain height\r\n     */\r\n    getTerrainHeightAtPosition(worldX, worldZ) {\r\n        // Check if height map is available and enabled\r\n        if (!this.heightMapData || !this.heightMapSettings?.enabled) {\r\n            return 0; // Fallback to flat ground\r\n        }\r\n        \r\n        // Convert world coordinates to height map coordinates\r\n        // The ground is centered at origin, so we need to offset by half the extended size\r\n        const heightMapX = Math.floor(worldX + this.extendedSize / 2);\r\n        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);\r\n        \r\n        // Ensure coordinates are within bounds\r\n        if (heightMapX < 0 || heightMapX >= this.extendedSize || \r\n            heightMapZ < 0 || heightMapZ >= this.extendedSize) {\r\n            // Outside terrain bounds, use extension terrain height\r\n            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;\r\n            return extensionTerrainType * this.heightStep;\r\n        }\r\n        \r\n        // Get height from height map\r\n        const heightIndex = heightMapZ * this.extendedSize + heightMapX;\r\n        return this.heightMapData[heightIndex] || 0;\r\n    }\r\n\r\n    /**\r\n     * Get terrain height with bilinear interpolation for smoother transitions\r\n     * @param {number} worldX - World X coordinate  \r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {number} Smoothly interpolated terrain height\r\n     */\r\n    getTerrainHeightAtPositionSmooth(worldX, worldZ) {\r\n        // Check if height map is available and enabled\r\n        if (!this.heightMapData || !this.heightMapSettings?.enabled) {\r\n            return 0; // Fallback to flat ground\r\n        }\r\n        \r\n        // Convert world coordinates to height map coordinates (with decimal precision)\r\n        const heightMapX = worldX + this.extendedSize / 2;\r\n        const heightMapZ = worldZ + this.extendedSize / 2;\r\n        \r\n        // Get the four surrounding grid points\r\n        const x0 = Math.floor(heightMapX);\r\n        const x1 = x0 + 1;\r\n        const z0 = Math.floor(heightMapZ);\r\n        const z1 = z0 + 1;\r\n        \r\n        // Get fractional parts for interpolation\r\n        const fx = heightMapX - x0;\r\n        const fz = heightMapZ - z0;\r\n        \r\n        // Helper function to get height at specific grid point\r\n        const getHeightAt = (x, z) => {\r\n            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {\r\n                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;\r\n                return extensionTerrainType * this.heightStep;\r\n            }\r\n            const heightIndex = z * this.extendedSize + x;\r\n            return this.heightMapData[heightIndex] || 0;\r\n        };\r\n        \r\n        // Get heights at the four corners\r\n        const h00 = getHeightAt(x0, z0);\r\n        const h10 = getHeightAt(x1, z0);\r\n        const h01 = getHeightAt(x0, z1);\r\n        const h11 = getHeightAt(x1, z1);\r\n        \r\n        // Bilinear interpolation\r\n        const h0 = h00 * (1 - fx) + h10 * fx;\r\n        const h1 = h01 * (1 - fx) + h11 * fx;\r\n        return h0 * (1 - fz) + h1 * fz;\r\n    }\r\n\r\n    /**\r\n     * Get terrain type at world position\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldZ - World Z coordinate  \r\n     * @returns {number|null} Terrain type index, or null if outside bounds\r\n     */\r\n    getTerrainTypeAtPosition(worldX, worldZ) {\r\n        if (!this.tileMap?.terrainMap) {\r\n            return null;\r\n        }\r\n\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n        const terrainMap = this.tileMap.terrainMap;\r\n        \r\n        // Convert world coordinates to terrain grid coordinates\r\n        const terrainX = Math.floor((worldX + this.terrainSize / 2) / gridSize);\r\n        const terrainZ = Math.floor((worldZ + this.terrainSize / 2) / gridSize);\r\n        \r\n        // Check bounds\r\n        if (terrainX < 0 || terrainX >= terrainMap[0]?.length || \r\n            terrainZ < 0 || terrainZ >= terrainMap.length) {\r\n            // Outside terrain bounds, return extension terrain type\r\n            return this.tileMap.extensionTerrainType || 0;\r\n        }\r\n        \r\n        return terrainMap[terrainZ][terrainX];\r\n    }\r\n\r\n    getTerrainTypeAtGridPosition(gridX, gridZ) {\r\n        if (!this.tileMap?.terrainMap) {\r\n            return null;\r\n        }\r\n\r\n        const terrainMap = this.tileMap.terrainMap;\r\n\r\n        if(terrainMap.length <= gridZ || gridZ < 0) {\r\n            return null;\r\n        }\r\n        if(terrainMap[gridZ].length <= gridX || gridX < 0) {\r\n            return null;\r\n        }\r\n\r\n        return terrainMap[gridZ][gridX];\r\n    }\r\n\r\n    /**\r\n     * Get height level at grid position (not the actual height, but the level index)\r\n     * @param {number} gridX - Grid X coordinate\r\n     * @param {number} gridZ - Grid Z coordinate\r\n     * @returns {number|null} Height level (0, 1, 2, etc.), or null if outside bounds\r\n     */\r\n    getHeightLevelAtGridPosition(gridX, gridZ) {\r\n        // If we have a separate heightMap in tileMap, use it\r\n        if (this.tileMap?.heightMap && this.tileMap.heightMap.length > 0) {\r\n            const heightData = this.tileMap.heightMap;\r\n\r\n            if (heightData.length <= gridZ || gridZ < 0) {\r\n                return this.tileMap.extensionHeight || 0;\r\n            }\r\n            if (heightData[gridZ].length <= gridX || gridX < 0) {\r\n                return this.tileMap.extensionHeight || 0;\r\n            }\r\n\r\n            return heightData[gridZ][gridX];\r\n        }\r\n\r\n        // Fall back to old behavior: derive from terrain type\r\n        const terrainType = this.getTerrainTypeAtGridPosition(gridX, gridZ);\r\n        return terrainType !== null ? terrainType : 0;\r\n    }\r\n\r\n    /**\r\n     * Check if a position is within terrain bounds\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {boolean} True if within terrain bounds\r\n     */\r\n    isWithinTerrainBounds(worldX, worldZ) {\r\n        const halfTerrain = this.terrainSize / 2;\r\n        return worldX >= -halfTerrain && worldX <= halfTerrain &&\r\n               worldZ >= -halfTerrain && worldZ <= halfTerrain;\r\n    }\r\n\r\n    /**\r\n     * Check if a position is within extended terrain bounds (including extension)\r\n     * @param {number} worldX - World X coordinate  \r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {boolean} True if within extended terrain bounds\r\n     */\r\n    isWithinExtendedBounds(worldX, worldZ) {\r\n        const halfExtended = this.extendedSize / 2;\r\n        return worldX >= -halfExtended && worldX <= halfExtended &&\r\n               worldZ >= -halfExtended && worldZ <= halfExtended;\r\n    }\r\n\r\n    /**\r\n     * Get terrain information at position including height, type, and bounds checking\r\n     * @param {number} worldX - World X coordinate\r\n     * @param {number} worldZ - World Z coordinate\r\n     * @returns {Object} Terrain info object\r\n     */\r\n    getTerrainInfoAtPosition(worldX, worldZ) {\r\n        return {\r\n            height: this.getTerrainHeightAtPosition(worldX, worldZ),\r\n            heightSmooth: this.getTerrainHeightAtPositionSmooth(worldX, worldZ),\r\n            terrainType: this.getTerrainTypeAtPosition(worldX, worldZ),\r\n            withinBounds: this.isWithinTerrainBounds(worldX, worldZ),\r\n            withinExtendedBounds: this.isWithinExtendedBounds(worldX, worldZ)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Enforce terrain boundaries for movement\r\n     * @param {Object} pos - Position object with x, z properties\r\n     * @param {number} unitRadius - Unit radius for boundary checking\r\n     */\r\n    enforceBoundaries(pos, unitRadius = 25) {\r\n        const halfTerrain = this.terrainSize / 2;\r\n        \r\n        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));\r\n        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));\r\n    }\r\n\r\n    /**\r\n     * Get safe spawn position within terrain bounds\r\n     * @param {number} preferredX - Preferred X coordinate\r\n     * @param {number} preferredZ - Preferred Z coordinate\r\n     * @param {number} unitRadius - Unit radius for boundary checking\r\n     * @returns {Object} Safe position with x, y, z coordinates\r\n     */\r\n    getSafeSpawnPosition(preferredX, preferredZ, unitRadius = 25) {\r\n        const halfTerrain = this.terrainSize / 2;\r\n        \r\n        // Clamp to safe bounds\r\n        const safeX = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredX));\r\n        const safeZ = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredZ));\r\n        \r\n        // Get terrain height at safe position\r\n        const height = this.getTerrainHeightAtPosition(safeX, safeZ);\r\n        \r\n        return {\r\n            x: safeX,\r\n            y: height,\r\n            z: safeZ\r\n        };\r\n    }\r\n\r\n    update() {\r\n        // TerrainSystem is mostly static, minimal update needed\r\n        if (!this.initialized) {\r\n            this.init();\r\n        }\r\n    }\r\n\r\n    destroy() {\r\n        // Clean up resources\r\n        this.heightMapData = null;\r\n        this.heightMapCanvas = null;\r\n        this.heightMapCtx = null;\r\n        \r\n        this.initialized = false;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TerrainSystem.js",
        "fileName": "TerrainSystem"
      },
      "DamageNumberSystem": {
        "script": "class DamageNumberSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game); \r\n        this.game.damageNumberSystem = this;\r\n              \r\n        // Damage number system\r\n        this.damageNumbers = [];\r\n        this.damageNumberPool = [];\r\n        this.maxDamageNumbers = 20;\r\n        \r\n        // Text atlas/sprite approach for damage numbers\r\n        this.damageTextMaterial = null;\r\n        this.damageTextGeometry = null;\r\n        this.damageNumberMesh = null;\r\n        this.activeCharInstances = 0;\r\n        this.VERTICAL_SPEED = 48;\r\n        this.CHAR_SIZE = 12;\r\n        this.effectOffset = { x: 0, y: 0, z: 0 };       \r\n        // Performance tracking\r\n        this.stats = {\r\n            activeDamageNumbers: 0\r\n        };\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('showDamageNumber', this.showDamageNumber.bind(this));\r\n        this.initializeDamageNumberSystem();\r\n    }\r\n    \r\n    initializeDamageNumberSystem() {\r\n        // Create texture atlas with all characters we need\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = 1024;\r\n        canvas.height = 128;\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        // Store canvas for reference\r\n        this.damageTextCanvas = canvas;\r\n        this.damageTextContext = ctx;\r\n        \r\n        // Character set for damage numbers\r\n        this.damageChars = '0123456789,-+!CRITICAL';\r\n        this.charWidth = 64; // Each character is 64px wide\r\n        this.charHeight = 128;\r\n        this.atlasColumns = Math.floor(canvas.width / this.charWidth);\r\n        \r\n        // Draw all characters into the atlas\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n        ctx.font = 'bold 100px monospace';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        \r\n        for (let i = 0; i < this.damageChars.length; i++) {\r\n            const char = this.damageChars[i];\r\n            const x = (i % this.atlasColumns) * this.charWidth + this.charWidth / 2;\r\n            const y = Math.floor(i / this.atlasColumns) * this.charHeight + this.charHeight / 2;\r\n            \r\n            // Draw outline\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.lineWidth = 8;\r\n            ctx.strokeText(char, x, y);\r\n            \r\n            // Draw character (white, we'll tint with vertex colors)\r\n            ctx.fillStyle = '#FFFFFF';\r\n            ctx.fillText(char, x, y);\r\n        }\r\n        \r\n        // Create texture\r\n        this.damageTexture = new THREE.CanvasTexture(canvas);\r\n        this.damageTexture.minFilter = THREE.LinearFilter;\r\n        this.damageTexture.magFilter = THREE.LinearFilter;\r\n        this.damageTexture.needsUpdate = true;\r\n        \r\n        // Create instanced geometry for quads\r\n        // Each damage number can have up to 10 characters\r\n        const maxCharsPerNumber = 10;\r\n        const maxNumbers = 20; // Max simultaneous damage numbers\r\n        const maxInstances = maxNumbers * maxCharsPerNumber;\r\n        \r\n        this.maxDamageNumbers = maxNumbers;\r\n        this.maxDamageChars = maxCharsPerNumber;\r\n        this.maxDamageInstances = maxInstances;\r\n        \r\n        const geometry = new THREE.PlaneGeometry(1, 1);\r\n        this.damageTextGeometry = new THREE.InstancedBufferGeometry().copy(geometry);\r\n        \r\n        // Instance attributes\r\n        const instancePositions = new Float32Array(maxInstances * 3);\r\n        const instanceColors = new Float32Array(maxInstances * 3);\r\n        const instanceOpacities = new Float32Array(maxInstances);\r\n        const instanceScales = new Float32Array(maxInstances * 2);\r\n        const instanceUVOffsets = new Float32Array(maxInstances * 4); // x, y, width, height\r\n        \r\n        this.damageTextGeometry.setAttribute('instancePosition', \r\n            new THREE.InstancedBufferAttribute(instancePositions, 3));\r\n        this.damageTextGeometry.setAttribute('instanceColor', \r\n            new THREE.InstancedBufferAttribute(instanceColors, 3));\r\n        this.damageTextGeometry.setAttribute('instanceOpacity', \r\n            new THREE.InstancedBufferAttribute(instanceOpacities, 1));\r\n        this.damageTextGeometry.setAttribute('instanceScale', \r\n            new THREE.InstancedBufferAttribute(instanceScales, 2));\r\n        this.damageTextGeometry.setAttribute('instanceUVOffset', \r\n            new THREE.InstancedBufferAttribute(instanceUVOffsets, 4));\r\n        \r\n        // Create material with custom shader\r\n        this.damageTextMaterial = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                map: { value: this.damageTexture },\r\n                cameraRight: { value: new THREE.Vector3(1, 0, 0) },\r\n                cameraUp: { value: new THREE.Vector3(0, 1, 0) }\r\n            },\r\n            vertexShader: `\r\n                attribute vec3 instancePosition;\r\n                attribute vec3 instanceColor;\r\n                attribute float instanceOpacity;\r\n                attribute vec2 instanceScale;\r\n                attribute vec4 instanceUVOffset;\r\n                \r\n                uniform vec3 cameraRight;\r\n                uniform vec3 cameraUp;\r\n                \r\n                varying vec2 vUv;\r\n                varying vec3 vColor;\r\n                varying float vOpacity;\r\n                \r\n                void main() {\r\n                    vUv = uv * instanceUVOffset.zw + instanceUVOffset.xy;\r\n                    vColor = instanceColor;\r\n                    vOpacity = instanceOpacity;\r\n                    \r\n                    // For orthographic camera, build billboard in view space\r\n                    vec3 viewRight = normalize((modelViewMatrix * vec4(cameraRight, 0.0)).xyz);\r\n                    vec3 viewUp = normalize((modelViewMatrix * vec4(cameraUp, 0.0)).xyz);\r\n                    \r\n                    vec4 viewPos = modelViewMatrix * vec4(instancePosition, 1.0);\r\n                    viewPos.xyz += viewRight * position.x * instanceScale.x;\r\n                    viewPos.xyz += viewUp * position.y * instanceScale.y;\r\n                    \r\n                    gl_Position = projectionMatrix * viewPos;\r\n                }\r\n            `,\r\n            fragmentShader: `\r\n                uniform sampler2D map;\r\n                \r\n                varying vec2 vUv;\r\n                varying vec3 vColor;\r\n                varying float vOpacity;\r\n                \r\n                void main() {\r\n                    vec4 texColor = texture2D(map, vUv);\r\n                    \r\n                    // Use texture alpha and tint with color\r\n                    gl_FragColor = vec4(vColor * texColor.rgb, texColor.a * vOpacity);\r\n                    \r\n                    if (gl_FragColor.a < 0.01) discard;\r\n                }\r\n            `,\r\n            transparent: true,\r\n            depthWrite: false,\r\n            side: THREE.DoubleSide\r\n        });\r\n        \r\n        this.damageNumberMesh = new THREE.Mesh(this.damageTextGeometry, this.damageTextMaterial);\r\n        this.damageNumberMesh.frustumCulled = false;\r\n        this.game.scene.add(this.damageNumberMesh);\r\n        \r\n        // Initially hide all instances\r\n        this.damageTextGeometry.instanceCount = 0;\r\n        \r\n        // Track active character instances\r\n        this.activeCharInstances = 0;\r\n    }\r\n    \r\n    getCharUVOffset(char) {\r\n        const index = this.damageChars.indexOf(char);\r\n        if (index === -1) return { x: 0, y: 0, width: 0, height: 0 }; // Hide unknown chars\r\n        \r\n        const col = index % this.atlasColumns;\r\n        const row = Math.floor(index / this.atlasColumns);\r\n        \r\n        const uWidth = this.charWidth / this.damageTextCanvas.width;\r\n        const uHeight = this.charHeight / this.damageTextCanvas.height;\r\n        \r\n        return {\r\n            x: col * uWidth,\r\n            y: row * uHeight,\r\n            width: uWidth,\r\n            height: uHeight\r\n        };\r\n    }\r\n    \r\n    showDamageNumber(x, y, z, damage, type = 'physical') {\r\n        console.log('showing damage number', x, y, z, damage, type);\r\n        // Get or create damage number object\r\n        let damageObj = this.damageNumberPool.pop();\r\n        \r\n        if (!damageObj) {\r\n            damageObj = {\r\n                charStartIndex: 0, // Index in instance buffer where this number's chars start\r\n                charCount: 0,\r\n                startTime: 0,\r\n                duration: 1.5,\r\n                startPos: new THREE.Vector3(),\r\n                velocity: new THREE.Vector3(),\r\n                color: new THREE.Color(),\r\n                text: ''\r\n            };\r\n        }\r\n        \r\n        // Setup damage number\r\n        damageObj.text = Math.abs(Math.round(damage)).toString();\r\n        damageObj.charCount = damageObj.text.length;\r\n        damageObj.startTime = this.game.state.now;\r\n        damageObj.startPos.set(x + (Math.random() - 0.5) * 12, y + 10, z + (Math.random() - 0.5) * 12);\r\n        damageObj.velocity.set(\r\n            0, // Slight random horizontal drift\r\n            this.VERTICAL_SPEED, // Initial upward velocity\r\n            0\r\n        );\r\n        \r\n        // Set color based on type\r\n        switch (type) {\r\n            case 'heal':\r\n                damageObj.color.setHex(0x00ff88);\r\n                break;\r\n            case 'critical':\r\n                damageObj.color.setHex(0xff0044);\r\n                damageObj.velocity.y = 12;\r\n                break;\r\n            case 'poison':\r\n                damageObj.color.setHex(0x8a2be2);\r\n                break;\r\n            case 'fire':\r\n                damageObj.color.setHex(0xff4400);\r\n                break;\r\n            case 'cold':\r\n                damageObj.color.setHex(0x00bfff);\r\n                break;\r\n            case 'lightning':\r\n                damageObj.color.setHex(0xffff00);\r\n                break;\r\n            case 'divine':\r\n                damageObj.color.setHex(0xffd700);\r\n                break;\r\n            default:\r\n                damageObj.color.setHex(0xffffff);\r\n        }\r\n        \r\n        // Allocate character instances\r\n        if (this.activeCharInstances + damageObj.charCount > this.maxDamageInstances) {\r\n            // Pool is full, can't show this damage number\r\n            console.warn('Damage number pool full');\r\n            this.damageNumberPool.push(damageObj);\r\n            return;\r\n        }\r\n        \r\n        damageObj.charStartIndex = this.activeCharInstances;\r\n        this.activeCharInstances += damageObj.charCount;\r\n        \r\n        // Add to active list\r\n        this.damageNumbers.push(damageObj);\r\n        \r\n        // Update instance count\r\n        this.damageTextGeometry.instanceCount = this.activeCharInstances;\r\n        \r\n        // Initialize character instances\r\n        this.updateDamageNumberInstance(damageObj, 0);\r\n        \r\n    }\r\n    \r\n    updateDamageNumberInstance(damageObj, progress) {\r\n        if (!this.game.camera) return;\r\n        \r\n        // Calculate position with simple upward motion\r\n        const pos = damageObj.startPos.clone();\r\n        const elapsed = progress * damageObj.duration;\r\n        pos.x += damageObj.velocity.x * elapsed;\r\n        pos.y += damageObj.velocity.y * elapsed;\r\n        pos.z += damageObj.velocity.z * elapsed;\r\n        \r\n        // Calculate opacity with fade out\r\n        let opacity = 1.0;\r\n        if (progress > 0.6) {\r\n            opacity = 1.0 - ((progress - 0.6) / 0.4);\r\n        }\r\n        \r\n        // No scaling - constant size\r\n        const scale = 1.0;\r\n        \r\n        // Character size (world units)\r\n        const charWidth = this.CHAR_SIZE * scale;\r\n        const charHeight = this.CHAR_SIZE * scale * 2;\r\n        \r\n        // Update each character instance\r\n        const positions = this.damageTextGeometry.attributes.instancePosition;\r\n        const colors = this.damageTextGeometry.attributes.instanceColor;\r\n        const opacities = this.damageTextGeometry.attributes.instanceOpacity;\r\n        const scales = this.damageTextGeometry.attributes.instanceScale;\r\n        const uvOffsets = this.damageTextGeometry.attributes.instanceUVOffset;\r\n        \r\n        // Get camera right vector for horizontal spacing\r\n        const camera = this.game.camera;\r\n        const cameraRight = new THREE.Vector3();\r\n        const cameraUp = new THREE.Vector3();\r\n        camera.matrixWorld.extractBasis(cameraRight, cameraUp, new THREE.Vector3());\r\n        \r\n        // Center the entire text string at pos\r\n        const totalWidth = damageObj.charCount * charWidth;\r\n        const startOffset = -totalWidth / 2 + charWidth / 2;\r\n        \r\n        for (let i = 0; i < damageObj.charCount; i++) {\r\n            const instanceIdx = damageObj.charStartIndex + i;\r\n            const char = damageObj.text[i];\r\n            \r\n            // Position each character along camera right vector, centered\r\n            const offset = startOffset + i * charWidth;\r\n            const charPos = pos.clone().add(cameraRight.clone().multiplyScalar(offset));\r\n            positions.setXYZ(instanceIdx, charPos.x, charPos.y, charPos.z);\r\n            \r\n            // Color\r\n            colors.setXYZ(instanceIdx, damageObj.color.r, damageObj.color.g, damageObj.color.b);\r\n            \r\n            // Opacity\r\n            opacities.setX(instanceIdx, opacity);\r\n            \r\n            // Scale\r\n            scales.setXY(instanceIdx, charWidth, charHeight);\r\n            \r\n            // UV offset for this character\r\n            const uvOffset = this.getCharUVOffset(char);\r\n            uvOffsets.setXYZW(instanceIdx, uvOffset.x, uvOffset.y, uvOffset.width, uvOffset.height);\r\n        }\r\n        \r\n        positions.needsUpdate = true;\r\n        colors.needsUpdate = true;\r\n        opacities.needsUpdate = true;\r\n        scales.needsUpdate = true;\r\n        uvOffsets.needsUpdate = true;\r\n    }\r\n    \r\n    updateDamageNumbers() {\r\n        if (!this.game.state || this.damageNumbers.length === 0 || !this.game.camera) return;\r\n        console.log('update');\r\n        // Update camera vectors for billboarding\r\n        const camera = this.game.camera;\r\n        const cameraRight = new THREE.Vector3();\r\n        const cameraUp = new THREE.Vector3();\r\n        \r\n        camera.matrixWorld.extractBasis(cameraRight, cameraUp, new THREE.Vector3());\r\n        \r\n        this.damageTextMaterial.uniforms.cameraRight.value.copy(cameraRight);\r\n        this.damageTextMaterial.uniforms.cameraUp.value.copy(cameraUp);\r\n        \r\n        const currentTime = this.game.state.now;\r\n        const toRemove = [];\r\n        \r\n        for (let i = 0; i < this.damageNumbers.length; i++) {\r\n            const damageObj = this.damageNumbers[i];\r\n            const elapsed = currentTime - damageObj.startTime;\r\n            const progress = elapsed / damageObj.duration;\r\n            \r\n            if (progress >= 1) {\r\n                toRemove.push(i);\r\n                continue;\r\n            }\r\n            \r\n            this.updateDamageNumberInstance(damageObj, progress);\r\n        }\r\n        \r\n        // Remove completed damage numbers (backwards to maintain indices)\r\n        for (let i = toRemove.length - 1; i >= 0; i--) {\r\n            const idx = toRemove[i];\r\n            const damageObj = this.damageNumbers[idx];\r\n            \r\n            // Free up character instances\r\n            const charsToRemove = damageObj.charCount;\r\n            const startIdx = damageObj.charStartIndex;\r\n            \r\n            // Shift all subsequent characters back in the buffer\r\n            if (startIdx + charsToRemove < this.activeCharInstances) {\r\n                const positions = this.damageTextGeometry.attributes.instancePosition;\r\n                const colors = this.damageTextGeometry.attributes.instanceColor;\r\n                const opacities = this.damageTextGeometry.attributes.instanceOpacity;\r\n                const scales = this.damageTextGeometry.attributes.instanceScale;\r\n                const uvOffsets = this.damageTextGeometry.attributes.instanceUVOffset;\r\n                \r\n                for (let j = startIdx + charsToRemove; j < this.activeCharInstances; j++) {\r\n                    const sourceIdx = j;\r\n                    const destIdx = j - charsToRemove;\r\n                    \r\n                    // Copy position\r\n                    positions.setXYZ(destIdx, \r\n                        positions.getX(sourceIdx),\r\n                        positions.getY(sourceIdx),\r\n                        positions.getZ(sourceIdx)\r\n                    );\r\n                    \r\n                    // Copy color\r\n                    colors.setXYZ(destIdx,\r\n                        colors.getX(sourceIdx),\r\n                        colors.getY(sourceIdx),\r\n                        colors.getZ(sourceIdx)\r\n                    );\r\n                    \r\n                    // Copy opacity\r\n                    opacities.setX(destIdx, opacities.getX(sourceIdx));\r\n                    \r\n                    // Copy scale\r\n                    scales.setXY(destIdx,\r\n                        scales.getX(sourceIdx),\r\n                        scales.getY(sourceIdx)\r\n                    );\r\n                    \r\n                    // Copy UV offset\r\n                    uvOffsets.setXYZW(destIdx,\r\n                        uvOffsets.getX(sourceIdx),\r\n                        uvOffsets.getY(sourceIdx),\r\n                        uvOffsets.getZ(sourceIdx),\r\n                        uvOffsets.getW(sourceIdx)\r\n                    );\r\n                }\r\n                \r\n                positions.needsUpdate = true;\r\n                colors.needsUpdate = true;\r\n                opacities.needsUpdate = true;\r\n                scales.needsUpdate = true;\r\n                uvOffsets.needsUpdate = true;\r\n            }\r\n            \r\n            this.activeCharInstances -= charsToRemove;\r\n            \r\n            // Update indices for remaining damage numbers\r\n            for (let j = idx + 1; j < this.damageNumbers.length; j++) {\r\n                this.damageNumbers[j].charStartIndex -= charsToRemove;\r\n            }\r\n            \r\n            // Return to pool\r\n            this.damageNumberPool.push(damageObj);\r\n            \r\n            // Remove from active array\r\n            this.damageNumbers.splice(idx, 1);\r\n        }\r\n        \r\n        // Update instance count\r\n        this.damageTextGeometry.instanceCount = this.activeCharInstances;\r\n        this.stats.activeDamageNumbers = this.damageNumbers.length;\r\n    }\r\n    \r\n    // Keep all existing particle and screen effect methods unchanged\r\n    getEffectConfig(effectType) {\r\n        const configs = {\r\n            victory: {\r\n                count: 5,\r\n                shape: 'star',\r\n                color: 0x00ff00,\r\n                colorRange: { start: 0x00ff00, end: 0xffff00 },\r\n                lifetime: 1.5,\r\n                velocity: { speed: 8, spread: 0.5, pattern: 'burst' },\r\n                scale: 2,\r\n                scaleVariation: 0.3,\r\n                physics: { gravity: -0.5, drag: 0.99 },\r\n                rotation: { enabled: true, speed: 5 },\r\n                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n            },\r\n            defeat: {\r\n                count: 8,\r\n                shape: 'spark',\r\n                color: 0xff0000,\r\n                colorRange: { start: 0xff0000, end: 0x440000 },\r\n                lifetime: 2,\r\n                velocity: { speed: 6, spread: 0.8, pattern: 'burst' },\r\n                scale: 1.5,\r\n                scaleVariation: 0.4,\r\n                physics: { gravity: 0.3, drag: 0.95 },\r\n                rotation: { enabled: true, speed: 3 },\r\n                visual: { fadeOut: true, scaleOverTime: false, blending: 'normal' }\r\n            },\r\n            levelup: {\r\n                count: 12,\r\n                shape: 'glow',\r\n                color: 0xffaa00,\r\n                colorRange: { start: 0xffaa00, end: 0xffffff },\r\n                lifetime: 2.5,\r\n                velocity: { speed: 4, spread: 0.3, pattern: 'fountain' },\r\n                scale: 3,\r\n                scaleVariation: 0.2,\r\n                physics: { gravity: -0.2, drag: 0.98 },\r\n                rotation: { enabled: false },\r\n                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }\r\n            }\r\n        };\r\n        \r\n        return configs[effectType] || configs.victory;\r\n    }\r\n        \r\n    getDamageColor(type) {\r\n        switch (type) {\r\n            case 'heal': return 0x00ff88;\r\n            case 'critical': return 0xff0044;\r\n            case 'poison': return 0x8a2be2;\r\n            case 'fire': return 0xff4400;\r\n            case 'cold': return 0x00bfff;\r\n            case 'lightning': return 0xffff00;\r\n            case 'divine': return 0xffd700;\r\n            default: return 0xff4444;\r\n        }\r\n    }\r\n        \r\n    // Main update method called by game loop\r\n    update() {\r\n        this.updateDamageNumbers();\r\n    }\r\n\r\n    destroy() {\r\n        // Clean up damage number system\r\n        if (this.damageNumberMesh) {\r\n            this.game.scene.remove(this.damageNumberMesh);\r\n            this.damageTextGeometry.dispose();\r\n            this.damageTextMaterial.dispose();\r\n            this.damageTexture.dispose();\r\n        }\r\n\r\n    }\r\n\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageNumberSystem.js",
        "fileName": "DamageNumberSystem"
      },
      "StatisticsTrackingSystem": {
        "script": "class StatisticsTrackingSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.statisticsTrackingSystem = this;\r\n        this.gameStartTime = null;\r\n        this.battleStartTime = null;\r\n        this.battleEndTime = null;\r\n        this.sessionStats = {\r\n            gamesPlayed: 0, totalWins: 0, totalLosses: 0,\r\n            bestRound: 0, totalGoldEarned: 0, totalPlayTime: 0\r\n        };\r\n        \r\n        this.loadSessionStats();\r\n    }\r\n    \r\n    startSession() {\r\n        this.gameStartTime = Date.now();\r\n    }\r\n    \r\n    recordBattleStart() {\r\n        this.battleStartTime = Date.now();\r\n    }\r\n    \r\n    recordBattleEnd() {\r\n        this.battleEndTime = Date.now();\r\n    }\r\n    \r\n    collectStats() {\r\n        return {\r\n            round: this.game.state?.round || 1,\r\n            goldEarned: this.game.state?.playerGold || 0,\r\n            unitsDeployed: this.getUnitsDeployed(),\r\n            unitsLost: this.getUnitsLost(),\r\n            unitsRemaining: this.getUnitsRemaining(),\r\n            battleDuration: this.getBattleDuration(),\r\n            efficiency: this.calculateEfficiency(),\r\n            armyValue: this.calculateArmyValue()\r\n        };\r\n    }\r\n    \r\n    getUnitsDeployed() {\r\n        try {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const playerUnits = this.game.getEntitiesWith(ComponentTypes.TEAM, ComponentTypes.UNIT_TYPE) || [];\r\n            \r\n            return playerUnits.filter(entityId => {\r\n                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n                return team?.team === 'player';\r\n            }).length;\r\n        } catch (error) {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    getUnitsRemaining() {\r\n        try {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const alivePlayerUnits = this.game.getEntitiesWith(\r\n                ComponentTypes.TEAM, ComponentTypes.HEALTH, ComponentTypes.UNIT_TYPE\r\n            ) || [];\r\n            \r\n            return alivePlayerUnits.filter(entityId => {\r\n                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);\r\n                return team?.team === 'player' && health?.current > 0;\r\n            }).length;\r\n        } catch (error) {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    getUnitsLost() {\r\n        return Math.max(0, this.getUnitsDeployed() - this.getUnitsRemaining());\r\n    }\r\n    \r\n    getBattleDuration() {\r\n        if (this.battleStartTime && this.battleEndTime) {\r\n            return this.battleEndTime - this.battleStartTime;\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    calculateEfficiency() {\r\n        const deployed = this.getUnitsDeployed();\r\n        const remaining = this.getUnitsRemaining();\r\n        return deployed > 0 ? Math.round((remaining / deployed) * 100) : 100;\r\n    }\r\n    \r\n    calculateArmyValue() {\r\n        try {\r\n            const ComponentTypes = this.game.componentManager.getComponentTypes();\r\n            const playerUnits = this.game.getEntitiesWith(ComponentTypes.TEAM, ComponentTypes.UNIT_TYPE) || [];\r\n            \r\n            return playerUnits.reduce((total, entityId) => {\r\n                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);\r\n                const unitType = this.game.getComponent(entityId, ComponentTypes.UNIT_TYPE);\r\n                \r\n                if (team?.team === 'player' && unitType?.value) {\r\n                    return total + unitType.value;\r\n                }\r\n                return total;\r\n            }, 0);\r\n        } catch (error) {\r\n            return 0;\r\n        }\r\n    }\r\n    \r\n    update() {\r\n        // Update enhanced stats display\r\n        const efficiency = this.calculateEfficiency();\r\n        const armyValue = this.calculateArmyValue();\r\n        \r\n        const efficiencyElement = document.getElementById('armyEfficiency');\r\n        if (efficiencyElement) {\r\n            efficiencyElement.textContent = `${efficiency}%`;\r\n            efficiencyElement.className = efficiency > 80 ? 'stat-good' : efficiency > 60 ? 'stat-ok' : 'stat-poor';\r\n        }\r\n        \r\n        const valueElement = document.getElementById('armyValue');\r\n        if (valueElement) {\r\n            valueElement.textContent = `${armyValue}g`;\r\n        }\r\n    }\r\n    \r\n    updateSession(result, stats) {\r\n        this.sessionStats.gamesPlayed++;\r\n        \r\n        if (result === 'victory') {\r\n            this.sessionStats.totalWins++;\r\n            this.sessionStats.bestRound = Math.max(this.sessionStats.bestRound, stats.round);\r\n        } else {\r\n            this.sessionStats.totalLosses++;\r\n        }\r\n        \r\n        this.sessionStats.totalGoldEarned += stats.goldEarned || 0;\r\n        this.sessionStats.totalPlayTime += stats.battleDuration || 0;\r\n        \r\n        this.saveSessionStats();\r\n    }\r\n    \r\n    loadSessionStats() {\r\n        try {\r\n            const saved = localStorage.getItem('autoBattleArena_sessionStats');\r\n            if (saved) {\r\n                Object.assign(this.sessionStats, JSON.parse(saved));\r\n            }\r\n        } catch (error) {\r\n            console.warn('Could not load session stats:', error);\r\n        }\r\n    }\r\n    \r\n    saveSessionStats() {\r\n        try {\r\n            localStorage.setItem('autoBattleArena_sessionStats', JSON.stringify(this.sessionStats));\r\n        } catch (error) {\r\n            console.warn('Could not save session stats:', error);\r\n        }\r\n    }\r\n    \r\n    getSessionStats() {\r\n        return { ...this.sessionStats };\r\n    }\r\n\r\n    resetSession() {\r\n        \r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/StatisticsTrackingSystem.js",
        "fileName": "StatisticsTrackingSystem"
      },
      "MovementSystem": {
        "script": "class MovementSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.movementSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n        \r\n        this.DEFAULT_UNIT_RADIUS = 25;\r\n        this.MIN_MOVEMENT_THRESHOLD = 0.1;\r\n        \r\n        this.AI_SPEED_MULTIPLIER = 0.1;\r\n        this.DEFAULT_AI_SPEED = 50;\r\n        this.POSITION_UPDATE_MULTIPLIER = 1;\r\n        this.DEFAULT_TERRAIN_SIZE = 768 * 2;\r\n        \r\n        this.GRAVITY = 200;\r\n        this.GROUND_LEVEL = 0;\r\n        this.GROUND_IMPACT_THRESHOLD = 5;\r\n        this.TERRAIN_FOLLOW_SPEED = 8;\r\n        \r\n        this.SEPARATION_FORCE = 80;\r\n        this.SEPARATION_RADIUS_MULTIPLIER = 0.1;\r\n        this.MAX_SEPARATION_CHECKS = 8;\r\n        this.AVOIDANCE_SMOOTHING = 0.15;\r\n        \r\n        this.PATHFINDING_LOOKAHEAD = 100;\r\n        this.OBSTACLE_AVOIDANCE_FORCE = 70;\r\n        this.AVOIDANCE_ANGLE = Math.PI / 3;\r\n        this.STUCK_THRESHOLD = 5;\r\n        this.STUCK_TIME_LIMIT = 2000;\r\n        this.REPATH_DISTANCE = 50;\r\n        \r\n        this.PATH_REACHED_DISTANCE = 3;\r\n        this.PATH_REREQUEST_INTERVAL = 0.5;\r\n        \r\n        this.SPATIAL_GRID_SIZE = 80;\r\n        this.MAX_PATHFINDING_CHECKS = 6;\r\n        this.PATHFINDING_CHECK_POINTS = 3;\r\n        this.PATHFINDING_UPDATE_INTERVAL = 3;\r\n        this.NEAR_UNIT_RADIUS = 150;\r\n        \r\n        this.VELOCITY_SMOOTHING = 0.9;\r\n        this.DIRECTION_SMOOTHING = 0.9;\r\n        this.FORCE_DAMPING = 0.85;\r\n        this.MIN_DIRECTION_CHANGE = 0.1;\r\n        this.OSCILLATION_DETECTION_FRAMES = 5;\r\n        this.OSCILLATION_THRESHOLD = Math.PI / 6;\r\n        \r\n        this.unitStates = new Map();\r\n        this.frameCounter = 0;\r\n        this.pathfindingQueue = [];\r\n        this.pathfindingQueueIndex = 0;\r\n        \r\n        this.movementHistory = new Map();\r\n    }\r\n    \r\n    update() {\r\n        if (this.game.state.phase !== 'battle') return;\r\n        \r\n        this.frameCounter++;\r\n        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.VELOCITY);        \r\n        \r\n        const unitData = new Map();\r\n        \r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);\r\n            const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);\r\n            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);\r\n            \r\n            if (!projectile) {\r\n                const unitRadius = this.getUnitRadius(collision);\r\n\r\n                const isAnchored = vel.anchored ||\r\n                    (!!aiState &&\r\n                    (aiState.state === 'attacking' || aiState.state === 'waiting') &&\r\n                    aiState.aiBehavior &&\r\n                    !!aiState.target);\r\n\r\n                unitData.set(entityId, {\r\n                    pos, vel, unitType, collision, aiState, projectile,\r\n                    unitRadius,\r\n                    isAnchored,\r\n                    desiredVelocity: { vx: 0, vy: 0, vz: 0 },\r\n                    separationForce: { x: 0, y: 0, z: 0 },\r\n                    avoidanceForce: { x: 0, y: 0, z: 0 }\r\n                });\r\n                \r\n                this.updateUnitState(entityId, pos, vel);\r\n                this.updateMovementHistory(entityId, vel);\r\n            }\r\n        });\r\n        \r\n        const sortedEntityIds = Array.from(unitData.keys());\r\n\r\n        sortedEntityIds.forEach((entityId) => {\r\n            this.calculateDesiredVelocity(entityId, unitData.get(entityId));\r\n        });\r\n        \r\n        sortedEntityIds.forEach((entityId) => {\r\n            this.calculateSeparationForceOptimized(entityId, unitData.get(entityId));\r\n        });\r\n        \r\n        this.updatePathfindingStaggered(unitData);\r\n        \r\n        entities.forEach(entityId => {\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);\r\n            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);\r\n            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            \r\n            const isAffectedByGravity = vel.affectedByGravity;\r\n            \r\n            if (!projectile && unitData.has(entityId)) {\r\n                let entityData = unitData.get(entityId);\r\n                if(vel.vx != 0 || vel.vz != 0 || entityData.desiredVelocity.vx != 0 || entityData.desiredVelocity.vz != 0){\r\n                    this.applyUnitMovementWithSmoothing(entityId, unitData.get(entityId));\r\n                }\r\n            }\r\n            \r\n            if (isAffectedByGravity) {\r\n                vel.vy -= this.GRAVITY * this.game.state.deltaTime;\r\n            }\r\n            \r\n            pos.x += vel.vx * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;\r\n            pos.y += vel.vy * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;\r\n            pos.z += vel.vz * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;\r\n      \r\n            if(!projectile){\r\n                this.handleGroundInteraction(pos, vel);\r\n                if(!vel.anchored){\r\n                    this.enforceBoundaries(pos, collision);\r\n                }\r\n                 \r\n                this.game.triggerEvent(\"onEntityPositionUpdated\", entityId);\r\n            }\r\n        });\r\n    }\r\n    \r\n    updateMovementHistory(entityId, vel) {\r\n        if (!this.movementHistory.has(entityId)) {\r\n            this.movementHistory.set(entityId, {\r\n                velocityHistory: [],\r\n                smoothedDirection: { x: 0, z: 0 },\r\n                dampedForces: { separation: { x: 0, z: 0 }, avoidance: { x: 0, z: 0 } }\r\n            });\r\n        }\r\n        \r\n        const history = this.movementHistory.get(entityId);\r\n        \r\n        history.velocityHistory.push({ \r\n            vx: vel.vx, \r\n            vz: vel.vz, \r\n            frame: this.frameCounter \r\n        });\r\n        \r\n        if (history.velocityHistory.length > this.OSCILLATION_DETECTION_FRAMES) {\r\n            history.velocityHistory.shift();\r\n        }\r\n    }\r\n    \r\n    isUnitOscillating(entityId) {\r\n        const history = this.movementHistory.get(entityId);\r\n        if (!history || history.velocityHistory.length < this.OSCILLATION_DETECTION_FRAMES) {\r\n            return false;\r\n        }\r\n        \r\n        let directionChanges = 0;\r\n        let lastDirection = null;\r\n        \r\n        for (const vel of history.velocityHistory) {\r\n            const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);\r\n            if (speed < 0.1) continue;\r\n            \r\n            const direction = Math.atan2(vel.vz, vel.vx);\r\n            if (lastDirection !== null) {\r\n                let angleDiff = Math.abs(direction - lastDirection);\r\n                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;\r\n                \r\n                if (angleDiff > this.OSCILLATION_THRESHOLD) {\r\n                    directionChanges++;\r\n                }\r\n            }\r\n            lastDirection = direction;\r\n        }\r\n        \r\n        return directionChanges >= 2;\r\n    }\r\n    \r\n    updatePathfindingStaggered(unitData) {\r\n        if (this.pathfindingQueue.length === 0) {\r\n            const sortedEntityIds = Array.from(unitData.keys()).sort((a, b) => String(a).localeCompare(String(b)));\r\n            sortedEntityIds.forEach(entityId => {\r\n                const data = unitData.get(entityId);\r\n                if (data.aiState?.state === 'chasing') {\r\n                    this.pathfindingQueue.push(entityId);\r\n                }\r\n            });\r\n        }\r\n        \r\n        const unitsPerFrame = Math.max(1, Math.ceil(this.pathfindingQueue.length / this.PATHFINDING_UPDATE_INTERVAL));\r\n        \r\n        for (let i = 0; i < unitsPerFrame && this.pathfindingQueueIndex < this.pathfindingQueue.length; i++) {\r\n            const entityId = this.pathfindingQueue[this.pathfindingQueueIndex];\r\n            if (unitData.has(entityId)) {\r\n                this.calculatePathfindingAvoidanceOptimized(entityId, unitData.get(entityId), unitData);\r\n            }\r\n            this.pathfindingQueueIndex++;\r\n        }\r\n        \r\n        if (this.pathfindingQueueIndex >= this.pathfindingQueue.length) {\r\n            this.pathfindingQueueIndex = 0;\r\n            this.pathfindingQueue = [];\r\n        }\r\n    }\r\n    \r\n    updateUnitState(entityId, pos, vel) {\r\n        const currentTime = this.game.state.now;\r\n        \r\n        if (!this.unitStates.has(entityId)) {\r\n            this.unitStates.set(entityId, {\r\n                lastPosition: { x: pos.x, z: pos.z },\r\n                lastMovementTime: currentTime,\r\n                stuckTime: 0,\r\n                lastPathTime: 0,\r\n                avoidanceDirection: 0\r\n            });\r\n            return;\r\n        }\r\n        \r\n        const state = this.unitStates.get(entityId);\r\n        const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);\r\n        const distanceMoved = Math.sqrt(\r\n            Math.pow(pos.x - state.lastPosition.x, 2) + \r\n            Math.pow(pos.z - state.lastPosition.z, 2)\r\n        );\r\n        \r\n        if (speed < this.STUCK_THRESHOLD && distanceMoved < 1) {\r\n            state.stuckTime += this.game.state.deltaTime;\r\n        } else {\r\n            state.stuckTime = 0;\r\n            state.lastPosition.x = pos.x;\r\n            state.lastPosition.z = pos.z;\r\n        }\r\n        \r\n        if (distanceMoved > this.REPATH_DISTANCE) {\r\n            state.avoidanceDirection = 0;\r\n            state.lastPathTime = currentTime;\r\n        }\r\n    }\r\n    \r\n    calculateSeparationForceOptimized(entityId, data) {\r\n        const { pos, unitRadius, isAnchored } = data;\r\n\r\n        if (isAnchored) {\r\n            data.separationForce.x = 0;\r\n            data.separationForce.y = 0;\r\n            data.separationForce.z = 0;\r\n            return;\r\n        }\r\n        \r\n        const separationRadius = unitRadius * this.SEPARATION_RADIUS_MULTIPLIER;\r\n        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, separationRadius, entityId);\r\n        \r\n        let separationForceX = 0;\r\n        let separationForceZ = 0;\r\n        let neighborCount = 0;\r\n        let checksPerformed = 0;\r\n        \r\n        for (const otherEntityId of nearbyUnits) {\r\n            if (checksPerformed >= this.MAX_SEPARATION_CHECKS) break;\r\n            \r\n            checksPerformed++;\r\n            \r\n            const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);\r\n            const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);\r\n            \r\n            if (!otherPos) continue;\r\n            \r\n            const otherRadius = this.getUnitRadius(otherCollision);\r\n            \r\n            const dx = pos.x - otherPos.x;\r\n            const dz = pos.z - otherPos.z;\r\n            const distance = Math.sqrt(dx * dx + dz * dz);\r\n            \r\n            const minDistance = unitRadius + otherRadius;\r\n            const influenceDistance = Math.max(minDistance, separationRadius);\r\n            \r\n            if (distance < influenceDistance && distance > 0.1) {\r\n                const force = this.SEPARATION_FORCE * (influenceDistance - distance) / influenceDistance;\r\n                \r\n                const dirX = dx / distance;\r\n                const dirZ = dz / distance;\r\n                \r\n                separationForceX += dirX * force;\r\n                separationForceZ += dirZ * force;\r\n                neighborCount++;\r\n            }\r\n        }\r\n        \r\n        if (neighborCount > 0) {\r\n            const history = this.movementHistory.get(entityId);\r\n            if (history) {\r\n                const dampedSeparation = history.dampedForces.separation;\r\n                dampedSeparation.x *= this.FORCE_DAMPING;\r\n                dampedSeparation.z *= this.FORCE_DAMPING;\r\n                \r\n                separationForceX = (separationForceX / neighborCount) * 0.7 + dampedSeparation.x * 0.3;\r\n                separationForceZ = (separationForceZ / neighborCount) * 0.7 + dampedSeparation.z * 0.3;\r\n                \r\n                dampedSeparation.x = separationForceX;\r\n                dampedSeparation.z = separationForceZ;\r\n            } else {\r\n                separationForceX /= neighborCount;\r\n                separationForceZ /= neighborCount;\r\n            }\r\n        }\r\n        \r\n        data.separationForce.x = separationForceX;\r\n        data.separationForce.z = separationForceZ;\r\n    }\r\n    \r\n    calculatePathfindingAvoidanceOptimized(entityId, data, allUnitData) {\r\n        const { pos, vel, aiState, unitRadius, isAnchored } = data;\r\n\r\n        if (isAnchored || !aiState || aiState.state !== 'chasing') {\r\n            data.avoidanceForce.x = 0;\r\n            data.avoidanceForce.z = 0;\r\n            return;\r\n        }\r\n        \r\n        let targetPos = aiState.targetPosition;\r\n        const targetEntityId = aiState.target;\r\n\r\n        if(targetEntityId){\r\n            targetPos = this.game.getComponent(targetEntityId, this.componentTypes.POSITION);\r\n        }\r\n        \r\n        if (!targetPos) {\r\n            data.avoidanceForce.x = 0;\r\n            data.avoidanceForce.z = 0;\r\n            return;\r\n        }\r\n        \r\n        const desiredDirection = {\r\n            x: targetPos.x - pos.x,\r\n            z: targetPos.z - pos.z\r\n        };\r\n        \r\n        const desiredDistance = Math.sqrt(desiredDirection.x * desiredDirection.x + desiredDirection.z * desiredDirection.z);\r\n        \r\n        if (desiredDistance < 0.1) {\r\n            data.avoidanceForce.x = 0;\r\n            data.avoidanceForce.z = 0;\r\n            return;\r\n        }\r\n        \r\n        desiredDirection.x /= desiredDistance;\r\n        desiredDirection.z /= desiredDistance;\r\n        \r\n        const obstacleInfo = this.findObstaclesInPathOptimized(pos, desiredDirection, unitRadius, entityId, targetEntityId);\r\n        \r\n        if (obstacleInfo.hasObstacle) {\r\n            const unitState = this.unitStates.get(entityId);\r\n            const avoidanceForce = this.calculateAvoidanceVector(\r\n                pos, desiredDirection, obstacleInfo, unitState, unitRadius\r\n            );\r\n            \r\n            const history = this.movementHistory.get(entityId);\r\n            if (history) {\r\n                const dampedAvoidance = history.dampedForces.avoidance;\r\n                dampedAvoidance.x *= this.FORCE_DAMPING;\r\n                dampedAvoidance.z *= this.FORCE_DAMPING;\r\n                \r\n                const blendedX = avoidanceForce.x * 0.6 + dampedAvoidance.x * 0.4;\r\n                const blendedZ = avoidanceForce.z * 0.6 + dampedAvoidance.z * 0.4;\r\n                \r\n                dampedAvoidance.x = blendedX;\r\n                dampedAvoidance.z = blendedZ;\r\n                \r\n                data.avoidanceForce.x = blendedX;\r\n                data.avoidanceForce.z = blendedZ;\r\n            } else {\r\n                data.avoidanceForce.x = avoidanceForce.x;\r\n                data.avoidanceForce.z = avoidanceForce.z;\r\n            }\r\n        } else {\r\n            data.avoidanceForce.x = 0;\r\n            data.avoidanceForce.z = 0;\r\n        }\r\n    }\r\n    \r\n    findObstaclesInPathOptimized(pos, direction, unitRadius, entityId, targetEntityId = null) {\r\n        const lookaheadDistance = this.PATHFINDING_LOOKAHEAD;\r\n        const checkRadius = unitRadius * 1.5;\r\n        \r\n        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, lookaheadDistance + checkRadius, entityId);\r\n        \r\n        let closestObstacle = null;\r\n        let closestDistance = Infinity;\r\n        let checksPerformed = 0;\r\n        \r\n        for (let i = 1; i <= this.PATHFINDING_CHECK_POINTS; i++) {\r\n            const checkDistance = (lookaheadDistance / this.PATHFINDING_CHECK_POINTS) * i;\r\n            const checkPos = {\r\n                x: pos.x + direction.x * checkDistance,\r\n                z: pos.z + direction.z * checkDistance\r\n            };\r\n            \r\n            for (const otherEntityId of nearbyUnits) {\r\n                if (targetEntityId && otherEntityId === targetEntityId) continue;\r\n                if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;\r\n                \r\n                checksPerformed++;\r\n                \r\n                const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);\r\n                const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);\r\n                \r\n                if (!otherPos) continue;\r\n                \r\n                const otherRadius = this.getUnitRadius(otherCollision);\r\n                \r\n                const dx = checkPos.x - otherPos.x;\r\n                const dz = checkPos.z - otherPos.z;\r\n                const distance = Math.sqrt(dx * dx + dz * dz);\r\n                const minDistance = checkRadius + otherRadius;\r\n                \r\n                if (distance < minDistance && distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestObstacle = {\r\n                        pos: otherPos,\r\n                        radius: otherRadius,\r\n                        distance: distance,\r\n                        entityId: otherEntityId\r\n                    };\r\n                }\r\n            }\r\n            \r\n            if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;\r\n        }\r\n        \r\n        return {\r\n            hasObstacle: closestObstacle !== null,\r\n            obstacle: closestObstacle\r\n        };\r\n    }\r\n    \r\n    calculateAvoidanceVector(pos, desiredDirection, obstacleInfo, unitState, unitRadius) {\r\n        if (!obstacleInfo.hasObstacle) {\r\n            return { x: 0, z: 0 };\r\n        }\r\n        \r\n        const obstacle = obstacleInfo.obstacle;\r\n        const toObstacle = {\r\n            x: obstacle.pos.x - pos.x,\r\n            z: obstacle.pos.z - pos.z\r\n        };\r\n        \r\n        const obstacleDistance = Math.sqrt(toObstacle.x * toObstacle.x + toObstacle.z * toObstacle.z);\r\n        \r\n        if (obstacleDistance < 0.1) {\r\n            return { x: 0, z: 0 };\r\n        }\r\n        \r\n        toObstacle.x /= obstacleDistance;\r\n        toObstacle.z /= obstacleDistance;\r\n        \r\n        let avoidanceDirection = unitState?.avoidanceDirection || 0;\r\n        \r\n        if (avoidanceDirection === 0) {\r\n            const perpLeft = { x: -toObstacle.z, z: toObstacle.x };\r\n            const perpRight = { x: toObstacle.z, z: -toObstacle.x };\r\n            \r\n            const leftAlignment = perpLeft.x * desiredDirection.x + perpLeft.z * desiredDirection.z;\r\n            const rightAlignment = perpRight.x * desiredDirection.x + perpRight.z * desiredDirection.z;\r\n            \r\n            avoidanceDirection = leftAlignment > rightAlignment ? 1 : -1;\r\n            \r\n            if (unitState) {\r\n                unitState.avoidanceDirection = avoidanceDirection;\r\n            }\r\n        }\r\n        \r\n        const avoidanceVector = {\r\n            x: -toObstacle.z * avoidanceDirection,\r\n            z: toObstacle.x * avoidanceDirection\r\n        };\r\n        \r\n        const minDistance = unitRadius + obstacle.radius + 10;\r\n        const avoidanceStrength = Math.max(0, (minDistance - obstacleDistance) / minDistance);\r\n        const force = this.OBSTACLE_AVOIDANCE_FORCE * avoidanceStrength;\r\n        \r\n        return {\r\n            x: avoidanceVector.x * force,\r\n            z: avoidanceVector.z * force\r\n        };\r\n    }\r\n    \r\n    calculateDesiredVelocity(entityId, data) {\r\n        const { pos, vel, aiState, isAnchored } = data;\r\n\r\n        if (isAnchored || !aiState) {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            data.desiredVelocity.vz = 0;\r\n            return;\r\n        }\r\n        \r\n        if (aiState.state === 'waiting' || aiState.state === 'idle') {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            data.desiredVelocity.vz = 0;\r\n            return;\r\n        }\r\n        \r\n        if (aiState.state === 'chasing' && aiState.aiBehavior && (aiState.targetPosition || aiState.target)) {\r\n            // Check if we should use direct movement (line of sight to target)\r\n            if (aiState.useDirectMovement) {\r\n                // Move directly toward target using steering behaviors\r\n                this.moveDirectlyToTarget(entityId, data);\r\n            } else {\r\n                // Use pathfinding for navigation\r\n                this.requestPathIfNeeded(entityId, data);\r\n\r\n                if (aiState.path && aiState.path.length > 0) {\r\n                    this.followPath(entityId, data);\r\n                } else {\r\n                    data.desiredVelocity.vx = 0;\r\n                    data.desiredVelocity.vy = 0;\r\n                    data.desiredVelocity.vz = 0;\r\n                }\r\n            }\r\n        } else if (aiState.state === 'attacking') {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            data.desiredVelocity.vz = 0;\r\n        } else {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            data.desiredVelocity.vz = 0;\r\n        }\r\n    }\r\n    \r\n    moveDirectlyToTarget(entityId, data) {\r\n        const { pos, vel, aiState } = data;\r\n\r\n        let targetPos = aiState.targetPosition;\r\n        if (aiState.target) {\r\n            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);\r\n            if (currentTargetPos) {\r\n                targetPos = currentTargetPos;\r\n            }\r\n        }\r\n\r\n        if (!targetPos) {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vz = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            return;\r\n        }\r\n\r\n        const dx = targetPos.x - pos.x;\r\n        const dz = targetPos.z - pos.z;\r\n        const distToTarget = Math.sqrt(dx * dx + dz * dz);\r\n\r\n        if (distToTarget < 0.1) {\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vz = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            return;\r\n        }\r\n\r\n        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);\r\n        data.desiredVelocity.vx = (dx / distToTarget) * moveSpeed;\r\n        data.desiredVelocity.vz = (dz / distToTarget) * moveSpeed;\r\n        data.desiredVelocity.vy = 0;\r\n    }\r\n\r\n    requestPathIfNeeded(entityId, data) {\r\n        const { pos, aiState } = data;\r\n        const now = this.game.state.now;\r\n        if(!aiState.aiBehavior){\r\n            aiState.aiBehavior = {};\r\n        }\r\n        if (!aiState.aiBehavior.lastPathRequest || (now - aiState.aiBehavior.lastPathRequest) > this.PATH_REREQUEST_INTERVAL) {\r\n            aiState.aiBehavior.lastPathRequest = now;\r\n\r\n            let targetPos = aiState.targetPosition;\r\n            if (aiState.target) {\r\n                targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);\r\n            }\r\n\r\n            if ((!aiState.path || aiState.path.length == 0) && targetPos) {\r\n                aiState.path = this.game.gameManager.call('requestPath',\r\n                    entityId,\r\n                    pos.x,\r\n                    pos.z,\r\n                    targetPos.x,\r\n                    targetPos.z,\r\n                    1\r\n                );\r\n            }\r\n        }\r\n    }\r\n    \r\n    followPath(entityId, data) {\r\n        const { pos, vel, aiState } = data;\r\n        \r\n        if (aiState.pathIndex === undefined) {\r\n            aiState.pathIndex = 0;\r\n        }\r\n        \r\n        if (aiState.pathIndex >= aiState.path.length) {\r\n            aiState.path = null;\r\n            aiState.pathIndex = 0;\r\n            data.desiredVelocity.vx = 0;\r\n            data.desiredVelocity.vz = 0;\r\n            data.desiredVelocity.vy = 0;\r\n            return;\r\n        }\r\n        const waypoint = aiState.path[aiState.pathIndex];\r\n        const dx = waypoint.x - pos.x;\r\n        const dz = waypoint.z - pos.z;\r\n        const distToWaypoint = Math.sqrt(dx * dx + dz * dz);\r\n        \r\n        if (distToWaypoint < this.PATH_REACHED_DISTANCE) {\r\n            aiState.pathIndex++;\r\n            if (aiState.pathIndex >= aiState.path.length) {\r\n                aiState.path = null;\r\n                aiState.pathIndex = 0;\r\n            }\r\n            return;\r\n        }\r\n        \r\n        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);\r\n        data.desiredVelocity.vx = (dx / distToWaypoint) * moveSpeed;\r\n        data.desiredVelocity.vz = (dz / distToWaypoint) * moveSpeed;\r\n        data.desiredVelocity.vy = 0;\r\n    }\r\n    \r\n    applyUnitMovementWithSmoothing(entityId, data) {\r\n        const { vel, desiredVelocity, separationForce, avoidanceForce, isAnchored } = data;\r\n\r\n        if (isAnchored) {\r\n            vel.vx = 0;\r\n            vel.vz = 0;\r\n            vel.vy = desiredVelocity.vy || vel.vy || 0;\r\n            return;\r\n        }\r\n        \r\n        const history = this.movementHistory.get(entityId);\r\n        const isOscillating = this.isUnitOscillating(entityId);\r\n        \r\n        let targetVx = desiredVelocity.vx + separationForce.x + avoidanceForce.x;\r\n        let targetVz = desiredVelocity.vz + separationForce.z + avoidanceForce.z;\r\n        \r\n        if (isOscillating) {\r\n            targetVx = desiredVelocity.vx + (separationForce.x + avoidanceForce.x) * 0.3;\r\n            targetVz = desiredVelocity.vz + (separationForce.z + avoidanceForce.z) * 0.3;\r\n        }\r\n        \r\n        const velocitySmoothing = isOscillating ? this.VELOCITY_SMOOTHING * 0.5 : this.VELOCITY_SMOOTHING;\r\n        const directionSmoothing = isOscillating ? this.DIRECTION_SMOOTHING * 0.3 : this.DIRECTION_SMOOTHING;\r\n        \r\n        const newVx = this.lerp(vel.vx, targetVx, velocitySmoothing);\r\n        const newVz = this.lerp(vel.vz, targetVz, velocitySmoothing);\r\n        \r\n        if (history && history.smoothedDirection) {\r\n            const targetDirection = Math.atan2(targetVz, targetVx);\r\n            \r\n            let currentDirection;\r\n            const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);\r\n            \r\n            if (currentSpeed < this.MIN_MOVEMENT_THRESHOLD) {\r\n                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);\r\n                currentDirection = facing ? facing.angle : 0;\r\n            } else {\r\n                currentDirection = Math.atan2(vel.vz, vel.vx);\r\n            }\r\n            \r\n            let directionDiff = targetDirection - currentDirection;\r\n            if (directionDiff > Math.PI) directionDiff -= 2 * Math.PI;\r\n            if (directionDiff < -Math.PI) directionDiff += 2 * Math.PI;\r\n            \r\n            if (Math.abs(directionDiff) > this.MIN_DIRECTION_CHANGE) {\r\n                const smoothedDirection = currentDirection + directionDiff * directionSmoothing;\r\n                const speed = Math.sqrt(newVx * newVx + newVz * newVz);\r\n                \r\n                if (speed > 0.1) {\r\n                    vel.vx = Math.cos(smoothedDirection) * speed;\r\n                    vel.vz = Math.sin(smoothedDirection) * speed;\r\n                    \r\n                    const facing = this.game.getComponent(entityId, this.componentTypes.FACING);\r\n                    if (facing) {\r\n                        facing.angle = smoothedDirection;\r\n                    }\r\n                } else {\r\n                    vel.vx = newVx;\r\n                    vel.vz = newVz;\r\n                }\r\n            } else {\r\n                vel.vx = newVx;\r\n                vel.vz = newVz;\r\n            }\r\n        } else {\r\n            vel.vx = newVx;\r\n            vel.vz = newVz;\r\n        }\r\n        \r\n        vel.vy = desiredVelocity.vy;\r\n        \r\n        const speedSqrd = vel.vx * vel.vx + vel.vz * vel.vz;\r\n        if (speedSqrd < this.MIN_MOVEMENT_THRESHOLD * this.MIN_MOVEMENT_THRESHOLD) {\r\n            vel.vx = 0;\r\n            vel.vz = 0;\r\n        }\r\n        \r\n        const maxSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED) * 1.4;\r\n        const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);\r\n        if (currentSpeed > maxSpeed) {\r\n            const speedRatio = maxSpeed / currentSpeed;\r\n            vel.vx *= speedRatio;\r\n            vel.vz *= speedRatio;\r\n        }\r\n    }\r\n    \r\n    lerp(a, b, t) {\r\n        return a + (b - a) * t;\r\n    }\r\n    \r\n    shouldApplyGravity(entityId, projectile, unitType) {\r\n        if (projectile) {\r\n            return true;\r\n        }\r\n        \r\n        if (unitType) {\r\n            const collections = this.game.getCollections && this.game.getCollections();\r\n            if (collections && collections.units) {\r\n                const unitDef = collections.units[unitType.id];\r\n                if (unitDef && unitDef.flying) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n    \r\n    handleGroundInteraction(pos, vel) {\r\n        const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);\r\n        \r\n        if (terrainHeight !== null) {\r\n            const targetHeight = terrainHeight;   \r\n            pos.y = targetHeight;\r\n            \r\n            if (pos.y <= targetHeight + 0.1) {\r\n                vel.vy = Math.max(0, vel.vy);\r\n            }\r\n        } else {\r\n            if (pos.y < this.GROUND_LEVEL) {\r\n                pos.y = this.GROUND_LEVEL;\r\n                vel.vy = Math.max(0, vel.vy);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    enforceBoundaries(pos, collision) {\r\n        const collections = this.game.getCollections();\r\n        const currentLevel = this.game.state.level;\r\n        const level = collections.levels[currentLevel];        \r\n        const tileMap = level.tileMap;\r\n\r\n        const terrainSize = tileMap.size * collections.configs.game.gridSize;\r\n        const halfTerrain = terrainSize / 2;\r\n        const unitRadius = this.getUnitRadius(collision);\r\n        \r\n\r\n        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));\r\n        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));\r\n    }\r\n    \r\n    getUnitRadius(collision) {\r\n        if (collision && collision.radius) {\r\n            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);\r\n        }\r\n        return this.DEFAULT_UNIT_RADIUS;\r\n    }\r\n    \r\n    entityDestroyed(entityId) {\r\n        \r\n        if (this.unitStates) {\r\n            this.unitStates.delete(entityId);\r\n        }\r\n        \r\n        if (this.movementTracking) {\r\n            this.movementTracking.delete(entityId);\r\n        }\r\n        \r\n        if (this.movementHistory) {\r\n            this.movementHistory.delete(entityId);\r\n        }\r\n    }\r\n\r\n    ping() {\r\n        console.log('pong');\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MovementSystem.js",
        "fileName": "MovementSystem"
      },
      "SchedulingSystem": {
        "script": "class SchedulingSystem extends engine.BaseSystem {\r\n   constructor(game) {\r\n        super(game);\r\n        this.game.schedulingSystem = this;\r\n        \r\n        // Scheduled actions storage\r\n        this.scheduledActions = new Map();\r\n        this.actionIdCounter = 0;\r\n        \r\n        // Entity tracking for cleanup\r\n        this.entityActions = new Map(); // entityId -> Set of actionIds\r\n    }\r\n\r\n    init() {\r\n        // Register methods with GameManager\r\n        this.game.gameManager.register('scheduleAction', this.scheduleAction.bind(this));\r\n        this.game.gameManager.register('cancelScheduledAction', this.cancelAction.bind(this));\r\n    }\r\n\r\n    update() {\r\n        this.processScheduledActions();\r\n    }\r\n    \r\n    /**\r\n     * Schedule an action to execute after a delay\r\n     * @param {Function} callback - Function to execute\r\n     * @param {number} delaySeconds - Delay in seconds (game time)\r\n     * @param {string|null} entityId - Optional entity ID for tracking/cleanup\r\n     * @returns {string} actionId - Unique identifier for this action\r\n     */\r\n    scheduleAction(callback, delaySeconds, entityId = null) {\r\n        const executeTime = this.game.state.now + delaySeconds;\r\n        const actionId = `action_${this.actionIdCounter++}_${executeTime.toFixed(6)}`;\r\n        \r\n        this.scheduledActions.set(actionId, {\r\n            callback: callback,\r\n            executeTime: executeTime,\r\n            entityId: entityId\r\n        });\r\n        \r\n        // Track entity associations for cleanup\r\n        if (entityId) {\r\n            if (!this.entityActions.has(entityId)) {\r\n                this.entityActions.set(entityId, new Set());\r\n            }\r\n            this.entityActions.get(entityId).add(actionId);\r\n        }\r\n        \r\n        return actionId;\r\n    }\r\n    \r\n    /**\r\n     * Process all scheduled actions that are ready to execute\r\n     */\r\n    processScheduledActions() {\r\n        const actionsToExecute = [];\r\n        \r\n        // Find all actions ready to execute\r\n        for (const [actionId, action] of this.scheduledActions.entries()) {\r\n            if (this.game.state.now >= action.executeTime) {\r\n                actionsToExecute.push({ id: actionId, action: action });\r\n            }\r\n        }\r\n        \r\n        // Sort actions for deterministic execution order\r\n        actionsToExecute.sort((a, b) => {\r\n            // Primary sort: by execution time\r\n            if (Math.abs(a.action.executeTime - b.action.executeTime) > 0.000001) {\r\n                return a.action.executeTime - b.action.executeTime;\r\n            }\r\n            // Secondary sort: by action ID for deterministic tie-breaking\r\n            return a.id.localeCompare(b.id);\r\n        });\r\n        \r\n        // Execute actions in deterministic order\r\n        actionsToExecute.forEach(({ id, action }) => {\r\n            try {\r\n                action.callback();\r\n            } catch (error) {\r\n                console.error(`Error executing scheduled action ${id}:`, error);\r\n            }\r\n            \r\n            // Clean up\r\n            this.removeAction(id, action.entityId);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Cancel a scheduled action\r\n     * @param {string} actionId - Action to cancel\r\n     * @returns {boolean} - True if action was found and cancelled\r\n     */\r\n    cancelAction(actionId) {\r\n        const action = this.scheduledActions.get(actionId);\r\n        if (action) {\r\n            this.removeAction(actionId, action.entityId);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Cancel all actions associated with an entity\r\n     * @param {string} entityId - Entity whose actions should be cancelled\r\n     * @returns {number} - Number of actions cancelled\r\n     */\r\n    entityDestroyed(entityId) {\r\n        const entityActionIds = this.entityActions.get(entityId);\r\n        if (!entityActionIds) return 0;\r\n        \r\n        let cancelledCount = 0;\r\n        for (const actionId of entityActionIds) {\r\n            if (this.scheduledActions.has(actionId)) {\r\n                this.scheduledActions.delete(actionId);\r\n                cancelledCount++;\r\n            }\r\n        }\r\n        \r\n        this.entityActions.delete(entityId);\r\n        return cancelledCount;\r\n    }\r\n    \r\n    /**\r\n     * Internal method to remove action and clean up tracking\r\n     * @param {string} actionId \r\n     * @param {string|null} entityId \r\n     */\r\n    removeAction(actionId, entityId) {\r\n        this.scheduledActions.delete(actionId);\r\n        \r\n        if (entityId && this.entityActions.has(entityId)) {\r\n            this.entityActions.get(entityId).delete(actionId);\r\n            \r\n            // Clean up empty entity tracking\r\n            if (this.entityActions.get(entityId).size === 0) {\r\n                this.entityActions.delete(entityId);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Get info about scheduled actions (for debugging)\r\n     * @returns {Object} - Statistics about scheduled actions\r\n     */\r\n    getSchedulingStats() {\r\n        return {\r\n            totalActions: this.scheduledActions.size,\r\n            entitiesWithActions: this.entityActions.size,\r\n            nextActionTime: this.getNextActionTime()\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Get the time of the next scheduled action\r\n     * @returns {number|null} - Time of next action, or null if none scheduled\r\n     */\r\n    getNextActionTime() {\r\n        let nextTime = null;\r\n        for (const action of this.scheduledActions.values()) {\r\n            if (nextTime === null || action.executeTime < nextTime) {\r\n                nextTime = action.executeTime;\r\n            }\r\n        }\r\n        return nextTime;\r\n    }\r\n    \r\n    /**\r\n     * Check if an entity has scheduled actions\r\n     * @param {string} entityId \r\n     * @returns {boolean}\r\n     */\r\n    hasEntityActions(entityId) {\r\n        const entityActionIds = this.entityActions.get(entityId);\r\n        return entityActionIds && entityActionIds.size > 0;\r\n    }\r\n    \r\n    /**\r\n     * Clear all scheduled actions (useful for game reset)\r\n     */\r\n    clearAllActions() {\r\n        this.scheduledActions.clear();\r\n        this.entityActions.clear();\r\n    }\r\n    \r\n    /**\r\n     * Convenience method: Schedule a delayed function call\r\n     * @param {Object} obj - Object to call method on\r\n     * @param {string} methodName - Method name to call\r\n     * @param {Array} args - Arguments to pass\r\n     * @param {number} delaySeconds - Delay in seconds\r\n     * @param {string|null} entityId - Optional entity ID\r\n     * @returns {string} actionId\r\n     */\r\n    scheduleMethodCall(obj, methodName, args = [], delaySeconds, entityId = null) {\r\n        return this.scheduleAction(() => {\r\n            if (obj && typeof obj[methodName] === 'function') {\r\n                obj[methodName](...args);\r\n            }\r\n        }, delaySeconds, entityId);\r\n    }\r\n}\r\n",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SchedulingSystem.js",
        "fileName": "SchedulingSystem"
      },
      "VisionSystem": {
        "script": "class VisionSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.visionSystem = this;\r\n\r\n        // Default unit height for line of sight calculations\r\n        this.DEFAULT_UNIT_HEIGHT = 25;\r\n    }\r\n\r\n    init() {\r\n        this.game.gameManager.register('hasLineOfSight', this.hasLineOfSight.bind(this));\r\n    }\r\n\r\n\r\n    hasLineOfSight(from, to, unitType, viewerEntityId = null) {\r\n        const dx = to.x - from.x;\r\n        const dz = to.z - from.z;\r\n        const distanceSq = dx * dx + dz * dz;\r\n        const distance = Math.sqrt(distanceSq);\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n\r\n        if (distance < gridSize*2) return true;\r\n\r\n        const terrainSystem = this.game.terrainSystem;\r\n        if (!terrainSystem) {\r\n            console.warn('[hasLineOfSight] No terrain system found!');\r\n            return true;\r\n        }\r\n\r\n        // Get discrete heightmap levels for from and to positions\r\n        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);\r\n        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);\r\n        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);\r\n        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);\r\n\r\n        const fromHeightLevel = terrainSystem.getHeightLevelAtGridPosition(fromGridX, fromGridZ);\r\n        const toHeightLevel = terrainSystem.getHeightLevelAtGridPosition(toGridX, toGridZ);\r\n\r\n        // Cannot see up to tiles with higher heightmap values\r\n        if (toHeightLevel > fromHeightLevel) {\r\n            return false;\r\n        }\r\n\r\n        const fromTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(from.x, from.z);\r\n        const toTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(to.x, to.z);\r\n\r\n        // Use unit height from unitType, or fall back to default if not available\r\n        const unitHeight = (unitType && unitType.height) ? unitType.height : this.DEFAULT_UNIT_HEIGHT;\r\n\r\n        const fromEyeHeight = fromTerrainHeight + unitHeight;\r\n        const toEyeHeight = toTerrainHeight + unitHeight;\r\n\r\n        // Check for terrain blocking along the path (for same-level or downward vision)\r\n        if (!this.checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel)) {\r\n            return false;\r\n        }\r\n        \r\n        let nearbyTrees = [];\r\n\r\n        const midX = (from.x + to.x) / 2;\r\n        const midZ = (from.z + to.z) / 2;\r\n        const unitSize = (unitType && unitType.size) ? unitType.size : gridSize;\r\n        nearbyTrees = this.game.gameManager.call('getNearbyUnits', { x: midX, y: 0, z: midZ} , distance / 2 + unitSize, viewerEntityId, 'worldObjects');\r\n\r\n\r\n        if (nearbyTrees.length > 0) {\r\n            const numSamples = Math.max(2, Math.ceil(distance / (gridSize * 0.5)));\r\n            const stepX = dx / numSamples;\r\n            const stepZ = dz / numSamples;\r\n            \r\n            for (let i = 1; i < numSamples; i++) {\r\n                const t = i / numSamples;\r\n                const sampleX = from.x + stepX * i;\r\n                const sampleZ = from.z + stepZ * i;\r\n                const rayHeight = fromEyeHeight + (toEyeHeight - fromEyeHeight) * t;\r\n                \r\n                for (const unit of nearbyTrees) {                    \r\n                    const dx = sampleX - unit.x;\r\n                    const dz = sampleZ - unit.z;\r\n                    const distSq = dx * dx + dz * dz;\r\n                    if(!unit.size) unit.size = gridSize;\r\n                    if (distSq < unit.size * unit.size) {            \r\n                        if (rayHeight < unit.y+unit.height) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel) {\r\n        const terrainSystem = this.game.terrainSystem;\r\n        const gridSize = this.game.getCollections().configs.game.gridSize;\r\n\r\n        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);\r\n        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);\r\n        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);\r\n        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);\r\n\r\n        const tiles = this.bresenhamLine(fromGridX, fromGridZ, toGridX, toGridZ);\r\n\r\n        // Check intermediate tiles along the path\r\n        for (let i = 1; i < tiles.length - 1; i++) {\r\n            const tile = tiles[i];\r\n\r\n            // Check if this intermediate tile has a higher heightmap level than the viewer\r\n            const tileHeightLevel = terrainSystem.getHeightLevelAtGridPosition(tile.x, tile.z);\r\n            if (tileHeightLevel > fromHeightLevel) {\r\n                // Cannot see through a tile with higher elevation\r\n                return false;\r\n            }\r\n\r\n            // Also check if the ray goes below the terrain at this point (for smooth terrain variations)\r\n            const t = i / (tiles.length - 1);\r\n            const worldX = tile.x * gridSize - terrainSystem.terrainSize / 2;\r\n            const worldZ = tile.z * gridSize - terrainSystem.terrainSize / 2;\r\n            const rayHeight = fromEyeHeight + (toTerrainHeight - fromEyeHeight) * t;\r\n            const terrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(worldX, worldZ);\r\n\r\n            if (rayHeight <= terrainHeight) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    bresenhamLine(x0, z0, x1, z1) {\r\n        const tiles = [];\r\n        \r\n        const dx = Math.abs(x1 - x0);\r\n        const dz = Math.abs(z1 - z0);\r\n        const sx = x0 < x1 ? 1 : -1;\r\n        const sz = z0 < z1 ? 1 : -1;\r\n        let err = dx - dz;\r\n        \r\n        let x = x0;\r\n        let z = z0;\r\n        \r\n        while (true) {\r\n            tiles.push({ x, z });\r\n            \r\n            if (x === x1 && z === z1) break;\r\n            \r\n            const e2 = 2 * err;\r\n            if (e2 > -dz) {\r\n                err -= dz;\r\n                x += sx;\r\n            }\r\n            if (e2 < dx) {\r\n                err += dx;\r\n                z += sz;\r\n            }\r\n        }\r\n        \r\n        return tiles;\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/VisionSystem.js",
        "fileName": "VisionSystem"
      },
      "FogOfWarSystem": {
        "script": "class FogOfWarSystem extends engine.BaseSystem {\r\n    constructor(game) {\r\n        super(game);\r\n        this.game.fogOfWarSystem = this;\r\n        this.componentTypes = this.game.componentManager.getComponentTypes();\r\n\r\n        this.VISION_RADIUS = 500;\r\n        this.WORLD_SIZE = this.game.gameManager.call('getWorldExtendedSize');\r\n        this.FOG_TEXTURE_SIZE = 64;\r\n\r\n        // Line of sight settings (optimized)\r\n        this.LOS_ENABLED = true;\r\n        this.LOS_RAYS_PER_UNIT = 16;\r\n        this.LOS_SAMPLE_DISTANCE = 12;\r\n        this.LOS_UNIT_BLOCKING_ENABLED = true;\r\n        this.LOS_UNIT_HEIGHT = 25;\r\n        this.LOS_UNIT_BLOCK_RADIUS = 25;\r\n\r\n        this.fogRenderTarget = null;\r\n        this.explorationRenderTarget = null;\r\n        this.explorationRenderTargetPingPong = null;\r\n        this.fogScene = null;\r\n        this.fogCamera = null;\r\n        this.fogPass = null;\r\n\r\n        // LOS mesh pool with geometry reuse\r\n        this.losGeometryPool = [];\r\n        this.losMeshPool = [];\r\n        this.losMaterial = null;\r\n        \r\n        this.accumulationMaterial = null;\r\n        this.accumulationQuad = null;\r\n        this.accumulationScene = null;\r\n        this.accumulationCamera = null;\r\n        \r\n        this.cachedVisibilityBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE);\r\n        this.cachedExplorationBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE);\r\n        this.visibilityCacheValid = false;\r\n        this.explorationCacheValid = false;\r\n        \r\n        // Pre-allocate reusable arrays\r\n        this.tempVisiblePoints = new Array(this.LOS_RAYS_PER_UNIT);\r\n        for (let i = 0; i < this.LOS_RAYS_PER_UNIT; i++) {\r\n            this.tempVisiblePoints[i] = { x: 0, z: 0 };\r\n        }\r\n       \r\n    }\r\n\r\n    init(params = {}) {\r\n        this.params = params;\r\n        this.initRendering();\r\n\r\n        // Register getter methods\r\n        this.game.gameManager.register('getExplorationTexture', this.getExplorationTexture.bind(this));\r\n        this.game.gameManager.register('getFogTexture', this.getFogTexture.bind(this));\r\n    }\r\n\r\n    getExplorationTexture() {\r\n        return this.explorationRenderTarget?.texture || null;\r\n    }\r\n\r\n    getFogTexture() {\r\n        return this.fogRenderTarget?.texture || null;\r\n    }\r\n    initRendering(){\r\n        this.fogRenderTarget = new THREE.WebGLRenderTarget(\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.FOG_TEXTURE_SIZE,\r\n            {\r\n                minFilter: THREE.LinearFilter,\r\n                magFilter: THREE.LinearFilter,\r\n                format: THREE.RedFormat\r\n            }\r\n        );\r\n        \r\n        this.explorationRenderTarget = new THREE.WebGLRenderTarget(\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.FOG_TEXTURE_SIZE,\r\n            {\r\n                minFilter: THREE.LinearFilter,\r\n                magFilter: THREE.LinearFilter,\r\n                format: THREE.RedFormat\r\n            }\r\n        );\r\n        \r\n        this.explorationRenderTargetPingPong = new THREE.WebGLRenderTarget(\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.FOG_TEXTURE_SIZE,\r\n            {\r\n                minFilter: THREE.LinearFilter,\r\n                magFilter: THREE.LinearFilter,\r\n                format: THREE.RedFormat\r\n            }\r\n        );\r\n        \r\n        const halfSize = this.WORLD_SIZE / 2;\r\n        this.fogCamera = new THREE.OrthographicCamera(\r\n            -halfSize, halfSize,\r\n            halfSize, -halfSize,\r\n            0.1, 1000\r\n        );\r\n        this.fogCamera.position.set(0, 500, 0);\r\n        this.fogCamera.lookAt(0, 0, 0);\r\n        this.fogScene = new THREE.Scene();\r\n        this.fogScene.background = new THREE.Color(0x000000);\r\n                \r\n        this.losMaterial = new THREE.MeshBasicMaterial({\r\n            color: 0xffffff,\r\n            transparent: true,\r\n            opacity: 1.0,\r\n            side: THREE.DoubleSide,\r\n            depthWrite: false\r\n        });\r\n        \r\n        this.accumulationMaterial = new THREE.ShaderMaterial({\r\n            uniforms: {\r\n                currentExploration: { value: null },\r\n                newVisibility: { value: null }\r\n            },\r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                }\r\n            `,\r\n            fragmentShader: `\r\n                uniform sampler2D currentExploration;\r\n                uniform sampler2D newVisibility;\r\n                varying vec2 vUv;\r\n                \r\n                void main() {\r\n                    float explored = texture2D(currentExploration, vUv).r;\r\n                    float visible = texture2D(newVisibility, vUv).r;\r\n                    float newExploration = max(explored, visible);\r\n                    gl_FragColor = vec4(newExploration, newExploration, newExploration, 1.0);\r\n                }\r\n            `\r\n        });\r\n        \r\n        this.accumulationQuad = new THREE.Mesh(\r\n            new THREE.PlaneGeometry(2, 2),\r\n            this.accumulationMaterial\r\n        );\r\n        this.accumulationScene = new THREE.Scene();\r\n        this.accumulationScene.add(this.accumulationQuad);\r\n        this.accumulationCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n        \r\n        console.log('[FogOfWarSystem] Optimized GPU fog with LOS initialized');\r\n    }\r\n\r\n    postAllInit() {\r\n        if (this.game.postProcessingSystem) {\r\n            this.createFogPass();\r\n            this.game.gameManager.call('registerPostProcessingPass', 'fog', {\r\n                enabled: true,\r\n                pass: this.fogPass\r\n            });\r\n        }\r\n    }\r\n\r\n\r\n    generateLOSVisibilityShape(unitPos, visionRadius, unitType, entityId) {\r\n        const angleStep = (Math.PI * 2) / this.LOS_RAYS_PER_UNIT;\r\n        \r\n        for (let i = 0; i < this.LOS_RAYS_PER_UNIT; i++) {\r\n            const angle = i * angleStep;\r\n            const dirX = Math.cos(angle);\r\n            const dirZ = Math.sin(angle);\r\n            \r\n            // Binary search with reduced iterations (4 instead of 6)\r\n            let minDist = 0;\r\n            let maxDist = visionRadius;\r\n            let visibleDist = visionRadius;\r\n            \r\n            // First check max distance\r\n            const maxX = unitPos.x + dirX * visionRadius;\r\n            const maxZ = unitPos.z + dirZ * visionRadius;\r\n            if (!this.game.gameManager.call('hasLineOfSight',\r\n                { x: unitPos.x, z: unitPos.z },\r\n                { x: maxX, z: maxZ },\r\n                unitType,\r\n                entityId\r\n            )) {\r\n                // Binary search with 4 iterations (instead of 6)\r\n                for (let iter = 0; iter < 4; iter++) {\r\n                    const midDist = (minDist + maxDist) / 2;\r\n                    const midX = unitPos.x + dirX * midDist;\r\n                    const midZ = unitPos.z + dirZ * midDist;\r\n                    if (this.game.gameManager.call('hasLineOfSight',\r\n                        { x: unitPos.x, z: unitPos.z },\r\n                        { x: midX, z: midZ },\r\n                        unitType,\r\n                        entityId\r\n                    )) {\r\n                        minDist = midDist;\r\n                    } else {\r\n                        maxDist = midDist;\r\n                    }\r\n                }\r\n                visibleDist = minDist;\r\n            }\r\n            \r\n            // Reuse pre-allocated point objects\r\n            this.tempVisiblePoints[i].x = unitPos.x + dirX * visibleDist;\r\n            this.tempVisiblePoints[i].z = unitPos.z + dirZ * visibleDist;\r\n        }\r\n        \r\n        return this.tempVisiblePoints;\r\n    }\r\n\r\n    updateVisibilityMesh(points, meshIndex) {\r\n        if (points.length < 3) return null;\r\n        \r\n        const vertexCount = points.length * 3 * 3; // triangles * 3 vertices * 3 coords\r\n        \r\n        // Try to reuse existing geometry\r\n        let geometry;\r\n        if (meshIndex < this.losGeometryPool.length) {\r\n            geometry = this.losGeometryPool[meshIndex];\r\n            // Resize if needed\r\n            const currentSize = geometry.attributes.position?.array.length || 0;\r\n            if (currentSize !== vertexCount) {\r\n                geometry.dispose();\r\n                geometry = new THREE.BufferGeometry();\r\n                this.losGeometryPool[meshIndex] = geometry;\r\n            }\r\n        } else {\r\n            geometry = new THREE.BufferGeometry();\r\n            this.losGeometryPool.push(geometry);\r\n        }\r\n        \r\n        // Calculate center\r\n        let centerX = 0, centerZ = 0;\r\n        for (let i = 0; i < points.length; i++) {\r\n            centerX += points[i].x;\r\n            centerZ += points[i].z;\r\n        }\r\n        centerX /= points.length;\r\n        centerZ /= points.length;\r\n        \r\n        // Create or update vertex buffer\r\n        let vertices;\r\n        if (geometry.attributes.position) {\r\n            vertices = geometry.attributes.position.array;\r\n            // Expand array if needed\r\n            if (vertices.length !== vertexCount) {\r\n                vertices = new Float32Array(vertexCount);\r\n            }\r\n        } else {\r\n            vertices = new Float32Array(vertexCount);\r\n        }\r\n        \r\n        // Fill vertices (triangle fan from center)\r\n        // The fog camera looks down from Y=500, so we create a flat mesh in XZ plane at Y=0\r\n        let vertIdx = 0;\r\n        for (let i = 0; i < points.length; i++) {\r\n            const nextI = (i + 1) % points.length;\r\n            \r\n            // Center point\r\n            vertices[vertIdx++] = centerX;\r\n            vertices[vertIdx++] = 0;\r\n            vertices[vertIdx++] = centerZ;\r\n            \r\n            // Current point\r\n            vertices[vertIdx++] = points[i].x;\r\n            vertices[vertIdx++] = 0;\r\n            vertices[vertIdx++] = points[i].z;\r\n            \r\n            // Next point\r\n            vertices[vertIdx++] = points[nextI].x;\r\n            vertices[vertIdx++] = 0;\r\n            vertices[vertIdx++] = points[nextI].z;\r\n        }\r\n        \r\n        if (!geometry.attributes.position || geometry.attributes.position.array !== vertices) {\r\n            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));\r\n        }\r\n        geometry.attributes.position.needsUpdate = true;\r\n        geometry.computeBoundingSphere();\r\n        \r\n        // Reuse or create mesh\r\n        let mesh;\r\n        if (meshIndex < this.losMeshPool.length) {\r\n            mesh = this.losMeshPool[meshIndex];\r\n            if (mesh.geometry !== geometry) {\r\n                mesh.geometry = geometry;\r\n            }\r\n        } else {\r\n            mesh = new THREE.Mesh(geometry, this.losMaterial);\r\n            this.losMeshPool.push(mesh);\r\n            this.fogScene.add(mesh);\r\n        }\r\n        \r\n        // Position mesh at origin (vertices are already in world space)\r\n        mesh.position.set(0, 0, 0);\r\n        mesh.rotation.set(0, 0, 0);\r\n        mesh.scale.set(1, 1, 1);\r\n        mesh.visible = true;\r\n        \r\n        return mesh;\r\n    }\r\n\r\n    createFogPass() {\r\n        this.fogPass = {\r\n            enabled: true,\r\n            needsSwap: true,\r\n            clear: false,\r\n                                    \r\n            uniforms: {\r\n                tDiffuse: { value: null },\r\n                tDepth: { value: null },\r\n                fogTexture: { value: this.fogRenderTarget.texture },\r\n                explorationTexture: { value: this.explorationRenderTarget.texture },\r\n                worldSize: { value: this.WORLD_SIZE },\r\n                cameraNear: { value: 1 },\r\n                cameraFar: { value: 100 },\r\n                cameraWorldMatrix: { value: new THREE.Matrix4() },\r\n                cameraProjectionMatrixInv: { value: new THREE.Matrix4() }\r\n            },\r\n            \r\n            material: null,\r\n            fsQuad: null,\r\n            fsQuadScene: null,\r\n            fsQuadCamera: null\r\n        };\r\n\r\n        this.fogPass.material = new THREE.ShaderMaterial({\r\n            uniforms: this.fogPass.uniforms,\r\n            vertexShader: `\r\n                varying vec2 vUv;\r\n                void main() {\r\n                    vUv = uv;\r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n                }\r\n            `,\r\n            fragmentShader: `\r\n                uniform sampler2D tDiffuse;\r\n                uniform sampler2D tDepth;\r\n                uniform sampler2D fogTexture;\r\n                uniform sampler2D explorationTexture;\r\n                uniform float worldSize;\r\n                uniform float cameraNear;\r\n                uniform float cameraFar;\r\n                uniform mat4 cameraWorldMatrix;\r\n                uniform mat4 cameraProjectionMatrixInv;\r\n\r\n                varying vec2 vUv;\r\n                \r\n                float readDepth(vec2 coord) {\r\n                    return texture2D(tDepth, coord).x;\r\n                }\r\n                \r\n                vec3 getWorldPosition(vec2 uv, float depth) {\r\n                    float x = uv.x * 2.0 - 1.0;\r\n                    float y = uv.y * 2.0 - 1.0;\r\n                    float z = depth * 2.0 - 1.0;\r\n                    \r\n                    vec4 clipPos = vec4(x, y, z, 1.0);\r\n                    vec4 viewPos = cameraProjectionMatrixInv * clipPos;\r\n                    viewPos /= viewPos.w;\r\n                    vec4 worldPos = cameraWorldMatrix * viewPos;\r\n                    \r\n                    return worldPos.xyz;\r\n                }\r\n\r\n                void main() {\r\n                    vec4 sceneColor = texture2D(tDiffuse, vUv);\r\n                    float unexploredIntensity = 0.025;\r\n                    float exploredIntensity = 0.2;\r\n                    \r\n                    float depth = readDepth(vUv);\r\n                    vec3 worldPos = getWorldPosition(vUv, depth);\r\n                    \r\n                    float halfSize = worldSize * 0.5;\r\n                    vec2 fogUV = vec2(\r\n                        (worldPos.x + halfSize) / worldSize,\r\n                        (-worldPos.z + halfSize) / worldSize\r\n                    );\r\n                    \r\n                    vec3 grayscale = vec3(dot(sceneColor.rgb, vec3(0.299, 0.587, 0.114)));\r\n                    \r\n                    float inset = 1e-4;\r\n                    if (fogUV.x < inset || fogUV.x > 1.0 - inset ||\r\n                        fogUV.y < inset || fogUV.y > 1.0 - inset) {\r\n                        gl_FragColor = vec4(grayscale * unexploredIntensity, 1.0);\r\n                        return;\r\n                    }\r\n                    \r\n                    vec4 fogSample = texture2D(fogTexture, fogUV);\r\n                    float visibleGradient = fogSample.r;\r\n                    \r\n                    vec4 explorationSample = texture2D(explorationTexture, fogUV);\r\n                    float explorationGradient = explorationSample.r;\r\n                    \r\n                    vec3 exploredColor = sceneColor.rgb * exploredIntensity;\r\n                    vec3 visibleColor = mix(exploredColor, sceneColor.rgb, visibleGradient);\r\n                    vec3 finalColor = mix(grayscale * unexploredIntensity, visibleColor, explorationGradient);\r\n                    \r\n                    gl_FragColor = vec4(finalColor, 1.0);\r\n                }\r\n            `\r\n        });\r\n        \r\n        const geometry = new THREE.PlaneGeometry(2, 2);\r\n        const mesh = new THREE.Mesh(geometry, this.fogPass.material);\r\n        const scene = new THREE.Scene();\r\n        scene.add(mesh);\r\n        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\r\n        \r\n        this.fogPass.fsQuadScene = scene;\r\n        this.fogPass.fsQuadCamera = camera;\r\n        \r\n        const fogPassObj = this.fogPass;\r\n        const fogSystemRef = this;\r\n        \r\n        this.fogPass.fsQuad = {\r\n            render: (renderer) => {\r\n                renderer.render(fogPassObj.fsQuadScene, fogPassObj.fsQuadCamera);\r\n            }\r\n        };\r\n        \r\n        this.fogPass.render = function(renderer, writeBuffer, readBuffer) {\r\n            if (fogSystemRef.game.camera) {\r\n                fogPassObj.uniforms.cameraWorldMatrix.value.copy(fogSystemRef.game.camera.matrixWorld);\r\n                fogPassObj.uniforms.cameraProjectionMatrixInv.value.copy(fogSystemRef.game.camera.projectionMatrixInverse);\r\n                fogPassObj.uniforms.cameraNear.value = fogSystemRef.game.camera.near;\r\n                fogPassObj.uniforms.cameraFar.value = fogSystemRef.game.camera.far;\r\n            }\r\n            \r\n            fogSystemRef.renderFogTexture();\r\n            \r\n            fogPassObj.uniforms.tDiffuse.value = readBuffer.texture;\r\n            fogPassObj.uniforms.tDepth.value = readBuffer.depthTexture;\r\n            \r\n            if (fogPassObj.needsSwap) {\r\n                renderer.setRenderTarget(writeBuffer);\r\n            } else {\r\n                renderer.setRenderTarget(null);\r\n            }\r\n            \r\n            fogPassObj.fsQuad.render(renderer);\r\n        };\r\n                \r\n        this.fogPass.setSize = function(width, height) {\r\n            // No-op\r\n        };\r\n    }\r\n\r\n    renderFogTexture() {\r\n        const myTeam = this.game.state.mySide;\r\n        if (!myTeam) return;\r\n\r\n        const myUnits = this.game.getEntitiesWith(\r\n            this.componentTypes.POSITION,\r\n            this.componentTypes.TEAM,\r\n            this.componentTypes.HEALTH\r\n        ).filter(id => {\r\n            const team = this.game.getComponent(id, this.componentTypes.TEAM);\r\n            return team?.team === myTeam;\r\n        });\r\n\r\n        // Hide all meshes\r\n        this.losMeshPool.forEach(mesh => mesh.visible = false);\r\n\r\n        let meshIndex = 0;\r\n\r\n        myUnits.forEach((entityId) => {\r\n            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);\r\n            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);\r\n            if (!pos) return;\r\n\r\n            const visionRadius = unitType?.visionRange || this.VISION_RADIUS;\r\n\r\n            const visiblePoints = this.generateLOSVisibilityShape(\r\n                { x: pos.x, z: pos.z },\r\n                visionRadius,\r\n                unitType,\r\n                entityId\r\n            );\r\n            \r\n            this.updateVisibilityMesh(visiblePoints, meshIndex);\r\n    \r\n            meshIndex++;\r\n            \r\n        });\r\n\r\n        // Render visibility\r\n        this.game.renderer.setRenderTarget(this.fogRenderTarget);\r\n        this.game.renderer.render(this.fogScene, this.fogCamera);\r\n        \r\n        // Accumulate exploration\r\n        this.accumulationMaterial.uniforms.currentExploration.value = this.explorationRenderTarget.texture;\r\n        this.accumulationMaterial.uniforms.newVisibility.value = this.fogRenderTarget.texture;\r\n        \r\n        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);\r\n        this.game.renderer.render(this.accumulationScene, this.accumulationCamera);\r\n        \r\n        const temp = this.explorationRenderTarget;\r\n        this.explorationRenderTarget = this.explorationRenderTargetPingPong;\r\n        this.explorationRenderTargetPingPong = temp;\r\n        \r\n        this.fogPass.uniforms.explorationTexture.value = this.explorationRenderTarget.texture;\r\n        \r\n        this.game.renderer.setRenderTarget(null);\r\n        \r\n        this.visibilityCacheValid = false;\r\n        this.explorationCacheValid = false;\r\n    }\r\n\r\n    updateVisibilityCache() {\r\n        if (this.visibilityCacheValid) return;\r\n        \r\n        this.game.renderer.readRenderTargetPixels(\r\n            this.fogRenderTarget,\r\n            0, 0,\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.cachedVisibilityBuffer\r\n        );\r\n        \r\n        this.visibilityCacheValid = true;\r\n    }\r\n\r\n    updateExplorationCache() {\r\n        if (this.explorationCacheValid) return;\r\n        \r\n        this.game.renderer.readRenderTargetPixels(\r\n            this.explorationRenderTarget,\r\n            0, 0,\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.FOG_TEXTURE_SIZE,\r\n            this.cachedExplorationBuffer\r\n        );\r\n        \r\n        this.explorationCacheValid = true;\r\n    }\r\n\r\n    //only available on CLIENT\r\n    isVisibleAt(x, z) {\r\n        const uv = this.worldToUV(x, z);\r\n        if (!uv) return false;\r\n        \r\n        this.updateVisibilityCache();\r\n        \r\n        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);\r\n        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);\r\n        const index = (py * this.FOG_TEXTURE_SIZE + px);\r\n        \r\n        return this.cachedVisibilityBuffer[index] > 0;\r\n    }\r\n\r\n    //only available on CLIENT\r\n    isExploredAt(x, z) {\r\n        const uv = this.worldToUV(x, z);\r\n        if (!uv) return false;\r\n        \r\n        this.updateExplorationCache();\r\n        \r\n        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);\r\n        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);\r\n        const index = (py * this.FOG_TEXTURE_SIZE + px);\r\n        \r\n        return this.cachedExplorationBuffer[index] > 0;\r\n    }\r\n\r\n    worldToUV(x, z) {\r\n        const half = this.WORLD_SIZE * 0.5;\r\n        let u = (x + half) / this.WORLD_SIZE;\r\n        let v = (-z + half) / this.WORLD_SIZE;\r\n\r\n        if (u < 0 || u > 1 || v < 0 || v > 1) {\r\n            return null;\r\n        }\r\n\r\n        return { x: u, y: v };\r\n    }\r\n\r\n    resetExploration() {\r\n        this.game.renderer.setRenderTarget(this.explorationRenderTarget);\r\n        this.game.renderer.clear();\r\n        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);\r\n        this.game.renderer.clear();\r\n        this.game.renderer.setRenderTarget(null);\r\n        this.explorationCacheValid = false;\r\n    }\r\n\r\n    dispose() {\r\n        if (this.fogRenderTarget) this.fogRenderTarget.dispose();\r\n        if (this.explorationRenderTarget) this.explorationRenderTarget.dispose();\r\n        if (this.explorationRenderTargetPingPong) this.explorationRenderTargetPingPong.dispose();\r\n        if (this.game.postProcessingSystem) this.game.gameManager.call('removePostProcessingPass', 'fog');\r\n        if (this.accumulationMaterial) this.accumulationMaterial.dispose();\r\n        if (this.accumulationQuad) this.accumulationQuad.geometry.dispose();\r\n        if (this.losMaterial) this.losMaterial.dispose();\r\n\r\n        this.losGeometryPool.forEach(geom => geom.dispose());\r\n        this.losMeshPool = [];\r\n        this.losGeometryPool = [];\r\n    }\r\n}",
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/FogOfWarSystem.js",
        "fileName": "FogOfWarSystem"
      },
      "ParticleSystem": {
        "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ParticleSystem.js",
        "fileName": "ParticleSystem",
        "script": "class ParticleSystem extends engine.BaseSystem {\r\n  constructor(game) {\r\n    super(game);\r\n    this.game.particleSystem = this;\r\n\r\n    this.CAPACITY = 2000;\r\n    this.initialized = false;\r\n    this.activeCount = 0;\r\n    this.freeList = [];\r\n\r\n    this.positions = new Array(this.CAPACITY);\r\n    this.velocities = new Array(this.CAPACITY);\r\n    this.gravityArr = new Float32Array(this.CAPACITY);\r\n    this.dragArr = new Float32Array(this.CAPACITY);\r\n\r\n    this.aColorStart = new Float32Array(this.CAPACITY * 3);\r\n    this.aColorEnd   = new Float32Array(this.CAPACITY * 3);\r\n    this.aLifetime   = new Float32Array(this.CAPACITY);\r\n    this.aStartTime  = new Float32Array(this.CAPACITY);\r\n    this.aInitScale  = new Float32Array(this.CAPACITY);\r\n    this.aFlags      = new Float32Array(this.CAPACITY * 2);\r\n\r\n    this._tmpMat = new THREE.Matrix4();\r\n    this._cursor = 0;\r\n\r\n    this.UPDATE_STRIDE = 2;\r\n  }\r\n\r\n  init() {\r\n    // Register methods with GameManager\r\n    this.game.gameManager.register('createParticles', this.createParticles.bind(this));\r\n    this.game.gameManager.register('clearAllParticles', this.clearAllParticles.bind(this));\r\n    this.game.gameManager.register('initializeParticleSystem', this.initialize.bind(this));\r\n  }\r\n\r\n  initialize() {\r\n    if (this.initialized || !this.game.scene) return;\r\n\r\n    const geometry = new THREE.PlaneGeometry(0.25, 0.25);\r\n\r\n    const vertexShader = `\r\n      attribute vec3 aColorStart;\r\n      attribute vec3 aColorEnd;\r\n      attribute float aLifetime;\r\n      attribute float aStartTime;\r\n      attribute float aInitScale;\r\n      attribute vec2 aFlags; // x: fadeOut, y: scaleOverTime\r\n      varying vec3 vColor;\r\n      varying float vAlpha;\r\n      varying vec2 vUv;\r\n      uniform float uTime;\r\n\r\n      vec3 camRight() { return vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]); }\r\n      vec3 camUp()    { return vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]); }\r\n\r\n      void main() {\r\n        vUv = uv;\r\n        float age = max(uTime - aStartTime, 0.0);\r\n        float lifeT = clamp(1.0 - age / max(aLifetime, 0.0001), 0.0, 1.0);\r\n\r\n        vColor = mix(aColorEnd, aColorStart, lifeT);\r\n        vAlpha = aFlags.x > 0.5 ? lifeT : 1.0;\r\n\r\n        float s = aInitScale;\r\n        if (aFlags.y > 0.5) {\r\n          if (lifeT > 0.8)       s *= (1.0 - lifeT) * 5.0;\r\n          else if (lifeT > 0.2)  s *= 1.0;\r\n          else                   s *= lifeT * 5.0;\r\n        }\r\n\r\n        vec3 right = camRight();\r\n        vec3 up    = camUp();\r\n\r\n        vec3 instT = vec3(instanceMatrix[3][0], instanceMatrix[3][1], instanceMatrix[3][2]);\r\n        vec3 worldPos = instT + right * (position.x * s) + up * (position.y * s);\r\n\r\n        gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);\r\n      }\r\n    `;\r\n\r\n    const fragmentShader = `\r\n      precision mediump float;\r\n      varying vec3 vColor;\r\n      varying float vAlpha;\r\n      varying vec2 vUv;\r\n\r\n      void main() {\r\n        vec2 c = vUv - vec2(0.5);\r\n        float r = length(c) * 2.0;\r\n        float mask = smoothstep(1.0, 0.6, r);\r\n        float a = vAlpha * mask;\r\n\r\n        if (a <= 0.001) discard;\r\n\r\n        // CHANGED: simple straight output (no tone mapping), alpha not premultiplied here\r\n        gl_FragColor = vec4(vColor, a); // CHANGED\r\n      }\r\n    `;\r\n\r\n    this.material = new THREE.ShaderMaterial({\r\n      vertexShader,\r\n      fragmentShader,\r\n      transparent: true,\r\n      depthWrite: false,\r\n      blending: THREE.NormalBlending,          // CHANGED: sane default; per-effect override allowed\r\n      uniforms: { uTime: { value: 0 } },\r\n      toneMapped: false                        // CHANGED: ensure shader output isn't remapped\r\n    });\r\n\r\n    this.mesh = new THREE.InstancedMesh(geometry, this.material, this.CAPACITY);\r\n    this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\r\n\r\n    const addAttr = (arr, itemSize, name) => {\r\n      const a = new THREE.InstancedBufferAttribute(arr, itemSize);\r\n      this.mesh.geometry.setAttribute(name, a);\r\n      return a;\r\n    };\r\n    this.attrColorStart = addAttr(this.aColorStart, 3, 'aColorStart');\r\n    this.attrColorEnd   = addAttr(this.aColorEnd,   3, 'aColorEnd');\r\n    this.attrLifetime   = addAttr(this.aLifetime,   1, 'aLifetime');\r\n    this.attrStartTime  = addAttr(this.aStartTime,  1, 'aStartTime');\r\n    this.attrInitScale  = addAttr(this.aInitScale,  1, 'aInitScale');\r\n    this.attrFlags      = addAttr(this.aFlags,      2, 'aFlags');\r\n\r\n    for (let i = 0; i < this.CAPACITY; i++) {\r\n      this._writeTranslation(i, 1e9, 1e9, 1e9);\r\n      this.positions[i]  = new THREE.Vector3(1e9, 1e9, 1e9);\r\n      this.velocities[i] = new THREE.Vector3(0, 0, 0);\r\n      this.gravityArr[i] = 0.0;\r\n      this.dragArr[i]    = 1.0;\r\n      this.freeList.push(i);\r\n    }\r\n\r\n    this.mesh.frustumCulled = false;\r\n    this.game.scene.add(this.mesh);\r\n\r\n    this.initialized = true;\r\n  }\r\n\r\n  _writeTranslation(index, x, y, z) {\r\n    const m = this._tmpMat;\r\n    m.identity();\r\n    m.setPosition(x, y, z);\r\n    this.mesh.setMatrixAt(index, m);\r\n  }\r\n\r\n  /**\r\n   * createParticles(config)\r\n   * Config preserved:\r\n   *   position, count, lifetime,\r\n   *   visual.{color|colorRange{start,end}|scale|fadeOut|scaleOverTime|blending|scaleMultiplier},\r\n   *   velocityRange, gravity, drag, speedMultiplier, heightOffset, shape? (ignored)\r\n   */\r\n  createParticles(config) {\r\n    if (!this.initialized) {\r\n      this.initialize();\r\n      if (!this.initialized) return;\r\n    }\r\n\r\n    const {\r\n      position = new THREE.Vector3(0, 0, 0),\r\n      count = 10,\r\n      lifetime = 1.25,\r\n      visual = {},\r\n      velocityRange = { x: [-30, 30], y: [50, 120], z: [-30, 30] },\r\n      gravity = -100.0,\r\n      drag = 0.98,\r\n      speedMultiplier: speedMulTop = 1.0,\r\n      heightOffset = 0\r\n    } = config;\r\n\r\n    // ---------- COLOR RESOLUTION (broad compatibility) ----------\r\n    // CHANGED: find start/end colors across multiple common fields\r\n    const { startColorResolved, endColorResolved } = this._resolveColorPair(config, visual); // CHANGED\r\n\r\n    // ---------- SCALE / SPEED ----------\r\n    const scaleMul = (visual.scaleMultiplier != null ? visual.scaleMultiplier : 1.0);\r\n    const initScale = ((visual.scale != null) ? visual.scale : 16.0) * scaleMul;\r\n\r\n    const speedMulVisual = (visual.speedMultiplier != null ? visual.speedMultiplier : 1.0);\r\n    const speedMul = speedMulTop * speedMulVisual;\r\n\r\n    const fadeOut = (visual.fadeOut === undefined) ? true : !!visual.fadeOut;\r\n    const scaleOverTime = (visual.scaleOverTime === undefined) ? true : !!visual.scaleOverTime;\r\n\r\n    // Per-effect blending (global switch for the single material)\r\n    if (visual.blending) {\r\n      const b = String(visual.blending).toLowerCase();\r\n      const target =\r\n        b === 'additive' ? THREE.AdditiveBlending :\r\n        b === 'multiply' ? THREE.MultiplyBlending :\r\n                           THREE.NormalBlending;\r\n      if (this.material.blending !== target) {\r\n        this.material.blending = target;\r\n        this.material.needsUpdate = true;\r\n      }\r\n    }\r\n\r\n    const rv = (min, max) => min + Math.random() * (max - min);\r\n    const now = this._now();\r\n\r\n    let spawned = 0;\r\n    const want = Math.max(1, Math.floor(count));\r\n    while (spawned < want && this.freeList.length > 0) {\r\n      const i = this.freeList.pop();\r\n\r\n      const px = position.x;\r\n      const py = position.y + heightOffset;\r\n      const pz = position.z;\r\n\r\n      this.positions[i].set(px, py, pz);\r\n      this._writeTranslation(i, px, py, pz);\r\n\r\n      const vx = rv(velocityRange.x[0], velocityRange.x[1]) * speedMul;\r\n      const vy = rv(velocityRange.y[0], velocityRange.y[1]) * speedMul;\r\n      const vz = rv(velocityRange.z[0], velocityRange.z[1]) * speedMul;\r\n      this.velocities[i].set(vx, vy, vz);\r\n      this.gravityArr[i] = gravity;\r\n      this.dragArr[i]    = drag;\r\n\r\n      // CHANGED: write resolved colors\r\n      const si = i * 3;\r\n      this.aColorStart[si    ] = startColorResolved.r;\r\n      this.aColorStart[si + 1] = startColorResolved.g;\r\n      this.aColorStart[si + 2] = startColorResolved.b;\r\n\r\n      this.aColorEnd[si    ] = endColorResolved.r;\r\n      this.aColorEnd[si + 1] = endColorResolved.g;\r\n      this.aColorEnd[si + 2] = endColorResolved.b;\r\n\r\n      this.aLifetime[i]  = lifetime;\r\n      this.aStartTime[i] = now;\r\n      this.aInitScale[i] = initScale;\r\n      this.aFlags[i * 2    ] = fadeOut ? 1.0 : 0.0;\r\n      this.aFlags[i * 2 + 1] = scaleOverTime ? 1.0 : 0.0;\r\n\r\n      spawned++;\r\n      this.activeCount++;\r\n    }\r\n\r\n    this.attrColorStart.needsUpdate = true;\r\n    this.attrColorEnd.needsUpdate   = true;\r\n    this.attrLifetime.needsUpdate   = true;\r\n    this.attrStartTime.needsUpdate  = true;\r\n    this.attrInitScale.needsUpdate  = true;\r\n    this.attrFlags.needsUpdate      = true;\r\n    this.mesh.instanceMatrix.needsUpdate = true;\r\n  }\r\n\r\n  clearAllParticles() {\r\n    if (!this.initialized) return;\r\n    for (let i = 0; i < this.CAPACITY; i++) {\r\n      this.aLifetime[i] = 0.0;\r\n      this._writeTranslation(i, 1e9, 1e9, 1e9);\r\n      this.positions[i].set(1e9, 1e9, 1e9);\r\n      this.velocities[i].set(0, 0, 0);\r\n      this.gravityArr[i] = 0.0;\r\n      this.dragArr[i] = 1.0;\r\n      if (!this.freeList.includes(i)) this.freeList.push(i);\r\n    }\r\n    this.activeCount = 0;\r\n    this.attrLifetime.needsUpdate = true;\r\n    this.mesh.instanceMatrix.needsUpdate = true;\r\n  }\r\n\r\n  update() {\r\n    if (!this.initialized) return;\r\n\r\n    const dt = this.game?.state?.deltaTime || 0.016;\r\n    const now = this._now();\r\n    this.material.uniforms.uTime.value = now;\r\n\r\n    if (this.activeCount === 0) return;\r\n\r\n    const total = this.CAPACITY;\r\n    let processed = 0;\r\n    const target = Math.max(1, Math.floor(this.activeCount / this.UPDATE_STRIDE));\r\n\r\n    for (let loop = 0; loop < total && processed < target; loop++) {\r\n      const i = this._cursor;\r\n      this._cursor = (this._cursor + 1) % total;\r\n\r\n      const life = this.aLifetime[i];\r\n      if (life <= 0.0) continue;\r\n\r\n      if ((now - this.aStartTime[i]) >= life) {\r\n        this.aLifetime[i] = 0.0;\r\n        this.attrLifetime.needsUpdate = true;\r\n\r\n        this._writeTranslation(i, 1e9, 1e9, 1e9);\r\n        this.mesh.instanceMatrix.needsUpdate = true;\r\n\r\n        this.positions[i].set(1e9, 1e9, 1e9);\r\n        this.velocities[i].set(0, 0, 0);\r\n        this.gravityArr[i] = 0.0;\r\n        this.dragArr[i] = 1.0;\r\n\r\n        this.freeList.push(i);\r\n        this.activeCount--;\r\n        processed++;\r\n        continue;\r\n      }\r\n\r\n      const vel = this.velocities[i];\r\n      vel.y += this.gravityArr[i] * dt;\r\n      vel.x *= this.dragArr[i];\r\n      vel.y *= this.dragArr[i];\r\n      vel.z *= this.dragArr[i];\r\n\r\n      const pos = this.positions[i];\r\n      pos.x += vel.x * dt;\r\n      pos.y += vel.y * dt;\r\n      pos.z += vel.z * dt;\r\n\r\n      this._writeTranslation(i, pos.x, pos.y, pos.z);\r\n      processed++;\r\n    }\r\n\r\n    this.mesh.instanceMatrix.needsUpdate = true;\r\n  }\r\n\r\n  destroy() {\r\n    if (!this.initialized) return;\r\n    this.game.scene.remove(this.mesh);\r\n    this.mesh.geometry.dispose();\r\n    this.material.dispose();\r\n    this.initialized = false;\r\n  }\r\n\r\n  // ===== helpers =====\r\n\r\n  // CHANGED: resolve *pair* of colors from many possible config shapes\r\n  _resolveColorPair(config, visual) {\r\n    // Try pairs first (most explicit)\r\n    const pairCandidates = [\r\n      visual?.colorRange,\r\n      config?.colorRange,\r\n      (visual && (visual.startColor || visual.endColor)) ? { start: visual.startColor, end: visual.endColor } : null,\r\n      (config && (config.startColor || config.endColor)) ? { start: config.startColor, end: config.endColor } : null\r\n    ].filter(Boolean);\r\n\r\n    for (const pair of pairCandidates) {\r\n      if (pair?.start != null && pair?.end != null) {\r\n        return {\r\n          startColorResolved: this._resolveColor(pair.start),\r\n          endColorResolved:   this._resolveColor(pair.end)\r\n        };\r\n      }\r\n    }\r\n\r\n    // Single color fallbacks (use same for start/end)\r\n    const singleCandidates = [\r\n      visual?.color,\r\n      config?.color\r\n    ].filter((v) => v != null);\r\n\r\n    if (singleCandidates.length) {\r\n      const c = this._resolveColor(singleCandidates[0]);\r\n      return { startColorResolved: c, endColorResolved: c };\r\n    }\r\n\r\n    // Default white\r\n    const white = { r: 1, g: 1, b: 1 };\r\n    return { startColorResolved: white, endColorResolved: white };\r\n  }\r\n\r\n  // Normalize many color forms to {r,g,b} floats (0..1)\r\n  _resolveColor(input) {\r\n    if (input instanceof THREE.Color) {\r\n      return { r: input.r, g: input.g, b: input.b };\r\n    }\r\n    if (typeof input === 'number' || typeof input === 'string') {\r\n      const c = new THREE.Color(input);\r\n      return { r: c.r, g: c.g, b: c.b };\r\n    }\r\n    if (Array.isArray(input) && input.length >= 3) {\r\n      let [r, g, b] = input;\r\n      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }\r\n      return { r, g, b };\r\n    }\r\n    if (input && typeof input === 'object' && 'r' in input && 'g' in input && 'b' in input) {\r\n      let { r, g, b } = input;\r\n      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }\r\n      return { r, g, b };\r\n    }\r\n    return { r: 1, g: 1, b: 1 };\r\n  }\r\n\r\n  _now() {\r\n    if (this.game?.state?.simTime != null) return this.game.state.simTime;\r\n    return performance.now() / 1000;\r\n  }\r\n}"
      }
    },
    "configs": {
      "ai": {
        "title": "AI",
        "aiEndPoint": "http://localhost:11434/api/generate",
        "aiModel": "",
        "defaultPrompt": "I am developing a tower defense game featuring a simple 3d art style.  Generate a new object based on the following context.    Please provide ONLY a valid JSON object with keys MATCHING EXACTLY to the context above. It absolutely MUST have an appropriate 'id' field. Ensure all existing key types are maintained. Do not wrap the json object with any other text.",
        "fileName": "ai"
      },
      "editor": {
        "title": "Editor Config",
        "editorCategories": "",
        "theme": "claude2",
        "editorModules": [
          "terrainModule",
          "sceneModule",
          "graphicsModule",
          "scriptModule",
          "aiPromptModule",
          "audioModule",
          "exportScriptModule",
          "textureEditor",
          "compilerModule"
        ],
        "path": "/",
        "fileName": "editor"
      },
      "server": {
        "title": "Server Game",
        "projectName": "TurnBasedWarfare",
        "tickRate": 20,
        "seed": "auto",
        "appLoaderLibrary": "ServerGameLoader",
        "appLibrary": "ServerECSGame",
        "initialScene": "server",
        "libraries": [
          "BaseSystem",
          "GameRoom",
          "ServerGameRoom",
          "GameState",
          "BaseECSGame",
          "GameUtils",
          "ServerECSGame",
          "ServerEventManager",
          "ServerNetworkManager",
          "ServerSceneManager",
          "SeededRandom",
          "MinHeap",
          "DesyncDebugger"
        ]
      },
      "game": {
        "gridSize": 48,
        "imageSize": 128,
        "title": "Turn Based Warfare",
        "isIsometric": false,
        "libraries": [
          "threejs",
          "BaseECSGame",
          "Rapier",
          "three_SkeletonUtils",
          "SceneManager",
          "ShapeFactory",
          "ImageManager",
          "SpatialGrid",
          "CoordinateTranslator",
          "CanvasUtility",
          "TerrainImageProcessor",
          "TileMap",
          "Entity",
          "Component",
          "GameState",
          "ModelManager",
          "three_OrbitControls",
          "GLTFLoader",
          "ECSGame",
          "three_EffectComposer",
          "three_RenderPixelatedPass",
          "three_OutputPass",
          "GameModeConfigs",
          "UIComponents",
          "NotificationSystem",
          "GameLoader",
          "GameUtils",
          "PlacementPreview",
          "EnemyStrategy",
          "MultiplayerECSGame",
          "ClientNetworkManager",
          "socket.io.min.js",
          "BaseSystem",
          "SeededRandom",
          "DesyncDebugger",
          "FantasyUIEnhancements",
          "MinHeap",
          "PerformanceProfiler"
        ],
        "fileName": "game",
        "interface": "main",
        "appLibrary": "MultiplayerECSGame",
        "canvasWidth": 1600,
        "canvasHeight": 1600,
        "is3D": true,
        "palette": "main",
        "appLoaderLibrary": "GameLoader",
        "initialScene": "client"
      },
      "state": {
        "level": "level1",
        "mousePosition": "{ x: 0, y: 0, isoX: 0, isoY: 0, gridX: 0, gridY: 0 }",
        "isPaused": false,
        "isLevelingUp": false,
        "timeScale": 1,
        "gameOver": false,
        "victory": false,
        "modifierSet": "global",
        "fileName": "state",
        "population": 0,
        "phase": "placement",
        "round": 1,
        "playerGold": 100,
        "playerReady": false,
        "phaseTimeLeft": 30,
        "selectedUnitType": "",
        "teamMaxHealth": 2500,
        "startingGold": 100
      },
      "codeMirror": {
        "title": "Code Mirror",
        "theme": "codeMirrorTheme",
        "fileName": "codeMirror"
      },
      "multiplayer": {
        "title": "Multiplayer",
        "serverUrl": "http://localhost:3000",
        "maxReconnectAttempts": 5,
        "reconnectDelay": 3000,
        "enabled": true
      }
    },
    "inputDataTypes": {
      "json": {
        "title": "JSON"
      },
      "string": {
        "title": "String"
      }
    },
    "inputElementTypes": {
      "text": {
        "title": "text",
        "tag": "input"
      },
      "textarea": {
        "title": "Text Area",
        "tag": "textarea"
      }
    },
    "levels": {
      "level1": {
        "title": "Level 1",
        "tileMap": {
          "size": 64,
          "terrainTypes": [
            {
              "type": "water",
              "texture": "water",
              "color": "#0288d1",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
              ],
              "walkableNeighbors": [
                "water",
                "grass",
                "forest"
              ],
              "buildable": false
            },
            {
              "type": "lava",
              "texture": "lava",
              "color": "#ff8c00",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "grass",
              "texture": "grass",
              "color": "#5a8a4f",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
              ],
              "walkableNeighbors": [
                "grass",
                "water",
                "forest"
              ],
              "buildable": true
            },
            {
              "type": "forest",
              "texture": "path",
              "color": "#2f4a29",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
              ],
              "buildable": true
            },
            {
              "type": "rock",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "buildable": true
            }
          ],
          "terrainMap": [
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              3,
              3,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              3,
              3,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              3,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              4,
              3,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              2,
              2,
              4,
              2,
              4,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              4,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              2,
              3,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              2,
              2,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              2,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              3,
              2,
              3,
              3,
              3,
              3,
              3,
              3,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ]
          ],
          "terrainBGColor": {
            "paletteColor": "greenMColor"
          },
          "environmentObjects": [
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 707,
              "y": 23.21875
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 702,
              "y": 81.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 584,
              "y": 328.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 56,
              "y": 347.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 73,
              "y": 266.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 54,
              "y": 190.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 205,
              "y": 48.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1095,
              "y": 351.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1234,
              "y": 320.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1094,
              "y": 255.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1258,
              "y": 242.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1442,
              "y": 334.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1504,
              "y": 315.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1193,
              "y": 196.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1313,
              "y": 78.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1519,
              "y": 55.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1518,
              "y": 166.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1431,
              "y": 255.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1136,
              "y": 286.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1056,
              "y": 333.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1233,
              "y": 76.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1423,
              "y": 67.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1469,
              "y": 248.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1551,
              "y": 331.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1182,
              "y": 326.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1229,
              "y": 177.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1538,
              "y": 263.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1490,
              "y": 110.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1351,
              "y": 50.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 714,
              "y": 1547.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 701,
              "y": 1497.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 746,
              "y": 1393.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 926,
              "y": 1424.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1008,
              "y": 1407.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 957,
              "y": 1238.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 691,
              "y": 1200.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 631,
              "y": 1192.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 644,
              "y": 1428.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 617,
              "y": 1538.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 454,
              "y": 1528.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 148,
              "y": 1534.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -15,
              "y": 1535.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -6,
              "y": 1371.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 61,
              "y": 1355.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 33,
              "y": 1470.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 232,
              "y": 1450.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 435,
              "y": 1448.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 576,
              "y": 1405.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 374,
              "y": 1297.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 8,
              "y": 1223.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2,
              "y": 1304.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 70,
              "y": 1226.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 516,
              "y": 1211.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 656,
              "y": 1266.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 504,
              "y": 1332.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 304,
              "y": 1405.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 292,
              "y": 1523.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 125,
              "y": 1398.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 406,
              "y": 1357.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 584,
              "y": 1324.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1516,
              "y": 1350.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1482,
              "y": 1175.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1493,
              "y": 1242.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 356,
              "y": 1191.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 160,
              "y": 1154.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 6,
              "y": 1150.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 435,
              "y": 1135.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 418,
              "y": 1231.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 646,
              "y": 1126.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1398,
              "y": 1146.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 214,
              "y": 1128.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 511,
              "y": 1499.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 476,
              "y": 1416.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 669,
              "y": 1366.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 352,
              "y": 1487.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 180,
              "y": 1517.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 163,
              "y": 1399.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 72,
              "y": 1528.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 94,
              "y": 264.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 88,
              "y": 358.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 619,
              "y": 136.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 679,
              "y": 141.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 689,
              "y": 223.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 667,
              "y": 335.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 603,
              "y": 386.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 589,
              "y": 482.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 744,
              "y": 385.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 782,
              "y": 226.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 861,
              "y": 58.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 780,
              "y": 1324.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 920,
              "y": 1335.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 862,
              "y": 1408.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 747,
              "y": 1497.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 867,
              "y": 1539.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 843,
              "y": 1293.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 876,
              "y": 1206.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 832,
              "y": 1270.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 945,
              "y": 1317.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 784,
              "y": 1467.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 865,
              "y": 1533.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 686,
              "y": 483.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 711,
              "y": 306.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 727,
              "y": 148.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 727,
              "y": 1250.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 752,
              "y": 1468.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 904,
              "y": 1502.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 673,
              "y": 421.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 744,
              "y": 51.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 744,
              "y": 50.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 369,
              "y": 1110.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 369,
              "y": 1109.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 102,
              "y": 1414.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 521,
              "y": 1466.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 120,
              "y": 1224.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 597,
              "y": 1467.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 345,
              "y": 1532.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 549,
              "y": 1278.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1234,
              "y": 272.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 1409,
              "y": 305.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 501,
              "y": 84.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1227,
              "y": 141.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1175,
              "y": 278.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1176,
              "y": 276.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1391,
              "y": 1537.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1391,
              "y": 1536.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1528,
              "y": 1435.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 173,
              "y": 1351.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 132,
              "y": 1482.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 93,
              "y": 971.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1239,
              "y": 935.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 1194,
              "y": 642.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 1369,
              "y": 486.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 98,
              "y": 534.8125
            },
            {
              "type": "tree",
              "imageIndex": 4,
              "x": 1432,
              "y": 683.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 408,
              "y": 602.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 1298,
              "y": 915.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 347,
              "y": 820.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 1206,
              "y": 514.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 451,
              "y": 1038.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 86,
              "y": 612.8125
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 2976,
              "y": 2976
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 96,
              "y": 96
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 144,
              "y": 2931.800048828125
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 2928,
              "y": 147.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2335,
              "y": 2963.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2314,
              "y": 2644.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2966,
              "y": 2469.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2016,
              "y": 2964.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1831,
              "y": 2647.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1876,
              "y": 2376.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1738,
              "y": 2936.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1831,
              "y": 2850.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2108,
              "y": 2994.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1813,
              "y": 2997.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2030,
              "y": 2757.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2166,
              "y": 2908.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2254,
              "y": 3038.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1877,
              "y": 2932.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1979,
              "y": 2630.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1979,
              "y": 2629.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1924,
              "y": 2801.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2199,
              "y": 2729.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2041,
              "y": 2864.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1667,
              "y": 2724.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1665,
              "y": 2515.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2117,
              "y": 2481.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1624,
              "y": 3000.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1911,
              "y": 3023.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1587,
              "y": 2854.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1903,
              "y": 2461.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2092,
              "y": 2581.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1772,
              "y": 2770.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2001,
              "y": 3068.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1771,
              "y": 3076.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2170,
              "y": 3107.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1830,
              "y": 2105.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1710,
              "y": 2252.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 215,
              "y": 1692.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 737,
              "y": 1688.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 977,
              "y": 1859.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 66,
              "y": 1897.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 302,
              "y": 1597.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 305,
              "y": 1831.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 618,
              "y": 1902.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 210,
              "y": 2183.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 752,
              "y": 2223.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 882,
              "y": 2790.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 305,
              "y": 2473.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1203,
              "y": 2977.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1311,
              "y": 2679.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 103,
              "y": 2328.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 451,
              "y": 2123.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 836,
              "y": 3058.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 835,
              "y": 3058.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 918,
              "y": 2925.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1035,
              "y": 2796.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1034,
              "y": 3034.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1411,
              "y": 3013.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1125,
              "y": 2820.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2298,
              "y": 89.79998779296875
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2549,
              "y": 504.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1955,
              "y": 392.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1743,
              "y": 496.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1872,
              "y": 198.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2264,
              "y": 796.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2934,
              "y": 805.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2508,
              "y": 705.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1844,
              "y": 613.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1595,
              "y": 744.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1775,
              "y": 773.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1982,
              "y": 812.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2162,
              "y": 969.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2494,
              "y": 1029.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1829,
              "y": 1085.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2458,
              "y": 1160.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2268,
              "y": 1135.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2719,
              "y": 1194.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2632,
              "y": 910.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2880,
              "y": 1202.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2537,
              "y": 1323.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2832,
              "y": 1378.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2527,
              "y": 1567.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2363,
              "y": 1502.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2434,
              "y": 1314.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2763,
              "y": 1505.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2529,
              "y": 1404.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2050,
              "y": 1430.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1999,
              "y": 1577.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2288,
              "y": 1593.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2002,
              "y": 1761.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2310,
              "y": 1851.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2537,
              "y": 1727.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2537,
              "y": 1726.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2909,
              "y": 1670.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3010,
              "y": 1357.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2731,
              "y": 1068.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1363,
              "y": 1812.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1272,
              "y": 2365.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1346,
              "y": 2778.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1942,
              "y": 2721.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1890,
              "y": 2595.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1755,
              "y": 2620.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1824,
              "y": 2532.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1884,
              "y": 2764.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1728,
              "y": 2830.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1727,
              "y": 2830.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1978,
              "y": 2369.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1782,
              "y": 2408.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1660,
              "y": 2639.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1629,
              "y": 2885.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1966,
              "y": 2493.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 119,
              "y": 1624.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 63,
              "y": 1719.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 415,
              "y": 1623.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 184,
              "y": 1842.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 83,
              "y": 1993.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 82,
              "y": 2102.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 82,
              "y": 2101.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 189,
              "y": 1943.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 419,
              "y": 1705.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2820,
              "y": 1909.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 651,
              "y": 1600.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1294,
              "y": 1667.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1544,
              "y": 1802.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1166,
              "y": 1792.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2980,
              "y": 601.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2805,
              "y": 582.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2671,
              "y": 590.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2719,
              "y": 679.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2855,
              "y": 642.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2771,
              "y": 742.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2927,
              "y": 729.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3021,
              "y": 668.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3015,
              "y": 856.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2852,
              "y": 793.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2849,
              "y": 717.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2774,
              "y": 652.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2653,
              "y": 715.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2625,
              "y": 652.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2630,
              "y": 765.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2699,
              "y": 776.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2813,
              "y": 855.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2814,
              "y": 855.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3040,
              "y": 746.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2882,
              "y": 657.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2918,
              "y": 842.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2985,
              "y": 889.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2750,
              "y": 804.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2973,
              "y": 686.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2993,
              "y": 791.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3041,
              "y": 601.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2584,
              "y": 688.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 834,
              "y": 1514.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 833,
              "y": 1407.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 721,
              "y": 1299.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 721,
              "y": 1298.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 831,
              "y": 1224.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 832,
              "y": 1224.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 921,
              "y": 1289.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 850,
              "y": 1341.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 981,
              "y": 1344.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 796,
              "y": 1591.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 319,
              "y": 1653.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 524,
              "y": 1645.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 856,
              "y": 1644.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2002,
              "y": 2434.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2060,
              "y": 2964.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1936,
              "y": 2883.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1858,
              "y": 2300.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1859,
              "y": 2300.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1634,
              "y": 2384.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1556,
              "y": 2564.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1860,
              "y": 2667.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1617,
              "y": 2668.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1530,
              "y": 2452.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1753,
              "y": 2316.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1799,
              "y": 2184.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1709,
              "y": 2460.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1901,
              "y": 2261.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1747,
              "y": 2529.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1677,
              "y": 3020.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1668,
              "y": 2798.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1727,
              "y": 2684.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 51,
              "y": 2182.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 184,
              "y": 2076.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 357,
              "y": 2214.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 494,
              "y": 2160.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 90,
              "y": 2288.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 315,
              "y": 2298.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 516,
              "y": 2289.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 327,
              "y": 2077.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 606,
              "y": 2102.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 421,
              "y": 2269.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 207,
              "y": 2199.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 484,
              "y": 1991.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 802,
              "y": 2083.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 584,
              "y": 2254.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 430,
              "y": 2041.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 307,
              "y": 2161.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 221,
              "y": 2293.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 220,
              "y": 2293.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 119,
              "y": 2235.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 426,
              "y": 2334.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 188,
              "y": 2321.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 446,
              "y": 2187.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 548,
              "y": 2183.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 526,
              "y": 2094.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 544,
              "y": 2023.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 380,
              "y": 1983.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 301,
              "y": 2027.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 220,
              "y": 1984.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 219,
              "y": 1984.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 93,
              "y": 2025.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 38,
              "y": 2073.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 35,
              "y": 2337.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 24,
              "y": 2428.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 44,
              "y": 2276.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 43,
              "y": 2276.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 26,
              "y": 2201.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 176,
              "y": 2171.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 280,
              "y": 2174.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 282,
              "y": 2082.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 518,
              "y": 2110.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 638,
              "y": 2022.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 641,
              "y": 220.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 661,
              "y": 127.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 549,
              "y": 1.8000030517578125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 426,
              "y": -28.199996948242188
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 145,
              "y": -18.199996948242188
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -77,
              "y": -46.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -157,
              "y": 153.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -79,
              "y": 80.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -133,
              "y": 10.800003051757812
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -44,
              "y": 9.800003051757812
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 26,
              "y": -46.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -149,
              "y": 236.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -115,
              "y": 268.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -171,
              "y": 418.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -64,
              "y": 273.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -161,
              "y": 351.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -58,
              "y": 386.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -73,
              "y": 600.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -159,
              "y": 710.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -45,
              "y": 839.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -26,
              "y": 660.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -137,
              "y": 529.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -34,
              "y": 427.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -35,
              "y": 427.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -100,
              "y": 715.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -154,
              "y": 872.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -165,
              "y": 571.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -68,
              "y": 502.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -102,
              "y": 333.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -24,
              "y": 210.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 73,
              "y": -20.199996948242188
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -33,
              "y": 83.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 279,
              "y": -46.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 544,
              "y": 503.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 43,
              "y": 708.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 87,
              "y": 877.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 181,
              "y": 791.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 447,
              "y": 856.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 691,
              "y": 625.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 599,
              "y": 793.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 598,
              "y": 793.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 704,
              "y": -100.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 268,
              "y": -157.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2,
              "y": -115.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -161,
              "y": -173.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 163,
              "y": -88.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 511,
              "y": -142.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1064,
              "y": -46.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1526,
              "y": -111.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1402,
              "y": -43.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1402,
              "y": -44.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1112,
              "y": -138.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 778,
              "y": -57.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 885,
              "y": -42.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1255,
              "y": -98.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1363,
              "y": -150.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1624,
              "y": -72.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -159,
              "y": 1974.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -162,
              "y": 1973.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -79,
              "y": 1753.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -143,
              "y": 1657.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -97,
              "y": 1094.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -104,
              "y": 956.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -143,
              "y": 1314.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -90,
              "y": 2081.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -120,
              "y": 2378.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -162,
              "y": 2182.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -70,
              "y": 2293.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -122,
              "y": 2555.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -40,
              "y": 2480.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -79,
              "y": 2856.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -25,
              "y": 2599.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -132,
              "y": 2675.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -144,
              "y": 3019.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -110,
              "y": 3164.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 73,
              "y": 3180.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 276,
              "y": 3108.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 336,
              "y": 3196.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 8,
              "y": 3100.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -18,
              "y": 3188.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -172,
              "y": 3216.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -162,
              "y": 3068.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -40,
              "y": 2948.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -40,
              "y": 2947.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -150,
              "y": 2857.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -45,
              "y": 2729.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 522,
              "y": 3124.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 861,
              "y": 3183.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 624,
              "y": 3233.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1096,
              "y": 3153.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1825,
              "y": 3234.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1672,
              "y": 3108.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2012,
              "y": 3146.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2038,
              "y": 3253.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2266,
              "y": 3193.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2355,
              "y": 3241.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2317,
              "y": 3113.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1696,
              "y": 3206.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1902,
              "y": 3203.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1943,
              "y": 3254.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1626,
              "y": 3117.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1444,
              "y": 3210.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1660,
              "y": 3230.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3118,
              "y": 3194.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2950,
              "y": 3144.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3134,
              "y": 3065.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3151,
              "y": 2957.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3121,
              "y": 2825.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3108,
              "y": 2653.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3237,
              "y": 3079.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3006,
              "y": 3086.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2925,
              "y": 3216.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2720,
              "y": 3208.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2855,
              "y": 3093.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3020,
              "y": 3231.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3237,
              "y": 3220.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3014,
              "y": 3123.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3227,
              "y": 2929.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3084,
              "y": 2893.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3125,
              "y": 2995.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3228,
              "y": 2764.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3116,
              "y": 2733.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3232,
              "y": 2524.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3112,
              "y": 2569.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3093,
              "y": 2368.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3243,
              "y": 2385.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3214,
              "y": 2653.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2816,
              "y": 3238.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3113,
              "y": 3249.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3200,
              "y": 3144.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2676,
              "y": 3102.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2413,
              "y": 3221.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2595,
              "y": 3240.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2596,
              "y": 3240.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2469,
              "y": 3134.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2598,
              "y": 3107.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2500,
              "y": 3220.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2559,
              "y": 3157.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2675,
              "y": 3269.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2753,
              "y": 3115.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2906,
              "y": 3265.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2906,
              "y": 3264.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2906,
              "y": 3263.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2906,
              "y": 3262.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2651,
              "y": 2306.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2938,
              "y": 2332.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2657,
              "y": 2988.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2412,
              "y": 3004.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3037,
              "y": 2606.800048828125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3142,
              "y": 564.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3133,
              "y": 697.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3211,
              "y": 694.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3176,
              "y": 586.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2351,
              "y": -81.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2171,
              "y": -123.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2210,
              "y": -24.199996948242188
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2299,
              "y": -170.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3159,
              "y": 830.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3160,
              "y": 831.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3209,
              "y": 888.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3117,
              "y": 882.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3253,
              "y": 822.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3113,
              "y": 784.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3158,
              "y": 1056.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2940,
              "y": 1004.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3151,
              "y": 1177.7999877929688
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3203,
              "y": 412.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3120,
              "y": 312.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3104,
              "y": 455.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3225,
              "y": 285.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3118,
              "y": 194.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3225,
              "y": 155.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3140,
              "y": 100.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3027,
              "y": 41.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2778,
              "y": -43.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2778,
              "y": -44.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2512,
              "y": 11.800003051757812
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2394,
              "y": -114.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2735,
              "y": -167.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3212,
              "y": -86.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3080,
              "y": -162.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2890,
              "y": -130.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3103,
              "y": -57.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3214,
              "y": 18.800003051757812
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3233,
              "y": -169.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 3001,
              "y": -101.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2912,
              "y": -30.199996948242188
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2668,
              "y": -92.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2513,
              "y": -148.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2567,
              "y": -58.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2400,
              "y": -48.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2269,
              "y": -90.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1994,
              "y": -123.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1828,
              "y": -52.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1727,
              "y": -162.1999969482422
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2074,
              "y": -45.19999694824219
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2118,
              "y": 56.80000305175781
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1955,
              "y": 228.8000030517578
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1657,
              "y": 12.800003051757812
            }
          ],
          "extensionTerrainType": 1,
          "ramps": [
            {
              "x": 21,
              "z": 44
            },
            {
              "x": 25,
              "z": 44
            },
            {
              "x": 39,
              "z": 33
            },
            {
              "x": 39,
              "z": 31
            },
            {
              "x": 17,
              "z": 9
            },
            {
              "x": 56,
              "z": 51
            },
            {
              "x": 14,
              "z": 52
            },
            {
              "x": 49,
              "z": 9
            }
          ],
          "heightMap": [
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              0,
              2,
              0,
              2,
              2,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ],
            [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4
            ]
          ],
          "extensionHeight": 2
        },
        "world": "shire",
        "grassShader": "grass",
        "waterShader": "water"
      },
      "level3": {
        "title": "Level 3",
        "tileMap": {
          "size": 128,
          "terrainTypes": [
            {
              "type": "water",
              "texture": "water",
              "color": "#0288d1",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "lava",
              "texture": "lava",
              "color": "#ff8c00",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "grass",
              "texture": "grass",
              "color": "#5a8a4f",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
              ],
              "buildable": true
            },
            {
              "type": "forest",
              "texture": "forest",
              "color": "#2f4a29",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
              ],
              "buildable": true
            },
            {
              "type": "rock",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "buildable": false
            }
          ],
          "terrainMap": [
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ]
          ],
          "terrainBGColor": {
            "paletteColor": "greenMColor"
          },
          "environmentObjects": [],
          "extensionTerrainType": 3,
          "ramps": []
        },
        "world": "shire",
        "grassShader": "grass",
        "waterShader": "water"
      },
      "level32": {
        "title": "Level 32x32",
        "tileMap": {
          "size": 32,
          "terrainTypes": [
            {
              "type": "water",
              "texture": "water",
              "color": "#0288d1",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
              ],
              "walkableNeighbors": [
                "water",
                "grass",
                "forest"
              ],
              "buildable": false
            },
            {
              "type": "lava",
              "texture": "lava",
              "color": "#ff8c00",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "grass",
              "texture": "grass",
              "color": "#5a8a4f",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
              ],
              "walkableNeighbors": [
                "grass",
                "water",
                "forest"
              ],
              "buildable": true
            },
            {
              "type": "forest",
              "texture": "forest",
              "color": "#2f4a29",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
              ],
              "walkableNeighbors": [
                "forest",
                "grass",
                "water"
              ],
              "buildable": true
            },
            {
              "type": "cliff",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "buildable": false
            },
            {
              "type": "cliff",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "buildable": false
            },
            {
              "type": "cliff",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "buildable": false
            },
            {
              "type": "rock",
              "texture": "rock",
              "color": "#3e4f57",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
              ],
              "walkableNeighbors": [
                "rock"
              ],
              "buildable": false
            }
          ],
          "terrainMap": [
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              7,
              7,
              7,
              7
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              7,
              7,
              7,
              7,
              7,
              7
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              7,
              7,
              7,
              7,
              7,
              7,
              7
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              7,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ]
          ],
          "terrainBGColor": {
            "paletteColor": "greenMColor"
          },
          "environmentObjects": [
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 707,
              "y": 23.21875
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 932,
              "y": 24.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 645,
              "y": 291.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 846,
              "y": 282.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 838,
              "y": 196.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 904,
              "y": 102.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 654,
              "y": 213.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 702,
              "y": 81.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 475,
              "y": 168.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 584,
              "y": 328.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 585,
              "y": 328.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 387,
              "y": 343.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 387,
              "y": 342.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 162,
              "y": 362.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 56,
              "y": 347.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 55,
              "y": 347.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 14,
              "y": 48.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -7,
              "y": 343.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -7,
              "y": 344.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 350,
              "y": 98.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 549,
              "y": 137.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 468,
              "y": 388.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 511,
              "y": 283.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 73,
              "y": 266.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 375,
              "y": 196.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 533,
              "y": 72.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 126,
              "y": 50.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 8,
              "y": 135.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 399,
              "y": 125.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 601,
              "y": 80.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 577,
              "y": 215.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 432,
              "y": 274.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 54,
              "y": 190.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 416,
              "y": 61.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 205,
              "y": 48.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 996,
              "y": 222.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 884,
              "y": 346.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 992,
              "y": 355.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1095,
              "y": 351.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1234,
              "y": 320.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 941,
              "y": 281.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1020,
              "y": 149.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1094,
              "y": 255.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1258,
              "y": 242.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1442,
              "y": 334.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1504,
              "y": 315.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1504,
              "y": 314.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1193,
              "y": 196.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1020,
              "y": 244.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 919,
              "y": 230.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 963,
              "y": 109.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1043,
              "y": 66.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1313,
              "y": 78.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1519,
              "y": 55.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1518,
              "y": 166.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1517,
              "y": 166.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1431,
              "y": 255.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1074,
              "y": 180.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1074,
              "y": 179.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1136,
              "y": 286.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1056,
              "y": 333.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1127,
              "y": 119.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1114,
              "y": 76.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1233,
              "y": 76.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1423,
              "y": 67.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1469,
              "y": 248.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1551,
              "y": 331.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1182,
              "y": 326.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1229,
              "y": 177.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1134,
              "y": 220.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1168,
              "y": 72.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1538,
              "y": 263.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1490,
              "y": 110.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 940,
              "y": 182.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1351,
              "y": 50.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 714,
              "y": 1547.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 714,
              "y": 1546.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 701,
              "y": 1497.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 700,
              "y": 1497.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 746,
              "y": 1393.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 926,
              "y": 1424.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 926,
              "y": 1423.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 946,
              "y": 1544.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 945,
              "y": 1544.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1008,
              "y": 1407.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 957,
              "y": 1238.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 956,
              "y": 1236.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 903,
              "y": 1145.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 730,
              "y": 1304.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 691,
              "y": 1200.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 631,
              "y": 1192.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 644,
              "y": 1428.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 643,
              "y": 1428.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 617,
              "y": 1538.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 615,
              "y": 1538.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 454,
              "y": 1528.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 453,
              "y": 1528.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 148,
              "y": 1534.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 147,
              "y": 1534.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -15,
              "y": 1535.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -15,
              "y": 1536.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": -6,
              "y": 1371.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 61,
              "y": 1355.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 33,
              "y": 1470.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 232,
              "y": 1450.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 435,
              "y": 1448.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 576,
              "y": 1405.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 374,
              "y": 1297.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 8,
              "y": 1223.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 2,
              "y": 1304.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 70,
              "y": 1226.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 516,
              "y": 1211.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 516,
              "y": 1210.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 656,
              "y": 1266.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 504,
              "y": 1332.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 304,
              "y": 1405.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 292,
              "y": 1523.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 291,
              "y": 1523.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 125,
              "y": 1398.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 406,
              "y": 1357.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 584,
              "y": 1324.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1029,
              "y": 1525.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1029,
              "y": 1524.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1338,
              "y": 1524.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1516,
              "y": 1350.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1482,
              "y": 1175.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 998,
              "y": 1147.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1055,
              "y": 1271.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1093,
              "y": 1394.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1145,
              "y": 1498.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1145,
              "y": 1497.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1221,
              "y": 1529.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1179,
              "y": 1321.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1106,
              "y": 1197.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1205,
              "y": 1405.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1493,
              "y": 1242.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1214,
              "y": 1202.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1077,
              "y": 1154.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1076,
              "y": 1154.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 356,
              "y": 1191.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 160,
              "y": 1154.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 6,
              "y": 1150.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 435,
              "y": 1135.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 418,
              "y": 1231.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 646,
              "y": 1126.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1214,
              "y": 1272.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1398,
              "y": 1146.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 214,
              "y": 1128.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 511,
              "y": 1499.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 476,
              "y": 1416.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1201,
              "y": 1447.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1258,
              "y": 1458.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 1093,
              "y": 1338.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 669,
              "y": 1366.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 668,
              "y": 1366.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 352,
              "y": 1487.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 180,
              "y": 1517.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 163,
              "y": 1399.8125
            },
            {
              "type": "tree",
              "imageIndex": 0,
              "x": 72,
              "y": 1528.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 94,
              "y": 264.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 341,
              "y": 251.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 88,
              "y": 358.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 494,
              "y": 258.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 619,
              "y": 136.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 679,
              "y": 141.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 689,
              "y": 223.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 667,
              "y": 335.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 603,
              "y": 386.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 589,
              "y": 482.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 717,
              "y": 528.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 744,
              "y": 385.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 782,
              "y": 226.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 861,
              "y": 58.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 818,
              "y": 134.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 652,
              "y": 596.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 641,
              "y": 662.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 681,
              "y": 835.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 752,
              "y": 806.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 752,
              "y": 805.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 799,
              "y": 919.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 752,
              "y": 1122.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 780,
              "y": 1324.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 920,
              "y": 1335.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 862,
              "y": 1408.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 747,
              "y": 1497.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 867,
              "y": 1539.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 843,
              "y": 1293.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 876,
              "y": 1206.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 827,
              "y": 1078.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 714,
              "y": 994.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 797,
              "y": 881.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 739,
              "y": 740.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 726,
              "y": 926.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 799,
              "y": 1066.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 832,
              "y": 1270.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 945,
              "y": 1317.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 784,
              "y": 1467.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 865,
              "y": 1533.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 723,
              "y": 671.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 723,
              "y": 670.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 604,
              "y": 468.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 686,
              "y": 483.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 711,
              "y": 306.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 805,
              "y": 94.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 727,
              "y": 148.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 719,
              "y": 637.8125
            },
            {
              "type": "rock",
              "imageIndex": 5,
              "x": 727,
              "y": 1250.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 752,
              "y": 1468.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 904,
              "y": 1502.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 762,
              "y": 1222.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 786,
              "y": 1009.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 800,
              "y": 853.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 687,
              "y": 791.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 673,
              "y": 421.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 600,
              "y": 575.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 744,
              "y": 51.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 744,
              "y": 50.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 883,
              "y": 67.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 369,
              "y": 1110.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 369,
              "y": 1109.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 102,
              "y": 1414.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 521,
              "y": 1466.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1328,
              "y": 1511.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1049,
              "y": 1315.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1091,
              "y": 1499.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 120,
              "y": 1224.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 597,
              "y": 1467.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 345,
              "y": 1532.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 549,
              "y": 1278.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1234,
              "y": 272.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 1117,
              "y": 137.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 944,
              "y": 335.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 1409,
              "y": 305.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 998,
              "y": 301.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 195,
              "y": 323.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 318,
              "y": 98.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 501,
              "y": 84.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1227,
              "y": 141.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1175,
              "y": 278.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1176,
              "y": 276.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1118,
              "y": 1459.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1391,
              "y": 1537.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1391,
              "y": 1536.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1528,
              "y": 1435.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1144,
              "y": 1260.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 173,
              "y": 1351.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 132,
              "y": 1482.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 672,
              "y": 1062.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 711,
              "y": 837.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 682,
              "y": 689.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 757,
              "y": 583.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 758,
              "y": 583.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 758,
              "y": 711.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 855,
              "y": 1084.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 93,
              "y": 971.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 347,
              "y": 685.8125
            },
            {
              "type": "rock",
              "imageIndex": 6,
              "x": 550,
              "y": 925.8125
            },
            {
              "type": "rock",
              "imageIndex": 6,
              "x": 550,
              "y": 924.8125
            },
            {
              "type": "rock",
              "imageIndex": 2,
              "x": 1239,
              "y": 935.8125
            },
            {
              "type": "rock",
              "imageIndex": 3,
              "x": 1194,
              "y": 642.8125
            },
            {
              "type": "rock",
              "imageIndex": 7,
              "x": 915,
              "y": 633.8125
            },
            {
              "type": "rock",
              "imageIndex": 0,
              "x": 1369,
              "y": 486.8125
            },
            {
              "type": "rock",
              "imageIndex": 4,
              "x": 98,
              "y": 534.8125
            },
            {
              "type": "tree",
              "imageIndex": 4,
              "x": 1432,
              "y": 683.8125
            },
            {
              "type": "tree",
              "imageIndex": 4,
              "x": 1432,
              "y": 682.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 408,
              "y": 602.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 1298,
              "y": 915.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 347,
              "y": 820.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 1206,
              "y": 514.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 451,
              "y": 1038.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 450,
              "y": 1037.8125
            },
            {
              "type": "tree",
              "imageIndex": 2,
              "x": 86,
              "y": 612.8125
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 1440,
              "y": 1440
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 96,
              "y": 96
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 144,
              "y": 1296
            },
            {
              "type": "goldVein",
              "imageIndex": 0,
              "x": 1392,
              "y": 144
            }
          ],
          "extensionTerrainType": 3,
          "ramps": []
        },
        "world": "shire",
        "grassShader": "grass",
        "waterShader": "water"
      },
      "level2": {
        "title": "Level 2",
        "wavesets": [
          "swarm",
          "swarm",
          "swarm"
        ],
        "tileMap": {
          "size": 32,
          "terrainTypes": [
            {
              "type": "water",
              "color": "#2d85c6",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "rock",
              "color": "#9e9e9e",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAECFSQ0HGbi8AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAgnnz5v2nZTAxjlpAKHhHg4hQCDGMBtFoEBEMAYIKRlPRaBARDAGCCmieigCFBDkNArgMlAAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAgnnz5v2nRjAlJSVhDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAOcCUBnjhUZTAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDB0E5FSUlJjDTzAchwUPjRxAKY4TSxANlwkAUAUEhJDYCk3yoAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFAB7VMRQSdQqICRQv0EtQ99CwDb3jkNHe23xQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAC4oUBlpvrH3AAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "grass",
              "color": "#4a7c59",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P0qon8z0AlsK1lOSO6UYxDygKQ69F9QVUfwIIH2RKaWIDsE5pZAPPNqAUEc9BoEI0GEcEQIKhgNBWNBhHBECCoYDQVEQwiAA75PFN7PN69AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCAB4BShTjqMEpwAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVRFQsK1lOc6gpooFIPtxWUI1C3BZMmoBSvRji4fRIBoNItIKkdFURDC8RoNocAYRADzPTBkQkiUcAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSra1rKcEWQ7TSyAGU4TC5ANp7oF6IbTxQIARN88U7u38m0AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQCyWyhTURksDgAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0AlsK1lOSO6UYyjFiAHyWgQEUxro0E0GkQEQ4CggtFUNMyDCFsEg7xMlQoHl+FgCwgGLIUKRi0gGIA0DyIAQT9MGVwsaTUAAAAASUVORK5CYII="
              ],
              "buildable": true
            },
            {
              "type": "forest",
              "color": "#1c6438",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2OUSbH4z0Al8GTOCUZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAIHMNK76+kj9AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCACNcyCuKmmRrQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVRFQ8GTOCZxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAPx6TBmX9XIXAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSp6MucEI8h2mlgAM5wmFiAbTnUL0A2niwUAO0c0rkd3ClIAAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQBLXiCu2Bx7HwAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0Al8GTOCUZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAAPlMGX+pQM0AAAAASUVORK5CYII="
              ],
              "buildable": true
            },
            {
              "type": "path",
              "color": "#f5d69a",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P8em3WfwYqAW6tNEZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAJvSVIWbYGLaAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIoCBaMWEAy80SAaDSKCIUBQwWgqGg0igiFAUMFoKiIYRAACV0CFxNTeCQAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIqAAm6tNJxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAFzITBnELKoVAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABzVIRt1YaI8h2mlgAM5wmFiAbTnUL0A2niwUAqyRUhRUUb34AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABI0EVFCoYtYBgANI8iAAWGUCFGtCTSgAAAABJRU5ErkJggg==",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYqAW6tNEZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAYThMGX3v4DMAAAAASUVORK5CYII="
              ],
              "buildable": false
            },
            {
              "type": "lava",
              "color": "#cc6315",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "end",
              "color": "#ff9999",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC"
              ],
              "buildable": false
            },
            {
              "type": "start",
              "color": "#ffff80",
              "image": [
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
                "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII="
              ],
              "buildable": false
            }
          ],
          "terrainMap": [
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              4,
              4,
              2,
              2,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              2,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              0,
              3,
              2,
              4,
              2,
              2,
              4,
              2,
              3,
              2,
              2,
              1,
              1,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              4,
              2,
              2,
              4,
              2,
              3,
              2,
              2,
              1,
              1,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              0,
              0,
              0,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              0,
              0,
              0,
              2,
              4,
              2,
              3,
              3,
              2,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              0,
              0,
              0,
              2,
              4,
              2,
              3,
              2,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              6,
              2,
              4,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              7
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              3,
              3,
              2,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              3,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              5,
              5,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              5,
              5,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              5,
              5,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              0,
              4,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              0,
              4,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              4,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              4,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              4,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ],
            [
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              7,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2,
              2
            ]
          ],
          "terrainBGColor": "#467554",
          "environmentObjects": [],
          "ramps": []
        },
        "world": "shire"
      }
    }
  },
  "objectTypeDefinitions": [
    {
      "id": "configs",
      "name": "Configs",
      "singular": "Config",
      "category": "Settings",
      "isCore": true
    },
    {
      "id": "components",
      "name": "Components",
      "singular": "Component",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "renderers",
      "name": "Renderers",
      "singular": "Renderer",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "functions",
      "name": "Functions",
      "singular": "Function",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "projectiles",
      "name": "Projectiles",
      "singular": "Projectile",
      "category": "Prefabs"
    },
    {
      "id": "upgrades",
      "name": "Upgrades",
      "singular": "Upgrade",
      "category": "Data"
    },
    {
      "id": "effects",
      "name": "Effects",
      "singular": "Effect",
      "category": "Data"
    },
    {
      "id": "levels",
      "name": "Levels",
      "singular": "Level",
      "category": "Terrain",
      "isCore": true
    },
    {
      "id": "particles",
      "name": "Particles",
      "singular": "Particle",
      "category": "Prefabs"
    },
    {
      "id": "themes",
      "name": "Themes",
      "singular": "Theme",
      "category": "Settings",
      "isCore": true
    },
    {
      "id": "sounds",
      "name": "Sounds",
      "singular": "Sound",
      "category": "Audio",
      "isCore": true
    },
    {
      "id": "libraries",
      "name": "Libraries",
      "singular": "Library",
      "category": "Scripts",
      "isCore": true
    },
    {
      "id": "interfaces",
      "name": "Interfaces",
      "singular": "Interface",
      "category": "Scripts"
    },
    {
      "id": "palettes",
      "name": "Palettes",
      "singular": "Palette",
      "category": "Resources"
    },
    {
      "id": "shadows",
      "name": "Shadows",
      "singular": "Shadow",
      "category": "Environment"
    },
    {
      "id": "lightings",
      "name": "Lightings",
      "singular": "lighting",
      "category": "Environment"
    },
    {
      "id": "fogs",
      "name": "Fogs",
      "singular": "Fog",
      "category": "Environment"
    },
    {
      "id": "cameras",
      "name": "Cameras",
      "singular": "Camera",
      "category": "Environment"
    },
    {
      "id": "worlds",
      "name": "Worlds",
      "singular": "World",
      "category": "Environment"
    },
    {
      "id": "textures",
      "name": "Textures",
      "singular": "Texture",
      "category": "Resources"
    },
    {
      "id": "materials",
      "name": "Materials",
      "singular": "Material",
      "category": "Resources"
    },
    {
      "id": "shaders",
      "name": "Shaders",
      "singular": "Shader",
      "category": "Resources"
    },
    {
      "id": "attackSounds",
      "name": "AttackSounds",
      "singular": "attackSound",
      "category": "Audio"
    },
    {
      "id": "hitSounds",
      "name": "HitSounds",
      "singular": "hitSound",
      "category": "Audio"
    },
    {
      "id": "modifierSets",
      "name": "ModifierSets",
      "singular": "modifierSet",
      "category": "Data"
    },
    {
      "id": "heightMaps",
      "name": "HeightMaps",
      "singular": "heightMap",
      "category": "Environment"
    },
    {
      "id": "worldObjects",
      "name": "WorldObjects",
      "singular": "worldObject",
      "category": "Prefabs"
    },
    {
      "id": "editorModules",
      "name": "EditorModules",
      "singular": "editorModule",
      "category": "Settings"
    },
    {
      "id": "inputDataTypes",
      "name": "InputDataTypes",
      "singular": "inputDataType",
      "category": "Settings"
    },
    {
      "id": "inputElementTypes",
      "name": "InputElementTypes",
      "singular": "inputElementType",
      "category": "Settings"
    },
    {
      "id": "scenes",
      "name": "Scenes",
      "singular": "scene",
      "category": "Environment"
    },
    {
      "id": "gamePrefabs",
      "name": "GamePrefabs",
      "singular": "gamePrefab",
      "category": "Prefabs"
    },
    {
      "id": "modals",
      "name": "Modals",
      "singular": "modal",
      "category": "Scripts"
    },
    {
      "id": "buildings",
      "name": "Buildings",
      "singular": "building",
      "category": "Prefabs"
    },
    {
      "id": "managers",
      "name": "Managers",
      "singular": "manager",
      "category": "Scripts"
    },
    {
      "id": "systems",
      "name": "Systems",
      "singular": "system",
      "category": "Scripts"
    },
    {
      "id": "units",
      "name": "Units",
      "singular": "unit",
      "category": "Prefabs"
    },
    {
      "id": "items",
      "name": "Items",
      "singular": "item",
      "category": "Prefabs"
    },
    {
      "id": "animations",
      "name": "Animations",
      "singular": "Animation",
      "category": "Data"
    },
    {
      "id": "abilities",
      "name": "Abilities",
      "singular": "ability",
      "category": "Scripts"
    },
    {
      "id": "visuals",
      "name": "Visuals",
      "singular": "visual",
      "category": "Prefabs"
    },
    {
      "id": "models",
      "name": "Models",
      "singular": "Model",
      "category": "Data"
    },
    {
      "id": "icons",
      "name": "Icons",
      "singular": "Icon",
      "category": "Resources"
    },
    {
      "id": "actionSets",
      "name": "Action Sets",
      "singular": "Action Set",
      "category": "Data"
    },
    {
      "id": "actions",
      "name": "Actions",
      "singular": "Action",
      "category": "Data"
    },
    {
      "id": "cliffs",
      "name": "Cliffs",
      "singular": "Cliff",
      "category": "Prefabs"
    }
  ]
}