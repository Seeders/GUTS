/**
 * Compiled Game Bundle
 * Project: TurnBasedWarfare
 * Generated: 2025-11-17T10:55:22.692Z
 */

window.engine = {
        app: {}
};

// Global bundle namespace
window.COMPILED_GAME = {
    projectName: "TurnBasedWarfare",
    version: "2025-11-17T10:55:22.692Z",
    classRegistry: {},
    libraryClasses: {},
    collections: {
  "components": {
    "Animator": {
      "filePath": "/global/components/js/Animator.js",
      "fileName": "Animator"
    },
    "ArrayTracker": {
      "filePath": "/global/components/js/ArrayTracker.js",
      "fileName": "ArrayTracker"
    },
    "AudioManager": {
      "filePath": "/global/components/js/AudioManager.js",
      "fileName": "AudioManager"
    },
    "Effect": {
      "filePath": "/global/components/js/Effect.js",
      "fileName": "Effect"
    },
    "Collider": {
      "filePath": "/global/components/js/Collider.js",
      "fileName": "Collider"
    },
    "MapManager": {
      "filePath": "/global/components/js/MapManager.js",
      "fileName": "MapManager"
    },
    "Physics": {
      "filePath": "/global/components/js/Physics.js",
      "fileName": "Physics"
    },
    "PlayerController": {
      "filePath": "/global/components/js/PlayerController.js",
      "fileName": "PlayerController"
    },
    "Projectile": {
      "filePath": "/global/components/js/Projectile.js",
      "fileName": "Projectile"
    },
    "Stats": {
      "filePath": "/global/components/js/Stats.js",
      "fileName": "Stats"
    },
    "ThreeJsWorld": {
      "filePath": "/global/components/js/ThreeJsWorld.js",
      "fileName": "ThreeJsWorld"
    },
    "InfiniWorld": {
      "fileName": "InfiniWorld",
      "parameters": "[\"world\", \"palette\"]",
      "updateInEditor": true,
      "filePath": "/global/components/js/InfiniWorld.js"
    },
    "Transform": {
      "fileName": "Transform",
      "filePath": "/global/components/js/Transform.js"
    },
    "MultiplayerManager": {
      "fileName": "MultiplayerManager",
      "filePath": "/global/components/js/MultiplayerManager.js"
    }
  },
  "editorModules": {
    "aiPromptModule": {
      "title": "AI Prompt Modal",
      "library": "AIPromptPanel",
      "interface": "aiPromptPanel"
    },
    "audioModule": {
      "title": "Audio Editor",
      "container": "audio-editor-container",
      "propertyName": "audio",
      "interface": "audioEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "editAudio",
      "saveHook": "saveAudio",
      "libraries": [
        "Component",
        "AudioEditor"
      ]
    },
    "compilerModule": {
      "title": "Game Compiler",
      "library": "CompilerModule",
      "propertyName": "compiler",
      "libraries": [
        "jszip.min.js",
        "Compiler",
        "CompilerModule"
      ],
      "interface": "compilerInterface"
    },
    "exportScriptModule": {
      "title": "Export Scripts Module",
      "library": "ZipExporter"
    },
    "graphicsModule": {
      "title": "Graphics Editor",
      "container": "graphics-editor-container",
      "libraries": [
        "threejs",
        "three_OrbitControls",
        "GLTFLoader",
        "ShapeFactory",
        "ModelManager",
        "GE_AnimationManager",
        "GE_EventManager",
        "GE_GizmoManager",
        "GE_GroupManager",
        "GE_ShapeManager",
        "GE_RotationUtils",
        "GE_SceneRenderer",
        "GE_UIManager",
        "GE_EquipmentEditor",
        "GraphicsEditor"
      ],
      "propertyName": "render",
      "interface": "graphicsEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "renderGraphicsObject",
      "saveHook": "saveGraphicsObject"
    },
    "sceneModule": {
      "title": "Scene Editor",
      "container": "scene-editor-container",
      "libraries": [
        "threejs",
        "three_OrbitControls",
        "three_SkeletonUtils",
        "three_EffectComposer",
        "three_OutputPass",
        "three_RenderPixelatedPass",
        "GLTFLoader",
        "ShapeFactory",
        "GameState",
        "TileMap",
        "SimplexNoise",
        "TerrainGenerator",
        "ModelManager",
        "SE_GizmoManager",
        "SceneEditor"
      ],
      "propertyName": "sceneData",
      "interface": "sceneEditor",
      "inputElement": "textarea",
      "inputDataType": "array",
      "loadHook": "renderSceneObject",
      "saveHook": "saveSceneObject"
    },
    "scriptModule": {
      "title": "Script Editor",
      "container": "script-editor-container",
      "interface": "scriptEditor",
      "inputElement": "textarea",
      "inputDataType": "string",
      "libraries": [
        "ScriptEditor"
      ],
      "propertyNames": "[\"script\", \"html\", \"css\"]",
      "loadHook": "editScript",
      "saveHook": "saveScript"
    },
    "terrainModule": {
      "title": "Terrain Editor",
      "container": "level-editor-container",
      "libraries": [
        "threejs",
        "ShapeFactory",
        "CoordinateTranslator",
        "ImageManager",
        "CanvasUtility",
        "TerrainImageProcessor",
        "TileMap",
        "GE_GroupManager",
        "TerrainMapEditor"
      ],
      "propertyName": "tileMap",
      "interface": "terrainEditor",
      "inputElement": "textarea",
      "inputDataType": "json",
      "loadHook": "editTileMap",
      "saveHook": "saveTileMap"
    },
    "textureEditor": {
      "title": "Texture Editor",
      "container": "texture-editor-container",
      "library": "TextureEditor",
      "propertyName": "image",
      "interface": "TextureEditor",
      "inputElement": "textarea",
      "inputDataType": "string",
      "loadHook": "editTexture",
      "saveHook": "saveTexture"
    }
  },
  "interfaces": {
    "aiPromptPanel": {
      "title": "AI Prompt Panel",
      "modals": [
        "aiPromptPanel"
      ],
      "fileName": "aiPromptPanel"
    },
    "compilerInterface": {
      "title": "Compiler Interface",
      "fileName": "compilerInterface",
      "filePath": "/global/interfaces/css/compilerInterface.css",
      "modals": [
        "compilerModal"
      ],
      "css": ".compiler-modal {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(0, 0, 0, 0.7);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 10000;\n}\n\n.compiler-modal .modal-content {\n    background: #2d2d30;\n    border-radius: 8px;\n    width: 600px;\n    max-width: 90%;\n    max-height: 90vh;\n    overflow-y: auto;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n}\n\n.compiler-modal .modal-header {\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    padding: 20px;\n    border-bottom: 1px solid #3e3e42;\n}\n\n.compiler-modal .modal-header h2 {\n    margin: 0;\n    color: #fff;\n}\n\n.compiler-modal .close-btn {\n    background: none;\n    border: none;\n    color: #999;\n    font-size: 24px;\n    cursor: pointer;\n    padding: 0;\n    width: 30px;\n    height: 30px;\n    line-height: 30px;\n    text-align: center;\n}\n\n.compiler-modal .close-btn:hover {\n    color: #fff;\n}\n\n.compiler-modal .modal-body {\n    padding: 20px;\n}\n\n.compiler-modal .form-group {\n    margin-bottom: 15px;\n}\n\n.compiler-modal .form-group label {\n    display: block;\n    margin-bottom: 5px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"text\"] {\n    width: 100%;\n    padding: 10px;\n    background: #3c3c3c;\n    border: 1px solid #555;\n    border-radius: 4px;\n    color: #d4d4d4;\n    font-size: 14px;\n}\n\n.compiler-modal .form-group input[type=\"checkbox\"] {\n    margin-right: 8px;\n}\n\n.compiler-modal .compilation-output {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 10px;\n    margin-top: 15px;\n}\n\n.compiler-modal .compilation-output h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .compilation-output pre {\n    margin: 0;\n    color: #d4d4d4;\n    font-family: 'Courier New', monospace;\n    font-size: 12px;\n    white-space: pre-wrap;\n    max-height: 200px;\n    overflow-y: auto;\n}\n\n.compiler-modal .downloads-section {\n    background: #1e1e1e;\n    border: 1px solid #3e3e42;\n    border-radius: 4px;\n    padding: 15px;\n    margin-bottom: 15px;\n}\n\n.compiler-modal .downloads-section h3 {\n    margin: 0 0 10px 0;\n    color: #fff;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link {\n    display: inline-block;\n    padding: 8px 12px;\n    background: #007acc;\n    color: white;\n    text-decoration: none;\n    border-radius: 4px;\n    margin-right: 10px;\n    margin-bottom: 10px;\n    font-size: 14px;\n}\n\n.compiler-modal .download-link:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .modal-footer {\n    padding: 20px;\n    border-top: 1px solid #3e3e42;\n    display: flex;\n    justify-content: flex-end;\n    gap: 10px;\n}\n\n.compiler-modal .btn {\n    padding: 10px 20px;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    font-weight: 600;\n}\n\n.compiler-modal .btn-primary {\n    background: #007acc;\n    color: white;\n}\n\n.compiler-modal .btn-primary:hover {\n    background: #005a9e;\n}\n\n.compiler-modal .btn-secondary {\n    background: #3e3e42;\n    color: #d4d4d4;\n}\n\n.compiler-modal .btn-secondary:hover {\n    background: #505053;\n}\n\n.toolbar-btn {\n    padding: 8px 16px;\n    background: #007acc;\n    color: white;\n    border: none;\n    border-radius: 4px;\n    cursor: pointer;\n    font-size: 14px;\n    margin-left: 10px;\n}\n\n.toolbar-btn:hover {\n    background: #005a9e;\n}\n"
    },
    "audioEditor": {
      "title": "Audio Editor",
      "fileName": "audioEditor",
      "css": "/* =============================================================================\r\n   AUDIO EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Value display for sliders */\r\n.audio-editor__value-display {\r\n    float: right;\r\n    font-weight: 600;\r\n    color: var(--editor-primary);\r\n    font-size: 12px;\r\n}\r\n\r\n/* Waveform display area */\r\n.audio-editor__waveform-display {\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-dark);\r\n    position: relative;\r\n}\r\n\r\n.audio-editor__waveform-display::before {\r\n    content: 'ðŸŽµ Waveform Visualization';\r\n    color: var(--editor-text-muted);\r\n    font-size: 24px;\r\n}\r\n\r\n/* Status container */\r\n#status-container {\r\n    background-color: var(--editor-bg-light);\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    text-align: center;\r\n    font-size: 12px;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
      "filePath": "/global/interfaces/html/audioEditor.html",
      "html": "<div id=\"audio-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left editor-module__scroll-y\">\r\n        <div id=\"status-container\" class=\"editor-module__status-bar\">\r\n            <span id=\"status-message\">Ready</span>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"playBtn\" class=\"editor-module__btn editor-module__btn--primary\">Play</button>\r\n                <button id=\"exportBtn\" class=\"editor-module__btn editor-module__btn--success\">Save</button>\r\n                <button id=\"randomSoundBtn\" class=\"editor-module__btn editor-module__btn--secondary\">ðŸŽ² Randomize Sound</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Basic Parameters</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Waveform:</label>\r\n                <select id=\"waveform\" class=\"editor-module__select\">\r\n                    <option value=\"sine\">Sine</option>\r\n                    <option value=\"square\">Square</option>\r\n                    <option value=\"sawtooth\">Sawtooth</option>\r\n                    <option value=\"triangle\">Triangle</option>\r\n                    <option value=\"noise\">Noise</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Frequency: <span class=\"audio-editor__value-display\">440 Hz</span></label>\r\n                <input type=\"range\" id=\"frequency\" class=\"editor-module__range\" min=\"20\" max=\"2000\" value=\"440\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Duration: <span class=\"audio-editor__value-display\">1.00 s</span></label>\r\n                <input type=\"range\" id=\"duration\" class=\"editor-module__range\" min=\"0.1\" max=\"5\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Volume: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"volume\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Noise Generator</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Type:</label>\r\n                <select id=\"noiseType\" class=\"editor-module__select\">\r\n                    <option value=\"white\">White</option>\r\n                    <option value=\"pink\">Pink</option>\r\n                    <option value=\"brown\">Brown</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Amount: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"noiseAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter:</label>\r\n                <select id=\"noiseFilterType\" class=\"editor-module__select\">\r\n                    <option value=\"none\">None</option>\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Noise Filter Freq: <span class=\"audio-editor__value-display\">2000 Hz</span></label>\r\n                <input type=\"range\" id=\"noiseFilterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"2000\" step=\"1\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Envelope (ADSR)</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Attack: <span class=\"audio-editor__value-display\">0.010 s</span></label>\r\n                <input type=\"range\" id=\"attack\" class=\"editor-module__range\" min=\"0.001\" max=\"2\" value=\"0.01\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Decay: <span class=\"audio-editor__value-display\">0.10 s</span></label>\r\n                <input type=\"range\" id=\"decay\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.1\" step=\"0.001\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Sustain: <span class=\"audio-editor__value-display\">70%</span></label>\r\n                <input type=\"range\" id=\"sustain\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0.7\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Release: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"release\" class=\"editor-module__range\" min=\"0.001\" max=\"5\" value=\"0.3\" step=\"0.001\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Pitch Envelope</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Start: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvStart\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">End: <span class=\"audio-editor__value-display\">1.00x</span></label>\r\n                <input type=\"range\" id=\"pitchEnvEnd\" class=\"editor-module__range\" min=\"0.1\" max=\"4\" value=\"1\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Effects</h3>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Type:</label>\r\n                <select id=\"filterType\" class=\"editor-module__select\">\r\n                    <option value=\"lowpass\">Low Pass</option>\r\n                    <option value=\"highpass\">High Pass</option>\r\n                    <option value=\"bandpass\">Band Pass</option>\r\n                    <option value=\"notch\">Notch</option>\r\n                </select>\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Frequency: <span class=\"audio-editor__value-display\">1000 Hz</span></label>\r\n                <input type=\"range\" id=\"filterFreq\" class=\"editor-module__range\" min=\"20\" max=\"20000\" value=\"1000\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Filter Q: <span class=\"audio-editor__value-display\">Q: 1.0</span></label>\r\n                <input type=\"range\" id=\"filterQ\" class=\"editor-module__range\" min=\"0.1\" max=\"20\" value=\"1\" step=\"0.1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Distortion: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"distortion\" class=\"editor-module__range\" min=\"0\" max=\"100\" value=\"0\" step=\"1\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Time: <span class=\"audio-editor__value-display\">0.30 s</span></label>\r\n                <input type=\"range\" id=\"delayTime\" class=\"editor-module__range\" min=\"0\" max=\"2\" value=\"0.3\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Delay Feedback: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"delayFeedback\" class=\"editor-module__range\" min=\"0\" max=\"0.9\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Reverb: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"reverbAmount\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Bitcrusher: <span class=\"audio-editor__value-display\">0%</span></label>\r\n                <input type=\"range\" id=\"bitcrusher\" class=\"editor-module__range\" min=\"0\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n            <div class=\"editor-module__form-group\">\r\n                <label class=\"editor-module__label\">Panning: <span class=\"audio-editor__value-display\">Center</span></label>\r\n                <input type=\"range\" id=\"panning\" class=\"editor-module__range\" min=\"-1\" max=\"1\" value=\"0\" step=\"0.01\">\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area audio-editor__waveform-display\">\r\n        <!-- Waveform visualization will go here -->\r\n    </div>\r\n</div>\r\n"
    },
    "graphicsEditor": {
      "title": "Graphics Editor",
      "modals": [
        "rotateShapes",
        "moveAllShapes",
        "generateIsometric"
      ],
      "fileName": "graphicsEditor",
      "css": "/* =============================================================================\r\n   GRAPHICS EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#graphics-editor-canvas {\r\n    cursor: grab;\r\n    outline: none;\r\n}\r\n\r\n#graphics-editor-canvas:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n/* Equipment list specific styles */\r\n.graphics-editor__equipment-list {\r\n    max-height: 200px;\r\n}\r\n\r\n.graphics-editor__no-equipment {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n    font-size: 13px;\r\n}\r\n\r\n/* Equipment item styling */\r\n.graphics-editor__equipment-item {\r\n    padding: var(--editor-spacing-md);\r\n    border-bottom: 1px solid var(--editor-border-color);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n}\r\n\r\n.graphics-editor__equipment-item:hover {\r\n    background-color: var(--editor-primary);\r\n}\r\n\r\n.graphics-editor__equipment-item--selected {\r\n    background-color: var(--editor-primary);\r\n    color: white;\r\n}\r\n\r\n.graphics-editor__equipment-item:last-child {\r\n    border-bottom: none;\r\n}\r\n\r\n.graphics-editor__equipment-info {\r\n    display: flex;\r\n    flex-direction: column;\r\n    flex: 1;\r\n}\r\n\r\n.graphics-editor__item-name {\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n}\r\n\r\n.graphics-editor__slot-name {\r\n    color: var(--editor-text-muted);\r\n    font-size: 12px;\r\n}\r\n\r\n.graphics-editor__bone-info {\r\n    font-size: 11px;\r\n    color: var(--editor-text-muted);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n/* Shape list specific styles */\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n    user-select: none;\r\n    cursor: grab;\r\n}\r\n\r\n.graphics-editor__shape-item:active,\r\n.graphics-editor__group-item:active {\r\n    cursor: grabbing;\r\n}\r\n\r\n.graphics-editor__group-item {\r\n    border-left: 4px solid var(--editor-primary);\r\n    font-weight: 500;\r\n}\r\n\r\n.graphics-editor__shape-item {\r\n    border-left: 2px solid var(--editor-bg-lighter);\r\n}\r\n\r\n.graphics-editor__group-shapes {\r\n    margin-left: var(--editor-spacing-lg);\r\n    padding: var(--editor-spacing-sm);\r\n    border-left: 2px dashed var(--editor-border-color);\r\n}\r\n\r\n/* Drag states */\r\n.graphics-editor__shape-item.dragging,\r\n.graphics-editor__group-item.dragging {\r\n    opacity: 0.5;\r\n}\r\n\r\n.graphics-editor__group-item.drag-over {\r\n    border-color: var(--editor-success);\r\n    box-shadow: 0 0 8px rgba(34, 197, 94, 0.3);\r\n}\r\n\r\n/* Mode-specific visibility */\r\n#graphics-editor-container.equipment-mode #graphics-toolbar,\r\n#graphics-editor-container.equipment-mode #graphics-lists,\r\n#graphics-editor-container.equipment-mode #inspector {\r\n    display: none !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #equipment-toolbar,\r\n#graphics-editor-container.equipment-mode #equipment-controls,\r\n#graphics-editor-container.equipment-mode #equipment-inspector,\r\n#graphics-editor-container.equipment-mode #equipment-info,\r\n#graphics-editor-container.equipment-mode #selected-equipment-info {\r\n    display: block !important;\r\n}\r\n\r\n#graphics-editor-container.equipment-mode #shape-count,\r\n#graphics-editor-container.equipment-mode #selected-shape {\r\n    display: none !important;\r\n}\r\n\r\n/* Transform buttons */\r\n.graphics-editor__transform-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.graphics-editor__transform-buttons button {\r\n    flex: 1;\r\n}\r\n",
      "filePath": "/global/interfaces/html/graphicsEditor.html",
      "html": "<div id=\"graphics-editor-container\" class=\"editor-module\">\r\n   <div id=\"graphics-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n\r\n      <!-- Standard Graphics Editor Toolbar -->\r\n      <div id=\"toolbar\" class=\"editor-module__toolbar\">\r\n         <div id=\"graphics-toolbar\" class=\"editor-module__toolbar-group editor-module__flex-col editor-module__gap-sm\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-animation\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Animation\">+A</button>\r\n               <button id=\"delete-animation\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Animation\">-A</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-frame\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Frame\">+F</button>\r\n               <button id=\"delete-frame\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Frame\">-F</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"create-group\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Create Group\">+G</button>\r\n               <button id=\"delete-group\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Group\">-G</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"add-shape\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Shape\">+S</button>\r\n               <button id=\"delete-shape\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Delete Shape\">-S</button>\r\n            </div>\r\n         </div>\r\n         <div id=\"graphics-toolbar-right\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"preview-animation\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Preview Animation\">â–¶</button>\r\n               <button id=\"generate-isometric\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Generate Isometric Sprites\">Iso</button>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Toolbar -->\r\n         <div id=\"equipment-toolbar\" class=\"editor-module__toolbar-group\">\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-add-btn\" class=\"editor-module__btn editor-module__btn--secondary editor-module__btn--small\" title=\"Add Equipment\">+E</button>\r\n               <button id=\"equipment-remove-btn\" class=\"editor-module__btn editor-module__btn--danger editor-module__btn--small\" title=\"Remove Equipment\">-E</button>\r\n               <button id=\"equipment-reset-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Reset Position\">â†»</button>\r\n            </div>\r\n            <div class=\"editor-module__flex editor-module__gap-sm\">\r\n               <button id=\"equipment-mode-toggle\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Toggle Equipment Mode\">âš”</button>\r\n               <button id=\"equipment-save-btn\" class=\"editor-module__btn editor-module__btn--primary editor-module__btn--small\" title=\"Save Equipment\">ðŸ’¾</button>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- Standard Graphics Editor Lists -->\r\n      <div id=\"graphics-lists\" class=\"editor-module__scroll-y\">\r\n         <div id=\"frame-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"group-list\" class=\"editor-module__list\"></div>\r\n         <div id=\"shape-list\" class=\"editor-module__list\"></div>\r\n      </div>\r\n\r\n      <!-- Equipment Controls -->\r\n      <div id=\"equipment-controls\">\r\n\r\n         <!-- Add Equipment Section -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Add Equipment</h4>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Item:</label>\r\n               <select id=\"equipment-item-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Item...</option>\r\n               </select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Slot:</label>\r\n               <select id=\"equipment-slot-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Select Slot...</option>\r\n                  <option value=\"mainHand\">Main Hand</option>\r\n                  <option value=\"offHand\">Off Hand</option>\r\n                  <option value=\"head\">Head</option>\r\n                  <option value=\"chest\">Chest</option>\r\n                  <option value=\"back\">Back</option>\r\n                  <option value=\"legs\">Legs</option>\r\n                  <option value=\"feet\">Feet</option>\r\n               </select>\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment List -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment List</h4>\r\n            <div id=\"equipment-list\" class=\"graphics-editor__equipment-list editor-module__scroll-y\">\r\n               <div class=\"graphics-editor__no-equipment\">No equipment loaded</div>\r\n            </div>\r\n         </div>\r\n\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Canvas Container -->\r\n   <div id=\"canvas-container\" class=\"editor-module__canvas-area editor-module__grid-background\">\r\n      <canvas id=\"graphics-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n      <div class=\"editor-module__info\">\r\n         <div>Shapes: <span id=\"shape-count\">0</span></div>\r\n         <div>Selected: <span id=\"selected-shape\">None</span></div>\r\n         <div id=\"equipment-info\">Equipment: <span id=\"equipment-count\">0</span></div>\r\n         <div id=\"selected-equipment-info\">Selected: <span id=\"selected-equipment\">None</span></div>\r\n         <div><small>Controls: Left-click to select, Drag to rotate, Right-drag to pan, Scroll to zoom</small></div>\r\n      </div>\r\n   </div>\r\n\r\n   <!-- Right Sidebar -->\r\n   <div id=\"graphics-rightbar\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n\r\n      <!-- Standard Inspector -->\r\n      <div id=\"inspector\" class=\"editor-module__scroll-y\"></div>\r\n\r\n      <!-- Equipment Inspector -->\r\n      <div id=\"equipment-inspector\">\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Attachment</h4>\r\n\r\n            <div class=\"editor-module__form-row\">\r\n               <label class=\"editor-module__label\">Bone:</label>\r\n               <select id=\"equipment-bone-selector\" class=\"editor-module__select\">\r\n                  <option value=\"\">Auto-detect</option>\r\n               </select>\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Position Offset</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-offset-x\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-offset-y\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-offset-z\" class=\"editor-module__input\" step=\"0.01\" value=\"0\">\r\n            </div>\r\n\r\n            <h5 class=\"editor-module__section-title\">Rotation (degrees)</h5>\r\n            <div class=\"editor-module__form-row editor-module__form-row--compact\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">X:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-x\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Y:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-y\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n               <label class=\"editor-module__label editor-module__label--compact\">Z:</label>\r\n               <input type=\"number\" id=\"equipment-rotation-z\" class=\"editor-module__input\" step=\"1\" value=\"0\">\r\n            </div>\r\n\r\n            <div class=\"editor-module__message editor-module__message--warning\">\r\n               Select equipment to adjust positioning. Changes apply in real-time.\r\n            </div>\r\n         </div>\r\n\r\n         <!-- Equipment Properties -->\r\n         <div class=\"editor-module__panel\">\r\n            <h4 class=\"editor-module__panel-title\">Equipment Properties</h4>\r\n            <div id=\"equipment-property-list\">\r\n               <div class=\"graphics-editor__no-equipment\">Select equipment to view properties</div>\r\n            </div>\r\n         </div>\r\n      </div>\r\n\r\n      <!-- JSON Editor -->\r\n      <div id=\"json-editor\" style=\"display: none;\">\r\n        <textarea id=\"json-content\" class=\"editor-module__textarea editor-module__input\" placeholder=\"Edit JSON here...\"></textarea>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
    },
    "terrainEditor": {
      "title": "Terrain Editor",
      "modals": [
        "addTerrainType",
        "generateIsoSprites"
      ],
      "fileName": "terrainEditor",
      "css": "/* =============================================================================\r\n   TERRAIN EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#grid {\r\n    display: block;\r\n    image-rendering: pixelated;\r\n}\r\n\r\n/* Save button styling */\r\n.terrain-editor__save-btn {\r\n    width: 100%;\r\n    font-weight: 600;\r\n}\r\n\r\n/* Terrain list */\r\n.terrain-editor__terrain-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__terrain-item {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    background-color: rgba(255, 255, 255, 0.03);\r\n    border: 1px solid var(--editor-border-color);\r\n    cursor: move;\r\n    user-select: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__terrain-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__color-option {\r\n    width: 36px;\r\n    height: 36px;\r\n    min-width: 36px;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    border: 2px solid transparent;\r\n    flex-shrink: 0;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__color-option--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__terrain-label {\r\n    flex-grow: 1;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__terrain-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n}\r\n\r\n/* Object controls */\r\n.terrain-editor__object-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__object-controls button {\r\n    flex: 1;\r\n}\r\n\r\n/* Environment objects container */\r\n.terrain-editor__environment-objects {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__environment-type {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    overflow: hidden;\r\n    box-shadow: var(--editor-shadow-sm);\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.terrain-editor__environment-type:hover {\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-type-header {\r\n    padding: var(--editor-spacing-md);\r\n    font-weight: 500;\r\n    cursor: pointer;\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background-color: var(--editor-bg-medium);\r\n    color: var(--editor-text-secondary);\r\n    text-transform: capitalize;\r\n}\r\n\r\n.terrain-editor__environment-type-header::after {\r\n    content: 'â–¼';\r\n    font-size: 10px;\r\n    transition: transform 0.2s ease;\r\n}\r\n\r\n.terrain-editor__environment-type-header.open::after {\r\n    transform: rotate(180deg);\r\n}\r\n\r\n.terrain-editor__environment-items {\r\n    padding: var(--editor-spacing-md);\r\n    display: flex;\r\n    flex-wrap: wrap;\r\n    gap: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__environment-item {\r\n    width: 128px;\r\n    height: 128px;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    padding: 2px;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    background-color: var(--editor-bg-light);\r\n    transition: var(--editor-transition);\r\n    position: relative;\r\n}\r\n\r\n.terrain-editor__environment-item:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-2px);\r\n}\r\n\r\n.terrain-editor__environment-item--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n.terrain-editor__environment-item canvas {\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n    object-fit: contain;\r\n}\r\n\r\n/* Tooltip for environment items */\r\n.terrain-editor__environment-item::before {\r\n    content: attr(data-name);\r\n    position: absolute;\r\n    bottom: calc(100% + 5px);\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background-color: var(--editor-bg-dark);\r\n    color: var(--editor-text-primary);\r\n    text-align: center;\r\n    border-radius: var(--editor-border-radius-sm);\r\n    padding: var(--editor-spacing-xs) var(--editor-spacing-sm);\r\n    font-size: 12px;\r\n    white-space: nowrap;\r\n    visibility: hidden;\r\n    opacity: 0;\r\n    transition: var(--editor-transition);\r\n    z-index: 10;\r\n    pointer-events: none;\r\n    box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n.terrain-editor__environment-item:hover::before {\r\n    visibility: visible;\r\n    opacity: 1;\r\n}\r\n\r\n/* Object preview canvas (dragging) */\r\n#object-preview-canvas {\r\n    transition: transform 0.05s ease-out;\r\n    will-change: transform;\r\n    image-rendering: pixelated;\r\n    position: absolute;\r\n    pointer-events: none;\r\n    z-index: 9999;\r\n    opacity: 0.7;\r\n}\r\n\r\n/* Delete mode indicator */\r\n.terrain-editor--delete-mode .editor-module__canvas-area {\r\n    cursor: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"red\" stroke-width=\"2\"><path d=\"M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2\"/><path d=\"M10 11v6M14 11v6\"/></svg>'), auto;\r\n}\r\n\r\n/* Height level selector */\r\n.terrain-editor__height-levels {\r\n    display: grid;\r\n    grid-template-columns: repeat(3, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-md);\r\n}\r\n\r\n.terrain-editor__height-btn {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    background-color: var(--editor-bg-medium);\r\n    border: 1px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    color: var(--editor-text-secondary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n    font-size: 12px;\r\n    font-weight: 500;\r\n}\r\n\r\n.terrain-editor__height-btn:hover {\r\n    background-color: var(--editor-bg-light);\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.terrain-editor__height-btn.active {\r\n    background-color: var(--editor-primary);\r\n    border-color: var(--editor-primary);\r\n    color: white;\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}\r\n\r\n/* Tool buttons */\r\n.terrain-editor__tool-buttons {\r\n    display: flex;\r\n    gap: var(--editor-spacing-sm);\r\n    margin-top: var(--editor-spacing-xs);\r\n}\r\n\r\n.terrain-editor__tool-buttons button {\r\n    flex: 1;\r\n}\r\n\r\n/* Slider styling */\r\n.editor-module__slider {\r\n    flex: 1;\r\n    height: 4px;\r\n    border-radius: 2px;\r\n    background: var(--editor-bg-medium);\r\n    outline: none;\r\n    -webkit-appearance: none;\r\n    margin: 0 var(--editor-spacing-sm);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb {\r\n    -webkit-appearance: none;\r\n    appearance: none;\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb {\r\n    width: 16px;\r\n    height: 16px;\r\n    border-radius: 50%;\r\n    background: var(--editor-primary);\r\n    cursor: pointer;\r\n    border: none;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.editor-module__slider::-webkit-slider-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__slider::-moz-range-thumb:hover {\r\n    background: var(--editor-primary-hover);\r\n    transform: scale(1.2);\r\n}\r\n\r\n.editor-module__value-display {\r\n    min-width: 20px;\r\n    text-align: center;\r\n    font-weight: 500;\r\n    color: var(--editor-text-primary);\r\n}\r\n\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .terrain-editor__environment-items {\r\n        justify-content: center;\r\n    }\r\n\r\n    .terrain-editor__environment-item {\r\n        width: 80px;\r\n        height: 80px;\r\n    }\r\n\r\n    .terrain-editor__height-levels {\r\n        grid-template-columns: repeat(2, 1fr);\r\n    }\r\n}\r\n",
      "filePath": "/global/interfaces/html/terrainEditor.html",
      "html": "<div id=\"level-editor-container\" class=\"editor-module\">\r\n   <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n     <div class=\"editor-module__toolbar\">\r\n       <button id=\"terrainsBtn\" class=\"editor-module__btn editor-module__btn--active\">Tiles</button>\r\n       <button id=\"heightsBtn\" class=\"editor-module__btn\">Heights</button>\r\n       <button id=\"environmentBtn\" class=\"editor-module__btn\">Env</button>\r\n       <button id=\"rampsBtn\" class=\"editor-module__btn\">Ramps</button>\r\n       <button id=\"placementsBtn\" class=\"editor-module__btn\">Entities</button>\r\n     </div>\r\n\r\n     <div class=\"editor-module__scroll-y\">\r\n       <div id=\"terrainsPanel\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Map Settings</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"terrainMapSize\" class=\"editor-module__label\">Map Size:</label>\r\n             <input type=\"number\" id=\"terrainMapSize\" class=\"editor-module__input\" value=\"48\" step=\"1\" min=\"1\">\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n              <label for=\"extensionTerrainType\" class=\"editor-module__label\">Surrounding Type:</label>\r\n              <select id=\"extensionTerrainType\" class=\"editor-module__select extensionTerrainType\"></select>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n              <button id=\"saveMapBtn\" class=\"editor-module__btn editor-module__btn--success terrain-editor__save-btn\">ðŸ’¾ Save Map</button>\r\n            </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"terrainBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"terrainFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"terrainBrushSizeRow\">\r\n             <label for=\"terrainBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"terrainBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"terrainBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Terrain Types</h3>\r\n           <div class=\"terrain-editor__terrain-list\">\r\n             <!-- Terrain items will be dynamically populated here -->\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"environmentPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Environment Objects</h3>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small\" id=\"clear-selection-btn\">Clear Selection</button>\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"delete-mode-btn\">Delete Mode</button>\r\n           </div>\r\n           <div class=\"terrain-editor__environment-objects\"></div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"rampsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Ramp Placement</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Click on tiles to place/remove ramps. Ramps allow units to walk between different terrain heights.</p>\r\n             <p><strong>Current ramps:</strong> <span id=\"rampCount\">0</span></p>\r\n           </div>\r\n           <div class=\"terrain-editor__object-controls\">\r\n             <button class=\"editor-module__btn editor-module__btn--small editor-module__btn--danger\" id=\"clear-all-ramps-btn\">Clear All Ramps</button>\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"heightsPanel\" style=\"display: none;\">\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Height Map Editor</h3>\r\n           <div class=\"editor-module__info-box\">\r\n             <p>Paint height levels on the map. Heights are independent of terrain types.</p>\r\n             <p>Click on tiles to paint the selected height level.</p>\r\n           </div>\r\n           <div class=\"editor-module__form-row\">\r\n             <label for=\"heightLevel\" class=\"editor-module__label\">Height Level:</label>\r\n             <input type=\"number\" id=\"heightLevel\" class=\"editor-module__input\" value=\"0\" step=\"1\" min=\"0\" max=\"10\">\r\n           </div>\r\n           <div class=\"editor-module__section\">\r\n             <h4 class=\"editor-module__section-title\">Quick Select</h4>\r\n             <div class=\"terrain-editor__height-levels\" id=\"heightLevelButtons\">\r\n               <!-- Height level buttons will be dynamically populated here -->\r\n             </div>\r\n           </div>\r\n         </div>\r\n\r\n         <div class=\"editor-module__section\">\r\n           <h3 class=\"editor-module__section-title\">Tools</h3>\r\n           <div class=\"editor-module__form-row\">\r\n             <label class=\"editor-module__label\">Tool:</label>\r\n             <div class=\"terrain-editor__tool-buttons\">\r\n               <button id=\"heightBrushBtn\" class=\"editor-module__btn editor-module__btn--small editor-module__btn--active\">Brush</button>\r\n               <button id=\"heightFillBtn\" class=\"editor-module__btn editor-module__btn--small\">Fill</button>\r\n             </div>\r\n           </div>\r\n           <div class=\"editor-module__form-row\" id=\"heightBrushSizeRow\">\r\n             <label for=\"heightBrushSize\" class=\"editor-module__label\">Brush Size:</label>\r\n             <input type=\"range\" id=\"heightBrushSize\" class=\"editor-module__slider\" value=\"1\" step=\"1\" min=\"1\" max=\"5\">\r\n             <span id=\"heightBrushSizeValue\" class=\"editor-module__value-display\">1</span>\r\n           </div>\r\n         </div>\r\n       </div>\r\n\r\n       <div id=\"placementsPanel\" style=\"display: none;\">\r\n         <!-- Panel content will be dynamically generated by setupPlacementsPanel() -->\r\n       </div>\r\n     </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n     <canvas id=\"grid\" class=\"editor-module__canvas\"></canvas>\r\n\r\n     <div class=\"editor-module__status-bar\">\r\n       Cursor: x: 0, y: 0 | Zoom: 100% | Selected: Grass\r\n     </div>\r\n   </div>\r\n </div>\r\n"
    },
    "sceneEditor": {
      "title": "Scene Editor",
      "modals": [],
      "fileName": "sceneEditor",
      "css": "/* =============================================================================\r\n   SCENE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Scene view */\r\n.scene-editor__scene-view {\r\n    flex: 1;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n\r\n#scene-canvas-container {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#scene-editor-canvas {\r\n    cursor: crosshair;\r\n    outline: none;\r\n}\r\n\r\n/* No selection message */\r\n.scene-editor__no-selection {\r\n    text-align: center;\r\n    padding: var(--editor-spacing-xl);\r\n    color: var(--editor-text-muted);\r\n    font-style: italic;\r\n}\r\n\r\n/* Hierarchy item */\r\n.scene-editor__hierarchy-item {\r\n    padding: var(--editor-spacing-sm) var(--editor-spacing-md);\r\n    cursor: pointer;\r\n    border-left: 2px solid transparent;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.scene-editor__hierarchy-item:hover {\r\n    background-color: rgba(255, 255, 255, 0.05);\r\n}\r\n\r\n.scene-editor__hierarchy-item--selected {\r\n    background-color: var(--editor-primary);\r\n    border-left-color: var(--editor-primary-hover);\r\n    color: white;\r\n}\r\n\r\n/* Component styling */\r\n.scene-editor__component {\r\n    background-color: var(--editor-bg-light);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n    padding: var(--editor-spacing-md);\r\n}\r\n\r\n.scene-editor__component-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: var(--editor-spacing-sm);\r\n    font-weight: 600;\r\n    color: var(--editor-text-secondary);\r\n}\r\n",
      "filePath": "/global/interfaces/html/sceneEditor.html",
      "html": "<div id=\"scene-editor-container\" class=\"editor-module\">\r\n   <div id=\"scene-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n      <h2 class=\"editor-module__panel-title\">Hierarchy</h2>\r\n      <div id=\"scene-hierarchy\" class=\"editor-module__list editor-module__scroll-y\">\r\n        <!-- Entities will be populated here -->\r\n      </div>\r\n      <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n        <select id=\"scene-addPrefabSelect\" class=\"editor-module__select\"></select>\r\n        <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"scene-addPrefabBtn\">+ Add Prefab</button>\r\n        <button class=\"editor-module__btn editor-module__btn--danger\" id=\"scene-removePrefabBtn\">Remove Selected Prefab</button>\r\n      </div>\r\n   </div>\r\n\r\n   <div class=\"editor-module__canvas-area\">\r\n      <div class=\"editor-module__toolbar\">\r\n        <button id=\"scene-translate-tool\" class=\"editor-module__btn editor-module__btn--active\" title=\"Translate (G)\">\r\n            <span>Move</span>\r\n        </button>\r\n        <button id=\"scene-rotate-tool\" class=\"editor-module__btn\" title=\"Rotate (R)\">\r\n            <span>Rotate</span>\r\n        </button>\r\n        <button id=\"scene-scale-tool\" class=\"editor-module__btn\" title=\"Scale (S)\">\r\n            <span>Scale</span>\r\n        </button>\r\n      </div>\r\n      <div id=\"scene-view\" class=\"scene-editor__scene-view\">\r\n         <div id=\"scene-canvas-container\" class=\"editor-module__grid-background\">\r\n            <canvas id=\"scene-editor-canvas\" class=\"editor-module__canvas\"></canvas>\r\n         </div>\r\n      </div>\r\n   </div>\r\n\r\n   <div id=\"scene-inspector\" class=\"editor-module__sidebar editor-module__sidebar--right\">\r\n      <h2 class=\"editor-module__panel-title\">Inspector</h2>\r\n      <div class=\"editor-module__scroll-y\">\r\n        <div class=\"scene-editor__no-selection\" id=\"scene-noSelection\">\r\n          No entity selected\r\n        </div>\r\n        <div id=\"scene-entityInspector\" style=\"display: none;\">\r\n          <div id=\"scene-components\">\r\n            <!-- Components will be added here dynamically -->\r\n          </div>\r\n          <button class=\"editor-module__btn editor-module__btn--secondary\" id=\"addComponentBtn\">+ Add Component</button>\r\n        </div>\r\n      </div>\r\n   </div>\r\n</div>\r\n"
    },
    "scriptEditor": {
      "title": "Script Editor",
      "fileName": "scriptEditor",
      "css": "/* =============================================================================\r\n   SCRIPT EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Code container */\r\n.script-editor__code-container {\r\n    position: relative;\r\n    height: 100%;\r\n    width: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n}\r\n\r\n.script-editor__code {\r\n    flex: 1;\r\n    height: 100%;\r\n    font-family: 'Courier New', 'Monaco', 'Menlo', monospace;\r\n    font-size: 14px;\r\n    line-height: 1.5;\r\n}\r\n\r\n/* Override global scrollbar suppression for CodeMirror */\r\n#script-editor-container .CodeMirror {\r\n    overflow-y: auto !important;\r\n    -ms-overflow-style: auto !important;\r\n    scrollbar-width: auto !important;\r\n    height: 100%;\r\n    font-size: 14px;\r\n}",
      "filePath": "/global/interfaces/html/scriptEditor.html",
      "html": "<div id=\"script-editor-container\" class=\"editor-module\">\r\n    <div id=\"script-editor-sidebar\" class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Script Editor</h3>\r\n            <button id=\"save-script-btn\" class=\"editor-module__btn editor-module__btn--primary\">Save Script</button>\r\n        </div>\r\n    </div>\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <div class=\"script-editor__code-container\">\r\n            <textarea id=\"script-editor\" class=\"editor-module__textarea editor-module__input script-editor__code\" placeholder=\"Enter your script here...\"></textarea>\r\n            <div class=\"handle\"></div>\r\n        </div>\r\n    </div>\r\n</div>\r\n"
    },
    "TextureEditor": {
      "title": "Texture Editor",
      "fileName": "TextureEditor",
      "css": "/* =============================================================================\r\n   TEXTURE EDITOR - MODULE-SPECIFIC STYLES\r\n   ============================================================================= */\r\n\r\n/* Canvas specific styling */\r\n#texture-canvas {\r\n    background-color: transparent;\r\n    image-rendering: pixelated;\r\n    border: 1px solid var(--editor-border-color);\r\n    box-shadow: var(--editor-shadow-md);\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n}\r\n\r\n/* No texture message */\r\n.texture-editor__no-texture-message {\r\n    position: absolute;\r\n    left: 50%;\r\n    top: 50%;\r\n    transform: translate(-50%, -50%);\r\n    color: var(--editor-text-muted);\r\n    font-size: 14px;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Color palette grid */\r\n.texture-editor__color-palette {\r\n    display: grid;\r\n    grid-template-columns: repeat(4, 1fr);\r\n    gap: var(--editor-spacing-sm);\r\n    margin-bottom: var(--editor-spacing-md);\r\n}\r\n\r\n.texture-editor__color-btn {\r\n    width: 100%;\r\n    aspect-ratio: 1;\r\n    border: 2px solid var(--editor-border-color);\r\n    border-radius: var(--editor-border-radius-sm);\r\n    cursor: pointer;\r\n    transition: var(--editor-transition);\r\n}\r\n\r\n.texture-editor__color-btn:hover {\r\n    border-color: var(--editor-border-color-hover);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.texture-editor__color-btn--active {\r\n    border-color: var(--editor-primary);\r\n    box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.3);\r\n}",
      "filePath": "/global/interfaces/html/TextureEditor.html",
      "html": "<div id=\"texture-editor-container\" class=\"editor-module\">\r\n    <div class=\"editor-module__sidebar editor-module__sidebar--left\">\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Tools</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"brush-tool\" class=\"editor-module__btn editor-module__btn--active\">Brush</button>\r\n                <button id=\"eraser-tool\" class=\"editor-module__btn\">Eraser</button>\r\n                <button id=\"fill-tool\" class=\"editor-module__btn\">Fill</button>\r\n                <button id=\"eyedropper-tool\" class=\"editor-module__btn\">Eyedropper</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Brush Size</h3>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"range\" id=\"brush-size\" class=\"editor-module__range\" min=\"1\" max=\"10\" value=\"1\">\r\n                <span id=\"brush-size-display\">1px</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Colors</h3>\r\n            <div id=\"color-palette\" class=\"texture-editor__color-palette\"></div>\r\n            <div class=\"editor-module__form-row\">\r\n                <input type=\"color\" id=\"custom-color-picker\" class=\"editor-module__color-picker\" value=\"#000000\">\r\n                <label for=\"custom-color-picker\" class=\"editor-module__label\">Custom Color</label>\r\n            </div>\r\n            <div class=\"editor-module__form-row\">\r\n                <label for=\"transparency-slider\" class=\"editor-module__label\">Opacity:</label>\r\n                <input type=\"range\" id=\"transparency-slider\" class=\"editor-module__range\" min=\"0\" max=\"255\">\r\n                <span id=\"transparency-display\">100%</span>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Actions</h3>\r\n            <div class=\"editor-module__toolbar editor-module__toolbar--vertical\">\r\n                <button id=\"new-btn\" class=\"editor-module__btn\">New</button>\r\n                <button id=\"undo-btn\" class=\"editor-module__btn\" disabled>Undo</button>\r\n                <button id=\"redo-btn\" class=\"editor-module__btn\" disabled>Redo</button>\r\n                <button id=\"clear-btn\" class=\"editor-module__btn editor-module__btn--danger\">Clear</button>\r\n                <button class=\"export-btn editor-module__btn editor-module__btn--primary\">Save</button>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"editor-module__section\">\r\n            <h3 class=\"editor-module__section-title\">Import</h3>\r\n            <input type=\"file\" class=\"editor-module__input\" accept=\"image/*\">\r\n        </div>\r\n    </div>\r\n\r\n    <div class=\"editor-module__canvas-area editor-module__grid-background\">\r\n        <canvas id=\"texture-canvas\" class=\"editor-module__canvas\"></canvas>\r\n        <div id=\"noTextureMessage\" class=\"texture-editor__no-texture-message\">No texture loaded</div>\r\n    </div>\r\n</div>\r\n"
    },
    "createOrJoinRoom": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/createOrJoinRoom.html",
      "fileName": "createOrJoinRoom",
      "html": "<div class=\"setup-content\" style=\"background: #1a1a1a; padding: 2rem; border: 2px solid #444; border-radius: 10px; text-align: center; color: white;\">\r\n    <h2>âš”ï¸ Arena âš”ï¸</h2>\r\n    <p>Battle against another player in real-time strategic combat.</p>\r\n    \r\n    <div class=\"player-name-input\" style=\"margin: 1rem 0;\">\r\n        <label for=\"playerName\">Your Name:</label><br>\r\n        <input type=\"text\" id=\"playerName\" placeholder=\"Enter your name\" maxlength=\"20\" value=\"Player\" \r\n                style=\"padding: 0.5rem; margin: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n    </div>\r\n    \r\n    <div class=\"multiplayer-options\" style=\"margin: 1.5rem 0;\">\r\n            <button id=\"createRoomBtn\" class=\"btn btn-primary\" style=\"padding: 0.75rem 1.5rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px;\">Create Room</button><br>\r\n            <div class=\"room-join-section\" style=\"margin-top: 1rem;\">\r\n                <input type=\"text\" id=\"roomIdInput\" value=\"1000\" placeholder=\"Enter Room ID\" maxlength=\"6\" \r\n                        style=\"padding: 0.5rem; border: 1px solid #666; background: #333; color: white;\">\r\n                <button id=\"joinRoomBtn\" class=\"btn btn-secondary\" \r\n                        style=\"padding: 0.5rem 1rem; margin-left: 0.5rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Join Room</button>\r\n            </div>\r\n                    <button id=\"quickMatchBtn\" class=\"btn btn-primary\" \r\n                style=\"padding: 1rem 2rem; margin: 0.5rem; background: #0066cc; border: none; color: white; cursor: pointer; border-radius: 5px; font-size: 1.2rem;\">\r\n            ðŸŽ¯ Find Game\r\n        </button>\r\n        <p style=\"color: #999; font-size: 0.9rem; margin-top: 1rem;\">\r\n            You'll be matched with an available opponent or<br>\r\n            wait for another player to join your game.\r\n        </p>\r\n    </div>\r\n    \r\n    <button id=\"cancelMultiplayerBtn\" class=\"btn btn-secondary\" \r\n            style=\"padding: 0.5rem 1rem; background: #666; border: none; color: white; cursor: pointer; border-radius: 5px;\">Cancel</button>\r\n</div>"
    },
    "main": {
      "title": "Main Interface",
      "modals": [],
      "fileName": "main",
      "css": "/* Import fantasy fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&display=swap');\r\n\r\n/* === RESET & BASE === */\r\n* {\r\n    margin: 0;\r\n    padding: 0;\r\n    box-sizing: border-box;\r\n}\r\n\r\n:root {\r\n    /* Fantasy Color Palette */\r\n    --primary-gold: #d4af37;\r\n    --secondary-gold: #b8860b;\r\n    --accent-amber: #daa520;\r\n    --deep-forest: #1b3d1b;\r\n    --medium-forest: #2d4a2b;\r\n    --light-forest: #3d5a3b;\r\n    --forest-brown: #4a3f2a;\r\n    --dark-brown: #3d2f1f;\r\n    --medium-brown: #5d4037;\r\n    --light-brown: #6d4c41;\r\n    --stone-gray: #8d7053;\r\n    --warm-gray: #a68b5b;\r\n    --cream: #f5e6b3;\r\n    --dark-green: #0f2f0f;\r\n    --blood-red: #8b0000;\r\n    --dark-bronze: #8B7355;\r\n    --mystic-blue: #4169E1;\r\n    --rich-purple: #8A2BE2;\r\n    --shadow-black: #000000;\r\n    --parchment: #F5E6B3;\r\n    --forest-green: #1b5e20;\r\n    \r\n    /* Gradients */\r\n    --gold-gradient: linear-gradient(135deg, var(--primary-gold), var(--secondary-gold));\r\n    --forest-gradient: linear-gradient(135deg, var(--deep-forest), var(--medium-forest));\r\n    --earth-gradient: linear-gradient(135deg, var(--dark-brown), var(--medium-brown));\r\n    --natural-gradient: linear-gradient(135deg, var(--forest-brown), var(--medium-brown));\r\n    --command-gradient: linear-gradient(135deg, var(--dark-brown), var(--forest-brown));\r\n    \r\n    /* Typography */\r\n    --font-decorative: 'Cinzel Decorative', serif;\r\n    --font-title: 'Cinzel', serif;\r\n    --font-body: 'MedievalSharp', cursive;\r\n}\r\n\r\nbody {\r\n    font-family: var(--font-body);\r\n    background-color: var(--dark-green);\r\n    color: var(--cream);\r\n    overflow: hidden;\r\n    height: 100vh;\r\n}\r\n\r\n/* Screen Management */\r\n.screen {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100vh;\r\n    display: none;\r\n    justify-content: center;\r\n    align-items: center;\r\n    flex-direction: column;\r\n}\r\n\r\n.screen.active {\r\n    display: flex;\r\n}\r\n\r\n/* Main Menu Screen */\r\n#mainMenu {\r\n    text-align: center;\r\n}\r\n\r\n#mainMenu, #gameModeSelect, #multiplayerLobby {\r\n    background-color: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.3));\r\n    background-image: url('resources/images/background.png');\r\n    background-size: cover;\r\n    background-position: center center;\r\n    background-repeat: no-repeat;\r\n    overflow-y: auto;\r\n    padding: 2rem;\r\n}\r\n\r\nbody.bg2 #mainMenu, body.bg2 #gameModeSelect, body.bg2 #multiplayerLobby {\r\n    background-image: url('resources/images/background2.png');\r\n}\r\n\r\nbody.bg3 #mainMenu, body.bg3 #gameModeSelect, body.bg3 #multiplayerLobby {\r\n    background-image: url('resources/images/background3.png');\r\n}\r\n\r\n\r\nbody.bg4 #mainMenu, body.bg4 #gameModeSelect, body.bg4 #multiplayerLobby {\r\n    background-image: url('resources/images/background4.png');\r\n}\r\n\r\nbody.bg5 #mainMenu, body.bg5 #gameModeSelect, body.bg5 #multiplayerLobby {\r\n    background-image: url('resources/images/background5.png');\r\n}\r\n\r\n.game-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: clamp(2.5rem, 8vw, 5rem);\r\n    font-weight: 700;\r\n    color: var(--primary-gold);\r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    animation: titleGlow 3s ease-in-out infinite alternate;\r\n    position: relative;\r\n}\r\n\r\n@keyframes titleGlow {\r\n    from {\r\n        filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.5));\r\n    }\r\n    to {\r\n        filter: drop-shadow(0 0 30px rgba(212, 175, 55, 0.8));\r\n    }\r\n}\r\n\r\n.subtitle {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--cream);\r\n    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);\r\n    margin-bottom: 3rem;\r\n    font-style: italic;\r\n}\r\n\r\n\r\n.main-menu-buttons {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 1rem;\r\n    min-width: 300px;\r\n}\r\n\r\n\r\n\r\n/* Game Mode Selection */\r\n.mode-selection {\r\n    text-align: center;\r\n    max-width: 1000px;\r\n    width: 100%;\r\n}\r\n\r\n.mode-selection h2 {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 2rem;    \r\n    text-shadow: 2px 2px 3px var(--dark-green);\r\n}\r\n\r\n.mode-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.mode-card {\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.8), rgba(13, 10, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 12px;\r\n    padding: 2rem;\r\n    cursor: pointer;\r\n    transition: all 0.4s ease;\r\n    text-align: center;\r\n    position: relative;\r\n    overflow: hidden;\r\n}\r\n.mode-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -50%;\r\n    left: -50%;\r\n    width: 200%;\r\n    height: 200%;\r\n    background: radial-gradient(circle, rgba(212, 175, 55, 0.1) 0%, transparent 70%);\r\n    opacity: 0;\r\n    transition: opacity 0.4s ease;\r\n    z-index: 0;\r\n}\r\n\r\n.mode-card:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.mode-card:hover {\r\n    transform: translateY(-8px) scale(1.02);\r\n    border-color: var(--primary-gold);\r\n    box-shadow: \r\n        0 15px 40px rgba(212, 175, 55, 0.2),\r\n        0 0 30px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.mode-card.selected {\r\n    border-color: var(--accent-amber);\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.4),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.1);\r\n}\r\n\r\n.mode-card > * {\r\n    position: relative;\r\n    z-index: 1;\r\n}\r\n\r\n.mode-icon {\r\n    font-size: 3.5rem;\r\n    margin-bottom: 1rem;\r\n    display: block;\r\n}\r\n\r\n.mode-title {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.mode-description {\r\n    font-size: 0.95rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 1.2rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.mode-difficulty {\r\n    display: inline-block;\r\n    padding: 0.4rem 1rem;\r\n    border-radius: 20px;\r\n    font-size: 0.8rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.easy { \r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.medium { \r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    color: var(--shadow-black);\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.hard { \r\n    background: linear-gradient(135deg, var(--blood-red), #c62828);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(183, 28, 28, 0.3);\r\n}\r\n\r\n.expert { \r\n    background: linear-gradient(135deg, var(--rich-purple), #6a1b9a);\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 10px rgba(74, 20, 140, 0.3);\r\n}\r\n\r\n/* Game Screen */\r\n#gameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#gameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#canvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#gameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.08) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(139, 0, 0, 0.08) 0%, transparent 50%),\r\n        #2a3a2a;\r\n    border-left: 2px solid var(--medium-brown);\r\n    cursor: crosshair;\r\n}\r\n\r\n#miniMapContainer {\r\n    min-width: 200px;\r\n    width: 200px;\r\n    height: 200px;\r\n    rotate: -45deg;\r\n    margin: 2em;\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.1rem;\r\n}\r\n\r\n#actionPanel {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    min-height: 200px;\r\n    min-width: 200px;\r\n    max-width: 200px;\r\n    max-height: 200px;\r\n}\r\n\r\n#selectedUnits {\r\n  max-height: 200px;\r\n  width: 100%;\r\n  display: flex;\r\n  gap: .5em;\r\n  pointer-events: none !important;\r\n  flex-wrap: wrap;\r\n}\r\n\r\n#selectedUnits > div {\r\n    display: flex;\r\n    width: 32px;\r\n    height: 32px;\r\n    pointer-events: all;\r\n}\r\n\r\n#selectedUnits > div > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n#selectedUnits > div.selected {\r\n    border: 2px solid  rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n}\r\n\r\n#unitPortrait {\r\n    background: rgba(20, 20, 30, 0.9);\r\n    border: 2px solid rgba(255, 170, 0, 0.3);\r\n    border-radius: 8px;\r\n    height: 128px;\r\n    width: 128px;\r\n    min-width: 128px;\r\n    max-width: 128px;\r\n}\r\n\r\n#unitPortrait > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n#gameControls {\r\n    position: absolute;\r\n    bottom: calc(200px + 2em);\r\n    right: 1em;\r\n    width: 200px;\r\n    margin: auto;\r\n}\r\n#undoBtn { display: none;}\r\n#uiContainer {\r\n    pointer-events: none;\r\n    display: flex;\r\n    position: absolute;\r\n    bottom: 1em;\r\n    left: 1em;\r\n    right: 1em;\r\n    align-items: flex-end;\r\n    gap: 1em;\r\n    justify-content: space-between;\r\n}\r\n#uiContainer > div {\r\n    pointer-events: all;\r\n}\r\n/* Buttons */\r\n.btn {\r\n    background: var(--gold-gradient);\r\n    color: var(--shadow-black);\r\n    border: 2px solid var(--secondary-gold);\r\n    padding: 12px 30px;\r\n    font-family: var(--font-title);\r\n    font-weight: 600;\r\n    font-size: 14px;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    cursor: pointer;\r\n    border-radius: .5em;\r\n    position: relative;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.btn::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    z-index: -1;\r\n    opacity: 0;\r\n    transition: opacity 0.3s ease;\r\n    border-radius: .5em;\r\n}\r\n\r\n.btn:hover::before {\r\n    opacity: 1;\r\n}\r\n\r\n.btn:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.4);\r\n}\r\n\r\n.btn:active {\r\n    transform: translateY(0);\r\n}\r\n\r\n.btn-secondary {\r\n    background: var(--mystical-gradient);\r\n    color: var(--parchment);\r\n    border-color: var(--mystic-blue);\r\n}\r\n\r\n.btn-secondary:hover {\r\n    box-shadow: 0 8px 20px rgba(21, 101, 192, 0.4);\r\n}\r\n\r\n.btn-danger {\r\n    background: linear-gradient(135deg, var(--blood-red), #d32f2f);\r\n    color: var(--parchment);\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.btn-danger:hover {\r\n    box-shadow: 0 8px 20px rgba(183, 28, 28, 0.4);\r\n}\r\n\r\n/* UI Components for Game */\r\n#resourcesContainer {\r\n    display: flex;\r\n    gap: 1em;\r\n    position: absolute;\r\n    top: 1em;\r\n    right: 1em;\r\n}\r\n.resource-label {\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.resource-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-size: 1.1rem;\r\n    text-shadow: 0 0 5px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.unit-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    cursor: pointer;\r\n    text-align: center;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n    overflow: hidden;\r\n    animation: cardSlideIn 0.3s ease-out;\r\n}\r\n\r\n.unit-card::before {\r\n    content: '';\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(212, 175, 55, 0.2), transparent);\r\n    transition: left 0.5s ease;\r\n}\r\n\r\n.unit-card:hover::before {\r\n    left: 100%;\r\n}\r\n\r\n.unit-card:hover {\r\n    border-color: var(--primary-gold);\r\n    transform: translateY(-3px) scale(1.02);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.3), 0 0 15px rgba(212, 175, 55, 0.2);\r\n}\r\n.unit-card:hover .shimmer {\r\n    left: 100%;\r\n}\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1);\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3));\r\n    transform: translateY(-3px) scale(1.02);\r\n}\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n.unit-card.disabled {\r\n    opacity: 0.4;\r\n    cursor: not-allowed;\r\n    filter: grayscale(0.7);\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none;\r\n    border-color: var(--dark-bronze);\r\n    box-shadow: none;\r\n}\r\n.unit-card.disabled:hover .shimmer {\r\n    left: -100%;\r\n}\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n.unit-card.disabled:hover .unit-icon {\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    border-color: var(--dark-bronze);\r\n    transform: scale(1);\r\n}\r\n/* Add these CSS styles to your main.css or in a <style> tag */\r\n\r\n/* Unit Icon Styles */\r\n.unit-icon {\r\n    width: 24px;\r\n    height: 24px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 6px;\r\n    border-radius: 3px;\r\n    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\r\n    transition: all 0.2s ease;\r\n    border: 1px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.2);\r\n}\r\n\r\n/* Hover effects for icons */\r\n.unit-card:hover .unit-icon {\r\n    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);\r\n    border-color: var(--primary-gold);\r\n    transform: scale(1.05);\r\n}\r\n\r\n/* Selected card icon effects */\r\n.unit-card.selected .unit-icon {\r\n    box-shadow: 0 0 12px rgba(255, 140, 0, 0.6);\r\n    border-color: var(--accent-amber);\r\n    transform: scale(1.1);\r\n}\r\n\r\n/* Disabled card icon effects */\r\n.unit-card.disabled .unit-icon {\r\n    filter: grayscale(1) brightness(0.6);\r\n    opacity: 0.5;\r\n}\r\n\r\n/* Alternative styling for larger icons if you prefer */\r\n.unit-icon-large {\r\n    width: 32px;\r\n    height: 32px;\r\n    object-fit: cover;\r\n    vertical-align: middle;\r\n    margin-right: 8px;\r\n    border-radius: 4px;\r\n    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    background: rgba(0, 0, 0, 0.3);\r\n}\r\n\r\n/* Icon error handling - fallback styling */\r\n.unit-icon:not([src]),\r\n.unit-icon[src=\"\"] {\r\n    background: linear-gradient(45deg, var(--dark-bronze), var(--primary-gold));\r\n    display: inline-block;\r\n    position: relative;\r\n}\r\n\r\n.unit-icon:not([src])::before,\r\n.unit-icon[src=\"\"]::before {\r\n    content: \"âš”ï¸\";\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n    font-size: 16px;\r\n}\r\n\r\n/* Rarity-based icon effects */\r\n.unit-card.rarity-rare:hover {\r\n    border-color: #4169E1;\r\n    box-shadow: 0 8px 20px rgba(65, 105, 225, 0.4), 0 0 15px rgba(65, 105, 225, 0.2);\r\n}\r\n\r\n.unit-card.rarity-epic:hover {\r\n    border-color: #8A2BE2;\r\n    box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4), 0 0 15px rgba(138, 43, 226, 0.2);\r\n}\r\n\r\n.unit-card.rarity-legendary:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 8px 20px rgba(212, 175, 55, 0.6), 0 0 20px rgba(255, 215, 0, 0.4);\r\n}\r\n\r\n/* Rarity background effects */\r\n.unit-card.rarity-rare {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(65, 105, 225, 0.3) 0%, transparent 70%);\r\n    border-color: #4169E1;\r\n}\r\n\r\n.unit-card.rarity-epic {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(138, 43, 226, 0.3) 0%, transparent 70%);\r\n    border-color: #8A2BE2;\r\n}\r\n\r\n.unit-card.rarity-legendary {\r\n    background: \r\n        linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8)),\r\n        radial-gradient(circle at center, rgba(255, 215, 0, 0.3) 0%, transparent 70%);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Legendary border animation */\r\n.unit-card.rarity-legendary .legendary-border {\r\n    position: absolute;\r\n    top: -2px;\r\n    left: -2px;\r\n    right: -2px;\r\n    bottom: -2px;\r\n    border-radius: 10px;\r\n    background: linear-gradient(45deg, var(--primary-gold), var(--accent-amber), var(--primary-gold));\r\n    animation: legendaryBorder 3s ease-in-out infinite;\r\n    z-index: -1;\r\n    pointer-events: none;\r\n}\r\n\r\n/* Unit cost color states */\r\n.unit-cost.cost-affordable {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.unit-cost.cost-unaffordable {\r\n    color: var(--blood-red);\r\n}\r\n\r\n@keyframes cardSlideIn {\r\n    from {\r\n        opacity: 0;\r\n        transform: translateY(20px);\r\n    }\r\n    to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n    }\r\n}\r\n/* Responsive adjustments */\r\n@media (max-width: 768px) {\r\n    .unit-icon {\r\n        width: 20px;\r\n        height: 20px;\r\n        margin-right: 4px;\r\n    }\r\n}\r\n\r\n/* Loading placeholder for icons */\r\n.unit-icon[loading] {\r\n    background: linear-gradient(90deg, \r\n        rgba(212, 175, 55, 0.1) 25%, \r\n        rgba(212, 175, 55, 0.2) 50%, \r\n        rgba(212, 175, 55, 0.1) 75%);\r\n    background-size: 200% 100%;\r\n    animation: shimmer 2s infinite;\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { background-position: -200% 0; }\r\n    100% { background-position: 200% 0; }\r\n}\r\n.unit-name {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    margin-bottom: 6px;\r\n    font-size: 0.9rem;\r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: space-between;\r\n}\r\n\r\n.unit-name img {\r\n    width: 24px; \r\n    height: 24px; \r\n    object-fit: cover; \r\n    vertical-align: middle; \r\n    margin-right: 6px; \r\n    border-radius: 3px;\r\n}\r\n\r\n.unit-cost {\r\n    color: var(--accent-amber); \r\n    font-size: 0.8rem; \r\n    margin-bottom: 6px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-stats {\r\n    font-size: 0.75rem; \r\n    line-height: 1.2;\r\n}\r\n\r\n.spec-unit-preview {\r\n    margin-top: 8px;\r\n    padding: 6px;\r\n    background: rgba(255, 170, 0, 0.1);\r\n    border-radius: 4px;\r\n    font-size: 10px;\r\n    color: #ffaa00;\r\n    position: relative;\r\n    z-index: 2;\r\n    border: 1px solid rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.army-list {\r\n    max-height: 200px;\r\n    overflow-y: auto;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 0.8rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n.army-unit {\r\n    padding: 0.8rem;\r\n    margin: 0.3rem 0;\r\n    background: \r\n        linear-gradient(135deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border-radius: 6px;\r\n    border: 1px solid var(--dark-bronze);\r\n    color: var(--parchment);\r\n    font-size: 0.85rem;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.army-unit:hover {\r\n    border-color: var(--primary-gold);\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);\r\n}\r\n\r\n.stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.stat-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.ready-status {\r\n    font-weight: bold;\r\n}\r\n\r\n.connection-good {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.connection-waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.connection-bad {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Ready Button - Make it prominent */\r\n.ready-btn {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 3px solid #388e3c;\r\n    padding: 1rem 2rem;\r\n    border-radius: 8px;\r\n    font-weight: bold;\r\n    cursor: pointer;\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.1rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n    transition: all 0.3s ease;\r\n    box-shadow: \r\n        0 0 20px rgba(27, 94, 32, 0.3),\r\n        0 4px 15px rgba(27, 94, 32, 0.2);\r\n    animation: readyPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.ready-btn:hover {\r\n    background: linear-gradient(135deg, #2e7d32, #388e3c);\r\n    transform: translateY(-3px) scale(1.05);\r\n    box-shadow: \r\n        0 0 30px rgba(27, 94, 32, 0.5),\r\n        0 8px 25px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.ready-btn:disabled {\r\n    background: var(--stone-gray);\r\n    color: #666;\r\n    border-color: #666;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n    animation: none;\r\n    box-shadow: none;\r\n}\r\n\r\n.ready-btn.ready-state {\r\n    background: linear-gradient(135deg, var(--accent-amber), #f57c00);\r\n    border-color: var(--accent-amber);\r\n    animation: readyGlow 1.5s ease-in-out infinite alternate;\r\n}\r\n\r\n/* Multiplayer Lobby Enhancements */\r\n.multiplayer-lobby-container {\r\n    max-width: 900px;\r\n    width: 100%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border-radius: 15px;\r\n    padding: 2rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.lobby-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 2.5rem;\r\n    background: var(--gold-gradient);\r\n    -webkit-background-clip: text;\r\n    -webkit-text-fill-color: transparent;\r\n    background-clip: text;\r\n    margin-bottom: 1rem;\r\n    text-align: center;\r\n}\r\n\r\n.room-info {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.room-id-display {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 1rem;\r\n}\r\n\r\n.room-label {\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.room-id {\r\n    font-family: var(--font-title);\r\n    color: var(--accent-amber);\r\n    font-size: 1.2rem;\r\n    font-weight: bold;\r\n    letter-spacing: 2px;\r\n}\r\n\r\n.connection-status {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.status-indicator {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n}\r\n\r\n/* Players Section */\r\n.players-section {\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.players-section h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.8rem;\r\n    margin-bottom: 1.5rem;\r\n    text-align: center;\r\n}\r\n\r\n.players-grid {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 1.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n.player-card {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    position: relative;\r\n}\r\n\r\n.player-card.ready {\r\n    border-color: var(--forest-green);\r\n    box-shadow: 0 0 20px rgba(27, 94, 32, 0.3);\r\n}\r\n\r\n.player-card.waiting {\r\n    border-color: var(--accent-amber);\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.3);\r\n}\r\n\r\n.player-card.empty {\r\n    border-color: var(--stone-gray);\r\n    opacity: 0.6;\r\n    border-style: dashed;\r\n}\r\n\r\n.player-name {\r\n    font-family: var(--font-title);\r\n    font-size: 1.2rem;\r\n    color: var(--primary-gold);\r\n    margin-bottom: 0.8rem;\r\n    font-weight: 600;\r\n}\r\n\r\n.player-status {\r\n    font-size: 1rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.player-status.ready {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.player-status.waiting {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.player-status.empty {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.player-stats {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.lobby-status {\r\n    margin-bottom: 2rem;\r\n    text-align: center;\r\n}\r\n\r\n.status-message {\r\n    font-size: 1.3rem;\r\n    color: var(--accent-amber);\r\n    margin-bottom: 1rem;\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-progress {\r\n    margin-top: 1rem;\r\n}\r\n\r\n.progress-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin-bottom: 0.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.progress-fill {\r\n    height: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    width: 0%;\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.progress-text {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.game-info h3 {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 1rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.game-settings {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.setting {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.setting-label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.setting-value {\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n}\r\n\r\n.lobby-footer {\r\n    border-top: 1px solid var(--dark-bronze);\r\n    padding-top: 2rem;\r\n}\r\n\r\n/* Enhanced Lobby Controls */\r\n.lobby-controls {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    gap: 2rem;\r\n    margin-bottom: 2rem;\r\n    padding: 1.5rem;\r\n    background: rgba(0, 0, 0, 0.2);\r\n    border-radius: 10px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.lobby-controls-left {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n.lobby-controls-right {\r\n    display: flex;\r\n    gap: 1rem;\r\n}\r\n\r\n\r\n/* Retreat button - less prominent */\r\n#leaveLobbyBtn {\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 2px solid #757575;\r\n    padding: 0.8rem 1.5rem;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n#leaveLobbyBtn:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.lobby-tips {\r\n    color: var(--stone-gray);\r\n    font-size: 0.9rem;\r\n    line-height: 1.4;\r\n}\r\n\r\n.lobby-tips p {\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n/* Multiplayer Game Screen Styles */\r\n#multiplayerGameScreen {\r\n    background: var(--shadow-black);\r\n    justify-content: flex-start;\r\n    align-items: flex-start;\r\n}\r\n\r\n#multiplayerGameContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    position: relative;\r\n}\r\n\r\n#multiplayerCanvasContainer {\r\n    position: absolute;\r\n    width: calc(100% - 380px);\r\n    height: 100%;\r\n    left: 0;\r\n    top: 0;\r\n}\r\n\r\n#multiplayerGameCanvas {\r\n    width: 100%;\r\n    height: 100%;\r\n    background: \r\n        radial-gradient(circle at 30% 70%, rgba(27, 94, 32, 0.1) 0%, transparent 50%),\r\n        radial-gradient(circle at 70% 30%, rgba(183, 28, 28, 0.1) 0%, transparent 50%),\r\n        #111111;\r\n    cursor: crosshair;\r\n}\r\n\r\n.opponent-overlay {\r\n    position: absolute;\r\n    top: 10px;\r\n    right: 10px;\r\n    z-index: 100;\r\n}\r\n\r\n.opponent-info-card {\r\n    background: rgba(0, 0, 0, 0.9);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    min-width: 250px;\r\n    color: var(--parchment);\r\n}\r\n\r\n.opponent-info-card h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.8rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-details {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.5rem;\r\n}\r\n\r\n.opponent-details > div {\r\n    display: flex;\r\n    justify-content: space-between;\r\n}\r\n\r\n.opponent-details .label {\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.status-deploying { color: var(--accent-amber); }\r\n.status-ready { color: var(--forest-green); }\r\n.status-battling { color: var(--blood-red); }\r\n\r\n#multiplayerUIContainer {\r\n    position: absolute;\r\n    right: 0;\r\n    top: 0;\r\n    width: 380px;\r\n    height: 100%;\r\n    background: \r\n        linear-gradient(180deg, rgba(26, 13, 26, 0.95) 0%, rgba(13, 10, 26, 0.95) 50%, rgba(26, 10, 13, 0.95) 100%);\r\n    border-left: 3px solid var(--primary-gold);\r\n    padding: 1.5rem;\r\n    overflow-y: auto;\r\n}\r\n\r\n.multiplayer-player-panel {\r\n    background: \r\n        linear-gradient(145deg, rgba(114, 47, 55, 0.2), rgba(74, 20, 140, 0.2)),\r\n        radial-gradient(circle at center, rgba(212, 175, 55, 0.05) 0%, transparent 70%);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 1.5rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-resources {\r\n    background: \r\n        linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    padding: 1rem;\r\n    border-radius: 8px;\r\n    margin-bottom: 1.5rem;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.multiplayer-unit-shop {\r\n    display: grid;\r\n    grid-template-columns: 1fr 1fr;\r\n    gap: 0.8rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.multiplayer-game-controls {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.multiplayer-phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.versus-info {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.5rem;\r\n    font-size: 0.9rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-indicator {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n}\r\n\r\n.vs {\r\n    color: var(--accent-amber);\r\n    font-weight: bold;\r\n}\r\n\r\n.opponent-indicator {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n}\r\n\r\n.multiplayer-phase-info .phase-title {\r\n    font-size: 1.5rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.5rem;\r\n    text-align: center;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.phase-info {\r\n    position: absolute;\r\n    bottom: 2rem;\r\n    left: 2rem;\r\n    background: linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border: 3px solid var(--accent-amber);\r\n    border-radius: 12px;\r\n    padding: 1.5rem;\r\n    text-align: center;\r\n    min-width: 250px;\r\n    box-shadow: \r\n        0 0 30px rgba(255, 140, 0, 0.2),\r\n        inset 0 0 20px rgba(255, 140, 0, 0.05);\r\n}\r\n\r\n.phase-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 1.8rem;\r\n    color: var(--accent-amber);\r\n    text-shadow: 0 0 15px rgba(255, 140, 0, 0.5);\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n.phase-timer {\r\n    font-family: var(--font-title);\r\n    font-size: 1.4rem;\r\n    color: var(--primary-gold);\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n}\r\n\r\n.round-info {\r\n    color: var(--mystic-blue);\r\n    font-family: var(--font-title);\r\n    font-size: 1.1rem;\r\n    margin-bottom: 0.8rem;\r\n}\r\n\r\n/* Victory/Defeat Screens */\r\n#victoryScreen, #defeatScreen {\r\n    text-align: center;\r\n}\r\n\r\n#victoryScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(27, 94, 32, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n#defeatScreen {\r\n    background: \r\n        radial-gradient(circle at center, rgba(183, 28, 28, 0.2) 0%, transparent 70%),\r\n        var(--shadow-gradient);\r\n}\r\n\r\n.result-content {\r\n    max-width: 600px;\r\n    width: 90%;\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.9), rgba(13, 10, 26, 0.9));\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    border: 3px solid var(--primary-gold);\r\n    box-shadow: \r\n        0 0 40px rgba(212, 175, 55, 0.2),\r\n        inset 0 0 40px rgba(212, 175, 55, 0.05);\r\n}\r\n\r\n.result-title {\r\n    font-family: var(--font-decorative);\r\n    font-size: 3.5rem;\r\n    margin-bottom: 2rem;\r\n    text-shadow: 0 0 20px currentColor;\r\n}\r\n\r\n.victory-title {\r\n    color: var(--forest-green);\r\n    animation: victoryPulse 2s ease-in-out infinite;\r\n}\r\n\r\n.defeat-title {\r\n    color: var(--blood-red);\r\n    animation: defeatShake 0.5s ease-in-out infinite;\r\n}\r\n\r\n@keyframes victoryPulse {\r\n    0%, 100% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n}\r\n\r\n@keyframes defeatShake {\r\n    0%, 100% { transform: translateX(0); }\r\n    25% { transform: translateX(-3px); }\r\n    75% { transform: translateX(3px); }\r\n}\r\n\r\n.stats-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(2, 1fr);\r\n    gap: 1rem;\r\n    margin: 2rem 0;\r\n    background: rgba(0, 0, 0, 0.3);\r\n    padding: 1.5rem;\r\n    border-radius: 10px;\r\n}\r\n\r\n.victory-stats .stat, .defeat-stats .stat {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    padding: 0.5rem 0;\r\n    border-bottom: 1px solid rgba(255, 255, 255, 0.1);\r\n}\r\n\r\n.stat-card {\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n}\r\n\r\n.stat-label {\r\n    font-size: 0.9rem;\r\n    color: var(--stone-gray);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.stat-value {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.victory-controls, .defeat-controls {\r\n    display: flex;\r\n    gap: 1rem;\r\n    justify-content: center;\r\n    margin-top: 2rem;\r\n}\r\n\r\n.victory-controls .btn, .defeat-controls .btn {\r\n    min-width: 150px;\r\n}\r\n\r\n/* Loading Screen */\r\n#loadingScreen {\r\n    background: var(--shadow-gradient);\r\n}\r\n\r\n.loading-content {\r\n    text-align: center;\r\n}\r\n\r\n.loading-spinner {\r\n    width: 60px;\r\n    height: 60px;\r\n    border: 4px solid var(--dark-bronze);\r\n    border-top: 4px solid var(--primary-gold);\r\n    border-radius: 50%;\r\n    animation: spin 1s linear infinite;\r\n    margin: 0 auto 2rem;\r\n    box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n@keyframes spin {\r\n    0% { transform: rotate(0deg); }\r\n    100% { transform: rotate(360deg); }\r\n}\r\n\r\n.loading-text {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 1.5rem;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.loading-tip {\r\n    color: var(--stone-gray);\r\n    font-style: italic;\r\n    max-width: 400px;\r\n    margin: 0 auto;\r\n    line-height: 1.4;\r\n}\r\n\r\n/* Pause Menu */\r\n.pause-overlay {\r\n    display: none;\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.85);\r\n    z-index: 2000;\r\n    justify-content: center;\r\n    align-items: center;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.pause-overlay.active {\r\n    display: flex;\r\n}\r\n\r\n.pause-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 3rem;\r\n    text-align: center;\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.pause-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2.5rem;\r\n    margin-bottom: 2rem;\r\n}\r\n\r\n/* Battle log styles */\r\n.battle-log {\r\n    background: rgba(0, 0, 0, 0.6);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 1rem;\r\n    height: 150px;\r\n    overflow-y: auto;\r\n    font-size: 0.8rem;\r\n    margin-top: 1.5rem;\r\n}\r\n\r\n.log-entry {\r\n    margin: 0.3rem 0;\r\n    padding: 0.3rem 0.5rem;\r\n    border-radius: 3px;\r\n    line-height: 1.3;\r\n}\r\n\r\n.log-damage {\r\n    color: #ff6666;\r\n    background: rgba(255, 102, 102, 0.1);\r\n}\r\n\r\n.log-death {\r\n    color: var(--blood-red);\r\n    font-weight: bold;\r\n    background: rgba(183, 28, 28, 0.1);\r\n}\r\n\r\n.log-victory {\r\n    color: var(--forest-green);\r\n    font-weight: bold;\r\n    background: rgba(27, 94, 32, 0.1);\r\n}\r\n\r\n.log-placement {\r\n    color: var(--primary-gold);\r\n    background: rgba(212, 175, 55, 0.1);\r\n}\r\n\r\n/* Experience Panel Styles */\r\n.experience-panel {\r\n    background: linear-gradient(135deg, rgba(255, 140, 0, 0.15), rgba(212, 175, 55, 0.15));\r\n    border-radius: 10px;\r\n    border: 2px solid var(--accent-amber);\r\n    animation: experienceGlow 2s ease-in-out infinite alternate;\r\n    position: relative;\r\n    overflow: hidden;\r\n    padding: 0.5em;\r\n    margin-bottom: 1em;\r\n}\r\n\r\n.experience-panel .experience-squad-info {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    align-items: center; margin-bottom: 6px; position: relative; z-index: 2;\r\n}\r\n\r\n.experience-panel .experience-squad-name {\r\n    color: var(--parchment); font-size: 13px; font-weight: bold; font-family: var(--font-title);\r\n}\r\n\r\n.experience-panel .experience-levelUpCost {\r\n    display: flex; \r\n    justify-content: space-between; \r\n    font-size: 11px; \r\n    margin-bottom: 6px; \r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-panel .level-up-button {\r\n    position: relative;\r\n    z-index: 2;   \r\n}\r\n\r\n.experience-panel .level-up-button.level-up-button-spec {\r\n    background: 'linear-gradient(135deg, #cc6600, #ff8800)';\r\n    border-color: '#ffaa00';\r\n    box-shadow: '0 0 15px rgba(255, 170, 0, 0.4)';\r\n}\r\n\r\n.experience-nextLevelSpec {\r\n    color: '#ffaa00'; \r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.experience-nextLevel {    \r\n    color: '#44ff44';\r\n    font-size: 12px; \r\n    font-weight: bold;\r\n}\r\n\r\n.unit-card .shimmer {\r\n    position: absolute;\r\n    top: 0;\r\n    left: -100%;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);\r\n    transition: left 0.5s ease;\r\n    pointer-events: none;\r\n    z-index: 1;\r\n}\r\n\r\n.insufficientGoldEffect  {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    right: 0;\r\n    bottom: 0;\r\n    background: rgba(183, 28, 28, 0.3);\r\n    border-radius: 8px;\r\n    animation: insufficientGoldFlash 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 5;\r\n}\r\n\r\n@keyframes experienceGlow {\r\n    from { box-shadow: 0 0 10px rgba(255, 140, 0, 0.3); }\r\n    to { box-shadow: 0 0 25px rgba(255, 140, 0, 0.6); }\r\n}\r\n.selection-ripple {\r\n    position: absolute;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);\r\n    border-radius: 50%;\r\n    transform: scale(0);\r\n    animation: selectionRipple 0.6s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-burst {\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    width: 20px;\r\n    height: 20px;\r\n    background: radial-gradient(circle, \r\n        rgba(255, 215, 0, 0.9) 0%, \r\n        rgba(255, 140, 0, 0.6) 50%, \r\n        transparent 100%);\r\n    border-radius: 50%;\r\n    transform: translate(-50%, -50%) scale(0);\r\n    animation: levelUpBurst 1.2s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n\r\n.level-up-sparkle {\r\n    position: absolute;\r\n    width: 4px;\r\n    height: 4px;\r\n    background: var(--primary-gold);\r\n    transform: scale(0);\r\n    animation: sparkle 0.8s ease-out;\r\n    pointer-events: none;\r\n    z-index: 10;\r\n}\r\n.experience-bar {\r\n    width: 100%;\r\n    height: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    border-radius: 4px;\r\n    overflow: hidden;\r\n    margin: 0.5rem 0;\r\n    border: 1px solid var(--dark-bronze);\r\n\r\n    position: relative; \r\n    z-index: 2;\r\n}\r\n\r\n.experience-fill {\r\n    height: 100%;\r\n    width: 100%;\r\n    background: linear-gradient(90deg, var(--accent-amber), var(--primary-gold));\r\n    transition: width 0.3s ease;\r\n    box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);\r\n}\r\n\r\n.level-up-button {\r\n    background: linear-gradient(135deg, var(--forest-green), #2e7d32);\r\n    color: var(--parchment);\r\n    border: 2px solid #388e3c;\r\n    padding: 0.5rem 1rem;\r\n    margin: 0.3rem;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.8rem;\r\n    font-weight: 600;\r\n    transition: all 0.3s ease;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.level-up-button:hover {\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 5px 15px rgba(27, 94, 32, 0.4);\r\n}\r\n\r\n.level-up-button:disabled {\r\n    background: var(--stone-gray);\r\n    border-color: #616161;\r\n    cursor: not-allowed;\r\n    opacity: 0.6;\r\n}\r\n\r\n/* Undo Container */\r\n.undo-container {\r\n    margin-bottom: 1.5rem;\r\n    padding: 1rem;\r\n    background: rgba(0, 0, 0, 0.4);\r\n    border-radius: 8px;\r\n    border: 1px solid var(--dark-bronze);\r\n}\r\n\r\n.undo-button {\r\n    width: 100%;\r\n    padding: 0.8rem;\r\n    background: linear-gradient(135deg, var(--stone-gray), #616161);\r\n    color: var(--parchment);\r\n    border: 1px solid #757575;\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n    font-family: var(--font-title);\r\n    font-size: 0.9rem;\r\n    transition: all 0.3s ease;\r\n}\r\n\r\n.undo-button:hover {\r\n    background: linear-gradient(135deg, #616161, #757575);\r\n    transform: translateY(-1px);\r\n}\r\n\r\n.undo-button:disabled {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    transform: none;\r\n}\r\n\r\n/* Multiplayer Setup Dialog */\r\n.multiplayer-setup-dialog {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.9);\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    z-index: 3000;\r\n    backdrop-filter: blur(5px);\r\n}\r\n\r\n.setup-content {\r\n    background: \r\n        linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));\r\n    border: 3px solid var(--primary-gold);\r\n    border-radius: 15px;\r\n    padding: 2.5rem;\r\n    max-width: 500px;\r\n    width: 90%;\r\n    text-align: center;\r\n    color: var(--parchment);\r\n    box-shadow: 0 0 50px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.setup-content h2 {\r\n    font-family: var(--font-decorative);\r\n    color: var(--primary-gold);\r\n    font-size: 2rem;\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.player-name-input {\r\n    margin: 2rem 0;\r\n}\r\n\r\n.player-name-input label {\r\n    display: block;\r\n    margin-bottom: 0.8rem;\r\n    color: var(--stone-gray);\r\n    font-family: var(--font-title);\r\n}\r\n\r\n.player-name-input input {\r\n    width: 100%;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    font-size: 1rem;\r\n    font-family: var(--font-title);\r\n    transition: border-color 0.3s ease;\r\n}\r\n\r\n.player-name-input input:focus {\r\n    border-color: var(--primary-gold);\r\n    outline: none;\r\n    box-shadow: 0 0 10px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.room-join-section {\r\n    margin-top: 1.5rem;\r\n    display: flex;\r\n    gap: 0.8rem;\r\n}\r\n\r\n.room-join-section input {\r\n    flex: 1;\r\n    padding: 1rem;\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    background: rgba(0, 0, 0, 0.5);\r\n    color: var(--parchment);\r\n    text-transform: uppercase;\r\n    font-family: var(--font-title);\r\n    font-weight: bold;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.opponent-info {\r\n    background: rgba(0,0,0,0.8);\r\n    border: 2px solid var(--blood-red);\r\n    border-radius: 5px;\r\n    padding: 1rem;\r\n    color: var(--parchment);\r\n    min-width: 200px;\r\n}\r\n\r\n.opponent-info h4 {\r\n    color: var(--blood-red);\r\n    margin-bottom: 0.5rem;\r\n    font-family: var(--font-decorative);\r\n}\r\n\r\n.opponent-stats div {\r\n    margin: 0.25rem 0;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.multiplayer-notification {\r\n    background: rgba(0,0,0,0.9);\r\n    border: 2px solid;\r\n    border-radius: 5px;\r\n    padding: 1rem 2rem;\r\n    margin: 0.5rem;\r\n    font-weight: bold;\r\n    animation: notificationSlideIn 0.3s ease-out;\r\n}\r\n\r\n.modal {\r\n    position: fixed; \r\n    top: 0; \r\n    left: 0; \r\n    width: 100%; \r\n    height: 100%;\r\n    background: rgba(0,0,0,0.9); \r\n    display: flex; \r\n    justify-content: center;\r\n    align-items: center; \r\n    z-index: 10000;\r\n}\r\n\r\n.team-health-bar {\r\n    background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(26, 13, 26, 0.4));\r\n    border: 1px solid var(--dark-bronze);\r\n    border-radius: 10px;\r\n    padding: 0.8rem;\r\n    min-width: 200px;\r\n    text-align: center;\r\n    font-family: 'Courier New', monospace;\r\n    margin-bottom: 1rem;\r\n}\r\n\r\n.player-health {\r\n    border-color: #00ff00;\r\n}\r\n\r\n.opponent-health {\r\n    border-color: #ff4444;\r\n}\r\n\r\n.team-label {\r\n    font-size: 0.9rem;\r\n    font-weight: bold;\r\n    margin-bottom: 0.5rem;\r\n    text-shadow: 0 0 5px currentColor;\r\n}\r\n\r\n.health-bar-container {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 0.3rem;\r\n}\r\n\r\n.health-bar {\r\n    width: 100%;\r\n    height: 20px;\r\n    background: #222;\r\n    border: 1px solid #444;\r\n    border-radius: 10px;\r\n    overflow: hidden;\r\n    position: relative;\r\n}\r\n\r\n.health-fill {\r\n    height: 100%;\r\n    transition: width 0.5s ease;\r\n    border-radius: 10px;\r\n    position: relative;\r\n}\r\n\r\n.player-fill {\r\n    background: linear-gradient(90deg, #004400 0%, #00aa00 50%, #00ff00 100%);\r\n    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);\r\n}\r\n\r\n.opponent-fill {\r\n    background: linear-gradient(90deg, #440000 0%, #aa0000 50%, #ff4444 100%);\r\n    box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);\r\n}\r\n\r\n.health-text {\r\n    font-size: 0.8rem;\r\n    color: #fff;\r\n    font-weight: bold;\r\n    text-shadow: 1px 1px 2px #000;\r\n}\r\n\r\n.damage-popup {\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n    text-shadow: 2px 2px 4px #000;\r\n    animation: damageFloat 2s ease-out forwards;\r\n    pointer-events: none;\r\n    z-index: 1001;\r\n    color: #ff6666;\r\n}\r\n\r\n@keyframes damageFloat {\r\n    0% {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n        font-size: 1.5rem;\r\n    }\r\n    50% {\r\n        opacity: 1;\r\n        transform: translateY(-30px);\r\n        font-size: 2rem;\r\n    }\r\n    100% {\r\n        opacity: 0;\r\n        transform: translateY(-60px);\r\n        font-size: 1rem;\r\n    }\r\n}\r\n@keyframes notificationSlideIn {\r\n    from {\r\n        transform: translateX(100%);\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        transform: translateX(0);\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n/* Scrollbar Styling */\r\n::-webkit-scrollbar {\r\n    width: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border-radius: 4px;\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n    background: var(--dark-bronze);\r\n    border-radius: 4px;\r\n    transition: background 0.3s ease;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n    background: var(--primary-gold);\r\n}\r\n\r\n/* Responsive Design */\r\n@media (max-width: 768px) {\r\n    .game-title {\r\n        font-size: 2.5rem;\r\n    }\r\n    \r\n    .mode-grid {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    #canvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #uiContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n    \r\n    .phase-info {\r\n        position: relative;\r\n        bottom: auto;\r\n        left: auto;\r\n        margin: 1rem;\r\n    }\r\n\r\n    .unit-shop {\r\n        grid-template-columns: 1fr;\r\n    }\r\n\r\n    #multiplayerCanvasContainer {\r\n        width: 100%;\r\n    }\r\n    \r\n    #multiplayerUIContainer {\r\n        position: relative;\r\n        width: 100%;\r\n        height: auto;\r\n        border-left: none;\r\n        border-top: 3px solid var(--primary-gold);\r\n    }\r\n}\r\n\r\n\r\n\r\n/* Ripple Animation */\r\n@keyframes ripple {\r\n    to {\r\n        transform: scale(4);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n@keyframes particleFloat {\r\n    0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }\r\n    10% { opacity: 1; }\r\n    90% { opacity: 1; }\r\n    100% { transform: translate(-100px, -100vh) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes shimmer {\r\n    0% { left: -100%; }\r\n    50% { left: 100%; }\r\n    100% { left: 100%; }\r\n}\r\n\r\n@keyframes selectionPulse {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(10); opacity: 0; }\r\n}\r\n\r\n@keyframes selectionBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    100% { transform: translate(-50%, -50%) scale(8); opacity: 0; }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(6); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(12); opacity: 0; }\r\n}\r\n\r\n@keyframes cardSelect {\r\n    0% { transform: scale(1); }\r\n    50% { transform: scale(1.05); }\r\n    100% { transform: scale(1.02); }\r\n}\r\n\r\n@keyframes cardDeselect {\r\n    0% { transform: scale(1.02); }\r\n    100% { transform: scale(1); }\r\n}\r\n\r\n@keyframes copyPulse {\r\n    0%, 100% { transform: scale(1); color: var(--accent-amber); }\r\n    50% { transform: scale(1.1); color: var(--primary-gold); }\r\n}\r\n\r\n@keyframes notificationSlideOut {\r\n    from { transform: translateX(0); opacity: 1; }\r\n    to { transform: translateX(100%); opacity: 0; }\r\n}\r\n\r\n\r\n\r\n @keyframes selectionRipple {\r\n    0% { transform: scale(0); opacity: 1; }\r\n    100% { transform: scale(6); opacity: 0; }\r\n}\r\n\r\n@keyframes insufficientGoldFlash {\r\n    0%, 100% { opacity: 0; }\r\n    50% { opacity: 1; }\r\n}\r\n\r\n@keyframes sparkle {\r\n    0% { transform: scale(0) rotate(0deg); opacity: 1; }\r\n    50% { transform: scale(1) rotate(180deg); opacity: 1; }\r\n    100% { transform: scale(0) rotate(360deg); opacity: 0; }\r\n}\r\n\r\n@keyframes legendaryBorder {\r\n    0%, 100% { opacity: 0.6; transform: scale(1); }\r\n    50% { opacity: 1; transform: scale(1.02); }\r\n}\r\n\r\n@keyframes levelUpBurst {\r\n    0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }\r\n    50% { transform: translate(-50%, -50%) scale(8); opacity: 0.8; }\r\n    100% { transform: translate(-50%, -50%) scale(15); opacity: 0; }\r\n}\r\n\r\n.unit-card.selected {\r\n    border-color: var(--accent-amber) !important;\r\n    background: linear-gradient(145deg, rgba(74, 20, 140, 0.3), rgba(114, 47, 55, 0.3)) !important;\r\n    box-shadow: 0 0 20px rgba(255, 140, 0, 0.4), inset 0 0 10px rgba(255, 140, 0, 0.1) !important;\r\n    transform: translateY(-3px) scale(1.02) !important;\r\n}\r\n\r\n.unit-card.disabled:hover {\r\n    transform: none !important;\r\n    border-color: var(--dark-bronze) !important;\r\n    box-shadow: none !important;\r\n}\r\n\r\n\r\n@keyframes readyPulse {\r\n    0%, 100% { \r\n        box-shadow: \r\n            0 0 20px rgba(27, 94, 32, 0.3),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n    50% { \r\n        box-shadow: \r\n            0 0 35px rgba(27, 94, 32, 0.5),\r\n            0 4px 15px rgba(27, 94, 32, 0.2);\r\n    }\r\n}\r\n\r\n@keyframes readyGlow {\r\n    from { \r\n        box-shadow: \r\n            0 0 20px rgba(255, 140, 0, 0.4),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n    to { \r\n        box-shadow: \r\n            0 0 40px rgba(255, 140, 0, 0.7),\r\n            0 4px 15px rgba(255, 140, 0, 0.3);\r\n    }\r\n}\r\n\r\n@keyframes startGamePulse {\r\n    0%, 100% { \r\n        box-shadow: 0 0 25px rgba(74, 20, 140, 0.4);\r\n    }\r\n    50% { \r\n        box-shadow: 0 0 40px rgba(74, 20, 140, 0.7);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/* Building Shop Container */\r\n#buildingShop {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 8px;\r\n    padding: 10px;\r\n    overflow-y: auto;\r\n    max-height: calc(100vh - 200px);\r\n}\r\n\r\n/* Building Section */\r\n.building-section {\r\n    margin-bottom: 20px;\r\n}\r\n\r\n.building-section-header {\r\n    color: var(--primary-gold);\r\n    font-family: var(--font-title);\r\n    margin-bottom: 10px;\r\n    font-size: 1rem;\r\n}\r\n\r\n/* Building Card */\r\n.building-card {\r\n    background: linear-gradient(145deg, rgba(13, 10, 26, 0.8), rgba(26, 13, 26, 0.8));\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    margin-bottom: 8px;\r\n    cursor: pointer;\r\n    transition: all 0.3s ease;\r\n    font-size: 0.85rem;\r\n    position: relative;\r\n}\r\n\r\n.building-card.owned {\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n.building-card.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.building-card.phase-disabled {\r\n    opacity: 0.6;\r\n    filter: grayscale(0.5);\r\n}\r\n\r\n.building-card.hover {\r\n    transform: scale(1.02) translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);\r\n}\r\n\r\n.building-card.shake {\r\n    animation: shake 0.5s;\r\n}\r\n\r\n/* Building Card Header */\r\n.building-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: center;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-title {\r\n    font-family: var(--font-title);\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.building-card-progress {\r\n    color: var(--accent-amber);\r\n    font-size: 0.7rem;\r\n}\r\n\r\n/* Building Card Details */\r\n.building-card-cost {\r\n    color: var(--accent-amber);\r\n    font-size: 0.8rem;\r\n    margin-bottom: 6px;\r\n    font-weight: bold;\r\n}\r\n\r\n.building-card-locked {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.building-card-description {\r\n    font-size: 0.75rem;\r\n    line-height: 1.2;\r\n    color: var(--stone-gray);\r\n}\r\n\r\n.building-card-owned {\r\n    color: var(--forest-green);\r\n    font-size: 0.7rem;\r\n    margin-top: 6px;\r\n}\r\n\r\n/* Upgrade Modal */\r\n.upgrade-modal {\r\n    position: fixed;\r\n    top: 0;\r\n    left: 0;\r\n    width: 100%;\r\n    height: 100%;\r\n    background: rgba(0, 0, 0, 0.8);\r\n    z-index: 10000;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    animation: fadeIn 0.2s;\r\n}\r\n\r\n.upgrade-panel {\r\n    background: linear-gradient(145deg, #1a1a2e, #16213e);\r\n    border: 2px solid var(--primary-gold);\r\n    border-radius: 10px;\r\n    padding: 20px;\r\n    max-width: 500px;\r\n    max-height: 80vh;\r\n    overflow-y: auto;\r\n    width: 90%;\r\n}\r\n\r\n.upgrade-panel-header {\r\n    color: var(--primary-gold);\r\n    margin-bottom: 15px;\r\n    font-family: var(--font-title);\r\n}\r\n\r\n/* Upgrade List */\r\n.upgrade-list {\r\n    display: flex;\r\n    flex-direction: column;\r\n    gap: 10px;\r\n    margin-bottom: 15px;\r\n}\r\n\r\n/* Upgrade Card */\r\n.upgrade-card {\r\n    background: rgba(0, 0, 0, 0.3);\r\n    border: 2px solid var(--dark-bronze);\r\n    border-radius: 8px;\r\n    padding: 12px;\r\n    transition: all 0.2s;\r\n}\r\n\r\n.upgrade-card.purchased {\r\n    border-color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked {\r\n    border-color: var(--blood-red);\r\n}\r\n\r\n.upgrade-card.available {\r\n    cursor: pointer;\r\n}\r\n\r\n.upgrade-card.available:hover {\r\n    transform: translateX(5px);\r\n    border-color: var(--primary-gold);\r\n}\r\n\r\n/* Upgrade Card Header */\r\n.upgrade-card-header {\r\n    display: flex;\r\n    justify-content: space-between;\r\n    align-items: start;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-name {\r\n    color: var(--primary-gold);\r\n    font-weight: 600;\r\n}\r\n\r\n.upgrade-card-status {\r\n    color: var(--accent-amber);\r\n}\r\n\r\n.upgrade-card.purchased .upgrade-card-status {\r\n    color: var(--forest-green);\r\n}\r\n\r\n.upgrade-card.locked .upgrade-card-status {\r\n    color: var(--blood-red);\r\n}\r\n\r\n/* Upgrade Card Details */\r\n.upgrade-card-description {\r\n    color: var(--stone-gray);\r\n    font-size: 0.85rem;\r\n    margin-bottom: 6px;\r\n}\r\n\r\n.upgrade-card-requirement {\r\n    color: var(--blood-red);\r\n    font-size: 0.75rem;\r\n}\r\n\r\n/* Upgrade Close Button */\r\n.upgrade-close-button {\r\n    width: 100%;\r\n}\r\n\r\n/* Animations */\r\n@keyframes fadeIn {\r\n    from {\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n@keyframes shake {\r\n    0%, 100% {\r\n        transform: translateX(0);\r\n    }\r\n    10%, 30%, 50%, 70%, 90% {\r\n        transform: translateX(-5px);\r\n    }\r\n    20%, 40%, 60%, 80% {\r\n        transform: translateX(5px);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.shop-container {\r\n    display: grid;\r\n    grid-template-columns: 200px 1fr;\r\n    gap: 1rem;\r\n    margin-top: 1rem;\r\n}\r\n\r\n\r\n.action-panel-header {\r\n    display: flex;\r\n    align-items: center;\r\n    gap: 0.6rem;\r\n    font-size: 1.1rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 1rem;\r\n    padding-bottom: 0.6rem;\r\n    border-bottom: 2px solid rgba(255, 170, 0, 0.3);\r\n    text-transform: uppercase;\r\n    letter-spacing: 1px;\r\n}\r\n\r\n.deselect-btn {\r\n    background: rgba(255, 170, 0, 0.2);\r\n    border: 1px solid rgba(255, 170, 0, 0.5);\r\n    border-radius: 4px;\r\n    padding: 0.3rem 0.6rem;\r\n    color: #ffaa00;\r\n    cursor: pointer;\r\n    font-weight: bold;\r\n    transition: all 0.2s ease;\r\n}\r\n\r\n.deselect-btn:hover {\r\n    background: rgba(255, 170, 0, 0.3);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n}\r\n\r\n.action-section {\r\n    margin-bottom: 1.5rem;\r\n}\r\n\r\n.action-section:last-child {\r\n    margin-bottom: 0;\r\n}\r\n\r\n.action-section-header {\r\n    font-size: 0.85rem;\r\n    font-weight: bold;\r\n    color: #ffaa00;\r\n    margin-bottom: 0.8rem;\r\n    text-transform: uppercase;\r\n    letter-spacing: 0.5px;\r\n}\r\n\r\n.action-grid {\r\n    display: grid;\r\n    grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));\r\n    gap: 0.6rem;\r\n    width: 100%;\r\n}\r\n\r\n.action-btn {\r\n    position: relative;\r\n    background: linear-gradient(145deg, #2a2a3e, #1a1a2e);\r\n    border: 2px solid rgba(255, 170, 0, 0.4);\r\n    border-radius: 6px;\r\n    cursor: pointer;\r\n}\r\n\r\n.action-btn:hover:not(.locked):not(.disabled):not(.purchased) {\r\n    background: linear-gradient(145deg, #3a3a4e, #2a2a3e);\r\n    border-color: rgba(255, 170, 0, 0.8);\r\n    transform: translateY(-2px);\r\n    box-shadow: 0 4px 12px rgba(255, 170, 0, 0.3);\r\n}\r\n\r\n.action-btn.locked {\r\n    opacity: 0.5;\r\n    cursor: not-allowed;\r\n    border-color: rgba(100, 100, 100, 0.4);\r\n}\r\n\r\n.action-btn.disabled {\r\n    opacity: 0.6;\r\n    cursor: not-allowed;\r\n}\r\n\r\n.action-btn.purchased {\r\n    background: linear-gradient(145deg, #2a3a2e, #1a2a1e);\r\n    border-color: rgba(74, 222, 128, 0.6);\r\n    opacity: 0.8;\r\n    cursor: default;\r\n}\r\n\r\n.action-btn-icon {\r\n    font-size: 2rem;\r\n}\r\n\r\n.action-btn-icon > img {\r\n    width: 100%;\r\n    display: block;\r\n}\r\n\r\n.action-btn-title {\r\n    font-size: 0.75rem;\r\n    font-weight: 600;\r\n    color: #fff;\r\n    text-align: center;\r\n    line-height: 1.2;\r\n}\r\n\r\n.action-btn-cost {\r\n    font-size: 0.75rem;\r\n    color: #ffaa00;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-check {\r\n    color: #4ade80;\r\n    font-size: 1.5rem;\r\n    font-weight: bold;\r\n}\r\n\r\n.action-btn-lock {\r\n    position: absolute;\r\n    top: 4px;\r\n    right: 4px;\r\n    font-size: 0.9rem;\r\n}\r\n\r\n.action-btn-tooltip {\r\n    position: absolute;\r\n    bottom: 100%;\r\n    left: 50%;\r\n    transform: translateX(-50%);\r\n    background: rgba(0, 0, 0, 0.95);\r\n    color: #fff;\r\n    padding: 0.4rem 0.6rem;\r\n    border-radius: 4px;\r\n    font-size: 0.7rem;\r\n    white-space: nowrap;\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    transition: opacity 0.2s ease;\r\n    margin-bottom: 4px;\r\n    z-index: 1000;\r\n}\r\n\r\n.action-btn.locked:hover .action-btn-tooltip {\r\n    opacity: 1;\r\n}\r\n\r\n.action-empty {\r\n    text-align: center;\r\n    color: rgba(255, 255, 255, 0.4);\r\n    font-style: italic;\r\n    padding: 3rem 1rem;\r\n}\r\n\r\n@media (max-width: 768px) {\r\n    .shop-container {\r\n        grid-template-columns: 1fr;\r\n    }\r\n    \r\n    .building-list {\r\n        max-height: 200px;\r\n        display: flex;\r\n        flex-wrap: nowrap;\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n        gap: 0.5rem;\r\n        padding: 0.6rem;\r\n    }\r\n    \r\n    .building-list-item {\r\n        flex-direction: column;\r\n        min-width: 80px;\r\n        margin-bottom: 0;\r\n        padding: 0.5rem;\r\n    }\r\n    \r\n    .building-list-info {\r\n        text-align: center;\r\n    }\r\n    \r\n    .action-grid {\r\n        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));\r\n    }\r\n}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/interfaces/html/main.html",
      "html": "<!-- Main Menu Screen -->\r\n<div id=\"mainMenu\" class=\"screen active\">\r\n    <div class=\"game-title\">LEGENDS OF THE ARENA</div>\r\n    <div class=\"subtitle\">Where Heroes Rise and Legends Are Forged</div>\r\n    <div class=\"main-menu-buttons\">\r\n        <button id=\"mainMenu_PlayGameBtn\" class=\"btn\">âš”ï¸ ENTER BATTLE</button>\r\n        <button id=\"mainMenu_SettingsBtn\" class=\"btn btn-secondary\">âš™ï¸ SETTINGS</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Mode Selection Screen -->\r\n<div id=\"gameModeSelect\" class=\"screen\">\r\n    <div class=\"mode-selection\">\r\n        <h2>ðŸŽ¯ CHOOSE YOUR DESTINY</h2>\r\n        <div class=\"mode-grid\" id=\"modeGrid\">\r\n            <!-- Game mode cards populated by GameModeManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"gameMode_BackBtn\" class=\"btn btn-secondary\">â† RETURN</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Multiplayer Lobby -->\r\n<div id=\"multiplayerLobby\" class=\"screen\">\r\n    <div class=\"multiplayer-lobby-container\">\r\n        <div class=\"lobby-header\">\r\n            <h1 class=\"lobby-title\">âš”ï¸ WAR COUNCIL</h1>\r\n            <div class=\"room-info\">\r\n                <div class=\"room-id-display\">\r\n                    <span class=\"room-label\">Battle Hall:</span>\r\n                    <span id=\"lobbyRoomId\" class=\"room-id\">------</span>\r\n                    <button id=\"copyRoomIdBtn\" class=\"btn-small\">ðŸ“‹ Copy</button>\r\n                </div>\r\n                <div class=\"connection-status\">\r\n                    <span id=\"connectionStatus\" class=\"status-indicator\">ðŸ”´ Summoning...</span>\r\n                </div>\r\n            </div>\r\n        </div>\r\n\r\n        <div class=\"lobby-content\">\r\n            <div class=\"players-section\">\r\n                <h2>âš”ï¸ Warriors (<span id=\"playerCount\">1</span>/2)</h2>\r\n                <div id=\"playersContainer\" class=\"players-grid\">\r\n                    <div class=\"player-card\" id=\"player1Card\">\r\n                        <div class=\"player-name\" id=\"player1Name\">You</div>\r\n                        <div class=\"player-status waiting\" id=\"player1Status\">ðŸŸ¡ Preparing...</div>\r\n                        <div class=\"player-stats\">Ready to battle</div>\r\n                    </div>\r\n                    <div class=\"player-card empty\" id=\"player2Card\">\r\n                        <div class=\"player-name\" id=\"player2Name\">Waiting for opponent</div>\r\n                        <div class=\"player-status empty\" id=\"player2Status\">âšª Empty slot</div>\r\n                        <div class=\"player-stats\">Seeking worthy challenger</div>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n\r\n\r\n            <div class=\"lobby-status\">\r\n                <div class=\"status-message\" id=\"lobbyStatusMessage\">Waiting for worthy opponents...</div>\r\n                <div class=\"game-progress\">\r\n                    <div class=\"progress-bar\">\r\n                        <div class=\"progress-fill\" id=\"gameProgressFill\"></div>\r\n                    </div>\r\n                    <div class=\"progress-text\" id=\"gameProgressText\">Preparing battlefield...</div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"game-info\">\r\n                <h3>ðŸ° Battle Configuration</h3>\r\n                <div class=\"game-settings\">\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">ðŸŽ¯ Game Mode</span>\r\n                        <span class=\"setting-value\" id=\"lobbyGameMode\">Arena Combat</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">â±ï¸ Turn Timer</span>\r\n                        <span class=\"setting-value\" id=\"lobbyTurnTimer\">30 seconds</span>\r\n                    </div>\r\n                    <div class=\"setting\">\r\n                        <span class=\"setting-label\">ðŸ’° Starting Gold</span>\r\n                        <span class=\"setting-value\" id=\"lobbyStartGold\">100 coins</span>\r\n                    </div>\r\n                </div>\r\n            </div>\r\n\r\n            <div class=\"lobby-footer\">\r\n                <div class=\"lobby-controls\">\r\n                    <div class=\"lobby-controls-left\">\r\n                        <button id=\"leaveLobbyBtn\" class=\"btn btn-secondary\">ðŸšª Retreat</button>\r\n                    </div>\r\n                    <div class=\"lobby-controls-right\">\r\n                        <button id=\"player1ReadyBtn\" class=\"ready-btn\">ðŸ›¡ï¸ READY FOR BATTLE</button>\r\n                    </div>\r\n                </div>\r\n\r\n                <div class=\"lobby-tips\">\r\n                    <p>ðŸ—¡ï¸ Prepare your strategies while waiting for opponents</p>\r\n                    <p>ðŸ° Victory requires both tactical skill and wise resource management</p>\r\n                    <p>âš¡ The realm's fate lies in your hands, Commander</p>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Game Screen -->\r\n<div id=\"gameScreen\" class=\"screen\">\r\n    <div id=\"gameContainer\">\r\n        <div id=\"canvasContainer\">\r\n            <canvas id=\"gameCanvas\"></canvas>\r\n        </div>\r\n        <div id=\"resourcesContainer\" class=\"resources\">\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ’°</span>\r\n                <span class=\"resource-value\" id=\"playerGold\">--</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ‘¥</span>\r\n                <span class=\"resource-value\" id=\"playerSupplies\">0</span>\r\n            </div>\r\n            <div class=\"resource-item\">\r\n                <span class=\"resource-label\">ðŸ†</span>\r\n                <span class=\"resource-value\" id=\"currentRound\">--</span>\r\n            </div>\r\n        </div>\r\n        <div id=\"unitPromotions\" style=\"display: none\"></div>  \r\n        <div id=\"gameControls\">\r\n            <button id=\"game_ExitBtn\" class=\"btn btn-secondary\" style=\"display:none\">ðŸšª RETREAT</button>\r\n            <button id=\"undoBtn\" class=\"btn btn-secondary\">ðŸ¤¦â€â™‚ï¸ Undo</button>\r\n            <button id=\"placementReadyBtn\" class=\"btn btn-primary\">Ready for Battle!</button>\r\n        </div>\r\n        <div id=\"uiContainer\">              \r\n            <div id=\"miniMapContainer\"></div>\r\n            <div id=\"selectedUnits\"></div>  \r\n            <div id=\"unitPortrait\"></div>            \r\n            <div class=\"action-panel\" id=\"actionPanel\"></div>\r\n        </div>  \r\n    </div>\r\n</div>\r\n\r\n<!-- Victory Screen -->\r\n<div id=\"victoryScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title victory-title\">ðŸ† GLORIOUS VICTORY! ðŸ†</div>\r\n        <div class=\"stats-grid\" id=\"victoryStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"victory_NextRoundBtn\" class=\"btn\">âš¡ NEXT CONQUEST</button>\r\n            <button id=\"victory_RestartBtn\" class=\"btn btn-secondary\">ðŸ”„ RETRY BATTLE</button>\r\n            <button id=\"victory_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Defeat Screen -->\r\n<div id=\"defeatScreen\" class=\"screen\">\r\n    <div class=\"result-content\">\r\n        <div class=\"result-title defeat-title\">ðŸ’€ DEFEAT ðŸ’€</div>\r\n        <div class=\"stats-grid\" id=\"defeatStats\">\r\n            <!-- Stats populated by ResultsManager -->\r\n        </div>\r\n        <div>\r\n            <button id=\"defeat_RetryBtn\" class=\"btn\">âš¡ SEEK REVENGE</button>\r\n            <button id=\"defeat_ChangeModeBtn\" class=\"btn btn-secondary\">ðŸŽ¯ CHANGE PATH</button>\r\n            <button id=\"defeat_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n        </div>\r\n    </div>\r\n</div>\r\n\r\n<!-- Pause Menu (Overlay) -->\r\n<div id=\"pauseMenu\" class=\"pause-overlay\">\r\n    <div class=\"pause-content\">\r\n        <h2>â³ WAR COUNCIL RECESS</h2>\r\n        <button id=\"paused_ResumeBtn\" class=\"btn\">â–¶ï¸ RETURN TO BATTLE</button>\r\n        <button id=\"paused_RestartBtn\" class=\"btn btn-secondary\">ðŸ”„ RESTART CAMPAIGN</button>\r\n        <button id=\"paused_MainMenuBtn\" class=\"btn btn-secondary\">ðŸ° RETURN HOME</button>\r\n    </div>\r\n</div>\r\n\r\n<!-- Loading Screen -->\r\n<div id=\"loadingScreen\" class=\"screen\">\r\n    <div class=\"loading-content\">\r\n        <div class=\"loading-spinner\"></div>\r\n        <div class=\"loading-text\">ðŸ”® SUMMONING WARRIORS...</div>\r\n        <div class=\"loading-tip\">Tip: Position ranged units behind your frontline for maximum effectiveness</div>\r\n    </div>\r\n</div>"
    }
  },
  "libraries": {
    "CodeMirror.js.min.js": {
      "title": "CodeMirror.js.min.js",
      "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/mode/javascript/javascript.min.js",
      "className": "CodeMirror.js",
      "fileName": "CodeMirror.js.min.js"
    },
    "codemirror.min.js": {
      "title": "CodeMirror.min.js",
      "href-disabled": "https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js",
      "className": "CodeMirror",
      "fileName": "codemirror.min.js"
    },
    "jszip.min.js": {
      "title": "jszip.min.js",
      "href": "/node_modules/jszip/dist/jszip.min.js",
      "fileName": "jszip.min.js"
    },
    "Rapier": {
      "fileName": "Rapier",
      "href": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
      "requireName": "RAPIER",
      "importName": "RAPIER",
      "isModule": true
    },
    "socket.io.min.js": {
      "title": "Socket.IO",
      "fileName": "socket.io.min.js",
      "href": "https://cdn.socket.io/4.7.2/socket.io.min.js",
      "isModule": true
    },
    "threejs": {
      "title": "THREE",
      "filePath": "/node_modules/three/build/three.module.min.js",
      "requireName": "THREE",
      "importName": "three",
      "fileName": "threejs",
      "windowName": "THREE",
      "isModule": true
    },
    "three_EffectComposer": {
      "title": "THREE.EffectComposer",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "EffectComposer",
      "importName": "EffectComposer",
      "fileName": "three_EffectComposer"
    },
    "three_OrbitControls": {
      "title": "THREE.OrbitControls",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "OrbitControls",
      "importName": "OrbitControls",
      "fileName": "three_OrbitControls"
    },
    "three_OutputPass": {
      "title": "THREE.OutputPass",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "OutputPass",
      "importName": "OutputPass",
      "fileName": "three_OutputPass"
    },
    "three_PointerLockControls": {
      "title": "THREE.PointerLockControls",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/PointerLockControls.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "PointerLockControls",
      "importName": "PointerLockControls",
      "fileName": "three_PointerLockControls"
    },
    "three_RenderPixelatedPass": {
      "title": "THREE.RenderPixelatedPass",
      "href": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "RenderPixelatedPass",
      "importName": "RenderPixelatedPass",
      "fileName": "three_RenderPixelatedPass"
    },
    "BaseECSGame": {
      "filePath": "/global/libraries/js/BaseECSGame.js",
      "fileName": "BaseECSGame"
    },
    "BaseSystem": {
      "filePath": "/global/libraries/js/BaseSystem.js",
      "fileName": "BaseSystem"
    },
    "ClientNetworkManager": {
      "filePath": "/global/libraries/js/ClientNetworkManager.js",
      "fileName": "ClientNetworkManager"
    },
    "Compiler": {
      "filePath": "/global/libraries/js/Compiler.js",
      "fileName": "Compiler"
    },
    "ECGame": {
      "filePath": "/global/libraries/js/ECGame.js",
      "fileName": "ECGame"
    },
    "CompilerModule": {
      "filePath": "/global/libraries/js/CompilerModule.js",
      "fileName": "CompilerModule"
    },
    "GameRoom": {
      "filePath": "/global/libraries/js/GameRoom.js",
      "fileName": "GameRoom"
    },
    "ECSGame": {
      "filePath": "/global/libraries/js/ECSGame.js",
      "fileName": "ECSGame"
    },
    "GameLoader": {
      "filePath": "/global/libraries/js/GameLoader.js",
      "fileName": "GameLoader"
    },
    "InputManager": {
      "filePath": "/global/libraries/js/InputManager.js",
      "fileName": "InputManager"
    },
    "InstancePool": {
      "filePath": "/global/libraries/js/InstancePool.js",
      "fileName": "InstancePool"
    },
    "MultiplayerECSGame": {
      "filePath": "/global/libraries/js/MultiplayerECSGame.js",
      "fileName": "MultiplayerECSGame"
    },
    "PerformanceProfiler": {
      "filePath": "/global/libraries/js/PerformanceProfiler.js",
      "fileName": "PerformanceProfiler"
    },
    "SceneEditor": {
      "filePath": "/global/libraries/js/SceneEditor.js",
      "fileName": "SceneEditor"
    },
    "SceneManager": {
      "filePath": "/global/libraries/js/SceneManager.js",
      "fileName": "SceneManager"
    },
    "SeededRandom": {
      "filePath": "/global/libraries/js/SeededRandom.js",
      "fileName": "SeededRandom"
    },
    "ServerECSGame": {
      "filePath": "/global/libraries/js/ServerECSGame.js",
      "fileName": "ServerECSGame"
    },
    "ServerEventManager": {
      "filePath": "/global/libraries/js/ServerEventManager.js",
      "fileName": "ServerEventManager"
    },
    "ServerGameRoom": {
      "filePath": "/global/libraries/js/ServerGameRoom.js",
      "fileName": "ServerGameRoom"
    },
    "ServerGameLoader": {
      "filePath": "/global/libraries/js/ServerGameLoader.js",
      "fileName": "ServerGameLoader"
    },
    "ServerMatchmakingService": {
      "filePath": "/global/libraries/js/ServerMatchmakingService.js",
      "fileName": "ServerMatchmakingService"
    },
    "ServerNetworkManager": {
      "filePath": "/global/libraries/js/ServerNetworkManager.js",
      "fileName": "ServerNetworkManager"
    },
    "ServerSceneManager": {
      "filePath": "/global/libraries/js/ServerSceneManager.js",
      "fileName": "ServerSceneManager"
    },
    "SE_GizmoManager": {
      "filePath": "/global/libraries/js/SE_GizmoManager.js",
      "fileName": "SE_GizmoManager"
    },
    "AIPromptPanel": {
      "fileName": "AIPromptPanel",
      "filePath": "/global/libraries/js/AIPromptPanel.js"
    },
    "AudioEditor": {
      "fileName": "AudioEditor",
      "filePath": "/global/libraries/js/AudioEditor.js"
    },
    "Component": {
      "fileName": "Component",
      "filePath": "/global/libraries/js/Component.js"
    },
    "CanvasUtility": {
      "fileName": "CanvasUtility",
      "filePath": "/global/libraries/js/CanvasUtility.js"
    },
    "Entity": {
      "fileName": "Entity",
      "filePath": "/global/libraries/js/Entity.js"
    },
    "GameState": {
      "fileName": "GameState",
      "filePath": "/global/libraries/js/GameState.js"
    },
    "GE_AnimationManager": {
      "title": "GE_AnimationManager",
      "fileName": "GE_AnimationManager",
      "filePath": "/global/libraries/js/GE_AnimationManager.js"
    },
    "BufferGeometryUtils": {
      "title": "THREE.BufferGeometryUtils",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "BufferGeometryUtils",
      "importName": "BufferGeometryUtils",
      "filePath": "/global/libraries/js/BufferGeometryUtils.js",
      "fileName": "BufferGeometryUtils"
    },
    "GE_EquipmentEditor": {
      "title": "GE_EquipmentEditor",
      "fileName": "GE_EquipmentEditor",
      "filePath": "/global/libraries/js/GE_EquipmentEditor.js"
    },
    "AmmoWorker": {
      "fileName": "AmmoWorker",
      "filePath": "/global/libraries/js/AmmoWorker.js"
    },
    "GE_SceneRenderer": {
      "title": "GE_SceneRenderer",
      "fileName": "GE_SceneRenderer",
      "filePath": "/global/libraries/js/GE_SceneRenderer.js"
    },
    "GE_GizmoManager": {
      "title": "GE_GizmoManager",
      "fileName": "GE_GizmoManager",
      "filePath": "/global/libraries/js/GE_GizmoManager.js"
    },
    "GE_GroupManager": {
      "title": "GE_GroupManager",
      "fileName": "GE_GroupManager",
      "filePath": "/global/libraries/js/GE_GroupManager.js"
    },
    "GE_RotationUtils": {
      "title": "GE_RotationUtils",
      "fileName": "GE_RotationUtils",
      "filePath": "/global/libraries/js/GE_RotationUtils.js"
    },
    "TerrainMapEditor": {
      "fileName": "TerrainMapEditor",
      "filePath": "/global/libraries/js/TerrainMapEditor.js"
    },
    "GE_UIManager": {
      "title": "GE_UIManager",
      "fileName": "GE_UIManager",
      "filePath": "/global/libraries/js/GE_UIManager.js"
    },
    "CoordinateTranslator": {
      "fileName": "CoordinateTranslator",
      "filePath": "/global/libraries/js/CoordinateTranslator.js"
    },
    "SpatialGrid": {
      "fileName": "SpatialGrid",
      "filePath": "/global/libraries/js/SpatialGrid.js"
    },
    "GLTFLoader": {
      "title": "GLTF Loader",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "GLTFLoader",
      "importName": "GLTFLoader",
      "fileName": "GLTFLoader",
      "filePath": "/global/libraries/js/GLTFLoader.js"
    },
    "ModelManager": {
      "title": "ModelManager",
      "fileName": "ModelManager",
      "filePath": "/global/libraries/js/ModelManager.js"
    },
    "TextureEditor": {
      "title": "TextureEditor",
      "fileName": "TextureEditor",
      "filePath": "/global/libraries/js/TextureEditor.js"
    },
    "ImageManager": {
      "fileName": "ImageManager",
      "filePath": "/global/libraries/js/ImageManager.js"
    },
    "ZipExporter": {
      "fileName": "ZipExporter",
      "filePath": "/global/libraries/js/ZipExporter.js"
    },
    "three-nebula": {
      "fileName": "three-nebula",
      "isModule": true,
      "importName": "Nebula",
      "requireName": "Nebula",
      "filePath": "/global/libraries/js/three-nebula.js"
    },
    "ShapeFactory": {
      "fileName": "ShapeFactory",
      "filePath": "/global/libraries/js/ShapeFactory.js"
    },
    "PhysicsEngine": {
      "title": "PhysicsEngine",
      "fileName": "PhysicsEngine",
      "filePath": "/global/libraries/js/PhysicsEngine.js"
    },
    "ScriptEditor": {
      "fileName": "ScriptEditor",
      "filePath": "/global/libraries/js/ScriptEditor.js"
    },
    "three_MeshBVH": {
      "title": "THREE MeshBVH",
      "isModule": true,
      "windowContext": "THREE_",
      "fileName": "three_MeshBVH",
      "filePath": "/global/libraries/js/three_MeshBVH.js"
    },
    "ExportScripts": {
      "fileName": "ExportScripts",
      "filePath": "/global/libraries/js/ExportScripts.js"
    },
    "GE_ShapeManager": {
      "title": "GE_ShapeManager",
      "fileName": "GE_ShapeManager",
      "filePath": "/global/libraries/js/GE_ShapeManager.js"
    },
    "GE_EventManager": {
      "title": "GE_EventManager",
      "fileName": "GE_EventManager",
      "filePath": "/global/libraries/js/GE_EventManager.js"
    },
    "TileMap": {
      "fileName": "TileMap",
      "filePath": "/global/libraries/js/TileMap.js"
    },
    "SimplexNoise": {
      "title": "SimplexNoise",
      "fileName": "SimplexNoise",
      "filePath": "/global/libraries/js/SimplexNoise.js"
    },
    "GraphicsEditor": {
      "fileName": "GraphicsEditor",
      "title": "GraphicsEditor",
      "filePath": "/global/libraries/js/GraphicsEditor.js"
    },
    "TerrainGenerator": {
      "title": "TerrainGenerator",
      "fileName": "TerrainGenerator",
      "filePath": "/global/libraries/js/TerrainGenerator.js"
    },
    "NetworkManager": {
      "fileName": "NetworkManager",
      "filePath": "/global/libraries/js/NetworkManager.js"
    },
    "RapierWorker": {
      "fileName": "RapierWorker",
      "script": "",
      "filePath": "/global/libraries/js/RapierWorker.js"
    },
    "TerrainImageProcessor": {
      "fileName": "TerrainImageProcessor",
      "filePath": "/global/libraries/js/TerrainImageProcessor.js"
    },
    "three_SkeletonUtils": {
      "title": "THREE SkeletonUtils",
      "isModule": true,
      "windowContext": "THREE_",
      "requireName": "SkeletonUtils",
      "importName": "SkeletonUtils",
      "fileName": "three_SkeletonUtils",
      "filePath": "/global/libraries/js/three_SkeletonUtils.js"
    },
    "NotificationSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/NotificationSystem.js",
      "fileName": "NotificationSystem"
    },
    "GameModeConfigs": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameModeConfigs.js",
      "fileName": "GameModeConfigs"
    },
    "UIComponents": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/UIComponents.js",
      "fileName": "UIComponents"
    },
    "DesyncDebugger": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/DesyncDebugger.js",
      "fileName": "DesyncDebugger"
    },
    "FantasyUIEnhancements": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/FantasyUIEnhancements.js",
      "fileName": "FantasyUIEnhancements"
    },
    "PlacementPreview": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/PlacementPreview.js",
      "fileName": "PlacementPreview"
    },
    "GameUtils": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameUtils.js",
      "fileName": "GameUtils"
    },
    "MinHeap": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/MinHeap.js",
      "fileName": "MinHeap"
    },
    "EnemyStrategy": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/libraries/js/EnemyStrategy.js",
      "fileName": "EnemyStrategy"
    }
  },
  "modals": {
    "addTerrainType": {
      "title": "Add Terrain Type",
      "fileName": "addTerrainType",
      "html": "\r\n<h4 id=\"formTitle\">Add Terrain Type</h4>\r\n<input type=\"hidden\" id=\"editingType\" value=\"\">\r\n<div class=\"form-group\">\r\n    <label for=\"terrainType\">Type:</label>\r\n    <input type=\"text\" id=\"terrainType\" placeholder=\"grass, water, etc.\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainColor\">Color:</label>\r\n    <input type=\"text\" id=\"terrainColorText\">\r\n    <input type=\"color\" id=\"terrainColor\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainImage\">Sprite Sheet:</label>\r\n    <input type=\"textarea\" id=\"terrainImage\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainTexture\">Texture:</label>\r\n    <select id=\"terrainTexture\"></select>\r\n</div>\r\n<div class=\"form-group\">\r\n    <img id=\"terrain-image-display\" alt=\"Terrain Image\">\r\n</div>\r\n<div class=\"form-group\">\r\n    <label for=\"terrainBuildable\">Buildable:</label>\r\n    <input type=\"checkbox\" id=\"terrainBuildable\">\r\n</div>\r\n<div class=\"form-actions\">\r\n    <button id=\"saveTerrainBtn\" class=\"primary\">Save</button>\r\n    <button id=\"cancelTerrainBtn\">Cancel</button>\r\n</div>\r\n<input type=\"hidden\" id=\"editingId\">\r\n",
      "filePath": "/global/modals/html/addTerrainType.html"
    },
    "aiPromptPanel": {
      "title": "AI Prompt Panel",
      "fileName": "aiPromptPanel",
      "html": "<h2>AI Object Generator</h2>\r\n                <div class=\"form-group\">\r\n                    <label for=\"ai-prompt-textarea\">Prompt:</label>\r\n                    <textarea id=\"ai-prompt-textarea\" rows=\"6\" placeholder=\"Enter your AI generation prompt\"></textarea>\r\n                    <textarea id=\"ai-pre-prompt-textarea\" rows=\"6\" placeholder=\"context\"></textarea>\r\n                </div>\r\n                <div class=\"actions\">\r\n                    <button id=\"send-ai-prompt-btn\" class=\"primary\">Send to AI</button>\r\n                    <button id=\"close-ai-prompt-modal\">Cancel</button>\r\n                </div>\r\n                <div class=\"preview-section\">\r\n                    <h3>AI Response Preview</h3>\r\n                    <textarea id=\"ai-response-preview\" rows=\"6\"></textarea>\r\n                    <div class=\"preview-actions\">\r\n                        <button id=\"apply-ai-response-btn\" class=\"primary\" style=\"display:none;\">Apply Response</button>\r\n                    </div>\r\n                </div>",
      "filePath": "/global/modals/html/aiPromptPanel.html"
    },
    "generateIsometric": {
      "title": "Generate Isometric Sprites",
      "fileName": "generateIsometric",
      "html": " <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>                 <div class=\"form-row\">                     <label for=\"iso-frustum\">Frustum Size:</label>                     <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-distance\">Distance:</label>                     <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">                 </div>                 <div class=\"form-row\">                     <label for=\"iso-size\">Sprite Size:</label>                     <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">                 </div>                 <div style=\"display: flex; gap: 10px; margin-top: 20px;\">                     <button id=\"iso-cancel\">Cancel</button>                     <button id=\"iso-generate\">Generate</button>                 </div>           ",
      "filePath": "/global/modals/html/generateIsometric.html"
    },
    "rotateShapes": {
      "title": "Rotate Shapes",
      "fileName": "rotateShapes",
      "html": "\r\n                <h3>Rotate All Shapes</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-angle\">Angle (degrees):</label>\r\n                    <input type=\"number\" id=\"rotate-angle\" value=\"0\" step=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"rotate-axis\">Axis:</label>\r\n                    <select id=\"rotate-axis\">\r\n                        <option value=\"x\">X</option>\r\n                        <option value=\"y\" selected>Y</option>\r\n                        <option value=\"z\">Z</option>\r\n                    </select>\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"rotate-cancel\">Cancel</button>\r\n                    <button id=\"rotate-apply\">Apply</button>\r\n                </div>\r\n",
      "filePath": "/global/modals/html/rotateShapes.html"
    },
    "compilerModal": {
      "title": "Compiler Modal",
      "fileName": "compilerModal",
      "filePath": "/global/modals/html/compilerModal.html",
      "html": "\n<div class=\"modal-header\">\n    <h2>Compile Game</h2>\n</div>\n<div class=\"modal-body\">\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileIncludeMetadata\" />\n            Include metadata file\n        </label>\n    </div>\n    <div class=\"form-group\">\n        <label>\n            <input type=\"checkbox\" id=\"compileCreateZip\" />\n            Download as zip file\n        </label>\n    </div>\n    <div class=\"compilation-output\" id=\"compilationOutput\" style=\"display: none;\">\n        <h3>Output:</h3>\n        <pre id=\"compilationLog\"></pre>\n    </div>\n</div>\n<div class=\"modal-footer\">\n    <button class=\"btn btn-primary\" onclick=\"window.compilerModule.compile()\">\n        Compile\n    </button>\n    <button class=\"btn btn-secondary\" onclick=\"this.closest('.modal').classList.remove('show')\">\n        Cancel\n    </button>\n</div>"
    },
    "generateIsoSprites": {
      "title": "Generate Spritesheet",
      "fileName": "generateIsoSprites",
      "html": "\r\n                <h3 style=\"margin-bottom: 20px; color: #e0e0e0; font-size: 18px;\">Generate Isometric Sprites</h3>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-frustum\">Frustum Size:</label>\r\n                    <input type=\"number\" id=\"iso-frustum\" value=\"48\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-distance\">Distance:</label>\r\n                    <input type=\"number\" id=\"iso-distance\" value=\"100\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div class=\"form-row\">\r\n                    <label for=\"iso-size\">Sprite Size:</label>\r\n                    <input type=\"number\" id=\"iso-size\" value=\"64\" step=\"1\" min=\"1\">\r\n                </div>\r\n                <div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n                    <button id=\"iso-cancel\">Cancel</button>\r\n                    <button id=\"iso-generate\">Generate</button>\r\n                </div>\r\n",
      "filePath": "/global/modals/html/generateIsoSprites.html"
    },
    "moveAllShapes": {
      "title": "Move All Shapes",
      "fileName": "moveAllShapes",
      "html": "\r\n<h3>Move All Shapes</h3>\r\n<div class=\"form-row\">\r\n    <label for=\"move-x\">X Offset:</label>\r\n    <input type=\"number\" id=\"move-x\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-y\">Y Offset:</label>\r\n    <input type=\"number\" id=\"move-y\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div class=\"form-row\">\r\n    <label for=\"move-z\">Z Offset:</label>\r\n    <input type=\"number\" id=\"move-z\" value=\"0\" step=\"0.5\">\r\n</div>\r\n<div style=\"display: flex; gap: 10px; margin-top: 20px;\">\r\n    <button id=\"move-cancel\">Cancel</button>\r\n    <button id=\"move-apply\">Apply</button>\r\n</div>\r\n",
      "filePath": "/global/modals/html/moveAllShapes.html"
    }
  },
  "renderers": {
    "MapRenderer": {
      "filePath": "/global/renderers/js/MapRenderer.js",
      "fileName": "MapRenderer"
    },
    "ModelRenderer": {
      "title": "Model Renderer",
      "fileName": "ModelRenderer",
      "parameters": "[\"objectType\",\"spawnType\"]",
      "filePath": "/global/renderers/js/ModelRenderer.js"
    },
    "Renderer": {
      "fileName": "Renderer",
      "filePath": "/global/renderers/js/Renderer.js"
    },
    "Health": {
      "fileName": "Health",
      "filePath": "/global/renderers/js/Health.js"
    }
  },
  "themes": {
    "aurora": {
      "title": "Aurora",
      "fileName": "aurora",
      "css": "/* Aurora Theme - Modern gradient-based design for GUTS Editor */\r\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Fira+Code:wght@400;500;600&display=swap');\r\n\r\n:root {\r\n  /* Override editor module variables with Aurora theme */\r\n  --editor-primary: #10b981;\r\n  --editor-primary-hover: #059669;\r\n  --editor-secondary: #3b82f6;\r\n  --editor-secondary-hover: #2563eb;\r\n  --editor-danger: #f43f5e;\r\n  --editor-danger-hover: #e11d48;\r\n  --editor-success: #10b981;\r\n  --editor-warning: #f59e0b;\r\n\r\n  /* Aurora-specific colors */\r\n  --aurora-teal: #14b8a6;\r\n  --aurora-blue: #0ea5e9;\r\n  --aurora-purple: #8b5cf6;\r\n  --aurora-pink: #ec4899;\r\n\r\n  /* Background layers - darker for comfort */\r\n  --editor-bg-dark: #050810;\r\n  --editor-bg-medium: #0a0e1a;\r\n  --editor-bg-light: #0f172a;\r\n  --editor-bg-lighter: #1e293b;\r\n\r\n  /* Text colors - softer for eyes */\r\n  --editor-text-primary: #cbd5e1;\r\n  --editor-text-secondary: #94a3b8;\r\n  --editor-text-muted: #64748b;\r\n\r\n  /* Borders */\r\n  --editor-border-color: rgba(20, 184, 166, 0.12);\r\n  --editor-border-color-hover: rgba(20, 184, 166, 0.25);\r\n\r\n  /* Shadows with aurora glow - softer */\r\n  --editor-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.5);\r\n  --editor-shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);\r\n  --editor-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);\r\n  --aurora-glow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  --aurora-glow-strong: 0 0 25px rgba(16, 185, 129, 0.3), 0 0 50px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Base body with aurora gradient background - darker and subtle */\r\nbody {\r\n  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\r\n  background-color: var(--editor-bg-dark);\r\n  color: var(--editor-text-primary);\r\n  background-image:\r\n    radial-gradient(ellipse at 20% 20%, rgba(16, 185, 129, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 80% 80%, rgba(59, 130, 246, 0.04) 0%, transparent 50%),\r\n    radial-gradient(ellipse at 50% 50%, rgba(139, 92, 246, 0.02) 0%, transparent 60%);\r\n  background-attachment: fixed;\r\n}\r\n\r\n/* Monospace font for code */\r\ninput[type=\"text\"],\r\ntextarea,\r\n.editor-module__textarea,\r\n.script-editor__code {\r\n  font-family: 'Fira Code', 'Monaco', 'Courier New', monospace;\r\n}\r\n\r\n/* Force dark backgrounds on all inputs - easy on the eyes */\r\ninput,\r\ntextarea,\r\nselect,\r\n.editor-module__input,\r\n.editor-module__textarea,\r\n.editor-module__select,\r\ninput[type=\"text\"],\r\ninput[type=\"number\"],\r\ninput[type=\"email\"],\r\ninput[type=\"password\"],\r\ninput[type=\"search\"],\r\ninput[type=\"url\"] {\r\n  background-color: var(--editor-bg-dark) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n/* Darker background for color pickers */\r\ninput[type=\"color\"],\r\n.editor-module__color-picker {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border: 1px solid var(--editor-border-color) !important;\r\n}\r\n\r\n/* Sidebar styling with aurora glow */\r\n.sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Main editor area */\r\n.editor {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n}\r\n\r\n/* Object items in sidebar - softer colors */\r\n.object-item {\r\n  background-color: transparent;\r\n  border-left: 2px solid transparent;\r\n  color: var(--editor-text-muted);\r\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\r\n}\r\n\r\n.object-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.05);\r\n  border-left-color: rgba(16, 185, 129, 0.5);\r\n  color: var(--editor-text-secondary);\r\n  transform: translateX(3px);\r\n}\r\n\r\n.object-item.selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.1), transparent);\r\n  border-left-color: var(--editor-primary);\r\n  color: var(--editor-text-primary);\r\n  box-shadow: var(--aurora-glow);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Buttons with aurora styling - much darker and easier on eyes */\r\nbutton {\r\n  font-family: 'Inter', sans-serif;\r\n  font-weight: 500;\r\n  text-transform: none;\r\n  letter-spacing: 0.02em;\r\n  transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\nbutton:hover {\r\n  transform: translateY(-1px);\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\nbutton:active {\r\n  transform: translateY(0);\r\n}\r\n\r\nbutton.primary {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\nbutton.primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.18) !important;\r\n  box-shadow: 0 0 8px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\nbutton.danger {\r\n  background-color: rgba(244, 63, 94, 0.08) !important;\r\n  border-color: rgba(244, 63, 94, 0.3) !important;\r\n  color: rgba(244, 63, 94, 0.75) !important;\r\n}\r\n\r\nbutton.danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  box-shadow: 0 0 8px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n/* Editor module buttons - much darker with !important to override base styles */\r\n.editor-module__btn {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n.editor-module__btn--primary {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: none !important;\r\n}\r\n\r\n.editor-module__btn--primary:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--secondary {\r\n  background-color: rgba(59, 130, 246, 0.12) !important;\r\n  border-color: rgba(59, 130, 246, 0.3) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--secondary:hover {\r\n  background-color: rgba(59, 130, 246, 0.18) !important;\r\n  box-shadow: 0 0 10px rgba(59, 130, 246, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--active {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.5) !important;\r\n  color: var(--editor-text-primary) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.15) !important;\r\n}\r\n\r\n.editor-module__btn--danger {\r\n  background-color: rgba(244, 63, 94, 0.12) !important;\r\n  border-color: rgba(244, 63, 94, 0.35) !important;\r\n  color: rgba(244, 63, 94, 0.85) !important;\r\n}\r\n\r\n.editor-module__btn--danger:hover {\r\n  background-color: rgba(244, 63, 94, 0.18) !important;\r\n  border-color: rgba(244, 63, 94, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(244, 63, 94, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--success {\r\n  background-color: rgba(16, 185, 129, 0.15) !important;\r\n  border-color: rgba(16, 185, 129, 0.35) !important;\r\n  color: var(--editor-text-primary) !important;\r\n}\r\n\r\n.editor-module__btn--success:hover {\r\n  background-color: rgba(16, 185, 129, 0.22) !important;\r\n  border-color: rgba(16, 185, 129, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(16, 185, 129, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--warning {\r\n  background-color: rgba(245, 158, 11, 0.12) !important;\r\n  border-color: rgba(245, 158, 11, 0.35) !important;\r\n  color: rgba(245, 158, 11, 0.9) !important;\r\n}\r\n\r\n.editor-module__btn--warning:hover {\r\n  background-color: rgba(245, 158, 11, 0.18) !important;\r\n  border-color: rgba(245, 158, 11, 0.45) !important;\r\n  box-shadow: 0 0 10px rgba(245, 158, 11, 0.12) !important;\r\n}\r\n\r\n.editor-module__btn--small {\r\n  background-color: rgba(15, 23, 42, 0.5) !important;\r\n}\r\n\r\n.editor-module__btn--small:hover {\r\n  background-color: rgba(15, 23, 42, 0.7) !important;\r\n}\r\n\r\n.editor-module__btn--icon {\r\n  background-color: rgba(15, 23, 42, 0.6) !important;\r\n  border-color: rgba(20, 184, 166, 0.2) !important;\r\n}\r\n\r\n.editor-module__btn--icon:hover {\r\n  background-color: rgba(15, 23, 42, 0.8) !important;\r\n  border-color: rgba(20, 184, 166, 0.3) !important;\r\n}\r\n\r\n/* Form inputs with aurora accent - soft glow on focus */\r\ninput:focus,\r\ntextarea:focus,\r\nselect:focus,\r\n.editor-module__input:focus,\r\n.editor-module__select:focus,\r\n.editor-module__textarea:focus {\r\n  background-color: var(--editor-bg-medium) !important;\r\n  border-color: var(--editor-primary) !important;\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.1) !important;\r\n  outline: none !important;\r\n}\r\n\r\n/* Range sliders - darker */\r\n.editor-module__range::-webkit-slider-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n.editor-module__range::-moz-range-thumb {\r\n  background: rgba(16, 185, 129, 0.6);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Modal styling */\r\n.modal {\r\n  background-color: rgba(10, 14, 26, 0.75);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n.modal-content {\r\n  background-color: var(--editor-bg-medium);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-lg), var(--aurora-glow);\r\n}\r\n\r\n/* Property list and panels */\r\n.property-list {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n}\r\n\r\n.editor-module__panel {\r\n  background-color: var(--editor-bg-light);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n\r\n/* Section titles with aurora accent - softer */\r\n.editor-module__section-title,\r\n.editor-module__panel-title {\r\n  color: var(--editor-text-primary);\r\n  position: relative;\r\n  padding-bottom: 8px;\r\n}\r\n\r\n.editor-module__section-title::after,\r\n.editor-module__panel-title::after {\r\n  content: '';\r\n  position: absolute;\r\n  bottom: 0;\r\n  left: 0;\r\n  width: 40px;\r\n  height: 2px;\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.6), transparent);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n/* Items with aurora hover effect - subtle */\r\n.editor-module__item:hover {\r\n  background-color: rgba(16, 185, 129, 0.04);\r\n  border-color: var(--editor-border-color-hover);\r\n  box-shadow: none;\r\n}\r\n\r\n.editor-module__item--active,\r\n.editor-module__item--selected {\r\n  background: linear-gradient(90deg, rgba(16, 185, 129, 0.12), transparent);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Toolbar styling */\r\n.toolbar,\r\n.editor-module__toolbar {\r\n  background: linear-gradient(180deg, rgba(15, 23, 42, 0.8), rgba(10, 14, 26, 0.8));\r\n  border-bottom: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Grid background with aurora tint */\r\n.grid-background,\r\n.editor-module__grid-background {\r\n  background-image:\r\n    linear-gradient(rgba(16, 185, 129, 0.05) 1px, transparent 1px),\r\n    linear-gradient(90deg, rgba(16, 185, 129, 0.05) 1px, transparent 1px);\r\n  background-size: 20px 20px;\r\n}\r\n\r\n/* Status bar */\r\n.editor-module__status-bar {\r\n  background: linear-gradient(90deg, rgba(10, 14, 26, 0.9), rgba(15, 23, 42, 0.9));\r\n  border-top: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(8px);\r\n}\r\n\r\n/* Success messages */\r\n.success-message,\r\n.editor-module__message--success {\r\n  color: var(--editor-primary);\r\n  background-color: rgba(16, 185, 129, 0.1);\r\n  border-color: var(--editor-primary);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Warning messages */\r\n.warning,\r\n.editor-module__message--warning {\r\n  color: var(--editor-warning);\r\n  background-color: rgba(245, 158, 11, 0.1);\r\n  border-color: var(--editor-warning);\r\n}\r\n\r\n/* Instructions */\r\n.instructions {\r\n  background-color: rgba(59, 130, 246, 0.08);\r\n  border-left: 3px solid var(--editor-secondary);\r\n}\r\n\r\n/* Scrollbar styling - darker */\r\n::-webkit-scrollbar {\r\n  width: 8px;\r\n  height: 8px;\r\n}\r\n\r\n::-webkit-scrollbar-track {\r\n  background: var(--editor-bg-dark);\r\n}\r\n\r\n::-webkit-scrollbar-thumb {\r\n  background: rgba(16, 185, 129, 0.25);\r\n  border-radius: 4px;\r\n  box-shadow: none;\r\n}\r\n\r\n::-webkit-scrollbar-thumb:hover {\r\n  background: rgba(16, 185, 129, 0.35);\r\n  box-shadow: 0 0 6px rgba(16, 185, 129, 0.15);\r\n}\r\n\r\n/* Canvas containers */\r\n#three-js-container,\r\n.preview-canvas-container {\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Camera controls */\r\n.camera-controls {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Content sidebars */\r\n.content-sidebar,\r\n.editor-module__sidebar {\r\n  background: linear-gradient(180deg, var(--editor-bg-medium) 0%, var(--editor-bg-dark) 100%);\r\n  border-right: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset -1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n.editor-module__sidebar--right {\r\n  border-right: none;\r\n  border-left: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md), inset 1px 0 0 rgba(16, 185, 129, 0.1);\r\n}\r\n\r\n/* Shape list items */\r\n.shape-item,\r\n.graphics-editor__shape-item,\r\n.graphics-editor__group-item {\r\n  border-left-color: rgba(16, 185, 129, 0.3);\r\n}\r\n\r\n.shape-item:hover,\r\n.graphics-editor__shape-item:hover,\r\n.graphics-editor__group-item:hover {\r\n  background-color: rgba(16, 185, 129, 0.08);\r\n  box-shadow: var(--aurora-glow);\r\n}\r\n\r\n/* Active/selected state - Aurora theme colors (teal/green glow) */\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option.active),\r\n.terrain-editor__terrain-item:has(.terrain-editor__color-option--active),\r\n.terrain-editor__environment-item.active,\r\n.terrain-editor__environment-item--active,\r\n.editor-module__selectable-item.active,\r\n.editor-module__selectable-item--active {\r\n  background-color: rgba(16, 185, 129, 0.12) !important;\r\n  border-color: rgba(16, 185, 129, 0.4) !important;\r\n  box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.4), 0 0 8px rgba(16, 185, 129, 0.2) !important;\r\n}\r\n\r\n.terrain-editor__color-option.active,\r\n.terrain-editor__color-option--active {\r\n  box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.6), 0 0 12px rgba(16, 185, 129, 0.5) !important;\r\n}\r\n\r\n/* Audio editor value displays */\r\n.audio-editor__value-display {\r\n  color: var(--editor-primary);\r\n  text-shadow: 0 0 8px rgba(16, 185, 129, 0.5);\r\n}\r\n\r\n/* Animations - disabled pulsing for comfort */\r\n@keyframes aurora-pulse {\r\n  0%, 100% {\r\n    box-shadow: 0 0 15px rgba(16, 185, 129, 0.2);\r\n  }\r\n  50% {\r\n    box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);\r\n  }\r\n}\r\n\r\n/* Removed automatic pulsing animation for eye comfort */\r\n/* .editor-module__btn--primary:hover,\r\n.editor-module__item--active,\r\n.object-item.selected {\r\n  animation: aurora-pulse 2s ease-in-out infinite;\r\n} */\r\n\r\n/* Typography enhancements */\r\nh1, h2, h3, h4 {\r\n  color: var(--editor-text-primary);\r\n  font-weight: 600;\r\n}\r\n\r\n/* Labels */\r\nlabel,\r\n.editor-module__label {\r\n  color: var(--editor-text-secondary);\r\n  font-weight: 500;\r\n}\r\n\r\n/* Info boxes */\r\n.editor-module__info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-md);\r\n  backdrop-filter: blur(10px);\r\n}\r\n\r\n/* Scene info */\r\n.scene-info {\r\n  background: rgba(15, 23, 42, 0.9);\r\n  border: 1px solid var(--editor-border-color);\r\n  box-shadow: var(--editor-shadow-sm);\r\n}\r\n",
      "filePath": "/global/themes/css/aurora.css"
    },
    "professional3": {
      "title": "Claude",
      "fileName": "professional3",
      "css": "/* Eclipse Theme - A premium dark UI experience */ @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500;600&display=swap');  :root {   --bg-primary: #0f111a;   --bg-secondary: #141725;   --bg-tertiary: #1a1d2d;   --accent-primary: #7c4dff;   --accent-secondary: #00bcd4;   --accent-tertiary: #ff4081;   --text-primary: #eceff1;   --text-secondary: #b0bec5;   --border-light: rgba(99, 114, 166, 0.25);   --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);   --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);   --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);   --gradient-bg: linear-gradient(135deg, rgba(20, 23, 37, 0.95), rgba(15, 17, 26, 0.95));   --gradient-accent: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); }  body {   font-family: 'Space Grotesk', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6;   transition: background-color 0.3s ease;   background-image:      radial-gradient(circle at 15% 15%, rgba(124, 77, 255, 0.08) 0%, transparent 25%),     radial-gradient(circle at 85% 85%, rgba(0, 188, 212, 0.08) 0%, transparent 25%); }  /* Modern sidebar with glassmorphism effect */ .sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--text-secondary);   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   margin-bottom: 4px;   border-radius: 0 4px 4px 0; }  .object-item:hover {   background-color: rgba(124, 77, 255, 0.1);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   transform: translateX(2px); }  .object-item.selected {   background: linear-gradient(90deg, rgba(124, 77, 255, 0.15), rgba(124, 77, 255, 0.05));   border-left: 3px solid var(--accent-primary);   color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   font-weight: 600; }  /* Editor area with polished look */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  #three-js-container {   border: 1px solid var(--border-light);   border-radius: 6px;   box-shadow: inset 0 0 16px rgba(0, 0, 0, 0.2);   background: rgba(15, 17, 26, 0.5); }  .preview-canvas-container {   border: 1px solid var(--accent-primary);   box-shadow: 0 0 16px rgba(124, 77, 255, 0.15);   border-radius: 6px;   overflow: hidden; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-light);   border-radius: 4px; }  /* Enhanced camera controls with dynamic hover effects */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px;   box-shadow: var(--shadow-sm); }  .camera-controls button {   background-color: rgba(99, 114, 166, 0.15);   border: 1px solid var(--border-light);   color: var(--text-primary);   border-radius: 4px;   padding: 8px 12px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .camera-controls button:hover {   background-color: rgba(124, 77, 255, 0.15);   border-color: var(--accent-primary);   box-shadow: 0 0 12px rgba(124, 77, 255, 0.2);   transform: translateY(-2px) scale(1.02); }  .camera-controls button:active {   transform: translateY(1px); }  .camera-controls .color-picker {   border: 1px solid var(--border-light);   border-radius: 4px;   overflow: hidden;   box-shadow: var(--shadow-sm); }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-light);   border-radius: 4px;   height: 6px;   box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.2); }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.4);   border-radius: 50%;   cursor: pointer;   transition: all 0.2s ease; }  .camera-controls .size-slider::-webkit-slider-thumb:hover {   transform: scale(1.2); }  /* Form elements with attractive focus states */ label {   font-weight: 500;   text-transform: uppercase;   letter-spacing: 0.5px;   color: var(--accent-primary);   margin-bottom: 6px;   display: block;   font-size: 0.85rem; }  input, textarea, select {   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   border-radius: 4px;   padding: 10px 12px;   box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);   transition: all 0.3s ease;   font-family: 'JetBrains Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 3px rgba(124, 77, 255, 0.2), inset 0 2px 4px rgba(0, 0, 0, 0.1);   background-color: rgba(20, 23, 37, 0.8); }  /* Modern button styles with micro-interactions */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden; }  button:hover {   background-color: rgba(99, 114, 166, 0.2);   border-color: var(--border-light);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);   transform: translateY(-2px); }  button:active {   transform: translateY(1px); }  button::after {   content: '';   position: absolute;   top: 50%;   left: 50%;   width: 100%;   height: 100%;   background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, transparent 50%);   transform: scale(0);   opacity: 0;   transition: transform 0.5s, opacity 0.3s;   pointer-events: none; }  button:active::after {   transform: scale(2);   opacity: 1;   transition: 0s; }  button.primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  button.primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.3); }  button.primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  button.primary:hover::before {   opacity: 0.1; }  button.danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  button.danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  button.active {   border: 1px solid var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.3);   color: var(--accent-secondary);   background-color: rgba(0, 188, 212, 0.15); }  /* Modal with glassmorphism effect */ .modal {   background-color: rgba(15, 17, 26, 0.7);   backdrop-filter: blur(8px);   -webkit-backdrop-filter: blur(8px); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-lg);   border-radius: 8px;   overflow: hidden;   animation: modalAppear 0.3s ease; }  @keyframes modalAppear {   from {     opacity: 0;     transform: scale(0.95) translateY(-10px);   }   to {     opacity: 1;     transform: scale(1) translateY(0);   } }  .property-list {   border: 1px solid var(--border-light);   background-color: var(--bg-tertiary);   border-radius: 6px;   overflow: hidden; }  /* Tab navigation with smooth transitions */ .tab-navigation {   border-bottom: 1px solid var(--border-light);   display: flex;   gap: 4px;   padding: 0 6px; }  .tab {   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 10px 16px;   color: var(--text-secondary);   position: relative;   transition: all 0.3s ease;   border-radius: 4px 4px 0 0; }  .tab:hover {   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 600;   background-color: rgba(124, 77, 255, 0.05); }  .tab.active::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   right: 0;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Stylized instructions and warnings */ .instructions {   background-color: rgba(124, 77, 255, 0.05);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .instructions::before {   content: 'i';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: var(--accent-primary);   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   font-style: italic;   color: white;   font-size: 14px; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   border-radius: 6px;   overflow: hidden; }  .success-message {   color: #4caf50;   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px;   background-color: rgba(76, 175, 80, 0.1);   border-radius: 4px;   display: inline-block; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(244, 67, 54, 0.1);   border-left: 3px solid #f44336;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0;   box-shadow: var(--shadow-sm);   position: relative; }  .warning::before {   content: '!';   position: absolute;   left: -12px;   top: 10px;   width: 20px;   height: 20px;   background: #f44336;   border-radius: 50%;   display: flex;   align-items: center;   justify-content: center;   font-weight: bold;   color: white;   font-size: 14px; }  /* Content containers with subtle gradients */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--gradient-bg);   border-right: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  #graphics-rightbar {   background: var(--gradient-bg);   border-left: 1px solid var(--border-light);   box-shadow: var(--shadow-md);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(99, 114, 166, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(99, 114, 166, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar with subtle glassmorphism */ .toolbar {   background: var(--gradient-bg);   border-bottom: 1px solid var(--border-light);   box-shadow: var(--shadow-sm);   backdrop-filter: blur(10px);   -webkit-backdrop-filter: blur(10px);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations with consistent styling */ .btn {   border: 1px solid var(--border-light);   background-color: rgba(99, 114, 166, 0.1);   color: var(--text-primary);   text-transform: uppercase;   letter-spacing: 0.5px;   font-weight: 500;   padding: 8px 14px;   border-radius: 4px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   position: relative;   overflow: hidden;   font-size: 0.85rem; }  .btn:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);   transform: translateY(-2px); }  .btn:active {   transform: translateY(1px); }  .btn-primary {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.2), rgba(0, 188, 212, 0.2));   border: 1px solid var(--accent-primary);   color: var(--text-primary);   position: relative;   z-index: 1; }  .btn-primary:hover {   background: linear-gradient(135deg, rgba(124, 77, 255, 0.3), rgba(0, 188, 212, 0.3));   box-shadow: 0 4px 16px rgba(124, 77, 255, 0.2); }  .btn-primary::before {   content: '';   position: absolute;   top: 0;   left: 0;   right: 0;   bottom: 0;   background: var(--gradient-accent);   opacity: 0;   z-index: -1;   transition: opacity 0.3s ease;   border-radius: 3px; }  .btn-primary:hover::before {   opacity: 0.1; }  .btn-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336; }  .btn-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2); }  .btn-secondary {   background-color: rgba(99, 114, 166, 0.1);   border: 1px solid var(--border-light); }  .btn-secondary:hover {   background-color: rgba(99, 114, 166, 0.2);   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); }  .btn-special {   background-color: rgba(0, 188, 212, 0.15);   border: 1px solid var(--accent-secondary);   color: var(--accent-secondary); }  .btn-special:hover {   background-color: rgba(0, 188, 212, 0.25);   box-shadow: 0 4px 16px rgba(0, 188, 212, 0.2); }  /* Shape list with improved visual hierarchy */ #shape-list {   border-bottom: 1px solid var(--border-light);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-light);   border-radius: 4px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: rgba(99, 114, 166, 0.15);   transform: translateX(3px);   border-color: var(--border-light); }  .shape-item.active {   background-color: rgba(0, 188, 212, 0.1);   border-color: var(--accent-secondary);   color: var(--accent-secondary);   box-shadow: 0 0 12px rgba(0, 188, 212, 0.15);   font-weight: 500; }  /* Inspector panel with clean design */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-light);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--accent-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-light);   background-color: rgba(15, 17, 26, 0.6);   color: var(--text-primary);   padding: 10px 12px;   border-radius: 4px; }  /* Scene info with modern styling */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-light);   border-radius: 6px;   padding: 12px 16px;   margin-bottom: 16px;   box-shadow: var(--shadow-sm); }  .button-danger {   background-color: rgba(244, 67, 54, 0.15);   border: 1px solid #f44336;   color: #f44336;   padding: 10px 16px;   border-radius: 4px;   font-weight: 500;   transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1); }  .button-danger:hover {   background-color: rgba(244, 67, 54, 0.25);   box-shadow: 0 4px 16px rgba(244, 67, 54, 0.2);   transform: translateY(-2px); }  /* Typography improvements */ h2, h3 {   color: var(--accent-primary);   text-transform: uppercase;   letter-spacing: 1px;   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-light);   font-weight: 600;   text-shadow: 0 0 20px rgba(124, 77, 255, 0.3);   position: relative; }  h2::after, h3::after {   content: '';   position: absolute;   bottom: -1px;   left: 0;   width: 50px;   height: 2px;   background: var(--gradient-accent);   box-shadow: 0 0 8px rgba(124, 77, 255, 0.5); }  /* Sleek scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(124, 77, 255, 0.3);   border-radius: 3px;   border: 1px solid var(--bg-tertiary); }  ::-webkit-scrollbar-thumb:hover {   background: var(--accent-primary); }  /* Animations and transitions */ @keyframes pulse {   0% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0.4); }   70% { box-shadow: 0 0 0 10px rgba(124, 77, 255, 0); }   100% { box-shadow: 0 0 0 0 rgba(124, 77, 255, 0); } }  .pulse-animation {   animation: pulse 2s infinite; }  /* Tooltips */ [data-tooltip] {   position: relative; }  [data-tooltip]::after {   content: attr(data-tooltip);   position: absolute;   bottom: 125%;   left: 50%;   transform: translateX(-50%);   padding: 6px 10px;   background: var(--bg-tertiary);   color: var(--text-primary);   border-radius: 4px;   font-size: 0.75rem;   white-space: nowrap;   opacity: 0;   visibility: hidden;   transition: all 0.3s ease;   z-index: 100;   box-shadow: var(--shadow-md);   border: 1px solid var(--border-light); }  [data-tooltip]:hover::after {   opacity: 1;   visibility: visible; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional3.css"
    },
    "medieval": {
      "title": "Medieval",
      "fileName": "medieval",
      "css": "/* Medieval Theme */ @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=IM+Fell+English&display=swap');  body {     font-family: 'Cinzel', 'IM Fell English', serif;     background-color: #2b1e12; /* Dark brown, earthy tone */     color: #d4b98a; /* Parchment-like beige */ }  .sidebar {     background-color: rgba(50, 40, 30, 0.8); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), inset 0 0 20px rgba(50, 40, 30, 0.3); }  .object-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .editor {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #b8860b;     box-shadow: 0 0 15px rgba(184, 134, 11, 0.3); }  #three-js-container {     border: 1px solid rgba(138, 92, 46, 0.5); /* Bronze edge */ }  .preview-canvas-container {     border: 1px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.3); }  .preview {     background-color: rgba(50, 40, 30, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(138, 92, 46, 0.5); }  .camera-controls {     background: rgba(40, 30, 20, 0.7); /* Dark stone */     border: 1px solid #8a5c2e; }  .camera-controls button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a; }  .camera-controls .color-picker {     border: 1px solid #8a5c2e; }  .camera-controls .size-slider {     background: #3c2f1e; /* Darker wood */     border: 1px solid #8a5c2e; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #b8860b; /* Gold text */ }  input, textarea, select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  button {     background-color: rgba(138, 92, 46, 0.2);     border: 1px solid #8a5c2e;     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  button:hover {     background-color: rgba(138, 92, 46, 0.3);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5), 0 0 20px rgba(138, 92, 46, 0.2);     transform: translateY(-2px); }  button.primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  button.primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5), 0 0 20px rgba(184, 134, 11, 0.2); }  button.danger {     background-color: rgba(139, 0, 0, 0.2); /* Crimson */     border: 1px solid #8b0000;     color: #ff4040; }  button.danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5), 0 0 20px rgba(139, 0, 0, 0.2); }  button.active {     border: 1px solid #228b22; /* Forest green */     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5);     color: #228b22; }  .modal {     background-color: rgba(40, 30, 20, 0.85); /* Stone texture */     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(50, 40, 30, 0.9);     border: 1px solid #8a5c2e;     box-shadow: 0 0 30px rgba(138, 92, 46, 0.3), 0 0 60px rgba(138, 92, 46, 0.1); }  .property-list {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6); }  .tab-navigation {     border-bottom: 1px solid #8a5c2e; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(138, 92, 46, 0.1); }  .tab.active {     border-bottom: 3px solid #b8860b;     box-shadow: 0 5px 10px -5px rgba(184, 134, 11, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(60, 50, 40, 0.6);     border-left: 4px solid #b8860b;     box-shadow: 0 0 10px rgba(184, 134, 11, 0.2); }  #grid-display {     background-color: rgba(40, 30, 20, 0.7);     border: 1px solid #8a5c2e;     box-shadow: 0 0 10px rgba(138, 92, 46, 0.3); }  .success-message {     color: #228b22; /* Forest green */     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(139, 0, 0, 0.1);     border-left: 4px solid #8b0000;     box-shadow: 0 0 10px rgba(139, 0, 0, 0.2); }  .main-content-container {     background-color: #251a10; /* Darker brown */     color: #d4b98a; }  .content-sidebar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-right: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-left: 1px solid #8a5c2e;     box-shadow: 0 0 20px rgba(138, 92, 46, 0.2); }  .grid-background {     background: #1e150d;     background-image: radial-gradient(rgba(138, 92, 46, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(60, 50, 40, 0.8), rgba(40, 30, 20, 0.8));     border-bottom: 1px solid #8a5c2e; }  .btn {     border: 1px solid #8a5c2e;     background-color: rgba(138, 92, 46, 0.1);     color: #d4b98a;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(138, 92, 46, 0.2);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(184, 134, 11, 0.2);     border: 1px solid #b8860b;     color: #b8860b; }  .btn-primary:hover {     background-color: rgba(184, 134, 11, 0.3);     box-shadow: 0 0 10px rgba(184, 134, 11, 0.5); }  .btn-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .btn-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  .btn-secondary {     background-color: rgba(138, 92, 46, 0.15);     border: 1px solid #8a5c2e; }  .btn-secondary:hover {     background-color: rgba(138, 92, 46, 0.25);     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .btn-special {     background-color: rgba(34, 139, 34, 0.2); /* Forest green */     border: 1px solid #228b22;     color: #228b22; }  .btn-special:hover {     background-color: rgba(34, 139, 34, 0.3);     box-shadow: 0 0 10px rgba(34, 139, 34, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(138, 92, 46, 0.2); }  .shape-item {     background-color: rgba(60, 50, 40, 0.6);     border: 1px solid #8a5c2e; }  .shape-item:hover {     background-color: rgba(138, 92, 46, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(34, 139, 34, 0.1);     border-color: #228b22;     color: #228b22;     box-shadow: 0 0 10px rgba(34, 139, 34, 0.3); }  #inspector {     background: rgba(60, 50, 40, 0.8);     border-top: 1px solid #8a5c2e; }  .form-row label {     color: #b8860b; }  .form-row input, .form-row select {     border: 1px solid #8a5c2e;     background-color: rgba(60, 50, 40, 0.6);     color: #d4b98a;     box-shadow: 0 0 5px rgba(138, 92, 46, 0.3); }  .scene-info {     background: rgba(40, 30, 20, 0.8);     color: #d4b98a;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.3);     border: 1px solid #8a5c2e; }  .button-danger {     background-color: rgba(139, 0, 0, 0.2);     border: 1px solid #8b0000;     color: #ff4040; }  .button-danger:hover {     background-color: rgba(139, 0, 0, 0.3);     box-shadow: 0 0 10px rgba(139, 0, 0, 0.5); }  h2, h3 {     color: #b8860b;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #8a5c2e;     text-shadow: 0 0 5px rgba(184, 134, 11, 0.7); }   .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(138, 92, 46, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(138, 92, 46, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(60, 50, 40, 0.8);     border: 1px solid #8a5c2e;     color: #228b22; /* Green ink */     font-family: 'IM Fell English', serif;     padding: 15px;     box-shadow: 0 0 15px rgba(138, 92, 46, 0.2), inset 0 0 30px rgba(60, 50, 40, 0.5); }  .ref-value-item {     background-color: #4a3a2a; /* Darker wood */ }  .remove-ref-btn {     background: none;     border: none;     color: #ff4040;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(60, 50, 40, 0.6); }  ::-webkit-scrollbar-thumb {     background: #8a5c2e;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #b8860b; }  /* Category Styling for Medieval Theme */ .type-selector {     background-color: rgba(50, 40, 30, 0.7); /* Dark wood */     border: 1px solid #8a5c2e; /* Bronze */     box-shadow: inset 0 0 10px rgba(138, 92, 46, 0.3); }  .category-header {     background-color: rgba(60, 50, 40, 0.8); /* Aged wood */     border: 1px solid #8a5c2e;     color: #d4b98a; /* Parchment beige */     text-transform: uppercase;     letter-spacing: 1px;     font-weight: bold; }  .category-header:hover {     background-color: rgba(138, 92, 46, 0.2); /* Bronze hover */     box-shadow: 0 0 10px rgba(138, 92, 46, 0.5); }  .category-types {     background-color: rgba(40, 30, 20, 0.6); /* Dark stone */ }  .object-type-item {     background-color: rgba(60, 50, 40, 0.6); /* Aged wood */     border-left: 2px solid #b8860b; /* Gold accent */     color: #d4b98a;     text-transform: uppercase;     letter-spacing: 1px; }  .object-type-item:hover {     background-color: rgba(184, 134, 11, 0.2); /* Golden hover */     transform: translateX(5px); }  .object-type-item.selected {     background-color: rgba(184, 134, 11, 0.3);     border-left: 4px solid #b8860b;     box-shadow: 0 0 8px rgba(184, 134, 11, 0.5); }  .object-list {     background-color: rgba(50, 40, 30, 0.5); /* Slightly lighter wood */ }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/medieval.css"
    },
    "professional": {
      "title": "Professional",
      "fileName": "professional",
      "css": "/* Professional Theme */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #1a1a2e;     color: #e6e6fa;     line-height: 1.6; }  .sidebar {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.2); }  .object-item {     background-color: rgba(34, 34, 54, 0.8);     border-left: 2px solid #8a4af0;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(138, 74, 240, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(138, 74, 240, 0.25);     border-left: 3px solid #8a4af0;     box-shadow: 0 0 6px rgba(138, 74, 240, 0.4); }  .editor {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #three-js-container {     border: 1px solid rgba(75, 94, 135, 0.6); }  .preview-canvas-container {     border: 1px solid #8a4af0;     box-shadow: 0 4px 12px rgba(138, 74, 240, 0.1); }  .preview {     background-color: rgba(34, 34, 54, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(75, 94, 135, 0.5); }  .camera-controls {     background: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87; }  .camera-controls button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .camera-controls .color-picker {     border: 1px solid #4b5e87; }  .camera-controls .size-slider {     background: #2a2a42;     border: 1px solid #4b5e87; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #8a4af0; }  input, textarea, select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #8a4af0;     box-shadow: 0 0 8px rgba(138, 74, 240, 0.3); }  button {     background-color: rgba(75, 94, 135, 0.3);     border: 1px solid #4b5e87;     color: #e6e6fa;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  button.primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  button.danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  button.danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  button.active {     border: 1px solid #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.4);     color: #00cc99; }  .modal {     background-color: rgba(26, 26, 46, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(34, 34, 54, 0.95);     border: 1px solid #4b5e87;     box-shadow: 0 8px 24px rgba(75, 94, 135, 0.2); }  .property-list {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8); }  .tab-navigation {     border-bottom: 1px solid #4b5e87; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(75, 94, 135, 0.2); }  .tab.active {     border-bottom: 2px solid #8a4af0;     box-shadow: 0 4px 8px -4px rgba(138, 74, 240, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(34, 34, 54, 0.8);     border-left: 3px solid #8a4af0;     box-shadow: 0 2px 6px rgba(138, 74, 240, 0.1); }  #grid-display {     background-color: rgba(26, 26, 46, 0.9);     border: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .success-message {     color: #00cc99;     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(240, 74, 74, 0.15);     border-left: 3px solid #f04a4a;     box-shadow: 0 2px 6px rgba(240, 74, 74, 0.1); }  .main-content-container {     background-color: #1f1f38;     color: #e6e6fa; }  .content-sidebar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-right: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-left: 1px solid #4b5e87;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15); }  .grid-background {     background: #1a1a2e;     background-image: radial-gradient(rgba(75, 94, 135, 0.15) 1px, transparent 1px);     background-size: 30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(34, 34, 54, 0.95), rgba(26, 26, 46, 0.95));     border-bottom: 1px solid #4b5e87; }  .btn {     border: 1px solid #4b5e87;     background-color: rgba(75, 94, 135, 0.3);     color: #e6e6fa;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(75, 94, 135, 0.5);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(138, 74, 240, 0.3);     border: 1px solid #8a4af0;     color: #e6e6fa; }  .btn-primary:hover {     background-color: rgba(138, 74, 240, 0.5);     box-shadow: 0 2px 8px rgba(138, 74, 240, 0.3); }  .btn-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .btn-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  .btn-secondary {     background-color: rgba(75, 94, 135, 0.25);     border: 1px solid #4b5e87; }  .btn-secondary:hover {     background-color: rgba(75, 94, 135, 0.4);     box-shadow: 0 2px 8px rgba(75, 94, 135, 0.3); }  .btn-special {     background-color: rgba(0, 204, 153, 0.3);     border: 1px solid #00cc99;     color: #e6e6fa; }  .btn-special:hover {     background-color: rgba(0, 204, 153, 0.5);     box-shadow: 0 2px 8px rgba(0, 204, 153, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(75, 94, 135, 0.3); }  .shape-item {     background-color: rgba(34, 34, 54, 0.8);     border: 1px solid #4b5e87;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(75, 94, 135, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(0, 204, 153, 0.15);     border-color: #00cc99;     color: #00cc99;     box-shadow: 0 0 8px rgba(0, 204, 153, 0.3); }  #inspector {     background: rgba(34, 34, 54, 0.95);     border-top: 1px solid #4b5e87; }  .form-row label {     color: #8a4af0; }  .form-row input, .form-row select {     border: 1px solid #4b5e87;     background-color: rgba(34, 34, 54, 0.8);     color: #e6e6fa;     box-shadow: 0 2px 6px rgba(75, 94, 135, 0.1); }  .scene-info {     background: rgba(26, 26, 46, 0.9);     color: #e6e6fa;     box-shadow: 0 4px 12px rgba(75, 94, 135, 0.15);     border: 1px solid #4b5e87; }  .button-danger {     background-color: rgba(240, 74, 74, 0.3);     border: 1px solid #f04a4a;     color: #e6e6fa; }  .button-danger:hover {     background-color: rgba(240, 74, 74, 0.5);     box-shadow: 0 2px 8px rgba(240, 74, 74, 0.3); }  h2, h3 {     color: #8a4af0;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #4b5e87;     text-shadow: 0 0 4px rgba(138, 74, 240, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(34, 34, 54, 0.8); }  ::-webkit-scrollbar-thumb {     background: #4b5e87;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #8a4af0; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional.css"
    },
    "videogame": {
      "title": "Video Game",
      "fileName": "videogame",
      "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Share+Tech+Mono&display=swap');  body {     font-family: 'Orbitron', 'Share Tech Mono', sans-serif;     background-color: #0a0a0a; /* Deep black */     color: #00d4ff; /* Neon blue */     overflow: hidden; }  .sidebar {     background: linear-gradient(135deg, rgba(10, 10, 10, 0.9), rgba(155, 0, 255, 0.1)); /* Black to purple fade */     border: 1px solid #ff007a; /* Hot pink */     box-shadow: 0 0 15px rgba(0, 212, 255, 0.5), inset 0 0 10px rgba(155, 0, 255, 0.3); }  .inventory-item {     background-color: rgba(12, 12, 12, 0.7);     border-left: 3px solid #9b00ff; /* Electric purple */     text-transform: uppercase;     letter-spacing: 2px;     transition: all 0.2s ease; }  .inventory-item:hover {     background-color: rgba(0, 212, 255, 0.2);     transform: scale(1.03);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.7); }  .inventory-item.active {     background-color: rgba(255, 0, 122, 0.3); /* Pink glow */     border-left: 5px solid #ff007a;     box-shadow: 0 0 15px rgba(255, 0, 122, 0.8); }  .hud {     background: rgba(10, 10, 10, 0.8);     border: 1px solid #00d4ff;     box-shadow: 0 0 20px rgba(0, 212, 255, 0.4); }  #game-canvas {     border: 1px dashed #c0c0c0; /* Silver dashed */     background: radial-gradient(circle, rgba(155, 0, 255, 0.1), transparent); }  .hologram-display {     border: 2px solid #9b00ff;     box-shadow: 0 0 25px rgba(155, 0, 255, 0.6);     animation: pulseGlow 2s infinite alternate; }  @keyframes pulseGlow {     0% { box-shadow: 0 0 25px rgba(155, 0, 255, 0.6); }     100% { box-shadow: 0 0 35px rgba(155, 0, 255, 0.9); } }  .control-panel {     background: rgba(0, 0, 0, 0.85);     border: 1px solid #c0c0c0; }  .control-panel button {     background-color: rgba(0, 212, 255, 0.2);     border: 1px solid #00d4ff;     color: #fff;     text-transform: uppercase;     transition: all 0.3s ease; }  .control-panel button:hover {     background-color: rgba(0, 212, 255, 0.4);     box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);     transform: translateY(-3px); }  label {     color: #ff007a; /* Hot pink */     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1.5px; }  input, textarea, select {     border: 1px solid #9b00ff;     background-color: rgba(10, 10, 10, 0.7);     color: #00d4ff;     box-shadow: 0 0 8px rgba(155, 0, 255, 0.4); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #ff007a;     box-shadow: 0 0 12px rgba(255, 0, 122, 0.7); }  button {     background-color: rgba(155, 0, 255, 0.2);     border: 1px solid #9b00ff;     color: #fff;     text-transform: uppercase;     letter-spacing: 1px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(155, 0, 255, 0.4);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.7);     transform: translateY(-2px) scale(1.05); }  button.primary {     background-color: rgba(0, 212, 255, 0.3);     border: 1px solid #00d4ff;     color: #fff; }  button.primary:hover {     background-color: rgba(0, 212, 255, 0.5);     box-shadow: 0 0 20px rgba(0, 212, 255, 0.9); }  button.alert {     background-color: rgba(255, 0, 122, 0.2);     border: 1px solid #ff007a;     color: #fff; }  button.alert:hover {     background-color: rgba(255, 0, 122, 0.4);     box-shadow: 0 0 15px rgba(255, 0, 122, 0.7); }  .modal {     background: rgba(0, 0, 0, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background: linear-gradient(45deg, rgba(10, 10, 10, 0.9), rgba(0, 212, 255, 0.1));     border: 1px solid #00d4ff;     box-shadow: 0 0 30px rgba(0, 212, 255, 0.5); }  .notification {     background-color: rgba(155, 0, 255, 0.3);     border-left: 4px solid #9b00ff;     color: #fff;     animation: slideIn 0.5s ease-out; }  @keyframes slideIn {     0% { transform: translateX(100%); opacity: 0; }     100% { transform: translateX(0); opacity: 1; } }  .main-content {     background: #0a0a0a;     animation: glitch 4s infinite; }   .grid-overlay {     background: repeating-linear-gradient(45deg, rgba(155, 0, 255, 0.05), rgba(155, 0, 255, 0.05) 10px, transparent 10px, transparent 20px); }  .btn {     border: 1px solid #c0c0c0;     background-color: rgba(0, 212, 255, 0.15);     color: #fff; }  .btn:hover {     background-color: rgba(0, 212, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 212, 255, 0.6); }  .btn-primary {     background-color: rgba(9b, 0, 255, 0.25);     border: 1px solid #9b00ff; }  .btn-primary:hover {     background-color: rgba(155, 0, 255, 0.45);     box-shadow: 0 0 15px rgba(155, 0, 255, 0.8); }  ::-webkit-scrollbar {     width: 6px; }  ::-webkit-scrollbar-track {     background: #0a0a0a; }  ::-webkit-scrollbar-thumb {     background: #00d4ff;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #ff007a; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videogame.css"
    },
    "professional2": {
      "title": "Professional Warm",
      "fileName": "professional2",
      "css": "/* Professional Cyberpunk Variation - Warm Edition */ @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');  body {     font-family: 'Inter', 'Roboto Mono', sans-serif;     background-color: #2b1e1e; /* Deep reddish-brown */     color: #f4e1d2; /* Soft cream for text */     line-height: 1.6; }  .sidebar {     background-color: rgba(54, 36, 36, 0.95); /* Muted dark red */     border: 1px solid #7a4e4e; /* Subtle reddish-gray */     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.2); }  .object-item {     background-color: rgba(54, 36, 36, 0.8);     border-left: 2px solid #d97706; /* Warm amber */     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .object-item:hover {     background-color: rgba(217, 119, 6, 0.15);     transform: translateX(3px); }  .object-item.selected {     background-color: rgba(217, 119, 6, 0.25);     border-left: 3px solid #d97706;     box-shadow: 0 0 6px rgba(217, 119, 6, 0.4); }  .editor {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #three-js-container {     border: 1px solid rgba(122, 78, 78, 0.6); }  .preview-canvas-container {     border: 1px solid #d97706;     box-shadow: 0 4px 12px rgba(217, 119, 6, 0.1); }  .preview {     background-color: rgba(54, 36, 36, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(122, 78, 78, 0.5); }  .camera-controls {     background: rgba(46, 28, 28, 0.9); /* Darker reddish tint */     border: 1px solid #7a4e4e; }  .camera-controls button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     transition: all 0.3s ease; }  .camera-controls button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .camera-controls .color-picker {     border: 1px solid #7a4e4e; }  .camera-controls .size-slider {     background: #3a2424;     border: 1px solid #7a4e4e; }  label {     font-weight: 500;     text-transform: uppercase;     letter-spacing: 0.5px;     color: #d97706; /* Amber for labels */ }  input, textarea, select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1);     transition: all 0.3s ease; }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #d97706;     box-shadow: 0 0 8px rgba(217, 119, 6, 0.3); }  button {     background-color: rgba(122, 78, 78, 0.3);     border: 1px solid #7a4e4e;     color: #f4e1d2;     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  button:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  button.primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  button.primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  button.danger {     background-color: rgba(220, 38, 38, 0.3); /* Softer red */     border: 1px solid #dc2626;     color: #f4e1d2; }  button.danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  button.active {     border: 1px solid #10b981; /* Emerald green for active state */     box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);     color: #10b981; }  .modal {     background-color: rgba(46, 28, 28, 0.9);     backdrop-filter: blur(3px); }  .modal-content {     background-color: rgba(54, 36, 36, 0.95);     border: 1px solid #7a4e4e;     box-shadow: 0 8px 24px rgba(122, 78, 78, 0.2); }  .property-list {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8); }  .tab-navigation {     border-bottom: 1px solid #7a4e4e; }  .tab {     text-transform: uppercase;     letter-spacing: 0.5px;     transition: all 0.3s ease; }  .tab:hover {     background-color: rgba(122, 78, 78, 0.2); }  .tab.active {     border-bottom: 2px solid #d97706;     box-shadow: 0 4px 8px -4px rgba(217, 119, 6, 0.4);     font-weight: 600; }  .instructions {     background-color: rgba(54, 36, 36, 0.8);     border-left: 3px solid #d97706;     box-shadow: 0 2px 6px rgba(217, 119, 6, 0.1); }  #grid-display {     background-color: rgba(46, 28, 28, 0.9);     border: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .success-message {     color: #10b981; /* Emerald green for success */     text-transform: uppercase;     letter-spacing: 0.5px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(220, 38, 38, 0.15);     border-left: 3px solid #dc2626;     box-shadow: 0 2px 6px rgba(220, 38, 38, 0.1); }  .main-content-container {     background-color: #332121; /* Slightly lighter reddish-brown */     color: #f4e1d2; }  .content-sidebar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-right: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-left: 1px solid #7a4e4e;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15); }  .grid-background {     background: #2b1e1e;     background-image: radial-gradient(rgba(122, 78, 78, 0.15) 1px, transparent 1px);     background-size:30px 30px; }  .toolbar {     background: linear-gradient(90deg, rgba(54, 36, 36, 0.95), rgba(46, 28, 28, 0.95));     border-bottom: 1px solid #7a4e4e; }  .btn {     border: 1px solid #7a4e4e;     background-color: rgba(122, 78, 78, 0.3);     color: #f4e1d2;     text-transform: uppercase;     transition: all 0.3s ease; }  .btn:hover {     background-color: rgba(122, 78, 78, 0.5);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3);     transform: translateY(-1px); }  .btn-primary {     background-color: rgba(217, 119, 6, 0.3);     border: 1px solid #d97706;     color: #f4e1d2; }  .btn-primary:hover {     background-color: rgba(217, 119, 6, 0.5);     box-shadow: 0 2px 8px rgba(217, 119, 6, 0.3); }  .btn-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .btn-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  .btn-secondary {     background-color: rgba(122, 78, 78, 0.25);     border: 1px solid #7a4e4e; }  .btn-secondary:hover {     background-color: rgba(122, 78, 78, 0.4);     box-shadow: 0 2px 8px rgba(122, 78, 78, 0.3); }  .btn-special {     background-color: rgba(16, 185, 129, 0.3);     border: 1px solid #10b981;     color: #f4e1d2; }  .btn-special:hover {     background-color: rgba(16, 185, 129, 0.5);     box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3); }  #shape-list {     border-bottom: 1px solid rgba(122, 78, 78, 0.3); }  .shape-item {     background-color: rgba(54, 36, 36, 0.8);     border: 1px solid #7a4e4e;     transition: all 0.3s ease; }  .shape-item:hover {     background-color: rgba(122, 78, 78, 0.2);     transform: translateX(3px); }  .shape-item.active {     background-color: rgba(16, 185, 129, 0.15);     border-color: #10b981;     color: #10b981;     box-shadow: 0 0 8px rgba(16, 185, 129, 0.3); }  #inspector {     background: rgba(54, 36, 36, 0.95);     border-top: 1px solid #7a4e4e; }  .form-row label {     color: #d97706; }  .form-row input, .form-row select {     border: 1px solid #7a4e4e;     background-color: rgba(54, 36, 36, 0.8);     color: #f4e1d2;     box-shadow: 0 2px 6px rgba(122, 78, 78, 0.1); }  .scene-info {     background: rgba(46, 28, 28, 0.9prisma);     color: #f4e1d2;     box-shadow: 0 4px 12px rgba(122, 78, 78, 0.15);     border: 1px solid #7a4e4e; }  .button-danger {     background-color: rgba(220, 38, 38, 0.3);     border: 1px solid #dc2626;     color: #f4e1d2; }  .button-danger:hover {     background-color: rgba(220, 38, 38, 0.5);     box-shadow: 0 2px 8px rgba(220, 38, 38, 0.3); }  h2, h3 {     color: #d97706;     text-transform: uppercase;     letter-spacing: 1px;     margin-bottom: 12px;     padding-bottom: 4px;     border-bottom: 1px solid #7a4e4e;     text-shadow: 0 0 4px rgba(217, 119, 6, 0.3); }  ::-webkit-scrollbar {     width: 6px;     height: 6px; }  ::-webkit-scrollbar-track {     background: rgba(54, 36, 36, 0.8); }  ::-webkit-scrollbar-thumb {     background: #7a4e4e;     border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {     background: #d97706; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/professional2.css"
    },
    "scifi2": {
      "title": "SciFi2.0",
      "fileName": "scifi2",
      "css": "@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&display=swap'); :root {     --primary-bg: #0a0a1a;     --secondary-bg: #121228;     --accent-color: #00ffff;     --text-color: #e0e7ff;     --border-color: #2a2a4a;     --highlight-color: #ff00ff;     --hover-color: rgba(0, 255, 255, 0.2); }  body {     background-color: var(--primary-bg);     color: var(--text-color);     font-family: 'Orbitron', 'Arial', sans-serif;     line-height: 1.6; }  .container {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 20px rgba(0, 255, 255, 0.1); }  /* Sidebar Styling */ .sidebar {     background-color: #0f0f2a;     border-right: 1px solid var(--border-color); }  .object-item, .object-type-item {     background-color: var(--secondary-bg);     border: 1px solid var(--border-color);     color: var(--text-color);     transition: all 0.3s ease; }  .object-item:hover, .object-type-item:hover {     background-color: var(--hover-color);     border-color: var(--accent-color); }  .object-item.selected, .object-type-item.selected {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Button Styling */ button {     background-color: var(--secondary-bg);     color: var(--accent-color);     border: 2px solid var(--accent-color);     transition: all 0.3s ease;     position: relative;     overflow: hidden; }  button:before {     content: '';     position: absolute;     top: 0;     left: -100%;     width: 100%;     height: 100%;     background: linear-gradient(120deg, transparent, var(--highlight-color), transparent);     transition: all 0.5s ease; }  button:hover:before {     left: 100%; }  button:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  .primary {     background-color: var(--accent-color);     color: var(--primary-bg); }  .danger {     border-color: #ff4444;     color: #ff4444; }  /* Input Styling */ input, textarea, select {     background-color: var(--secondary-bg);     color: var(--text-color);     border: 1px solid var(--border-color);     transition: border-color 0.3s ease; }  input:focus, textarea:focus, select:focus {     border-color: var(--accent-color);     outline: none;     box-shadow: 0 0 10px rgba(0, 255, 255, 0.2); }  /* Modal Styling */ .modal {     background-color: rgba(10, 10, 26, 0.9); }  .modal-content {     background-color: var(--secondary-bg);     border: 2px solid var(--border-color);     box-shadow: 0 0 30px rgba(0, 255, 255, 0.1); }  /* Graphics Editor Enhancements */ #canvas-container {     background:          linear-gradient(45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(-45deg, rgba(0,255,255,0.05) 25%, transparent 25%) 0 0,         linear-gradient(45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0,         linear-gradient(-45deg, transparent 75%, rgba(0,255,255,0.05) 75%) 0 0;     background-size: 20px 20px;     background-color: var(--primary-bg); }  .scene-info {     background-color: rgba(18, 18, 40, 0.8);     border: 1px solid var(--border-color);     color: var(--accent-color); }  /* Toolbar Styling */ .toolbar .btn {     background-color: var(--secondary-bg);     border-color: var(--border-color);     color: var(--accent-color); }  .toolbar .btn:hover {     background-color: var(--accent-color);     color: var(--primary-bg); }  /* Tab and Category Styling */ .tab, .category-header {     color: var(--text-color);     transition: color 0.3s ease; }  .tab:hover, .category-header:hover {     color: var(--accent-color); }  .tab.active {     border-bottom-color: var(--accent-color); }  /* Scrollbar (for browsers that support) */ ::-webkit-scrollbar {     width: 10px; }  ::-webkit-scrollbar-track {     background: var(--secondary-bg); }  ::-webkit-scrollbar-thumb {     background: var(--accent-color);     border-radius: 5px; }  ::-webkit-scrollbar-thumb:hover {     background: var(--highlight-color); }  /* Subtle Sci-Fi Animations */ @keyframes pulse-border {     0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.3); }     50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); } }  @keyframes grid-pulse {     0%, 100% { opacity: 0.1; }     50% { opacity: 0.3; } }  /* Additional Futuristic Effects */ body::before {     content: '';     position: fixed;     top: 0;     left: 0;     width: 100%;     height: 100%;     pointer-events: none;     background:          repeating-linear-gradient(             0deg,             rgba(0, 0, 0, 0.15),             rgba(0, 0, 0, 0.15) 1px,             transparent 1px,             transparent 2px         );     opacity: 0.3;     z-index: 9999; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/scifi2.css"
    },
    "claude2": {
      "title": "Claude 2",
      "fileName": "claude2",
      "css": "/* Professional Theme - Clean UI */ @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap');  :root {   --bg-primary: #16192e;   --bg-secondary: #1d2035;   --bg-tertiary: #252a43;   --accent-primary: #4d7cff;   --accent-muted: rgba(77, 124, 255, 0.15);   --text-primary: #e9edf5;   --text-secondary: #a9b1c3;   --border-color: rgba(108, 123, 163, 0.25);   --shadow-sm: 0 2px 6px rgba(0, 0, 0, 0.2);   --shadow-md: 0 4px 12px rgba(0, 0, 0, 0.25); }  body {   font-family: 'Inter', sans-serif;   background-color: var(--bg-primary);   color: var(--text-primary);   line-height: 1.6; }  /* Sidebar styling */ .sidebar {   background-color: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  .object-item {   background-color: transparent;   border-left: 2px solid transparent;   text-transform: none;   letter-spacing: 0.2px;   color: var(--text-secondary);   font-weight: 400;   transition: all 0.2s ease;   padding: 10px 14px;   margin-bottom: 2px; }  .object-item:hover {   background-color: var(--bg-tertiary);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary); }  .object-item.selected {   background-color: var(--accent-muted);   border-left: 2px solid var(--accent-primary);   color: var(--text-primary);   font-weight: 500; }  /* Editor area */ .editor {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #three-js-container {   border: 1px solid var(--border-color);   border-radius: 4px;   background: var(--bg-primary); }  .preview-canvas-container {   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .preview {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  #preview-canvas {   background-color: transparent;   border: 1px solid var(--border-color);   border-radius: 2px; }  /* Camera controls */ .camera-controls {   background: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px; }  .camera-controls button {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   color: var(--text-primary);   border-radius: 3px;   padding: 8px 12px;   transition: all 0.2s ease; }  .camera-controls button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .camera-controls .color-picker {   border: 1px solid var(--border-color);   border-radius: 3px; }  .camera-controls .size-slider {   background: var(--bg-secondary);   border: 1px solid var(--border-color);   border-radius: 3px;   height: 5px; }  .camera-controls .size-slider::-webkit-slider-thumb {   background: var(--accent-primary);   border-radius: 50%;   cursor: pointer; }  /* Form elements */ label {   font-weight: 500;   color: var(--text-primary);   margin-bottom: 6px;   display: block;   font-size: 0.875rem; }  input, textarea, select {   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   border-radius: 3px;   width: calc(100% - 24px);  padding: 8px 12px;   transition: all 0.2s ease;   font-family: 'IBM Plex Mono', monospace; }  input:focus, textarea:focus, select:focus {   outline: none;   border-color: var(--accent-primary);   box-shadow: 0 0 0 2px var(--accent-muted); }  /* Button styles */ button {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease; }  button:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  button.primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  button.primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6;   box-shadow: var(--shadow-sm); }  button.danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  button.danger:hover {   background-color: rgba(235, 68, 68, 0.25);   box-shadow: var(--shadow-sm); }  button.active {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  /* Modal styling */ .modal {   background-color: rgba(22, 25, 46, 0.8); }  .modal-content {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-md);   border-radius: 4px; }  .property-list {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   border-radius: 4px; }  /* Tab navigation */ .tab-navigation {   border-bottom: 1px solid var(--border-color);   display: flex;   padding: 0 4px; }  .tab {   padding: 10px 16px;   color: var(--text-secondary);   transition: all 0.2s ease; }  .tab:hover {   background-color: var(--bg-tertiary);   color: var(--text-primary); }  .tab.active {   color: var(--accent-primary);   font-weight: 500;   border-bottom: 2px solid var(--accent-primary); }  /* Info and warning boxes */ .instructions {   background-color: var(--bg-tertiary);   border-left: 3px solid var(--accent-primary);   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  #grid-display {   background-color: var(--bg-secondary);   border: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   border-radius: 4px; }  .success-message {   color: #34c79a;   font-weight: 500;   animation: fadeOut 2s forwards;   animation-delay: 1.5s;   padding: 8px 12px; }  @keyframes fadeOut {   from { opacity: 1; }   to { opacity: 0; } }  .warning {   background-color: rgba(235, 68, 68, 0.1);   border-left: 3px solid #eb4444;   border-radius: 0 4px 4px 0;   padding: 12px 16px;   margin: 16px 0; }  /* Main containers */ .main-content-container {   background-color: var(--bg-primary);   color: var(--text-primary); }  .content-sidebar {   background: var(--bg-secondary);   border-right: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  #graphics-rightbar {   background: var(--bg-secondary);   border-left: 1px solid var(--border-color);   box-shadow: var(--shadow-sm); }  /* Subtle grid background */ .grid-background {   background: var(--bg-primary);   background-image:      linear-gradient(rgba(108, 123, 163, 0.05) 1px, transparent 1px),     linear-gradient(90deg, rgba(108, 123, 163, 0.05) 1px, transparent 1px);   background-size: 20px 20px; }  /* Toolbar */ .toolbar {   background: var(--bg-secondary);   border-bottom: 1px solid var(--border-color);   box-shadow: var(--shadow-sm);   padding: 8px 16px;   display: flex;   align-items: center;   gap: 8px; }  /* Button variations */ .btn {   border: 1px solid var(--border-color);   background-color: var(--bg-tertiary);   color: var(--text-primary);   font-weight: 500;   padding: 8px 14px;   border-radius: 3px;   transition: all 0.2s ease;   font-size: 0.875rem; }  .btn:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-primary {   background-color: var(--accent-primary);   border: 1px solid var(--accent-primary);   color: white; }  .btn-primary:hover {   background-color: #3a6ae6;   border-color: #3a6ae6; }  .btn-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444; }  .btn-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  .btn-secondary {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color); }  .btn-secondary:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .btn-special {   background-color: rgba(52, 199, 154, 0.15);   border: 1px solid #34c79a;   color: #34c79a; }  .btn-special:hover {   background-color: rgba(52, 199, 154, 0.25); }  /* Shape list */ #shape-list {   border-bottom: 1px solid var(--border-color);   padding-bottom: 16px;   margin-bottom: 16px; }  .shape-item {   background-color: var(--bg-tertiary);   border: 1px solid var(--border-color);   border-radius: 3px;   padding: 10px 14px;   margin-bottom: 6px;   transition: all 0.2s ease;   display: flex;   align-items: center;   gap: 8px; }  .shape-item:hover {   background-color: var(--accent-muted);   border-color: var(--accent-primary); }  .shape-item.active {   background-color: rgba(52, 199, 154, 0.1);   border-color: #34c79a;   color: #34c79a;   font-weight: 500; }  /* Inspector panel */ #inspector {   background: var(--bg-secondary);   border-top: 1px solid var(--border-color);   padding: 16px; }  .form-row {   margin-bottom: 12px; }  .form-row label {   color: var(--text-primary);   margin-bottom: 6px; }  .form-row input, .form-row select {   width: 100%;   border: 1px solid var(--border-color);   background-color: var(--bg-secondary);   color: var(--text-primary);   padding: 8px 12px;   border-radius: 3px; }  /* Scene info */ .scene-info {   background: var(--bg-tertiary);   color: var(--text-primary);   border: 1px solid var(--border-color);   border-radius: 4px;   padding: 12px 16px;   margin-bottom: 16px; }  .button-danger {   background-color: rgba(235, 68, 68, 0.15);   border: 1px solid #eb4444;   color: #eb4444;   padding: 8px 14px;   border-radius: 3px;   font-weight: 500;   transition: all 0.2s ease; }  .button-danger:hover {   background-color: rgba(235, 68, 68, 0.25); }  /* Typography */ h2, h3 {   color: var(--text-primary);   margin-bottom: 16px;   padding-bottom: 8px;   border-bottom: 1px solid var(--border-color);   font-weight: 600; }  /* Scrollbars */ ::-webkit-scrollbar {   width: 6px;   height: 6px; }  ::-webkit-scrollbar-track {   background: var(--bg-tertiary);   border-radius: 3px; }  ::-webkit-scrollbar-thumb {   background: rgba(108, 123, 163, 0.5);   border-radius: 3px; }  ::-webkit-scrollbar-thumb:hover {   background: rgba(108, 123, 163, 0.7); }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/claude2.css"
    },
    "codeMirrorTheme": {
      "title": "Code - Ez On Eyes",
      "fileName": "codeMirrorTheme",
      "css": ".CodeMirror {    background: #1e1e1e;    color: #d4d4d4;    font-size: 14px; } .CodeMirror-gutters {    background: #252525;  border-right: 1px solid #444; } .CodeMirror-linenumber {    color: #888; }.CodeMirror-cursor {    border-left: 1px solid #d4d4d4; } .CodeMirror-selected {    background: #3a3a3a; }.CodeMirror-focused .CodeMirror-selected {    background: #404040; /* Slightly lighter when focused */}.CodeMirror-activeline-background {    background: #2a2a2a; /* Subtle active line highlight */}.CodeMirror-matchingbracket {    color: #b5cea8; /* Muted green for matching brackets */}.CodeMirror-nonmatchingbracket {    color: #d16969; /* Soft red for non-matching */}/* Override default theme's syntax highlighting */.cm-s-default .cm-header { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-quote { color: #b5cea8; } /* Muted green (overrides #090) */.cm-negative { color: #d16969; } /* Soft red */.cm-positive { color: #6a9955; } /* Muted green */.cm-header, .cm-strong { font-weight: 700; }.cm-em { font-style: italic; }.cm-s-default .cm-link { color: #d7ba7d; text-decoration: underline; } /* Muted yellow (overrides #00c blue) */.cm-strikethrough { text-decoration: line-through; }.cm-s-default .cm-keyword { color: #ce9178; } /* Soft orange (overrides #708 purple) */.cm-s-default .cm-atom { color: #d4d4d4; } /* Light gray (overrides #219 blue) */.cm-s-default .cm-number { color: #b5cea8; } /* Muted green (overrides #164) */.cm-s-default .cm-def { color: #dcdcaa; } /* Soft yellow (overrides #00f blue) */.cm-s-default .cm-variable-2 { color: #d4d4d4; } /* Light gray (overrides #05a blue) */.cm-s-default .cm-variable-3, .cm-s-default .cm-type { color: #dcdcaa; } /* Soft yellow (overrides #085 blue) */.cm-s-default .cm-comment { color: #6a9955; } /* Muted green (overrides #a50) */.cm-s-default .cm-string { color: #ce9178; } /* Soft orange (overrides #a11) */.cm-s-default .cm-string-2 { color: #d7ba7d; } /* Muted yellow (overrides #f50) */.cm-s-default .cm-meta { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-qualifier { color: #d4d4d4; } /* Light gray (overrides #555) */.cm-s-default .cm-builtin { color: #dcdcaa; } /* Soft yellow (overrides #30a) */.cm-s-default .cm-bracket { color: #d4d4d4; } /* Light gray (overrides #997) */.cm-s-default .cm-tag { color: #dcdcaa; } /* Soft yellow (overrides #170) */.cm-s-default .cm-attribute { color: #d4d4d4; } /* Light gray (overrides #00c blue) */.cm-s-default .cm-hr { color: #888; } /* Muted gray (overrides #999) */.cm-s-default .cm-link { color: #d7ba7d; } /* Muted yellow (overrides #00c blue) */.cm-s-default .cm-error { color: #d16969; } /* Soft red (overrides red) */.cm-invalidchar { color: #d16969; } /* Soft red *//* Search highlight */.cm-searching {    background-color: rgba(255, 255, 0, 0.2); /* Subtle yellow */}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/codeMirrorTheme.css"
    },
    "videoGame2": {
      "title": "Video Game 2",
      "fileName": "videoGame2",
      "css": "/* retro-theme.css - Pixel Art Retro Video Game Theme */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base Styles */\r\nbody {\r\n    background-color: #1a1a1a; /* Dark retro background */\r\n    font-family: 'Press Start 2P', cursive; /* Pixelated font */\r\n    image-rendering: pixelated; /* Ensures crisp pixel art rendering */\r\n    color: #fff; /* Default text color */\r\n}\r\n\r\n/* Container */\r\n.container {\r\n    background: #2b2b2b; /* Retro gray */\r\n    border: 4px solid #000; /* Thick black border */\r\n    padding: .5em;\r\n}\r\n\r\n/* Sidebar */\r\n.sidebar {\r\n    background: #3c3c3c; /* Mid-gray retro */\r\n    border: 4px solid #000;\r\n}\r\n\r\n.sidebar img {\r\n    image-rendering: pixelated;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n/* Object List */\r\n.object-item {\r\n    background: #5a5a5a; /* Darker gray */\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px; /* Smaller for pixel readability */\r\n}\r\n\r\n.object-item:hover, .object-item.selected {\r\n    background: #ffcc00; /* Bright retro yellow */\r\n    color: #000;\r\n}\r\n.object-type-item.selected {\r\n    color: #ffcc00;\r\n}\r\n\r\n/* Buttons */\r\nbutton {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    text-transform: uppercase; /* Retro game style */\r\n    transition: background 0.1s ease;\r\n}\r\n\r\nbutton:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\nbutton.primary {\r\n    background: #33cc33; /* Green for primary actions */\r\n}\r\n\r\nbutton.primary:hover {\r\n    background: #ffcc00; /* Yellow on hover */\r\n}\r\n\r\n/* Main Content */\r\n.main-content {\r\n    background: #2b2b2b;\r\n}\r\n\r\n/* Editor */\r\n.editor {\r\n    background: #3c3c3c;\r\n    border: 4px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Canvas and Grid Containers */\r\n#canvas-container, .grid-container {\r\n    background: #000; /* Black canvas background */\r\n    border: 4px solid #fff;\r\n}\r\n\r\n#canvas, #grid {\r\n    image-rendering: pixelated;\r\n    background: repeating-linear-gradient(\r\n        45deg,\r\n        #333 0px,\r\n        #333 10px,\r\n        #000 10px,\r\n        #000 20px\r\n    ); /* Retro checkerboard grid */\r\n}\r\n\r\n.scene-info {\r\n    background: rgba(0, 0, 0, 0.8);\r\n    border: 2px solid #fff;\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 8px;\r\n}\r\n\r\n/* Toolbar */\r\n.toolbar {\r\n    background: #5a5a5a;\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.btn {\r\n    background: #ff3333; /* Retro red */\r\n    color: #fff;\r\n    border: 2px solid #000;\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n    transition: background 0.1s ease;\r\n}\r\n\r\n.btn:hover {\r\n    background: #33cc33; /* Retro green */\r\n}\r\n\r\n.btn.btn-danger {\r\n    background: #ff0000; /* Bright red */\r\n}\r\n\r\n.btn.btn-danger:hover {\r\n    background: #cc0000; /* Darker red */\r\n}\r\n\r\n.btn.btn-secondary {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.btn.btn-secondary:hover {\r\n    background: #9999ff; /* Lighter blue */\r\n}\r\n\r\n.btn.btn-special {\r\n    background: #ff00ff; /* Retro magenta */\r\n}\r\n\r\n.btn.btn-special:hover {\r\n    background: #cc00cc; /* Darker magenta */\r\n}\r\n\r\n/* Modals */\r\n.modal {\r\n    background: rgba(0, 0, 0, 0.8);\r\n}\r\n\r\n.modal-content {\r\n    background: #3c3c3c;\r\n    border: 4px solid #fff;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n/* Form Elements */\r\n.form-group label {\r\n    color: #00ff00; /* Neon green */\r\n    font-size: 10px;\r\n}\r\n\r\ninput, textarea, select {\r\n    background: #000;\r\n    border: 2px solid #fff;\r\n    color: #ffcc00; /* Retro yellow */\r\n    font-family: 'Press Start 2P', cursive;\r\n    font-size: 10px;\r\n}\r\n\r\ninput[type=\"color\"] {\r\n    padding: 0; /* Fix color picker padding */\r\n    height: 20px; /* Consistent height */\r\n}\r\n\r\n/* Tabs */\r\n.tab-navigation {\r\n    border-bottom: 2px solid #000;\r\n}\r\n\r\n.tab {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.tab.active {\r\n    background: #ffcc00; /* Yellow for active tab */\r\n    color: #000;\r\n}\r\n\r\n/* Inspector and JSON Editor */\r\n#inspector, #json-editor {\r\n    background: #3c3c3c;\r\n    border: 2px solid #000;\r\n}\r\n\r\n#json-content {\r\n    background: #000;\r\n    color: #00ff00; /* Green for code-like text */\r\n}\r\n\r\n/* Translation Controls */\r\n.translation-controls button {\r\n    background: #6666ff; /* Retro blue */\r\n}\r\n\r\n.translation-controls button:hover {\r\n    background: #9999ff;\r\n}\r\n\r\n/* Shape List */\r\n.shape-item {\r\n    background: #5a5a5a;\r\n    border: 2px solid #000;\r\n    color: #fff;\r\n    font-size: 10px;\r\n}\r\n\r\n.shape-item:hover {\r\n    background: #ffcc00;\r\n    color: #000;\r\n}\r\n\r\n.type-selector .object-item {\r\n  font-size: .6em;\r\n}\r\n\r\n/* codemirror-retro.css - Retro Pixel Art Theme for CodeMirror */\r\n\r\n/* Import pixel font from Google Fonts */\r\n@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');\r\n\r\n/* Base CodeMirror Styles */\r\n.CodeMirror {\r\n    height: 100% !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important; /* Small size for pixel readability */\r\n    background: #000 !important; /* Black background like a CRT screen */\r\n    color: #00ff00 !important; /* Neon green default text */\r\n    border: 4px solid #fff !important; /* Thick white border */\r\n    image-rendering: pixelated; /* Crisp rendering */\r\n}\r\n.CodeMirror-gutters {\r\n background-color: #000;\r\n}\r\n\r\n/* Retro Theme Definition */\r\n.cm-s-retro .CodeMirror-gutters {\r\n    background: #1a1a1a !important; /* Dark gray gutter */\r\n    border-right: 2px solid #fff !important; /* White separator */\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-linenumber {\r\n    color: #ffcc00 !important; /* Yellow line numbers */\r\n    padding: 0 5px !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-cursor {\r\n    border-left: 2px solid #ff3333 !important; /* Red blinking cursor */\r\n    animation: blink 1s step-end infinite; /* Retro blink effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-selected {\r\n    background: #ff3333 !important; /* Red selection highlight */\r\n    opacity: 0.5; /* Slightly transparent for retro effect */\r\n}\r\n\r\n.cm-s-retro .CodeMirror-focused .CodeMirror-selected {\r\n    background: #ff3333 !important;\r\n}\r\n\r\n/* Syntax Highlighting */\r\n.cm-s-retro .cm-comment {\r\n    color: #6666ff !important; /* Blue for comments */\r\n    font-style: italic; /* Slight retro flair */\r\n}\r\n\r\n.cm-s-retro .cm-string {\r\n    color: #ffcc00 !important; /* Yellow for strings */\r\n}\r\n\r\n.cm-s-retro .cm-number {\r\n    color: #33cc33 !important; /* Green for numbers */\r\n}\r\n\r\n.cm-s-retro .cm-keyword {\r\n    color: #ff00ff !important; /* Magenta for keywords */\r\n    font-weight: bold; /* Bold for emphasis */\r\n}\r\n\r\n.cm-s-retro .cm-operator {\r\n    color: #fff !important; /* White for operators */\r\n}\r\n\r\n.cm-s-retro .cm-variable {\r\n    color: #00ff00 !important; /* Green for variables */\r\n}\r\n\r\n.cm-s-retro .cm-variable-2 {\r\n    color: #33cc33 !important; /* Lighter green for secondary variables */\r\n}\r\n\r\n.cm-s-retro .cm-def {\r\n    color: #ff00ff !important; /* Magenta for definitions */\r\n}\r\n\r\n.cm-s-retro .cm-property {\r\n    color: #ffcc00 !important; /* Yellow for properties */\r\n}\r\n\r\n.cm-s-retro .cm-function {\r\n    color: #ff00ff !important; /* Magenta for functions */\r\n}\r\n\r\n.cm-s-retro .cm-builtin {\r\n    color: #33cc33 !important; /* Green for built-ins */\r\n}\r\n\r\n.cm-s-retro .cm-tag {\r\n    color: #ff3333 !important; /* Red for tags (if HTML mode is used) */\r\n}\r\n\r\n.cm-s-retro .cm-attribute {\r\n    color: #ffcc00 !important; /* Yellow for attributes */\r\n}\r\n\r\n/* Matching Brackets */\r\n.cm-s-retro .CodeMirror-matchingbracket {\r\n    color: #33cc33 !important; /* Green for matching brackets */\r\n    border-bottom: 2px solid #33cc33 !important;\r\n    background: none !important;\r\n}\r\n\r\n.cm-s-retro .CodeMirror-nonmatchingbracket {\r\n    color: #ff3333 !important; /* Red for non-matching brackets */\r\n    border-bottom: 2px solid #ff3333 !important;\r\n}\r\n\r\n/* Autocomplete Hints */\r\n.CodeMirror-hints {\r\n    background: #2b2b2b !important; /* Dark retro gray */\r\n    border: 2px solid #fff !important; /* White border */\r\n    color: #fff !important;\r\n    font-family: 'Press Start 2P', cursive !important;\r\n    font-size: 10px !important;\r\n    box-shadow: 4px 4px 0 #000; /* Retro shadow effect */\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint {\r\n    color: #ffcc00 !important; /* Yellow for hint items */\r\n    padding: 5px !important;\r\n}\r\n\r\n.CodeMirror-hints .CodeMirror-hint-active {\r\n    background: #ff3333 !important; /* Red for selected hint */\r\n    color: #000 !important;\r\n}\r\n\r\n/* Scrollbars (minimal retro style) */\r\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar {\r\n    background: #3c3c3c !important;\r\n}\r\n\r\n.CodeMirror-scrollbar-filler {\r\n    background: #000 !important;\r\n}\r\n\r\n/* Animations */\r\n@keyframes blink {\r\n    50% { opacity: 0; }\r\n}",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/videoGame2.css"
    },
    "cyberpunk": {
      "title": "Cyber Punk",
      "fileName": "cyberpunk",
      "css": "/* Default Cyberpunk Theme */ @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700&family=Rajdhani:wght@300;400;500;600;700&display=swap');  body {     font-family: 'Orbitron', 'Rajdhani', sans-serif;     background-color: #0a0a16;     color: #00f0ff; }  .sidebar {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px #00f0ff, inset 0 0 20px rgba(0, 240, 255, 0.2); }  .object-item {     background-color: rgba(0, 0, 35, 0.6);     border-left: 2px solid #fe01fe;     text-transform: uppercase;     letter-spacing: 1px; }  .object-item:hover {     background-color: rgba(254, 1, 254, 0.2);     transform: translateX(5px); }  .object-item.selected {     background-color: rgba(254, 1, 254, 0.3);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 8px rgba(254, 1, 254, 0.5); }  .editor {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #fe01fe;     box-shadow: 0 0 15px rgba(254, 1, 254, 0.3); }  #three-js-container {     border: 1px solid rgba(0, 240, 255, 0.5); }  .preview-canvas-container {     border: 1px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.3); }  .preview {     background-color: rgba(15, 15, 35, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3); }  #preview-canvas {     background-color: transparent;     border: 1px solid rgba(0, 240, 255, 0.5); }  .camera-controls {     background: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff; }  .camera-controls button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff; }  .camera-controls .color-picker {     border: 1px solid #00f0ff; }  .camera-controls .size-slider {     background: #101028;     border: 1px solid #00f0ff; }  label {     font-weight: bold;     text-transform: uppercase;     letter-spacing: 1px;     color: #fe01fe; }  input, textarea, select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  input:focus, textarea:focus, select:focus {     outline: none;     border-color: #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  button {     background-color: rgba(0, 240, 255, 0.2);     border: 1px solid #00f0ff;     color: #00f0ff;     text-transform: uppercase;     letter-spacing: 1px; }  button:after {     background: linear-gradient(to right, transparent, rgba(0, 240, 255, 0.2), transparent); }  button:hover {     background-color: rgba(0, 240, 255, 0.3);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5), 0 0 20px rgba(0, 240, 255, 0.2);     transform: translateY(-2px); }  button:hover:after {     transform: translateX(100%) rotate(30deg); }  button.primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  button.primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5), 0 0 20px rgba(254, 1, 254, 0.2); }  button.danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  button.danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5), 0 0 20px rgba(255, 0, 76, 0.2); }  button.active {     border: 1px solid #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);     color: #00ff9d; }  .modal {     background-color: rgba(0, 0, 20, 0.85);     backdrop-filter: blur(5px); }  .modal-content {     background-color: rgba(15, 15, 35, 0.9);     border: 1px solid #00f0ff;     box-shadow: 0 0 30px rgba(0, 240, 255, 0.3), 0 0 60px rgba(0, 240, 255, 0.1); }  .property-list {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6); }  .tab-navigation {     border-bottom: 1px solid #00f0ff; }  .tab {     text-transform: uppercase;     letter-spacing: 1px; }  .tab:hover {     background-color: rgba(0, 240, 255, 0.1); }  .tab.active {     border-bottom: 3px solid #fe01fe;     box-shadow: 0 5px 10px -5px rgba(254, 1, 254, 0.5);     font-weight: bold; }  .instructions {     background-color: rgba(0, 0, 35, 0.6);     border-left: 4px solid #fe01fe;     box-shadow: 0 0 10px rgba(254, 1, 254, 0.2); }  #grid-display {     background-color: rgba(0, 0, 20, 0.7);     border: 1px solid #00f0ff;     box-shadow: 0 0 10px rgba(0, 240, 255, 0.3); }  .success-message {     color: #00ff9d;     text-transform: uppercase;     letter-spacing: 1px;     animation: fadeOut 2s forwards;     animation-delay: 1s; }  .warning {     background-color: rgba(255, 0, 76, 0.1);     border-left: 4px solid #ff004c;     box-shadow: 0 0 10px rgba(255, 0, 76, 0.2); }  .main-content-container {     background-color: #080815;     color: #00f0ff; }  .content-sidebar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-right: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  #graphics-rightbar {     background: linear-gradient(180deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-left: 1px solid #00f0ff;     box-shadow: 0 0 20px rgba(0, 240, 255, 0.2); }  .grid-background {     background: #05051a;     background-image: radial-gradient(rgba(0, 240, 255, 0.1) 1px, transparent 1px);     background-size: 20px 20px; }  .toolbar {     background: linear-gradient(90deg, rgba(20, 20, 50, 0.8), rgba(10, 10, 30, 0.8));     border-bottom: 1px solid #00f0ff; }  .btn {     border: 1px solid #00f0ff;     background-color: rgba(0, 240, 255, 0.1);     color: #00f0ff;     text-transform: uppercase; }  .btn:hover {     background-color: rgba(0, 240, 255, 0.2);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5);     transform: translateY(-2px); }  .btn-primary {     background-color: rgba(254, 1, 254, 0.2);     border: 1px solid #fe01fe;     color: #fe01fe; }  .btn-primary:hover {     background-color: rgba(254, 1, 254, 0.3);     box-shadow: 0 0 10px rgba(254, 1, 254, 0.5); }  .btn-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .btn-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  .btn-secondary {     background-color: rgba(0, 240, 255, 0.15);     border: 1px solid #00f0ff; }  .btn-secondary:hover {     background-color: rgba(0, 240, 255, 0.25);     box-shadow: 0 0 10px rgba(0, 240, 255, 0.5); }  .btn-special {     background-color: rgba(0, 255, 157, 0.2);     border: 1px solid #00ff9d;     color: #00ff9d; }  .btn-special:hover {     background-color: rgba(0, 255, 157, 0.3);     box-shadow: 0 0 10px rgba(0, 255, 157, 0.5); }  #shape-list {     border-bottom: 1px solid rgba(0, 240, 255, 0.2); }  .shape-item {     background-color: rgba(0, 0, 35, 0.6);     border: 1px solid #00f0ff; }  .shape-item:hover {     background-color: rgba(0, 240, 255, 0.1);     transform: translateX(5px); }  .shape-item.active {     background-color: rgba(0, 255, 157, 0.1);     border-color: #00ff9d;     color: #00ff9d;     box-shadow: 0 0 10px rgba(0, 255, 157, 0.3); }  #inspector {     background: rgba(20, 20, 50, 0.8);     border-top: 1px solid #00f0ff; }  .form-row label {     color: #fe01fe; }  .form-row input, .form-row select {     border: 1px solid #00f0ff;     background-color: rgba(0, 0, 35, 0.6);     color: #00f0ff;     box-shadow: 0 0 5px rgba(0, 240, 255, 0.3); }  .scene-info {     background: rgba(0, 0, 20, 0.8);     color: #00f0ff;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.3);     border: 1px solid #00f0ff; }  .button-danger {     background-color: rgba(255, 0, 76, 0.2);     border: 1px solid #ff004c;     color: #ff004c; }  .button-danger:hover {     background-color: rgba(255, 0, 76, 0.3);     box-shadow: 0 0 10px rgba(255, 0, 76, 0.5); }  h2, h3 {     color: #fe01fe;     text-transform: uppercase;     letter-spacing: 3px;     margin-bottom: 15px;     padding-bottom: 5px;     border-bottom: 1px solid #00f0ff;     text-shadow: 0 0 5px rgba(254, 1, 254, 0.7); }  h2:hover, h3:hover {     text-shadow: -2px 0 #00f0ff, 2px 0 #ff004c; }  .container::before {     content: '';     position: fixed;     top: 0;     left: 0;     right: 0;     bottom: 0;     background:          linear-gradient(rgba(0, 240, 255, 0.07) 1px, transparent 1px),         linear-gradient(90deg, rgba(0, 240, 255, 0.07) 1px, transparent 1px);     background-size: 40px 40px;     background-position: center center;     z-index: -1;     perspective: 1000px;     transform-style: preserve-3d;     transform: rotateX(75deg) translateZ(-100px);     pointer-events: none; }  #json-content {     background-color: rgba(0, 0, 35, 0.8);     border: 1px solid #00f0ff;     color: #00ff9d;     font-family: 'Courier New', monospace;     padding: 15px;     box-shadow: 0 0 15px rgba(0, 240, 255, 0.2), inset 0 0 30px rgba(0, 0, 35, 0.5); }  .ref-value-item {     background-color: #405060; }  .remove-ref-btn {     background: none;     border: none;     color: #ff6b6b;     cursor: pointer; }  ::-webkit-scrollbar {     width: 8px;     height: 8px; }  ::-webkit-scrollbar-track {     background: rgba(0, 0, 35, 0.6); }  ::-webkit-scrollbar-thumb {     background: #00f0ff;     border-radius: 0; }  ::-webkit-scrollbar-thumb:hover {     background: #fe01fe; }  button:active::before {     content: '';     position: absolute;     top: 0;     left: 0;     width: 100%;     height: 100%;     background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.4), transparent);     animation: loading 1s infinite; }",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/cyberpunk.css"
    },
    "Neon Dune": {
      "title": "Neon Dune",
      "fileName": "Neon Dune",
      "css": "body { background-color: #1a0f05; color: #ffffff; font-family: 'Arial', sans-serif; }\r\n\r\nh1, h2, h3 { color: #00ffbf; }\r\n\r\n.button-primary { background-color: #00ffbf; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; transition: all 0.3s ease; }\r\n.button-primary:hover { transform: scale(1.05); box-shadow: 0 0 15px #00ffbf; }\r\n\r\n.link { color: #00ffbf; text-decoration: none; }\r\n.link:hover { text-decoration: underline; }\r\n\r\n.card { background-color: #2d1e13; border-radius: 10px; padding: 20px; margin: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }\r\n\r\ninput, textarea { background-color: #2d1e13; color: #ffffff; border: 1px solid #00ffbf; padding: 8px; border-radius: 5px; }\r\n\r\nheader { background-color: #00ffbf; padding: 20px; text-align: center; box-shadow: 0 4px 6px rgba(0,255,191,0.3); }\r\n\r\nfooter { background-color: #2d1e13; color: #ffffff; padding: 20px; text-align: center; border-top: 1px solid #00ffbf; }\r\n",
      "filePath": "/projects/TurnBasedWarfare/scripts/Settings/themes/css/Neon Dune.css"
    }
  },
  "attackSounds": {
    "missileLaunch": {
      "title": "Missile Launch",
      "audio": {
        "waveform": "noise",
        "frequency": 341,
        "duration": 0.4,
        "noise": {
          "type": "brown",
          "amount": 0.63,
          "filter": {
            "type": "bandpass",
            "frequency": 20
          }
        },
        "envelope": {
          "attack": 0.252,
          "decay": 0.4,
          "sustain": 0,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.38,
          "end": 0.59,
          "time": 0.4
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 20000,
            "Q": 1
          },
          "distortion": 0,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0.11,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    },
    "gunshot": {
      "title": "GunShot",
      "audio": {
        "waveform": "noise",
        "frequency": 200,
        "duration": 0.5,
        "noise": {
          "type": "pink",
          "amount": 0.8,
          "filter": {
            "type": "lowpass",
            "frequency": 400
          }
        },
        "envelope": {
          "attack": 0.01,
          "decay": 0.3,
          "sustain": 0.2,
          "release": 0.1
        },
        "pitchEnvelope": {
          "start": 4,
          "end": 2,
          "time": 0.5
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 2,
          "delay": {
            "time": 0.1,
            "feedback": 0.3
          },
          "reverb": 0.4,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "laser": {
      "title": "Laser",
      "audio": {
        "waveform": "triangle",
        "frequency": 197,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0.076,
          "sustain": 0.5,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.41,
          "end": 0.23,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 400,
            "Q": 1
          },
          "distortion": 5,
          "delay": {
            "time": 0.27,
            "feedback": 0.09
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    },
    "TeslaAttack": {
      "title": "Tesla Attack",
      "audio": {
        "waveform": "noise",
        "frequency": 200,
        "duration": 0.15,
        "envelope": {
          "attack": 0.001,
          "decay": 0.03,
          "sustain": 0.4,
          "release": 0.02
        },
        "pitchEnvelope": {
          "start": 2.5,
          "end": 0.8,
          "time": 0.15
        },
        "effects": {
          "filter": {
            "type": "bandpass",
            "frequency": 1200,
            "Q": 3
          },
          "distortion": 30,
          "delay": {
            "time": 0.05,
            "feedback": 0.05
          },
          "reverb": 0.05,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "plasma": {
      "title": "Plasma",
      "audio": {
        "waveform": "triangle",
        "frequency": 197,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0.076,
          "sustain": 0.5,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 3.41,
          "end": 0.23,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "highpass",
            "frequency": 4000,
            "Q": 1
          },
          "distortion": 5,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    }
  },
  "hitSounds": {
    "explosion_loud": {
      "title": "Explosion Loud",
      "audio": {
        "waveform": "noise",
        "frequency": 100,
        "duration": 1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 2000
          }
        },
        "envelope": {
          "attack": 0.005,
          "decay": 0.2,
          "sustain": 0.3,
          "release": 0.3
        },
        "pitchEnvelope": {
          "start": 2,
          "end": 0.5,
          "time": 1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 3,
          "delay": {
            "time": 0.15,
            "feedback": 0.25
          },
          "reverb": 0.5,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "explosion": {
      "title": "Explosion",
      "audio": {
        "waveform": "noise",
        "frequency": 100,
        "duration": 1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 2000
          }
        },
        "envelope": {
          "attack": 0.005,
          "decay": 0.2,
          "sustain": 0.3,
          "release": 0.3
        },
        "pitchEnvelope": {
          "start": 2,
          "end": 0.5,
          "time": 1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 800,
            "Q": 1
          },
          "distortion": 3,
          "delay": {
            "time": 0.15,
            "feedback": 0.25
          },
          "reverb": 0.5,
          "bitcrusher": 0.5,
          "pan": 0
        }
      }
    },
    "plasma": {
      "title": "Plasma",
      "audio": {
        "waveform": "noise",
        "frequency": 48,
        "duration": 0.1,
        "noise": {
          "type": "white",
          "amount": 0,
          "filter": {
            "type": "none",
            "frequency": 20
          }
        },
        "envelope": {
          "attack": 0.012,
          "decay": 0.064,
          "sustain": 0.01,
          "release": 0.062
        },
        "pitchEnvelope": {
          "start": 2.45,
          "end": 0.72,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 13141,
            "Q": 0.1
          },
          "distortion": 1,
          "delay": {
            "time": 0.05,
            "feedback": 0.03
          },
          "reverb": 0,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    }
  },
  "sounds": {
    "pickup": {
      "title": "Pickup",
      "audio": {
        "waveform": "triangle",
        "frequency": 200,
        "duration": 0.1,
        "envelope": {
          "attack": 0.001,
          "decay": 0,
          "sustain": 0,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 0.34,
          "end": 1.89,
          "time": 0.1
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 400,
            "Q": 1
          },
          "distortion": 20,
          "delay": {
            "time": 0,
            "feedback": 0.2
          },
          "reverb": 0,
          "bitcrusher": 0.1,
          "pan": 0
        }
      }
    },
    "placeTower": {
      "title": "Place Tower",
      "audio": {
        "waveform": "sine",
        "frequency": 20,
        "duration": 0.2,
        "noise": {
          "type": "pink",
          "amount": 0.8,
          "filter": {
            "type": "lowpass",
            "frequency": 400
          }
        },
        "envelope": {
          "attack": 0.01,
          "decay": 0,
          "sustain": 0.1,
          "release": 0.001
        },
        "pitchEnvelope": {
          "start": 4,
          "end": 4,
          "time": 0.2
        },
        "effects": {
          "filter": {
            "type": "lowpass",
            "frequency": 500,
            "Q": 1
          },
          "distortion": 0,
          "delay": {
            "time": 0.05,
            "feedback": 0.2
          },
          "reverb": 0.3,
          "bitcrusher": 0.4,
          "pan": 0
        }
      }
    },
    "test": {
      "title": "test",
      "audio": {
        "waveform": "noise",
        "frequency": 440,
        "duration": 0.6,
        "noise": {
          "type": "pink",
          "amount": 1,
          "filter": {
            "type": "bandpass",
            "frequency": 1200,
            "Q": 1.8
          }
        },
        "envelope": {
          "attack": 0.02,
          "decay": 0.4,
          "sustain": 0,
          "release": 0
        },
        "pitchEnvelope": {
          "start": 1.8,
          "end": 0.4,
          "time": 0.5
        },
        "effects": {
          "filter": {
            "type": "none",
            "frequency": 20000,
            "Q": 1
          },
          "distortion": 0.2,
          "delay": {
            "time": 0,
            "feedback": 0
          },
          "reverb": 0.15,
          "bitcrusher": 0,
          "pan": 0
        }
      }
    }
  },
  "actions": {
    "build": {
      "title": "Peasant Build",
      "icon": "building_townHall",
      "actionSet": "peasant_buildings",
      "ability": "BuildAbility"
    },
    "hold": {
      "title": "Hold",
      "icon": "order_hold",
      "order": "holdPosition"
    },
    "mineGold": {
      "title": "Peasant Mine Gold",
      "icon": "building_goldMine",
      "ability": "MineGoldAbility"
    },
    "move": {
      "title": "Force Move",
      "icon": "order_move",
      "order": "moveOrderAction"
    }
  },
  "actionSets": {
    "peasant_buildings": {
      "title": "Peasant Buildings",
      "buildings": [
        "goldMine",
        "townHall",
        "cottage",
        "barracks",
        "fletchersHall",
        "mageTower",
        "sentryTower"
      ]
    },
    "defaultUnitActions": {
      "title": "Default Unit Actions",
      "actions": [
        "move",
        "hold"
      ]
    },
    "peasant_actions": {
      "title": "Peasant Actions",
      "actions": [
        "move",
        "hold",
        "build"
      ]
    }
  },
  "animations": {
    "1h_axe_swing": {
      "title": "1h_axe_swing",
      "file": "animations/1h_axe_swing.glb"
    },
    "1h_spell_throw": {
      "title": "1h_spell_throw",
      "file": "animations/1h_spell_throw.glb"
    },
    "2h_slash": {
      "title": "2h_slash",
      "file": "animations/2h_slash.glb"
    },
    "2h_spell_blast": {
      "title": "2h_spell_blast",
      "file": "animations/2h_spell_blast.glb"
    },
    "2h_spell_calldown": {
      "title": "2h_spell_calldown",
      "file": "animations/2h_spell_calldown.glb"
    },
    "2h_spell_cast": {
      "title": "2h_spell_cast",
      "file": "animations/2h_spell_cast.glb"
    },
    "2h_spell_slam": {
      "title": "2h_spell_slam",
      "file": "animations/2h_spell_slam.glb"
    },
    "2h_spell_summon": {
      "title": "2h_spell_summon",
      "file": "animations/2h_spell_summon.glb"
    },
    "dance_gangnamstyle": {
      "title": "GangnamStyle",
      "file": "animations/dance_gangnamstyle.glb"
    },
    "death_delayed": {
      "title": "death_delayed",
      "file": "animations/death_delayed.glb"
    },
    "dance_thriller": {
      "title": "Dance Thriller",
      "file": "animations/dance_thriller.glb"
    },
    "death_fallback": {
      "title": "death_fallback",
      "file": "animations/death_fallback.glb"
    },
    "death_fallforward": {
      "title": "death_fallforward",
      "file": "animations/death_fallforward.glb"
    },
    "death_flyback": {
      "title": "death_flyback",
      "file": "animations/death_flyback.glb"
    },
    "hovering": {
      "title": "hovering",
      "file": "animations/hovering.glb"
    },
    "idle": {
      "title": "idle",
      "file": "animations/idle.glb"
    },
    "mutant_idle": {
      "title": "mutant_idle",
      "file": "animations/mutant_idle.glb"
    },
    "mutant_run": {
      "title": "mutant_run",
      "file": "animations/mutant_run.glb"
    },
    "mutant_swipe": {
      "title": "mutant_swipe",
      "file": "animations/mutant_swipe.glb"
    },
    "mutant_walk": {
      "title": "mutant_walk",
      "file": "animations/mutant_walk.glb"
    },
    "running_with_2h": {
      "title": "running_with_2h",
      "file": "animations/running_with_2h.glb"
    },
    "shooting_arrow": {
      "title": "shooting_arrow",
      "file": "animations/shooting_arrow.glb"
    },
    "swimming": {
      "title": "swimming",
      "file": "animations/swimming.glb"
    },
    "sword_and_shield_cast": {
      "title": "sword_and_shield_cast",
      "file": "animations/sword_and_shield_cast.glb"
    },
    "sword_slash": {
      "title": "sword_slash",
      "file": "animations/sword_slash.glb"
    },
    "walk_bow": {
      "title": "walk_bow",
      "file": "animations/walk_bow.glb"
    },
    "walk_steady_right_hand": {
      "title": "walk_steady_right_hand",
      "file": "animations/walk_steady_right_hand.glb"
    },
    "walk_with_shield": {
      "title": "walk_with_shield",
      "file": "animations/walk_with_shield.glb"
    }
  },
  "effects": {
    "goldPerTrip": {
      "title": "Gold Per Trip",
      "desc": "Extra gold per trip.",
      "type": "upgrade",
      "value": 5
    },
    "slow": {
      "id": "slow",
      "title": "Slow",
      "desc": "Target is slowed",
      "stat": "speed",
      "lifeTime": 100
    },
    "spellDamage": {
      "title": "Spell Damage",
      "description": "",
      "type": "upgrade",
      "value": 10
    },
    "weaken": {
      "id": "weaken",
      "title": "Weakened",
      "desc": "Target's armor is reduced",
      "stat": "armor",
      "lifeTime": 100
    }
  },
  "models": {
    "position": {
      "title": "Position",
      "x": 0,
      "y": 0,
      "z": 0
    }
  },
  "modifierSets": {
    "global": {
      "maxBloodCoreHP": 100,
      "bloodShardMultiplier": 1,
      "towerCostMod": 1,
      "damageMultiplier": 1,
      "healingMultiplier": 1,
      "essenceMultiplier": 1,
      "towerDamageReduction": 1,
      "population": 0,
      "maxPopulation": 5
    }
  },
  "upgrades": {
    "peasantEfficiency": {
      "title": "Peasant Efficiency",
      "description": "Increase Gold Per Trip by 5",
      "value": 100,
      "effects": [
        "goldPerTrip"
      ]
    },
    "spellDamage": {
      "title": "Spell Damage",
      "description": "Increase Spell Damage",
      "value": 100,
      "effects": [
        "spellDamage"
      ]
    }
  },
  "cameras": {
    "main": {
      "title": "Main Orthographic",
      "near": 0.1,
      "far": 50000,
      "position": "{ \"x\": 64, \"y\": 512, \"z\": 512}",
      "lookAt": "{ \"x\": 64, \"y\": 16, \"z\": 64}",
      "zoom": 1
    },
    "main_perspective": {
      "title": "Main Perspective",
      "near": 0.1,
      "far": 4000,
      "position": "{ \"x\": 1000, \"y\": 750, \"z\": 1000}",
      "lookAt": "{ \"x\": 384, \"y\": 15, \"z\": 384 }",
      "fov": 75
    }
  },
  "fogs": {
    "sunnyDayFog": {
      "title": "Sunny Day Fog",
      "color": "#b3e5fc",
      "density": 0.00004,
      "enabled": false
    }
  },
  "heightMaps": {
    "fiveStep": {
      "title": "Five Step and Smoothing",
      "heightStep": 15,
      "smoothing": false,
      "enabled": true,
      "resolutionDivisor": 4
    }
  },
  "lightings": {
    "sunnyDayLighting": {
      "title": "Sunny Day Lighting",
      "ambientColor": "#b3e5fc",
      "ambientIntensity": 0.4,
      "directionalColor": "#ffcc80",
      "directionalIntensity": 0.7,
      "skyColor": "#b3e5fc",
      "groundColor": "#5a8a4f",
      "hemisphereIntensity": 0.5,
      "direction": "{\"x\":0,\"y\":-1,\"z\":-1}"
    }
  },
  "scenes": {
    "client": {
      "title": "client",
      "type": "ECS",
      "sceneData": [
        {
          "id": 1,
          "objectType": "gamePrefabs",
          "spawnType": "multiplayer",
          "parent": null,
          "children": [],
          "managers": [
            {
              "type": "ComponentManager"
            },
            {
              "type": "GameManager"
            },
            {
              "type": "GameModeManager"
            },
            {
              "type": "KeyboardManager"
            },
            {
              "type": "LoadingManager"
            },
            {
              "type": "ResultsManager"
            },
            {
              "type": "SaveManager"
            },
            {
              "type": "ScreenManager"
            },
            {
              "type": "UnitCreationManager"
            },
            {
              "type": "SquadManager"
            },
            {
              "type": "MultiplayerNetworkManager"
            },
            {
              "type": "InputManager"
            }
          ],
          "systems": [
            {
              "type": "TerrainSystem"
            },
            {
              "type": "WorldSystem"
            },
            {
              "type": "PostProcessingSystem"
            },
            {
              "type": "RenderSystem"
            },
            {
              "type": "AISystem"
            },
            {
              "type": "CommandQueueSystem"
            },
            {
              "type": "MovementSystem"
            },
            {
              "type": "CombatAISystem"
            },
            {
              "type": "ProjectileSystem"
            },
            {
              "type": "AnimationSystem"
            },
            {
              "type": "ArmyDisplaySystem"
            },
            {
              "type": "EffectsSystem"
            },
            {
              "type": "GridSystem"
            },
            {
              "type": "MultiplayerPlacementSystem"
            },
            {
              "type": "MultiplayerUISystem"
            },
            {
              "type": "ShopSystem"
            },
            {
              "type": "TeamHealthSystem"
            },
            {
              "type": "HealthBarSystem"
            },
            {
              "type": "UnitRadiusSystem"
            },
            {
              "type": "EquipmentSystem"
            },
            {
              "type": "DeathSystem"
            },
            {
              "type": "DamageSystem"
            },
            {
              "type": "AbilitySystem"
            },
            {
              "type": "ParticleSystem"
            },
            {
              "type": "SquadExperienceSystem"
            },
            {
              "type": "LifetimeSystem"
            },
            {
              "type": "MultiplayerUISystem"
            },
            {
              "type": "SchedulingSystem"
            },
            {
              "type": "GoldMineSystem"
            },
            {
              "type": "PathfindingSystem"
            },
            {
              "type": "FogOfWarSystem"
            },
            {
              "type": "SelectedUnitSystem"
            },
            {
              "type": "UnitOrderSystem"
            },
            {
              "type": "MiniMapSystem"
            },
            {
              "type": "CameraControlSystem"
            },
            {
              "type": "DamageNumberSystem"
            },
            {
              "type": "VisionSystem"
            },
            {
              "type": "SupplySystem"
            }
          ],
          "classes": [
            {
              "collection": "abilities",
              "baseClass": "BaseAbility"
            }
          ]
        }
      ]
    },
    "server": {
      "title": "server",
      "type": "ECS",
      "sceneData": [
        {
          "id": 1,
          "objectType": "gamePrefabs",
          "spawnType": "multiplayer",
          "managers": [
            {
              "type": "ComponentManager"
            },
            {
              "type": "GameManager"
            },
            {
              "type": "UnitCreationManager"
            },
            {
              "type": "SquadManager"
            }
          ],
          "systems": [
            {
              "type": "TerrainSystem"
            },
            {
              "type": "AISystem"
            },
            {
              "type": "CommandQueueSystem"
            },
            {
              "type": "MovementSystem"
            },
            {
              "type": "CombatAISystem"
            },
            {
              "type": "ProjectileSystem"
            },
            {
              "type": "TeamHealthSystem"
            },
            {
              "type": "DeathSystem"
            },
            {
              "type": "DamageSystem"
            },
            {
              "type": "AbilitySystem"
            },
            {
              "type": "SquadExperienceSystem"
            },
            {
              "type": "ServerBattlePhaseSystem"
            },
            {
              "type": "ServerPlacementSystem"
            },
            {
              "type": "LifetimeSystem"
            },
            {
              "type": "GridSystem"
            },
            {
              "type": "SchedulingSystem"
            },
            {
              "type": "PathfindingSystem"
            },
            {
              "type": "GoldMineSystem"
            },
            {
              "type": "VisionSystem"
            },
            {
              "type": "SupplySystem"
            }
          ],
          "classes": [
            {
              "collection": "abilities",
              "baseClass": "BaseAbility"
            }
          ]
        }
      ]
    }
  },
  "shadows": {
    "sunnyDayShadows": {
      "title": "Sunny Day Shadows",
      "mapSize": 2048,
      "bias": -0.0003,
      "normalBias": 0,
      "radius": 512,
      "enabled": true
    }
  },
  "worlds": {
    "shire": {
      "title": "Shire",
      "lighting": "sunnyDayLighting",
      "shadow": "sunnyDayShadows",
      "fog": "sunnyDayFog",
      "heightMap": "fiveStep",
      "camera": "main",
      "extensionSize": 768,
      "worldObjects": [
        "tree",
        "rock",
        "goldVein"
      ],
      "backgroundColor": "#b3e5fc"
    }
  },
  "buildings": {
    "barracks": {
      "title": "Barracks",
      "info": "Strength based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "gltf",
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "metalness": 0,
                    "roughness": 1,
                    "x": 0,
                    "z": 0,
                    "scaleX": 1,
                    "name": "foundation",
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/barracks/barracks.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [
        "1_sd_soldier",
        "1_s_barbarian"
      ],
      "footprintWidth": 2,
      "footprintHeight": 3,
      "height": 100,
      "size": 75,
      "icon": "building_barracks",
      "hp": 1500,
      "supplies": 7
    },
    "castle": {
      "title": "Castle",
      "category": "townhall",
      "value": 100,
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "width": 24,
                "height": 16,
                "depth": 24,
                "color": "#cfd8dc",
                "x": 0,
                "y": 32,
                "z": 0,
                "size": 24,
                "name": "dome",
                "scaleX": 1
              },
              {
                "type": "cylinder",
                "size": 12,
                "height": 22,
                "color": "#cfd8dc",
                "x": 0,
                "y": 42,
                "z": 0,
                "name": "spire"
              },
              {
                "type": "cone",
                "size": 14,
                "height": 20,
                "color": "#ab47bc",
                "x": 0,
                "y": 62,
                "z": 0,
                "name": "spire roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          },
          "base": {
            "shapes": [
              {
                "type": "box",
                "width": 40,
                "height": 12,
                "depth": 40,
                "color": "#3e4f57",
                "x": 0,
                "y": 6,
                "z": 0,
                "scaleX": 1,
                "name": "base"
              },
              {
                "type": "box",
                "width": 44,
                "height": 4,
                "depth": 44,
                "color": "#3e4f57",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "foundation"
              },
              {
                "type": "box",
                "width": 32,
                "height": 12,
                "depth": 32,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "main structure"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "towers": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": 16,
                "name": "tower1"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": 16,
                "name": "tower2"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": -16,
                "name": "tower3"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": -16,
                "name": "tower4"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": 16,
                "name": "tower1roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": 16,
                "name": "tower2roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": -16,
                "name": "tower3roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": -16,
                "name": "tower4roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          }
        }
      },
      "size": 75
    },
    "cottage": {
      "title": "Cottage",
      "info": "A structure that fires arrows.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/cottage/cottage.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 1,
      "footprintHeight": 1,
      "height": 100,
      "size": 50,
      "icon": "building_cottage",
      "hp": 500,
      "supplyProvided": 8
    },
    "fletchersHall": {
      "title": "Fletchers Hall",
      "info": "Dexterity based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/fletchers_hall/fletchers_hall.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [
        "1_di_scout",
        "1_d_archer"
      ],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "size": 50,
      "icon": "building_fletchersHall",
      "hp": 1500
    },
    "goldMine": {
      "title": "Gold Mine",
      "info": "Mine gold veins",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/goldmine/goldmine.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1.5,
              "y": 1.5,
              "z": 1.5
            }
          }
        }
      },
      "upgrades": [
        "peasantEfficiency"
      ],
      "units": [],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "size": 50,
      "icon": "building_goldMine",
      "hp": 2000,
      "height": 100
    },
    "keep": {
      "title": "Keep",
      "category": "townhall",
      "value": 100,
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "width": 24,
                "height": 16,
                "depth": 24,
                "color": "#cfd8dc",
                "x": 0,
                "y": 32,
                "z": 0,
                "size": 24,
                "name": "dome",
                "scaleX": 1
              },
              {
                "type": "cylinder",
                "size": 12,
                "height": 22,
                "color": "#cfd8dc",
                "x": 0,
                "y": 42,
                "z": 0,
                "name": "spire"
              },
              {
                "type": "cone",
                "size": 14,
                "height": 20,
                "color": "#ab47bc",
                "x": 0,
                "y": 62,
                "z": 0,
                "name": "spire roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          },
          "base": {
            "shapes": [
              {
                "type": "box",
                "width": 40,
                "height": 12,
                "depth": 40,
                "color": "#3e4f57",
                "x": 0,
                "y": 6,
                "z": 0,
                "scaleX": 1,
                "name": "base"
              },
              {
                "type": "box",
                "width": 44,
                "height": 4,
                "depth": 44,
                "color": "#3e4f57",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "foundation"
              },
              {
                "type": "box",
                "width": 32,
                "height": 12,
                "depth": 32,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "main structure"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "towers": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": 16,
                "name": "tower1"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": 16,
                "name": "tower2"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": 16,
                "y": 22,
                "z": -16,
                "name": "tower3"
              },
              {
                "type": "cylinder",
                "size": 6,
                "height": 30,
                "color": "#cfd8dc",
                "x": -16,
                "y": 22,
                "z": -16,
                "name": "tower4"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": 16,
                "name": "tower1roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": 16,
                "name": "tower2roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": 16,
                "y": 42,
                "z": -16,
                "name": "tower3roof"
              },
              {
                "type": "cone",
                "size": 8,
                "height": 10,
                "color": "#0288d1",
                "x": -16,
                "y": 42,
                "z": -16,
                "name": "tower4roof"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 0.7,
              "z": 1
            }
          }
        }
      },
      "size": 75
    },
    "mageTower": {
      "title": "Mage Tower",
      "info": "Intelligence based training.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/mage_tower/mage_tower.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "upgrades": [
        "spellDamage"
      ],
      "units": [
        "1_is_acolyte",
        "1_i_apprentice"
      ],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "anchored": true,
      "size": 50,
      "icon": "building_mageTower",
      "hp": 1500
    },
    "sentryTower": {
      "title": "Sentry Tower",
      "info": "A structure that fires arrows.",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "blueDColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/mage_tower/mage_tower.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 2,
      "footprintHeight": 2,
      "height": 100,
      "size": 50,
      "icon": "unit_archer",
      "damage": 20,
      "attackSpeed": 1,
      "range": 300,
      "projectile": "arrow",
      "element": "physical",
      "hp": 500
    },
    "townHall": {
      "title": "Town Hall",
      "category": "townhall",
      "value": 100,
      "upgrades": [
        "peasantEfficiency"
      ],
      "render": {
        "animations": {
          "idle": [
            {}
          ],
          "underConstruction": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "purpleMColor"
                    },
                    "url": "models/underConstruction/underConstruction.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "purpleMColor"
                },
                "roughness": 1,
                "metalness": 0,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/townhall/townhall.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "footprintWidth": 3,
      "footprintHeight": 3,
      "units": [
        "peasant"
      ],
      "height": 1000,
      "size": 75,
      "icon": "building_townHall",
      "hp": 2500,
      "visionRange": 2000,
      "supplyProvided": 10
    },
    "underConstruction": {
      "title": "Under Construction",
      "info": "Under Construction",
      "value": 50,
      "category": "attribute",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "blueDColor"
                },
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "z": 0,
                "scaleX": 1,
                "name": "foundation",
                "url": "models/underConstruction/underConstruction.glb"
              }
            ],
            "position": {
              "x": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            }
          }
        }
      },
      "units": [],
      "footprintWidth": 3,
      "footprintHeight": 2,
      "height": 100,
      "size": 75,
      "hp": 1000
    }
  },
  "cliffs": {
    "atom_four": {
      "title": "Atom Four",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_four/atom_four.glb",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_one": {
      "title": "Atom One",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_one_grass/atom_one_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "y": 1.01,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_three": {
      "title": "Atom Three",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_three_grass/atom_three_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "y": 1.01,
              "z": 0.375
            }
          }
        }
      }
    },
    "atom_two": {
      "title": "Atom Two",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "type": "gltf",
                "color": {
                  "paletteColor": "greyMColor"
                },
                "metalness": 0,
                "roughness": 1,
                "name": "main",
                "url": "models/atom_two_grass/atom_two_grass.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.375,
              "z": 0.375,
              "y": 1.01
            }
          }
        }
      }
    }
  },
  "gamePrefabs": {
    "main": {
      "title": "main",
      "entity": "ECSGame",
      "palette": "main",
      "mapRenderer": "level1",
      "mapManager": "level1",
      "threeJsWorld": "level1"
    }
  },
  "items": {
    "axe1h": {
      "title": "Axe 1H",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_axe_1h/item_axe_1h.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "knightShield": {
      "title": "Knight Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_knight/item_shield_knight.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "knightSword": {
      "title": "Knight Sword",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_sword_knight/item_sword_knight.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "shieldSnowflake": {
      "title": "Snowflake Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_snowflake/item_shield_snowflake.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "shieldLeaf": {
      "title": "Leaf Shield",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_shield_leaf/item_shield_leaf.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "woodStaff": {
      "title": "Wood Staff",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_staff_wood/item_staff_wood.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 0.99,
                  "y": 0.99,
                  "z": 0.99
                }
              }
            ]
          }
        }
      }
    },
    "staff_feathers": {
      "title": "Feathered Staff",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_staff_feathers/item_staff_feathers.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      }
    },
    "woodBow": {
      "title": "Wood Bow",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1,
              "z": 0
            },
            "rotation": {
              "x": -4.40619762898109e-16,
              "z": -0.008513801229241034
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/item_bow_peasant/item_bow_peasant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 2,
                  "y": 2,
                  "z": 5
                }
              }
            ]
          }
        }
      }
    }
  },
  "particles": {
    "smoke": {
      "title": "Smoke",
      "render": {
        "animations": {
          "idle": [
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "sphere",
                    "size": 1,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "id": 0
                  }
                ]
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "type": "sphere",
                    "size": 1,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 2,
                  "y": 2,
                  "z": 2
                }
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 4,
                  "y": 4,
                  "z": 4
                }
              }
            },
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "id": 0
                  }
                ],
                "scale": {
                  "x": 8,
                  "y": 8,
                  "z": 8
                }
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "sphere",
                "size": 1,
                "color": "#000000",
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "lifeSpan": 0.66
    }
  },
  "projectiles": {
    "arrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "y": 0.5,
              "x": 0.5,
              "z": 0.5
            }
          }
        }
      },
      "speed": 1000,
      "title": "Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": false,
      "homingStrength": 0
    },
    "bolt": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Bolt",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": false,
      "homingStrength": 0
    },
    "boulder": {
      "damageType": "fire",
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "name": "ball",
                    "type": "sphere",
                    "size": 12,
                    "x": 0,
                    "z": 0,
                    "rotationX": 90,
                    "color": {
                      "paletteColor": "greyDColor"
                    },
                    "rotationY": 0,
                    "rotationZ": 0,
                    "scaleX": 1,
                    "scaleY": 1,
                    "scaleZ": 1,
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "name": "ball",
                "type": "sphere",
                "size": 12,
                "x": 0,
                "z": 0,
                "rotationX": 90,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              }
            ],
            "position": {
              "x": -3.00653594771243,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "speed": 100,
      "title": "Boulder",
      "ballistic": true,
      "homing": false,
      "homingStrength": 0,
      "particle": "smoke",
      "shadows": false,
      "hitSound": "explosion",
      "attackSound": "missileLaunch"
    },
    "elvenArrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Elven Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": true,
      "homingStrength": 0.5
    },
    "huntingArrow": {
      "damageType": "physical",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/projectile_arrow/projectile_arrow.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 0.25,
              "y": 0.25,
              "x": 0.25
            }
          }
        }
      },
      "speed": 1000,
      "title": "Hunting Arrow",
      "attackSound": "plasma",
      "hitSound": "plasma",
      "homing": true,
      "homingStrength": 0.3
    },
    "lightning": {
      "customRenderer": "",
      "damageType": "electric",
      "speed": 5,
      "title": "Lightning"
    },
    "fireball": {
      "damageType": "fire",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "shapes": [
              {
                "name": "ball",
                "type": "sphere",
                "x": 0,
                "y": 0,
                "z": 0,
                "size": 0.2,
                "color": {
                  "paletteColor": "redDColor"
                },
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              }
            ],
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "speed": 300,
      "title": "Fireball",
      "ballistic": false,
      "homing": false,
      "homingStrength": 0,
      "particle": "smoke",
      "shadows": false,
      "hitSound": "explosion",
      "attackSound": "missileLaunch"
    }
  },
  "units": {
    "0_golemIce": {
      "title": "Ice Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "cold",
      "armor": 8,
      "coldResistance": 1,
      "lightningResistance": 0.1,
      "fireResistance": -0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem_ice/golem_ice.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "FreezingAuraAbility"
      ]
    },
    "0_golemFire": {
      "title": "Fire Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "fire",
      "armor": 8,
      "fireResistance": 1,
      "coldResistance": -0.25,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem_fire/golem_fire.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "BurningAuraAbility"
      ]
    },
    "1_is_acolyte": {
      "title": "Acolyte",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 45,
      "damage": 10,
      "attackSpeed": 0.9,
      "element": "divine",
      "armor": 6,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/acolyte/acolyte.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 5,
                "y": 0,
                "z": -2
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_is_paladin",
        "2_is_crusader",
        "2_is_oathBreaker"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "HealAbility"
      ],
      "icon": "unit_acolyte",
      "visionRange": 500,
      "supplyCost": 2
    },
    "0_golemStone": {
      "title": "Stone Golem",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 2500,
      "speed": 15,
      "damage": 150,
      "attackSpeed": 0.7,
      "element": "physical",
      "armor": 12,
      "fireResistance": 0.1,
      "coldResistance": 0.1,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/golem/golem.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": true,
      "squadWidth": 1,
      "squadHeight": 1,
      "specUnits": [
        "0_golemIce",
        "0_golemFire"
      ],
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "icon": "unit_stoneGolem"
    },
    "1_di_scout": {
      "title": "Rogue",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 60,
      "damage": 40,
      "attackSpeed": 1.2,
      "range": 100,
      "projectile": "arrow",
      "element": "physical",
      "armor": 0,
      "fireResistance": 0.25,
      "coldResistance": 0.25,
      "lightningResistance": 0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/rogue/rogue.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 3,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_di_shadowAssassin",
        "2_di_trickster",
        "2_di_goblinBomber"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "icon": "unit_rogue",
      "visionRange": 800,
      "supplyCost": 2
    },
    "1_sd_soldier": {
      "title": "Soldier",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 300,
      "speed": 45,
      "damage": 12,
      "attackSpeed": 0.8,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.25,
      "coldResistance": 0.25,
      "lightningResistance": 0.25,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/warrior/warrior.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_sd_knight",
        "2_sd_hoplite",
        "2_sd_crossbowman"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "WindShieldAbility"
      ],
      "icon": "unit_soldier",
      "visionRange": 500,
      "supplyCost": 2
    },
    "2_di_trickster": {
      "title": "Trickster (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 320,
      "hp": 350,
      "speed": 80,
      "damage": 28,
      "attackSpeed": 2,
      "element": "poison",
      "armor": 4,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.15,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/walk_bow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/sword_slash.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/trickster/trickster.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": -20,
                "z": -910
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MirrorImagesAbility"
      ]
    },
    "0_skeleton": {
      "title": "Skeleton",
      "size": 25,
      "height": 50,
      "value": -1,
      "hp": 50,
      "speed": 65,
      "damage": 10,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 5,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/skeleton/skeleton.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": -8,
                "y": -5,
                "z": 3
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "1_s_barbarian": {
      "title": "Barbarian",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 300,
      "speed": 40,
      "damage": 10,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 8,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/sword_slash/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/barbarian/barbarian.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_s_berserker",
        "2_s_gladiator",
        "2_s_warlord"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "range": 5,
      "projectile": "arrow",
      "icon": "unit_barbarian",
      "visionRange": 500,
      "supplyCost": 2
    },
    "2_sd_knight": {
      "title": "Knight (2) [SD]",
      "size": 35,
      "height": 50,
      "value": 110,
      "hp": 240,
      "speed": 25,
      "damage": 20,
      "attackSpeed": 0.9,
      "element": "physical",
      "armor": 8,
      "fireResistance": 0.15,
      "coldResistance": 0.15,
      "lightningResistance": 0.1,
      "poisonResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "url": "models/knight/knight.glb",
                "metalness": "0",
                "roughness": "1"
              }
            ],
            "scale": {
              "z": 1,
              "y": 1,
              "x": 1
            }
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 6,
                "y": 16,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -6
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ChargeAbility"
      ]
    },
    "2_i_elementalist": {
      "title": "Elementalist (2) [I]",
      "size": 25,
      "height": 50,
      "value": 140,
      "hp": 150,
      "speed": 55,
      "damage": 0,
      "attackSpeed": 0,
      "range": 160,
      "armor": 2,
      "fireResistance": 0.4,
      "coldResistance": 0,
      "lightningResistance": 0.2,
      "abilities": [
        "ChainLightningAbility"
      ],
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/archmage/archmage.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "staff_feathers",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": -10,
                "y": 15,
                "z": 0
              },
              "rotation": {
                "x": 180,
                "y": 0,
                "z": 180
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_i_enchanter": {
      "title": "Enchanter (2) [I]",
      "size": 25,
      "height": 50,
      "value": 140,
      "hp": 150,
      "speed": 55,
      "damage": 0,
      "attackSpeed": 0,
      "range": 160,
      "armor": 2,
      "fireResistance": 0.4,
      "coldResistance": 0,
      "lightningResistance": 0.2,
      "abilities": [
        "MindControlAbility"
      ],
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/evil_sorcerer/evil_sorcerer.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "staff_feathers",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": -8
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_i_necromancer": {
      "title": "Necromancer (2) [I]",
      "size": 25,
      "height": 50,
      "value": 250,
      "hp": 180,
      "speed": 35,
      "damage": 12,
      "attackSpeed": 1,
      "element": "poison",
      "armor": 3,
      "fireResistance": 0.1,
      "coldResistance": 0.3,
      "lightningResistance": 0.2,
      "range": 100,
      "projectile": "fireball",
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/2h_spell_summon.glb",
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/necromancer/necromancer.glb",
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 160,
                "z": 0
              }
            }
          }
        ]
      },
      "abilities": [
        "RaiseDeadAbility"
      ],
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_sd_crossbowman": {
      "title": "Crossbowman (2) [SD]",
      "size": 25,
      "height": 50,
      "value": 380,
      "hp": 450,
      "speed": 40,
      "damage": 32,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 12,
      "fireResistance": 0.6,
      "coldResistance": 0.1,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/shooting_arrow/shooting_arrow.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/hoplite/hoplite.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": -5,
                "y": 5,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": -20
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "range": 200,
      "projectile": "bolt"
    },
    "2_s_gladiator": {
      "title": "Gladiator (2) [S]",
      "size": 25,
      "height": 50,
      "value": 50,
      "hp": 150,
      "speed": 35,
      "damage": 12,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.05,
      "coldResistance": 0.05,
      "lightningResistance": 0.05,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/gladiator/gladiator.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 2,
                "y": 5,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 10
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ArenaPresenceAbility"
      ]
    },
    "1_i_apprentice": {
      "title": "Apprentice",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 55,
      "damage": 15,
      "attackSpeed": 1.1,
      "range": 150,
      "element": "fire",
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/1h_spell_throw/1h_spell_throw.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/apprentice/apprentice.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "projectile": "fireball",
      "specUnits": [
        "2_i_elementalist",
        "2_i_enchanter",
        "2_i_necromancer"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "icon": "unit_apprentice",
      "visionRange": 500,
      "supplyCost": 2
    },
    "2_d_beastMaster": {
      "title": "Beast Master (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/idle/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "cast": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/2h_spell_summon/2h_spell_summon.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/beastmaster/beastmaster.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "SummonWolfAbility"
      ]
    },
    "2_di_goblinBomber": {
      "title": "Goblin Bomber (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 120,
      "hp": 450,
      "speed": 60,
      "damage": 40,
      "attackSpeed": 1.2,
      "element": "fire",
      "armor": 1,
      "fireResistance": 0.75,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 0.5,
              "y": 0.5,
              "z": 0.5
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/goblin/goblin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MeteorStrikeAbility"
      ],
      "range": 100,
      "projectile": "fireball"
    },
    "2_is_crusader": {
      "title": "Templar (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/templar/templar.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": -1,
                "y": 10,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 5,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "HealAbility"
      ]
    },
    "2_s_berserker": {
      "title": "Berserker (2) [S]",
      "size": 25,
      "height": 50,
      "value": 160,
      "hp": 180,
      "speed": 55,
      "damage": 24,
      "attackSpeed": 1.5,
      "element": "physical",
      "armor": 3,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.05,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/1h_axe_swing.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/berserker/berserker.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "position": {
                  "y": 0,
                  "z": 0
                },
                "rotation": {
                  "x": 0,
                  "y": 0,
                  "z": 0
                },
                "scale": {
                  "x": 1,
                  "y": 1,
                  "z": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 5,
                "z": 5
              },
              "rotation": {
                "x": 180,
                "y": 0,
                "z": 180
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": []
    },
    "2_di_shadowAssassin": {
      "title": "Shadow Assassin (2) [DI]",
      "size": 25,
      "height": 50,
      "value": 320,
      "hp": 500,
      "speed": 80,
      "damage": 28,
      "attackSpeed": 2,
      "element": "physical",
      "armor": 4,
      "fireResistance": 0.1,
      "coldResistance": 0.2,
      "lightningResistance": 0.15,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/walk_bow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/sword_slash.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/assassin/assassin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 20,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": -20,
                "z": -910
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ShadowStrikeAbility"
      ]
    },
    "2_is_oathBreaker": {
      "title": "Oathbreaker (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "poison",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/oathbreaker/oathbreaker.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -10
              },
              "rotation": {
                "x": 15,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "CurseAbility"
      ]
    },
    "1_d_archer": {
      "title": "Archer",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 150,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/shooting_arrow.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/scout/scout.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 90
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [
        "2_d_beastMaster",
        "2_d_ranger",
        "2_d_trapper"
      ],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [],
      "icon": "unit_archer",
      "visionRange": 650,
      "supplyCost": 2
    },
    "2_d_trapper": {
      "title": "Trapper (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 200,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/ranger/ranger.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "ExplosiveTrapAbility"
      ]
    },
    "2_d_ranger": {
      "title": "Ranger (2) [D]",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 140,
      "speed": 55,
      "damage": 16,
      "attackSpeed": 1.1,
      "range": 400,
      "projectile": "arrow",
      "element": "physical",
      "fireResistance": 0.5,
      "coldResistance": 0.5,
      "lightningResistance": 0.5,
      "armor": 1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_bow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/shooting_arrow.glb",
                    "scale": {
                      "z": 1,
                      "y": 1,
                      "x": 1
                    },
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/ranger/ranger.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1",
                "scale": {
                  "z": 1,
                  "y": 1,
                  "x": 1
                }
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodBow",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": 5
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": []
    },
    "2_sd_hoplite": {
      "title": "Hoplite (2) [SD]",
      "size": 25,
      "height": 50,
      "value": 380,
      "hp": 450,
      "speed": 40,
      "damage": 32,
      "attackSpeed": 1,
      "element": "fire",
      "armor": 12,
      "fireResistance": 0.6,
      "coldResistance": 0.1,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/hoplite/hoplite.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -10
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "",
              "offset": {
                "x": 0,
                "y": 0,
                "z": -20
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "PhalanxFormationAbility"
      ]
    },
    "4_archmage": {
      "title": "Archmage",
      "size": 25,
      "height": 50,
      "value": 420,
      "hp": 200,
      "speed": 30,
      "damage": 30,
      "attackSpeed": 0.7,
      "range": 200,
      "projectile": "fireball",
      "element": "fire",
      "armor": 4,
      "fireResistance": 0.5,
      "coldResistance": 0.2,
      "lightningResistance": 0.3,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/1h_spell_throw.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/archmage/archmage.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "offHand",
            "item": "woodStaff",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 15,
                "z": 2
              },
              "rotation": {
                "x": 0,
                "y": 180,
                "z": 0
              }
            }
          }
        ]
      },
      "abilities": [
        "ChainLightningAbility"
      ],
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "2_is_paladin": {
      "title": "Paladin (2) [IS]",
      "size": 25,
      "height": 50,
      "value": 110,
      "hp": 200,
      "speed": 35,
      "damage": 14,
      "attackSpeed": 1,
      "element": "divine",
      "armor": 6,
      "fireResistance": 0.2,
      "coldResistance": 0.2,
      "lightningResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/paladin/paladin.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 8,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 20,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "SmiteAbility"
      ]
    },
    "peasant": {
      "title": "Peasant",
      "size": 25,
      "height": 50,
      "value": 35,
      "hp": 60,
      "speed": 40,
      "damage": 6,
      "attackSpeed": 1,
      "element": "physical",
      "armor": 8,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "type": "gltf",
                    "url": "animations/idle.glb",
                    "width": 2,
                    "height": 0.2,
                    "depth": 1,
                    "x": 0,
                    "y": 0,
                    "z": 0,
                    "rotationX": 0,
                    "rotationY": 0,
                    "rotationZ": 0,
                    "color": "#FFFFFF",
                    "metalness": "0",
                    "roughness": "1",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_steady_right_hand.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "models/sword_slash/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/peasant/peasant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "axe1h",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 0,
                "y": 0,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": true,
      "specUnits": [],
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "MineGoldAbility",
        "BuildAbility"
      ],
      "icon": "unit_peasant",
      "actionSet": "peasant_actions",
      "visionRange": 400,
      "supplyCost": 1
    },
    "4_ancientTreant": {
      "title": "Ancient Treant",
      "size": 25,
      "height": 100,
      "value": 480,
      "hp": 720,
      "speed": 15,
      "damage": 40,
      "attackSpeed": 0.7,
      "element": "physical",
      "armor": 12,
      "fireResistance": -0.2,
      "coldResistance": 0.3,
      "lightningResistance": 0.1,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_walk.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/mutant_swipe.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 2,
              "y": 2,
              "z": 2
            },
            "shapes": [
              {
                "type": "gltf",
                "url": "models/treant/treant.glb",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "color": "#FFFFFF",
                "metalness": "0",
                "roughness": "1"
              }
            ]
          }
        }
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    },
    "sentry": {
      "title": "Sentry Tower",
      "info": "Defensive sentry tower",
      "value": 250,
      "range": 4,
      "damage": 10,
      "attackSpeed": 0.5,
      "projectile": "arrow",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 20,
                "height": 4,
                "color": "#78909c",
                "x": 0,
                "y": 2,
                "z": 0,
                "name": "base",
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "scaleX": 1,
                "scaleY": 1,
                "scaleZ": 1
              },
              {
                "type": "cylinder",
                "size": 14,
                "height": 26,
                "color": "#78909c",
                "x": 0,
                "y": 17,
                "z": 0,
                "name": "body"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          },
          "rampart": {
            "shapes": [
              {
                "type": "cylinder",
                "size": 12,
                "height": 8,
                "color": "#3e4f57",
                "x": 0,
                "y": 30,
                "z": 0,
                "name": "rampartbase"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": 4,
                "y": 34,
                "z": 4,
                "name": "rampartblock1"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": -4,
                "y": 34,
                "z": 4,
                "name": "rampartblock2"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": 4,
                "y": 34,
                "z": -4,
                "name": "rampartblock3"
              },
              {
                "type": "box",
                "width": 3,
                "height": 5,
                "depth": 3,
                "color": "#3e4f57",
                "x": -4,
                "y": 34,
                "z": -4,
                "name": "rampartblock4"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1.5,
              "y": 1,
              "z": 1.5
            }
          },
          "attacker": {
            "shapes": [],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      }
    },
    "2_s_warlord": {
      "title": "Warlord (2) [S]",
      "size": 35,
      "height": 50,
      "value": 110,
      "hp": 240,
      "speed": 25,
      "damage": 20,
      "attackSpeed": 0.9,
      "element": "physical",
      "armor": 8,
      "fireResistance": 0.15,
      "coldResistance": 0.15,
      "lightningResistance": 0.1,
      "poisonResistance": 0.2,
      "render": {
        "animations": {
          "idle": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/idle.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "walk": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/walk_with_shield.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "attack": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/sword_slash.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "death": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/death_fallback.glb",
                    "id": 0
                  }
                ]
              }
            }
          ],
          "celebrate": [
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_gangnamstyle.glb",
                    "id": 0
                  }
                ]
              }
            },
            {
              "main": {
                "shapes": [
                  {
                    "url": "animations/dance_thriller.glb",
                    "id": 0
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "gltf",
                "width": 2,
                "height": 0.2,
                "depth": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "metalness": "0",
                "roughness": "1",
                "color": "#FFFFFF",
                "url": "models/berserker/berserker.glb"
              }
            ],
            "scale": {
              "z": 1,
              "y": 1,
              "x": 1
            }
          }
        },
        "equipment": [
          {
            "slot": "mainHand",
            "item": "knightSword",
            "attachmentData": {
              "bone": "RightHand",
              "offset": {
                "x": 6,
                "y": 16,
                "z": 0
              },
              "rotation": {
                "x": 0,
                "y": 0,
                "z": 0
              }
            }
          },
          {
            "slot": "offHand",
            "item": "knightShield",
            "attachmentData": {
              "bone": "LeftHand",
              "offset": {
                "x": 0,
                "y": 10,
                "z": -6
              },
              "rotation": {
                "x": 10,
                "y": 0,
                "z": 0
              }
            }
          }
        ]
      },
      "buyable": false,
      "squadWidth": 1,
      "squadHeight": 1,
      "placementGridWidth": 1,
      "placementGridHeight": 1,
      "abilities": [
        "BattleCryAbility"
      ]
    }
  },
  "visuals": {
    "meteor_warning": {
      "title": "Meteor Warning",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "main": {
            "position": {
              "x": 0,
              "y": 0.1
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "shapes": [
              {
                "type": "sphere",
                "x": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "size": 20,
                "scale": {
                  "y": 0.1
                },
                "position": {
                  "y": 10
                },
                "color": {
                  "paletteColor": "redDColor"
                }
              }
            ]
          }
        }
      }
    }
  },
  "worldObjects": {
    "rock": {
      "title": "Rock",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "tetrahedron",
                "size": 16,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "x": 3.5,
                "y": 2,
                "z": 2.5,
                "rotationX": 50,
                "rotationY": 140,
                "rotationZ": 10,
                "scaleX": 1
              },
              {
                "type": "tetrahedron",
                "size": 12,
                "color": {
                  "paletteColor": "greyDColor"
                },
                "x": 10.5,
                "y": 2,
                "z": 7.5,
                "rotationX": 50,
                "rotationY": 150,
                "rotationZ": 10
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      }
    },
    "goldVein": {
      "title": "Gold Vein",
      "render": {
        "animations": {
          "idle": [
            {
              "shapes": {
                "shapes": [
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 1
                  },
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 2
                  },
                  {
                    "color": {
                      "paletteColor": "greenDColor"
                    },
                    "id": 3
                  }
                ]
              }
            }
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "size": 2,
                "color": "#ff0000",
                "metalness": 0,
                "roughness": 1,
                "x": 0,
                "y": 0,
                "z": 0,
                "rotationX": 0,
                "rotationY": 0,
                "rotationZ": 0,
                "url": "models/goldvein/goldvein.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            }
          }
        }
      },
      "placementGridWidth": 2,
      "placementGridHeight": 2,
      "snapToGrid": true,
      "height": 100
    },
    "tree": {
      "title": "Tree",
      "render": {
        "animations": {
          "idle": [
            {}
          ]
        },
        "model": {
          "shapes": {
            "shapes": [
              {
                "type": "gltf",
                "metalness": 0,
                "roughness": 1,
                "url": "models/new_fir/new_fir.glb"
              }
            ],
            "position": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "rotation": {
              "x": 0,
              "y": 0,
              "z": 0
            },
            "scale": {
              "x": 1,
              "y": 1,
              "z": 1
            }
          }
        }
      },
      "height": 75,
      "size": 25,
      "placementGridWidth": 1,
      "placementGridHeight": 1
    }
  },
  "icons": {
    "building_goldMine": {
      "title": "Building Gold Mine",
      "filePath": "resources/images/icons/building_goldMine.png"
    },
    "building_mageTower": {
      "title": "Building Mage Tower",
      "filePath": "resources/images/icons/building_mageTower.png"
    },
    "building_townHall": {
      "title": "Building Town Hall",
      "filePath": "resources/images/icons/building_townHall.png"
    },
    "order_hold": {
      "title": "Order Hold",
      "filePath": "resources/images/icons/order_hold.png"
    },
    "building_barracks": {
      "title": "Building Barracks",
      "filePath": "resources/images/icons/building_barracks.png"
    },
    "unit_peasant": {
      "title": "Unit Peasant",
      "filePath": "resources/images/icons/unit_peasant.png"
    },
    "building_fletchersHall": {
      "title": "Building Fletchers Hall",
      "filePath": "resources/images/icons/building_fletchersHall.png"
    },
    "unit_acolyte": {
      "title": "Unit Acolyte",
      "filePath": "resources/images/icons/unit_acolyte.png"
    },
    "unit_archer": {
      "title": "Unit Archer",
      "filePath": "resources/images/icons/unit_archer.png"
    },
    "unit_rogue": {
      "title": "Unit Rogue",
      "filePath": "resources/images/icons/unit_rogue.png"
    },
    "unit_soldier": {
      "title": "Unit Soldier",
      "filePath": "resources/images/icons/unit_soldier.png"
    },
    "building_cottage": {
      "title": "Building Cottage",
      "filePath": "resources/images/icons/building_cottage.png"
    },
    "unit_barbarian": {
      "title": "Unit Barbarian",
      "filePath": "resources/images/icons/unit_barbarian.png"
    },
    "unit_stoneGolem": {
      "title": "Unit Stone Golem",
      "filePath": "resources/images/icons/unit_stoneGolem.png"
    },
    "unit_apprentice": {
      "title": "Unit Apprentice",
      "filePath": "resources/images/icons/unit_apprentice.png"
    },
    "order_move": {
      "title": "Order Move",
      "filePath": "resources/images/icons/order_move.png"
    }
  },
  "materials": {
    "greenL": {
      "title": "Green Light",
      "color": "#a3d39c"
    }
  },
  "palettes": {
    "main": {
      "title": "Main",
      "greenLColor": "#a3d39c",
      "greenMColor": "#5a8a4f",
      "greenDColor": "#2f4a29",
      "brownLColor": "#d9b38c",
      "brownMColor": "#8b5e3c",
      "brownDColor": "#4a2f1f",
      "blueLColor": "#b3e5fc",
      "blueMColor": "#4fc3f7",
      "blueDColor": "#0288d1",
      "redLColor": "#ffcc80",
      "redMColor": "#ff8c00",
      "redDColor": "#bf360c",
      "purpleLColor": "#e1bee7",
      "purpleMColor": "#ab47bc",
      "purpleDColor": "#6a1b9a",
      "greyLColor": "#cfd8dc",
      "greyMColor": "#78909c",
      "greyDColor": "#3e4f57"
    }
  },
  "shaders": {
    "grass": {
      "title": "Grass",
      "fragmentScript": "varying vec2 vUv;\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform vec3 directionalLightColor; // DirectionalLight color\nuniform float directionalLightIntensity; // DirectionalLight intensity\nuniform vec3 directionalLightDirection; // DirectionalLight direction (world space)\nuniform vec3 ambientLightColor; // AmbientLight color\nuniform float ambientLightIntensity; // AmbientLight intensity\nuniform vec3 skyColor; // HemisphereLight sky color\nuniform vec3 groundColor; // HemisphereLight ground color\nuniform float hemisphereIntensity; // HemisphereLight intensity\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    vec4 texColor = texture2D(map, vUv);\n    vec3 color = texColor.rgb;\n\n    // Directional light (Lambertian diffuse)\n    vec3 lightDir = normalize(directionalLightDirection); // Ensure direction is normalized\n    float diff = max(dot(vNormal, lightDir), 0.0);\n    vec3 diffuse = directionalLightColor * directionalLightIntensity * diff * color;\n\n    // Ambient light\n    vec3 ambient = ambientLightColor * ambientLightIntensity * color;\n\n    // Hemisphere light\n    vec3 hemiDir = vec3(0.0, 1.0, 0.0); // Up direction for hemisphere\n    float hemiDot = dot(vNormal, hemiDir) * 0.5 + 0.5; // Remap to 0-1\n    vec3 hemi = mix(groundColor, skyColor, hemiDot) * hemisphereIntensity * color;\n\n    // Combine lighting contributions\n    vec3 litColor = diffuse + ambient + hemi;\n\n    // Apply fog\n    float fogDistance = length(vWorldPosition - cameraPosition);\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695);\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    vec3 finalColor = mix(fogColor, litColor, fogFactor);\n\n    gl_FragColor = vec4(finalColor, texColor.a);\n}",
      "vertexScript": "varying vec2 vUv;\nuniform float time;\nuniform float windSpeed;\nuniform float windStrength;\nuniform vec2 windDirection;\nattribute float instancePhase;\nvarying vec3 vWorldPosition;\nvarying vec3 vNormal; // Add for lighting\n\nvoid main() {\n    vUv = uv;\n    vec2 dir = normalize(windDirection);\n    float wave = sin(time * windSpeed + instancePhase) * windStrength;\n    wave *= uv.y;\n\n    vec3 displacement = vec3(\n        dir.x * wave,\n        0.0,\n        dir.y * wave\n    );\n\n    // Compute world position in world space\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(position + displacement, 1.0);\n    vWorldPosition = worldPosition.xyz; // Store correct world position\n  \n    vec3 normal = normalize(normal); // Assuming grass geometry has normals\n    vNormal = normalize((modelMatrix * instanceMatrix * vec4(normal, 0.0)).xyz);\n\n    // Compute view position for gl_Position\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    vUv = uv;\n}",
      "uniforms": "{ \"time\": { \"value\": 0 }, \"windSpeed\": { \"value\": 0.8 }, \"windStrength\": { \"value\": 2 }, \"windDirection\": { \"value\": [0.8, 0.6]} }",
      "vectors": "[\"windDirection\"]"
    },
    "water": {
      "title": "Water",
      "fragmentScript": "uniform float time;\nuniform float waveHeight;\nuniform vec3 liquidColor;\nuniform vec3 foamColor;\nuniform float waveFrequency;\nuniform float fresnelPower;\nuniform vec3 lightDirection;\nuniform float ambientIntensity;\nuniform float specularIntensity;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\nuniform vec3 fogColor;\nuniform float fogDensity;\n\nvoid main() {\n    vec2 uv = vUv;\n    vec3 normal = normalize(vNormal);\n    vec3 viewDir = normalize(vViewPosition);\n    vec3 lightDir = normalize(lightDirection);\n\n    // Fresnel effect for edge transparency\n    float fresnel = pow(1.0 - max(dot(normal, viewDir), 0.0), fresnelPower);\n\n    // Diffuse lighting\n    float diffuse = max(dot(normal, lightDir), 0.0) * 0.25;\n\n    // Specular (Blinn-Phong)\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float specular = pow(max(dot(normal, halfwayDir), 0.0), 32.0) * specularIntensity;\n\n    // Base color with subtle wave height modulation\n    vec3 baseColor = liquidColor * (0.8 + 0.2 * vNormalizedWaveHeight); // Slight tint variation\n\n    // Foam effect based on normalized wave height\n    float foamFactor = smoothstep(0.8, 1.0, vNormalizedWaveHeight); // Tighter range for foam at peaks\n    vec3 color = mix(baseColor, foamColor, foamFactor);\n  \n    float fogDistance = length(vWorldPosition - cameraPosition); // Distance from fragment to camera\n    float fogFactor = exp2(-fogDensity * fogDensity * fogDistance * fogDistance * 1.442695); // 1.442695 = ln(2)\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    // Combine lighting components\n    vec3 lightColor = color * (ambientIntensity + diffuse) + vec3(specular);\n\t\tvec3 finalColor = mix(fogColor, lightColor, fogFactor);\n    // Apply fresnel for transparency at edges\n    float alpha = mix(0.6, 1.0, fresnel);\n\n    gl_FragColor = vec4(finalColor, alpha);\n}",
      "vertexScript": " uniform float time;\nuniform float waveHeight;\nuniform float waveFrequency;\nuniform float waveSpeed;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvarying float vWaveHeight;\nvarying float vNormalizedWaveHeight; // New varying for normalized height\nvarying vec3 vWorldPosition;\n// Simple noise function for wave variation\nfloat snoise(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vUv = uv;\n\n    // Combine multiple waves for more natural movement\n    float wave1 = sin(uv.x * waveFrequency + time * waveSpeed) * waveHeight;\n    float wave2 = sin(uv.y * waveFrequency * 0.7 + time * waveSpeed * 0.8) * waveHeight * 0.5;\n    float wave3 = cos((uv.x + uv.y) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * waveHeight * 0.3;\n    float displacementY = (wave1 + wave2 + wave3) * 0.5;\n\n    // Store wave height for fragment shader\n    vWaveHeight = displacementY;\n\n    // Normalize wave height based on maximum possible displacement\n    float maxWaveHeight = waveHeight * (1.0 + 0.5 + 0.3) * 0.5; // Sum of wave amplitudes\n    vNormalizedWaveHeight = displacementY / maxWaveHeight;\n\n    // Update position with displacement\n    vec3 newPosition = vec3(position.x, position.y + displacementY, position.z);\n\n    // Compute normal for lighting\n    float offset = 0.01;\n    float waveX = (sin((uv.x + offset) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    float waveZ = (sin((uv.x) * waveFrequency + time * waveSpeed) +\n                   sin((uv.y + offset) * waveFrequency * 0.7 + time * waveSpeed * 0.8) * 0.5 +\n                   cos((uv.x + uv.y + offset) * waveFrequency * 0.5 + time * waveSpeed * 1.2) * 0.3) * waveHeight * 0.5;\n    vec3 tangent = normalize(vec3(1.0, (waveX - displacementY) / offset, 0.0));\n    vec3 bitangent = normalize(vec3(0.0, (waveZ - displacementY) / offset, 1.0));\n    vNormal = normalize(cross(tangent, bitangent));\n\n    // Pass view position for fresnel and lighting\n    vec4 worldPosition = modelMatrix * vec4(newPosition, 1.0);\n    vViewPosition = (cameraPosition - worldPosition.xyz);\n    vWorldPosition = worldPosition.xyz;\n    // Apply projection and model-view transforms\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\n}",
      "uniforms": "{\"time\":{\"value\":0},\"waveHeight\":{\"value\":3},\"waveFrequency\":{\"value\":5},\"waveSpeed\":{\"value\":0.25},\"liquidColor\":{\"value\":\"\"},\"foamColor\":{\"value\":\"\"},\"fresnelPower\":{\"value\":0},\"lightDirection\":{\"value\":[0.5,0.5,0.5]},\"ambientIntensity\":{\"value\":1},\"specularIntensity\":{\"value\":1}}",
      "vectors": "[\"foamColor\",\"liquidColor\",\"lightDirection\"]"
    }
  },
  "textures": {
    "path": {
      "title": "Path",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA+0lEQVRoQ+2UsRWDMAxEcZ8FskAmyIAMmAmyAAukJwlFCj+MfcLikCJqSzrdP5HmxzgPhr50H5MhuVWpyRqA70aeIJgE4AlCM4DndBlu11f1pEoP9tav9fVwCc0AxM5H4eJAKSxqADQSb53lGgQ1ANbN0tKfQxABiHTL8UAAwmi50aVKCED/8dExAJAzQAPg7Xcm3UcFgFQMOYyU8SoAKJtkQ0shOFs4NgFIxEpqzgCMpcHtBbAMRecGANSxz3vkymtvYQC1hoJ9fiWavffo0qyFAWiK+cfeLgFYuiSXAJBLYsPqCoC9DGL8EW9b/OgK4IilvM0IAGSiOYA3/xycGR8hN+EAAAAASUVORK5CYII="
    },
    "start": {
      "title": "Start",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwGEb1QOL0QuQwQqWXk7NdvLTHSwY3uy33VZ0v0HOdeEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAvn4mAZ8YoyRAAAAABJRU5ErkJggg=="
    },
    "lava": {
      "title": "Lava",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAkUlEQVRoQ+3UQQ6AIAxEUXpnj8GdMW4Jhl0/Jd+1yei8TGP0NlqhJ54WhT53+6lRDeD7o5sQSgLchFAW4BaE0gDbA3vQC39nU4BEpBWCAIkAq7MpgADJDcBx8xlyAckgAiQXPscJIADcABzvAgSAG4DjXYAAcANwvAsQAG4AjncBAsANwPEuQAC4ATjeBRwG8AKHQEgZvHpI7AAAAABJRU5ErkJggg=="
    },
    "rock": {
      "title": "Rock",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAA40lEQVRoQ+3VPQ6DMAwFYHItBqQOzIw9I2PnDpUYeq2iTkgoyAnBvzzmyHn4syEN0/PXOXqW15wcxSWjJm8A/zeKhOASIBKCW4AoCK4ByA+soQNHn00ACCLlELIA/WPsvp/35dG46l4elLHgHgEbwNjsXOkmAExwu1YTQPv1qAAA5RkAAACUO6B8vdgG4IedlxYDUB40s9e7A4i2SSYAojW1Zt2KAe7cpJqG1p4tBqgtbPU81yCdrcsGcDaQVTiuXGwAXIGj1VUBwHZsY0QCWGhWaYbSc5JbRGUiASTD3vGuPcAKi06NGSIOm+IAAAAASUVORK5CYII="
    },
    "scales": {
      "title": "Scales",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAQ0lEQVQYV2OM6vL/z4ADXD1wi4GRoAJ9L83/2g5qGGaAdIPEwSaAOOgApgnFCpguZMXEK4DpRjeFEeRIkJHIDkV2EwCeFirmzbH2AwAAAABJRU5ErkJggg=="
    },
    "water": {
      "title": "Water",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlUlEQVRoQ+3UwQ2AIBBEUbEh27ME27MhNF4Jhtt+lnzPJqPzMlv26362RE89j5Loc4efWrIBfH+0EkJKgJUQ0gKsgpAaYHhgJ3rh72wKEIjUQxAgEKB3NgUQILgBOK49Qy4gGESA4MLbOAEEgBuA412AAHADcLwLEABuAI53AQLADcDxLkAAuAE43gUIADcAx7uAyQBeDUJgGasSxlsAAAAASUVORK5CYII="
    },
    "end": {
      "title": "End",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAlklEQVRoQ+3UIQ6AMBBEUeo5D56T4zlPPQTblNTt7zYfTTIwL7PlOvZnS/Scdy2JPnf4qSUbwPdHKyGkBFgJIS3AKgipAYYHdqIX/s6mAIFIPQQBAgF6Z1MAAYIbgOPaM+QCgkEECC68jRNAALgBON4FCAA3AMe7AAHgBuB4FyAA3AAc7wIEgBuA412AAHADcLwLmAzgBfVWYBnOEmyVAAAAAElFTkSuQmCC"
    },
    "grass": {
      "title": "Grass",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAwCAYAAADuFn/PAAAAAXNSR0IArs4c6QAAFepJREFUeF7dnGusZFlZht+1b3Wvc++Znu6BQTQS/amJ/HAQQXBgMIDGGCBRE6KSiJFI1DhgCNEIxgAaY8IfiJJ4wRguigwzDsMEBjSK/BBNCAkRZprp6du51L323msv83yrqi+nh992zZ7L6TqnTtWqb63v/d7v/d7d7qd//t5QLoLmk0a97UShkTr9TE5SuWxUV0FSULefaTatJZeoWnjlLaduL36v00s1n3p7zMX3sjRRmjr5RioXtZKMV4xXCJKv4x+ck5pG9nrxh/FLXQdbQ6udaLlo5HiinJ74zNM3Xuj6K27uH9wrXn8+eB80Own22Yd7iQWUB4t5UGBHVleXQM9qheDUKlItyxh025ibrvX3ynlQ3nZqd1IdXy7t9QfbucqyseAmCf+TvUZVelW22VLKZgVnP+e5TR3U1E51JXWG0uOfuvC82QT3steeCw0bMJbOvqjQfBXMyXGj2SSo3WFT0uvhJRDjY6+8kHbO5FrOPQfztmsxjac2K5yd8hCCOt1MJ4eV+mzCzKvdTVXXjeRi4MkMruVEcllQ8EH97UyLqVdVBrX77Fi8ni+b4F7+M+dtA7pbmQVlHUw2YD7x2jnIlGScSslXUlYkKheNneTJVadi4FW0k+sbx2m+eqnUYJhpMfHKWs6Cn+bxVPf6mcZHlVzuVJeNgpdanVSVb+QXwaCq1ZYWi2CwRPZMTryy4kamsAGjQ69//fwzG58J7sE332cbMD6utXc2s9Pd7iZazBr7L01cxOjCCajq9lMtZl6Nl53OumrUaqcGQwT/6HJpmxmqIL+CmaaSfBNUtFf7S2Zkqe31+KRWkjgtF14uccpzykwiX8f3yH7olxS++TGDMtvcZ0t7PzbKKRhcbsL6v/S57z7nYXGvfOP5wEdpQtD0uNHBuVzTiVenk2o69mrqRlkr1dGVWtt7qcEJV9ME2xhKhJ3wLMIN0LOcN+oOUgVqtkuVFo0Gu5kSJyvWrSKzjIpFXRofSr1Boqpu1OokBmu8Lq9fVkH9Ad9rtLWX6dLTpTr9xOApzRLltqmbsf4vP3r7Jrgff9W5UPScDi959YdO2/uFDi+XekO/1CNqaXYiFUVibAg46W+ncmmwYuyXTp1uqsmoNsYzOvbKcqeilSjLpXoJbueajSv5Urrn+1oKauy9gP29s4Vmk8qYDgU/cYk9t7uVa3ZS2aHIgLexV6vrFKpESqgLqRZzrySVFqOgTVr/Fx+5lcW5173lvnB4pTb8h/i1u7IAUg/5gONDgpqoaElp4bR3d6Yr362NJXHySX8wnN/hdBdtp7yV6alvLnTX+Uw1BKmRat9YXchbqXoDWUZ1erltANd8FCzgiWODvTqDXHkRNB55BR+zqjNItXNANgJusSZwbdL6T5MH2wCKHGlfL4J27ykUGvoCr/lEVoB3zqTGRMBqgrRmpmRERbFsU1CDev1UtScDoIyNbU6eZ9YHQGZhUHkr0f7ZROXMaTKpdPVCozP3JkZB+1u5xkeNpqNSSZKot01BpgjTR8SAs+nA1s19xyat/zN//e1baoFtAFjsy0RJGmKD5GJj1m47be1nVgvAeIpk03jrA9YnkN/Nc6feMNHhpVrLRdDBPbkxnvFRrazILJMS1xizCXVQu5cohFRbe4kOr5Tqd3Mty1p5kWo6qVUvpEXpNdxJ7X3ZZCWNiiLTgmJ900dY9xysP82D6pLMbDSbNup2kjtu/Q9//Du3bsAr3nA+5Hmik2ve6B8ws72f6uoztdqdzPj4ctZYVgAfaRqMk+/fk+nqxch8ukPFP/c5wVUsyKCDc8aiwCsY1HQUlMipNZCqudTuueu0l2fZ7x+zAY3qJmjrTKbgnSYnwFTQR151pF99Yu96u9zpZUZ/W63EIK3VdrFObaU6ulyr3c2sXt1J6//+d8xu3YAH33RfGB3X6nQj+7gZZuDuvl51Ryt5AIq6lg/iSeTnznqBaknzJXnv1O1majz1I1VZer2mN9QXv31VF0Kq/k6iVgGtzDWbxhrQbmd65sJS3U6mNJGWyzrC0k4qehKYT7WkAUzkVn1hbwAFdUZlyUL6ilvWD3Vedde8B/LG//f6n3zk1t7F3f/AubC1l2sKk7kJZppm3cFKNZKEA+uhocEK7vGL3in31T+2k561EmNDZElVNWq3cutqgav1RQYoZKoWUqvPvnkVeaqqptYEJXnUh7a36fqcsaxWK2ZiZ0s6ueK1dRA7YbJuufR2OICn51p/aGJ2sY47af23FeFXvvFcgOUQBIILzCRJhBlO3XzcxMLrnTVjrR4g4jQbeXmUNhfUG6LlNKYPJVmi2aRWUwYT0cgMXocL1jMZxYLf6jhVy5UE4aGSvK4lk10EjoLLVyjubNIY1BD4tfhHp8yaWf9iZr9wAyaXQZ1Botnozlr/Y5966lYIQoqAuxNAPmwJd+84jQ6Dtg8S02umR41SkxQaTU9o1iJTohlDMe3TdFk753T54lJpklrRRWkrutBZMMNbbJuVEkpydKkBkqolzZpXu5VpPq9WwZcV0HImTawwNwZ2MKvtfeirsQX79/r6obs1tDixdfa377z1P/nIrc2Y+4kHz4V1MUsB3xWqc+rrZaOig/wMuwhWoHkKhe7as157d0cwhq1cuVCpO0hULgm4UwJTShI5RLheojk6T9Ko9kEZek8rNTxfzrw6fbruyhgUdaecNVagwfP5nI43yJdkpdTqcRBkkDcbw8h4/ViMeT4CIG9tcLgMKsi0O2j9X/6XUxsAC1qntK8oonSljTi0v/8bD+l9H36f1QZOLN9HIiZwFFweDLZlgaHr5fv8R1Ysp5zM2MxlbXIhtZM6GcOcbhRgoKjx8fdGx6U63VwvHZ/o8bSjXp9aEnR0tY4U2dODIOjFGQEbgfxxev38jHXeiet/8uFTRfgnX38+wFxodGhoQGKwnqYI+seJbHUyLee1ZieNuluJQp1oNq+0vZebMMcJrav4e3xwmMlbHvxFffrJv1U5r9Xu5RqflDZzaPWd2jbMya0R4/nkXdHNjbGA6eDKdFpp9yAz6kpA6TeoAeg/ZE1VB23twrDiUGdT1v+Ff7p1lnG9EUugnAsUy9ROmm8a9XqRSqLTrIsjDITOlEEJbIhhiTVoAXYUq2iWJfrtt75Lf/ax9xvt8146uVZaFiFbMMihyfvQe/5Kv/v+t1qGTUaV2u1Ui2Uc7pj0kA+Udhaaz5E+aALDSgrPNDmutXNXbPjYnE1Z/xOnN+C1b3phQNgynrykjEoupfGSjq94/eCPtDU5aSyIFGoqIewD1ROe/t6XjvUH/z4wOEKzBzbAc5Orh8wbU5OiwemTw9IYTZqlWi5qMTEDRugLqDHw+8zGmPH9q0WirN1YzWAaxvsNtjLj/UgdbC7zgk1a/xf/+VQGvOrnXhAorqQ1Em+SJppNvVyTqCEQqJYrAW64nxrW0/B0hyikskD42inNZUIcs2MK4louiPpN1IrIHCgjG8UAtMihiV7tfibPDhsBCMbzkSR6W6lCBRzVYm5Nc4dkDWyhVSFpAEmbtP5HP3FKivipnz0fOIlgauKccXZ0eD+XlpVXd5gaHPCh1zzdRLZ2YoE6fLa2Zmqwk14PPpIGbIjNkPNaziKvhxq2isi0OM15h4451YzNb4JtjPULXTrk0qSQqxcr7d5VmEyNzjPYox41xnTopn3dWCZtyvpvY0EMZAg4ciWFjLktKW4nrsfMNna0PEaH96UzfQgWRPtfLpAeGJxL/d0bM9t1MSWgiHNXnqmMwYS6ka+Quxk/Sr/3tnfrfR/+Qyv2dLbUICZdBJTXWIwZh8YaxIZNDpvYsSvOiB1Ff4PW//gnT0HQK15/LljHO41dKUGlCzbJd4QgllvBA1KidSRYd9nposEgAySG0cslSmqc464vpOVOLzZoFGoG8IsJcBWbpE4n0zsHqT5wsdQsiRaU2bi2ZssyhvdnCpfK9KC8RTedaTaqtHN3YTNn1rNJ6//Ko6doKEW4v+109WKUB4x99DKNDisL6HIu03tcLnW7iW0QtBDM50oTRokrSWE1noSOouHs7OfR5uOoLYijQSdXg1pt6kJtcwOTHGhoaZ58HHVSJ5g9U4uAscUMZRNLjFeeRWsMp571UoQ3af1f+PSpDLj/1edDZ+hMjsZqglQAu6Bo0gss5rUmx94G8AQQGGFj6DiBnisv+R090Puq/uvrT1gRf+evvEMf+OifWs9gDZwa5RkKqrPX2b0rs9+nSWMCNzryOjhb6OhKaboRjgs0HCCPbALaTP0081Zi2YhxjP6j3UkM/zdp/Y/+wykt6P4Hzpsjiw9LQNMcR0JjBRl8Ve00L320lAyREBjQ1BZEAkzGcOLpSDnGzI/JjulJHOgXNHHYXQALdJtUxnqgmcgSTdUYNAFTSBy8bn8Y0+vkGrOFOFfg+fQd5cJrMQ3q7URZHHV1k9b/2CdPbUCcCZfm+cFoNTqq7IMyv+UTWrp7eD/yrzTYZYOQI6IsDGT8lo70J822qZyG0SaURdaETMGGAkUEFjgxvYb5bxYhhPFifxgddlgagRZmCjH7GjsIvSFpECnqzU48Y2IbtP7nnAnzgZolKltj7KbVTaSQCD/PYlErz5yKbvSN2uk+CkrTVO1hUG9AwCujjK2OdHwt4vXoKDolOu1UJ8fVdUixeTE1IyhS3JlX0WKWfMMCySYig8QN8wZdvS3qQgz+DU9q9LBu0vpvmwkjxq29mZx4xnfgcKuLpCxtn8k0Poz+HYY03U6qKxcrDXcTkx+ADgI1NXdDdDUAKcgZBI6BPlo+NQVstx6gjIWWggN8mRglBvjRG4QmhI0FecF6c9fYyHP/bPY9vah4Szdh/bdlABtgQZnFLjgpZDQTaRlYAAYQzoAiijCQgo4Dth8+W1pW4PWsytpgxvQjbCbT2uRi6C2Qde8PFLr63Upn7i3sxIba2byWue3/vPiDevHXf/O6RxSpmblEhSvaxpONSRS9rcwcdM91bcr6H/67U50wNeDZp5faOcgNagjiyREMA1roTHuZmSM6uuAYfAMZ5RItHtEs6jO4FWyCZdMs/EIUzqDhdq4ZtpSbZsvTEdOt1GoDhqtogaTRilMx2A6SNu8zulapqqWDszCy293YZO8mrf+2DFjPhCm+fHqaI4YYFEbGkUjAW/vRwQZS3GoJyTUelZH9ZIltApo/np5rl0rtnc3t9P/C3cf6y2/1I1NazXQvfntpj6G8MB2aL1gQQSdz8Bpd+k6l3f1ClY8uvP1zkR1R+NejSpgSM+FNWf9tNYCRpE2XJrXJAQS4aGU6/OE/0l3feJc9ns3rqJLieFjVSmNCDNVxKrSd0U4mY/QRrTzVosRpkenC6AVaPv0NHTzwkIpvfsAasukosp7DK3EewDBG3pmmhLxggp9Heo7vGWluzMD1HBkx0DbDr6ZjG7L+Lz18aiL2stecD4PtTM3K7sZYDx/oM/pR3V3/hwbb8fTDXN79Y8f60NcPNF9iZaQ7DuoUmZ16jFVI0RRmhjdI0DY6HDhd/o5Xkq+G92C4cza2XN8Og77EfQPDvcy67emUvgOlNWhevEA7+YXoimMeUFaqlk7AGIyKYr5J6//s6RrwstecC6Q+NBIpoG68cXG7cQK/z2oixiYQXIxWZAHBQGYGPrIkStjtbrSyR9mU4X4m31Q6uhyVTvg/tNWyilubME5hBKiwpvjYeU9jbcGmYj83nxFTsRX+r3qMyRE2dtzUsYHblPXfDkGvuzcQTD4khXA6dto9Q7da6NfqQ/3bvNDXirbNiuHq+PoJGM81Vwr3ceWplnW0lF83bSXxjpjjy7WUwjijbMxsgW7XHBiLYHT36BJ3zaTWY5TzOPRB4+f3OQg2CLJ7DVBLsbnTpHmbJaCebtL6H/vEKQi6/9XnIO+mtyAEO5gQ94fZwIMUd1aYcbfh66cApkViLgWCv6zqeEMdfUIFg4Eq1kqLoJLblBI2joxBcogdNNx+OeN1pP17gDiaNmwuTg2wM8UdgXUx2kpoxkypNSmCU58aRWU+gNyxSet/5OOnpIh1H8CIsdN3yhwz2zgSRCrAMW0+nFUhno9wIsSKnGVBk7G0tctWcFckJihpaYF3RiWzxClZuaWNufAYw21FB7yaHwA5aESdVJef8rZ5bLR1v9zAV8Us6A9TjQ5rO/Wja7V27o7DGa5NWf8/fuxUH/Dgm18YwOZ2T7r4VKXhVh6bnZWtDzgg5aGJqGnoPVDFziCyoGuXS5OIsRuyDXg8TczLEdNqM0nR3RLI+ZQOOQ5v+AqTMjYTlQnLIoprVTr1B9F/xAVUUXBtqN+OdsbrckQXu+TmrP+Jz5weyLzhfBjuMuuN7gKCiuOBs7l9kOrkKq7pXEeXF+rvtpS4WCyno+hggxZi4KJZYiz5ywcDfeSZkWXCWpHD+IuWvxg3WixltzqZvWQBvXUGRVBhTvf+OepGhBybDRRO42ukI6Je0NZ+GkXAEK5D0yat/z+fvHi7PX3dHLEB1TzaTNgACmGxuh8YLr6cBG2fibIEOhHuBm6mW0zwBUmdLfqBxqADCsk/T3+j0r0vyW2jmHiRFdhWgDv2iBPNhv/Fez6st7/3bWp8o94wj3ddughLNGYTPJ6Yd89wH3Mc/N98rTPiTl//175yaiJGDaDQcQEd3CWJFM1Xs5yXjB9TkxLwh37woT/Xrz/0drUHTuUkqOhj1G3MgogVPW0xzgy69FSkpZ1hYjoOp5uiqgYbfK1lKZ17EYFmvuzVanY116G2d3PN59wxuZqSBawumW06zR4KqhXkYjU6BfY2ZP2fPzUP5nM4RpIMWrgdiRN5fLWyYXzAXLsy3AIFa72e0w42u5BYFviksQAt7MRyp6VT0Yt3tkMVt3dSTad4eJz1Ge1eqsG20//+d6n20EWfUBr1IHQhLjphGrX5rNHbt2f6qO9HDxG9BbI4e7xKZDJkE9Z/ehS5zl734FvuC6Qz0IHvh0ZouF2Y8smpU0gNknA3W3DmDEu4cToztmLzgHFlVBB3M6OXI1RSszhGoy4q5lq3b3dhvdhOahv6A3OAETYXlwS12wSYTre23gRZ5MK3SruvrI8wOPF2SyuTu8/+za2M4hZM2pAH7uWvOx+wh8xp7fHprKyHw/2Iw3anSyOTGkoG9Dif6cISr26XoXtsquiE9+7iPoNVMWd4TlGHydxSduIkDbvhgjkBg6A0ft06uBE1yEB3AJNqbEA/Pq6sT7ArOH3pc8+Pv7TDIIjbPMFw4+VJLHzc+4v0bPIySiVBTyM80CeAu9zMbTaS1V/yAGPhJg0yp2SgYp6doN0zhZbcVwxlj97beJcLN+0F7jGIKur6Z2QZ9kizuecr58Wi0bMXKuukn/wed51vyKG/ZZmOIhx5dvzrZQgGqqjdD4BgRtxTJAIaguhkwFxFsA1esBGuGAnshDOKrdAvmGpSC5LVVCyyGgt86W3qhVuCb0JH7a+zMQ3IaX4S+xDeH3Gwy3waEPRej/z98+Pkr3fh/wAwjitsSv4ZrwAAAABJRU5ErkJggg=="
    },
    "forest": {
      "title": "Forest",
      "image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAl0lEQVRoQ+3UsQ2AMBAEQVwOEX1QMH0QuRwQqWXk7NdvLTHSwY3uy3Huz5boua9aEn3u8FNLNoDvj1ZCSAmwEkJagFUQUgMMD+xEL/ydTQECkXoIAgQC9M6mAAIENwDHtWfIBQSDCBBceBsngABwA3C8CxAAbgCOdwECwA3A8S5AALgBON4FCAA3AMe7AAHgBuB4FzAZwAs/vWAZcNxDRQAAAABJRU5ErkJggg=="
    },
    "background": {
      "title": "background",
      "image": ""
    }
  },
  "abilities": {
    "ArenaPresenceAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ArenaPresenceAbility.js",
      "fileName": "ArenaPresenceAbility"
    },
    "BloodlustAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BloodlustAbility.js",
      "fileName": "BloodlustAbility"
    },
    "ChargeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChargeAbility.js",
      "fileName": "ChargeAbility"
    },
    "ConsecrationAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ConsecrationAbility.js",
      "fileName": "ConsecrationAbility"
    },
    "MultiShotAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MultiShotAbility.js",
      "fileName": "MultiShotAbility"
    },
    "BuildAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BuildAbility.js",
      "fileName": "BuildAbility"
    },
    "FreezingAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FreezingAuraAbility.js",
      "fileName": "FreezingAuraAbility"
    },
    "InfernoAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/InfernoAbility.js",
      "fileName": "InfernoAbility"
    },
    "MirrorImagesAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MirrorImagesAbility.js",
      "fileName": "MirrorImagesAbility"
    },
    "DisruptionBombAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DisruptionBombAbility.js",
      "fileName": "DisruptionBombAbility"
    },
    "DrainLifeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/DrainLifeAbility.js",
      "fileName": "DrainLifeAbility"
    },
    "ExplosiveTrapAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ExplosiveTrapAbility.js",
      "fileName": "ExplosiveTrapAbility"
    },
    "ShadowStrikeAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShadowStrikeAbility.js",
      "fileName": "ShadowStrikeAbility"
    },
    "ShieldWallAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ShieldWallAbility.js",
      "fileName": "ShieldWallAbility"
    },
    "SmiteAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SmiteAbility.js",
      "fileName": "SmiteAbility"
    },
    "MindControlAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MindControlAbility.js",
      "fileName": "MindControlAbility"
    },
    "WindShieldAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/WindShieldAbility.js",
      "fileName": "WindShieldAbility"
    },
    "CorruptingAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CorruptingAuraAbility.js",
      "fileName": "CorruptingAuraAbility"
    },
    "EnchantWeaponAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/EnchantWeaponAbility.js",
      "fileName": "EnchantWeaponAbility"
    },
    "PhalanxFormationAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PhalanxFormationAbility.js",
      "fileName": "PhalanxFormationAbility"
    },
    "BurningAuraAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BurningAuraAbility.js",
      "fileName": "BurningAuraAbility"
    },
    "TrackingMark": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/TrackingMark.js",
      "fileName": "TrackingMark"
    },
    "IceShardAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/IceShardAbility.js",
      "fileName": "IceShardAbility"
    },
    "MineGoldAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MineGoldAbility.js",
      "fileName": "MineGoldAbility"
    },
    "CurseAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/CurseAbility.js",
      "fileName": "CurseAbility"
    },
    "BlizzardAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BlizzardAbility.js",
      "fileName": "BlizzardAbility"
    },
    "SummonWolfAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/SummonWolfAbility.js",
      "fileName": "SummonWolfAbility"
    },
    "PiercingShotAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/PiercingShotAbility.js",
      "fileName": "PiercingShotAbility"
    },
    "Tornado": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/Tornado.js",
      "fileName": "Tornado"
    },
    "LightningBoltAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/LightningBoltAbility.js",
      "fileName": "LightningBoltAbility"
    },
    "RageAbility": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RageAbility.js",
      "fileName": "RageAbility"
    },
    "BattleCryAbility": {
      "fileName": "BattleCryAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BattleCryAbility.js"
    },
    "MeteorStrikeAbility": {
      "fileName": "MeteorStrikeAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MeteorStrikeAbility.js"
    },
    "FireStormAbility": {
      "fileName": "FireStormAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireStormAbility.js"
    },
    "RaiseDeadAbility": {
      "fileName": "RaiseDeadAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/RaiseDeadAbility.js"
    },
    "MassHealAbility": {
      "fileName": "MassHealAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/MassHealAbility.js"
    },
    "FireBallAbility": {
      "fileName": "FireBallAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/FireBallAbility.js"
    },
    "HealAbility": {
      "fileName": "HealAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/HealAbility.js"
    },
    "ChainLightningAbility": {
      "fileName": "ChainLightningAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/ChainLightningAbility.js"
    },
    "BaseAbility": {
      "fileName": "BaseAbility",
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/abilities/js/BaseAbility.js"
    }
  },
  "functions": {
    "calculateDamage": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateDamage.js",
      "fileName": "calculateDamage"
    },
    "calculateStats": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/functions/js/calculateStats.js",
      "fileName": "calculateStats"
    }
  },
  "managers": {
    "InputManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/InputManager.js",
      "fileName": "InputManager"
    },
    "AutoBattleMultiplayerManager": {
      "fileName": "AutoBattleMultiplayerManager"
    },
    "GameModeManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameModeManager.js",
      "fileName": "GameModeManager"
    },
    "KeyboardManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/KeyboardManager.js",
      "fileName": "KeyboardManager"
    },
    "ResultsManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ResultsManager.js",
      "fileName": "ResultsManager"
    },
    "GameManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/GameManager.js",
      "fileName": "GameManager"
    },
    "ComponentManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ComponentManager.js",
      "fileName": "ComponentManager"
    },
    "MultiplayerNetworkManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/MultiplayerNetworkManager.js",
      "fileName": "MultiplayerNetworkManager"
    },
    "SaveManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SaveManager.js",
      "fileName": "SaveManager"
    },
    "LoadingManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/LoadingManager.js",
      "fileName": "LoadingManager"
    },
    "ScreenManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/ScreenManager.js",
      "fileName": "ScreenManager"
    },
    "SquadManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/SquadManager.js",
      "fileName": "SquadManager"
    },
    "UnitCreationManager": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/managers/js/UnitCreationManager.js",
      "fileName": "UnitCreationManager"
    }
  },
  "systems": {
    "AnimationSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AnimationSystem.js",
      "fileName": "AnimationSystem"
    },
    "AISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AISystem.js",
      "fileName": "AISystem"
    },
    "ArmyDisplaySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ArmyDisplaySystem.js",
      "fileName": "ArmyDisplaySystem"
    },
    "DamageSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageSystem.js",
      "fileName": "DamageSystem"
    },
    "CameraControlSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CameraControlSystem.js",
      "fileName": "CameraControlSystem"
    },
    "EquipmentSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EquipmentSystem.js",
      "fileName": "EquipmentSystem"
    },
    "CombatAISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CombatAISystem.js",
      "fileName": "CombatAISystem"
    },
    "GoldMineSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GoldMineSystem.js",
      "fileName": "GoldMineSystem"
    },
    "DeathSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DeathSystem.js",
      "fileName": "DeathSystem"
    },
    "MiniMapSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MiniMapSystem.js",
      "fileName": "MiniMapSystem"
    },
    "FogOfWarSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/FogOfWarSystem.js",
      "fileName": "FogOfWarSystem"
    },
    "ServerPlacementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerPlacementSystem.js",
      "fileName": "ServerPlacementSystem"
    },
    "PathfindingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PathfindingSystem.js",
      "fileName": "PathfindingSystem"
    },
    "RenderSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/RenderSystem.js",
      "fileName": "RenderSystem"
    },
    "HealthBarSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/HealthBarSystem.js",
      "fileName": "HealthBarSystem"
    },
    "MovementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MovementSystem.js",
      "fileName": "MovementSystem"
    },
    "ServerBattlePhaseSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ServerBattlePhaseSystem.js",
      "fileName": "ServerBattlePhaseSystem"
    },
    "StatisticsTrackingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/StatisticsTrackingSystem.js",
      "fileName": "StatisticsTrackingSystem"
    },
    "TerrainSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TerrainSystem.js",
      "fileName": "TerrainSystem"
    },
    "DamageNumberSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/DamageNumberSystem.js",
      "fileName": "DamageNumberSystem"
    },
    "UnitOrderSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitOrderSystem.js",
      "fileName": "UnitOrderSystem"
    },
    "UnitRadiusSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UnitRadiusSystem.js",
      "fileName": "UnitRadiusSystem"
    },
    "VisionSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/VisionSystem.js",
      "fileName": "VisionSystem"
    },
    "MultiplayerPlacementSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerPlacementSystem.js",
      "fileName": "MultiplayerPlacementSystem"
    },
    "SquadExperienceSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SquadExperienceSystem.js",
      "fileName": "SquadExperienceSystem"
    },
    "TeamHealthSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/TeamHealthSystem.js",
      "fileName": "TeamHealthSystem"
    },
    "UISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/UISystem.js",
      "fileName": "UISystem"
    },
    "GridSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/GridSystem.js",
      "fileName": "GridSystem"
    },
    "SchedulingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SchedulingSystem.js",
      "fileName": "SchedulingSystem"
    },
    "AbilitySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/AbilitySystem.js",
      "fileName": "AbilitySystem"
    },
    "SupplySystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SupplySystem.js",
      "fileName": "SupplySystem"
    },
    "EffectsSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/EffectsSystem.js",
      "fileName": "EffectsSystem"
    },
    "ProjectileSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ProjectileSystem.js",
      "fileName": "ProjectileSystem"
    },
    "MultiplayerUISystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/MultiplayerUISystem.js",
      "fileName": "MultiplayerUISystem"
    },
    "PostProcessingSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/PostProcessingSystem.js",
      "fileName": "PostProcessingSystem"
    },
    "CommandQueueSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/CommandQueueSystem.js",
      "fileName": "CommandQueueSystem"
    },
    "ShopSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ShopSystem.js",
      "fileName": "ShopSystem"
    },
    "SelectedUnitSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/SelectedUnitSystem.js",
      "fileName": "SelectedUnitSystem"
    },
    "LifetimeSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/LifetimeSystem.js",
      "fileName": "LifetimeSystem"
    },
    "WorldSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/WorldSystem.js",
      "fileName": "WorldSystem"
    },
    "ParticleSystem": {
      "filePath": "/projects/TurnBasedWarfare/scripts/Scripts/systems/js/ParticleSystem.js",
      "fileName": "ParticleSystem"
    }
  },
  "configs": {
    "codeMirror": {
      "title": "Code Mirror",
      "theme": "codeMirrorTheme",
      "fileName": "codeMirror"
    },
    "editor": {
      "title": "Editor Config",
      "editorCategories": "",
      "theme": "claude2",
      "editorModules": [
        "terrainModule",
        "sceneModule",
        "graphicsModule",
        "scriptModule",
        "aiPromptModule",
        "audioModule",
        "exportScriptModule",
        "textureEditor",
        "compilerModule"
      ],
      "path": "/",
      "fileName": "editor"
    },
    "ai": {
      "title": "AI",
      "aiEndPoint": "http://localhost:11434/api/generate",
      "aiModel": "",
      "defaultPrompt": "I am developing a tower defense game featuring a simple 3d art style.  Generate a new object based on the following context.    Please provide ONLY a valid JSON object with keys MATCHING EXACTLY to the context above. It absolutely MUST have an appropriate 'id' field. Ensure all existing key types are maintained. Do not wrap the json object with any other text.",
      "fileName": "ai"
    },
    "multiplayer": {
      "title": "Multiplayer",
      "serverUrl": "http://localhost:3000",
      "maxReconnectAttempts": 5,
      "reconnectDelay": 3000,
      "enabled": true
    },
    "server": {
      "title": "Server Game",
      "projectName": "TurnBasedWarfare",
      "tickRate": 20,
      "seed": "auto",
      "appLoaderLibrary": "ServerGameLoader",
      "appLibrary": "ServerECSGame",
      "initialScene": "server",
      "libraries": [
        "BaseSystem",
        "GameRoom",
        "ServerGameRoom",
        "GameState",
        "BaseECSGame",
        "GameUtils",
        "ServerECSGame",
        "ServerEventManager",
        "ServerNetworkManager",
        "ServerSceneManager",
        "SeededRandom",
        "MinHeap",
        "DesyncDebugger"
      ]
    },
    "game": {
      "gridSize": 48,
      "imageSize": 128,
      "title": "Turn Based Warfare",
      "isIsometric": false,
      "libraries": [
        "threejs",
        "BaseECSGame",
        "Rapier",
        "three_MeshBVH",
        "three_SkeletonUtils",
        "SceneManager",
        "ShapeFactory",
        "ImageManager",
        "SpatialGrid",
        "CoordinateTranslator",
        "CanvasUtility",
        "TerrainImageProcessor",
        "TileMap",
        "Entity",
        "Component",
        "GameState",
        "ModelManager",
        "three_OrbitControls",
        "GLTFLoader",
        "ECSGame",
        "three_EffectComposer",
        "three_RenderPixelatedPass",
        "three_OutputPass",
        "GameModeConfigs",
        "UIComponents",
        "NotificationSystem",
        "GameLoader",
        "GameUtils",
        "PlacementPreview",
        "EnemyStrategy",
        "MultiplayerECSGame",
        "ClientNetworkManager",
        "socket.io.min.js",
        "BaseSystem",
        "SeededRandom",
        "DesyncDebugger",
        "FantasyUIEnhancements",
        "MinHeap",
        "PerformanceProfiler"
      ],
      "fileName": "game",
      "interface": "main",
      "appLibrary": "MultiplayerECSGame",
      "canvasWidth": 1600,
      "canvasHeight": 1600,
      "is3D": true,
      "palette": "main",
      "appLoaderLibrary": "GameLoader",
      "initialScene": "client"
    },
    "state": {
      "level": "level1",
      "mousePosition": "{ x: 0, y: 0, isoX: 0, isoY: 0, gridX: 0, gridY: 0 }",
      "isPaused": false,
      "isLevelingUp": false,
      "timeScale": 1,
      "gameOver": false,
      "victory": false,
      "modifierSet": "global",
      "fileName": "state",
      "population": 0,
      "phase": "placement",
      "round": 1,
      "playerGold": 100,
      "playerReady": false,
      "phaseTimeLeft": 30,
      "selectedUnitType": "",
      "teamMaxHealth": 2500,
      "startingGold": 100
    }
  },
  "inputDataTypes": {
    "string": {
      "title": "String"
    },
    "json": {
      "title": "JSON"
    }
  },
  "inputElementTypes": {
    "textarea": {
      "title": "Text Area",
      "tag": "textarea"
    },
    "text": {
      "title": "text",
      "tag": "input"
    }
  },
  "levels": {
    "level3": {
      "title": "Level 3",
      "tileMap": {
        "size": 128,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "forest",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [],
        "extensionTerrainType": 3,
        "ramps": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    },
    "level32": {
      "title": "Level 32x32",
      "tileMap": {
        "size": 32,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "water",
              "grass",
              "forest"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "grass",
              "water",
              "forest"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "forest",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "forest",
              "grass",
              "water"
            ],
            "buildable": true
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "cliff",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": false
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "walkableNeighbors": [
              "rock"
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            7,
            7,
            7,
            7,
            7,
            7
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            7,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 707,
            "y": 23.21875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 932,
            "y": 24.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 645,
            "y": 291.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 846,
            "y": 282.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 838,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 904,
            "y": 102.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 654,
            "y": 213.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 702,
            "y": 81.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 475,
            "y": 168.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 585,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 387,
            "y": 343.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 387,
            "y": 342.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 162,
            "y": 362.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 56,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 55,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 14,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -7,
            "y": 343.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -7,
            "y": 344.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 350,
            "y": 98.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 549,
            "y": 137.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 468,
            "y": 388.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 283.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 375,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 533,
            "y": 72.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 126,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 399,
            "y": 125.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 601,
            "y": 80.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 577,
            "y": 215.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 432,
            "y": 274.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 54,
            "y": 190.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 416,
            "y": 61.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 205,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 996,
            "y": 222.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 884,
            "y": 346.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 992,
            "y": 355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1095,
            "y": 351.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1234,
            "y": 320.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 941,
            "y": 281.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1020,
            "y": 149.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1094,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1442,
            "y": 334.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 315.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 314.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1193,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1020,
            "y": 244.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 919,
            "y": 230.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 963,
            "y": 109.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1043,
            "y": 66.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1313,
            "y": 78.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1519,
            "y": 55.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1518,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1517,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1431,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1074,
            "y": 180.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1074,
            "y": 179.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1136,
            "y": 286.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1056,
            "y": 333.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1127,
            "y": 119.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1114,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1233,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1423,
            "y": 67.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1469,
            "y": 248.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1551,
            "y": 331.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1182,
            "y": 326.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1229,
            "y": 177.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1134,
            "y": 220.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1168,
            "y": 72.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1538,
            "y": 263.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1490,
            "y": 110.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 940,
            "y": 182.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1351,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1547.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1546.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 701,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 700,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 746,
            "y": 1393.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1424.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1423.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 946,
            "y": 1544.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 945,
            "y": 1544.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1008,
            "y": 1407.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 957,
            "y": 1238.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 956,
            "y": 1236.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 903,
            "y": 1145.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 730,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 1200.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 631,
            "y": 1192.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 644,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 643,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 617,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 615,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 454,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 453,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 148,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 147,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1535.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1536.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -6,
            "y": 1371.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 61,
            "y": 1355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 33,
            "y": 1470.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 232,
            "y": 1450.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1448.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 576,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 374,
            "y": 1297.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 1223.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 70,
            "y": 1226.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1211.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1210.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 656,
            "y": 1266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 504,
            "y": 1332.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 304,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 292,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 291,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 125,
            "y": 1398.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 406,
            "y": 1357.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 1324.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1029,
            "y": 1525.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1029,
            "y": 1524.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1338,
            "y": 1524.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1516,
            "y": 1350.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1482,
            "y": 1175.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 998,
            "y": 1147.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1055,
            "y": 1271.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1093,
            "y": 1394.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1145,
            "y": 1498.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1145,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1221,
            "y": 1529.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1179,
            "y": 1321.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1106,
            "y": 1197.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1205,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1493,
            "y": 1242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1214,
            "y": 1202.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1077,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1076,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 356,
            "y": 1191.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 160,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 6,
            "y": 1150.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 418,
            "y": 1231.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 646,
            "y": 1126.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1214,
            "y": 1272.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1398,
            "y": 1146.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 214,
            "y": 1128.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 1499.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 476,
            "y": 1416.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1201,
            "y": 1447.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 1458.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1093,
            "y": 1338.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 669,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 668,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 352,
            "y": 1487.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 180,
            "y": 1517.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": 1399.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 72,
            "y": 1528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 94,
            "y": 264.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 341,
            "y": 251.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 88,
            "y": 358.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 494,
            "y": 258.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 619,
            "y": 136.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 679,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 689,
            "y": 223.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 667,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 603,
            "y": 386.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 589,
            "y": 482.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 717,
            "y": 528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 744,
            "y": 385.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 782,
            "y": 226.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 861,
            "y": 58.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 818,
            "y": 134.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 652,
            "y": 596.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 641,
            "y": 662.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 681,
            "y": 835.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 806.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 805.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 799,
            "y": 919.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 752,
            "y": 1122.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 780,
            "y": 1324.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 920,
            "y": 1335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 862,
            "y": 1408.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 747,
            "y": 1497.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 867,
            "y": 1539.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 843,
            "y": 1293.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 876,
            "y": 1206.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 827,
            "y": 1078.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 714,
            "y": 994.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 797,
            "y": 881.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 739,
            "y": 740.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 726,
            "y": 926.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 799,
            "y": 1066.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 832,
            "y": 1270.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 945,
            "y": 1317.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 784,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 865,
            "y": 1533.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 723,
            "y": 671.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 723,
            "y": 670.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 604,
            "y": 468.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 686,
            "y": 483.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 711,
            "y": 306.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 805,
            "y": 94.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 148.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 719,
            "y": 637.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 1250.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 752,
            "y": 1468.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 904,
            "y": 1502.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 762,
            "y": 1222.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 786,
            "y": 1009.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 800,
            "y": 853.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 687,
            "y": 791.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 673,
            "y": 421.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 600,
            "y": 575.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 51.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 50.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 883,
            "y": 67.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1110.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1109.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 102,
            "y": 1414.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 521,
            "y": 1466.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1328,
            "y": 1511.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1049,
            "y": 1315.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1091,
            "y": 1499.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 120,
            "y": 1224.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 597,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 345,
            "y": 1532.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 549,
            "y": 1278.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1234,
            "y": 272.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1117,
            "y": 137.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 944,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 1409,
            "y": 305.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 998,
            "y": 301.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 195,
            "y": 323.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 318,
            "y": 98.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 501,
            "y": 84.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1227,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1175,
            "y": 278.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1176,
            "y": 276.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1118,
            "y": 1459.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1537.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1536.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1528,
            "y": 1435.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1144,
            "y": 1260.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 173,
            "y": 1351.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 132,
            "y": 1482.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 672,
            "y": 1062.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 711,
            "y": 837.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 682,
            "y": 689.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 757,
            "y": 583.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 758,
            "y": 583.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 758,
            "y": 711.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 855,
            "y": 1084.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 93,
            "y": 971.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 347,
            "y": 685.8125
          },
          {
            "type": "rock",
            "imageIndex": 6,
            "x": 550,
            "y": 925.8125
          },
          {
            "type": "rock",
            "imageIndex": 6,
            "x": 550,
            "y": 924.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1239,
            "y": 935.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 1194,
            "y": 642.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 915,
            "y": 633.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 1369,
            "y": 486.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 98,
            "y": 534.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 683.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 682.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 408,
            "y": 602.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1298,
            "y": 915.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 347,
            "y": 820.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1206,
            "y": 514.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 451,
            "y": 1038.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 450,
            "y": 1037.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 86,
            "y": 612.8125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 1440,
            "y": 1440
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 96,
            "y": 96
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 144,
            "y": 1296
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 1392,
            "y": 144
          }
        ],
        "extensionTerrainType": 3,
        "ramps": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    },
    "level2": {
      "title": "Level 2",
      "wavesets": [
        "swarm",
        "swarm",
        "swarm"
      ],
      "tileMap": {
        "size": 32,
        "terrainTypes": [
          {
            "type": "water",
            "color": "#2d85c6",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2PUbT32n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABAAWoO0FhcUvnAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "rock",
            "color": "#9e9e9e",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAECFSQ0HGbi8AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAgnnz5v2nZTAxjlpAKHhHg4hQCDGMBtFoEBEMAYIKRlPRaBARDAGCCmieigCFBDkNArgMlAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAgnnz5v2nRjAlJSVhDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAOcCUBnjhUZTAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEAIf9RHEX0vjVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDB0E5FSUlJjDTzAchwUPjRxAKY4TSxANlwkAUAUEhJDYCk3yoAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2OcN2/efwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFAB7VMRQSdQqICRQv0EtQ99CwDb3jkNHe23xQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2OcN2/efwYqgqSkJEZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAC4oUBlpvrH3AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "color": "#4a7c59",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P0qon8z0AlsK1lOSO6UYxDygKQ69F9QVUfwIIH2RKaWIDsE5pZAPPNqAUEc9BoEI0GEcEQIKhgNBWNBhHBECCoYDQVEQwiAA75PFN7PN69AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCAB4BShTjqMEpwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRq+ayP8EVRFQsK1lOc6gpooFIPtxWUI1C3BZMmoBSvRji4fRIBoNItIKkdFURDC8RoNocAYRADzPTBkQkiUcAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAnCQy6fQdcSIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSra1rKcEWQ7TSyAGU4TC5ANp7oF6IbTxQIARN88U7u38m0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P0qon8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQCyWyhTURksDgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P0qon8z0AlsK1lOSO6UYyjFiAHyWgQEUxro0E0GkQEQ4CggtFUNMyDCFsEg7xMlQoHl+FgCwgGLIUKRi0gGIA0DyIAQT9MGVwsaTUAAAAASUVORK5CYII="
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "color": "#1c6438",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2OUSbH4z0Al8GTOCUZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAIHMNK76+kj9AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVVGgYNQCgoE3GkSjQUQwBAgqGE1Fo0FEMAQIKhhNRQSDCACNcyCuKmmRrQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhRpkUi/8EVRFQ8GTOCZxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAPx6TBmX9XIXAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgA71YpQQB/w8QAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgWSp6MucEI8h2mlgAM5wmFiAbTnUL0A2niwUAO0c0rkd3ClIAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2OUSbH4z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCpgJKiCQgWjFhAMQJoHEQBLXiCu2Bx7HwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2OUSbH4z0Al8GTOCUZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAAPlMGX+pQM0AAAAASUVORK5CYII="
            ],
            "buildable": true
          },
          {
            "type": "path",
            "color": "#f5d69a",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATklEQVRIS2P8em3WfwYqAW6tNEZ0oxiHlAUg16P7gqo+gAUPsiU0sQDZJzSzAOabUQsI5qDRIBoNIoIhQFDBaCoaDSKCIUBQwWgqIhhEAJvSVIWbYGLaAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIoCBaMWEAy80SAaDSKCIUBQwWgqGg0igiFAUMFoKiIYRAACV0CFxNTeCQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2NkoDFgpLH5DKMWEAxhxq/XZv0nqIqAAm6tNJxBTRULQPbjsoRqFuCyZNQClOjHFg+jQTQaRKQVIqOpiGB4jQbR4AwiAFzITBnELKoVAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEADJ7UXnV1RQ5AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABzVIRt1YaI8h2mlgAM5wmFiAbTnUL0A2niwUAqyRUhRUUb34AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2P8em3WfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFABI0EVFCoYtYBgANI8iAAWGUCFGtCTSgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P8em3WfwYqAW6tNEZ0oxhHLUAOktEgIpjWRoNoNIgIhgBBBaOpaJgHEbYIBnmZKhUOLsPBFhAMWAoVjFpAMABpHkQAYThMGX3v4DMAAAAASUVORK5CYII="
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "color": "#cc6315",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2M8kyz6n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABABafNmFbBL82AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "end",
            "color": "#ff9999",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2P8P3PmfwYaAsZRCwiF7mgQEQohhtEgGg0igiFAUMFoKhoNIoIhQFDBaCoaAUEEACT6TJlEjUJmAAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "start",
            "color": "#ffff80",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQd3czXGEr6x8ahKSC51M6jDtAOlKREIlkUQogAVfJBEKYMEXPSBaS5xT0QJZxg4AAAAASUVORK5CYII="
            ],
            "buildable": false
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            0,
            3,
            2,
            4,
            2,
            2,
            4,
            2,
            3,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            4,
            2,
            2,
            4,
            2,
            3,
            2,
            2,
            1,
            1,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            3,
            3,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            4,
            2,
            3,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            6,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            7
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            3,
            3,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            5,
            5,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            0,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            7,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": "#467554",
        "environmentObjects": [],
        "ramps": []
      },
      "world": "shire"
    },
    "level1": {
      "title": "Level 1",
      "tileMap": {
        "size": 64,
        "terrainTypes": [
          {
            "type": "water",
            "texture": "water",
            "color": "#0288d1",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYzUtgBkOLIlNLEA2RKaWQCzhKYWgCwZtYBgAh8NotEgIhgCBBWMpqLRICIYAgQVjKaigQ8iAB3DPyFhLWYbAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAqaOi/9pGUyMoxYQCt7RICIUQgyjQTQaRARDgKCC0VQ0GkQEQ4CgApqnIgAM+S8hyaxkaAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAqaOi/+pEUz/KvSxhgYjtSwAORKbJVS1AJsloxZgpA/0eBgNotEgIr0QGU1FBMNsNIhGYBABANMJUBkDDfPEAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwmopGQBABACTJOInljIZYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFPRvwp9Rpr5AGQ4KPxoYgHMcJpYgGw4yAIAIvU/Ia+PZCwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2Nk6rj4n4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgBZQi8hVlOfqgAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2Nk6rj4n4GK4F+FPiOycYyjFqCH7mgQEUxvo0E0GkQEQ4CggtFUNBpEBEMArwL0FARSTLUaDZvhYAsoczNh3aMWEAwjABovUBkJTyamAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "water",
              "grass",
              "forest"
            ],
            "buildable": false
          },
          {
            "type": "lava",
            "texture": "lava",
            "color": "#ff8c00",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2P838Pwn4GKgLGEgRHZOEZqWwAyHNkSmliAbAnNLIBZQlMLwJbQIg5oHsmjFpCULUcjmWBwjQbRaBARDAGCCkZT0QgIIgCvLT7h9ff/qwAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPElEQVRIS+3SsQkAMAwDQXn/7OyM8JUa866FBYcm5Zvy/xwo2JdtMo0FxCsRCUUiiVAAA65IIhTAQH1FHxXSMuGNrO/rAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAARklEQVRIS2NkoDFgpLH5DMPAgv89DP+pEUyMJdhDg5FaFoAcic0SqlqAzZJRCzDSB3o8jAbRaBCRXoiMpiKCYTYaRCMwiADWkTwZ+w+X6QAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS+3SsQ0AAAgCQdzfnXWEr6x8ahKSCzWdyWHKAdKViIQikUQogAVfJBEKYMEXPSBamJQ9CXgfObkAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFQwtFMRYwkDI818ADIcFH40sQBmOE0sQDYcZAEAtXs+4XbNSVcAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2P838Pwn4GGgHHUAkKhOxpEhEKIYTSIRoOIYAgQVDCaikaDiGAIEFRA+1RE0AkUKmCkUD9B7UPfAgARdTLhxToLvQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2P838Pwn4GKgLGEgRHZOMZRC9BDdzSICKa30SAaDSKCIUBQwWgqGg0igiGAVwF6CgIpplqNhs1wsAWUuZmw7lELCIYRAMvmPBmZFN13AAAAAElFTkSuQmCC"
            ],
            "buildable": false
          },
          {
            "type": "grass",
            "texture": "grass",
            "color": "#5a8a4f",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABTRJREFUSEtdljuPZEcVx3+nqu7t7ts9PT2e2cXeGWAd8QFICHiusUBe0NogAmOJhJgIkYAIEIEhJCMmISYkJ0J8AkIE2Luznpmeft1HVR106u7sriippb63q+qc+r+q5Ts/+rz2rXLYZuYrh2aYLQIC9F0mDgoozSKw30UQx9AmqonQzMd3s7nnsEvl2Ya9C97hvSCPnlxoSsp+rdhWy1NXFthDe1DUKr4YjW20j6gKk9rT9eOmpfBr4+5df1Dk6++da7YCG3jr7ZrDi8nbm8x+q0xnVtS/XJ6jsLlJVDWc3K/oDoly3P8b7S4jIsg3v39RCjTHgX7/arIVOGwTJ/cCLoAPkAYItaNvM0eriu1zoT5K1FP3sjHr/vnTnqNloN0m5PGPH5YCm5vI6VuhdDdtHO0+l493Qs5Q1YJB2Sw87T6REyxWgThkJlNfYLLNr5/1pVkdlATIOx9cqCBkVXY3mXvnFbttYjbz7DaJHDNh4rm+jKxOPfICjpy1FDaKVBUfhFALBk13yDRHHjVNfPXdc63nwtXTxGIprM5qrp71vL/o+SsT9muoa1fUFCbCYuURr4Xs1AmzxrO9jUUxtzeJUAn1xBEqiJ0i3/vooV5dxoK/IkwbygRTlPOwubJFjnoCvhZO3wxc/icWlVnnBu9k5ssak2o9FapJ4F//bPncRRgLbNepqCG2yhsPajSbLxKHLYXgk/uedpdwxodqgcWGnWholWoqxF6ZLzwx2QmkcGPFSwEjKPUO55VkkpbReNOpcHwWCheGsRTCU/GBjTu9V5UwXzqunka6Vrn3oAIVNtcRefT+hVaVY/1ZYjIdYVideZ7/NzKdBSQo3T6XU1UTj/fK0CtnDwLPPxmV0ywZvy8qNtfDSLiZ2nzw+MOHensTmTWuwPQ6DL4SUjQ2xhGjFgmbkkxBo6LsdyleGDozF6QkNE0gp4R87bvnenxasTMlvAZDzlImq0K0yBDD2mSqhdCbt3+O/OP3pdMwcUVNdsphyEwnVVlncMo7H5yrqeSw1bLYYHBuhGG2cBw2eSQ2STHbZO4w3+xvEynZMZT5MjD0ueSTC479NpJ7pWvzGBWmXZtgVfvO8ke4vVJW9xzTxrO7zviJlODbrc2Mo9LMbJa4CzNVsavw7JMO7zxOTGoO+cbjc53NQ8kS713B2lC1rmOXqWcWz1pkaAKwKSbPzz5NnL45huDyxHP574HmyNF35h/BmdKcG1V0l+dpMJIc7SHjPfz6Z7/k4z9+XLix7LH3zlkujYTaw9EKhn50rb23j52q21HcLN96cqFGphnKDGcIG9aL44rtesCUNJkFukNkv840xw6Njv1hYHValeDzQYnDuM4ayEn46PFP+Mvf/vzKaM4k2Sr11JfUTDkzn49Ss4vnLvNN99t1pO9zUVOOOhpQTV0GmHnA8Yuf/oo//Ol3yHsfflFbuzRM553RBOLNWHBzmfjSl6ds15mUDAqLTsp1aak5DMpvvrLht38/KnCFGuaLit1mGON8Kci7P/yCGnmdhV1SnHfsdwnJjpxHZd0F3PLMF6xjn2mWlrCUzElR8BUl6OzuNsHcxbp8+wcXanfnEBUnUrRvLk0H6IZEs/Ql3w3bYlxzcTLTuRITV59Ghpg4OvEvN7fIMTVZsXLh2IaYKALMmsDGMG4Vu+RjHB1pz3YXpF5KPpmKLOT61qIhkyMs3hhlXvqQMULk0ZNzLY7djZlji8zF1unhVjm+X7G9GY9s2BsJ+9vMrBE2a+X41BGC0HWWxJYEr/4BbK4z/wPLjQ+N1hSpygAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABW1JREFUSEtNlkuPXUcVhb96nNd9+Ha77YSE7tiBGb8gEx6Wk0g2scEIAhICBiDEnAFCQmISKZkgpkwYwC9gwJQoYsJ/YIQUyyF00933de55VNVGu46dUNJ9nVNn79prr7X2NW9/944MXcB6w4slAjEAIhgDKUFRPb8v064QBL1S1Za+SxjdiOGjv378eSC9cu9bp1I3juv/DOizy6OCYUj5YWv1DWZzzzhExnGK7vQwYvJ93ZuCkIIhjNDcgA//8vSzJObr75yKJhcRmplnfTmy0CRtpJ45QkhgpsBama5+B8YLEoXFkafbR8ZBqBd6omm9SGLuPToVDe6K6VTzhWd7NWIKQxgSEqFqHGNMxE4ylFUNXScZNq1+t4748vNKNcHmMvKPvz0z5v6TM0kjxCSUtaKowBm8d/n7dh2w1tB3EWMNRQHGWmKIpAj+Kz9B/vlnitpkKC/+PVDVLh/EIJivvv2auDKxvOmxBg77SFV6nId2H3LG7SXMl5YxJKrG0h8ikqbmD6OwWOq1xOrE8+nHA83CZvict5g3n9yVdjsSB3j1SxVC4vLTmGE/eaWk3Y2ZKd1BsMaie2ergnY9kkTwteWwjVQzg4wWrPbF0R0i1imLHp9pTEJMLG94isoxX8LVeaCZFzmBrsNGckBrHMZFmmVBUQrbTURiyhU0S8fxbcfVeczPKGTm4fdfzzpIkKlWVJZbr1iG1rDbjVw8Tbx0ZjNFF6uC7VVivxmw1jI/0oZrk1VHU0AljMKqUOcEb33nrmgp1qTMDAlCPbeIOFYnlsvzgcWsoB8CRenY7wKhg26I3Dh2WRNjJ2ATZenplAz/JzXz4N07AkKMwn4jWAzVEsYD1HPznFbTx2xRsL3WBImQhNVLHomG3VphFP741hU//+gkf9fVaAWPfvi6DEPkwfwGf//XBU/FsTi2VKXSrqDdTz2oa8+zpz2zxuMs9H2YYDt27K5TZs7YR4rSYtwktvnSYR68+1pOpxUgnrGDaqGHiJSFYwyRw06wxeRPR0cenOHQBqrKcfEs0KxgfR5Z3Z6UrNj3fSSqX33j4alo9qmkgt0mZp5XjWHsn1tEFMq5gpf97DPb0IZqT50ztLtEVdkcuJm73GRVurn/7TOxTmuK+dn03ElVpTPtATD2DldG6spzOIw5qL5WtzxDC7vc+JSRT1E4uqX0Vjs2mDcf35Fmbjmoz9hEiIJXv6lcxrNvI83Csd+O9N3kWUObMgHUQg4HVawQB2EcoJqbnLyZOdptxNz75pn4Wl3Z4QvDbhvyyV80WKFK0eZkm+uBZlbwxnbNh65hvigy768uAtZNTJSkhjnNiCwJbXI9L9iuB9q1UC0MdTUlUKGp52uHyllBHHUAKRCG/X7k5m2fqa3B1Le0B+o/WvUYhNVNh/nez74sMcL6v0N2R7XmfojUteH3v/0Tv/rgp1lMu81IXTu6XrFlsoZiiWs6DoeQrT4lYegSyyPP7jpw/HKBeecHd0WtWkWxvhwyI5x39F1gOEwsUV2EQTK/vTPElLKbjp3F1yn3TKeZ6mK58tniw5ioZxbz+Ed3RUSHi2RP8YXNw0MQysLSbiL1whO1zKxRyTxXy5ivHDIqXIGhE2Yzny1dYT3sYrYc8+jHZ9K3E+3260RVTprQ0xSNYaZsaNX/JSfOepmpwgfqxnPxycjNl8ts42GA5YnP8Ikhu4G5/+RUbr9acP5szAyQkIijzSdVh/z1L37D+394L9NTlVnWOukkN1Eb3m31T8DkoHqg3WXKPdM9OqPN1x5+UfSnjkMd8N3O4IrE4sjSNJ5fLh2/+2SgtdNflHYbsphyxRthdaLzgexHRTUZXLsZOf5CSbeL/A8UowBANo0cZAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABH5JREFUSEvdljmPHEUUx3+vqo+ZntnZtdfm8K7ARHwAEgIQh7GEMIgrAiQSYiJEAiJABIaQjJiEmJCcCPEJCBEI8MLuzs7R091V9dCrxhg+AAkttTRdU8d7/6tb+I8v+Y/3539wwK03r2uKyuo8cPhgweo8Mmkcu23Kt3dCSlBWQoxKM/fstpEUYX5QEIZEPfFsN4FmVnB2p6fZL9BBiYDcePVYBSGpsjlPXD0q2awj06lns4qkkChqz9lJ4ODQI3+BmpLmg9VuVXwhFJWw2yS6NtHseTSAPHHzSKuZcPpbZL4QDq5UnN7peWXe8w012yVUlSMMSlEL8wOPeKXdBmInTBvP+iLgvXBxHilKoaodRQmhU+TFt67r6Umg30YUYdKQJyjgPKxObZGjqsFXwuEDBSc/B2yCVW7w1lOf17SbSDURyrrgxx923H9cjAesl5GujYSdcvlahSalXUfaNbgCLt3n2W0izvhQzbDYZR0NO6WcCKFXZnNPiNaBZG7s8HyAERR7hy+V0Ftlie0m0Uwd+1eKzIVhLJnwiOpIhJFqa8tSmC0cp78Fup1y9VoJKqzOAvLsK8da1y6TWE9kxHnfc3YnMGmKjHe3TbmrsvZ4rwy9cuVawe+/jMppFoy/5yWrs2EkvDAJCWIyXS3HKkKf/gWDYR4HY2O8QtAsYVOSKWhUlP0vVBPH0KU8FqPQNAUpRuTJ5490/7BkY0r4JwxJbB2qEFpFxbA2mWom9PyR95DvP8uVFrXLarIuhyExqcu8zuCUG68eqalkt82yuAdDp0z3HNuLNBIbJZutnjnMN9uLSIzWhjJbFAx9oq48rnBs14HUK90uIU+/dKymXZtg6jAY6qljs0zMDxyTxrM5S/haMvk2fvVoVJqZre8SczNVtqtw55cO7zxOTGoOeerWkU5nBe0mZPxFxAQwttsp1XSUosnQOPFulOcfv0YOH/CZm8Ulz8lPA82eo+/MP4KzTZwbVTSd+WySOBhJLrfmHHz07gfc/uJ25sayZ9eO42U1EmoPewcw9KNrbdxu66rbkN0sz7x8rMa8GcoMZwgb1vP9kvVywJdCPS3o2sB2mWj2HRoc23bg4LDMwecLJQzjOisgReGtW2/z9bdf3TOaK4W4U6qJz6kZU2I2G6W2azUr6q651stA36esphR0NKCaumyGecDx/jsf8vmXnyIvvPGw7loLVmvTaALxI+HnJ5FHH5uwXiZiNCgsOqGsx9QcBuXjx1d88t1ehquoYDYv2ayGMc4Xgtx8/SE18joLu6g479huIpIcKaWs57sBt7jiM9ZmyGZhCUvOnBgEX5KDrpmPgrkb6/Lca8fat8oQFCfCdG4bQ2yhGyLNwud8N2wzSubiaKZzOSZOfw0MIbJ3yf+9eT0hq8kOyy8c2xATRQHTpsCio98pzcwTwuhIe7Z3QewFKUzCKcdLv7NoSKQA88vu71gxx1s18uzLR2pVt5sxc2yRhZlV2l4o+/eVrM/Hlg17I8HcPW2E1VLZP3QUhdB1SgyWBPe+I1ZniT8BAUyY7AWxio0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABGFJREFUSEvdlTuvVFUUx3/7cV7zYHgbkIugVn4CG40EMAGFiImPxKiFFpYmFsbExMZEG2NrY6GJhY2SqEHQoEHwQ1ihIsTcK5e5M3PmzDl772X2HizuhZbG3ZyTyZz1X2v9H1txj4+6x/X5HwAcPbMioQMfhLxkOZJSWGvS+2Ts0FqxaDxKK7IMlNZ45wke7COvIr99zi/f/3XXbajHnjwoJg8Md1q0gvnMU+QWY6GeuYQ4uQn9oaZzgaLSLOYeCRACtJ0wGMbfAlcu3Amijp05JPWkw7ew/8ECIXDzb48S2LUvp552FKWmmQtaaeJ/e6OMetwRRLClZj7xFD2FdJpL5//cNIk6cnol1sT5wHCbJSsM/SGsrzqqfpYA4plvSCqolUEZTzXMyHJhsuERH9IE1dBw8ey1zQAnXzgsbeMiBsEpskKze5+mrRXTacfatcDeFU0XVzHKmKwHZhstWmv62xVFaZhGniz0+pZvv7i6GeD4s4dEG9Aq0DSCOKHsa0QMo12am6stg17GonVkuWE2dbgGmtazbYfBWEXXCOhAnlvOffn7ZoATzz8gIHgvzDYEjaIYQjeHsq9uy2r56A0yJrciQMAFYbTXIl4xHcc1Cp8eX+fhN+vNAKdeOixt6znR38alq2tcE8Ngh6bIFb3IwWzJQVlarl9b0KssRsNi4ZZr22GY3gpUA0238Fw+f33rBAclFogTIJaugWIQG/LkmaFznvlU0Bl4B9u3WzCKee0oCsPadUc1gvGqZ7RH30nyEycPSESPJ6pmuuGTzotK0S0SNuKFvB+XF024TC+J/YikpzGKehooCs2PZ//YPMHRZ1ZEGxNnSN8GWXYaXdqLHADdwmByT1lY5vPudnEY7ba0NUwT8YHYzuXzm82mjp1+QKq+Zt4IWgecF6xVafws1yxqTzUwzCYdi0YwmaKtQxJAjJD5XDBW8K3QtXDlhy0AR55aEVuCxmAzxXTiUuf/ERxXFbxOYBu3WqpexqOTMRdNRX+QpTWtrzm0WSrx8rm7kFz2MybjlnosFANFWSwBotG0juCQ9zJ8J6iYIShms46de2yS9qIJKbciBz99s8XJz73+kHgP43/atPeiMixaT1kqPn7vM97+8LVkpulGR1kamoVLvKRoyIaYqmE+dyCKEISftwI8/eIhiVFd9S3jm21ShLGGReNo50uVRF+4VlAGrFH4EFKado3GliFx5jqSLy59t2WC0y8fEhGVCsRMsZnG5tGXQp5p6g1PObD4OGbyq6TMiZHRHxmki+tytI3Q61kufLUlKk69siKLeqnr2ThQ5EtPxG6yStHrGeo65r8k4OSXXnR4S1lZ1m507LwvTzHu7qaio2cOyJ79GavXOyQoxAV8p1OnMSHfeeNdPvjk/SRP7+KtF286oXNLwpsJSabRRLGhi19vWdHjJ+8XhUrXoXOBZqowWWCwXVNVlreGho9utNSadPHUE0fwS26igka74v1AyqOsgF8vbJbpv+r5WjcY8taYAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUtJREFUSEtFljuvJFcVhb99zqlXd9++PXfujEFzkR0ikSIRjTUisGw8SKTghAQRQIBAIjDEJAiw5Bh+CyESiAAnxEaasT1zX/2qrqrzQHuXMdVqdVerzn6stfbaLd/74ZtltRFev0w0nTD0mW4Z2N5MpFgYeggBpILFwlFVwnDK+Aq7vHNMsdj3kqGUQlULr19EHlxWyNN3rkq3Fu6vE1UNuUC7cMSxsDqvOPWR/V1itQmIFEoWSywipJR59c1f8+7yH/zrk79SUuFXP/kFf/jLRxzvMz4I8vTdq0KBqpkP+MqRYsaJIA6IQj8mKMJyLTRN4LCLlkQDaMdacagFRKhrZ90d7hM5ZuT5B2+Vm1cjaYIHjyu2txN14zhbKy5Cf4zkJJwOiRTh7EILwLpdLAM5F37JLb/PG4Y+GbzHfTTIRN+a4HiI5MFByExDplk4KI48wekUqYJQL5xhbNXdFrz3tOvC8kwDTrRdoOng7jrSLjzb24j3gnz3B1dFK5kUBhGGY2Y8aRKPE9g8DuxuopWTs7DoPK9eTqwvHLkUBGG1rjjsJ6UZJ54YMykV484SaDvTseC8w9Vw3GYWZ47VOhjJi2VlUCnJ0whtK9Rd4Oaz0bpabSqmMSqVLBU2oD9Ejrs0Q/TZfwYePKoMCn3o/jbRdlCScHYeOB4jpcwybDR44xmHZL8NfbFnTie9N73Yp/JWclEVPSnnD2dyFYauC9Sd0B8S/S7TNI7zy9pwllkoX13a2W47zuoJzpKESnDOcf35yMOvV8iz71+VbuGNeV+JBaibwM23fscb//6N3R/7OCtCIGn/MCup8kxDomrFZLl+4G2OmspzGiPdIiBvv3dVzjaBrP0DzglxKrzg23wt/p2zzVx9jIXffueOP33yiH6IjEed7kJXB6t6GCPLVWXED30k5WIQytvvPSmhEZNZSRBzInhnSlDM6kpoulmKetg7sS4U31IEHyA4x/GQaBdCno+ZojSmPHv+jaIPq6y8g8NOuHgM7armp/GGv/U1/6xbRBwxZULwjFOyZzWRxlJIhphMBAqjJhFXZoievvNExYt48KpqVVKB0z7RLsXaV+LHMdHU8+T62pFGnQEYpmjwWeBJLScwnCK+LoyH/P85OB0y3UoI4hnGbNW4IMRTYXNZfUV0v4VQz4yHUNjv4PxCUzm8z0byoIGdMA4Zef9HbxZ1xnYJLz+dWJ9XDCedatWzQWnGl5MOgppbsjnozmYVXX8xUgVPs5rhatswm2UF99dx7mB94YmDoJ6kh8Yxo0a6eeS5f51o2orbL06sLhqcJLPxw3ayAqahEIfMpEb4wPPjR2f8+cXWOjHD+59VqB9pgqkv1p4m8LXar0Kmu0IY9oXN49k21Kd88KSYOO0LcYLuXOchszx3JnV9WQJ1v3l4Mru7ZFatn3XrmMaMDmJW/2+EP374MT/78Oe0Z8K4L9QrMe+SUgiVxzcq/sLnn86yFV2Zukj6vcHN3euJxdJTRMWuXqnaLmZ82qFWq3MjxVkXyWWWq8DpoI5bONwJ9bKQo3DqE/L+B28VdT5tbX3pbbGsN7U5p0JB8QYZJOsy9rr5EqEOJkXbB7tJlUDbqJMWbtVlEVtK8uz5VXEB+m02k1Mu9veR9WVllrtYqPYxKxj1D4AXs3VcYrGoDGclWyf54RuOfv+lWIK38wbRzatoGOqqVHbbzrPfRrNmU2oqZh94iEOxOVHeus5z3EWzEL10Lze1t87HUX3tSxWNpzm4rjj1eXVV/Veh95rQexh7HQjlSSgxWzDnxRbMQfEH28cK5mEfSSfduoX/Anzv+uUrk2PPAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABUBJREFUSEtlVkuPVFUQ/uqccx99u6fnwfAYmEYJGl2auCGaACEgJExAEgkbFi5dkLh3Y/wBujNxZVy58AcYXOs/UBNjQhSBIAPDvLr7Ps6jTNVlMMaadO7cvueeU/XV933VdH5jwiCGsQARY/cZoygdmAPygsAMMMkzgCOQEsNlBtXIYj6LqEYOzTygrCzqeUTm5BqQElAMCHTm4hpnzoCIMN2JWDnqEINsAjAIe9sRh9dybD/tkJcGXZMwWJArIysIKQBkASQgKwymOwEDPTSiHBjQxRsnuZ1HSEimzgLlyIETECIj+YQQEggEV5AePhpnun53y8M6aHmyPi/k4IhmxhguS9IAnbu6zjEkMKAvSrlSDTPDOEI5sKhnEaOxw3wW4KzR0mMkNHXAdCeBDDAcSxmMativOwi6eutV3t3xL0sW3EMQ4IFqbCHV5YVFiOnlS4Ohw3TXv0goKrTDRelLv/nBIbKOLt+c8HyaEDpWbCV81zcSiZHlBJZawcgyAx8SomfEDjCZACc4JDx7HLC65v5fwVtn1jgGYPJ6jmePPI5Mcs2CA4Eso6wcfj39BU7//DGEbRKDyqJrGb7p4WnbBGcJw0WHtun7+RKia7dP8bwJSALLi5jtJRSFhfSmqAjNPMEaIBNWoGdL1yaFbm/Lwwfg8FqGpo7/r+DyzVf41rEdfHNvBJfL69BFj/9s9b6sjDIlRVYWyabz/YisJDy577GymsPHgNgSVk/07BKtiH6sJdDb75/j9sFvOHzlE+S/f66Cm+31rHn+1MNI5rkBIsGHiHJkEFpWCndNL0Dpk8uhVPVtj0Q17vtJ1z48yZv3I0zGGI4dvGBIBGP7xkrEjrD73GN8yKGqDGazqI+CZ9T5SSxnD7VqToyu8/AtQWAWRtLG7XXe3mTNQPg/XHCalTR6UDnta+cj6mnEaDFDM4tavsmk2f3aGFmbq/Sc9hqYbgNkEujclQnDCiMTuppx6FhvFbKJ2EFRWWw/8RgtWdgM6Oqk2duc9ABRue96jRjDyEsHQyLCiPleBJ29ss5BKk5iCYInlNvtnGFzYPV4rllZy0iJkASWGeth5dCoyYnvSCi7moRiYJXCoROruLzORtTrU995Q2oR3ouC+0ZJxtJ8sY3NvyJsLodxr96hg/d9FaOxxd7zgLwU+gYsHxMlf3CSRZ2ysJ4lxJjUIeUqAlQ29M6heEvzfEcYLUBpKyFQSkNTBIrSKtsO7IIuXJ/woDLq5c1+QtMCS4csrDNom6BwCVSiXslu9YTDzmYPic6GnLC/lQBhcmAsrlrdPDErdPTaG0d58mam/C1Kg92tAOcMBiPSrCWjrkv48tOvcOezj5BiwnCcoRbHpB42Ed50r6986YiBmJw+l6rPbqyz+IhkJ01DMmjrgLYDTpySjRi+jSjSCmo8x9JKhrqO6kE65RgYjpxOsdluVAfWhuekpkmXbkx4NksoK9KRWA4tFpYIf/zSoRyTyl0+4kfiSxKiZBFiPU+4szTH13GkFJc/sRY5VA1YKji/sc7ignIv4iorhqFM/6/3hKrSBUZWGpBhlKVsIEoNKrC8cHh4r8PqmsFoUYQWMVwwsJnB99/eJ7pwfV1G739CGVUHNDInWgPY/rp4+N9lWWZRLcjYTPoDYH/Hq056WhN+vPtAb+id947zypEc7TxAh5bysXfUthFFM7o2wmUCeP8s1DIrksIklmGNUWH9/dCrE/x099HLlOndSxNePmJ7DznYuIs6teTXhnwpdBXxqeAyQr0rhtjbsTGEaiyTX7QT8cN3feYH8Q9oQd+uVhh0EQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABIpJREFUSEvtlbmrZEUUxn+nqu7W2+v3ZlGZJxoKpoLRiBgMLiOYqomJGGggCgajsYm4gLH+LYaCYuAkxiPM6My8vbvvVoucujiGRmZW09y+TdU55/vOd76SV998Ki3WwsN7gaoR+jbSzB3nxyPBJ/oWnAMpYDYzFIXQdxFbkJc1htGn/DtFSClRlMLDu579ywVy/cZhalbC2VGgKCEmqGcGPyQWewVd69mcBhZrh0giRcmJRYQQIg+e+YSX5z/z6+0fSCHx8bsf8uX337A7i1gnyPWXDxMJimo6YAtD8BEjghjAC+0QIAnzlVBVju2Fz0k0gCLWil0pIEJZmoxuexaIPiI33346HT8YCCPsXy04PxkpK8NypbwI7c4Tg9BtA8HD8kALIKOdzR0xJj7ihC/imr4Nmd7dxmfKRL+aYLf1xN6Ai4x9pJoZSIY4Qtd5CieUM5M5ztWdJKy11KvEfKkBR+rGUTVweuSpZ5bzE4+1grz0xmHSSkalQYR+Fxk6TWIxAuurjotjn8uJUZg1lgf3RlYHhpgSgrBYFWw3o7YZIxbvIyGk3LucQOGMu4SxBlPC7jwyWxoWK5ebPJsXmSpt8jhAXQtl4zj+Y8ioFuuCcfDaSuZKG9BuPbuLMFH0x+89+1eKTIVuOjsJ1A2kICz3HLudJ6VJhpUGryxDH/J/fZvynq7T96yX/NS+pZhURdfS3qWpuUpD0zjKRmi3gfYiUlWGvctl5lkmoTxaiuzifJjU40xO4grBGMPRnwOXniiQF18/TM3M5s7bQnKAsnIcP/s5j/32aX7ftX5ShEBQ/DApqbCMfaCoJctytW/zHFWFpRs8zcwhL7xymJZrR1T8gDGCHxN3eY7H/U8s11P13ic+e/6Ur29foe09w06nO9GULlfdD575osiN71tPiClTKC+8ci25SrLMUgAfA86arATlrCyEqpmkqIetkYxC+U1JsA6cMey2gXomxOlYVpTGlBdvPpl0s8rKGtheCAdXoV6UvOeP+bEt+aWsETH4EHHOMowh79VEGksp6X3IIlAaNYmYNFF0/cY1FS9iwaqqVUkJuk2gnkuGr40fhkBVTpNrS0MYdAagH32mLwce1XIcfeexZWLYxn/moNtGmoXgxNIPMVdjnOC7xPpy8ajR7Tm4cuq4c4nNBewdaCqDtTE3udfARhj6iLz21lNJnbGew707I6u9gr7TqVY9Zyqz8cWgg6DmFvIcNMtJRUf3BwpnqRYTXXXtJrMs4OzITwhWBxbfC+pJemgYImqk6yuWs4eBqi44ud+xOKgwErKNb8/HXMDYJ3wfGdUI9y3vXFny3d3zjCQb3t9WoX6kCcY2ZXiawJZqv0qZ3hVCv0msr062oT5lnSX4QLdJ+BGaPZ2HyHzPZKnrJydQ95uGJ3JxGrJV67OsDeMQ0UGM6v+V8NWtb3n/1gfUS2HYJMqFZO+SlHCFxVYq/sSfdybZil6ZepG0m0w3pw9HZnNLEhW7eqVqO2XjU4Rarc6NJJNRBBOZLxzdVh03sT0VynkieqFrwzQS/+X6P8G/svsXXBt/Z1jfQFwAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAABFtJREFUSEvtVUuLXEUYPfW4j759pzPOw2TM9GiIokvBTVYZkcgMZFADhmyycOkikL0b8QfoTnAlIggKYlSCQYkPUNzpRgURxExMDJlknun7rMcnX90Y0j0LNy4taLqbW7e+75zvnFPi6bUhQRCkAoQg7N4mJKkGkUWcCBABJPgZQA7wnqAjiSxXKAuHLNeoS4s0U6hKh68/uSZw3xLHTixQpCWEEBjtOMwc1HCWDwEIAnvbDvMLMbZvtYhTibb26E3xNyFKBLwFhALggSiR+OLDq+MFTpxaoqZ0oSZ3qhWQ5hrkAesI3nhY6yEgoBMRiueDKOzf3TRQGgEe748TicsXJgosn1wkZz0ICC8yXEZDRJBaIO0pVIVDPtAoCwutJJKegHMCdWUx2vEQEugPGAbhq48nKDp55hHa3TH3IDPv1jLxQDZQYHRxomCdv8dsr68x2jV3G3KB2v4BnovGxfeujFO0cnpI5cjDthS45WXabpDwhCgWIJ4wCFEkYayHMwTXAjJi4lgBHrdvWMwt6P0Injy2QM4Cw8di3L5u8OAwDlSQFRCKkGYavxx9A0d/Og9WG69eptA2BFN39DSNh1YC/QMal95fH0fw3NkjVNYWnmm5u4o9jyRR4NkkmUBdeigJRD3J/Qa1tI0P1O1tGhgLzC9EqCu3H8HK6YfpzKEdvPN7Dh13xbO+xo0rTfifZjIoxTsKKuJDyzsOUSpwc91gZi6GcRauEZg7HO2fwVMvLFPz56+YX30F8W+vB8MVe51qtm4ZSO48loATMNYhzSVsQ0HCbd0ZkOekYwSpfnvp+gRFLy3RxrqDjAj9gYapXXhLqm6wvFwrsLtlMJjVyDKJonDhkTWEKl7CA9G1gJo84bPJGaydXaTtDQodsP77Uzp0xYPuZTrMtTUO1cghPxChLlyIDxnxsLu9zhGa2oUi+2S6vDokKFakR1sRZg91UcGHcBwkmcL2TYN8WkFFQFv50L2KRSjALjdt5xEpCZc/mqDo+OoiWUbsORKYTwRtNyVBxcDcQzHKkYVSBO8FPNNSUCiW9mUIufpu1LC6Pv9gMipWFkmye40PXSspQkQYww7ujMcd8/A5NjauOqiYi1Hn3r6GMR2KfKDw6bsTPlh5cYnYnbyxKjyc8yEh+ZsNmA1kKMDjZr7ZI6YVyKcQZMuLqeSI8Q745uJEFj3z/JB6mQxZXt/xqBtgelZBaYmmtoEupordu7dlMXdYY2ejS99wN8QCdzY9wEq2hB++uzEu00cfP0jDJyKYhi8aid1NC60lerkIXSepQtt6vPnqWzj32svwzqM/iFAVfBF0tLHxRnsd8h+//2u8wPG1ReIc4e54aPASTWXRtMDhI3wQwTQOiZ9BhS1Mz0SoKhcyKNxyBPRzjaq0+PLCOD2MUjx7akhF4ZFmIlyJaV9halrgj59bpAMBpboP5xHnEi92MhuxKj3OTZd42+X7rsp/cm0Mzv136X/1+/8C/8rk3zEjOzeChQgxAAAAAElFTkSuQmCC"
            ],
            "walkableNeighbors": [
              "grass",
              "water",
              "forest"
            ],
            "buildable": true
          },
          {
            "type": "forest",
            "texture": "path",
            "color": "#2f4a29",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFkyagHBBD4aRKNBRDAECCoYTUWjQUQwBAgqGE1FAx9EAM7AMK06eeZJAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAPUlEQVRIS2NkoDFgpLH5DMPAAn0vzf+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBaCoaDSKCIUBQAc1TEQC2nSCt0Vf5ogAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASElEQVRIS2NkoDFgpLH5DMPAAn0vzf/UCKaL265jDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMpqKCIbZaBCNwCACAFc5UBlc2SShAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAANUlEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoYTUUjIIgAMVcnMWaCer0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAASklEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCoY2qno4rbrjDTzAchwUPjRxAKY4TSxANlwkAUA6tgwrW9iQGUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAQElEQVRIS2PU99L8z0BDwDhqAaHQHQ0iQiHEMBpEo0FEMAQIKhhNRaNBRDAECCqgfSoi6AQKFTBSqJ+g9qFvAQAZ2yCt7eMyfAAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAS0lEQVRIS2PU99L8z0BFcHHbdUZk4xhHLUAP3dEgIpjeRoNoNIgIhgBBBaOpaDSICIYAXgXoKQikmGo1GjbDwRZQ5mbCukctIBhGAJ5QUBlAsncEAAAAAElFTkSuQmCC"
            ],
            "buildable": true
          },
          {
            "type": "rock",
            "texture": "rock",
            "color": "#3e4f57",
            "image": [
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXUlEQVRIS2O08w//z0BDwDhqAaHQHaZBZOXoynBs/25CvidKfnAFETk+G1w+ICrQ0RSN+gBnqMESxGgQEUxYOIOInEyFzbahEwe4fDx0fIArtjF8QK3IhVlI8yACABTaP2GrGczwAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAc0lEQVRIS2O08w//z0BFcGjjSkZk4xipbQHIcGRLaGIBsiU0swBmCU0tAFlCXwusHF0Zju3fTcU0RW8fUNXpUMPoGwejPsAWAqNxwEAoc2INIkKaSElto3FAMLToE0TUjFR0L5HlA2IdBFJHlgUEAx5JAQBSHEWVRFas9wAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATElEQVRIS2NkoDFgpLH5DMPAAjv/8P+0DCbGUQsIBe9oEBEKIYbRIBoNIoIhQFDBwKciK0dXhmP7dxN0KS4FA+8Dsp0O1TjqA4IhCACSGijVPQJ64AAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAX0lEQVRIS2NkoDFgpLH5DMPAAjv/8P/UCKZDG1diDQ1GalkAciQ2S6hqATZLRi3ASB/o8TAaRKNBRHohMoJSkZWjK8Ox/btJDqMRFEQkhw1UA8VBRChuKLaAkM/QLQAAEzdWGaItYCUAAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAXklEQVRIS2O08w//z0BDwIhugZWjK8Ox/bupZiWGBVQzGWrQ0LEAV9AOnA+oFdkD5wNqpaah6wNYHA5dH8DicIT5gJzMNzBBRI5LcWXMgfEBtYoJkDmjPiAYmjQPIgB29j9hRLICDQAAAABJRU5ErkJggg==",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAeElEQVRIS2O08w//z0BDwEiOBVaOrgzH9u8m6CyQOrAFxGogaCIWBWT5gBSLRi0gGFpYg4iakU5xHBByDMUWEAqjUQsIhRCkqCCoigIFoxYQDDyUICKUaQiaNlpckxpEhzauZKRZMgUZDnIQTSyAGU4TC5ANB1kAAGFjRZXml4rsAAAAAElFTkSuQmCC",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAATUlEQVRIS2O08w//z0BDwDhqAaHQHfggsnJ0ZTi2fzchh+KUH3gfkO10qMZRHxAMwdEgGg0igiFAUMFoKiIcRARVUKiAkUL9BLUPfQsAjkIo1UAR1E0AAAAASUVORK5CYII=",
              "iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAYUlEQVRIS2O08w//z0BFcGjjSkZk4xhJtcDK0ZXh2P7dOJ1EsQWEPDuCLCAU1riCagQFEaHUMhpE5IYQw2gqIhh0o0E0sEGEHv4g15BcoxFbRMDUodSfBP1PhoJRCwgGGgACl1YZGweXngAAAABJRU5ErkJggg=="
            ],
            "buildable": true
          }
        ],
        "terrainMap": [
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            3,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            4,
            3,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            4,
            2,
            2,
            2,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            2,
            2,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            2,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            3,
            3,
            2,
            3,
            3,
            3,
            3,
            3,
            3,
            3,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ]
        ],
        "terrainBGColor": {
          "paletteColor": "greenMColor"
        },
        "environmentObjects": [
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 707,
            "y": 23.21875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 702,
            "y": 81.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 328.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 56,
            "y": 347.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 54,
            "y": 190.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 205,
            "y": 48.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1095,
            "y": 351.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1234,
            "y": 320.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1094,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1258,
            "y": 242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1442,
            "y": 334.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1504,
            "y": 315.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1193,
            "y": 196.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1313,
            "y": 78.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1519,
            "y": 55.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1518,
            "y": 166.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1431,
            "y": 255.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1136,
            "y": 286.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1056,
            "y": 333.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1233,
            "y": 76.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1423,
            "y": 67.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1469,
            "y": 248.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1551,
            "y": 331.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1182,
            "y": 326.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1229,
            "y": 177.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1538,
            "y": 263.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1490,
            "y": 110.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1351,
            "y": 50.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 714,
            "y": 1547.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 701,
            "y": 1497.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 746,
            "y": 1393.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 926,
            "y": 1424.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1008,
            "y": 1407.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 957,
            "y": 1238.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 1200.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 631,
            "y": 1192.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 644,
            "y": 1428.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 617,
            "y": 1538.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 454,
            "y": 1528.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 148,
            "y": 1534.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -15,
            "y": 1535.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -6,
            "y": 1371.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 61,
            "y": 1355.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 33,
            "y": 1470.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 232,
            "y": 1450.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1448.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 576,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 374,
            "y": 1297.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 1223.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": 1304.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 70,
            "y": 1226.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 1211.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 656,
            "y": 1266.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 504,
            "y": 1332.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 304,
            "y": 1405.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 292,
            "y": 1523.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 125,
            "y": 1398.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 406,
            "y": 1357.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 1324.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1516,
            "y": 1350.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1482,
            "y": 1175.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1493,
            "y": 1242.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 356,
            "y": 1191.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 160,
            "y": 1154.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 6,
            "y": 1150.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 435,
            "y": 1135.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 418,
            "y": 1231.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 646,
            "y": 1126.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1398,
            "y": 1146.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 214,
            "y": 1128.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": 1499.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 476,
            "y": 1416.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 669,
            "y": 1366.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 352,
            "y": 1487.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 180,
            "y": 1517.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": 1399.8125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 72,
            "y": 1528.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 94,
            "y": 264.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 88,
            "y": 358.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 619,
            "y": 136.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 679,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 689,
            "y": 223.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 667,
            "y": 335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 603,
            "y": 386.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 589,
            "y": 482.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 744,
            "y": 385.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 782,
            "y": 226.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 861,
            "y": 58.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 780,
            "y": 1324.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 920,
            "y": 1335.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 862,
            "y": 1408.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 747,
            "y": 1497.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 867,
            "y": 1539.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 843,
            "y": 1293.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 876,
            "y": 1206.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 832,
            "y": 1270.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 945,
            "y": 1317.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 784,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 865,
            "y": 1533.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 686,
            "y": 483.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 711,
            "y": 306.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 148.8125
          },
          {
            "type": "rock",
            "imageIndex": 5,
            "x": 727,
            "y": 1250.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 752,
            "y": 1468.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 904,
            "y": 1502.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 673,
            "y": 421.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 51.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 744,
            "y": 50.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1110.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 369,
            "y": 1109.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 102,
            "y": 1414.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 521,
            "y": 1466.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 120,
            "y": 1224.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 597,
            "y": 1467.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 345,
            "y": 1532.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 549,
            "y": 1278.8125
          },
          {
            "type": "rock",
            "imageIndex": 7,
            "x": 1234,
            "y": 272.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 1409,
            "y": 305.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 501,
            "y": 84.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1227,
            "y": 141.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1175,
            "y": 278.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1176,
            "y": 276.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1537.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1391,
            "y": 1536.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1528,
            "y": 1435.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 173,
            "y": 1351.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 132,
            "y": 1482.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 93,
            "y": 971.8125
          },
          {
            "type": "rock",
            "imageIndex": 2,
            "x": 1239,
            "y": 935.8125
          },
          {
            "type": "rock",
            "imageIndex": 3,
            "x": 1194,
            "y": 642.8125
          },
          {
            "type": "rock",
            "imageIndex": 0,
            "x": 1369,
            "y": 486.8125
          },
          {
            "type": "rock",
            "imageIndex": 4,
            "x": 98,
            "y": 534.8125
          },
          {
            "type": "tree",
            "imageIndex": 4,
            "x": 1432,
            "y": 683.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 408,
            "y": 602.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1298,
            "y": 915.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 347,
            "y": 820.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 1206,
            "y": 514.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 451,
            "y": 1038.8125
          },
          {
            "type": "tree",
            "imageIndex": 2,
            "x": 86,
            "y": 612.8125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 2976,
            "y": 2976
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 96,
            "y": 96
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 144,
            "y": 2931.800048828125
          },
          {
            "type": "goldVein",
            "imageIndex": 0,
            "x": 2928,
            "y": 147.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2335,
            "y": 2963.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2314,
            "y": 2644.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2966,
            "y": 2469.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2016,
            "y": 2964.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1831,
            "y": 2647.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1876,
            "y": 2376.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1738,
            "y": 2936.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1831,
            "y": 2850.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2108,
            "y": 2994.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1813,
            "y": 2997.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2030,
            "y": 2757.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2166,
            "y": 2908.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2254,
            "y": 3038.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1877,
            "y": 2932.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1979,
            "y": 2630.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1979,
            "y": 2629.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1924,
            "y": 2801.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2199,
            "y": 2729.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2041,
            "y": 2864.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1667,
            "y": 2724.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1665,
            "y": 2515.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2117,
            "y": 2481.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1624,
            "y": 3000.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1911,
            "y": 3023.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1587,
            "y": 2854.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1903,
            "y": 2461.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2092,
            "y": 2581.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1772,
            "y": 2770.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2001,
            "y": 3068.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1771,
            "y": 3076.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2170,
            "y": 3107.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1830,
            "y": 2105.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1710,
            "y": 2252.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 215,
            "y": 1692.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 737,
            "y": 1688.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 977,
            "y": 1859.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 66,
            "y": 1897.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 302,
            "y": 1597.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 305,
            "y": 1831.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 618,
            "y": 1902.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 210,
            "y": 2183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 752,
            "y": 2223.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 882,
            "y": 2790.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 305,
            "y": 2473.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1203,
            "y": 2977.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1311,
            "y": 2679.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 103,
            "y": 2328.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 451,
            "y": 2123.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 836,
            "y": 3058.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 835,
            "y": 3058.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 918,
            "y": 2925.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1035,
            "y": 2796.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1034,
            "y": 3034.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1411,
            "y": 3013.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1125,
            "y": 2820.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2298,
            "y": 89.79998779296875
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2549,
            "y": 504.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1955,
            "y": 392.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1743,
            "y": 496.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1872,
            "y": 198.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2264,
            "y": 796.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2934,
            "y": 805.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2508,
            "y": 705.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1844,
            "y": 613.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1595,
            "y": 744.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1775,
            "y": 773.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1982,
            "y": 812.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2162,
            "y": 969.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2494,
            "y": 1029.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1829,
            "y": 1085.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2458,
            "y": 1160.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2268,
            "y": 1135.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2719,
            "y": 1194.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2632,
            "y": 910.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2880,
            "y": 1202.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1323.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2832,
            "y": 1378.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2527,
            "y": 1567.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2363,
            "y": 1502.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2434,
            "y": 1314.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2763,
            "y": 1505.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2529,
            "y": 1404.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2050,
            "y": 1430.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1999,
            "y": 1577.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2288,
            "y": 1593.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2002,
            "y": 1761.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2310,
            "y": 1851.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1727.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2537,
            "y": 1726.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2909,
            "y": 1670.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3010,
            "y": 1357.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2731,
            "y": 1068.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1363,
            "y": 1812.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1272,
            "y": 2365.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1346,
            "y": 2778.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1942,
            "y": 2721.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1890,
            "y": 2595.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1755,
            "y": 2620.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1824,
            "y": 2532.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1884,
            "y": 2764.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1728,
            "y": 2830.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": 2830.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1978,
            "y": 2369.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1782,
            "y": 2408.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1660,
            "y": 2639.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1629,
            "y": 2885.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1966,
            "y": 2493.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 119,
            "y": 1624.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 63,
            "y": 1719.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 415,
            "y": 1623.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 184,
            "y": 1842.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 83,
            "y": 1993.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 82,
            "y": 2102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 82,
            "y": 2101.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 189,
            "y": 1943.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 419,
            "y": 1705.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2820,
            "y": 1909.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 651,
            "y": 1600.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1294,
            "y": 1667.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1544,
            "y": 1802.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1166,
            "y": 1792.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2980,
            "y": 601.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2805,
            "y": 582.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2671,
            "y": 590.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2719,
            "y": 679.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2855,
            "y": 642.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2771,
            "y": 742.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2927,
            "y": 729.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3021,
            "y": 668.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3015,
            "y": 856.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2852,
            "y": 793.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2849,
            "y": 717.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2774,
            "y": 652.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2653,
            "y": 715.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2625,
            "y": 652.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2630,
            "y": 765.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2699,
            "y": 776.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2813,
            "y": 855.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2814,
            "y": 855.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3040,
            "y": 746.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2882,
            "y": 657.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2918,
            "y": 842.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2985,
            "y": 889.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2750,
            "y": 804.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2973,
            "y": 686.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2993,
            "y": 791.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3041,
            "y": 601.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2584,
            "y": 688.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 834,
            "y": 1514.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 833,
            "y": 1407.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 721,
            "y": 1299.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 721,
            "y": 1298.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 831,
            "y": 1224.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 832,
            "y": 1224.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 921,
            "y": 1289.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 850,
            "y": 1341.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 981,
            "y": 1344.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 796,
            "y": 1591.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 319,
            "y": 1653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 524,
            "y": 1645.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 856,
            "y": 1644.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2002,
            "y": 2434.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2060,
            "y": 2964.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1936,
            "y": 2883.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1858,
            "y": 2300.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1859,
            "y": 2300.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1634,
            "y": 2384.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1556,
            "y": 2564.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1860,
            "y": 2667.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1617,
            "y": 2668.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1530,
            "y": 2452.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1753,
            "y": 2316.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1799,
            "y": 2184.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1709,
            "y": 2460.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1901,
            "y": 2261.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1747,
            "y": 2529.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1677,
            "y": 3020.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1668,
            "y": 2798.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": 2684.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 51,
            "y": 2182.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 184,
            "y": 2076.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 357,
            "y": 2214.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 494,
            "y": 2160.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 90,
            "y": 2288.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 315,
            "y": 2298.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 516,
            "y": 2289.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 327,
            "y": 2077.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 606,
            "y": 2102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 421,
            "y": 2269.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 207,
            "y": 2199.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 484,
            "y": 1991.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 802,
            "y": 2083.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 584,
            "y": 2254.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 430,
            "y": 2041.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 307,
            "y": 2161.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 221,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 220,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 119,
            "y": 2235.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 426,
            "y": 2334.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 188,
            "y": 2321.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 446,
            "y": 2187.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 548,
            "y": 2183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 526,
            "y": 2094.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 544,
            "y": 2023.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 380,
            "y": 1983.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 301,
            "y": 2027.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 220,
            "y": 1984.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 219,
            "y": 1984.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 93,
            "y": 2025.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 38,
            "y": 2073.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 35,
            "y": 2337.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 24,
            "y": 2428.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 44,
            "y": 2276.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 43,
            "y": 2276.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 26,
            "y": 2201.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 176,
            "y": 2171.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 280,
            "y": 2174.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 282,
            "y": 2082.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 518,
            "y": 2110.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 638,
            "y": 2022.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 641,
            "y": 220.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 661,
            "y": 127.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 549,
            "y": 1.8000030517578125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 426,
            "y": -28.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 145,
            "y": -18.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -77,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -157,
            "y": 153.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 80.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -133,
            "y": 10.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -44,
            "y": 9.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 26,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -149,
            "y": 236.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -115,
            "y": 268.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -171,
            "y": 418.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -64,
            "y": 273.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -161,
            "y": 351.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -58,
            "y": 386.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -73,
            "y": 600.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -159,
            "y": 710.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -45,
            "y": 839.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -26,
            "y": 660.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -137,
            "y": 529.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -34,
            "y": 427.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -35,
            "y": 427.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -100,
            "y": 715.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -154,
            "y": 872.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -165,
            "y": 571.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -68,
            "y": 502.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -102,
            "y": 333.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -24,
            "y": 210.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": -20.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -33,
            "y": 83.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 279,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 544,
            "y": 503.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 43,
            "y": 708.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 87,
            "y": 877.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 181,
            "y": 791.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 447,
            "y": 856.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 691,
            "y": 625.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 599,
            "y": 793.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 598,
            "y": 793.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 704,
            "y": -100.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 268,
            "y": -157.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2,
            "y": -115.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -161,
            "y": -173.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 163,
            "y": -88.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 511,
            "y": -142.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1064,
            "y": -46.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1526,
            "y": -111.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1402,
            "y": -43.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1402,
            "y": -44.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1112,
            "y": -138.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 778,
            "y": -57.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 885,
            "y": -42.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1255,
            "y": -98.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1363,
            "y": -150.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1624,
            "y": -72.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -159,
            "y": 1974.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 1973.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 1753.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -143,
            "y": 1657.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -97,
            "y": 1094.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -104,
            "y": 956.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -143,
            "y": 1314.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -90,
            "y": 2081.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -120,
            "y": 2378.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 2182.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -70,
            "y": 2293.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -122,
            "y": 2555.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2480.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -79,
            "y": 2856.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -25,
            "y": 2599.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -132,
            "y": 2675.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -144,
            "y": 3019.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -110,
            "y": 3164.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 73,
            "y": 3180.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 276,
            "y": 3108.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 336,
            "y": 3196.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 8,
            "y": 3100.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -18,
            "y": 3188.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -172,
            "y": 3216.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -162,
            "y": 3068.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2948.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -40,
            "y": 2947.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -150,
            "y": 2857.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": -45,
            "y": 2729.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 522,
            "y": 3124.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 861,
            "y": 3183.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 624,
            "y": 3233.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1096,
            "y": 3153.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1825,
            "y": 3234.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1672,
            "y": 3108.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2012,
            "y": 3146.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2038,
            "y": 3253.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2266,
            "y": 3193.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2355,
            "y": 3241.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2317,
            "y": 3113.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1696,
            "y": 3206.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1902,
            "y": 3203.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1943,
            "y": 3254.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1626,
            "y": 3117.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1444,
            "y": 3210.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1660,
            "y": 3230.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3118,
            "y": 3194.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2950,
            "y": 3144.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3134,
            "y": 3065.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3151,
            "y": 2957.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3121,
            "y": 2825.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3108,
            "y": 2653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3237,
            "y": 3079.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3006,
            "y": 3086.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2925,
            "y": 3216.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2720,
            "y": 3208.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2855,
            "y": 3093.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3020,
            "y": 3231.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3237,
            "y": 3220.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3014,
            "y": 3123.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3227,
            "y": 2929.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3084,
            "y": 2893.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3125,
            "y": 2995.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3228,
            "y": 2764.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3116,
            "y": 2733.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3232,
            "y": 2524.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3112,
            "y": 2569.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3093,
            "y": 2368.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3243,
            "y": 2385.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3214,
            "y": 2653.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2816,
            "y": 3238.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3113,
            "y": 3249.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3200,
            "y": 3144.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2676,
            "y": 3102.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2413,
            "y": 3221.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2595,
            "y": 3240.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2596,
            "y": 3240.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2469,
            "y": 3134.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2598,
            "y": 3107.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2500,
            "y": 3220.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2559,
            "y": 3157.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2675,
            "y": 3269.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2753,
            "y": 3115.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3265.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3264.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3263.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2906,
            "y": 3262.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2651,
            "y": 2306.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2938,
            "y": 2332.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2657,
            "y": 2988.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2412,
            "y": 3004.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3037,
            "y": 2606.800048828125
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3142,
            "y": 564.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3133,
            "y": 697.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3211,
            "y": 694.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3176,
            "y": 586.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2351,
            "y": -81.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2171,
            "y": -123.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2210,
            "y": -24.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2299,
            "y": -170.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3159,
            "y": 830.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3160,
            "y": 831.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3209,
            "y": 888.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3117,
            "y": 882.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3253,
            "y": 822.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3113,
            "y": 784.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3158,
            "y": 1056.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2940,
            "y": 1004.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3151,
            "y": 1177.7999877929688
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3203,
            "y": 412.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3120,
            "y": 312.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3104,
            "y": 455.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3225,
            "y": 285.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3118,
            "y": 194.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3225,
            "y": 155.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3140,
            "y": 100.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3027,
            "y": 41.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2778,
            "y": -43.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2778,
            "y": -44.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2512,
            "y": 11.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2394,
            "y": -114.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2735,
            "y": -167.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3212,
            "y": -86.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3080,
            "y": -162.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2890,
            "y": -130.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3103,
            "y": -57.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3214,
            "y": 18.800003051757812
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3233,
            "y": -169.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 3001,
            "y": -101.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2912,
            "y": -30.199996948242188
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2668,
            "y": -92.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2513,
            "y": -148.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2567,
            "y": -58.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2400,
            "y": -48.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2269,
            "y": -90.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1994,
            "y": -123.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1828,
            "y": -52.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1727,
            "y": -162.1999969482422
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2074,
            "y": -45.19999694824219
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 2118,
            "y": 56.80000305175781
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1955,
            "y": 228.8000030517578
          },
          {
            "type": "tree",
            "imageIndex": 0,
            "x": 1657,
            "y": 12.800003051757812
          }
        ],
        "extensionTerrainType": 1,
        "ramps": [
          {
            "x": 21,
            "z": 44
          },
          {
            "x": 25,
            "z": 44
          },
          {
            "x": 39,
            "z": 33
          },
          {
            "x": 39,
            "z": 31
          },
          {
            "x": 17,
            "z": 9
          },
          {
            "x": 56,
            "z": 51
          },
          {
            "x": 14,
            "z": 52
          },
          {
            "x": 49,
            "z": 9
          }
        ],
        "heightMap": [
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            2,
            2,
            0,
            0,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            2,
            2,
            0,
            2,
            0,
            2,
            2,
            0,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ],
          [
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4,
            4
          ]
        ],
        "extensionHeight": 2,
        "startingLocations": [
          {
            "side": "right",
            "gridPosition": {
              "x": 116,
              "z": 116
            }
          },
          {
            "side": "left",
            "gridPosition": {
              "x": 12,
              "z": 12
            }
          }
        ],
        "entityPlacements": []
      },
      "world": "shire",
      "grassShader": "grass",
      "waterShader": "water"
    }
  }
},
    compiled: true,
    initialized: false
};

// Helper to get collections (replaces core.getCollections() at runtime)
window.COMPILED_GAME.getCollections = function() {
    return window.COMPILED_GAME.collections;
};

// FLAG TO PREVENT DUPLICATE LIBRARY LOADING
window.COMPILED_GAME_LOADED = true;

// ========== LIBRARIES ==========

// Library: threejs (local module - bundled)
// Original path: /node_modules/three/build/three.module.min.js
// Bundled path: ./modules/three.module.min.js
window["THREE"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.THREE = null; // Placeholder

// Library: BaseECSGame (non-module - inline)
// Original path: /global/libraries/js/BaseECSGame.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class BaseECSGame {
    constructor(app) {
        this.app = app;
        this.state = null; // Will be set by subclasses
        this.sceneManager = null; // Will be set by subclasses
        this.moduleManager = app.moduleManager;
        
        this.entityId = 0;
        this.entitiesToAdd = [];
        this.entities = new Map();
        this.components = new Map();
        this.classes = [];
        this.systems = [];
        
        this.nextEntityId = 1;
        this.lastTime = 0;
        this.currentTime = 0;
        this.deltaTime = 0;

        this.isServer = false;        

        this.componentTypes = null;
    }
    init() {
        if(document){
            document.addEventListener('keydown', (e) => {                
                this.triggerEvent('onKeyDown', e.key);
            });
        }
    }
    getEntityId() {
        return this.nextEntityId++;
    }
    getCollections() {
        return this.app.getCollections();
    }

    async update(deltaTime) {
  
        if (!this.state.isPaused) {
            this.currentTime = this.currentTime + deltaTime;

            // Only update if a reasonable amount of time has passed
            // const timeSinceLastUpdate = this.currentTime - this.lastTime;

            // // Skip update if more than 1 second has passed (tab was inactive)
            // if (timeSinceLastUpdate > 1000) {
            //     this.lastTime = this.currentTime; // Reset timer without updating
            //     return;
            // }
            this.state.now = this.currentTime;
            this.state.deltaTime = deltaTime;
            this.deltaTime = deltaTime;        

            this.systems.forEach(async system => {
                if (system.update) {
                    await system.update();
                }
                if(system.render && !this.isServer){
                    await system.render();
                }
            });
            
            this.postUpdate();
        }     
    }

    postUpdate() {
       // this.desyncDebugger?.displaySync(false); 
       
        this.lastTime = this.currentTime;
    
        this.entitiesToAdd.forEach((entity) => this.addEntity(entity));        
        this.entitiesToAdd = [];
        
    }

    createEntity(setId) {
        const id = setId || this.getEntityId();
        this.entities.set(id, new Set());
        return id;
    }
    
    destroyEntity(entityId) {
        if (this.entities.has(entityId)) {

            this.systems.forEach(system => {
                if (system.entityDestroyed) {
                    system.entityDestroyed(entityId);                    
                }
            });

            const componentTypes = this.entities.get(entityId);
            componentTypes.forEach(type => {
                this.removeComponent(entityId, type);
            });
            this.entities.delete(entityId);
        }
    }
    
    addComponent(entityId, componentId, componentData) {
        if (!this.entities.has(entityId)) {
            throw new Error(`Entity ${entityId} does not exist`);
        }
        
        if (!this.components.has(componentId)) {
            this.components.set(componentId, new Map());
        }
        
        this.components.get(componentId).set(entityId, componentData);
        this.entities.get(entityId).add(componentId);
    }
    
    removeComponent(entityId, componentType) {
        let component = this.getComponent(entityId, componentType);
        if (this.components.has(componentType)) {
            this.components.get(componentType).delete(entityId);
        }
        if (this.entities.has(entityId)) {
            this.entities.get(entityId).delete(componentType);
        }
        return component;
    }
    
    getComponent(entityId, componentType) {
        if (this.components.has(componentType)) {
            return this.components.get(componentType).get(entityId);
        }
        return null;
    }
    
    hasComponent(entityId, componentType) {
        return this.components.has(componentType) && 
                this.components.get(componentType).has(entityId);
    }
    
    getEntitiesWith(...componentTypes) {
        const result = [];
        for (const [entityId, entityComponents] of this.entities) {
            if (componentTypes.every(type => entityComponents.has(type))) {
                result.push(entityId);
            }
        }
        return result.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    addSystem(system, params) {
        system.game = this;
        this.systems.push(system);
        if (system.init) {
            system.init(params);
        }
    }

    addClass(classId, classRef, params) {
        this.classes[classId] = { classRef: classRef, defaultParams: params };
        this.app.appClasses[classId] = classRef;
    }


    triggerEvent(eventName, data) {
        this.systems.forEach(system => {
            if (system[eventName]) {
                system[eventName](data);
            }
        });
    }

    gameOver() {
        this.state.gameOver = true;
    }

    gameVictory() {
        this.state.victory = true;
    }
    resetCurrentTime() {
        this.state.now = 0;
        this.lastTime = 0;
        this.currentTime = 0;     
    }
}

if(typeof BaseECSGame != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseECSGame = BaseECSGame;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseECSGame;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseECSGame;
        exports.BaseECSGame = BaseECSGame;
    }
}
        
        // Explicitly register classes to window
        var className = "BaseECSGame";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing BaseECSGame:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "BaseECSGame";
    var className = "BaseECSGame";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.BaseECSGame = foundLibrary;
        window.engine.BaseECSGame = foundLibrary;
        
    } else {
        console.warn("Could not find BaseECSGame after loading");
    }
})();

// Library: Rapier (external module - loaded at runtime)
// Loaded from: https://cdn.skypack.dev/@dimforge/rapier3d-compat
window["RAPIER"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.RAPIER = null; // Placeholder

// Library: three_MeshBVH (local module - bundled)
// Original path: /global/libraries/js/three_MeshBVH.js
// Bundled path: ./modules/three_MeshBVH.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["three_MeshBVH"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.three_MeshBVH = null; // Placeholder

// Library: three_SkeletonUtils (local module - bundled)
// Original path: /global/libraries/js/three_SkeletonUtils.js
// Bundled path: ./modules/three_SkeletonUtils.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["SkeletonUtils"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.SkeletonUtils = null; // Placeholder

// Library: SceneManager (non-module - inline)
// Original path: /global/libraries/js/SceneManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class SceneManager {
    constructor(game) {
        this.game = game;
        this.game.state.currentScene = null;
        this.currentSceneData = null;
        this.currentSceneName = null;
    }

    addEntityToScene(entity){        
        if(this.game.state.currentScene){
            return this.game.state.currentScene.addChild(entity);  
        }
        return entity;
    }

    load(sceneName){
        this.currentSceneName = sceneName;
        if(this.game.currentScene) {
            this.game.currentScene.destroy();
        } 
        this.currentSceneData = this.game.getCollections().scenes[this.currentSceneName];

        
        if(this.currentSceneData.type == "ECS") {
            return this.loadECS();
        }
        this.game.state.currentScene = this.game.spawn("scene", {sceneData: this.currentSceneData});

        const sceneEntities = this.currentSceneData.sceneData;
        sceneEntities.forEach(async (sceneEntity) => {
            let params = {
                "objectType": sceneEntity.objectType,
                "spawnType": sceneEntity.spawnType,
            };
            sceneEntity.components.forEach((entityComp) => {
                params = {...params, ...entityComp.parameters, canvas: this.game.canvas };
            });                              
            let e = this.game.spawn(sceneEntity.type, params);
            this.addEntityToScene(e);  
        });
    }

    loadECS() {
        
        const sceneEntities = this.currentSceneData.sceneData;
          sceneEntities.forEach(async (sceneEntity) => {   

            sceneEntity.classes.forEach((sceneClassDef) => {
                const collectionName = sceneClassDef.collection;
                const baseClassId = sceneClassDef.baseClass;
                const classCollection = this.game.getCollections()[collectionName];
                
                if(baseClassId){
                    const collectionClassDef = classCollection[baseClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };
                    if(engine?.app?.appClasses){
                        const BaseClassDef = engine.app.appClasses[baseClassId];
                        this.game.addClass(baseClassId, BaseClassDef, params);
                    } else {
                        const BaseClassDef = this.game.moduleManager.getCompiledScript(baseClassId, collectionName);
                        this.game.addClass(baseClassId, BaseClassDef, params);
                    }
                }
                for(const collectionClassId in classCollection) {    
                    if(baseClassId && collectionClassId == baseClassId) continue;                
                    const collectionClassDef = classCollection[collectionClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };
                    if(engine?.app?.appClasses){
                        const ClassDef = engine.app.appClasses[collectionClassId];
                        this.game.addClass(collectionClassId, ClassDef, params);
                    } else {
                        const ClassDef = this.game.moduleManager.getCompiledScript(collectionClassId, collectionName);
                        this.game.addClass(collectionClassId, ClassDef, params);
                    }
                }
            });         
            
            sceneEntity.managers.forEach((managerDef) => {
                let params = {...managerDef.parameters, canvas: this.game.canvas };
                let ManagerClass = null;
                if(engine?.app?.appClasses){
                    ManagerClass = engine.app.appClasses[managerDef.type];        
                } else {
                    ManagerClass = this.game.moduleManager.getCompiledScript(managerDef.type, 'managers');
                }     
                const managerInst = new ManagerClass(this.game, this);
                if(managerInst.init){
                    managerInst.init(params);
                }  
            });   

            sceneEntity.systems.forEach((systemDef) => {
                let params = {...systemDef.parameters, canvas: this.game.canvas };
             
                let SystemClass = null;
                if(engine?.app?.appClasses){
                    SystemClass = engine.app.appClasses[systemDef.type];            
                } else {
                    SystemClass = this.game.moduleManager.getCompiledScript(systemDef.type, 'systems');
                }    
                const systemInst = new SystemClass(this.game, this);
   
                this.game.addSystem(systemInst, params);
                
            });   
            this.game.systems.forEach((system) => {
                system.postAllInit();                
            });                      
        });
    }

}
        
        // Explicitly register classes to window
        var className = "SceneManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing SceneManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "SceneManager";
    var className = "SceneManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.SceneManager = foundLibrary;
        window.engine.SceneManager = foundLibrary;
        
    } else {
        console.warn("Could not find SceneManager after loading");
    }
})();

// Library: ShapeFactory (non-module - inline)
// Original path: /global/libraries/js/ShapeFactory.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class ShapeFactory {
    constructor(resourcesPath, palette, textures, libraryClasses, gltfModelScale = 32) {
        this.gltfCache = new Map();
        this.gltfLoader = new THREE_.GLTFLoader();
        this.palette = palette;
        this.textures = textures;
        this.skeleUtils = THREE_.SkeletonUtils;   
        this.urlRoot = "/";
        this.resourcesPath = resourcesPath;
        this.gltfModelScale = gltfModelScale; // Add GLTF scale parameter
    }
    
    setURLRoot(root){
        this.urlRoot = root;
    }

    getResourcesPath(shapeUrl){
        return `${this.urlRoot}${this.resourcesPath}${shapeUrl.replace(this.resourcesPath,'')}`;
    }
    
    setGLTFScale(scale) {
        this.gltfModelScale = scale;
    }
    
    async createMergedGroupFromJSON(model, frameData, groupName) {
        let mergedGroup = this.getMergedGroup(model, frameData, groupName);
        if( mergedGroup){
            return await this.createGroupFromJSON(groupName, mergedGroup);
        } else {
            return null;
        }
    }
    
    async createGroupFromJSON(groupName, groupData) {
        const group = new THREE.Group();
        group.name = groupName;
        group.userData = { isGroup: true };
        // Use Promise.all with map instead of forEach to properly await all shapes
  
        await Promise.all(groupData.shapes.map(async (shape, index) => {
            if (shape.type === 'gltf') {
                await this.handleGLTFShape(shape, index, group);
            } else {
                await this.handlePrimitiveShape(shape, index, group);
            }
        }));
        
        if(groupData.position){            
            group.position.x = groupData.position.x || 0;
            group.position.y = groupData.position.y || 0;
            group.position.z = groupData.position.z || 0;
        }

        if(groupData.rotation){
            group.rotation.x = groupData.rotation.x || 0;
            group.rotation.y = groupData.rotation.y || 0;
            group.rotation.z = groupData.rotation.z || 0;
        }

        if(groupData.scale){
            group.scale.x = groupData.scale.x || 1;
            group.scale.y = groupData.scale.y || 1;
            group.scale.z = groupData.scale.z || 1;
        } 
        return group;
    }

    async handleGLTFShape(shape, index, group) {
        const applyTransformations = async (model, gltf) => {
            // Extract animations
            const animations = gltf.animations;
            
            // Apply individual shape transformations first
            model.position.set(
                (shape.position ? shape.position.x : shape.x) || 0, 
                (shape.position ? shape.position.y : shape.y) || 0, 
                (shape.position ? shape.position.z : shape.z) || 0
            );
            
            // Apply shape-specific scale first, then multiply by global GLTF scale
            const shapeScaleX = (shape.scale ? shape.scale.x : shape.scaleX) || 1;
            const shapeScaleY = (shape.scale ? shape.scale.y : shape.scaleY) || 1;
            const shapeScaleZ = (shape.scale ? shape.scale.z : shape.scaleZ) || 1;
            
            model.scale.set(
                shapeScaleX * this.gltfModelScale,
                shapeScaleY * this.gltfModelScale,
                shapeScaleZ * this.gltfModelScale
            );
            
            model.rotation.set(
                ((shape.rotation ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,
                ((shape.rotation ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,
                ((shape.rotation ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180
            );

            // Store reference to all bones for equipment attachment
            const modelBones = new Map();
            let skinnedMesh = null;
            let skeleton = null;

            model.traverse(child => {
                if (child.isMesh) {
                    // Override material with skinning enabled
                    let map = child.material.map;
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        metalness: shape.metalness || 0.5,
                        roughness: shape.roughness || 0.5,
                        map: map
                    });                           
                    child.material.alphaTest = 0.1;
                    child.material.needsUpdate = true;
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.userData = {
                        isShape: true,
                        index: index,
                        isGLTFChild: true
                    };
                    
                    // Check if this is a skinned mesh
                    if (child.isSkinnedMesh) {
                        skinnedMesh = child;
                        skeleton = child.skeleton;
                    }
                }
                
                // Collect all bones for equipment attachment
                if (child.isBone) {
                    modelBones.set(child.name, child);
                    // Mark bone with special userData for identification
                    child.userData.isCharacterBone = true;
                    child.userData.modelIndex = index;
                }
            });

            // Store skeleton and bone information in model userData
            model.userData = {
                isShape: true,
                index: index,
                isGLTFRoot: true,
                castShadow: true,
                animations: animations,
                bones: modelBones,
                skeleton: skeleton,
                skinnedMesh: skinnedMesh
            };
            group.add(model);

            if (animations && animations.length > 0) {
                const mixer = new THREE.AnimationMixer(model);
                const action = mixer.clipAction(animations[0]);
                action.play();

                model.userData.mixer = mixer;
                
                if (skeleton) {
                    model.userData.skeleton = skeleton;
                    // Ensure bones are accessible for equipment attachment
                    skeleton.bones.forEach(bone => {
                        if (!modelBones.has(bone.name)) {
                            modelBones.set(bone.name, bone);
                            bone.userData.isCharacterBone = true;
                            bone.userData.modelIndex = index;
                        }
                    });
                    if (skeleton && animations && animations.length > 0) {
                        const baked = await this.bakeGpuAnimFromModel(model, animations, skeleton, { fps: 30 });
                        model.userData.gpuAnim = baked; // stash VAT + meta on the GLTF root
                    }
                    
                    // Update bones map in userData
                    model.userData.bones = modelBones;
                }
            }         
        };
    
        if (shape.url) {
            const cached = this.gltfCache.get(shape.url);
            if (cached) {
                const clonedScene = this.skeleUtils.clone(cached.scene);
                await applyTransformations(clonedScene, cached);
            } else if (shape.url && location.hostname !== "") {
                await new Promise((resolve, reject) => {
                    this.gltfLoader.load(
                        this.getResourcesPath(shape.url),
                        async (gltf) => {
                            const clonedScene = this.skeleUtils.clone(gltf.scene);
                            this.gltfCache.set(shape.url, gltf);
                            await applyTransformations(clonedScene, gltf);
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.error(`Failed to load GLTF model at ${shape.url}:`, error);
                            reject(error);
                        }
                    );
                });
            }
        } else {
            return null;
        }
    }

    async handlePrimitiveShape(shape, index, group) {
        let geometry, material;

        let colorToUse = shape.color;
        if(shape.color.paletteColor){
            colorToUse = "#ffffff";
            if(this.palette && this.palette[shape.color.paletteColor]){
                colorToUse = this.palette[shape.color.paletteColor];
            }
        }
        if(shape.texture){
            // If a texture is specified, use it instead of the color
            // If a texture is specified, use it instead of the color
            const textureLoader = new THREE.TextureLoader();
                
            const textureData = this.textures[shape.texture];
            
            if( textureData ) {
                const texture = await new Promise((resolve, reject) => {
                    textureLoader.load(
                        textureData.image,
                        (loadedTexture) => {
                            loadedTexture.wrapS = THREE.RepeatWrapping; // Use ClampToEdge instead of RepeatWrapping
                            loadedTexture.wrapT = THREE.RepeatWrapping; // Use RepeatWrapping for vertical repeat
                            loadedTexture.magFilter = THREE.NearestFilter;
                            loadedTexture.minFilter = THREE.NearestFilter;
                            loadedTexture.generateMipmaps = false;
                            loadedTexture.anisotropy = 1;
                            loadedTexture.needsUpdate = true;

                            const meshWidth = shape.width || 1; // Mesh width in world units
                            const meshHeight = shape.height || 1; // Mesh height in world units
            
                            const textureWidth = loadedTexture.image.width;
                            const textureHeight = loadedTexture.image.height;
                            const pixelsPerUnit = 2;
                            const repeatX = Math.ceil((meshWidth * pixelsPerUnit) / textureWidth);
                            const repeatY = Math.ceil((meshHeight * pixelsPerUnit) / textureHeight);
                            loadedTexture.repeat.set(repeatX, repeatY);
 
                            resolve(loadedTexture);
                        },
                        undefined,
                        (error) => reject(error)
                    );
                });
                material = new THREE.MeshStandardMaterial({ map: texture, color: colorToUse });
            } else {                
                material = new THREE.MeshStandardMaterial({ color: colorToUse });
            }
        } else {            
            // Create material with specified color
            material = new THREE.MeshStandardMaterial({ color: colorToUse });
        }
        const shapeSize = shape.size / 32;
        switch (shape.type) {
            case 'sphere':
                geometry = new THREE.SphereGeometry(shapeSize / 2, 32, 32);
                break;
            case 'cube':
                geometry = new THREE.BoxGeometry(shapeSize, shapeSize, shapeSize);
                break;
            case 'box':
                geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(shapeSize / 2, shapeSize / 2, shape.height, 32);
                break;
            case 'cone':
                geometry = new THREE.ConeGeometry(shapeSize / 2, shape.height, 32);
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(shapeSize / 2, shape.tubeSize || shapeSize / 6, 16, 100);
                break;
            case 'tetrahedron':
                geometry = new THREE.TetrahedronGeometry(shapeSize / 2);
                break;
            default:
                return;
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { isShape: true, castShadow: true, index: index };
        
        // Position and rotation for primitive shapes (no global scale applied)
        mesh.position.set(
            (shape.position && shape.position.x ? shape.position.x : shape.x) || 0, 
            (shape.position && shape.position.y ? shape.position.y : shape.y) || 0, 
            (shape.position && shape.position.z ? shape.position.z : shape.z) || 0
        );
        mesh.rotation.set(
            ((shape.rotation && shape.rotation.x ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,
            ((shape.rotation && shape.rotation.y ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,
            ((shape.rotation && shape.rotation.z ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180
        );
        mesh.scale.set(
            (shape.scale && shape.scale.x ? shape.scale.x : shape.scaleX) || 1,
            (shape.scale && shape.scale.y ? shape.scale.y : shape.scaleY) || 1,
            (shape.scale && shape.scale.z ? shape.scale.z : shape.scaleZ) || 1
        );
        
        group.add(mesh);
    }

    disposeObject(object) {
        object.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }

    getMergedGroup(model, frameData, groupName) {
        const modelGroup = model[groupName];
        if (!modelGroup) {
            delete frameData?.[groupName];
            return null;
        }
    
        frameData = frameData || {};
        let frameGroup = this.initializeFrameGroup(frameData, modelGroup, groupName);
        
        this.cleanupMatchingTransforms(modelGroup, frameGroup);
        const mergedShapes = this.mergeShapes(modelGroup, frameGroup);
        
        this.cleanupEmptyShapes(frameGroup);
        
        const mergedGroup = {
            ...modelGroup,
            ...frameGroup,
            shapes: mergedShapes
        };
    
        if (modelGroup.shapes.length === 0) {
            frameGroup.shapes = [];
        }
    
        const returnVal = JSON.parse(JSON.stringify(mergedGroup));
        this.cleanupFrameData(frameData, frameGroup, groupName);
        
        return returnVal;
    }
    
    initializeFrameGroup(frameData, modelGroup, groupName) {
        if (!frameData[groupName]) {
            frameData[groupName] = JSON.parse(JSON.stringify(modelGroup));
            const frameGroup = frameData[groupName];
            frameGroup.shapes.forEach((shape, index) => {
                shape.id = index;
            });
            return frameGroup;
        }
        return frameData[groupName];
    }
    
    cleanupMatchingTransforms(modelGroup, frameGroup) {
        const properties = ['position', 'rotation', 'scale'];
        properties.forEach(prop => {
            if (JSON.stringify(modelGroup[prop]) === JSON.stringify(frameGroup[prop])) {
                delete frameGroup[prop];
            }
        });
    }
    
    mergeShapes(modelGroup, frameGroup) {
        return modelGroup.shapes.map((modelShape, i) => {
            if (!frameGroup.shapes) {
                return JSON.parse(JSON.stringify(modelShape));
            }
    
            let frameShape = frameGroup.shapes.find(shape => shape.id === i) || { id: i };
            if (!frameGroup.shapes.includes(frameShape)) {
                frameGroup.shapes.push(frameShape);
            }
    
            const mergedShape = this.mergeShapeProperties(modelShape, frameShape);
            this.cleanupMatchingShapeTransforms(modelShape, frameShape);
            
            return JSON.parse(JSON.stringify(mergedShape));
        });
    }
    
    mergeShapeProperties(modelShape, frameShape) {
        const mergedShape = {};
        
        for (const key in modelShape) {
            if (key === 'id') continue;
            
            if (frameShape && frameShape[key] !== undefined && modelShape[key] === frameShape[key]) {
                delete frameShape[key];
                mergedShape[key] = modelShape[key];
            } else if (!frameShape || frameShape[key] === undefined) {
                mergedShape[key] = modelShape[key];
            } else {
                mergedShape[key] = frameShape[key];
            }
        }
    
        return { ...mergedShape, ...frameShape };
    }
    
    cleanupMatchingShapeTransforms(modelShape, frameShape) {
        const transforms = [
            { prop: 'scale', defaultVal: 1, axes: ['X', 'Y', 'Z'] },
            { prop: 'rotation', defaultVal: 0, axes: ['X', 'Y', 'Z'] }
        ];
    
        transforms.forEach(({ prop, defaultVal, axes }) => {
            axes.forEach(axis => {
                const propName = `${prop}${axis}`;
                if (frameShape[propName] === modelShape[propName] || 
                   (frameShape[propName] === defaultVal && modelShape[propName] === undefined)) {
                    delete frameShape[propName];
                }
            });
        });
    }
    
    cleanupEmptyShapes(frameGroup) {
        if (frameGroup.shapes) {
            frameGroup.shapes = frameGroup.shapes.filter(shape => 
                Object.keys(shape).length > 0
            );
            
            if (frameGroup.shapes.length === 0) {
                delete frameGroup.shapes;
            }
        }
    }
    
    cleanupFrameData(frameData, frameGroup, groupName) {
        if (Object.keys(frameGroup).length === 0) {
            delete frameData[groupName];
        }
    }
        // ---- GPU Animation Bake (VAT) ----
    async bakeGpuAnimFromModel(model, animations, skeleton, opts = {}) {
        // opts: { fps=30, useDualQuat=false }  // keep simple: matrices
        const fps = opts.fps ?? 30;
        if (!skeleton || !animations || animations.length === 0) return null;

        const clips = animations; // THREE.AnimationClip[]
        const bones = skeleton.bones;
        const boneCount = bones.length;

        // Build meta per clip: {name, frames, duration}
        const perClipMeta = clips.map(clip => {
            const frames = Math.max(1, Math.ceil((clip.duration || 0) * fps));
            return { name: clip.name, duration: clip.duration, frames };
        });

        // Layout: one big atlas: rows = sum(frames over clips), columns = boneCount * 4 (mat4)
        const totalFrames = perClipMeta.reduce((a, c) => a + c.frames, 0);
        const cols = boneCount * 4;   // 4 texels per bone (mat4 rows)
        const rows = totalFrames;

        // R32F/RGBA32F: weâ€™ll pack mat4 rows into RGBA floats per texel
        const floatCount = rows * cols * 4; // 4 channels per texel
        const data = new Float32Array(floatCount);

        const mixer = new THREE.AnimationMixer(model);
        const tmpQuat = new THREE.Quaternion();
        const tmpPos = new THREE.Vector3();
        const tmpScl = new THREE.Vector3();
        const boneM = new THREE.Matrix4();
        const bindI = skeleton.boneInverses;

        let rowOffset = 0;
        for (let c = 0; c < clips.length; c++) {
            const clip = clips[c];
            const { frames } = perClipMeta[c];
            const action = mixer.clipAction(clip);
            action.play();

            for (let f = 0; f < frames; f++) {
                const t = (f / Math.max(1, frames - 1)) * (clip.duration || 0);
                mixer.setTime(t);

                // ensure world/bone matrices are fresh
                model.updateMatrixWorld(true);
                bones.forEach((b) => b.updateMatrixWorld(true));

                // For each bone: final palette matrix = world * bindInverse (classic skinning)
                for (let b = 0; b < boneCount; b++) {
                    boneM.copy(bones[b].matrixWorld).multiply(bindI[b]);

                    // write 4 rows (vec4 each) into data
                    // column-major three.js Matrix4 elements
                    const e = boneM.elements; // [n11,n12, ... n44], column-major
                    const baseTexel = ((rowOffset + f) * cols + (b * 4)) * 4;
                    // Row0
                    data[baseTexel + 0] = e[0]; data[baseTexel + 1] = e[4]; data[baseTexel + 2] = e[8];  data[baseTexel + 3] = e[12];
                    // Row1
                    data[baseTexel + 4] = e[1]; data[baseTexel + 5] = e[5]; data[baseTexel + 6] = e[9];  data[baseTexel + 7] = e[13];
                    // Row2
                    data[baseTexel + 8] = e[2]; data[baseTexel + 9] = e[6]; data[baseTexel +10] = e[10]; data[baseTexel +11] = e[14];
                    // Row3
                    data[baseTexel +12] = e[3]; data[baseTexel +13] = e[7]; data[baseTexel +14] = e[11]; data[baseTexel +15] = e[15];
                }
            }

            rowOffset += frames;
            action.stop();
        }

        const tex = new THREE.DataTexture(
            data, cols, rows, THREE.RGBAFormat, THREE.FloatType
        );
        tex.needsUpdate = true;
        tex.flipY = false;

        // clip row ranges
        let acc = 0;
        const clipRows = perClipMeta.map(m => {
            const start = acc;
            const end = acc + m.frames; // exclusive
            acc = end;
            return { name: m.name, start, end, frames: m.frames, duration: m.duration };
        });

        return {
            texture: tex,
            bones: boneCount,
            rows, cols,
            fps,
            clips: clipRows
        };
    }

}
        
        // Explicitly register classes to window
        var className = "ShapeFactory";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ShapeFactory:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ShapeFactory";
    var className = "ShapeFactory";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ShapeFactory = foundLibrary;
        window.engine.ShapeFactory = foundLibrary;
        
    } else {
        console.warn("Could not find ShapeFactory after loading");
    }
})();

// Library: ImageManager (non-module - inline)
// Original path: /global/libraries/js/ImageManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        
class ImageManager {
    constructor(app, {imageSize, palette, textures}) {
        this.app = app;
        this.images = {};
        this.imageSize = imageSize || 128;
        // Create a single reusable renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        this.renderer.setSize(this.imageSize, this.imageSize);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        this.renderTarget = new THREE.WebGLRenderTarget(this.imageSize, this.imageSize);
        this.renderTarget.texture.flipY = true;
        
        // Create reusable scene
        this.scene = new THREE.Scene();
        
        // Create reusable cameras for different views
        const cameraDistance = 64;
        const frustumSize = cameraDistance + 16;
        const aspect = 1;

        this.shapeFactory = new GUTS.ShapeFactory(this.app.getResourcesPath(), palette, textures);
        if(location.hostname.indexOf('github') >= 0) {
            this.shapeFactory.setURLRoot("/GUTS/");
        }
        // Create 8 cameras for isometric views at 45-degree intervals
        this.cameras = [];
        for (let i = 0; i < 8; i++) {
            this.cameras.push(new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000));
        }
        
        // Position cameras in a circle around the y-axis at isometric angle
        // Standard isometric angle is about 35.264 degrees (arctan(1/sqrt(2)))
        const isoAngle = Math.atan(1 / Math.sqrt(2));
        const horizDistance = cameraDistance * Math.cos(isoAngle);
        const vertDistance = cameraDistance * Math.sin(isoAngle);
        
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4); // 45-degree increments
            const x = horizDistance * Math.sin(angle);
            const z = horizDistance * Math.cos(angle);
            
            this.cameras[i].position.set(x, vertDistance, z);
            this.cameras[i].lookAt(0, 0, 0);
        }
        
        // Create reusable lights
        this.ambientLight = new THREE.AmbientLight(0xffaaff, .25);
        
        // Create a light group that will rotate with each camera view
        this.lightGroup = new THREE.Group();
        
        // Main directional light
        this.directionalLight = new THREE.DirectionalLight(0xffffaa, .7);
        this.directionalLight.position.set(75, 96, 75);
        this.directionalLight.castShadow = true;
        this.directionalLight.shadow.mapSize.width = 1024;
        this.directionalLight.shadow.mapSize.height = 1024;
        this.directionalLight.shadow.camera.near = 0.5;
        this.directionalLight.shadow.camera.far = 500;
        this.directionalLight.shadow.bias = -0.0005;
        this.directionalLight.shadow.normalBias = 0.02;
        this.directionalLight.shadow.radius = 1;
        this.lightGroup.add(this.directionalLight);
        
        // Fill light
        this.fillLight = new THREE.DirectionalLight(0xffaaff, .5);
        this.fillLight.position.set(-20, 30, -20);
        this.lightGroup.add(this.fillLight);
        
        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        this.ground.rotation.x = -Math.PI / 2;
        this.ground.position.y = 0;
        this.ground.receiveShadow = true;
    }

    clear() {
        images = {};
    }

    dispose() {
        // Proper cleanup when the manager is no longer needed
        if (this.renderer) {
            this.renderer.dispose();
            this.renderer = null;
        }
        if (this.renderTarget) {
            this.renderTarget.dispose();
            this.renderTarget = null;
        }
        if (this.ground && this.ground.geometry) {
            this.ground.geometry.dispose();
            this.ground.material.dispose();
        }
        // Dispose of other reusable resources
        this.cameras = [];
        this.scene = null;
        this.lightGroup = null;
        this.ambientLight = null;
    }

    async loadImages(prefix, config, checkCache = true, cacheResult = true) {

        if (!prefix || !config || typeof config !== 'object') {
            throw new Error('Invalid prefix or config provided to loadImages');
        }
        if( checkCache ) {
            const cachedImages = await this.checkCache(prefix);
            if (cachedImages) {
                this.images = { ...this.images, ...cachedImages };
                return;
            }
        }
        for (const [type, cfg] of Object.entries(config)) {
            if (cfg.render && cfg.render.animations) {
                this.images[`${prefix}_${type}`] = await this.createAnimatedPlaceholder(cfg);
            } else if (cfg.tileMap && cfg.tileMap.terrainTypes) {
                this.images[`${prefix}_${type}`] = await this.createTerrainImages(cfg);
            }
        }
        if(cacheResult) {
            await this.cacheImages(prefix);
        }
    }
    
    async checkCache(prefix) {
        try {
            const response = await fetch(`/cache/${prefix}.json`);
            if (response.ok) {
                const cacheData = await response.json();
                // Convert base64 cached images back to canvases
                return await this.convertBase64ToCanvases(cacheData.images);
            }
            return null;
        } catch (error) {
            return null;
        }
    }

    async convertBase64ToCanvases(cachedImages) {
        const convertedImages = {};
        
        for (const [key, value] of Object.entries(cachedImages)) {
            if (Array.isArray(value)) {
                // Handle terrain tiles
                convertedImages[key] = await Promise.all(value.map(async (terrain) => {
                    const sprites = await Promise.all(terrain.sprites.map(async (base64) => {
                        const canvas = document.createElement('canvas');
                        canvas.width = canvas.height = 24; // Match tileWidth from createTerrainImages
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                ctx.drawImage(img, 0, 0);
                                resolve();
                            };
                            img.onerror = reject;
                            img.src = base64;
                        });
                        
                        return canvas;
                    }));
                    
                    return {
                        type: terrain.type,
                        sprites
                    };
                }));
            } else if (typeof value === 'object') {
                // Handle animations
                const animations = {};
                for (const [animType, frames] of Object.entries(value)) {
                    animations[animType] = await Promise.all(frames.map(async (frameSet) => {
                        return Promise.all(frameSet.map(async (base64) => {
                            const canvas = document.createElement('canvas');
                            canvas.width = canvas.height = this.imageSize;
                            const ctx = canvas.getContext('2d');
                            const img = new Image();
                            
                            await new Promise((resolve, reject) => {
                                img.onload = () => {
                                    ctx.drawImage(img, 0, 0);
                                    resolve();
                                };
                                img.onerror = reject;
                                img.src = base64;
                            });
                            
                            return canvas;
                        }));
                    }));
                }
                convertedImages[key] = animations;
            }
        }
        
        return convertedImages;
    }
    async cacheImages(prefix) {
        const base64Images = {};
        
        for (const [key, value] of Object.entries(this.images)) {
            if (key.startsWith(prefix)) {
                if (Array.isArray(value) && value[0]?.type && value[0]?.sprites) {
                    // Handle terrain tiles
                    base64Images[key] = value.map(terrain => ({
                        type: terrain.type,
                        sprites: terrain.sprites.map(canvas => canvas.toDataURL('image/png'))
                    }));
                } else if (typeof value === 'object' && value !== null) {
                    // Handle animations
                    const animationData = {};
                    for (const [animType, frames] of Object.entries(value)) {
                        animationData[animType] = frames.map(frameSet => 
                            frameSet.map(canvas => canvas.toDataURL('image/png'))
                        );
                    }
                    base64Images[key] = animationData;
                }
            }
        }

        try {
            await fetch('/api/cache', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    prefix,
                    images: base64Images
                })
            });
        } catch (error) {
            console.error('Error caching images:', error);
        }
    }
    // In the ImageManager class
    async createTerrainImages(config) {
        let terrainTiles = [];
        const tileWidth = 24;

        // Create a map of terrain type to its image data first
        const terrainMap = {};
        await Promise.all(config.tileMap.terrainTypes.map(async (terrainType, terrainIndex) => {
            const pixelData = terrainType.image;
            if (pixelData && pixelData.length > 0) {
                let sprites = new Array(8);
                
                await Promise.all(pixelData.map(async (imagePixelData, spriteIdx) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = tileWidth;
                    const ctx = canvas.getContext('2d');

                    if (!imagePixelData.startsWith('data:image/')) {
                        imagePixelData = 'data:image/png;base64,' + imagePixelData;
                    }
                    img.src = imagePixelData;

                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0);
                            sprites[spriteIdx] = canvas;
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image for ${terrainType.type} at index ${spriteIdx}`);
                            sprites[spriteIdx] = canvas; // Store empty canvas on error
                            resolve(); // Don't reject, just move on
                        };
                    });
                }));

                // Store by index and type for more reliable lookup
                terrainTiles[terrainIndex] = { 
                    type: terrainType.type,
                    sprites: sprites 
                };
            } else {
                // Create transparent placeholder for types without images
                // Don't use terrainType.color as it causes color bleed at tile edges
                const sprites = new Array(8).fill().map(() => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = tileWidth;
                    const ctx = canvas.getContext('2d');
                    // Leave canvas transparent (don't fillRect)
                    // This prevents layer colors from bleeding through at edges
                    return canvas;
                });
                
                terrainTiles[terrainIndex] = {
                    type: terrainType.type,
                    sprites: sprites
                };
            }
        }));

        // Make sure there are no gaps in the array
        return terrainTiles.filter(Boolean);
    }
    async createAnimatedPlaceholder(config) {
        const animations = {};
        
        if(config.shadows === false) {
            this.ground.receiveShadow = false;
        } else {
            this.ground.receiveShadow = true;
        }
        for (const [animType, frames] of Object.entries(config.render.animations)) {
            animations[animType] = [];
            let i = 0;
            for (const frame of frames) {
                const frameImages = await this.captureObjectImagesFromJSON(config.render.model, frame);
                const canvases = frameImages.map(img => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = this.imageSize;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    return canvas;
                });                
                animations[animType].push(canvases); // Array of 8 canvases per frame
            }
        }
        return animations; // { "idle": [[canvas0, canvas1, canvas2, canvas3, ...], ...], "walk": [...] }
    }

    getImages(prefix, type) {
        return this.images[`${prefix}_${type}`]; // Returns animation object
    }
    async captureObjectImagesFromJSON(model, frameData) {
        const size = this.imageSize;
        // Clear the scene
        while (this.scene.children.length > 0) {
            const object = this.scene.children[0];
            this.scene.remove(object);
        }
        
        // Add reusable elements to scene
        this.scene.add(this.ground);
        this.scene.add(this.ambientLight);
        this.scene.add(this.lightGroup);
        
        // Create objects from the JSON data
        const objectGroup = await this.createObjectsFromJSON(model, frameData, this.scene);

        
        const images = [];
        
        // For each camera view, rotate the light group to match camera orientation
        for (let i = 0; i < this.cameras.length; i++) {
            const camera = this.cameras[i];
            
            // Reset light group rotation
            this.lightGroup.rotation.set(0, 0, 0);
            
            // Rotate light group to match camera position
            // Calculate angle based on camera index (8 positions at 45-degree intervals)
            // Rotate 45 degrees CLOCKWISE (subtract Ï€/4 instead of adding)
            const angle = (i * Math.PI / 4); 
            this.lightGroup.rotation.y = angle;
            
            // Before rendering with each camera, update shadow camera frustum
            const d = 100;
            this.directionalLight.shadow.camera.left = -d;
            this.directionalLight.shadow.camera.right = d;
            this.directionalLight.shadow.camera.top = d;
            this.directionalLight.shadow.camera.bottom = -d;
            // After rotating lightGroup in the camera loop
            this.directionalLight.shadow.camera.updateProjectionMatrix();
            this.directionalLight.shadow.camera.updateMatrixWorld();
            this.directionalLight.target.position.set(0, 0, 0);
            this.directionalLight.target.updateMatrixWorld();
            // Render and capture the image
            this.renderer.setRenderTarget(this.renderTarget);
            this.renderer.render(this.scene, camera);
            const buffer = new Uint8Array(size * size * 4);
            this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, size, size, buffer);
            
            // Flip the buffer (y-axis)
            const flippedBuffer = new Uint8Array(size * size * 4);
            for (let y = 0; y < size; y++) {
                const srcRowStart = y * size * 4;
                const destRowStart = (size - 1 - y) * size * 4;
                flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
            }
            
            const imageData = new ImageData(new Uint8ClampedArray(flippedBuffer), size, size);
            const imageBitmap = await createImageBitmap(imageData);
            images.push(imageBitmap);
        }
        if( this.renderer) this.renderer.setRenderTarget(null);
        
        // Cleanup object geometries and materials
        this.shapeFactory.disposeObject(objectGroup);
        
        // Remove object group from scene
        if( this.scene ) this.scene.remove(objectGroup);
        
        return images;
    }

    /**
     * Creates 3D objects from shape data.
     * @param {Object} frameData - The JSON object containing frame definitions.
     * @returns {THREE.Group} - A group containing all 3D objects.
     */
  
    async createObjectsFromJSON(model, frameData, scene) {
        const rootGroup = new THREE.Group();
        
        for(const groupName in model) {
            const group = await this.shapeFactory.createMergedGroupFromJSON(model, frameData, groupName);
            if(group){
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true; // or set this selectively for objects that should cast shadows
                        child.receiveShadow = true; // for objects that should receive shadows
                    }
                });
                rootGroup.add(group);
            }
        }

        scene.add(rootGroup);
    
        return rootGroup;
    }
   
}

        
        // Explicitly register classes to window
        var className = "ImageManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ImageManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ImageManager";
    var className = "ImageManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ImageManager = foundLibrary;
        window.engine.ImageManager = foundLibrary;
        
    } else {
        console.warn("Could not find ImageManager after loading");
    }
})();

// Library: SpatialGrid (non-module - inline)
// Original path: /global/libraries/js/SpatialGrid.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
         
    class SpatialGrid {
        constructor(worldSize, cellSize) {
            this.cellSize = cellSize;
            this.cols = worldSize;
            this.rows = worldSize;
            this.grid = new Array(this.cols * this.rows).fill().map(() => []);
            
            // Track which cell each entity is in
            this.entityCells = new Map(); // Map of entity -> cell index
        }
        
        getIndex(x, y) {
            return y * this.cols + x;
        }

        insert(entity) {
            const newIndex = this.getIndex(entity.transform.gridPosition.x, entity.transform.gridPosition.y);
            const oldIndex = this.entityCells.get(entity);
            
            // If entity moved to a new cell
            if (oldIndex !== newIndex) {
                // Remove from old cell if it exists
                if (oldIndex !== undefined) {
                    const oldCell = this.grid[oldIndex];
                    const entityIndex = oldCell.indexOf(entity);
                    if (entityIndex !== -1) {
                        oldCell.splice(entityIndex, 1);
                    }
                }
                
                // Add to new cell
                if (newIndex >= 0 && newIndex < this.grid.length) {
                    this.grid[newIndex].push(entity);
                    this.entityCells.set(entity, newIndex);
                }
            }
        }
        
        remove(entity) {
            const index = this.entityCells.get(entity);
            if (index !== undefined) {
                const cell = this.grid[index];
                const entityIndex = cell.indexOf(entity);
                if (entityIndex !== -1) {
                    cell.splice(entityIndex, 1);
                }
                this.entityCells.delete(entity);
            }
        }
        getNearbyEntities(x, y, radius, type="") {
            const nearby = [];
            // Get cells that could contain entities within radius
            const startX = Math.max(0, Math.floor((x - radius)));
            const endX = Math.min(this.cols - 1, Math.floor((x + radius)));
            const startY = Math.max(0, Math.floor((y - radius)));
            const endY = Math.min(this.rows - 1, Math.floor((y + radius)));
       
            // Collect potential candidates from relevant cells
            for (let row = startY; row <= endY; row++) {
                for (let col = startX; col <= endX; col++) {
                    const index = row * this.cols + col;
                    if (index >= 0 && index < this.grid.length) {
                        for (let entity of this.grid[index]) {
                            const dx = (entity.transform.gridPosition.x) - (x + .5);
                            const dy = (entity.transform.gridPosition.y) - (y + .5);
                            const distSquared = dx * dx + dy * dy;
                            
                            if (distSquared <= radius * radius) {
                                if(type) {
                                    if( entity.type == type ) {
                                        nearby.push(entity);
                                    }
                                } else {
                                    nearby.push(entity);
                                }
                            }                            
                        }
                    }
                }
            }
            
            return nearby;
        }
        clear() {
            this.grid = this.grid.map(() => []);
            this.entityCells.clear();
        }
        
        // Optional: Only clear but maintain all entity positions
        // Useful for when reusing the same grid across updates
        resetKeepingEntities() {
            const allEntities = [];
            this.entityCells.forEach((_, entity) => {
                allEntities.push(entity);
            });
            
            this.clear();
            
            allEntities.forEach(entity => {
                this.insert(entity);
            });
        }
    }

        
        // Explicitly register classes to window
        var className = "SpatialGrid";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing SpatialGrid:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "SpatialGrid";
    var className = "SpatialGrid";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.SpatialGrid = foundLibrary;
        window.engine.SpatialGrid = foundLibrary;
        
    } else {
        console.warn("Could not find SpatialGrid after loading");
    }
})();

// Library: CoordinateTranslator (non-module - inline)
// Original path: /global/libraries/js/CoordinateTranslator.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class CoordinateTranslator {
    constructor(config, mapSize, isometric = false) {
        this.isometric = isometric;
        this.tileWidth = config.gridSize;
        this.tileHeight = config.gridSize * 0.5;
        this.canvasWidth = config.canvasWidth;
        this.canvasHeight = config.canvasHeight;
        this.mapSize = mapSize;
    }

    // Pixel (top-down) to Grid
    pixelToGrid(pixelX, pixelY) {
        return {
            x: pixelX / this.tileWidth,
            y: pixelY / this.tileWidth
        };
    }

    // Grid to Isometric (with vertical centering)
    gridToIso(gridX, gridY) {
        // If not isometric, return grid coordinates as-is
        if (!this.isometric) {
            return { x: gridX * this.tileWidth, y: gridY * this.tileWidth };
        }

        const isoX = (gridX - gridY) * (this.tileWidth / 2) + this.canvasWidth / 2;
       
        // Calculate the height the grid would occupy
        const totalGridHeight = this.mapSize * this.tileHeight;
       
        // Center vertically by adding an offset
        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;
       
        const isoY = (gridX + gridY) * (this.tileHeight / 2) + verticalOffset;
       
        return { x: isoX, y: isoY };
    }

    // Pixel (top-down) to Isometric
    pixelToIso(pixelX, pixelY) {
        if(!this.isometric){
            return {
                x: pixelX + ( this.canvasWidth - this.mapSize * this.tileWidth) / 2,
                y: pixelY + ( this.canvasHeight - this.mapSize * this.tileWidth) / 2
            }
        }
        const grid = this.pixelToGrid(pixelX, pixelY);
        return this.gridToIso(grid.x, grid.y);
    }

    isoToGrid(isoX, isoY) {
        // If not isometric, convert directly to grid
        if (!this.isometric) {
            return {
                x: isoX / this.tileWidth,
                y: isoY / this.tileWidth
            };
        }

        const adjustedX = isoX - this.canvasWidth / 2;
       
        // Calculate the same vertical offset as in gridToIso
        const totalGridHeight = this.mapSize * this.tileHeight;
        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;
       
        // Subtract the offset before conversion
        const adjustedY = isoY - verticalOffset;
       
        const gridX = (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2;
        const gridY = (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2;
       
        return { x: gridX, y: gridY };
    }

    isoToPixel(isoX, isoY) {
        const grid = this.isoToGrid(isoX, isoY);
        return {
            x: grid.x * this.tileWidth,
            y: grid.y * this.tileWidth
        };
    }

    // Snap grid coordinates to nearest integer
    snapToGrid(gridX, gridY) {
        return { x: Math.floor(gridX), y: Math.floor(gridY) };
    }
}
        
        // Explicitly register classes to window
        var className = "CoordinateTranslator";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing CoordinateTranslator:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "CoordinateTranslator";
    var className = "CoordinateTranslator";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.CoordinateTranslator = foundLibrary;
        window.engine.CoordinateTranslator = foundLibrary;
        
    } else {
        console.warn("Could not find CoordinateTranslator after loading");
    }
})();

// Library: CanvasUtility (non-module - inline)
// Original path: /global/libraries/js/CanvasUtility.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class CanvasUtility {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
		this.ctx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency
        
		this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
		this.tempCtx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency
    }

    setSize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
    }
    paintTexture(imageData) {
        this.setSize(imageData.width, imageData.height);
        this.ctx.putImageData(imageData, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }
	rotateTexture(imageData, angle) {
        // Set the canvas size to accommodate the rotated image
        // Note: If the rotation results in a change in width/height, adjust these values accordingly
        this.setSize(imageData.width, imageData.height);

        // Draw the original imageData to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Apply the rotation
        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
        this.ctx.rotate(angle);
        this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);

        // Create a temporary canvas to hold the current state
        this.tempCanvas.width = this.canvas.width;
        this.tempCanvas.height = this.canvas.height;
        this.tempCtx.drawImage(this.canvas, 0, 0);

        // Clear the main canvas and draw the rotated image
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.tempCanvas, 0, 0);

        // Capture the rotated image data
        let rotatedData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
 

        return rotatedData;
    }
	flipTextureVertical(imageData) {
        this.setSize(imageData.width, imageData.height);

        // Draw the original image data to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Use an off-screen canvas to perform the flip
        this.tempCanvas.width = imageData.width;
        this.tempCanvas.height = imageData.height;
  
        // Apply the flip on the off-screen canvas
        this.tempCtx.translate(0, this.tempCanvas.height);
		this.tempCtx.scale(1, -1);
		this.tempCtx.drawImage(this.canvas, 0, 0);

        // Extract the flipped image data
        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
    }

    flipTextureHorizontal(imageData) {
        this.setSize(imageData.width, imageData.height);

        // Draw the original image data to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Use an off-screen canvas to perform the flip
        this.tempCanvas.width = imageData.width;
        this.tempCanvas.height = imageData.height;
        // Apply the flip on the off-screen canvas
		this.tempCtx.translate(this.tempCanvas.width, 0);
		this.tempCtx.scale(-1, 1);
		this.tempCtx.drawImage(this.canvas, 0, 0);

        // Extract the flipped image data
        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
    }
	drawImage(image) {
        this.setSize(image.width, image.height);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

	rotateImage(image, angle) {
		this.setSize(image.width, image.height);
		// Set up the rotation
		this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
		this.ctx.rotate(angle);
		this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
		this.ctx.fillStyle = 'rgba(0, 0, 0, 0)'; // Fully transparent
		this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
	
		// Draw the image
		this.ctx.drawImage(image, 0, 0);
		return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
	}

    flipImageVertical(image) {
        this.setSize(image.width, image.height);
        this.ctx.translate(0, this.canvas.height);
        this.ctx.scale(1, -1);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

    flipCanvasVertical() {
        this.ctx.translate(0, this.canvas.height);
        this.ctx.scale(1, -1);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

    flipImageHorizontal(image) {
        this.setSize(image.width, image.height);
        this.ctx.translate(this.canvas.width, 0);
        this.ctx.scale(-1, 1);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }
}
        
        // Explicitly register classes to window
        var className = "CanvasUtility";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing CanvasUtility:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "CanvasUtility";
    var className = "CanvasUtility";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.CanvasUtility = foundLibrary;
        window.engine.CanvasUtility = foundLibrary;
        
    } else {
        console.warn("Could not find CanvasUtility after loading");
    }
})();

// Library: TerrainImageProcessor (non-module - inline)
// Original path: /global/libraries/js/TerrainImageProcessor.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class TerrainImageProcessor {
  //Utility function to convert terrain tile spritesheets to and from base64 encoding
    constructor(app, options = {}) {
        this.app = app;
        // Configurable tile dimensions with defaults
        this.tileWidth = options.tileWidth || 24;
        this.tileHeight = options.tileHeight || 24;
        this.tilesX = options.tilesX || 4;
        this.tilesY = options.tilesY || 1; // Will be auto-detected

        // Bind methods to ensure correct context
        this.convertCanvasToBase64Tiles = this.convertCanvasToBase64Tiles.bind(this);
        this.displayStoredBase64Tiles = this.displayStoredBase64Tiles.bind(this);

        // Element references
        this.output = null;
        this.displayImage = null;
    }

    // Initialize the processor with DOM elements
    initialize(outputElement, displayImageElement) {
        this.output = outputElement;
        this.displayImage = displayImageElement;

        // Optional: Add custom event listener
        document.body.addEventListener('editTerrainImage', this.displayStoredBase64Tiles);
    }

    // Detect if the image is 4x1 or 4x2 based on aspect ratio
    detectSpriteSheetLayout(img) {
        const aspectRatio = img.width / img.height;
        
        // For 4x1 layout: width should be 4x tile width, height should be 1x tile height
        // For 4x2 layout: width should be 4x tile width, height should be 2x tile height
        
        // Calculate expected dimensions
        const expectedWidth4x1 = this.tileWidth * 4;
        const expectedHeight4x1 = this.tileHeight * 1;
        const expectedWidth4x2 = this.tileWidth * 4;
        const expectedHeight4x2 = this.tileHeight * 2;
        
        // Check if dimensions match 4x2 layout
        if (img.width === expectedWidth4x2 && img.height === expectedHeight4x2) {
            return { tilesX: 4, tilesY: 2, layout: '4x2' };
        }
        
        // Check if dimensions match 4x1 layout
        if (img.width === expectedWidth4x1 && img.height === expectedHeight4x1) {
            return { tilesX: 4, tilesY: 1, layout: '4x1' };
        }
        
        // Fallback: determine based on aspect ratio
        // 4x1 should have aspect ratio of 4:1
        // 4x2 should have aspect ratio of 2:1
        if (Math.abs(aspectRatio - 4.0) < Math.abs(aspectRatio - 2.0)) {
            return { tilesX: 4, tilesY: 1, layout: '4x1' };
        } else {
            return { tilesX: 4, tilesY: 2, layout: '4x2' };
        }
    }

    processImage(imageUrl) {
        const img = new Image();
        img.onload = () => {
            // Detect the sprite sheet layout
            const layout = this.detectSpriteSheetLayout(img);
            console.log(`Detected sprite sheet layout: ${layout.layout}`);
            
            // Update internal properties
            this.tilesX = layout.tilesX;
            this.tilesY = layout.tilesY;
            
            // Create a temporary canvas to process the image
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;

            const ctx = canvas.getContext('2d');
            
            // Set transparent background
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the uploaded image at original size
            ctx.drawImage(img, 0, 0);

            // Convert to base64 tiles based on detected layout
            const base64Tiles = this.convertCanvasToBase64Tiles(canvas, layout);
            
            // Save base64 tiles to output
            this.output.value = JSON.stringify(base64Tiles);

            // Display the original uploaded image
            this.displayImage.src = imageUrl;
        };
        img.src = imageUrl;
    }

    // Convert canvas to array of base64 tiles with layout detection
    convertCanvasToBase64Tiles(canvas, layout, format = 'png', quality = 1.0) {
        const base64Tiles = [];

        if (layout.layout === '4x2') {
            // Process 4x2 layout: use both provided rows
            
            // First row (top tiles)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

            // Second row (bottom tiles)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = this.tileHeight; // Second row

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

        } else {
            // Process 4x1 layout: use first row and create flipped versions
            
            // First row of tiles (normal)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

            // Create vertically flipped versions of the first row
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                // Create flipped image data
                const flippedImageData = this.verticallyFlipImageData(imageData);

                tileCtx.putImageData(flippedImageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }
        }

        return base64Tiles;
    }

    // Helper method to vertically flip ImageData
    verticallyFlipImageData(imageData) {
        const flippedImageData = new ImageData(this.tileWidth, this.tileHeight);
        
        for (let y = 0; y < this.tileHeight; y++) {
            for (let x = 0; x < this.tileWidth; x++) {
                const srcIndex = (y * this.tileWidth + x) * 4;
                const destIndex = ((this.tileHeight - 1 - y) * this.tileWidth + x) * 4;
                
                flippedImageData.data[destIndex] = imageData.data[srcIndex];         // R
                flippedImageData.data[destIndex + 1] = imageData.data[srcIndex + 1]; // G
                flippedImageData.data[destIndex + 2] = imageData.data[srcIndex + 2]; // B
                flippedImageData.data[destIndex + 3] = imageData.data[srcIndex + 3]; // A
            }
        }
        
        return flippedImageData;
    }

    // Display stored base64 tiles
    displayStoredBase64Tiles() {
        // Check if there are stored base64 tiles
        if (!this.output.value) return;

        try {
            // Parse the stored base64 tiles
            const base64Tiles = JSON.parse(this.output.value);

            // Validate the number of tiles
            if (!Array.isArray(base64Tiles) || base64Tiles.length !== 8) {
                console.error('Invalid base64 tiles array - expected 8 tiles, got:', base64Tiles.length);
                return;
            }

            // Create canvas for display - always show as 4x2 for consistency
            const canvas = document.createElement('canvas');
            canvas.width = this.tileWidth * 4;
            canvas.height = this.tileHeight * 2;
            const ctx = canvas.getContext('2d');

            let loadedImages = 0;
            const tileImages = new Array(8).fill(null);

            base64Tiles.forEach((base64String, index) => {
                const tileImg = new Image();
                tileImg.onload = () => {
                    tileImages[index] = tileImg;
                    loadedImages++;

                    // Once all images are loaded, draw them in 4x2 layout
                    if (loadedImages === base64Tiles.length) {
                        // Draw first row of tiles (indices 0-3)
                        for (let x = 0; x < 4; x++) {
                            ctx.drawImage(tileImages[x], x * this.tileWidth, 0);
                        }

                        // Draw second row of tiles (indices 4-7)
                        for (let x = 0; x < 4; x++) {
                            ctx.drawImage(tileImages[x + 4], x * this.tileWidth, this.tileHeight);
                        }

                        // Set the final image
                        this.displayImage.src = canvas.toDataURL('image/png');
                    }
                };

                // Ensure the base64 string has the correct data URL prefix
                let dataUrl = base64String;
                if (!base64String.startsWith('data:image/')) {
                    dataUrl = 'data:image/png;base64,' + base64String;
                }
                tileImg.src = dataUrl;
            });
        } catch (error) {
            console.error('Error parsing stored base64 tiles:', error);
        }
    }

    // Helper method to get layout info for external use
    getLayoutInfo() {
        return {
            tilesX: this.tilesX,
            tilesY: this.tilesY,
            tileWidth: this.tileWidth,
            tileHeight: this.tileHeight
        };
    }

    // Method to manually set layout (useful for testing or specific requirements)
    setLayout(tilesX, tilesY) {
        this.tilesX = tilesX;
        this.tilesY = tilesY;
    }

    // Method to clean up event listeners if needed
    destroy() {
        document.body.removeEventListener('editTerrainImage', this.displayStoredBase64Tiles);
    }
}
        
        // Explicitly register classes to window
        var className = "TerrainImageProcessor";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing TerrainImageProcessor:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "TerrainImageProcessor";
    var className = "TerrainImageProcessor";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.TerrainImageProcessor = foundLibrary;
        window.engine.TerrainImageProcessor = foundLibrary;
        
    } else {
        console.warn("Could not find TerrainImageProcessor after loading");
    }
})();

// Library: TileMap (non-module - inline)
// Original path: /global/libraries/js/TileMap.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class TileMap {

  constructor(app, config, { CanvasUtility }) {
   	this.app = app;
    this.config = config;
    this.engineClasses = {
 			"CanvasUtility": CanvasUtility
    } 
  }
	init(canvas, tileSize, layerSpriteSheets, isometric) {
		this.isometric = isometric;
		this.canvas = canvas;
		this.tileSize = tileSize;
		this.numColumns = 0;
		this.layerSpriteSheets = layerSpriteSheets;
		this.tileMap = [];
		this.layerTextures = [];
		this.baseAtoms = []; // Store base atoms per terrain type
		this.canvasUtility = new (this.engineClasses.CanvasUtility)();

		// Initialize height map canvas
		this.heightMapCanvas = null;
		this.heightMapCtx = null;
		
		this.TileAnalysis = class {
			constructor() {
			  this.heightIndex = 0;
			  this.neighborLowerCount = 0;
			  this.cornerLowerCount = 0;
			  this.topHeight = 0;
			  this.leftHeight = 0;
			  this.rightHeight = 0;
			  this.botHeight = 0;
			  this.topLeftHeight = 0;
			  this.topRightHeight = 0;
			  this.botLeftHeight = 0;
			  this.botRightHeight = 0;
			  this.topLess = false;
			  this.leftLess = false;
			  this.rightLess = false;
			  this.botLess = false;
			  this.cornerTopLeftLess = false;
			  this.cornerTopRightLess = false;
			  this.cornerBottomLeftLess = false;
			  this.cornerBottomRightLess = false;
			}
		};

		this.TileTransforms = {
			None: 0,
			ClockWise90: 1,
			CounterClockWise90: 2,
			Rotate180: 3,
			FlipHorizontal: 4,
			FlipVertical: 5,
		};
		
		this.TileAtom = {
			Full: 0,
			OneCorner: 1,
			TwoCorner: 2,
			ThreeCorner: 3,
			FullVariation: 4,
			OneCornerBot: 5,
			TwoCornerBot: 6,
			ThreeCornerBot: 7
		};
		
		this.TileMolecule = {
			Full: 0,
			Corner: 1,
			Edge: 2,
			Tunnel: 3,
			TwoSides: 4,
			Penninsula: 5,
			Island: 6,
		};
		
		this.TileCliffMolecules = {
			Full: 0,
			CornerTL: 1,
			CornerTR: 2,
			CornerBL: 3,
			CornerBR: 4,
			EdgeT: 5,
			EdgeL: 6,
			EdgeR: 7,
			EdgeB: 8,
			TunnelH: 9,
			TunnelV: 10,
			TwoSidesTL: 11,
			TwoSidesTR: 12,
			TwoSidesBL: 13,
			TwoSidesBR: 14,    
			PenninsulaT: 15,
			PenninsulaL: 16,
			PenninsulaR: 17,
			PenninsulaB: 18,
			Island: 19,
			FullVariation: 20, // Added for random full tile variation
		};
	}

	initializeHeightMapCanvas() {
		// Create height map canvas with same dimensions as main canvas
		this.heightMapCanvas = document.createElement('canvas');
		this.heightMapCanvas.width = this.canvas.width;
		this.heightMapCanvas.height = this.canvas.height;
		this.heightMapCtx = this.heightMapCanvas.getContext('2d');
		
		// Set properties for better performance when reading pixel data
		this.heightMapCanvas.setAttribute('willReadFrequently', true);
		this.heightMapCtx = this.heightMapCanvas.getContext('2d', { willReadFrequently: true });
		
		// Initialize with black (height 0)
		this.heightMapCtx.fillStyle = 'black';
		this.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);
	}

	updateHeightMapForTile(x, y, heightIndex) {
		if (!this.heightMapCtx) return;
		
		// Convert height index to grayscale value (0-255)
		// Assuming we have up to 256 different height levels
		const heightValue = Math.min(255, Math.max(0, heightIndex * 32)); // Scale as needed
		const heightColor = `rgb(${heightValue}, ${heightValue}, ${heightValue})`;
		
		this.heightMapCtx.fillStyle = heightColor;
		this.heightMapCtx.fillRect(x, y, this.tileSize, this.tileSize);
	}

	getHeightAtPixel(x, y) {
		if (!this.heightMapCtx) return 0;
		
		// Clamp coordinates to canvas bounds
		x = Math.max(0, Math.min(this.heightMapCanvas.width - 1, Math.floor(x)));
		y = Math.max(0, Math.min(this.heightMapCanvas.height - 1, Math.floor(y)));
		
		const imageData = this.heightMapCtx.getImageData(x, y, 1, 1);
		const heightValue = imageData.data[0]; // Red channel (same as green and blue in grayscale)
		
		// Convert back to height index
		return Math.floor(heightValue / 32); // Inverse of the scaling used in updateHeightMapForTile
	}

	getHeightMapImageData() {
		if (!this.heightMapCtx) return null;
		return this.heightMapCtx.getImageData(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);
	}

    draw(map, heightMap = null){
		this.tileMap = map;
		this.heightMap = heightMap; // NEW: Store heightMap separately
		this.numColumns = this.tileMap.length;

		// Initialize height map canvas if not already done
		if (!this.heightMapCanvas) {
			this.initializeHeightMapCanvas();
		}

		// Clear height map canvas
		this.heightMapCtx.fillStyle = 'black';
		this.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);

		// Load all textures
		if(this.layerTextures.length == 0 && this.layerSpriteSheets) {
			this.layerSpriteSheets.forEach((layerSprites, index) => {
				const result = this.buildBaseMolecules(layerSprites.sprites);
				this.layerTextures[index] = result.molecules;
				this.baseAtoms[index] = result.baseAtoms;
			});
		}

		let analyzedMap = this.analyzeMap();
		this.drawMap(analyzedMap);
        if(this.isometric){
          //  this.drawIsometric();
        }
    }

    drawIsometric() {
        let ctx = this.canvas.getContext('2d');
        // Save the original state
        ctx.save();
        
        // Create an off-screen canvas to hold original drawing
        const offscreen = document.createElement('canvas');
        offscreen.width = this.canvas.width;
        offscreen.height = this.canvas.height;
        const offCtx = offscreen.getContext('2d');
        offCtx.drawImage(this.canvas, 0, 0);
        
        // Clear the main canvas
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Move to center for rotation
        ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
        
        // Apply isometric transformation
        const scale = .56;    // Adjust overall size
        const isoAngle = Math.atan(1 / 2); // â‰ˆ 26.565Â° (classic isometric angle)
        const cosA = Math.cos(isoAngle);   // â‰ˆ 0.8944
        const sinA = Math.sin(isoAngle);   // â‰ˆ 0.4472
        
        ctx.transform(
            cosA * scale,    // scaleX
            sinA * scale,    // skewY
            -cosA * scale,   // skewX
            sinA * scale,    // scaleY
            0,               // translateX
            0                // translateY
        );
        
        // Draw the transformed image centered
        ctx.drawImage(offscreen, -this.canvas.width / 2, -this.canvas.height / 2);
        
        // Restore original state
        ctx.restore();
    }

    drawTexture(texture, x, y) {
		ctx.drawImage(texture, x, y, this.tileSize / 2, this.tileSize / 2); // Assuming each atom is 256x256
    }

    // Function to generate a molecule texture for various molecule ty
	buildBaseMolecules(sprites) {
		// Define texture objects
		const fullTexture = document.createElement("canvas");

		const oneCornerTexture = document.createElement("canvas");
		const twoCornerTexture = document.createElement("canvas");
		const threeCornerTexture = document.createElement("canvas");

		const oneCornerBotTexture = document.createElement("canvas");
		const twoCornerBotTexture = document.createElement("canvas");
		const threeCornerBotTexture = document.createElement("canvas");

		fullTexture.setAttribute('willReadFrequently', true); 

		oneCornerTexture.setAttribute('willReadFrequently', true); 
		twoCornerTexture.setAttribute('willReadFrequently', true); 
		threeCornerTexture.setAttribute('willReadFrequently', true); 

		oneCornerBotTexture.setAttribute('willReadFrequently', true); 
		twoCornerBotTexture.setAttribute('willReadFrequently', true); 
		threeCornerBotTexture.setAttribute('willReadFrequently', true); 

		// Set the texture sizes
		const spriteResolution = this.tileSize / 2;
		const finalTileBaseResolution = spriteResolution * 2;

		fullTexture.width = spriteResolution;
		fullTexture.height = spriteResolution;

		oneCornerTexture.width = spriteResolution;
		oneCornerTexture.height = spriteResolution;

		twoCornerTexture.width = spriteResolution;
		twoCornerTexture.height = spriteResolution;

		threeCornerTexture.width = spriteResolution;
		threeCornerTexture.height = spriteResolution;	

		oneCornerBotTexture.width = spriteResolution;
		oneCornerBotTexture.height = spriteResolution;	

		twoCornerBotTexture.width = spriteResolution;
		twoCornerBotTexture.height = spriteResolution;	

		threeCornerBotTexture.width = spriteResolution;
		threeCornerBotTexture.height = spriteResolution;	
		
		// Get sprite textures
		const fullSprite = sprites[this.TileAtom.Full];
		const fullVariationSprite = sprites[this.TileAtom.FullVariation]; // Sprite 4

		const oneCornerSprite = sprites[this.TileAtom.OneCorner];
		const twoCornerSprite = sprites[this.TileAtom.TwoCorner];
		const threeCornerSprite = sprites[this.TileAtom.ThreeCorner];

		const oneCornerBotSprite = sprites[this.TileAtom.OneCornerBot];
		const twoCornerBotSprite = sprites[this.TileAtom.TwoCornerBot];
		const threeCornerBotSprite = sprites[this.TileAtom.ThreeCornerBot];

		// Create CanvasRenderingContext2D objects for each texture
		const fullCtx = fullTexture.getContext("2d");
		const fullVariationTexture = document.createElement("canvas");
		fullVariationTexture.width = spriteResolution;
		fullVariationTexture.height = spriteResolution;
		fullVariationTexture.setAttribute('willReadFrequently', true);
		const fullVariationCtx = fullVariationTexture.getContext("2d");

		const oneCornerCtx = oneCornerTexture.getContext("2d", { willReadFrequently: true });
		const twoCornerCtx = twoCornerTexture.getContext("2d", { willReadFrequently: true });
		const threeCornerCtx = threeCornerTexture.getContext("2d", { willReadFrequently: true });

		const oneCornerBotCtx = oneCornerBotTexture.getContext("2d", { willReadFrequently: true });
		const twoCornerBotCtx = twoCornerBotTexture.getContext("2d", { willReadFrequently: true });
		const threeCornerBotCtx = threeCornerBotTexture.getContext("2d", { willReadFrequently: true });
		
		// Copy pixels from sprites to texture canvases
		fullCtx.drawImage(fullSprite,0,0);
		fullVariationCtx.drawImage(fullVariationSprite,0,0);

		oneCornerCtx.drawImage(oneCornerSprite,0,0);
		twoCornerCtx.drawImage(twoCornerSprite,0,0);
		threeCornerCtx.drawImage(threeCornerSprite,0,0);

		oneCornerBotCtx.drawImage(oneCornerBotSprite,0,0);
		twoCornerBotCtx.drawImage(twoCornerBotSprite,0,0);
		threeCornerBotCtx.drawImage(threeCornerBotSprite,0,0);

		// Get pixel data from the canvases
		const fullImageData = fullCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const fullVariationImageData = fullVariationCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerTopRightImageData = oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerTopLeftImageData = this.flipTextureHorizontal(oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));	

		const oneCornerBotRightImageData = oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerBotLeftImageData = this.flipTextureHorizontal(oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));	
		
		const twoCornerTopImageData = twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const twoCornerLeftImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), -Math.PI / 2);
		const twoCornerRightImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), Math.PI / 2);
		const twoCornerBottomImageData = twoCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		
		const threeCornerTopRightImageData = threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const threeCornerTopLeftImageData = this.flipTextureHorizontal(threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));
		const threeCornerBottomRightImageData = threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const threeCornerBottomLeftImageData = this.flipTextureHorizontal(threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));

		// Store base atoms for acute corner handling (will be returned, not stored here)
		const baseAtoms = {
			full: fullImageData,
			fullVariation: fullVariationImageData,
			oneCornerTL: oneCornerTopLeftImageData,
			oneCornerTR: oneCornerTopRightImageData,
			oneCornerBL: oneCornerBotLeftImageData,
			oneCornerBR: oneCornerBotRightImageData,
			twoCornerTop: twoCornerTopImageData,
			twoCornerLeft: twoCornerLeftImageData,
			twoCornerRight: twoCornerRightImageData,
			twoCornerBottom: twoCornerBottomImageData,
			threeCornerTL: threeCornerTopLeftImageData,
			threeCornerTR: threeCornerTopRightImageData,
			threeCornerBL: threeCornerBottomLeftImageData,
			threeCornerBR: threeCornerBottomRightImageData
		};

		// Define molecule objects
		const moleculeCanvas = document.createElement("canvas");

		moleculeCanvas.width = finalTileBaseResolution;
		moleculeCanvas.height = finalTileBaseResolution;
		
		const moleculeCtx = moleculeCanvas.getContext('2d', { willReadFrequently: true });

		const cornerCanvas = document.createElement("canvas");

		cornerCanvas.width = finalTileBaseResolution / 2;
		cornerCanvas.height = finalTileBaseResolution / 2;
		
		const cornerCtx = cornerCanvas.getContext('2d', { willReadFrequently: true });

		var imageDataList = [
			//FULL
			this.createMolecule(moleculeCtx, fullImageData, fullImageData, fullImageData, fullImageData),

			//CORNERS
			oneCornerTopLeftImageData, 
			oneCornerTopRightImageData,
			oneCornerBotLeftImageData,
			oneCornerBotRightImageData,
			//EDGES
			this.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, fullImageData, fullImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, twoCornerLeftImageData, fullImageData),
			this.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, fullImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, fullImageData, fullImageData, twoCornerBottomImageData, twoCornerBottomImageData),

			//TUNNELS
			this.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, twoCornerBottomImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, twoCornerLeftImageData, twoCornerRightImageData),

			//TWO SIDES
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, twoCornerLeftImageData, fullImageData),
			this.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, fullImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),

			//PENNINSULAS		
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, twoCornerLeftImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),

			//ISLAND
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),

			//FULL VARIATION (sprite 4)
			this.createMolecule(moleculeCtx, fullVariationImageData, fullVariationImageData, fullVariationImageData, fullVariationImageData),
		];

		return { molecules: imageDataList, baseAtoms: baseAtoms };
	}

	createMolecule(context, TLImageData, TRImageData, BLImageData, BRImageData) {
		let size = context.canvas.width;
		let spriteResolution = size / 2;
		context.fillStyle = 'black';
		context.fillRect(0, 0, size, size);
		context.putImageData(TLImageData, 0, 0);
		context.putImageData(TRImageData, spriteResolution, 0);
		context.putImageData(BLImageData, 0, spriteResolution);
		context.putImageData(BRImageData, spriteResolution, spriteResolution);
		return context.getImageData(0, 0, size, size);
	}

	// Extract individual atoms from a molecule ImageData
	extractAtomsFromMolecule(moleculeImageData) {
		const atomSize = this.tileSize / 2;
		const canvas = document.createElement('canvas');
		canvas.width = this.tileSize;
		canvas.height = this.tileSize;
		const ctx = canvas.getContext('2d');

		// Draw the molecule onto canvas
		ctx.putImageData(moleculeImageData, 0, 0);

		// Extract each atom
		return {
			TL: ctx.getImageData(0, 0, atomSize, atomSize),
			TR: ctx.getImageData(atomSize, 0, atomSize, atomSize),
			BL: ctx.getImageData(0, atomSize, atomSize, atomSize),
			BR: ctx.getImageData(atomSize, atomSize, atomSize, atomSize)
		};
	}

	// Select the correct atom for a specific position based on neighbor analysis
	selectAtomForPosition(tile, position, terrainIndex) {
		const analysis = tile.terrainAnalysis;
		const atoms = this.baseAtoms[terrainIndex];

		if (!atoms) return null;

		// For each position, check diagonal and adjacent cardinals to determine atom type
		switch(position) {
			case 'TL': {
				// Top-left atom: check top, left, and top-left diagonal
				const diagonalLess = analysis.cornerTopLeftLess;
				const topLess = analysis.topLess;
				const leftLess = analysis.leftLess;

				if (diagonalLess && !topLess && !leftLess) {
					// Only diagonal is lower: use oneCorner with TL corner cut
					return atoms.oneCornerTL;
				} else if (!topLess && !leftLess) {
					// No neighbors lower: use full atom
					return atoms.full;
				} else {
					// Cardinal neighbors are lower: handled by molecule logic
					return null; // Will use molecule-based atom
				}
			}
			case 'TR': {
				// Top-right atom: check top, right, and top-right diagonal
				const diagonalLess = analysis.cornerTopRightLess;
				const topLess = analysis.topLess;
				const rightLess = analysis.rightLess;

				if (diagonalLess && !topLess && !rightLess) {
					// Only diagonal is lower: use oneCorner with TR corner cut
					return atoms.oneCornerTR;
				} else if (!topLess && !rightLess) {
					// No neighbors lower: use full atom
					return atoms.full;
				} else {
					return null; // Will use molecule-based atom
				}
			}
			case 'BL': {
				// Bottom-left atom: check bottom, left, and bottom-left diagonal
				const diagonalLess = analysis.cornerBottomLeftLess;
				const botLess = analysis.botLess;
				const leftLess = analysis.leftLess;

				if (diagonalLess && !botLess && !leftLess) {
					// Only diagonal is lower: use oneCorner with BL corner cut
					return atoms.oneCornerBL;
				} else if (!botLess && !leftLess) {
					// No neighbors lower: use full atom
					return atoms.full;
				} else {
					return null; // Will use molecule-based atom
				}
			}
			case 'BR': {
				// Bottom-right atom: check bottom, right, and bottom-right diagonal
				const diagonalLess = analysis.cornerBottomRightLess;
				const botLess = analysis.botLess;
				const rightLess = analysis.rightLess;

				if (diagonalLess && !botLess && !rightLess) {
					// Only diagonal is lower: use oneCorner with BR corner cut
					return atoms.oneCornerBR;
				} else if (!botLess && !rightLess) {
					// No neighbors lower: use full atom
					return atoms.full;
				} else {
					return null; // Will use molecule-based atom
				}
			}
		}
		return null;
	}

	// Select base layer atom based on which neighbors are even lower
	selectBaseLayerAtom(atoms, position, miniAnalysis) {
		if (!atoms) return null;

		switch(position) {
			case 'TL': {
				const diagonal = miniAnalysis.cornerTopLeftLess;
				const top = miniAnalysis.topLess;
				const left = miniAnalysis.leftLess;

				// Check how many neighbors are lower
				if (top && left) {
					return atoms.threeCornerTL; // Both cardinals lower: 3 corners cut
				} else if (top && diagonal) {
					return atoms.twoCornerTop; // Top edge + corner
				} else if (left && diagonal) {
					return atoms.twoCornerLeft; // Left edge + corner
				} else if (top) {
					return atoms.twoCornerTop; // Just top edge (no diagonal)
				} else if (left) {
					return atoms.twoCornerLeft; // Just left edge (no diagonal)
				} else if (diagonal) {
					return atoms.oneCornerTL; // Just corner
				} else {
					return atoms.full; // No neighbors lower
				}
			}
			case 'TR': {
				const diagonal = miniAnalysis.cornerTopRightLess;
				const top = miniAnalysis.topLess;
				const right = miniAnalysis.rightLess;

				if (top && right) {
					return atoms.threeCornerTR;
				} else if (top && diagonal) {
					return atoms.twoCornerTop;
				} else if (right && diagonal) {
					return atoms.twoCornerRight;
				} else if (top) {
					return atoms.twoCornerTop; // Just top edge
				} else if (right) {
					return atoms.twoCornerRight; // Just right edge
				} else if (diagonal) {
					return atoms.oneCornerTR;
				} else {
					return atoms.full;
				}
			}
			case 'BL': {
				const diagonal = miniAnalysis.cornerBottomLeftLess;
				const bot = miniAnalysis.botLess;
				const left = miniAnalysis.leftLess;

				if (bot && left) {
					return atoms.threeCornerBL;
				} else if (bot && diagonal) {
					return atoms.twoCornerBottom;
				} else if (left && diagonal) {
					return atoms.twoCornerLeft;
				} else if (bot) {
					return atoms.twoCornerBottom; // Just bottom edge
				} else if (left) {
					return atoms.twoCornerLeft; // Just left edge
				} else if (diagonal) {
					return atoms.oneCornerBL;
				} else {
					return atoms.full;
				}
			}
			case 'BR': {
				const diagonal = miniAnalysis.cornerBottomRightLess;
				const bot = miniAnalysis.botLess;
				const right = miniAnalysis.rightLess;

				if (bot && right) {
					return atoms.threeCornerBR;
				} else if (bot && diagonal) {
					return atoms.twoCornerBottom;
				} else if (right && diagonal) {
					return atoms.twoCornerRight;
				} else if (bot) {
					return atoms.twoCornerBottom; // Just bottom edge
				} else if (right) {
					return atoms.twoCornerRight; // Just right edge
				} else if (diagonal) {
					return atoms.oneCornerBR;
				} else {
					return atoms.full;
				}
			}
		}
		return atoms.full;
	}

	// Paint base layer with lower neighbor textures to fill gaps
	paintBaseLowerLayer(ctx, analyzedMap, tile, row, col) {
		const atomSize = this.tileSize / 2;

		// For each atom position, check neighboring tile terrains and build appropriate base
		const positions = [
			{
				name: 'TL', x: 0, y: 0,
				// Tiles that affect TL atom
				tileNeighbors: [
					{ dir: 'topLeft', row: row - 1, col: col - 1 },
					{ dir: 'top', row: row - 1, col: col },
					{ dir: 'left', row: row, col: col - 1 }
				]
			},
			{
				name: 'TR', x: atomSize, y: 0,
				// Tiles that affect TR atom
				tileNeighbors: [
					{ dir: 'topRight', row: row - 1, col: col + 1 },
					{ dir: 'top', row: row - 1, col: col },
					{ dir: 'right', row: row, col: col + 1 }
				]
			},
			{
				name: 'BL', x: 0, y: atomSize,
				// Tiles that affect BL atom
				tileNeighbors: [
					{ dir: 'botLeft', row: row + 1, col: col - 1 },
					{ dir: 'bot', row: row + 1, col: col },
					{ dir: 'left', row: row, col: col - 1 }
				]
			},
			{
				name: 'BR', x: atomSize, y: atomSize,
				// Tiles that affect BR atom
				tileNeighbors: [
					{ dir: 'botRight', row: row + 1, col: col + 1 },
					{ dir: 'bot', row: row + 1, col: col },
					{ dir: 'right', row: row, col: col + 1 }
				]
			}
		];

		// Paint base layer for each atom position
		for (const pos of positions) {
			// Get terrain indices of neighboring tiles
			const neighborTerrains = {};
			for (const neighbor of pos.tileNeighbors) {
				const nRow = neighbor.row;
				const nCol = neighbor.col;

				if (nRow >= 0 && nRow < this.numColumns && nCol >= 0 && nCol < this.numColumns) {
					const nIndex = nRow * this.numColumns + nCol;
					const nTile = analyzedMap[nIndex];
					if (nTile && nTile.terrainIndex >= 0) {
						neighborTerrains[neighbor.dir] = nTile.terrainIndex;
					}
				}
			}

			// Find ALL unique terrain indices that are lower than current
			const lowerTerrains = new Set();
			for (const dir in neighborTerrains) {
				const terrain = neighborTerrains[dir];
				if (terrain < tile.terrainIndex) {
					lowerTerrains.add(terrain);
				}
			}

			// Sort terrains from lowest to highest for proper layering
			const sortedTerrains = Array.from(lowerTerrains).sort((a, b) => a - b);

			// Map position-specific neighbors to analysis flags
			const neighborMapping = {
				'TL': {
					topLeft: 'cornerTopLeftLess',
					top: 'topLess',
					left: 'leftLess'
				},
				'TR': {
					topRight: 'cornerTopRightLess',
					top: 'topLess',
					right: 'rightLess'
				},
				'BL': {
					botLeft: 'cornerBottomLeftLess',
					bot: 'botLess',
					left: 'leftLess'
				},
				'BR': {
					botRight: 'cornerBottomRightLess',
					bot: 'botLess',
					right: 'rightLess'
				}
			};

			// Paint each terrain layer from lowest to highest
			for (let i = 0; i < sortedTerrains.length; i++) {
				const currentLayerTerrain = sortedTerrains[i];

				if (!this.baseAtoms[currentLayerTerrain]) continue;

				// Build mini-analysis: check which neighbors are lower than THIS layer
				const miniAnalysis = {
					topLess: false,
					leftLess: false,
					rightLess: false,
					botLess: false,
					cornerTopLeftLess: false,
					cornerTopRightLess: false,
					cornerBottomLeftLess: false,
					cornerBottomRightLess: false
				};

				const mapping = neighborMapping[pos.name];
				for (const dir in neighborTerrains) {
					if (mapping[dir] && neighborTerrains[dir] < currentLayerTerrain) {
						miniAnalysis[mapping[dir]] = true;
					}
				}

				// Select appropriate atom for this layer
				const layerAtom = this.selectBaseLayerAtom(
					this.baseAtoms[currentLayerTerrain],
					pos.name,
					miniAnalysis
				);

				if (layerAtom) {
					if (i === 0) {
						// First layer: use putImageData (on black background)
						ctx.putImageData(layerAtom, pos.x, pos.y);
					} else {
						// Subsequent layers: use drawImage for alpha blending
						const atomCanvas = this.imageDataToCanvas(layerAtom);
						ctx.drawImage(atomCanvas, pos.x, pos.y);
					}
				}
			}
		}
	}

	// Convert ImageData to a canvas for proper alpha blending
	imageDataToCanvas(imageData) {
		const canvas = document.createElement('canvas');
		canvas.width = imageData.width;
		canvas.height = imageData.height;
		const ctx = canvas.getContext('2d');
		ctx.putImageData(imageData, 0, 0);
		return canvas;
	}

	// Draw a single tile with proper atom layering for smooth transitions
	drawTileWithLayering(analyzedMap, tile, row, col) {
		const atomSize = this.tileSize / 2;
		const canvas = document.createElement('canvas');
		canvas.width = this.tileSize;
		canvas.height = this.tileSize;
		const ctx = canvas.getContext('2d');

		// Fill with black background
		ctx.fillStyle = 'black';
		ctx.fillRect(0, 0, this.tileSize, this.tileSize);

		// Paint base layer with lower neighbor textures first
		this.paintBaseLowerLayer(ctx, analyzedMap, tile, row, col);

		// Build custom molecule based on diagonal-aware atom selection
		const atoms = {
			TL: this.selectAtomForPosition(tile, 'TL', tile.terrainIndex),
			TR: this.selectAtomForPosition(tile, 'TR', tile.terrainIndex),
			BL: this.selectAtomForPosition(tile, 'BL', tile.terrainIndex),
			BR: this.selectAtomForPosition(tile, 'BR', tile.terrainIndex)
		};

		// If any atom is null, fall back to molecule-based extraction
		const molecule = this.getMoleculeByTileAnalysis(tile.terrainAnalysis);
		const moleculeImageData = this.layerTextures[tile.terrainIndex][molecule];
		const moleculeAtoms = this.extractAtomsFromMolecule(moleculeImageData);

		// Use custom atoms where available, otherwise use molecule atoms
		const currentAtoms = {
			TL: atoms.TL || moleculeAtoms.TL,
			TR: atoms.TR || moleculeAtoms.TR,
			BL: atoms.BL || moleculeAtoms.BL,
			BR: atoms.BR || moleculeAtoms.BR
		};

		// Convert atoms to canvases and use drawImage for proper alpha blending
		const atomCanvases = {
			TL: this.imageDataToCanvas(currentAtoms.TL),
			TR: this.imageDataToCanvas(currentAtoms.TR),
			BL: this.imageDataToCanvas(currentAtoms.BL),
			BR: this.imageDataToCanvas(currentAtoms.BR)
		};

		// Draw each atom using drawImage (respects alpha blending)
		ctx.drawImage(atomCanvases.TL, 0, 0);
		ctx.drawImage(atomCanvases.TR, atomSize, 0);
		ctx.drawImage(atomCanvases.BL, 0, atomSize);
		ctx.drawImage(atomCanvases.BR, atomSize, atomSize);

		// Apply coloring and corner graphics
		let imageData = ctx.getImageData(0, 0, this.tileSize, this.tileSize);
		imageData = this.colorImageData(imageData, tile.terrainAnalysis, tile.terrainIndex);
		imageData = this.addCornerGraphics(imageData, tile.heightAnalysis, tile.terrainIndex);

		return imageData;
	}

	extractSpritesFromSheet(spriteSheet, columns, rows) {
		let sprites = [];
		let spriteWidth = spriteSheet.width / columns;
		let spriteHeight = spriteSheet.height / rows;
	
		for (let y = 0; y < rows; y++) {
			for (let x = 0; x < columns; x++) {
				let canvas = document.createElement('canvas');
				canvas.width = spriteWidth;
				canvas.height = spriteHeight;
				let context = canvas.getContext('2d');
				context.drawImage(spriteSheet, x * spriteWidth, y * spriteHeight, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
				sprites.push(canvas);
			}
		}
	
		return sprites;
	}
	
	getSpriteRotations(imageDataList) {
		let rotationDict = {};

		let requiredTransforms = {};

		requiredTransforms[this.TileMolecule.Full] = [];
		requiredTransforms[this.TileMolecule.Corner] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Edge] = [this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Tunnel] = [this.TileTransforms.CounterClockWise90];
		requiredTransforms[this.TileMolecule.TwoSides] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Penninsula] = [this.TileTransforms.FlipVertical, this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90];
		requiredTransforms[this.TileMolecule.Island] = [];

		Object.keys(imageDataList).forEach(moleculeType => {
			let rotations = {};
			let colors = imageDataList[moleculeType];
			rotations[this.TileTransforms.None] = colors;

			if (requiredTransforms[moleculeType].includes(this.TileTransforms.ClockWise90)) {
				rotations[this.TileTransforms.ClockWise90] = this.rotateTexture(colors, Math.PI / 2);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.CounterClockWise90)) {
				rotations[this.TileTransforms.CounterClockWise90] = this.rotateTexture(colors, -Math.PI / 2);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.Rotate180)) {
				rotations[this.TileTransforms.Rotate180] = this.rotateTexture(colors, Math.PI);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipHorizontal)) {
				rotations[this.TileTransforms.FlipHorizontal] = this.flipTextureHorizontal(colors);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipVertical)) {
				rotations[this.TileTransforms.FlipVertical] = this.flipTextureVertical(colors);
			}

			rotationDict[moleculeType] = rotations;
		});

		return rotationDict;
	}

	rotateTexture(imageData, angle) {
		return this.canvasUtility.rotateTexture(imageData, angle);
	}

	flipTextureVertical(imageData) {
		return this.canvasUtility.flipTextureVertical(imageData);
	}

	flipTextureHorizontal(imageData) {
		return this.canvasUtility.flipTextureHorizontal(imageData);
	}

	analyzeTile(x, y) {
		let row = y;
		let col = x;

		// Create result object with both analyses
		let result = {
			terrainIndex: 0,
			heightAnalysis: new this.TileAnalysis(),
			terrainAnalysis: new this.TileAnalysis()
		};

		if (row < 0 || row >= this.numColumns || col < 0 || col >= this.numColumns) {
			return result; // Out of bounds
		}

		// Get terrain type for this tile
		result.terrainIndex = this.tileMap[row][col];

		// Helper function to check if a location is within bounds
		function isWithinBounds(r, c, n) {
			return r >= 0 && r < n && c >= 0 && c < n;
		}

		// Analyze heights for cliff detection
		const heightData = this.heightMap || this.tileMap;
		result.heightAnalysis.heightIndex = heightData[row][col];

		var analyzeHeight = ((r, c, n, direction, propertyLess) => {
			if (isWithinBounds(r, c, n)) {
				result.heightAnalysis[direction] = heightData[r][c];
				if (heightData[r][c] < result.heightAnalysis.heightIndex) {
					result.heightAnalysis[propertyLess] = true;
					if(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0) {
						result.heightAnalysis.neighborLowerCount++;
					} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {
						result.heightAnalysis.cornerLowerCount++;
					}
				}
			}
		});

		analyzeHeight(row - 1, col, this.numColumns, 'topHeight', 'topLess');
		analyzeHeight(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');
		analyzeHeight(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');
		analyzeHeight(row + 1, col, this.numColumns, 'botHeight', 'botLess');
		analyzeHeight(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');
		analyzeHeight(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');
		analyzeHeight(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');
		analyzeHeight(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');

		// Analyze terrain types for texture tiling
		result.terrainAnalysis.heightIndex = this.tileMap[row][col];

		var analyzeTerrain = ((r, c, n, direction, propertyLess) => {
			if (isWithinBounds(r, c, n)) {
				result.terrainAnalysis[direction] = this.tileMap[r][c];
				if (this.tileMap[r][c] < result.terrainAnalysis.heightIndex) {
					result.terrainAnalysis[propertyLess] = true;
					if(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0) {
						result.terrainAnalysis.neighborLowerCount++;
					} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {
						result.terrainAnalysis.cornerLowerCount++;
					}
				}
			}
		});

		analyzeTerrain(row - 1, col, this.numColumns, 'topHeight', 'topLess');
		analyzeTerrain(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');
		analyzeTerrain(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');
		analyzeTerrain(row + 1, col, this.numColumns, 'botHeight', 'botLess');
		analyzeTerrain(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');
		analyzeTerrain(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');
		analyzeTerrain(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');
		analyzeTerrain(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');

		return result;
	}

	// Function to generate a random integer between min and max (inclusive)
	getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	// Function to generate a random 10x10 map
	generateRandomMap(rows, columns) {
		let map = [];
		for (let i = 0; i < rows; i++) {
			let row = [];
			for (let j = 0; j < columns; j++) {
				row.push(getRandomInt(0, layers.length - 1)); // Random height between 0 and 10
			}
			map.push(row);
		}
		return map;
	}

	analyzeMap() {
		let analyzedTiles = [];

		for (let i = 0; i < this.numColumns; i++) {
			for (let j = 0; j < this.numColumns; j++) {
				analyzedTiles.push(this.analyzeTile(j, i));
			}
		}

		return analyzedTiles;
	}

	getTransformedTexture(transformationDict, tileAnalysis, molecule){
		switch(tileAnalysis.neighborLowerCount){				
			case 1:
				if(tileAnalysis.leftLess){                    
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				} else if(tileAnalysis.rightLess){
                    return transformationDict[molecule][this.TileTransforms.ClockWise90];
				} else if(tileAnalysis.botLess){		
					return transformationDict[molecule][this.TileTransforms.Rotate180];
				}
				break;
			case 2:
				if(tileAnalysis.topLess && tileAnalysis.leftLess){
					return transformationDict[molecule][this.TileTransforms.FlipHorizontal];
				} else if(tileAnalysis.botLess && tileAnalysis.leftLess){		
					return transformationDict[molecule][this.TileTransforms.Rotate180];
				} else if(tileAnalysis.botLess && tileAnalysis.rightLess){		
					return transformationDict[molecule][this.TileTransforms.FlipVertical];
				} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				}
				break;
			case 3:
				if(!tileAnalysis.topLess){
					return transformationDict[molecule][this.TileTransforms.FlipVertical];
				} else if(!tileAnalysis.leftLess){		
					return transformationDict[molecule][this.TileTransforms.ClockWise90];
				} else if(!tileAnalysis.rightLess){		
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				}
				break;
			case 4:
				break;
			default:
				break;
		}		
        return transformationDict[molecule][this.TileTransforms.None];
	}

	getMoleculeByTileAnalysis(tileAnalysis){
		var molecule = this.TileCliffMolecules.Full;								
		switch(tileAnalysis.neighborLowerCount){
			case 0: 
				// Randomly choose between Full (sprite 0) and FullVariation (sprite 4)
				molecule = Math.random() < 0.5 ? this.TileCliffMolecules.Full : this.TileCliffMolecules.FullVariation;
				break;
			case 1:
				if(tileAnalysis.topLess) {
					molecule = this.TileCliffMolecules.EdgeT;
				} else if(tileAnalysis.leftLess) {
					molecule = this.TileCliffMolecules.EdgeL;
				} else if(tileAnalysis.rightLess) {
					molecule = this.TileCliffMolecules.EdgeR;
				} else if(tileAnalysis.botLess) {
					molecule = this.TileCliffMolecules.EdgeB;
				}
				break;
			case 2:
				if(tileAnalysis.topLess && tileAnalysis.botLess){
					molecule = this.TileCliffMolecules.TunnelH;
				} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TunnelV;
				} else if(tileAnalysis.topLess && tileAnalysis.leftLess){
					molecule = this.TileCliffMolecules.TwoSidesTL;
				} else if(tileAnalysis.topLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TwoSidesTR;
				} else if(tileAnalysis.botLess && tileAnalysis.leftLess){
					molecule = this.TileCliffMolecules.TwoSidesBL;
				} else if(tileAnalysis.botLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TwoSidesBR;
				} 
				break;
			case 3:
				if( !tileAnalysis.topLess ) {
					molecule = this.TileCliffMolecules.PenninsulaB;
				} else if( !tileAnalysis.leftLess ) {
					molecule = this.TileCliffMolecules.PenninsulaR;
				} else if( !tileAnalysis.rightLess ) {
					molecule = this.TileCliffMolecules.PenninsulaL;
				} else if( !tileAnalysis.botLess ) {
					molecule = this.TileCliffMolecules.PenninsulaT;
				}
				break;								
			case 4:
				molecule = this.TileCliffMolecules.Island;
				break;
		}
		return molecule;
	}

	colorImageData(imageData, terrainAnalysis, terrainIndex) {

		const data = new Uint8ClampedArray(imageData.data);
		var directions = ['topHeight', 'leftHeight', 'rightHeight', 'botHeight', 'topLeftHeight', 'topRightHeight', 'botLeftHeight', 'botRightHeight'];
		let heightCounts = {};
		directions.forEach((direction) => {
			let height = terrainAnalysis[direction];
			if (height !== terrainAnalysis.heightIndex) {
				if (!heightCounts[height]) {
					heightCounts[height] = 0;
				}
				heightCounts[height]++;
			}
		});

		let lowerNeighborHeight = Math.max(0, terrainAnalysis.heightIndex - 1);
		let maxCount = 0;
		Object.keys(heightCounts).forEach((height) => {
			if (heightCounts[height] > maxCount && height < terrainAnalysis.heightIndex) {
				lowerNeighborHeight = parseInt(height);
				maxCount = heightCounts[height];
			}
		});
		const numPixels = this.tileSize * this.tileSize;
		if(lowerNeighborHeight < 0){
			const blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)
			blackData.fill(0); // Fill with black (0, 0, 0, 255)
			return new ImageData(blackData, this.tileSize, this.tileSize);
		}
		// Use terrainIndex for texture selection
		let baseColors = this.layerTextures[terrainIndex][this.TileMolecule.Full].data;
		let neighborColors = this.layerTextures[terrainIndex][this.TileMolecule.Full].data;

		// Iterate over each pixel
		for (let i = 0; i < numPixels; i++) {
			const dataIndex = i * 4;
			let pColor = { r: data[dataIndex], g: data[dataIndex + 1], b: data[dataIndex + 2], a: data[dataIndex + 3] };
			let bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };
			let tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };

			if (this.layerTextures.length > terrainIndex) {
				if (baseColors.length > i) {
					bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };
				}
			}
			if (lowerNeighborHeight >= 0) {
				if (neighborColors.length > i) {
					tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };
				}
			}
			let fColor = pColor;
			if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 0 })) fColor = pColor;
			if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) fColor = bColor;

			data.set([fColor.r, fColor.g, fColor.b, fColor.a], dataIndex);
		}
		return new ImageData(data, this.tileSize, this.tileSize);
	}

	isEqualColor(color1, color2) {
		return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && color1.a === color2.a;
	}

	addCornerGraphics(imageData, heightAnalysis, terrainIndex) {
		let cornerSize = this.tileSize / 2;
		let cornerTexture;

		if (heightAnalysis.cornerLowerCount > 0) {
			if (heightAnalysis.cornerTopLeftLess && (!heightAnalysis.topLess && !heightAnalysis.leftLess)) {
				cornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerTL];
				imageData = this.colorCornerTextureRoutine(imageData, 0, 0, cornerTexture, terrainIndex);
			}
			// Assuming heightAnalysis, textureDict, and other variables are already defined
			if (heightAnalysis.cornerTopRightLess && (!heightAnalysis.topLess && !heightAnalysis.rightLess)) {
				cornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerTR];
				imageData = this.colorCornerTextureRoutine(imageData, cornerSize, 0, cornerTexture, terrainIndex);
			}

			if (heightAnalysis.cornerBottomLeftLess && (!heightAnalysis.botLess && !heightAnalysis.leftLess)) {
				cornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerBL];
				imageData = this.colorCornerTextureRoutine(imageData, 0, cornerSize, cornerTexture, terrainIndex);
			}

			if (heightAnalysis.cornerBottomRightLess && (!heightAnalysis.botLess && !heightAnalysis.rightLess)) {
				cornerTexture = this.layerTextures[terrainIndex][this.TileCliffMolecules.CornerBR];
				imageData = this.colorCornerTextureRoutine(imageData, cornerSize, cornerSize, cornerTexture, terrainIndex);
			}
		}
		return imageData;
	}
	
	colorCornerTextureRoutine(outputImageData, x, y, cornerImageData, terrainIndex) {
		let cornerSize = this.tileSize / 2;
		// Use terrainIndex for texture selection
		let baseColors = this.layerTextures[terrainIndex][this.TileMolecule.Full];
		const data = new Uint8ClampedArray(outputImageData.data);
		for (let j = 0; j < cornerSize; j++) {
			for (let i = 0; i < cornerSize; i++) {
				// Calculate the correct position in the output image data
				let outputIndex = ((y + j) * this.tileSize + (x + i)) * 4;
	
				let baseColor = this.getColorFromImageData(baseColors, outputIndex);
		
				let sourceOriginX = i;
				let sourceOriginY = j * cornerSize;
				let sourcePixel = (sourceOriginY + sourceOriginX) * 4;
				let pColor = this.getColorFromImageData(cornerImageData, sourcePixel);
				let fColor = pColor;
				if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) {
					fColor = baseColor;				
				}
	
				data[outputIndex] = fColor.r;
				data[outputIndex + 1] = fColor.g;
				data[outputIndex + 2] = fColor.b;
				data[outputIndex + 3] = fColor.a;
			}
		}

		return new ImageData(data, this.tileSize, this.tileSize);
	}
	
	getColorFromImageData(imageData, index) {
		return {
			r: imageData.data[index],
			g: imageData.data[index + 1],
			b: imageData.data[index + 2],
			a: imageData.data[index + 3]
		};
	}	
	
	addVariationImage(imageData, tileAnalysis) {
		const img = this.layerSpriteSheets[tileAnalysis.heightIndex];
	
		if (img && Math.random() < .25) {
			this.canvasUtility.setSize(imageData.width, imageData.height);
			
			
			// Paint the existing imageData onto the canvas
			this.canvasUtility.paintTexture(imageData);
	
			// Assuming img is a loaded Image object and you want to draw it at (0,0)
			// Draw the img over the imageData
			this.canvasUtility.ctx.drawImage(img, (imageData.width / 2) - img.width / 2,  (imageData.width / 2) - img.width / 2);
	
			// Get the updated imageData from the canvas
			return this.canvasUtility.ctx.getImageData(0, 0, imageData.width, imageData.height);
		} else {
			// If img is not available, return the original imageData
			return imageData;
		}
	}
	
	drawMap(analyzedMap) {
		const ctx = this.canvas.getContext('2d');

		// Clear the canvas with black background
		ctx.fillStyle = 'black';
		ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

		// Draw each tile with atom-level layering for smooth transitions
		analyzedMap.forEach((tile, index) => {
			const col = index % this.numColumns;
			const row = Math.floor(index / this.numColumns);
			const x = col * this.tileSize;
			const y = row * this.tileSize;

			let imageData;

			if (tile.terrainIndex >= 0) {
				// Use the new atom-based layering system for smooth transitions
				imageData = this.drawTileWithLayering(analyzedMap, tile, row, col);
			} else {
				// Create transparent/black tile for invalid terrain
				let numPixels = this.tileSize * this.tileSize;
				const blackData = new Uint8ClampedArray(numPixels * 4);
				blackData.fill(0);
				imageData = new ImageData(blackData, this.tileSize, this.tileSize);
			}

			// Update height map for this tile
			this.updateHeightMapForTile(x, y, tile.heightAnalysis.heightIndex);

			// Draw the tile to the main canvas
			ctx.putImageData(imageData, x, y);
		});

		// Store terrain data for height mapping
		this.terrainData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;
	}
}

        
        // Explicitly register classes to window
        var className = "TileMap";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing TileMap:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "TileMap";
    var className = "TileMap";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.TileMap = foundLibrary;
        window.engine.TileMap = foundLibrary;
        
    } else {
        console.warn("Could not find TileMap after loading");
    }
})();

// Library: Entity (non-module - inline)
// Original path: /global/libraries/js/Entity.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class Entity {
    constructor(game, type) {
        this.game = game;
        this.children = [];        
        this.components = [];
        this.renderers = [];
        this.destroyed = false;        
        this.id = -1;
        this.type = type;
        this.collisionRadius = 5;   
        this.entityHeight = 10;        
    }

    init(params) {
        for(let c in this.components) {
            this.components[c].init(params);               
        }     
    }
    getAABB(position = this.transform.position) {
        return {
            min: {
                x: position.x - this.collisionRadius,
                y: position.y,
                z: position.z - this.collisionRadius
            },
            max: {
                x: position.x + this.collisionRadius,
                y: position.y + this.entityHeight,
                z: position.z + this.collisionRadius
            }
        };
    }

    getComponent(name) {
        return this.components[name.toLowerCase()] || this.components[`${name.toLowerCase()}`];
    }
    addRenderer(RendererClassName, params) {
        const RendererClass = this.game.moduleManager.getCompiledScript(RendererClassName, 'renderers');
        const renderer = new RendererClass(this.game, this);
        this.renderers[RendererClass.name.toLowerCase()] = renderer;
        this.components[RendererClass.name.toLowerCase()] = renderer;
        if(params){
            renderer.init(params);
        }
        return renderer;
    }
    addComponent(ComponentClassName, params) {        
        const ComponentClass = this.game.moduleManager.getCompiledScript(ComponentClassName, 'components');
        const component = new ComponentClass(this.game, this);
        this.components[ComponentClass.name.toLowerCase()] = component;
        if(params){
            component.init(params);
        }
        return component;
    }
    getNetworkComponentData(){
        let data = {};
        for(let c in this.components) {
            let cData = this.components[c].getNetworkData(); 
            if(cData){
                data[c] = cData;
            }
        }    
        return data;
    }
    setNetworkComponentData(data, isRemote=false){            
        if(data?.components){
            for(let c in data.components) {
                this.components[c]?.setNetworkData(data.components[c], isRemote); 
            }    
        }
    }
    removeComponent(component) {
        let index = this.components.indexOf(component);
        if( index >= 0 ) {
            this.components.splice(index, 1);
        }
    }
    update() {    
        for(let c in this.components) {
            this.components[c].update(); 
            if(this.destroyed) break;
        }                
    }
    postUpdate() {
        for(let c in this.components) {
            this.components[c].postUpdate();   
            if(this.destroyed) break;
        }     
    }
    draw() {
        for(let r in this.renderers) {
            this.renderers[r].draw();  
        }

    }
    OnCollision(collidedWith){
        for(let c in this.components) {
            this.components[c].OnCollision(collidedWith);                           
        }                
    }
    OnStaticCollision(){
        for(let c in this.components) {
            this.components[c].OnStaticCollision();                           
        }                
    }
    OnGrounded(){
        for(let c in this.components) {
            this.components[c].OnGrounded();                           
        }                
    }
    onPhysicsUpdate(timestamp, physicsStepMs)  {
        for(let c in this.components) {
            this.components[c].onPhysicsUpdate(timestamp, physicsStepMs);                           
        }     
    }
    addChild(entity){
        this.children.push(entity);
        entity.parent = this;
        return entity;
    }
    destroy() {
        this.destroyed = true;
        this.children.forEach((c) => {
            if(!c.destroyed){
                c.destroy();
            }
        });
        for(let c in this.components) {
            this.components[c].destroy();   
        }   
        for(let r in this.renderers) {
            this.renderers[r].destroy();   
        }   
    }
}
        
        // Explicitly register classes to window
        var className = "Entity";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing Entity:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "Entity";
    var className = "Entity";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.Entity = foundLibrary;
        window.engine.Entity = foundLibrary;
        
    } else {
        console.warn("Could not find Entity after loading");
    }
})();

// Library: Component (non-module - inline)
// Original path: /global/libraries/js/Component.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class Component {
    constructor(game, parent) { 
        this.game = game;
        this.parent = parent;
    }
    init(params) {}
    getComponent(type) {
        return this.parent.getComponent(type);
    }
    update() {}
    postUpdate() {}
    getNetworkData(){ return null }
    setNetworkData(data){ }
    onPhysicsUpdate(timestamp, physicsStepMs){}
    destroy() {}
}

        
        // Explicitly register classes to window
        var className = "Component";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing Component:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "Component";
    var className = "Component";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.Component = foundLibrary;
        window.engine.Component = foundLibrary;
        
    } else {
        console.warn("Could not find Component after loading");
    }
})();

// Library: GameState (non-module - inline)
// Original path: /global/libraries/js/GameState.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameState {
    constructor(gameConfig = {}) {
        this.collections = gameConfig;
        let state = gameConfig.configs?.state;
     
        // Clear all existing properties
        for (let prop in this) {
            if (Object.prototype.hasOwnProperty.call(this, prop)) {
                delete this[prop];
            }
        }

        // Set only the properties from params
        for (let key in state) {
            if (Object.prototype.hasOwnProperty.call(state, key)) {
                this[key] = state[key];
            }
        }
        // If stats is present, create defaultStats as a copy
  
    }
}

if(typeof GameState != 'undefined'){
    if (typeof window !== 'undefined') {
        window.GameState = GameState;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = GameState;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = GameState;
        exports.GameState = GameState;
    }
}
        
        // Explicitly register classes to window
        var className = "GameState";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameState:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameState";
    var className = "GameState";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameState = foundLibrary;
        window.engine.GameState = foundLibrary;
        
    } else {
        console.warn("Could not find GameState after loading");
    }
})();

// Library: ModelManager (non-module - inline)
// Original path: /global/libraries/js/ModelManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class ModelManager {
    constructor(app, config, { ShapeFactory, palette, textures }) {
        this.app = app;
        this.config = config;
        this.shapeFactory = new ShapeFactory(this.app.getResourcesPath(), palette, textures, null, 1);

        if (location.hostname.indexOf('github') >= 0) {
            this.shapeFactory.setURLRoot("/GUTS/");
        }

        // VAT-focused storage
        this.masterModels = new Map();           // objectType_spawnType -> THREE.Group (master models)
        this.animationModels = new Map();        // objectType_spawnType_animName -> THREE.Group
        this.vatBundles = new Map();             // objectType_spawnType -> { geometry, material, vatTexture, meta }
        this.vatBundlePromises = new Map();      // objectType_spawnType -> Promise

        this.assetsLoaded = false;
        this.app.modelManager = this;
    }

    clear() {
        this.masterModels.clear();
        this.animationModels.clear();
        this.vatBundles.clear();
        this.vatBundlePromises.clear();
    }

    dispose() {
        // Dispose VAT bundles
        for (const [key, bundle] of this.vatBundles) {
            if (bundle.geometry) bundle.geometry.dispose();
            if (bundle.material) bundle.material.dispose();
            if (bundle.vatTexture) bundle.vatTexture.dispose();
        }
        this.clear();
    }

    async loadModels(prefix, config) {

        // Load all models first (master + animations)
        for (const [type, cfg] of Object.entries(config)) {
            if (!cfg.render?.model) continue;

            const modelKey = `${prefix}_${type}`;

            // Load master model
            this.masterModels.set(modelKey, await this.createModel(cfg.render.model));

            // Load animation variants
            if (cfg.render.animations) {
                for (const [animName, variants] of Object.entries(cfg.render.animations)) {
                    for (let variantIndex = 0; variantIndex < variants.length; variantIndex++) {
                        const animVariant = variants[variantIndex];
                        const animKey = variantIndex === 0
                            ? `${modelKey}_${animName}`
                            : `${modelKey}_${animName}_${variantIndex}`;

                        // Merge animation model data
                        let mergedModel = JSON.parse(JSON.stringify(cfg.render.model));
                        if (animVariant && Object.keys(animVariant).length > 0) {
                            const mainGroupName = Object.keys(mergedModel)[0];
                            const animGroupName = Object.keys(animVariant)[0];
                            if (animVariant[animGroupName]?.shapes?.[0]?.url) {
                                mergedModel[mainGroupName].shapes[0].url = animVariant[animGroupName].shapes[0].url;
                            }
                        }

                        this.animationModels.set(animKey, await this.createModel(mergedModel));
                    }
                }
            }
        }

        this.assetsLoaded = true;
    }

    async createModel(modelData) {
        const rootGroup = new THREE.Group();
        for (const groupName in modelData) {
            const group = await this.shapeFactory.createMergedGroupFromJSON(
                modelData, {}, groupName, null, null
            );
            if (group) {
                rootGroup.add(group);
            }
        }
        return rootGroup;
    }

    // Main VAT bundle creation - called by RenderSystem
    async requestVATBundle(objectType, spawnType, unitDef) {
        const key = `${objectType}_${spawnType}`;

        // Return existing bundle
        if (this.vatBundles.has(key)) {
            return { ready: true, bundle: this.vatBundles.get(key) };
        }

        // Return in-progress promise
        if (this.vatBundlePromises.has(key)) {
            return { ready: false, promise: this.vatBundlePromises.get(key) };
        }

        // Start building VAT bundle
        const promise = this._buildVATBundle(key, objectType, spawnType, unitDef);
        this.vatBundlePromises.set(key, promise);

        try {
            const bundle = await promise;
            if (bundle) {
                this.vatBundles.set(key, bundle);
                return { ready: true, bundle };
            }
        } catch (error) {
            console.error(`[ModelManager] VAT bundle failed: ${key}`, error);
        } finally {
            this.vatBundlePromises.delete(key);
        }

        return { ready: false, error: 'VAT bundle creation failed' };
    }

    async _buildVATBundle(key, objectType, spawnType, unitDef) {

        // Get master model
        const masterModel = this.masterModels.get(key);
        if (!masterModel) {
            throw new Error(`Master model not found: ${key}`);
        }

        // Find any mesh - prefer skinned mesh but fallback to any mesh
        let targetMesh = null;
        let skeleton = null;
        
        masterModel.traverse(obj => {
            if (obj.isSkinnedMesh && obj.skeleton && !targetMesh) {
                targetMesh = obj;
                skeleton = obj.skeleton;
            } else if (obj.isMesh && !targetMesh) {
                targetMesh = obj;
            }
        });

        if (!targetMesh) {
            throw new Error(`No mesh found in: ${key}`);
        }

        // Collect animation clips (may be empty for static meshes)
        const clips = await this._collectAnimationClips(key, objectType, spawnType, unitDef);
        
        // If no skeleton or no clips, create a static "animation" 
        if (!skeleton || clips.length === 0) {
            return this._buildStaticVATBundle(key, masterModel, targetMesh);
        }

        // Standard VAT bundle with animations
        const vatData = await this._bakeVATTexture(masterModel, skeleton, clips);
        if (!vatData) {
            throw new Error(`VAT baking failed for: ${key}`);
        }

        vatData.clipIndexByName = this._buildClipIndexMap(vatData.clips);
        const material = this._createVATMaterial(targetMesh, vatData, key);
        const geometry = targetMesh.geometry.clone();

        // Copy bone data
        const skinIndexAttr = targetMesh.geometry.getAttribute('skinIndex');
        const skinWeightAttr = targetMesh.geometry.getAttribute('skinWeight');
        if (!skinIndexAttr || !skinWeightAttr) {
            throw new Error('Skinned geometry missing skinIndex/skinWeight attributes.');
        }
        
        geometry.setAttribute('aBoneIndex', skinIndexAttr.clone());
        geometry.setAttribute('aBoneWeight', skinWeightAttr.clone());

        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);

        return {
            geometry,
            material,
            vatTexture: vatData.texture,
            meta: {
                fps: vatData.fps,
                cols: vatData.cols,
                rows: vatData.rows,
                clips: vatData.clips,
                clipIndexByName: vatData.clipIndexByName,
                skeleton: skeleton,
                attachmentTexture: vatData.attachmentTexture,
                attachmentBones: vatData.attachmentBones
            }
        };
    }

    // Add method for static meshes without skeletons:
    _buildStaticVATBundle(key, masterModel, mesh) {
            console.log('build static', key);
        const clips = [{ name: 'idle', startRow: 0, frames: 1 }];
        const clipIndexByName = { 'idle': 0 };
        
        // Now use clips in the material creation
        const identityData = new Float32Array([
            1, 0, 0, 0,  // identity matrix column 0
            0, 1, 0, 0,  // identity matrix column 1  
            0, 0, 1, 0,  // identity matrix column 2
            0, 0, 0, 1   // identity matrix column 3
        ]);

        const identityTexture = new THREE.DataTexture(
            identityData, 4, 1, THREE.RGBAFormat, THREE.FloatType
        );
        identityTexture.needsUpdate = true;
        identityTexture.flipY = false;

        // Then use this instead of null:
        const material = this._createVATMaterial(mesh, {
            texture: identityTexture,  // Instead of null
            clips: clips,
            clipIndexByName: clipIndexByName,
            fps: 30,
            cols: 4,
            rows: 1
        }, key);

        material.userData.batchKey = key;
        material.customProgramCacheKey = () => key;
        material.needsUpdate = true;

        const geometry = mesh.geometry.clone();
        const positionCount = geometry.getAttribute('position').count;
        
        // Create identity bone data (all vertices use bone 0 with weight 1)
        const boneIndices = new Float32Array(positionCount * 4);
        const boneWeights = new Float32Array(positionCount * 4);
        
        for (let i = 0; i < positionCount; i++) {
            boneIndices[i * 4] = 0;     // bone index 0
            boneWeights[i * 4] = 1;     // full weight
            // other indices/weights remain 0
        }
        
        geometry.setAttribute('aBoneIndex', new THREE.BufferAttribute(boneIndices, 4));
        geometry.setAttribute('aBoneWeight', new THREE.BufferAttribute(boneWeights, 4));

        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);
        const baseScale = (masterModel && masterModel.children[0]?.scale) ? masterModel.children[0].scale : new THREE.Vector3(1, 1, 1);
        const basePos = (masterModel && masterModel.children[0]?.position) ? masterModel.children[0].position : new THREE.Vector3(0, 0, 0);

        return {
            geometry,
            material,
            vatTexture: null, // No animation texture needed
            meta: {
                fps: 30,
                cols: 4,   // Identity matrix
                rows: 1,   // Single frame
                clips: clips,
                clipIndexByName: clipIndexByName,
                baseScale: baseScale,
                basePos: basePos
            }
        };
    }
    
    _ensureFloatAttribute(geometry, name, itemSize, fillValue = 0.0) {
        if (!geometry.getAttribute(name)) {
            const pos = geometry.getAttribute('position');
            const count = pos ? pos.count : 0;
            const arr = new Float32Array(count * itemSize);
            if (fillValue !== 0.0) arr.fill(fillValue);
            geometry.setAttribute(name, new THREE.BufferAttribute(arr, itemSize));
        }
    }

    async _collectAnimationClips(key, objectType, spawnType, unitDef) {
        const clips = [];

        // Define standard animation names in order
        const animNames = ['idle', 'walk', 'attack', 'cast', 'death', 'celebrate'];

        for (const animName of animNames) {
            // Skip if not defined in unit config
            if (!unitDef?.render?.animations?.[animName]) continue;

            try {
                // Try to get animation model
                const animKey = `${key}_${animName}`;
                const animModel = this.animationModels.get(animKey);

                if (animModel) {
                    // Extract clip from animation model
                    let clip = null;
                    animModel.traverse(obj => {
                        if (obj.userData?.animations?.[0]) {
                            clip = obj.userData.animations[0];
                        }
                    });

                    if (clip) {
                        clips.push({ name: animName, clip });
                    }
                } else {
                    console.warn(`[ModelManager] Animation model not found: ${animKey}`);
                }
            } catch (error) {
                console.warn(`[ModelManager] Failed to load animation '${animName}' for ${key}:`, error);
            }
        }

        // Ensure we have at least idle
        if (clips.length === 0 || !clips.some(c => c.name === 'idle')) {
            // Create a default idle clip
            const defaultClip = new THREE.AnimationClip('idle', 1.0, []);
            clips.unshift({ name: 'idle', clip: defaultClip });
        }

        return clips;
    }

    async _bakeVATTexture(masterModel, skeleton, clipData, fps = 30) {

        const bones = skeleton.bones;
        const boneCount = bones.length;
        const bindMatrices = skeleton.boneInverses;

        // Calculate texture dimensions
        const cols = boneCount * 4; // 4 columns per bone (matrix rows)
        let totalFrames = 0;

        const clipMeta = clipData.map(({ name, clip }) => {
            const duration = clip.duration || 1.0;
            const frames = Math.max(1, Math.ceil(duration * fps));
            totalFrames += frames;
            return { name, clip, duration, frames };
        });

        const rows = totalFrames;

        // Create texture data
        const textureData = new Float32Array(rows * cols * 4); // RGBA
        const mixer = new THREE.AnimationMixer(masterModel);
        const tempMatrix = new THREE.Matrix4();

        let currentRow = 0;

        // Bake each clip
        for (const clipInfo of clipMeta) {
            const action = mixer.clipAction(clipInfo.clip);
            action.play();


            // Bake frames for this clip
            for (let frame = 0; frame < clipInfo.frames; frame++) {
                // Calculate time for this frame
                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;
                mixer.setTime(t);
                masterModel.updateMatrixWorld(true);

                // Bake bone matrices for this frame
                for (let boneIndex = 0; boneIndex < boneCount; boneIndex++) {
                    // Calculate final bone matrix (world * inverse bind)
                    tempMatrix.copy(bones[boneIndex].matrixWorld);
                    tempMatrix.multiply(bindMatrices[boneIndex]);

                    // Store matrix as 4 columns (transposed for shader)
                    const elements = tempMatrix.elements; // column-major
                    const textureRowIndex = currentRow + frame;
                    const boneColumnStart = boneIndex * 4;

                    for (let col = 0; col < 4; col++) {
                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;
                        // Store column of matrix as RGBA
                        textureData[pixelIndex + 0] = elements[col * 4 + 0]; // x
                        textureData[pixelIndex + 1] = elements[col * 4 + 1]; // y
                        textureData[pixelIndex + 2] = elements[col * 4 + 2]; // z
                        textureData[pixelIndex + 3] = elements[col * 4 + 3]; // w
                    }
                }
            }

            action.stop();
            currentRow += clipInfo.frames;
        }

        // Create texture
        const texture = new THREE.DataTexture(
            textureData,
            cols,
            rows,
            THREE.RGBAFormat,
            THREE.FloatType
        );
        texture.needsUpdate = true;
        texture.flipY = false;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        // Build clip info with row ranges
        let rowOffset = 0;
        const clips = clipMeta.map(info => {
            const clipData = {
                name: info.name,
                startRow: rowOffset,
                endRow: rowOffset + info.frames,
                frames: info.frames,
                duration: info.duration
            };
            rowOffset += info.frames;
            return clipData;
        });

        const attachmentData = await this._bakeBoneAttachmentTexture(
            masterModel, bones, bindMatrices, mixer, clipMeta, fps
        );

        return {
            texture,
            cols,
            rows,
            fps,
            clips,
            boneCount,
            attachmentTexture: attachmentData.texture,
            attachmentBones: attachmentData.bones
        };

  
    }

    _createVATMaterial(baseMesh, vatData, batchKey = 'unknown') {
        // Get base material properties
        const sourceMaterial = Array.isArray(baseMesh.material)
            ? baseMesh.material[0]
            : baseMesh.material;

        // Create VAT material (do NOT enable skinning; we aren't using Three's path)
        const material = new THREE.MeshStandardMaterial({
            map: sourceMaterial?.map || null,
            color: sourceMaterial?.color?.clone() || new THREE.Color(0xffffff),
            metalness: sourceMaterial?.metalness ?? 0.5,
            roughness: sourceMaterial?.roughness ?? 0.5,
            transparent: false
        });

        // Add VAT shader modifications
        material.side = THREE.DoubleSide;           // helps if any frames flip winding
        material.metalness = sourceMaterial?.metalness ?? 0.05; // less metal, easier to see
        material.roughness = sourceMaterial?.roughness ?? 0.9;  // more diffuse light
        // Make VAT lookups crisp (optional but recommended)
        if(vatData.texture){
            vatData.texture.magFilter = THREE.NearestFilter;
            vatData.texture.minFilter = THREE.NearestFilter;
        }
        // Force unique shader compilation per batch
        material.userData.batchKey = batchKey;
        material.customProgramCacheKey = () => batchKey;

        material.onBeforeCompile = (shader) => {
            shader.uniforms.uVATTexture = { value: vatData.texture };
            shader.uniforms.uVATCols    = { value: vatData.cols };
            shader.uniforms.uVATRows    = { value: vatData.rows };
            shader.uniforms.uVATFPS     = { value: vatData.fps };

            // FIXED: Generate unique defines per batch to prevent cross-batch contamination
            const batchPrefix = batchKey.toUpperCase().replace(/[^A-Z0-9]/g, '_');
            const clipDefines = vatData.clips.map((clip, index) => `
                #define ${batchPrefix}_CLIP_${index}_START ${clip.startRow}.0
                #define ${batchPrefix}_CLIP_${index}_FRAMES ${clip.frames}.0
            `).join('\n');


            const clipHelpers = `
                float getClipStartRow(float clipIndex) {
                    ${vatData.clips.map((clip, i) => 
                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_START;`
                    ).join('\n                    ')}
                    return ${batchPrefix}_CLIP_0_START;
                }
                float getClipFrames(float clipIndex) {
                    ${vatData.clips.map((clip, i) => 
                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_FRAMES;`
                    ).join('\n                    ')}
                    return ${batchPrefix}_CLIP_0_FRAMES;
                }
                mat4 sampleVATMatrix(float row, float boneIndex) {
                    float boneColStart = boneIndex * 4.0;
                    float v = (row + 0.5) / uVATRows;
                    vec4 c0 = texture2D(uVATTexture, vec2((boneColStart + 0.5) / uVATCols, v));
                    vec4 c1 = texture2D(uVATTexture, vec2((boneColStart + 1.5) / uVATCols, v));
                    vec4 c2 = texture2D(uVATTexture, vec2((boneColStart + 2.5) / uVATCols, v));
                    vec4 c3 = texture2D(uVATTexture, vec2((boneColStart + 3.5) / uVATCols, v));
                    return mat4(c0, c1, c2, c3);  // columns
                }
            `;

            // strip three's skinning prelude (we supply our own attributes)
            shader.vertexShader = shader.vertexShader.replace('#include <skinning_pars_vertex>', '');

            shader.vertexShader = shader.vertexShader.replace(
                'void main() {',
                `
                // Custom VAT attributes
                attribute vec4 aBoneIndex;
                attribute vec4 aBoneWeight;
                attribute float aClipIndex;
                attribute float aAnimTime;
                attribute float aAnimSpeed;

                uniform sampler2D uVATTexture;
                uniform float uVATCols;
                uniform float uVATRows;
                uniform float uVATFPS;

                ${clipDefines}
                ${clipHelpers}

                // Shared temporaries
                float _vat_currentRow;
                mat4 _vat_bm0, _vat_bm1, _vat_bm2, _vat_bm3;

                void main() {
                `
            );

            shader.vertexShader = shader.vertexShader.replace(
            '#include <beginnormal_vertex>',
            `
            // Determine current frame
            float _clipStart  = getClipStartRow(aClipIndex);
            float _clipFrames = getClipFrames(aClipIndex);
            float _frame      = floor(mod(aAnimTime * uVATFPS, _clipFrames));
            _vat_currentRow   = _clipStart + _frame;

            // Normalize bone weights (must be available here)
            float wsum_bn = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;
            vec4 w = (wsum_bn > 0.0) ? (aBoneWeight / wsum_bn) : vec4(1.0, 0.0, 0.0, 0.0);

            // Sample bone matrices for this frame (needed for normals too)
            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);
            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);
            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);
            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);

            // Skin the normal and renormalize
            vec3 n = normal;
            vec3 skinnedN =
                    mat3(_vat_bm0) * n * w.x +
                    mat3(_vat_bm1) * n * w.y +
                    mat3(_vat_bm2) * n * w.z +
                    mat3(_vat_bm3) * n * w.w;

            vec3 objectNormal = normalize(skinnedN);
            `
            );

            // --- begin_vertex: (re)compute weights & use same matrices to skin position
            shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `
            // Recompute (safe if driver reorders chunks)
            float wsum_bv = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;
            vec4 w2 = (wsum_bv > 0.0) ? (aBoneWeight / wsum_bv) : vec4(1.0, 0.0, 0.0, 0.0);

            // Ensure matrices are available (cheap duplicates; keeps things robust)
            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);
            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);
            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);
            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);

            // Skin the position
            vec4 _pos = vec4(position, 1.0);
            vec4 _skinnedPos =
                    (_vat_bm0 * _pos) * w2.x +
                    (_vat_bm1 * _pos) * w2.y +
                    (_vat_bm2 * _pos) * w2.z +
                    (_vat_bm3 * _pos) * w2.w;

            vec3 transformed = _skinnedPos.xyz;
            `
            );
        };
        material.needsUpdate = true;
        return material;
    }

    _buildClipIndexMap(clips) {
        const map = {};
        clips.forEach((clip, index) => {
            map[clip.name] = index;
        });
        return map;
    }

    // Legacy compatibility for non-unit objects (buildings, environment objects, etc.)
    getModel(objectType, spawnType) {
        const key = `${objectType}_${spawnType}`;

        // For units, redirect to VAT system
        if (objectType === 'units') {
            console.warn(`[ModelManager] Unit '${spawnType}' should use VAT batching, not getModel()`);
            // Return master model clone for emergency compatibility
            const master = this.masterModels.get(key);
            return master ? master.clone() : null;
        }

        // For environment objects, buildings, etc. - return master model clone
        const masterModel = this.masterModels.get(key);
        if (masterModel) {
            const clone = masterModel.clone();
            // Apply basic material setup
            clone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return clone;
        }

        console.warn(`[ModelManager] No model found for ${objectType}_${spawnType}`);
        return null;
    }

    // Legacy compatibility for animations
    async getAnimation(objectType, spawnType, animName, variantIndex = 0) {
        const key = variantIndex === 0
            ? `${objectType}_${spawnType}_${animName}`
            : `${objectType}_${spawnType}_${animName}_${variantIndex}`;

        const animModel = this.animationModels.get(key);
        if (animModel) {
            const clone = animModel.clone();
            clone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return clone;
        }

        console.warn(`[ModelManager] No animation model found for ${key}`);
        return null;
    }

    // Public API
    hasVATBundle(objectType, spawnType) {
        return this.vatBundles.has(`${objectType}_${spawnType}`);
    }

    getVATBundle(objectType, spawnType) {
        return this.vatBundles.get(`${objectType}_${spawnType}`);
    }
    async _bakeBoneAttachmentTexture(masterModel, bones, bindMatrices, mixer, clipMeta, fps) {
        const attachmentBoneNames = [
            'RightHand', 'LeftHand', 'Head', 'Spine2', 'Spine'
        ];
        const bonePrefix = 'mixamorig';
        
        const attachmentBones = [];
        for (const boneName of attachmentBoneNames) {
            let foundIndex = -1;
            for (let i = 0; i < bones.length; i++) {
                const bone = bones[i];
                const cleanName = bone.name.replace(bonePrefix, '');
                if (bone.name === boneName || cleanName === boneName || bone.name.includes(boneName)) {
                    foundIndex = i;
                    break;
                }
            }
            attachmentBones.push({ name: boneName, index: foundIndex });
        }

        const validBones = attachmentBones.filter(b => b.index >= 0);
        const cols = validBones.length * 4;
        const totalFrames = clipMeta.reduce((sum, info) => sum + info.frames, 0);
        const rows = totalFrames;

        const textureData = new Float32Array(rows * cols * 4);
        const tempMatrix = new THREE.Matrix4();
        const worldMatrix = new THREE.Matrix4();

        let currentRow = 0;

        for (const clipInfo of clipMeta) {
            const action = mixer.clipAction(clipInfo.clip);
            action.play();

            for (let frame = 0; frame < clipInfo.frames; frame++) {
                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;
                mixer.setTime(t);
                masterModel.updateMatrixWorld(true);

                for (let i = 0; i < validBones.length; i++) {
                    const boneIndex = validBones[i].index;
                    const bone = bones[boneIndex];
                    
                    worldMatrix.copy(bone.matrixWorld);
                    tempMatrix.copy(worldMatrix).multiply(bindMatrices[boneIndex]);

                    const elements = tempMatrix.elements;
                    const textureRowIndex = currentRow + frame;
                    const boneColumnStart = i * 4;

                    for (let col = 0; col < 4; col++) {
                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;
                        textureData[pixelIndex + 0] = elements[col * 4 + 0];
                        textureData[pixelIndex + 1] = elements[col * 4 + 1];
                        textureData[pixelIndex + 2] = elements[col * 4 + 2];
                        textureData[pixelIndex + 3] = elements[col * 4 + 3];
                    }
                }
            }

            action.stop();
            currentRow += clipInfo.frames;
        }

        const texture = new THREE.DataTexture(
            textureData,
            cols,
            rows,
            THREE.RGBAFormat,
            THREE.FloatType
        );
        texture.needsUpdate = true;
        texture.flipY = false;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        console.log(`[ModelManager] Baked attachment texture: ${cols}x${rows} for ${validBones.length} bones`);

        return {
            texture,
            bones: attachmentBones,
            validBones
        };
    }
}
        
        // Explicitly register classes to window
        var className = "ModelManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ModelManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ModelManager";
    var className = "ModelManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ModelManager = foundLibrary;
        window.engine.ModelManager = foundLibrary;
        
    } else {
        console.warn("Could not find ModelManager after loading");
    }
})();

// Library: three_OrbitControls (external module - loaded at runtime)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["OrbitControls"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.OrbitControls = null; // Placeholder

// Library: GLTFLoader (local module - bundled)
// Original path: /global/libraries/js/GLTFLoader.js
// Bundled path: ./modules/GLTFLoader.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["GLTFLoader"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.GLTFLoader = null; // Placeholder

// Library: ECSGame (non-module - inline)
// Original path: /global/libraries/js/ECSGame.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class ECSGame extends engine.BaseECSGame {
    constructor(app){
        super(app);   
        this.imageManager = new GUTS.ImageManager(app, 
            { 
                imageSize: this.getCollections().configs.game.imageSize, 
                palette: this.getCollections().configs.game.palette, 
                textures: this.getCollections().textures
            }
        );         
        this.state = new GUTS.GameState(this.getCollections());  
        this.sceneManager = new GUTS.SceneManager(this); 
        this.moduleManager = app.moduleManager;
        this.desyncDebugger = new GUTS.DesyncDebugger(this);
    }

    init() {    
        super.init();   
        this.imageManager.dispose();
    }
}

if(typeof ECSGame != 'undefined'){
    if (typeof window !== 'undefined') {
        window.ECSGame = ECSGame;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = ECSGame;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = ECSGame;
        exports.ECSGame = ECSGame;
    }
}
        
        // Explicitly register classes to window
        var className = "ECSGame";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ECSGame:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ECSGame";
    var className = "ECSGame";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ECSGame = foundLibrary;
        window.engine.ECSGame = foundLibrary;
        
    } else {
        console.warn("Could not find ECSGame after loading");
    }
})();

// Library: three_EffectComposer (external module - loaded at runtime)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["EffectComposer"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.EffectComposer = null; // Placeholder

// Library: three_RenderPixelatedPass (external module - loaded at runtime)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["RenderPixelatedPass"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.RenderPixelatedPass = null; // Placeholder

// Library: three_OutputPass (external module - loaded at runtime)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["OutputPass"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.OutputPass = null; // Placeholder

// Library: GameModeConfigs (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameModeConfigs.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameModeConfigs {
    static getDefaultConfigs() {
        return {
            campaign: {
                name: 'Campaign',
                rounds: 10,
                goldProgression: (round) => 100 + (round * 50),
                enemyScaling: (round) => Math.floor(1 + round * 0.5),
                specialRules: ['story_mode', 'progressive_unlock']
            },
            
            survival: {
                name: 'Survival',
                rounds: Infinity,
                goldProgression: (round) => Math.max(50, 150 - (round * 5)),
                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.2)),
                specialRules: ['limited_gold', 'exponential_enemies']
            },
            
            arena: {
                name: 'Arena',
                rounds: 1,
                goldProgression: () => 200,
                enemyScaling: () => 3,
                specialRules: ['balanced_armies', 'quick_battle']
            },
            
            challenge: {
                name: 'Challenge',
                rounds: 1,
                goldProgression: (challenge) => challenge.startingGold || 100,
                enemyScaling: (challenge) => challenge.enemyCount || 3,
                specialRules: ['preset_enemies', 'special_constraints']
            },
            
            endless: {
                name: 'Endless',
                rounds: Infinity,
                goldProgression: (round) => 100 + (round * 25),
                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.5)),
                specialRules: ['infinite_scaling', 'leaderboards']
            },
            
            tournament: {
                name: 'Tournament',
                rounds: 8,
                goldProgression: (round) => 120 + (round * 30),
                enemyScaling: (round) => 2 + Math.floor(round / 2),
                specialRules: ['bracket_progression', 'ai_personalities']
            }
        };
    }

    static applyModeRules(gameInstance, mode, round) {
        const config = this.getDefaultConfigs()[mode];
        if (!config) return;

        // Apply gold progression
        if (gameInstance.state) {
            gameInstance.state.playerGold = config.goldProgression(round);
            console.log('set player gold 1', gameInstance.state.playerGold);
        }

        // Apply special rules
        config.specialRules.forEach(rule => {
            this.applySpecialRule(gameInstance, rule, round);
        });
    }

    static applySpecialRule(gameInstance, rule, round) {
        switch (rule) {
            case 'limited_gold':
                // Reduce gold income over time in survival
                break;
                
            case 'exponential_enemies':
                // Increase enemy difficulty exponentially
                break;
                
            case 'balanced_armies':
                // Ensure fair army compositions
                break;
                
            case 'infinite_scaling':
                // Allow unlimited round progression
                break;
                
            default:
                console.log(`Applying special rule: ${rule}`);
        }
    }
}
        
        // Explicitly register classes to window
        var className = "GameModeConfigs";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameModeConfigs:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameModeConfigs";
    var className = "GameModeConfigs";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameModeConfigs = foundLibrary;
        window.engine.GameModeConfigs = foundLibrary;
        
    } else {
        console.warn("Could not find GameModeConfigs after loading");
    }
})();

// Library: UIComponents (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/UIComponents.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class UIComponents {
    static createStatCard(label, value, className = '') {
        const card = document.createElement('div');
        card.className = `enhanced-ui-stat ${className}`;
        card.innerHTML = `
            <div class="stat-label">${label}</div>
            <div class="stat-value">${value}</div>
        `;
        return card;
    }

    static createProgressBar(current, max, label = '') {
        const container = document.createElement('div');
        container.className = 'progress-container';
        
        const percentage = max > 0 ? (current / max) * 100 : 0;
        
        container.innerHTML = `
            <div class="progress-label">${label}</div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${percentage}%"></div>
            </div>
            <div class="progress-text">${current}/${max}</div>
        `;
        
        return container;
    }

    static createNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        
        // Style the notification
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem;
            border-radius: 5px;
            color: white;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        `;
        
        const colors = {
            info: '#0088ff',
            success: '#00ff00',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        
        notification.style.backgroundColor = colors[type] || colors.info;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, duration);
        
        return notification;
    }

    static addProgressBarCSS() {
        const style = document.createElement('style');
        style.textContent = `
            .progress-container {
                margin: 0.5rem 0;
            }
            
            .progress-label {
                font-size: 0.8rem;
                color: #aaa;
                margin-bottom: 0.2rem;
            }
            
            .progress-bar {
                width: 100%;
                height: 1rem;
                background: #333;
                border: 1px solid #555;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #00ff00, #88ff88);
                transition: width 0.3s ease;
            }
            
            .progress-text {
                font-size: 0.7rem;
                color: #ccc;
                margin-top: 0.2rem;
                text-align: center;
            }
            
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
}

// Initialize CSS when the script loads
if (typeof document !== 'undefined') {
    window.engine.UIComponents = UIComponents;
    document.addEventListener('DOMContentLoaded', () => {
        window.engine.UIComponents.addProgressBarCSS();
    });
}
        
        // Explicitly register classes to window
        var className = "UIComponents";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing UIComponents:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "UIComponents";
    var className = "UIComponents";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.UIComponents = foundLibrary;
        window.engine.UIComponents = foundLibrary;
        
    } else {
        console.warn("Could not find UIComponents after loading");
    }
})();

// Library: NotificationSystem (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/NotificationSystem.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        // ================================
// FILE: js/ui/NotificationSystem.js - User Notifications
// ================================

class NotificationSystem {
    static notifications = [];
    static maxNotifications = 5;
    static defaultDuration = 3000;
    static container = null;
    
    static initialize() {
        this.createContainer();
        this.addNotificationCSS();
    }
    
    static createContainer() {
        if (this.container) return;
        
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.className = 'notification-container';
        document.body.appendChild(this.container);
    }
    
    static show(message, type = 'info', duration = null, options = {}) {
        this.createContainer();
        
        const notification = this.createNotification(message, type, duration || this.defaultDuration, options);
        this.addNotification(notification);
        
        return notification;
    }
    
    static createNotification(message, type, duration, options) {
        const notification = document.createElement('div');
        const id = 'notification-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        notification.id = id;
        notification.className = `notification notification-${type}`;
        notification.setAttribute('data-type', type);
        
        // Create notification content
        const content = document.createElement('div');
        content.className = 'notification-content';
        
        // Add icon based on type
        const icon = this.getTypeIcon(type);
        const iconElement = document.createElement('span');
        iconElement.className = 'notification-icon';
        iconElement.textContent = icon;
        
        // Add message
        const messageElement = document.createElement('span');
        messageElement.className = 'notification-message';
        messageElement.textContent = message;
        
        // Add close button if closable
        let closeButton = null;
        if (options.closable !== false) {
            closeButton = document.createElement('button');
            closeButton.className = 'notification-close';
            closeButton.innerHTML = '&times;';
            closeButton.type = 'button';
            closeButton.addEventListener('click', () => {
                this.remove(id);
            });
        }
        
        // Add progress bar for timed notifications
        let progressBar = null;
        if (duration > 0) {
            progressBar = document.createElement('div');
            progressBar.className = 'notification-progress';
            progressBar.innerHTML = '<div class="notification-progress-fill"></div>';
        }
        
        // Assemble notification
        content.appendChild(iconElement);
        content.appendChild(messageElement);
        if (closeButton) content.appendChild(closeButton);
        
        notification.appendChild(content);
        if (progressBar) notification.appendChild(progressBar);
        
        // Add click handler for the entire notification if specified
        if (options.onClick) {
            notification.style.cursor = 'pointer';
            notification.addEventListener('click', (e) => {
                if (e.target !== closeButton) {
                    options.onClick();
                    if (options.closeOnClick !== false) {
                        this.remove(id);
                    }
                }
            });
        }
        
        // Store notification data
        notification._notificationData = {
            id,
            type,
            duration,
            createdAt: Date.now(),
            progressBar,
            options
        };
        
        return notification;
    }
    
    static addNotification(notification) {
        // Remove excess notifications
        while (this.notifications.length >= this.maxNotifications) {
            const oldest = this.notifications.shift();
            if (oldest && oldest.parentElement) {
                oldest.parentElement.removeChild(oldest);
            }
        }
        
        // Add to container and tracking array
        this.container.appendChild(notification);
        this.notifications.push(notification);
        
        // Animate in
        setTimeout(() => {
            notification.classList.add('notification-show');
        }, 10);
        
        // Setup auto-removal timer
        const data = notification._notificationData;
        if (data.duration > 0) {
            this.setupAutoRemoval(notification);
        }
        
        // Setup progress bar animation
        if (data.progressBar) {
            this.animateProgressBar(notification);
        }
    }
    
    static setupAutoRemoval(notification) {
        const data = notification._notificationData;
        
        setTimeout(() => {
            this.remove(data.id);
        }, data.duration);
    }
    
    static animateProgressBar(notification) {
        const data = notification._notificationData;
        const progressFill = notification.querySelector('.notification-progress-fill');
        
        if (progressFill) {
            progressFill.style.transition = `width ${data.duration}ms linear`;
            setTimeout(() => {
                progressFill.style.width = '0%';
            }, 10);
        }
    }
    
    static remove(id) {
        const notification = document.getElementById(id);
        if (!notification) return;
        
        // Animate out
        notification.classList.add('notification-hide');
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.parentElement.removeChild(notification);
            }
            
            // Remove from tracking array
            this.notifications = this.notifications.filter(n => n.id !== id);
        }, 300);
    }
    
    static clear(type = null) {
        const notificationsToRemove = type 
            ? this.notifications.filter(n => n._notificationData.type === type)
            : [...this.notifications];
        
        notificationsToRemove.forEach(notification => {
            this.remove(notification._notificationData.id);
        });
    }
    
    static getTypeIcon(type) {
        const icons = {
            info: 'â„¹ï¸',
            success: 'âœ…',
            warning: 'âš ï¸',
            error: 'âŒ',
            achievement: 'ðŸ†',
            gold: 'ðŸ’°',
            battle: 'âš”ï¸',
            victory: 'ðŸŽ‰',
            defeat: 'ðŸ’€'
        };
        
        return icons[type] || icons.info;
    }
    
    // Convenience methods for common notification types
    static success(message, duration = null, options = {}) {
        return this.show(message, 'success', duration, options);
    }
    
    static error(message, duration = 5000, options = {}) {
        return this.show(message, 'error', duration, options);
    }
    
    static warning(message, duration = 4000, options = {}) {
        return this.show(message, 'warning', duration, options);
    }
    
    static info(message, duration = null, options = {}) {
        return this.show(message, 'info', duration, options);
    }
    
    static achievement(message, duration = 5000, options = {}) {
        return this.show(message, 'achievement', duration, options);
    }
    
    static gold(message, duration = 3000, options = {}) {
        return this.show(message, 'gold', duration, options);
    }
    
    static battle(message, duration = 2000, options = {}) {
        return this.show(message, 'battle', duration, options);
    }
    
    static victory(message, duration = 4000, options = {}) {
        return this.show(message, 'victory', duration, options);
    }
    
    static defeat(message, duration = 4000, options = {}) {
        return this.show(message, 'defeat', duration, options);
    }
    
    // Persistent notification (no auto-removal)
    static persistent(message, type = 'info', options = {}) {
        return this.show(message, type, 0, { closable: true, ...options });
    }
    
    static addNotificationCSS() {
        if (document.querySelector('#notification-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
            .notification-container {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 1500;
                pointer-events: none;
                max-width: 400px;
            }
            
            .notification {
                background: #1a1a2e;
                border: 2px solid;
                border-radius: 8px;
                margin-bottom: 10px;
                min-height: 60px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                overflow: hidden;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                pointer-events: auto;
                font-family: 'Courier New', monospace;
                position: relative;
            }
            
            .notification-show {
                opacity: 1;
                transform: translateX(0);
            }
            
            .notification-hide {
                opacity: 0;
                transform: translateX(100%);
                margin-bottom: 0;
                min-height: 0;
            }
            
            .notification-content {
                display: flex;
                align-items: center;
                padding: 1rem;
                position: relative;
                z-index: 1;
            }
            
            .notification-icon {
                font-size: 1.2rem;
                margin-right: 0.8rem;
                flex-shrink: 0;
            }
            
            .notification-message {
                flex: 1;
                color: #fff;
                font-size: 0.9rem;
                line-height: 1.4;
            }
            
            .notification-close {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.6);
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0;
                margin-left: 0.5rem;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: all 0.2s;
                flex-shrink: 0;
            }
            
            .notification-close:hover {
                background: rgba(255, 255, 255, 0.1);
                color: #fff;
            }
            
            .notification-progress {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 3px;
                background: rgba(255, 255, 255, 0.1);
            }
            
            .notification-progress-fill {
                width: 100%;
                height: 100%;
                background: currentColor;
                transition: none;
            }
            
            /* Type-specific styles */
            .notification-info {
                border-color: #0088ff;
                background: linear-gradient(135deg, #001133 0%, #002244 100%);
                color: #4dc3ff;
            }
            
            .notification-success {
                border-color: #00ff00;
                background: linear-gradient(135deg, #001100 0%, #003300 100%);
                color: #88ff88;
            }
            
            .notification-warning {
                border-color: #ffaa00;
                background: linear-gradient(135deg, #331100 0%, #442200 100%);
                color: #ffcc66;
            }
            
            .notification-error {
                border-color: #ff4444;
                background: linear-gradient(135deg, #330000 0%, #442222 100%);
                color: #ff8888;
            }
            
            .notification-achievement {
                border-color: #ffd700;
                background: linear-gradient(135deg, #332200 0%, #443300 100%);
                color: #ffee88;
                box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2);
            }
            
            .notification-gold {
                border-color: #ffd700;
                background: linear-gradient(135deg, #2d2200 0%, #443300 100%);
                color: #ffe066;
            }
            
            .notification-battle {
                border-color: #ff6600;
                background: linear-gradient(135deg, #330000 0%, #441100 100%);
                color: #ff9966;
            }
            
            .notification-victory {
                border-color: #00ff88;
                background: linear-gradient(135deg, #001122 0%, #003344 100%);
                color: #66ffaa;
                animation: victoryGlow 2s ease-in-out infinite;
            }
            
            @keyframes victoryGlow {
                0%, 100% { box-shadow: 0 4px 12px rgba(0, 255, 136, 0.2); }
                50% { box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4); }
            }
            
            .notification-defeat {
                border-color: #ff0000;
                background: linear-gradient(135deg, #220000 0%, #330000 100%);
                color: #ff6666;
            }
            
            /* Hover effects for clickable notifications */
            .notification[style*="cursor: pointer"]:hover {
                transform: scale(1.02);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            }
            
            /* Mobile responsiveness */
            @media (max-width: 768px) {
                .notification-container {
                    top: 10px;
                    right: 10px;
                    left: 10px;
                    max-width: none;
                }
                
                .notification {
                    margin-bottom: 8px;
                }
                
                .notification-content {
                    padding: 0.8rem;
                }
                
                .notification-message {
                    font-size: 0.85rem;
                }
            }
            
            /* Animation for notification entrance */
            @keyframes notificationSlide {
                from {
                    opacity: 0;
                    transform: translateX(100%);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }
            
            /* Special effects for achievement notifications */
            .notification-achievement {
                position: relative;
                overflow: visible;
            }
            
            .notification-achievement::before {
                content: 'âœ¨';
                position: absolute;
                top: -5px;
                right: -5px;
                font-size: 1.5rem;
                animation: sparkle 1.5s ease-in-out infinite;
            }
            
            @keyframes sparkle {
                0%, 100% { opacity: 0.5; transform: scale(1) rotate(0deg); }
                50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
            }
        `;
        document.head.appendChild(style);
    }
}
        
        // Explicitly register classes to window
        var className = "NotificationSystem";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing NotificationSystem:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "NotificationSystem";
    var className = "NotificationSystem";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.NotificationSystem = foundLibrary;
        window.engine.NotificationSystem = foundLibrary;
        
    } else {
        console.warn("Could not find NotificationSystem after loading");
    }
})();

// Library: GameLoader (non-module - inline)
// Original path: /global/libraries/js/GameLoader.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameLoader {
    constructor(game) {
        this.game = game;
    }    
    async load(){
        this.collections = this.game.getCollections();        
       // this.collections.configs.game.canvasWidth = window.outerWidth;
       // this.collections.configs.game.canvasHeight = window.outerHeight;
        this.game.palette = this.collections.palettes && this.collections.configs.game.palette ? this.collections.palettes[this.collections.configs.game.palette] : null;
        this.isometric = this.collections.configs.game.isIsometric;
        this.game.state.tileMapData = this.collections.levels[this.game.state.level].tileMap;
        this.game.state.isometric = this.collections.configs.game.isIsometric;
        if (this.game.state.modifierSet && this.collections.modifierSets) {
            this.game.state.stats = this.collections.modifierSets[this.game.state.modifierSet];
            this.game.state.defaultStats = { ...this.game.state.stats };
        }   

        this.setupCanvas(this.collections.configs.game.canvasWidth, this.collections.configs.game.canvasHeight);
        await this.loadAssets();
        this.game.translator = new GUTS.CoordinateTranslator(this.collections.configs.game, this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.isometric);
        
    
        this.game.spatialGrid = new GUTS.SpatialGrid(this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.collections.configs.game.gridSize);
        const terrainImages = this.game.imageManager.getImages("levels", this.game.state.level);

        // Use ModuleManager's script environment
        this.game.terrainTileMapper = new GUTS.TileMap(this, {}, {CanvasUtility: GUTS.CanvasUtility});

        this.game.terrainTileMapper.init(this.game.terrainCanvasBuffer, this.collections.configs.game.gridSize, terrainImages, this.isometric);

        this.game.sceneManager.load(this.collections.configs.game.initialScene);

        this.game.init();

    }

    setupCanvas(canvasWidth, canvasHeight) {
        
        this.canvas = document.getElementById("gameCanvas");
        if(this.game.getCollections().configs.game.is3D){
            this.finalCtx = this.canvas.getContext("webgl2");
        } else {
            this.finalCtx = this.canvas.getContext("2d");
        }
        this.canvasBuffer = document.createElement("canvas");
        this.ctx = this.canvasBuffer.getContext("2d");
        this.canvasBuffer.setAttribute('width', canvasWidth);
        this.canvasBuffer.setAttribute('height', canvasHeight);
        this.canvas.setAttribute('width', canvasWidth);
        this.canvas.setAttribute('height', canvasHeight);  
        
        this.terrainCanvasBuffer = document.createElement('canvas');
        this.terrainCanvasBuffer.width = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap[0].length;
        this.terrainCanvasBuffer.height = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap.length;

        this.game.canvas = this.canvas;
        this.game.finalCtx = this.finalCtx;
        this.game.canvasBuffer = this.canvasBuffer;
        this.game.ctx = this.ctx;
        this.game.terrainCanvasBuffer = this.terrainCanvasBuffer;
    }
    async loadAssets() {
         // Load all images
        for(let objectType in this.collections) {
            await this.game.imageManager.loadImages(objectType, this.collections[objectType]);
        }  
        this.game.modelManager = new GUTS.ModelManager(this.game.app, {}, { ShapeFactory: GUTS.ShapeFactory, palette: this.game.palette, textures: this.game.getCollections().textures});
        
        for(let objectType in this.collections) {
            await this.game.modelManager.loadModels(objectType, this.collections[objectType]);
        }  
 
    }
}
        
        // Explicitly register classes to window
        var className = "GameLoader";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameLoader:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameLoader";
    var className = "GameLoader";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameLoader = foundLibrary;
        window.engine.GameLoader = foundLibrary;
        
    } else {
        console.warn("Could not find GameLoader after loading");
    }
})();

// Library: GameUtils (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/GameUtils.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class GameUtils {
    static DEFAULT_UNIT_RADIUS = 25;
    static MIN_MOVEMENT_THRESHOLD = 0.1;
    
    static getUnitRadius(collision) {
        return collision?.radius ? Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius) : this.DEFAULT_UNIT_RADIUS;
    }
    
    static calculateDistance(pos1, pos2, collision1 = null, collision2 = null) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos2.z;
        const centerDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (!collision1 || !collision2) return centerDistance;
        
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        
        return {
            center: centerDistance,
            edge: Math.max(0, centerDistance - radius1 - radius2),
            toTargetEdge: Math.max(0, centerDistance - radius2)
        };
    }
    
    static lerp(a, b, t) {
        return a + (b - a) * t;
    }    
}
        
        // Explicitly register classes to window
        var className = "GameUtils";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing GameUtils:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "GameUtils";
    var className = "GameUtils";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.GameUtils = foundLibrary;
        window.engine.GameUtils = foundLibrary;
        
    } else {
        console.warn("Could not find GameUtils after loading");
    }
})();

// Library: PlacementPreview (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/PlacementPreview.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class PlacementPreview {
    constructor(game) {
        this.game = game;
        this.game.placementPreview = this;
        
        this.isActive = false;
        
        this.previewGroup = new THREE.Group();
        this.previewGroup.name = 'PlacementPreview';
        this.previewGroup.visible = false;
        this.game.uiScene.add(this.previewGroup);
        
        const configs = game.getCollections().configs.game;
        this.config = {
            cellOpacity: 0.4,
            borderOpacity: 0.8,
            unitIndicatorRadius: 3,
            unitIndicatorSegments: 8,
            elevationOffset: 0,
            unitElevationOffset: -12,
            cellSizeMultiplier: 0.9,
            maxCells: 50,
            updateThrottle: 16,
            placementGridSize: configs.gridSize / 2, // Placement grid is always half the terrain grid
            terrainGridSize: configs.gridSize // Terrain grid size for building footprints
        };

        this.geometryPool = this.createGeometryPool();
        this.materials = this.createMaterials();
        
        this.placementCellMeshPool = [];
        this.placementBorderMeshPool = [];
        this.footprintCellMeshPool = [];
        this.footprintBorderMeshPool = [];
        this.unitMeshPool = [];
        this.activeMeshes = [];

        this.animationId = null;
        this.lastUpdateTime = 0;

        this.initializeObjectPools();
    }
    
    createGeometryPool() {
        const placementCellSize = this.game.gridSystem.dimensions.cellSize * this.config.cellSizeMultiplier;
        const footprintCellSize = this.config.terrainGridSize * this.config.cellSizeMultiplier;

        return {
            placementCellPlane: new THREE.PlaneGeometry(placementCellSize, placementCellSize), // For units
            footprintCellPlane: new THREE.PlaneGeometry(footprintCellSize, footprintCellSize), // For buildings
            unitCircle: new THREE.CircleGeometry(
                this.config.unitIndicatorRadius,
                this.config.unitIndicatorSegments
            )
        };
    }
    
    createMaterials() {
        return {
            validCell: new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: this.config.cellOpacity,
                side: THREE.DoubleSide
            }),
            invalidCell: new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: this.config.cellOpacity,
                side: THREE.DoubleSide
            }),
            validBorder: new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: this.config.borderOpacity
            }),
            invalidBorder: new THREE.LineBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: this.config.borderOpacity
            }),
            validUnit: new THREE.MeshBasicMaterial({
                color: 0x00aa00,
                transparent: true,
                opacity: 0.6
            }),
            invalidUnit: new THREE.MeshBasicMaterial({
                color: 0xaa0000,
                transparent: true,
                opacity: 0.6
            })
        };
    }
    
    initializeObjectPools() {
        const maxObjects = this.config.maxCells;

        for (let i = 0; i < maxObjects; i++) {
            // Placement cell meshes (for units)
            const placementCellMesh = new THREE.Mesh(this.geometryPool.placementCellPlane, this.materials.validCell);
            placementCellMesh.rotation.x = -Math.PI / 2;
            placementCellMesh.visible = false;
            this.placementCellMeshPool.push(placementCellMesh);
            this.previewGroup.add(placementCellMesh);

            const placementBorderGeometry = new THREE.EdgesGeometry(this.geometryPool.placementCellPlane);
            const placementBorderMesh = new THREE.LineSegments(placementBorderGeometry, this.materials.validBorder);
            placementBorderMesh.rotation.x = -Math.PI / 2;
            placementBorderMesh.visible = false;
            this.placementBorderMeshPool.push(placementBorderMesh);
            this.previewGroup.add(placementBorderMesh);

            // Footprint cell meshes (for buildings)
            const footprintCellMesh = new THREE.Mesh(this.geometryPool.footprintCellPlane, this.materials.validCell);
            footprintCellMesh.rotation.x = -Math.PI / 2;
            footprintCellMesh.visible = false;
            this.footprintCellMeshPool.push(footprintCellMesh);
            this.previewGroup.add(footprintCellMesh);

            const footprintBorderGeometry = new THREE.EdgesGeometry(this.geometryPool.footprintCellPlane);
            const footprintBorderMesh = new THREE.LineSegments(footprintBorderGeometry, this.materials.validBorder);
            footprintBorderMesh.rotation.x = -Math.PI / 2;
            footprintBorderMesh.visible = false;
            this.footprintBorderMeshPool.push(footprintBorderMesh);
            this.previewGroup.add(footprintBorderMesh);

            // Unit indicator meshes
            const unitMesh = new THREE.Mesh(this.geometryPool.unitCircle, this.materials.validUnit);
            unitMesh.rotation.x = -Math.PI / 2;
            unitMesh.visible = false;
            this.unitMeshPool.push(unitMesh);
            this.previewGroup.add(unitMesh);
        }
    }
    
    showAtWorldPositions(worldPositions, isValid = true, isBuilding = false) {
        const now = performance.now();
        if (now - this.lastUpdateTime < this.config.updateThrottle) {
            return;
        }
        this.lastUpdateTime = now;

        if (!worldPositions || worldPositions.length === 0) {
            this.hide();
            return;
        }

        this.isActive = true;
        this.hideAllMeshes();

        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;
        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;

        // Choose appropriate mesh pools based on whether it's a building or unit
        const cellMeshPool = isBuilding ? this.footprintCellMeshPool : this.placementCellMeshPool;
        const borderMeshPool = isBuilding ? this.footprintBorderMeshPool : this.placementBorderMeshPool;
        const gridSize = isBuilding ? this.config.terrainGridSize : this.config.placementGridSize;

        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
            if (index >= cellMeshPool.length) return;

            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);
            const yPosition = (terrainHeight || 0) + this.config.elevationOffset;

            const cellMesh = cellMeshPool[index];
            cellMesh.material = cellMaterial;
            cellMesh.position.set(pos.x, yPosition, pos.z);
            cellMesh.visible = true;
            this.activeMeshes.push(cellMesh);

            const borderMesh = borderMeshPool[index];
            borderMesh.material = borderMaterial;
            borderMesh.position.set(pos.x, yPosition, pos.z);
            borderMesh.visible = true;
            this.activeMeshes.push(borderMesh);
        });

        this.previewGroup.visible = true;
        this.startAnimation();
    }
    
    showAtGridPositions(gridPositions, isValid = true, isBuilding = false) {
        const worldPositions = gridPositions.map(gridPos =>
            this.game.gridSystem.gridToWorld(gridPos.x, gridPos.z)
        );
        this.showAtWorldPositions(worldPositions, isValid, isBuilding);
    }

    showWithUnitMarkers(worldPositions, unitPositions, isValid = true, isBuilding = false) {
        const now = performance.now();
        if (now - this.lastUpdateTime < this.config.updateThrottle) {
            return;
        }
        this.lastUpdateTime = now;

        if (!worldPositions || worldPositions.length === 0) {
            this.hide();
            return;
        }

        this.isActive = true;
        this.hideAllMeshes();

        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;
        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;
        const unitMaterial = isValid ? this.materials.validUnit : this.materials.invalidUnit;

        // Choose appropriate mesh pools based on whether it's a building or unit
        const cellMeshPool = isBuilding ? this.footprintCellMeshPool : this.placementCellMeshPool;
        const borderMeshPool = isBuilding ? this.footprintBorderMeshPool : this.placementBorderMeshPool;
        const gridSize = isBuilding ? this.config.terrainGridSize : this.config.placementGridSize;
        // Center the mesh on the cell (gridToWorld returns corner positions)
        const halfSize = gridSize / 2;

        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
            if (index >= cellMeshPool.length) return;

            // Get terrain height at the center of the cell
            const centerX = pos.x + halfSize;
            const centerZ = pos.z + halfSize;
            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', centerX, centerZ);
            const yPosition = (terrainHeight || 0) + this.config.elevationOffset;

            const cellMesh = cellMeshPool[index];
            cellMesh.material = cellMaterial;
            cellMesh.position.set(centerX, yPosition, centerZ);
            cellMesh.visible = true;
            this.activeMeshes.push(cellMesh);

            const borderMesh = borderMeshPool[index];
            borderMesh.material = borderMaterial;
            borderMesh.position.set(centerX, yPosition, centerZ);
            borderMesh.visible = true;
            this.activeMeshes.push(borderMesh);
        });

        if (unitPositions && unitPositions.length > 0) {
            unitPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
                if (index >= this.unitMeshPool.length) return;

                // Get terrain height at the unit position
                const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);
                const yPosition = (terrainHeight || 0) + this.config.unitElevationOffset;

                const unitMesh = this.unitMeshPool[index];
                unitMesh.material = unitMaterial;
                unitMesh.position.set(pos.x, yPosition, pos.z);
                unitMesh.visible = true;
                this.activeMeshes.push(unitMesh);
            });
        }

        this.previewGroup.visible = true;
        this.startAnimation();
    }
    
    hideAllMeshes() {
        this.activeMeshes.length = 0;
        
        [...this.placementCellMeshPool, ...this.placementBorderMeshPool, ...this.footprintCellMeshPool, ...this.footprintBorderMeshPool, ...this.unitMeshPool].forEach(mesh => {
            mesh.visible = false;
        });
    }
    
    startAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        const startTime = performance.now();
        const animate = () => {
            if (!this.previewGroup.visible) {
                this.animationId = null;
                return;
            }
            
            const elapsed = (performance.now() - startTime) / 1000;
            const scale = 1 + Math.sin(elapsed * 2) * 0.05;
            
            this.activeMeshes.forEach(mesh => {
                if (mesh.visible) {
                    mesh.scale.setScalar(scale);
                }
            });
            
            this.animationId = requestAnimationFrame(animate);
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    hide() {
        this.previewGroup.visible = false;
        this.hideAllMeshes();
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    clear() {
        this.hide();
        this.isActive = false;
    }
    
    updateConfig(newConfig) {
        Object.assign(this.config, newConfig);
        
        if (newConfig.cellOpacity !== undefined) {
            this.materials.validCell.opacity = newConfig.cellOpacity;
            this.materials.invalidCell.opacity = newConfig.cellOpacity;
        }
        
        if (newConfig.borderOpacity !== undefined) {
            this.materials.validBorder.opacity = newConfig.borderOpacity;
            this.materials.invalidBorder.opacity = newConfig.borderOpacity;
        }
    }
    
    dispose() {
        this.clear();
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        if (this.previewGroup.parent) {
            this.previewGroup.parent.remove(this.previewGroup);
        }
        
        Object.values(this.geometryPool).forEach(geometry => {
            if (geometry.dispose) {
                geometry.dispose();
            }
        });
        
        Object.values(this.materials).forEach(material => {
            if (material.dispose) {
                material.dispose();
            }
        });
        
        this.cellMeshPool = [];
        this.borderMeshPool = [];
        this.unitMeshPool = [];
        this.activeMeshes = [];
    }
}
        
        // Explicitly register classes to window
        var className = "PlacementPreview";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing PlacementPreview:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "PlacementPreview";
    var className = "PlacementPreview";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.PlacementPreview = foundLibrary;
        window.engine.PlacementPreview = foundLibrary;
        
    } else {
        console.warn("Could not find PlacementPreview after loading");
    }
})();

// Library: EnemyStrategy (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/EnemyStrategy.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class EnemyStrategy {
    constructor() {
        this.current = null;
        this.history = [];
        this.playerCounters = new Map();
        
        // Strategy definitions with weights and preferences
        this.strategies = {
            balanced: {
                name: 'Balanced',
                weights: { 
                    hp: 0.3, 
                    damage: 0.4, 
                    range: 0.2, 
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: {},
                description: 'Well-rounded army composition',
                maxUnitsMultiplier: 1.0,
                valueThreshold: null
            },
            counter: {
                name: 'Counter Strategy',
                weights: {},
                unitTypePreferences: {},
                description: 'Counters player\'s last strategy',
                maxUnitsMultiplier: 1.2,
                valueThreshold: null
            },
            starter: {
                name: 'Opening Gambit',
                weights: { 
                    hp: 0.2, 
                    damage: 0.3, 
                    range: 0.3, 
                    speed: 0.2,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: {},
                maxUnitsToPlace: 2,
                description: 'Simple opening with 2 random units',
                maxUnitsMultiplier: 0.5,
                valueThreshold: 0.4
            },
            aggressive: {
                name: 'All-Out Attack',
                weights: {
                    hp: 0.1,
                    damage: 0.6,
                    range: 0.2,
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: { archer: 1.5, mage: 1.3 },
                description: 'Focus on high damage output',
                maxUnitsMultiplier: 1.3,
                valueThreshold: null
            },
            defensive: {
                name: 'Fortress Defense',
                weights: {
                    hp: 0.5,
                    damage: 0.2,
                    range: 0.1,
                    speed: 0.0,
                    armor: 0.2,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: { tank: 2.0 },
                description: 'Focus on survivability and armor',
                maxUnitsMultiplier: 0.8,
                valueThreshold: null
            },
            elemental: {
                name: 'Elemental Mastery',
                weights: {
                    hp: 0.2,
                    damage: 0.3,
                    range: 0.2,
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.2,
                    poison: 0.0
                },
                unitTypePreferences: { mage: 2.5 },
                description: 'Focus on elemental damage',
                maxUnitsMultiplier: 1.1,
                valueThreshold: null
            }
        };
        
        // Unit categorization patterns
        this.unitPatterns = {
            tank: {
                idPatterns: ['_s_'],
                statRequirements: { hp: 200, armor: 5 },
                tags: ['heavy', 'shield', 'guard', 'knight']
            },
            archer: {
                idPatterns: ['_d_'],
                statRequirements: { range: 50 },
                tags: ['bow', 'archer', 'ranger', 'marksman']
            },
            mage: {
                idPatterns: ['_i_'],
                statRequirements: {},
                elementalUnits: true,
                tags: ['mage', 'wizard', 'sorcerer', 'elemental']
            },
            fast: {
                idPatterns: [],
                statRequirements: { speed: 55 },
                tags: ['scout', 'cavalry', 'runner']
            },
            ranged: {
                idPatterns: [],
                statRequirements: { range: 50 },
                tags: ['ranged', 'projectile']
            }
        };
        
        // Strategy selection weights based on game state
        this.selectionWeights = {
            round1: { starter: 1.0 },
            earlyGame: { balanced: 0.4, aggressive: 0.3, counter: 0.3 },
            midGame: { counter: 0.5, balanced: 0.2, aggressive: 0.2, defensive: 0.1 },
            lateGame: { counter: 0.6, elemental: 0.2, aggressive: 0.1, defensive: 0.1 }
        };
    }
    
    /**
     * Select the best strategy for the current game state
     * @param {number} round - Current round number
     * @param {Array} playerPlacements - Player's unit placements
     * @param {Object} gameState - Additional game state information
     * @returns {string} Selected strategy key
     */
    selectStrategy(round, playerPlacements, gameState = {}) {
        // Always use starter strategy for round 1
        if (round === 1) {
            return 'starter';
        }
        
        // Try counter strategy if we have player data
        if (round > 1 && playerPlacements.length > 0) {
            const counterStrategy = this.getCounterStrategy(playerPlacements);
            if (counterStrategy) {
                return 'counter';
            }
        }
        
        // Select based on game phase and weighted probabilities
        const gamePhase = this.determineGamePhase(round, gameState);
        const weights = this.selectionWeights[gamePhase] || this.selectionWeights.midGame;
        
        return this.weightedRandomSelection(weights);
    }
    
    /**
     * Determine current game phase based on round and state
     * @param {number} round - Current round number
     * @param {Object} gameState - Game state information
     * @returns {string} Game phase identifier
     */
    determineGamePhase(round, gameState) {
        if (round <= 2) return 'earlyGame';
        if (round <= 5) return 'midGame';
        return 'lateGame';
    }
    
    /**
     * Select strategy using weighted random selection
     * @param {Object} weights - Strategy weights
     * @returns {string} Selected strategy key
     */
    weightedRandomSelection(weights) {
        const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        for (const [strategy, weight] of Object.entries(weights)) {
            random -= weight;
            if (random <= 0) {
                return strategy;
            }
        }
        
        return 'balanced'; // Fallback
    }
    
    /**
     * Generate counter strategy based on player army analysis
     * @param {Array} playerPlacements - Player's unit placements
     * @returns {string|null} Counter strategy or null if no clear counter
     */
    getCounterStrategy(playerPlacements) {
        const playerStats = this.analyzePlayerArmy(playerPlacements);
        
        if (playerPlacements.length === 0) {
            return null;
        }
        
        // Store player analysis for learning
        this.playerCounters.set('lastAnalysis', playerStats);
        
        // Tank-heavy counter: Use mages and elemental damage
        if (playerStats.tankHeavy) {
            this.strategies.counter.unitTypePreferences = { mage: 2.5 };
            this.strategies.counter.weights = { 
                elemental: 0.4, 
                damage: 0.4,
                range: 0.2,
                hp: 0.0,
                speed: 0.0,
                armor: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player tanks with elemental mages';
            return 'counter';
        }
        
        // Archer-heavy counter: Use fast tanks and cavalry
        if (playerStats.archerHeavy) {
            this.strategies.counter.unitTypePreferences = { tank: 2.0, fast: 1.5 };
            this.strategies.counter.weights = { 
                hp: 0.4, 
                armor: 0.3,
                speed: 0.3,
                damage: 0.0,
                range: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player archers with armored units';
            return 'counter';
        }
        
        // Mage-heavy counter: Use fast archers and anti-magic
        if (playerStats.mageHeavy) {
            this.strategies.counter.unitTypePreferences = { archer: 2.0, fast: 1.3 };
            this.strategies.counter.weights = { 
                damage: 0.4, 
                range: 0.3,
                speed: 0.3,
                hp: 0.0,
                armor: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player mages with fast archers';
            return 'counter';
        }
        
        // Elemental-heavy counter: Use physical damage
        if (playerStats.elementalHeavy) {
            this.strategies.counter.unitTypePreferences = { tank: 1.5, archer: 1.5 };
            this.strategies.counter.weights = {
                hp: 0.3,
                damage: 0.4,
                armor: 0.2,
                speed: 0.1,
                range: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering elemental units with physical damage';
            return 'counter';
        }
        
        // Balanced army counter: Focus on superior positioning and damage
        this.strategies.counter.unitTypePreferences = { 
            mage: 1.4, 
            archer: 1.3,
            tank: 1.2
        };
        this.strategies.counter.weights = { 
            damage: 0.4,
            hp: 0.2, 
            range: 0.2, 
            speed: 0.1,
            armor: 0.1,
            elemental: 0.0,
            poison: 0.0
        };
        this.strategies.counter.description = 'Countering balanced army with damage focus';
        return 'counter';
    }
    
    /**
     * Analyze player army composition and characteristics
     * @param {Array} playerPlacements - Player's unit placements
     * @returns {Object} Analysis results
     */
    analyzePlayerArmy(playerPlacements) {
        const totalUnits = playerPlacements.reduce((sum, placement) => {
            return sum + (placement.isSquad ? placement.squadUnits.length : 1);
        }, 0);
        
        if (totalUnits === 0) return {};
        
        let tankCount = 0;
        let mageCount = 0;
        let archerCount = 0;
        let fastCount = 0;
        let elementalCount = 0;
        let totalValue = 0;
        let totalHP = 0;
        let totalDamage = 0;
        
        playerPlacements.forEach(placement => {
            const unit = placement.unitType;
            const squadSize = placement.isSquad ? placement.squadUnits.length : 1;
            
            const category = this.categorizeUnit(unit);
            switch (category) {
                case 'tank': tankCount += squadSize; break;
                case 'archer': archerCount += squadSize; break;
                case 'mage': mageCount += squadSize; break;
                case 'fast': fastCount += squadSize; break;
            }
            
            if (this.isElementalUnit(unit)) {
                elementalCount += squadSize;
            }
            
            totalValue += (unit.value || 0) * squadSize;
            totalHP += (unit.hp || 0) * squadSize;
            totalDamage += (unit.damage || 0) * squadSize;
        });
        
        const analysis = {
            totalUnits,
            tankCount,
            mageCount,
            archerCount,
            fastCount,
            elementalCount,
            totalValue,
            averageValue: totalValue / totalUnits,
            averageHP: totalHP / totalUnits,
            averageDamage: totalDamage / totalUnits,
            
            // Composition flags
            tankHeavy: tankCount / totalUnits > 0.5,
            mageHeavy: mageCount / totalUnits > 0.5,
            archerHeavy: archerCount / totalUnits > 0.5,
            fastHeavy: fastCount / totalUnits > 0.4,
            elementalHeavy: elementalCount / totalUnits > 0.6,
            balanced: Math.max(tankCount, mageCount, archerCount) / totalUnits < 0.6,
            
            // Army characteristics
            highValue: totalValue / totalUnits > 100,
            tanky: totalHP / totalUnits > 150,
            glassCannon: totalDamage / totalHP > 0.5
        };
        
        return analysis;
    }
    
    /**
     * Categorize a unit based on its properties
     * @param {Object} unit - Unit definition
     * @returns {string} Unit category
     */
    categorizeUnit(unit) {
        const id = (unit.id || '').toLowerCase();
        const title = (unit.title || '').toLowerCase();
        
        // Check ID patterns first
        for (const [category, pattern] of Object.entries(this.unitPatterns)) {
            if (pattern.idPatterns.some(p => id.includes(p))) {
                return category;
            }
        }
        
        // Check stat requirements
        if (this.unitPatterns.tank.statRequirements.hp <= (unit.hp || 0) &&
            this.unitPatterns.tank.statRequirements.armor <= (unit.armor || 0)) {
            return 'tank';
        }
        
        if (this.unitPatterns.archer.statRequirements.range <= (unit.range || 0)) {
            return 'archer';
        }
        
        if (this.unitPatterns.fast.statRequirements.speed <= (unit.speed || 0)) {
            return 'fast';
        }
        
        // Check for elemental units (mages)
        if (this.isElementalUnit(unit)) {
            return 'mage';
        }
        
        // Check title/name tags
        for (const [category, pattern] of Object.entries(this.unitPatterns)) {
            if (pattern.tags && pattern.tags.some(tag => title.includes(tag))) {
                return category;
            }
        }
        
        // Default categorization based on primary stats
        if (unit.range > 30) return 'ranged';
        if (unit.speed > 50) return 'fast';
        if (unit.hp > 120) return 'tank';
        
        return 'melee';
    }
    
    /**
     * Check if a unit uses elemental damage
     * @param {Object} unit - Unit definition
     * @returns {boolean} True if unit is elemental
     */
    isElementalUnit(unit) {
        const element = (unit.element || 'physical').toLowerCase();
        return element !== 'physical' && element !== '';
    }
    
    /**
     * Calculate unit efficiency score based on strategy weights
     * @param {Object} unit - Unit definition
     * @param {Object} strategyConfig - Strategy configuration
     * @returns {number} Efficiency score
     */
    calculateUnitScore(unit, strategyConfig) {
        let score = this.calculateEfficiency(unit, strategyConfig.weights);
        
        // Apply unit type preferences
        if (strategyConfig.unitTypePreferences) {
            const unitCategory = this.categorizeUnit(unit);
            const multiplier = strategyConfig.unitTypePreferences[unitCategory] || 1.0;
            score *= multiplier;
        }
        
        // Apply strategy-specific bonuses
        score *= this.getStrategyBonus(unit, strategyConfig);
        
        return score;
    }
    
    /**
     * Calculate base unit efficiency using weighted stats
     * @param {Object} unit - Unit definition
     * @param {Object} weights - Stat weights
     * @returns {number} Base efficiency score
     */
    calculateEfficiency(unit, weights) {
        const hp = unit.hp || 100;
        const damage = unit.damage || 10;
        const range = unit.range || 1;
        const speed = unit.speed || 1;
        const armor = unit.armor || 0;
        const element = (unit.element || 'physical');        
        const poison = element === 'poison' ? 1 : 0;
        const physical = element === 'physical' ? 1 : 0;
        const elemental = (physical + poison === 0) ? 1 : 0;

        let combatValue = (hp * (weights.hp || 0)) + 
                         (damage * (weights.damage || 0)) + 
                         (range * (weights.range || 0)) + 
                         (speed * (weights.speed || 0)) + 
                         (armor * (weights.armor || 0)) + 
                         (elemental * (weights.elemental || 0)) + 
                         (poison * (weights.poison || 0));
        
        return combatValue / (unit.value || 1);
    }
    
    /**
     * Apply strategy-specific bonuses to unit score
     * @param {Object} unit - Unit definition
     * @param {Object} strategyConfig - Strategy configuration
     * @returns {number} Bonus multiplier
     */
    getStrategyBonus(unit, strategyConfig) {
        let bonus = 1.0;
        
        // Elemental strategy bonuses
        if (strategyConfig.name === 'Elemental Mastery' && this.isElementalUnit(unit)) {
            bonus *= 1.3;
        }
        
        // Defensive strategy bonuses
        if (strategyConfig.name === 'Fortress Defense' && (unit.hp || 0) > 150) {
            bonus *= 1.2;
        }
        
        // Aggressive strategy bonuses
        if (strategyConfig.name === 'All-Out Attack' && (unit.damage || 0) > 30) {
            bonus *= 1.2;
        }
        
        return bonus;
    }
    
    /**
     * Get current strategy information
     * @returns {Object} Strategy information
     */
    getCurrentStrategyInfo() {
        const strategy = this.strategies[this.current];
        return {
            current: this.current,
            name: strategy?.name || 'Unknown',
            description: strategy?.description || 'No description',
            weights: strategy?.weights || {},
            preferences: strategy?.unitTypePreferences || {},
            history: this.history.slice(-5)
        };
    }
    
    /**
     * Update strategy history
     * @param {number} round - Round number
     * @param {string} strategy - Strategy used
     * @param {Object} results - Battle results (optional)
     */
    updateHistory(round, strategy, results = {}) {
        this.current = strategy;
        this.history.push({
            round,
            strategy,
            timestamp: Date.now(),
            results
        });
        
        // Keep history manageable
        if (this.history.length > 10) {
            this.history.shift();
        }
    }
    
    /**
     * Reset strategy state
     */
    reset() {
        this.current = null;
        this.history = [];
        this.playerCounters.clear();
    }
    
    /**
     * Get strategy effectiveness analysis
     * @returns {Object} Effectiveness data
     */
    getEffectivenessAnalysis() {
        const strategyResults = new Map();
        
        this.history.forEach(entry => {
            if (!strategyResults.has(entry.strategy)) {
                strategyResults.set(entry.strategy, {
                    uses: 0,
                    wins: 0,
                    effectiveness: 0
                });
            }
            
            const data = strategyResults.get(entry.strategy);
            data.uses++;
            
            if (entry.results?.victory) {
                data.wins++;
            }
            
            data.effectiveness = data.wins / data.uses;
        });
        
        return Object.fromEntries(strategyResults);
    }
}
        
        // Explicitly register classes to window
        var className = "EnemyStrategy";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing EnemyStrategy:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "EnemyStrategy";
    var className = "EnemyStrategy";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.EnemyStrategy = foundLibrary;
        window.engine.EnemyStrategy = foundLibrary;
        
    } else {
        console.warn("Could not find EnemyStrategy after loading");
    }
})();

// Library: MultiplayerECSGame (non-module - inline)
// Original path: /global/libraries/js/MultiplayerECSGame.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class MultiplayerECSGame extends engine.ECSGame {
    constructor(app) {
        super(app);
        this.networkManager = new GUTS.ClientNetworkManager(this);
        this.isMultiplayer = true;
        this.isConnected = false;
        this.isServer = false;
    }

    async init() {
        super.init();
        
        // Check if this is a multiplayer game
        const config = this.getCollections().configs.game;
        if (config.isMultiplayer && !this.app.isServer) {
            console.log('Initializing multiplayer client...');
            
            // Connect to server
            try {
                await this.networkManager.connect(config.networkConfig?.serverUrl);
                this.isConnected = true;
                console.log('Connected to multiplayer server');
                
     
                
                // Show multiplayer UI
                this.showMultiplayerUI();
                
            } catch (error) {
                console.error('Failed to connect to server:', error);
                this.handleConnectionError(error);
            }
        }
    }

    showMultiplayerUI() {
        // Show the join room UI
        const joinUI = document.getElementById('joinUI');
        const multiplayerUI = document.getElementById('multiplayerUI');
        
        if (joinUI) {
            joinUI.style.display = 'block';
        }
        if (multiplayerUI) {
            multiplayerUI.style.display = 'none';
        }
    }

    handleConnectionError(error) {
        // Show error message to user
        const errorUI = document.getElementById('connectionError') || this.createErrorUI();
        errorUI.textContent = `Connection failed: ${error.message}`;
        errorUI.style.display = 'block';
    }

    createErrorUI() {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'connectionError';
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: red;
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 9999;
        `;
        document.body.appendChild(errorDiv);
        return errorDiv;
    }

}
        
        // Explicitly register classes to window
        var className = "MultiplayerECSGame";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing MultiplayerECSGame:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "MultiplayerECSGame";
    var className = "MultiplayerECSGame";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.MultiplayerECSGame = foundLibrary;
        window.engine.MultiplayerECSGame = foundLibrary;
        
    } else {
        console.warn("Could not find MultiplayerECSGame after loading");
    }
})();

// Library: ClientNetworkManager (non-module - inline)
// Original path: /global/libraries/js/ClientNetworkManager.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class ClientNetworkManager {
    constructor(game, options = {}) {
        this.game = game;
        this.game.clientNetworkManager = this;
        this.socket = null;
        this.isConnected = false;
        
        // Configuration
        this.serverUrl = options.serverUrl || this.game.getCollections().configs.multiplayer.serverUrl;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
        this.reconnectDelay = options.reconnectDelay || 1000;
        this.callTimeout = options.callTimeout || 10000;
        
        // Event system
        this.listeners = new Map(); // eventName -> Set of callbacks
        this.oneTimeCallbacks = new Map(); // eventName -> Map of callbackId -> callback
        this.callbackCounter = 0;
        
    }

    // =============================================
    // CONNECTION MANAGEMENT
    // =============================================

    async connect(serverUrl = null) {
        if (serverUrl) {
            this.serverUrl = serverUrl;
        }

        try {
            // Uncomment when socket.io is available
            // const { io } = await import('/socket.io/socket.io.js');
            this.socket = io(this.serverUrl, {
                transports: ['websocket', 'polling'],
                autoConnect: true, // Disable auto-connection
                reconnection: false // Disable auto-reconnection during development
            });

            this.setupSocketEventHandlers();
            
            return new Promise((resolve, reject) => {
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.emit('connect', { connected: true });
                    resolve();
                });

                this.socket.on('connect_error', (error) => {
                    console.log('disconnected:', error);
                    this.emit('connect_error', error);
                    reject(error);
                });
            });
        } catch (error) {
            console.error('Failed to initialize socket connection:', error);
            throw error;
        }
    }

    setupSocketEventHandlers() {
        // Handle disconnect
        this.socket.on('disconnect', (reason) => {
            console.log('Disconnected from server:', reason);
            this.isConnected = false;
            this.emit('disconnect', { reason });
            this.handleDisconnection();
        });

        // Forward all events to our event system
        if (typeof this.socket.onAny === 'function') {
            this.socket.onAny((eventName, data) => {
                this.emit(eventName, data);
            });
        } else {
            // Fallback for older socket.io versions
            const originalOn = this.socket.on.bind(this.socket);
            
            this.socket.on = (eventName, callback) => {
                const wrappedCallback = (data) => {
                    if (callback) callback(data);
                    this.emit(eventName, data);
                };
                
                return originalOn(eventName, wrappedCallback);
            };
        }

        window.addEventListener('beforeunload', () => {
            this.disconnect();
        });
        
        window.addEventListener('unload', () => {
            this.disconnect();
        });
    }

    handleDisconnection() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            console.log(`Attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.reconnectAttempts++;
                this.connect().catch(() => {
                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        this.emit('connection_lost', {
                            attempts: this.reconnectAttempts,
                            maxAttempts: this.maxReconnectAttempts
                        });
                    }
                });
            }, this.reconnectDelay * this.reconnectAttempts);
        } else {
            this.emit('connection_lost', {
                attempts: this.reconnectAttempts,
                maxAttempts: this.maxReconnectAttempts
            });
        }
    }

    disconnect() {
        if (this.socket) {
            this.socket.removeAllListeners(); // Remove all listeners first
            this.socket.disconnect(true); // Force disconnect
            this.socket = null;
        }
        this.isConnected = false;
        this.emit('disconnect', { reason: 'Manual disconnect' });
    }

    // =============================================
    // EVENT SYSTEM
    // =============================================

    /**
     * Listen for an event from the server
     * @param {string} eventName - The event name to listen for
     * @param {function} callback - The callback function
     * @returns {function} - Unsubscribe function
     */
    listen(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, new Set());
        }
        
        this.listeners.get(eventName).add(callback);
        
        // Return unsubscribe function
        return () => {
            const callbacks = this.listeners.get(eventName);
            if (callbacks) {
                callbacks.delete(callback);
                if (callbacks.size === 0) {
                    this.listeners.delete(eventName);
                }
            }
        };
    }

    /**
     * Remove a listener for an event
     * @param {string} eventName - The event name
     * @param {function} callback - The callback to remove
     */
    unlisten(eventName, callback) {
        const callbacks = this.listeners.get(eventName);
        if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
                this.listeners.delete(eventName);
            }
        }
    }

    /**
     * Emit an event to all listeners
     * @param {string} eventName - The event name
     * @param {any} data - The event data
     */
    emit(eventName, data) {
        // Emit to persistent listeners
        const callbacks = this.listeners.get(eventName);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in event listener for ${eventName}:`, error);
                }
            });
        }

        // Emit to one-time callbacks
        const oneTimeCallbacks = this.oneTimeCallbacks.get(eventName);
        if (oneTimeCallbacks) {
            oneTimeCallbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in one-time callback for ${eventName}:`, error);
                }
            });
            this.oneTimeCallbacks.delete(eventName);
        }
    }

    /**
     * Call a server method - optionally wait for a response
     * @param {string} sendEvent - The event to send to server
     * @param {any} data - Data to send
     * @param {string} responseEvent - The event to wait for (optional)
     * @param {function} callback - Callback when response is received (optional)
     * @param {number} timeout - Timeout in milliseconds (optional)
     * @returns {number|null} - Callback ID that can be used to cancel, or null for fire-and-forget
     */
    call(sendEvent, data = {}, responseEvent = null, callback = null, timeout = null) {
        if (!this.isConnected) {
            const error = new Error('Not connected to server');
            if (callback) {
                setTimeout(() => callback(null, error), 0);
            }
            return null;
        }

        // If no response event expected, just send (fire and forget)
        if (!responseEvent || !callback) {
            this.socket.emit(sendEvent, data);
            if (callback) {
                setTimeout(() => callback(true), 0);
            }
            return null;
        }

        // Generate unique callback ID
        const callbackId = ++this.callbackCounter;

        // Store the one-time callback
        if (!this.oneTimeCallbacks.has(responseEvent)) {
            this.oneTimeCallbacks.set(responseEvent, new Map());
        }
        
        const responseCallbacks = this.oneTimeCallbacks.get(responseEvent);
        responseCallbacks.set(callbackId, callback);

        // Set up timeout
        const timeoutMs = timeout || this.callTimeout;
        let timeoutId = null;
        if (timeoutMs > 0) {
            timeoutId = setTimeout(() => {
                const callbacks = this.oneTimeCallbacks.get(responseEvent);
                if (callbacks && callbacks.has(callbackId)) {
                    callbacks.delete(callbackId);
                    if (callbacks.size === 0) {
                        this.oneTimeCallbacks.delete(responseEvent);
                    }
                    const timeoutError = new Error(`Timeout waiting for ${responseEvent}`);
                    callback(null, timeoutError);
                }
            }, timeoutMs);
        }

        // Wrap callback to clear timeout
        if (timeoutId) {
            const originalCallback = responseCallbacks.get(callbackId);
            responseCallbacks.set(callbackId, (data) => {
                clearTimeout(timeoutId);
                originalCallback(data);
            });
        }

        // Send the event
        this.socket.emit(sendEvent, data);

        return callbackId;
    }

    /**
     * Cancel a pending call
     * @param {string} responseEvent - The response event
     * @param {number} callbackId - The callback ID
     */
    cancelCall(responseEvent, callbackId) {
        const callbacks = this.oneTimeCallbacks.get(responseEvent);
        if (callbacks && callbacks.has(callbackId)) {
            callbacks.delete(callbackId);
            if (callbacks.size === 0) {
                this.oneTimeCallbacks.delete(responseEvent);
            }
        }
    }

    // =============================================
    // UTILITY METHODS
    // =============================================

    /**
     * Get connection state
     */
    getConnectionState() {
        return {
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            maxReconnectAttempts: this.maxReconnectAttempts
        };
    }

    /**
     * Set reconnection options
     */
    setReconnectionOptions(options) {
        if (options.maxReconnectAttempts !== undefined) {
            this.maxReconnectAttempts = options.maxReconnectAttempts;
        }
        if (options.reconnectDelay !== undefined) {
            this.reconnectDelay = options.reconnectDelay;
        }
        if (options.callTimeout !== undefined) {
            this.callTimeout = options.callTimeout;
        }
    }

    // =============================================
    // CLEANUP
    // =============================================

    destroy() {
        // Clean up all listeners
        this.listeners.clear();
        this.oneTimeCallbacks.clear();
        
        // Disconnect socket
        this.disconnect();
    }
}
        
        // Explicitly register classes to window
        var className = "ClientNetworkManager";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing ClientNetworkManager:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "ClientNetworkManager";
    var className = "ClientNetworkManager";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.ClientNetworkManager = foundLibrary;
        window.engine.ClientNetworkManager = foundLibrary;
        
    } else {
        console.warn("Could not find ClientNetworkManager after loading");
    }
})();

// Library: socket.io.min.js (external module - loaded at runtime)
// Loaded from: https://cdn.socket.io/4.7.2/socket.io.min.js
window["socket_io_min_js"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.socket_io_min_js = null; // Placeholder

// Library: BaseSystem (non-module - inline)
// Original path: /global/libraries/js/BaseSystem.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class BaseSystem {
    constructor(game) {
        this.game = game;
        this.engine = game.app;
        this.componentTypes = this.game.componentManager.getComponentTypes();
    }
    postAllInit() {

    }
    
    update(){

    }

    render() {

    }

}

if(typeof BaseSystem != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseSystem = BaseSystem;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseSystem;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseSystem;
        exports.BaseSystem = BaseSystem;
    }
}
        
        // Explicitly register classes to window
        var className = "BaseSystem";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing BaseSystem:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "BaseSystem";
    var className = "BaseSystem";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.BaseSystem = foundLibrary;
        window.engine.BaseSystem = foundLibrary;
        
    } else {
        console.warn("Could not find BaseSystem after loading");
    }
})();

// Library: SeededRandom (non-module - inline)
// Original path: /global/libraries/js/SeededRandom.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class SeededRandom {
    constructor(seed) {
        this.seed = seed;
        this.current = seed;
    }
    
    next() {
        this.current = (this.current * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.current / Math.pow(2, 32);
    }
    
    range(min, max) {
        return min + this.next() * (max - min);
    }
    
    int(min, max) {
        return Math.floor(this.range(min, max + 1));
    }
}

if(typeof SeededRandom != 'undefined'){
    if (typeof window !== 'undefined') {
        window.SeededRandom = SeededRandom;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = SeededRandom;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = SeededRandom;
        exports.SeededRandom = SeededRandom;
    }
}
        
        // Explicitly register classes to window
        var className = "SeededRandom";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing SeededRandom:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "SeededRandom";
    var className = "SeededRandom";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.SeededRandom = foundLibrary;
        window.engine.SeededRandom = foundLibrary;
        
    } else {
        console.warn("Could not find SeededRandom after loading");
    }
})();

// Library: DesyncDebugger (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/DesyncDebugger.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class DesyncDebugger {
    constructor(game) {
        this.game = game;
        this.game.desyncDebugger = this;
        this.frameHashes = [];
        this.lastDisplayTime = 0;
        this.logInterval = 0; // Log every 1 sec
        this.detailedLogging = true;
        this.enabled = false;
    }
    displaySync(detailed) {    
        if(this.enabled){
            const entities = this.game.getEntitiesWith(
                this.game.componentManager.getComponentTypes().POSITION,
                this.game.componentManager.getComponentTypes().COMBAT
            );
            // Create deterministic state snapshot
            const stateData = this.createStateSnapshot(entities);
            const hash = this.hash(stateData);
            
            this.frameHashes.push({
                hash: hash,
                entityCount: entities.length,
                stateData: stateData,
                time: this.game.state.now
            });   
            if(this.game.isServer){
                console.log(this.game.state.now, hash);                    
            } else {
                console.log(this.game.state.now, hash, stateData);                    
            }
        }
    }

    createStateSnapshot(entities) {
        const CT = this.game.componentManager.getComponentTypes();
        
        const snapshot = {
            gameTime: parseFloat(this.game.state.now.toFixed(6)), // Round to avoid float precision issues
            entities: []
        };

        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const health = this.game.getComponent(entityId, CT.HEALTH);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);

            const entityData = {
                id: String(entityId),
                pos: `${this.hash(pos ? {
                    x: parseFloat(pos.x.toFixed(3)),
                    y: parseFloat(pos.y.toFixed(3)),
                    z: parseFloat(pos.z.toFixed(3))
                } : null)} ${pos.x}, ${pos.y}, ${pos.z}`,
                vel: `${this.hash(vel ? {
                    vx: parseFloat(vel.vx.toFixed(3)),
                    vy: parseFloat(vel.vy.toFixed(3)),
                    vz: parseFloat(vel.vz.toFixed(3))
                } : null)} ${vel?.vx || 0}, ${vel?.vy || 0}, ${vel?.vz || 0}`,
                healthHash: this.hash(health ? {
                    current: health.current,
                    max: health.max
                } : null),
                combatHash: this.hash(combat ? {
                    lastAttack: parseFloat(combat.lastAttack.toFixed(6)),
                    damage: combat.damage,
                    attackSpeed: combat.attackSpeed
                } : null),
                aiStateHash: this.hash(aiState ? {
                    state: aiState.state,
                    controller: aiState.aiControllerId,
                    targetPosition: aiState.targetPosition || 'null',
                    target: aiState.target || 'null'
                } : null),
                aiState: JSON.stringify(aiState)
            };

            snapshot.entities.push(entityData);
        });

        return snapshot;
    }

    hash(data) {
        // Simple hash function for state comparison
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }

    // Compare with another client's hashes
    compareHashes(otherClientHashes) {
        const mismatches = [];
        
        for (let i = 0; i < Math.min(this.frameHashes.length, otherClientHashes.length); i++) {
            const myFrame = this.frameHashes[i];
            const otherFrame = otherClientHashes[i];
            
            if (myFrame.hash !== otherFrame.hash) {
                mismatches.push({
                    frame: myFrame.frame,
                    myHash: myFrame.hash,
                    otherHash: otherFrame.hash,
                    myTime: myFrame.time,
                    otherTime: otherFrame.time,
                    myEntities: myFrame.entityCount,
                    otherEntities: otherFrame.entityCount
                });
            }
        }
        
        return mismatches;
    }

    enableDetailedLogging() {
        this.detailedLogging = true;
        console.log("Detailed desync logging enabled");
    }

    disableDetailedLogging() {
        this.detailedLogging = false;
        console.log("Detailed desync logging disabled");
    }

    // Get the last N frame hashes for comparison
    getRecentHashes(count = 10) {
        return this.frameHashes.slice(-count);
    }

    // Check for common desync patterns
    analyzeDesyncPatterns() {
        if (this.frameHashes.length < 10) return;

        const recent = this.frameHashes.slice(-10);
        const patterns = {
            stableHashes: new Set(recent.map(f => f.hash)).size === 1,
            increasingEntityCount: recent[recent.length - 1].entityCount > recent[0].entityCount,
            decreasingEntityCount: recent[recent.length - 1].entityCount < recent[0].entityCount,
            timeIncreasingMonotonically: recent.every((frame, i) => i === 0 || frame.time > recent[i-1].time)
        };

        console.log("Desync Analysis:", patterns);
        return patterns;
    }
}

if(typeof DesyncDebugger != 'undefined'){

    if (typeof window !== 'undefined') {
        window.DesyncDebugger = DesyncDebugger;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = DesyncDebugger;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = DesyncDebugger;
        exports.DesyncDebugger = DesyncDebugger;
    }
}
        
        // Explicitly register classes to window
        var className = "DesyncDebugger";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing DesyncDebugger:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "DesyncDebugger";
    var className = "DesyncDebugger";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.DesyncDebugger = foundLibrary;
        window.engine.DesyncDebugger = foundLibrary;
        
    } else {
        console.warn("Could not find DesyncDebugger after loading");
    }
})();

// Library: FantasyUIEnhancements (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/FantasyUIEnhancements.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class FantasyUIEnhancements {
    constructor(game) {
        this.game = game;
        this.initializeEnhancements();
    }

    initializeEnhancements() {
        this.setupButtonAnimations();
        this.setupModeCardSelection();
        this.setupNotificationSystem();
        this.setupBattleLogAnimations();
        this.addParticleEffects();
    }

    /**
     * Enhanced button interactions with ripple effects
     */
    setupButtonAnimations() {
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('.btn, .ready-btn, .level-up-button, .undo-button');
            buttons.forEach(button => {
                // Hover effects
                button.addEventListener('mouseenter', () => {
                    if (!button.disabled) {
                        button.style.transform = 'translateY(-2px) scale(1.02)';
                    }
                });
                
                button.addEventListener('mouseleave', () => {
                    if (!button.disabled) {
                        button.style.transform = 'translateY(0) scale(1)';
                    }
                });

                // Ripple effect on click
                button.addEventListener('click', (e) => {
                    this.createRippleEffect(e.target, e);
                });
            });
        });
    }

    /**
     * Creates ripple effect on button click
     */
    createRippleEffect(button, event) {
        const ripple = document.createElement('span');
        ripple.style.cssText = `
            position: absolute;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.6);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
            z-index: 1;
        `;
        
        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = (event.clientX - rect.left - size / 2) + 'px';
        ripple.style.top = (event.clientY - rect.top - size / 2) + 'px';
        
        button.style.position = 'relative';
        button.style.overflow = 'hidden';
        button.appendChild(ripple);
        
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.remove();
            }
        }, 600);
    }

    /**
     * Enhanced mode card selection with animations
     */
    setupModeCardSelection() {
        document.addEventListener('click', (e) => {
            const modeCard = e.target.closest('.mode-card');
            if (modeCard) {
                // Remove selected class from all cards
                const allCards = document.querySelectorAll('.mode-card');
                allCards.forEach(card => {
                    card.classList.remove('selected');
                    card.style.animation = 'cardDeselect 0.3s ease-out';
                });
                
                // Add selected class to clicked card
                modeCard.classList.add('selected');
                modeCard.style.animation = 'cardSelect 0.4s ease-out';
                
                // Create selection sound effect (visual feedback)
                this.createSelectionEffect(modeCard);
            }
        });
    }

    /**
     * Creates visual selection effect for mode cards
     */
    createSelectionEffect(card) {
        const effect = document.createElement('div');
        effect.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: selectionPulse 0.8s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        card.style.position = 'relative';
        card.appendChild(effect);
        
        setTimeout(() => {
            if (effect.parentNode) {
                effect.remove();
            }
        }, 800);
    }

    /**
     * Enhanced notification system
     */
    setupNotificationSystem() {
        this.notificationContainer = document.createElement('div');
        this.notificationContainer.id = 'notificationContainer';
        this.notificationContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        document.body.appendChild(this.notificationContainer);
    }

    /**
     * Show enhanced notification with fantasy styling
     */
    showNotification(message, type = 'info', duration = 5000) {
        const notification = document.createElement('div');
        notification.className = `fantasy-notification ${type}`;
        notification.style.cssText = `
            background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));
            border: 2px solid var(--primary-gold);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            color: var(--parchment);
            font-family: var(--font-title);
            min-width: 250px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            animation: notificationSlideIn 0.3s ease-out;
            backdrop-filter: blur(10px);
        `;

        // Set border color based on type
        switch (type) {
            case 'success':
                notification.style.borderColor = 'var(--forest-green)';
                message = `âœ… ${message}`;
                break;
            case 'error':
                notification.style.borderColor = 'var(--blood-red)';
                message = `âŒ ${message}`;
                break;
            case 'warning':
                notification.style.borderColor = 'var(--accent-amber)';
                message = `âš ï¸ ${message}`;
                break;
            default:
                message = `â„¹ï¸ ${message}`;
        }

        notification.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>${message}</span>
                <button onclick="this.parentElement.parentElement.remove()" 
                        style="background: none; border: none; color: var(--stone-gray); cursor: pointer; font-size: 1.2rem; margin-left: 1rem;">Ã—</button>
            </div>
        `;

        this.notificationContainer.appendChild(notification);

        // Auto-hide after duration
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'notificationSlideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, duration);

        return notification;
    }

    /**
     * Enhanced battle log with smooth animations
     */
    setupBattleLogAnimations() {
        this.battleLogQueue = [];
        this.isProcessingLog = false;
    }

    /**
     * Add battle log entry with animation
     */
    addBattleLogEntry(message, type = 'default') {
        this.battleLogQueue.push({ message, type });
        if (!this.isProcessingLog) {
            this.processBattleLogQueue();
        }
    }

    /**
     * Process battle log queue with animations
     */
    processBattleLogQueue() {
        if (this.battleLogQueue.length === 0) {
            this.isProcessingLog = false;
            return;
        }

        this.isProcessingLog = true;
        const { message, type } = this.battleLogQueue.shift();
        
        const battleLog = document.getElementById('battleLog');
        if (!battleLog) {
            this.processBattleLogQueue();
            return;
        }

        const entry = document.createElement('div');
        entry.classList.add('log-entry');
        if (type !== 'default') {
            entry.classList.add(`log-${type}`);
        }
        
        entry.textContent = message;
        entry.style.cssText = `
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.4s ease;
        `;

        battleLog.appendChild(entry);

        // Animate in
        setTimeout(() => {
            entry.style.opacity = '1';
            entry.style.transform = 'translateX(0)';
        }, 10);

        // Auto-scroll to bottom
        battleLog.scrollTop = battleLog.scrollHeight;

        // Remove old entries if too many
        const entries = battleLog.querySelectorAll('.log-entry');
        if (entries.length > 50) {
            const oldEntry = entries[0];
            oldEntry.style.opacity = '0';
            oldEntry.style.transform = 'translateX(-20px)';
            setTimeout(() => {
                if (oldEntry.parentNode) {
                    oldEntry.remove();
                }
            }, 400);
        }

        // Process next entry after delay
        setTimeout(() => {
            this.processBattleLogQueue();
        }, 200);
    }

    /**
     * Add floating particle effects
     */
    addParticleEffects() {
        // Add particles to main menu
        const mainMenu = document.getElementById('mainMenu');
        if (mainMenu && !mainMenu.querySelector('.particle-container')) {
            this.createParticleSystem(mainMenu);
        }

        // Add subtle particles to game screen
        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen && !gameScreen.querySelector('.particle-container')) {
            this.createParticleSystem(gameScreen, 'subtle');
        }
    }

    /**
     * Create particle system for backgrounds
     */
    createParticleSystem(container, intensity = 'normal') {
        const particleContainer = document.createElement('div');
        particleContainer.className = 'particle-container';
        particleContainer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        `;

        const particleCount = intensity === 'subtle' ? 15 : 30;
        const particleSize = intensity === 'subtle' ? 2 : 3;
        const particleOpacity = intensity === 'subtle' ? 0.3 : 0.6;

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.style.cssText = `
                position: absolute;
                width: ${particleSize}px;
                height: ${particleSize}px;
                background: radial-gradient(circle, rgba(212, 175, 55, ${particleOpacity}), transparent);
                border-radius: 50%;
                animation: particleFloat ${15 + Math.random() * 20}s linear infinite;
                animation-delay: ${Math.random() * 10}s;
                left: ${Math.random() * 100}%;
                top: ${Math.random() * 100}%;
            `;
            particleContainer.appendChild(particle);
        }

        container.style.position = 'relative';
        container.appendChild(particleContainer);
    }

    /**
     * Enhanced screen transitions
     */
    switchScreen(fromScreenId, toScreenId) {
        const fromScreen = document.getElementById(fromScreenId);
        const toScreen = document.getElementById(toScreenId);

        if (fromScreen) {
            fromScreen.style.animation = 'screenFadeOut 0.4s ease-in forwards';
            setTimeout(() => {
                fromScreen.classList.remove('active');
                fromScreen.style.animation = '';
            }, 400);
        }

        setTimeout(() => {
            if (toScreen) {
                toScreen.classList.add('active');
                toScreen.style.animation = 'screenFadeIn 0.6s ease-out';
                
                // Add particles if it's main menu
                if (toScreenId === 'mainMenu') {
                    this.addParticleEffects();
                }
            }
        }, fromScreen ? 200 : 0);
    }

    /**
     * Create enhanced unit card with animations
     */
    createEnhancedUnitCard(unitData) {
        const card = document.createElement('div');
        card.className = 'unit-card';
        card.dataset.unitId = unitData.id;
        card.style.animation = 'cardSlideIn 0.3s ease-out';

        // Add shimmer effect for rare/special units
        if (unitData.rarity && unitData.rarity !== 'common') {
            card.classList.add('rare-unit');
            this.addShimmerEffect(card, unitData.rarity);
        }

        card.innerHTML = `
            <div class="unit-name">${unitData.name || unitData.title}</div>
            <div class="unit-cost">ðŸ’° ${unitData.value || unitData.cost}g</div>
            <div class="unit-stats">âš”ï¸ ${unitData.damage} | ðŸ›¡ï¸ ${unitData.hp}</div>
        `;

        // Add tooltip
        if (unitData.description) {
            card.title = unitData.description;
        }

        // Add selection animation
        card.addEventListener('click', () => {
            this.animateUnitSelection(card);
        });

        return card;
    }

    /**
     * Add shimmer effect for rare units
     */
    addShimmerEffect(card, rarity) {
        const shimmer = document.createElement('div');
        shimmer.style.cssText = `
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);
            animation: shimmer 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        `;
        
        card.style.position = 'relative';
        card.style.overflow = 'hidden';
        card.appendChild(shimmer);
    }

    /**
     * Animate unit card selection
     */
    animateUnitSelection(card) {
        // Remove selection from other cards
        document.querySelectorAll('.unit-card.selected').forEach(c => {
            c.classList.remove('selected');
        });

        // Add selection to this card
        card.classList.add('selected');
        
        // Create selection burst effect
        const burst = document.createElement('div');
        burst.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: selectionBurst 0.6s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        card.appendChild(burst);
        setTimeout(() => burst.remove(), 600);
    }

    /**
     * Enhanced experience panel creation
     */
    createEnhancedExperiencePanel(squadData) {
        const panel = document.createElement('div');
        panel.className = 'experience-panel';
        panel.style.animation = 'experienceGlow 2s ease-in-out infinite alternate';

        panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: var(--stone-gray); font-size: 14px; font-weight: bold;">
                    ${squadData.displayName} (Lvl ${squadData.level})
                </span>
                <span style="color: var(--accent-amber); font-size: 12px;">
                    â†’ ${squadData.nextLevelName}
                </span>
            </div>
            <div class="experience-bar">
                <div class="experience-fill" style="width: 100%;"></div>
            </div>
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--stone-gray); margin-bottom: 8px;">
                <span>Ready to level up!</span>
                <span>${squadData.levelUpCost}g cost</span>
            </div>
        `;

        const levelUpButton = document.createElement('button');
        levelUpButton.className = 'level-up-button';
        levelUpButton.textContent = `Level Up (-${squadData.levelUpCost}g)`;
        levelUpButton.addEventListener('click', () => {
            this.animateLevelUp(panel);
        });

        panel.appendChild(levelUpButton);
        return panel;
    }

    /**
     * Animate level up effect
     */
    animateLevelUp(panel) {
        // Create level up burst effect
        const burst = document.createElement('div');
        burst.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.5), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: levelUpBurst 1s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        panel.style.position = 'relative';
        panel.appendChild(burst);
        
        setTimeout(() => burst.remove(), 1000);
        
        // Show success notification
        this.showNotification('ðŸŒŸ Squad leveled up successfully!', 'success');
    }

    /**
     * Copy room ID with enhanced feedback
     */
    copyRoomId() {
        const roomId = document.getElementById('lobbyRoomId').textContent;
        if (navigator.clipboard) {
            navigator.clipboard.writeText(roomId).then(() => {
                this.showNotification(`ðŸ° Room ID "${roomId}" copied to clipboard!`, 'success');
                
                // Visual feedback on the room ID element
                const roomIdEl = document.getElementById('lobbyRoomId');
                roomIdEl.style.animation = 'copyPulse 0.6s ease-out';
                setTimeout(() => {
                    roomIdEl.style.animation = '';
                }, 600);
            });
        } else {
            this.showNotification('ðŸ“‹ Copy feature not available in this browser', 'warning');
        }
    }
}

if(typeof FantasyUIEnhancements != 'undefined'){
        
    // Export for use in your game systems
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = FantasyUIEnhancements;
    } else if (typeof window !== 'undefined') {
        window.FantasyUIEnhancements = FantasyUIEnhancements;
    }
}
        
        // Explicitly register classes to window
        var className = "FantasyUIEnhancements";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing FantasyUIEnhancements:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "FantasyUIEnhancements";
    var className = "FantasyUIEnhancements";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.FantasyUIEnhancements = foundLibrary;
        window.engine.FantasyUIEnhancements = foundLibrary;
        
    } else {
        console.warn("Could not find FantasyUIEnhancements after loading");
    }
})();

// Library: MinHeap (non-module - inline)
// Original path: /projects/TurnBasedWarfare/scripts/Scripts/libraries/js/MinHeap.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].f >= this.heap[parentIndex].f) break;
            
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            let smallest = index;
            
            if (leftChild < this.heap.length && this.heap[leftChild].f < this.heap[smallest].f) {
                smallest = leftChild;
            }
            
            if (rightChild < this.heap.length && this.heap[rightChild].f < this.heap[smallest].f) {
                smallest = rightChild;
            }
            
            if (smallest === index) break;
            
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
}

if(typeof MinHeap != 'undefined'){
        
    if (typeof window !== 'undefined') {
        window.MinHeap = MinHeap;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = MinHeap;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = MinHeap;
        exports.MinHeap = MinHeap;
    }
}
        
        // Explicitly register classes to window
        var className = "MinHeap";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing MinHeap:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "MinHeap";
    var className = "MinHeap";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.MinHeap = foundLibrary;
        window.engine.MinHeap = foundLibrary;
        
    } else {
        console.warn("Could not find MinHeap after loading");
    }
})();

// Library: PerformanceProfiler (non-module - inline)
// Original path: /global/libraries/js/PerformanceProfiler.js
// Execute and register library code
(function() {
    try {
        // Execute the library code
        class PerformanceProfiler {
    constructor(game, sampleSize = 60) {
        this.game = game;
        this.game.profiler = this;
        this.sampleSize = sampleSize;
        this.timings = new Map();
        this.frameTimes = [];
        this.enabled = true;
        this.startTime = performance.now();
    }

    startMeasure(label) {
        if (!this.enabled) return;
        if (!this.timings.has(label)) {
            this.timings.set(label, {
                samples: [],
                totalTime: 0,
                calls: 0,
                avgTime: 0,
                maxTime: 0,
                minTime: Infinity
            });
        }
        return performance.now();
    }

    endMeasure(label, startTime) {
        if (!this.enabled) return;
        const duration = performance.now() - startTime;
        const stats = this.timings.get(label);
        
        if (stats) {
            stats.samples.push(duration);
            if (stats.samples.length > this.sampleSize) {
                stats.samples.shift();
            }
            
            stats.totalTime += duration;
            stats.calls++;
            stats.maxTime = Math.max(stats.maxTime, duration);
            stats.minTime = Math.min(stats.minTime, duration);
            stats.avgTime = stats.samples.reduce((a, b) => a + b, 0) / stats.samples.length;
        }
    }

    measure(label, fn) {
        const start = this.startMeasure(label);
        try {
            return fn();
        } finally {
            this.endMeasure(label, start);
        }
    }

    async measureAsync(label, fn) {
        const start = this.startMeasure(label);
        try {
            return await fn();
        } finally {
            this.endMeasure(label, start);
        }
    }

    getReport(sortBy = 'avgTime') {
        const report = [];
        for (const [label, stats] of this.timings) {
            report.push({
                label,
                avgTime: stats.avgTime,
                maxTime: stats.maxTime,
                minTime: stats.minTime,
                totalTime: stats.totalTime,
                calls: stats.calls,
                percentOfFrame: 0
            });
        }

        const totalTime = report.reduce((sum, stat) => sum + stat.avgTime, 0);
        report.forEach(stat => {
            stat.percentOfFrame = totalTime > 0 ? (stat.avgTime / totalTime * 100) : 0;
        });

        report.sort((a, b) => b[sortBy] - a[sortBy]);
        return report;
    }

    printReport() {
        const report = this.getReport();
        console.log('\n=== Performance Report ===');
        console.log('Label'.padEnd(30), 'Avg(ms)', 'Max(ms)', 'Min(ms)', '% Frame', 'Calls');
        console.log('-'.repeat(80));
        
        report.forEach(stat => {
            console.log(
                stat.label.padEnd(30),
                stat.avgTime.toFixed(3).padStart(7),
                stat.maxTime.toFixed(3).padStart(7),
                stat.minTime.toFixed(3).padStart(7),
                stat.percentOfFrame.toFixed(1).padStart(6) + '%',
                stat.calls.toString().padStart(6)
            );
        });
        
        const totalAvg = report.reduce((sum, stat) => sum + stat.avgTime, 0);
        console.log('-'.repeat(80));
        console.log('Total'.padEnd(30), totalAvg.toFixed(3).padStart(7));
        console.log('\n');
    }

    reset() {
        this.timings.clear();
        this.frameTimes = [];
    }

    toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
    }

    
    setupCommands() {
        window.debug = {
            profileSystem: (systemName) => {
                const system = this.game.systems.find(s => 
                    s.constructor.name.toLowerCase().includes(systemName.toLowerCase())
                );
                if (system) {
                    console.log(`Profiling ${system.constructor.name}...`);
                    this.game.profiler.reset();
                    setTimeout(() => {
                        this.game.profiler.printReport();
                    }, 3000);
                } else {
                    console.log(`System "${systemName}" not found`);
                }
            },
            
            listSystems: () => {
                console.log('Active Systems:');
                this.game.systems.forEach((system, i) => {
                    console.log(`${i + 1}. ${system.constructor.name}`);
                });
            },
            
            compareRuns: (duration = 5000) => {
                console.log('Starting comparison run...');
                this.game.profiler.reset();
                
                setTimeout(() => {
                    const baseline = this.game.getPerformanceReport();
                    console.log('Baseline recorded. Make changes and wait...');
                    
                    setTimeout(() => {
                        const current = this.game.getPerformanceReport();
                        console.log('\n=== Performance Comparison ===');
                        console.log('System'.padEnd(30), 'Before', 'After', 'Diff');
                        console.log('-'.repeat(70));
                        
                        baseline.forEach(before => {
                            const after = current.find(s => s.label === before.label);
                            if (after) {
                                const diff = after.avgTime - before.avgTime;
                                const diffStr = (diff > 0 ? '+' : '') + diff.toFixed(3);
                                const color = diff > 0 ? '\x1b[31m' : '\x1b[32m';
                                console.log(
                                    before.label.padEnd(30),
                                    before.avgTime.toFixed(3).padStart(7),
                                    after.avgTime.toFixed(3).padStart(7),
                                    `${color}${diffStr}\x1b[0m`.padStart(10)
                                );
                            }
                        });
                    }, duration);
                }, duration);
            }
        };
        
        console.log('Debug commands loaded. Available: debug.profileSystem(), debug.listSystems(), debug.compareRuns()');
    }
}
if(typeof PerformanceProfiler != 'undefined'){
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = PerformanceProfiler;
    }
}
        
        // Explicitly register classes to window
        var className = "PerformanceProfiler";
        if (typeof eval(className) !== 'undefined') {
            window[className] = eval(className);
            console.log("set ", className);
        }
        
    } catch (error) {
        console.error("Error executing PerformanceProfiler:", error);
    }
})();

// Register library in COMPILED_GAME
(function() {
    var foundLibrary = null;
    var libraryKey = "PerformanceProfiler";
    var className = "PerformanceProfiler";
    
    // Check for classes defined in the file

    if (window[className]) {
        foundLibrary = window[className];
        
        // Register this class by its actual name
        window.COMPILED_GAME.libraryClasses[className] = window[className];
        window.engine[className] = window[className];
    }
    
    
    if (foundLibrary) {
        window.COMPILED_GAME.libraryClasses.PerformanceProfiler = foundLibrary;
        window.engine.PerformanceProfiler = foundLibrary;
        
    } else {
        console.warn("Could not find PerformanceProfiler after loading");
    }
})();

// ========== IMPORT MAP ==========
window.COMPILED_GAME.importMap = {
  "three": "./modules/three.module.min.js",
  "RAPIER": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
  "SkeletonUtils": "./modules/three_SkeletonUtils.js",
  "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
  "GLTFLoader": "./modules/GLTFLoader.js",
  "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
  "RenderPixelatedPass": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
  "OutputPass": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js"
};
// Create and inject import map
(function() {
    if (!document.querySelector('script[type="importmap"]')) {
        const importMapScript = document.createElement('script');
        importMapScript.setAttribute('type', 'importmap');
        importMapScript.textContent = JSON.stringify({ 
            imports: window.COMPILED_GAME.importMap 
        }, null, 2);
        document.head.prepend(importMapScript);
    }
})();

// ========== EXTERNAL LIBRARY LOADER ==========
window.COMPILED_GAME.externalLibraries = [
  {
    "name": "threejs",
    "url": "./modules/three.module.min.js",
    "isModule": true,
    "requireName": "THREE",
    "isLocalModule": true
  },
  {
    "name": "Rapier",
    "url": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
    "isModule": true,
    "requireName": "RAPIER",
    "isLocalModule": false
  },
  {
    "name": "three_MeshBVH",
    "url": "./modules/three_MeshBVH.js",
    "isModule": true,
    "requireName": "three_MeshBVH",
    "windowContext": "THREE_",
    "isLocalModule": true
  },
  {
    "name": "three_SkeletonUtils",
    "url": "./modules/three_SkeletonUtils.js",
    "isModule": true,
    "requireName": "SkeletonUtils",
    "windowContext": "THREE_",
    "isLocalModule": true
  },
  {
    "name": "three_OrbitControls",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
    "isModule": true,
    "requireName": "OrbitControls",
    "windowContext": "THREE_",
    "isLocalModule": false
  },
  {
    "name": "GLTFLoader",
    "url": "./modules/GLTFLoader.js",
    "isModule": true,
    "requireName": "GLTFLoader",
    "windowContext": "THREE_",
    "isLocalModule": true
  },
  {
    "name": "three_EffectComposer",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
    "isModule": true,
    "requireName": "EffectComposer",
    "windowContext": "THREE_",
    "isLocalModule": false
  },
  {
    "name": "three_RenderPixelatedPass",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
    "isModule": true,
    "requireName": "RenderPixelatedPass",
    "windowContext": "THREE_",
    "isLocalModule": false
  },
  {
    "name": "three_OutputPass",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
    "isModule": true,
    "requireName": "OutputPass",
    "windowContext": "THREE_",
    "isLocalModule": false
  },
  {
    "name": "socket.io.min.js",
    "url": "https://cdn.socket.io/4.7.2/socket.io.min.js",
    "isModule": true,
    "requireName": "socket.io.min.js",
    "isLocalModule": false
  }
];
// Load external libraries at bundle initialization
(async function() {
    const loadPromises = [];
    
    for (const lib of window.COMPILED_GAME.externalLibraries) {
        if (lib.isModule) {
            // Import as ES module
            const loadPromise = import(lib.url).then((module) => {
                const libName = lib.requireName || lib.name;
                const loadedModule = module[libName] || module.default || module;
                
                const libraryKey = libName.replace(/-/g, "__").replace(/\./g, "_");
                
                if (lib.windowContext) {
                    if (!window[lib.windowContext]) {
                        window[lib.windowContext] = {};
                    }
                    window[lib.windowContext][libName] = loadedModule;
                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;
                    window.engine[libraryKey] = loadedModule;
                } else {
                    window[libName] = loadedModule;
                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;
                    window.engine[libraryKey] = loadedModule;
                }
                
                console.log(`Loaded ${lib.isLocalModule ? 'bundled' : 'external'} module: ${lib.name}`);
            }).catch(error => {
                console.error(`Failed to load module ${lib.name}:`, error);
            });
            
            loadPromises.push(loadPromise);
        }
    }
    
    // Wait for all external modules to load
    await Promise.all(loadPromises);
    console.log('All libraries loaded');
    
    // Dispatch event when libraries are ready
    window.dispatchEvent(new CustomEvent('compiled-libraries-ready'));
})();

// ========== GAME CLASSES ==========

// ========== Functions ==========

// Function: calculateDamage
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['calculateDamage'] = function calculateDamage(attack, target) {
    // Set default values if not provided
    
    attack.speed = attack.speed || 5;     
    attack.piercing = attack.piercing || 0,
    attack.splashRadius = attack.splashRadius || 0;
    attack.critChance = attack.critChance || .05;
    attack.critMultiplier = attack.critMultiplier || 2;
    attack.penetration = {
      "fire": attack.firePenetration || 0,
      "electric": attack.electricPenetration || 0,
      "cold": attack.coldPenetration || 0,
      "physical": attack.physicalPenetration || 0,
      "toxic": attack.toxicPenetration || 0,
    }
    target.resistances = {
      "fire": target.fireResistance || 0,
      "electric": target.electricResistance || 0,
      "cold": target.coldResistance || 0,
      "physical": target.physicalResistance || 0,
      "toxic": target.toxicResistance || 0,
    }
    
    // Initialize result object
    const result = {
      damageBlocked: 0,
      damageAbsorbed: 0,
      damageDealt: 0,
      energyShieldRemaining: target.energyShield || 0,
      wasEvaded: false,
      wasCritical: Math.random() <= attack.critChance,
      hitDetails: {}
    };
    
    // Check for evasion
    if (target.evasion && target.evasion > 0) {
      const evasionRoll = Math.random() * 100;
      if (evasionRoll < target.evasion) {
        result.wasEvaded = true;
        result.hitDetails.evasion = "Attack evaded";
        return result;
      }
    }
    
    // Calculate initial damage
    let damage = attack.baseDamage;
    
    // Apply critical hit
    if (result.wasCritical) {
      damage *= attack.critMultiplier;
      result.hitDetails.critical = `Critical hit (${attack.critMultiplier}x damage)`;
    }
    
    // Apply resistances based on damage type
  
    if(attack.damageType != "physical") {
      const resistance = target.resistances[attack.damageType] || 0;
      const penetration = attack.penetration[attack.damageType] || 0;
      const finalResist = resistance - penetration;
      let resistanceMultiplier = 1 - (finalResist / 100);
      damage *= resistanceMultiplier;
  
      
      if (finalResist !== 0) {
        if (finalResist > 0) {
          result.hitDetails.resistance = `${attack.damageType} resisted (${finalResist}%)`;
        } else {
          result.hitDetails.resistance = `${attack.damageType} vulnerability (${-finalResist}%)`;
        }
      }  
    }
    
    // Apply armor (only affects physical damage)
    if (attack.damageType === "physical" && target.armor > 0) {
      let effectiveArmor = target.armor;
      if (attack.penetration.physical > 0 ) {
        // Piercing ignores 75% of armor
        effectiveArmor = target.armor * (1 - attack.penetration.physical);
      }
      // Armor formula: damage reduction percentage = armor / (armor + 100)
      const armorReduction = effectiveArmor / (effectiveArmor + 100);
      const blockedDamage = damage * armorReduction;
      
      damage -= blockedDamage;
      result.damageBlocked = blockedDamage;
      result.hitDetails.armor = `Armor blocked ${blockedDamage.toFixed(1)} damage`;
    }
    
    // Round damage to 1 decimal place for cleaner numbers
    damage = Math.round(damage * 10) / 10;
    
    // Apply shield absorption
    if (target.energyShield > 0) {
      if (damage <= target.energyShield) {
        // Shield absorbs all damage
        result.damageAbsorbed = damage;
        result.energyShieldRemaining = target.energyShield - damage;
        result.hitDetails.energyShield = `Shield absorbed all damage, ${result.energyShieldRemaining.toFixed(1)} shield remaining`;
        damage = 0;
      } else {
        // Shield is depleted, remaining damage goes through
        result.damageAbsorbed = target.energyShield;
        result.damageDealt = damage - target.energyShield;
        result.energyShieldRemaining = 0;
        result.hitDetails.energyShield = `Shield depleted, ${result.damageDealt.toFixed(1)} damage dealt to health`;
        damage -= target.energyShield;
      }
    } else {
      // No shield, all damage goes to health
      result.damageDealt = damage;
    }
    
    // Make sure we don't return negative damage
    result.damageDealt = Math.max(0, result.damageDealt);
    
    return result;
  }
;

// Function: calculateStats
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['calculateStats'] = function calculateStats(stats, calcArray) {

    if( calcArray && calcArray.length > 0 ) {
        let additiveStats = {};
        let multiplicitiveStats = {};
        for(let key in stats) {
            additiveStats[key] = [];
            multiplicitiveStats[key] = [];
        }
        for(let effect of calcArray) {
            effect.apply(stats, additiveStats, multiplicitiveStats);
        }
        let addedEffects = {};
        for(let key in additiveStats){
            for(let val of additiveStats[key]){ 
                if(addedEffects[key]){
                    addedEffects[key] += val - 1;
                } else {
                    addedEffects[key] = val - 1;
                }
            }
        }

        for(let key in addedEffects) {
            if( stats[key] ) {
                stats[key] *= ( 1 + addedEffects[key] );
            }
        }

        let multipliedUpgrades = {};        
        for(let key in multiplicitiveStats){
            for(let val of multiplicitiveStats[key]){ 
                if(stats[key]){
                    stats[key] *= val;
                }
            }
        }
    }
};

// ========== Managers ==========

// manager: ComponentManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ComponentManager'] = class ComponentManager {
    constructor(game) {
        this.game = game;
        this.game.componentManager = this;
        this.models = this.game.getCollections().models;        
        this.game.componentTypes = this.getComponentTypes();
        //this.models.position == { x: 0, y: 0, z: 0 };
    }

    deepMerge(target, source) {
        const result = { ...target };
        
        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else {
                result[key] = source[key] == 'null' ? null : source[key];
            }
        }
        
        return result;
    }

    getModels() {
        let components = {};
        Object.keys(this.models).forEach((modelId) => {
            const data = this.models[modelId];
            components[modelId] = (params = {}) => {
                return this.deepMerge(data, params);
            };        
        });
        return components;
    }
    getComponents(){
        return {
            Position: (x = 0, y = 0, z = 0) => ({ x, y, z }),
            Velocity: (vx = 0, vy = 0, vz = 0, maxSpeed = 100, affectedByGravity = true, anchored = false) => ({ vx, vy, vz, maxSpeed, affectedByGravity, anchored}),
            Facing: (angle) => ({ angle: angle || 0 }),
            Renderable: (objectType, spawnType, capacity = 128) => ({ objectType, spawnType, capacity }),
            Collision: (radius = 1, height = 50) => ({ radius, height }),
            Health: (max = 100) => ({ max, current: max }),
            Building: (type) => ( { type }),
            
            // Enhanced Combat component with elemental damage and defenses
            Combat: (
                damage = 0, 
                range = 1, 
                attackSpeed = 1, 
                projectile = null, 
                lastAttack = 0,
                element = 'physical',
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                visionRange = 300
            ) => ({
                damage,
                range,
                attackSpeed,
                projectile,
                lastAttack,
                element,
                armor,
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                visionRange
            }),
            Placement: (placement = null) => (placement),
            Team: (team = 'neutral') => ({ team }),
            UnitType: (unitType) => ({ ...unitType }),
            AIState: (state = 'idle', targetPosition = null, target = null, aiControllerId = null, meta = {} ) => 
                ({ state, targetPosition, target, aiControllerId, meta }),
            Animation: (scale = 1, rotation = 0, flash = 0) => ({ scale, rotation, flash }),
            
            // Enhanced Projectile component with element support
            Projectile: (
                damage = 10, 
                speed = 200, 
                range = 100, 
                target = null, 
                source = null, 
                startTime = 0,
                element = 'physical'
            ) => ({
                damage,
                speed,
                range,
                target,
                source,
                startTime,
                element
            }),
            Lifetime: (duration = 5, startTime = 0) => ({ duration, startTime }),
            HomingTarget: (targetId = null, homingStrength = 0.5, lastKnownPosition = null) => 
                ({ targetId, homingStrength, lastKnownPosition }),
            
            // Enhanced Equipment component that can provide resistances
            Equipment: (slots = {}) => ({ 
                slots: {
                    mainHand: null,
                    offHand: null,
                    helmet: null,
                    chest: null,
                    legs: null,
                    feet: null,
                    back: null,
                    ...slots
                }
            }),
            
            EquipmentSlot: (slotType, itemId = null, attachmentPoint = null, offset = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) => ({
                slotType,
                itemId,
                attachmentPoint,
                offset,
                rotation
            }),
            
            // Enhanced EquipmentItem with defensive stats
            EquipmentItem: (
                itemType, 
                modelPath, 
                stats = {},
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                element = null  // Weapon element
            ) => ({
                itemType,
                modelPath,
                stats: {
                    ...stats,
                    armor,
                    fireResistance,
                    coldResistance,
                    lightningResistance,
                    poisonResistance,
                    element
                },
                attachmentData: {
                    mainHand: {
                        bone: 'Hand_R',
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    offHand: {
                        bone: 'Hand_L', 
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    }
                }
            }),
            
            Corpse: (originalUnitType = null, deathTime = 0, teamAtDeath = 'neutral') => ({ 
                originalUnitType, 
                deathTime, 
                teamAtDeath,
                isCorpse: true 
            }),
            
            DeathState: (isDying = false, deathStartTime = 0, deathAnimationDuration = 2.0) => ({ 
                isDying, 
                deathStartTime, 
                deathAnimationDuration 
            }),

            // Status effect component for tracking temporary effects
            StatusEffect: (
                effectType = 'buff',
                element = null,
                duration = 0,
                startTime = 0,
                sourceId = null,
                stacks = 1,
                maxStacks = 1
            ) => ({
                effectType,  // 'buff', 'debuff', 'dot', 'immunity'
                element,
                duration,
                startTime,
                sourceId,
                stacks,
                maxStacks
            }),

            // Resistance component for temporary resistances/immunities
            ElementalResistance: (
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                physicalResistance = 0,
                divineResistance = 0,
                duration = null,
                permanent = true
            ) => ({
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                physicalResistance,
                divineResistance,
                duration,
                permanent
            }),

            // =============================================
            // TACTICAL ABILITY COMPONENTS (from original)
            // =============================================
            MiningState: (state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId) => ({
                state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId
            }),
            BuildingState: (state, targetBuildingEntityId, targetBuildingPosition, constructionStartTime) => ({
                state, 
                targetBuildingEntityId, 
                targetBuildingPosition, 
                constructionStartTime                
            }),
            MindControlled: (originalTeam = 'neutral', controller = null, endTime = 0) => ({
                originalTeam,
                controller,
                endTime,
                isControlled: true
            }),
            
            MirrorImage: (originalEntity = null, isIllusion = true, createdTime = 0) => ({
                originalEntity,
                isIllusion,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Trap: (
                damage = 50, 
                radius = 80, 
                triggerRadius = 30, 
                element = 'physical', 
                caster = null, 
                triggered = false, 
                maxTriggers = 1
            ) => ({
                damage,
                radius,
                triggerRadius,
                element,
                caster,
                triggered,
                triggerCount: 0,
                maxTriggers
            }),
            
            Summoned: (summoner = null, summonType = 'generic', originalStats = null, createdTime = 0) => ({
                summoner,
                summonType,
                originalStats,
                createdTime: createdTime || (this.game.state.now || 0),
                isSummoned: true
            }),
            
            TemporaryEffect: (effectType = 'generic', data = {}, createdTime = 0) => ({
                effectType,
                data,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Thorns: (reflectionPercent = 0.5, endTime = 0, totalReflected = 0) => ({
                reflectionPercent,
                endTime: endTime || (this.game.state.now || 0) + 20,
                totalReflected,
                isActive: true
            }),
            
            Taunt: (taunter = null, endTime = 0, radius = 0, isTaunted = true) => ({
                taunter,
                endTime: endTime || (this.game.state.now || 0) + 5,
                radius,
                isTaunted
            }),
            
            ShieldWall: (damageReduction = 0.75, endTime = 0, tauntRadius = 200, originalArmor = 0) => ({
                damageReduction,
                endTime: endTime || (this.game.state.now || 0) + 10,
                tauntRadius,
                originalArmor,
                isActive: true
            }),
            
            // =============================================
            // ENHANCED BUFF SYSTEM FOR NEW SPELLS
            // =============================================
            
            Buff: (
                buffType = 'generic', 
                modifiers = {}, 
                endTime = 0, 
                stackable = false, 
                stacks = 1, 
                appliedTime = 0
            ) => ({
                buffType,
                modifiers,
                endTime: endTime || (this.game.state.now || 0) + 30,
                stackable,
                stacks,
                appliedTime: appliedTime || (this.game.state.now || 0),
                isActive: true,
                
                // Specific buff properties based on type
                ...(buffType === 'rallied' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.3,
                    moralBoost: true,
                    fearImmunity: true
                }),
                
                ...(buffType === 'intimidated' && {
                    damageReduction: modifiers.damageReduction || 0.25,
                    accuracyReduction: modifiers.accuracyReduction || 0.2
                }),
                
                ...(buffType === 'phalanx' && {
                    armorMultiplier: modifiers.armorMultiplier || 1.0,
                    counterAttackChance: modifiers.counterAttackChance || 0.2,
                    formationSize: modifiers.formationSize || 1
                }),
                
                ...(buffType === 'marked' && {
                    damageTakenMultiplier: modifiers.damageTakenMultiplier || 1.25,
                    revealed: true,
                    markedBy: modifiers.markedBy || null
                }),
                
                ...(buffType === 'poison_weapon' && {
                    poisonDamage: modifiers.poisonDamage || 25,
                    poisonDuration: modifiers.poisonDuration || 6,
                    attacksRemaining: modifiers.attacksRemaining || 5
                }),
                
                ...(buffType === 'disrupted' && {
                    abilitiesDisabled: true,
                    accuracyReduction: modifiers.accuracyReduction || 0.4,
                    movementSlowed: modifiers.movementSlowed || 0.6
                }),
                
                ...(buffType === 'magic_weapon' && {
                    weaponElement: modifiers.weaponElement || 'fire',
                    elementalDamage: modifiers.elementalDamage || 15,
                    glowing: true
                }),
                
                ...(buffType === 'dark_empowerment' && {
                    damageMultiplier: modifiers.damageMultiplier,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier
                }),
                
                ...(buffType === 'ice_armor' && {
                    armorMultiplier: modifiers.armorMultiplier,
                }),
                
                ...(buffType === 'rage' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.5,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier || 1.3
                }),
                
                ...(buffType === 'bloodlust' && {
                    lifeSteal: modifiers.lifeSteal || 0.3,
                    damagePerKill: modifiers.damagePerKill || 5,
                    maxStacks: modifiers.maxStacks || 10
                }),
                
                ...(buffType === 'stunned' && {
                    movementDisabled: true,
                    attackDisabled: true
                })
            }),
            
            Whirlwind: (
                damage = 30, 
                radius = 80, 
                endTime = 0, 
                hitInterval = 0.3, 
                lastHitTime = 0, 
                totalHits = 0
            ) => ({
                damage,
                radius,
                endTime: endTime || (this.game.state.now || 0) + 2,
                hitInterval,
                lastHitTime,
                totalHits,
                isActive: true
            }),

            // =============================================
            // FORMATION AND SQUAD COMPONENTS
            // =============================================
            
            Formation: (
                formationType = 'none',
                formationSize = 1,
                formationLeader = null,
                formationMembers = [],
                formationBonuses = {},
                isActive = false
            ) => ({
                formationType, // 'phalanx', 'wedge', 'line', 'circle', etc.
                formationSize,
                formationLeader,
                formationMembers,
                formationBonuses,
                isActive,
                createdTime: (this.game.state.now || 0)
            }),
            
            SquadMember: (
                squadId = null,
                squadRole = 'member', // 'leader', 'member', 'specialist'
                squadPosition = { x: 0, z: 0 },
                squadBonuses = {}
            ) => ({
                squadId,
                squadRole,
                squadPosition,
                squadBonuses,
                joinedTime: (this.game.state.now || 0)
            }),

            // =============================================
            // ABILITY COOLDOWN AND RESOURCE COMPONENTS
            // =============================================
            
            AbilityCooldowns: (cooldowns = {}) => ({
                cooldowns, // Map of abilityId -> cooldownEndTime
                lastAbilityUsed: null,
                lastAbilityTime: 0
            }),
            
            ResourcePool: (
                mana = 100,
                maxMana = 100,
                manaRegen = 5,
                stamina = 100,
                maxStamina = 100,
                staminaRegen = 10,
                focus = 100,
                maxFocus = 100
            ) => ({
                mana,
                maxMana,
                manaRegen,
                stamina,
                maxStamina, 
                staminaRegen,
                focus,
                maxFocus,
                lastRegenTick: (this.game.state.now || 0)
            }),

            // =============================================
            // VISUAL EFFECT COMPONENTS
            // =============================================
            
            VisualEffect: (
                effectType = 'particle',
                effectData = {},
                duration = 1.0,
                startTime = 0,
                attachedTo = null
            ) => ({
                effectType,
                effectData,
                duration,
                startTime: startTime || (this.game.state.now || 0),
                attachedTo,
                isActive: true
            }),
            
            Aura: (
                auraType = 'generic',
                radius = 50,
                effects = {},
                visualEffect = null,
                persistent = true,
                pulseInterval = 1.0,
                lastPulse = 0
            ) => ({
                auraType,
                radius,
                effects,
                visualEffect,
                persistent,
                pulseInterval,
                lastPulse,
                createdTime: (this.game.state.now || 0)
            }),

            // =============================================
            // TARGETING AND AI COMPONENTS
            // =============================================
            
            TargetingPreference: (
                preferredTargets = [],
                avoidedTargets = [],
                targetPriority = 'nearest',
                maxTargetRange = 200,
                requiresLineOfSight = false
            ) => ({
                preferredTargets,
                avoidedTargets,
                targetPriority, // 'nearest', 'weakest', 'strongest', 'marked', 'leader'
                maxTargetRange,
                requiresLineOfSight,
                currentTarget: null,
                targetLockTime: 0
            }),
            
            Threat: (
                threatLevel = 0,
                maxThreat = 100,
                threatDecay = 1,
                lastThreatUpdate = 0,
                threatSources = new Map()
            ) => ({
                threatLevel,
                maxThreat,
                threatDecay,
                lastThreatUpdate,
                threatSources
            }),

            // =============================================
            // SPECIAL ABILITY STATE COMPONENTS
            // =============================================
            
            Charging: (
                target = null,
                chargeSpeed = 100,
                chargeDamage = 50,
                chargeStartTime = 0,
                chargeDistance = 0,
                maxChargeDistance = 150
            ) => ({
                target,
                chargeSpeed,
                chargeDamage,
                chargeStartTime,
                chargeDistance,
                maxChargeDistance,
                isCharging: true
            }),
            
            Channeling: (
                abilityId = null,
                channelDuration = 3.0,
                channelStartTime = 0,
                canBeInterrupted = true,
                interruptThreshold = 10
            ) => ({
                abilityId,
                channelDuration,
                channelStartTime,
                canBeInterrupted,
                interruptThreshold,
                isChanneling: true
            }),
            
            Stealthed: (
                stealthLevel = 1.0, // 0.0 = invisible, 1.0 = fully visible
                detectionRadius = 30,
                stealthStartTime = 0,
                canAttackWhileStealth = false,
                breaksOnAttack = true
            ) => ({
                stealthLevel,
                detectionRadius,
                stealthStartTime,
                canAttackWhileStealth,
                breaksOnAttack,
                isStealth: true
            }),

            // =============================================
            // ENVIRONMENTAL INTERACTION COMPONENTS  
            // =============================================
            
            EnvironmentalHazard: (
                hazardType = 'generic',
                damagePerTick = 10,
                tickInterval = 1.0,
                element = 'physical',
                affectsTeams = ['all'],
                lastTickTime = 0
            ) => ({
                hazardType, // 'fire', 'poison_cloud', 'ice_field', 'lightning_storm', etc.
                damagePerTick,
                tickInterval,
                element,
                affectsTeams,
                lastTickTime,
                createdTime: (this.game.state.now || 0)
            }),
            
            Consecrated: (
                consecrationLevel = 1.0,
                healPerTick = 5,
                damageToUndead = 10,
                tickInterval = 2.0,
                caster = null,
                lastTickTime = 0
            ) => ({
                consecrationLevel,
                healPerTick,
                damageToUndead,
                tickInterval,
                caster,
                lastTickTime,
                isConsecrated: true
            }),

            // =============================================
            // COMMAND QUEUE SYSTEM
            // =============================================

            CommandQueue: (
                commands = [],
                currentCommand = null,
                commandHistory = []
            ) => ({
                commands,           // Array of pending commands
                currentCommand,     // Currently executing command
                commandHistory      // History of completed commands (for debugging)
            }),

            Command: (
                type = 'move',
                controllerId = null,
                targetPosition = null,
                target = null,
                meta = {},
                priority = 0,
                interruptible = true,
                createdTime = 0
            ) => ({
                type,               // 'move', 'build', 'mine', 'attack', etc.
                controllerId,       // Which AI controller to activate
                targetPosition,     // Target position for movement
                target,            // Target entity ID
                meta,              // Controller-specific metadata
                priority,          // Higher priority interrupts lower priority
                interruptible,     // Can this command be interrupted?
                createdTime: createdTime || (this.game.state.now || 0),
                id: Math.random().toString(36).substr(2, 9) // Unique command ID
            })
        };
    }

    getComponentTypes() {
        return {
            // Basic Components
            TRANSFORM: 'transform',
            POSITION: 'position',
            FACING: 'facing',
            VELOCITY: 'velocity',
            SCALE: 'scale',
            RENDERABLE: 'renderable',
            MAP_RENDERER: 'mapRenderer',
            SPRITE: 'sprite',
            MAP_MANAGER: 'mapManager',
            WORLD_OBJECT: 'worldObject',
            ENVIRONMENT_OBJECT: 'environmentObject',
            
            // Unit Components
            PLACEMENT: 'placement',
            TEAM: 'team',
            UNIT_TYPE: 'unitType',
            AI_STATE: 'aiState',
            ANIMATION: 'animation',
            HEALTH: 'health',
            COMBAT: 'combat',
            COLLISION: 'collision',
            BUILDING: 'building',
            
            // Projectile System
            PROJECTILE: 'projectile',
            LIFETIME: 'lifetime',
            HOMING_TARGET: 'homingTarget',
            
            // Entity System
            ENTITY_TYPE: 'entityType',
            LEVEL_DATA: 'levelData',
            
            // Equipment System
            EQUIPMENT: 'equipment',
            EQUIPMENT_SLOT: 'equipmentSlot',
            EQUIPMENT_ITEM: 'equipmentItem',
            
            // Death System
            CORPSE: 'corpse',
            DEATH_STATE: 'deathState',
            
            // Status Effects
            STATUS_EFFECT: 'statusEffect',
            ELEMENTAL_RESISTANCE: 'elementalResistance',

            // =============================================
            // TACTICAL ABILITY COMPONENT TYPES
            // =============================================
            MIND_CONTROLLED: 'mindControlled',
            MIRROR_IMAGE: 'mirrorImage',
            TRAP: 'trap',
            SUMMONED: 'summoned',
            TEMPORARY_EFFECT: 'temporaryEffect',
            THORNS: 'thorns',
            TAUNT: 'taunt',
            SHIELD_WALL: 'shieldWall',
            BUFF: 'buff',
            WHIRLWIND: 'whirlwind',

            // =============================================
            // NEW SPELL SUPPORT COMPONENT TYPES
            // =============================================
            
            // Formation and Squad
            FORMATION: 'formation',
            SQUAD_MEMBER: 'squadMember',
            
            // Ability Resources
            ABILITY_COOLDOWNS: 'abilityCooldowns',
            RESOURCE_POOL: 'resourcePool',
            
            // Visual Effects
            VISUAL_EFFECT: 'visualEffect',
            AURA: 'aura',
            MINING_STATE: 'miningState',
            BUILDING_STATE: 'buildingState',
            // AI and Targeting
            TARGETING_PREFERENCE: 'targetingPreference',
            THREAT: 'threat',
            
            // Special States
            CHARGING: 'charging',
            CHANNELING: 'channeling',
            STEALTHED: 'stealthed',
            
            // Environmental
            ENVIRONMENTAL_HAZARD: 'environmentalHazard',
            CONSECRATED: 'consecrated',

            // Command Queue
            COMMAND_QUEUE: 'commandQueue'
        };
    }
};

// manager: GameManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GameManager'] = class GameManager {
    constructor(game) {
        this.game = game;
        this.game.gameManager = this;
        this.services = new Map();
    }

    initializeGame(){
        if (!this.game.screenManager.selectedGameMode) {
            alert('Please select a game mode first!');
            return;
        }

        this.game.screenManager.showLoadingScreen();
        
        // Update loading content based on selected mode
        const mode = this.game.gameModeManager.getSelectedMode();
        if (mode) {
            const loadingTip = document.querySelector('.loading-tip');
            if (loadingTip) {
                loadingTip.textContent = `Mode: ${mode.title} - ${mode.description}`;
            }
        }

        this.game.triggerEvent('onGameStarted');

        setTimeout(() => {   
            this.game.state.isPaused = false;
            this.game.uiSystem.start();
            this.game.screenManager.showGameScreen();  
        }, 2000);
        
    }

    pauseGame() {
        this.game.screenManager.pause();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'flex';
        }
    }

    resumeGame() {
        this.game.screenManager.resume();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    restartGame() {
        const confirmRestart = this.game.screenManager.currentScreen === 'gameScreen' 
            ? confirm('Are you sure you want to restart? Your current progress will be lost.')
            : true;

        if (confirmRestart) {
            this.initializeGame();
        }
        
        // Hide pause menu if open
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    exitToMenu() {
        if (confirm('Are you sure you want to exit to the main menu? Your progress will be lost.')) {
            this.game.phaseSystem.reset();
            this.game.screenManager.showMainMenu();
        }
    }

    continueGame() {
        // Continue to next round/level
        this.game.screenManager.stats.round++;
        this.initializeGame();
    }

    // Systems call this in constructor or init()
    register(key, method) {
        if (this.services.has(key)) {
            debugger;
            console.warn(`Service ${key} already registered! Overwriting.`);
        }
        this.services.set(key, method);
    }

    has(key){
        return this.services.has(key);
    }

    // Public API
    call(key, ...args) {
        const method = this.services.get(key);
        if (!method) {
            return undefined;
        }
        return method(...args);
    }

    // Optional: async version
    async callAsync(key, ...args) {
        return this.call(key, ...args);
    }

    // Debug
    listServices() {
        return Array.from(this.services.keys());
    }

}
;

// manager: GameModeManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GameModeManager'] = class GameModeManager {
    constructor(app) {
        this.game = app;
        this.game.gameModeManager = this;        
        this.modes = this.initializeGameModes();
        this.setupUI();
    }

    initializeGameModes() {
        return {
            arena: {
                id: 'arena',
                title: 'Arena',
                icon: 'âš”ï¸',
                interfaceId: 'createOrJoinRoom',
                description: 'Battle against another player in real-time strategic combat',
                difficulty: 'Player vs Player',
                difficultyClass: 'pvp',
                isMultiplayer: true,
                maxPlayers: 2,
                startingGold: 100,
                onStart: (mode) => {
                    this.game.uiSystem.handleMultiplayerModeSelection(mode);
                }
            }
            // ,
            // campaign: {
            //     id: 'campaign',
            //     title: 'Campaign',
            //     icon: 'ðŸ†',
            //     description: 'Progress through increasingly difficult battles and unlock new units',
            //     startingGold: 100
            // },
            // survival: {
            //     id: 'survival',
            //     title: 'Survival',
            //     icon: 'âš¡',
            //     description: 'See how many waves you can survive with limited resources',
            //     startingGold: 150
            // },
            // arena: {
            //     id: 'arena',
            //     title: 'Arena',
            //     icon: 'âš”ï¸',
            //     description: 'Quick battles with balanced armies for testing strategies',
            //     startingGold: 200
            // },
            // challenge: {
            //     id: 'challenge',
            //     title: 'Challenge',
            //     icon: 'ðŸ’€',
            //     description: 'Face pre-built enemy compositions with specific constraints',
            //     startingGold: 100
            // },
            // endless: {
            //     id: 'endless',
            //     title: 'Endless',
            //     icon: 'â™¾ï¸',
            //     description: 'Battle continues until defeat with exponentially scaling enemies',
            //     startingGold: 100
            // },
            // tournament: {
            //     id: 'tournament',
            //     title: 'Tournament',
            //     icon: 'ðŸ…',
            //     description: 'Bracket-style competition against AI opponents',
            //     startingGold: 120
            // }
        };
    }

    setupUI() {
        const modeGrid = document.getElementById('modeGrid');
        if (!modeGrid) return;

        modeGrid.innerHTML = '';
        
        Object.values(this.modes).forEach(mode => {
            const card = this.createModeCard(mode);
            modeGrid.appendChild(card);
        });
    }

    createModeCard(mode) {
        const card = document.createElement('div');
        card.className = 'mode-card';
        card.dataset.mode = mode.id;
        
        card.innerHTML = `
            <div class="mode-icon">${mode.icon}</div>
            <div class="mode-title">${mode.title}</div>
            <div class="mode-description">${mode.description}</div>
            <div class="mode-difficulty ${mode.difficultyClass}">${mode.difficulty}</div>
        `;

        card.addEventListener('click', () => this.selectMode(mode.id));
        
        return card;
    }

    selectMode(modeId) {
        // Remove previous selection
        document.querySelectorAll('.mode-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Add selection to clicked card
        const selectedCard = document.querySelector(`[data-mode="${modeId}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
            this.game.screenManager.setGameMode(modeId);
            const modeConfig = this.getModeConfig(modeId);
            modeConfig.onStart(modeConfig);
        }
    }

    getSelectedMode() {
        return this.modes[this.game.screenManager.selectedGameMode];
    }

    getModeConfig(modeId) {
        return this.modes[modeId];
    }
};

// manager: KeyboardManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['KeyboardManager'] = class KeyboardManager {
    constructor(app) {
        this.game = app;
        this.game.keyboardManager = this;
    }
};

// manager: LoadingManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['LoadingManager'] = class LoadingManager {
    constructor(app) {
        this.game = app;
        this.game.loadingManager = this;
        this.loadingSteps = [
            'Initializing game engine...',
            'Loading unit data...',
            'Preparing battlefield...',
            'Setting up AI opponents...',
            'Ready to battle!'
        ];
    }

    showLoadingWithProgress(onComplete) {
        let currentStep = 0;
        const loadingText = document.querySelector('.loading-text');
        
        const progressInterval = setInterval(() => {
            if (currentStep < this.loadingSteps.length) {
                if (loadingText) {
                    loadingText.textContent = this.loadingSteps[currentStep];
                }
                currentStep++;
            } else {
                clearInterval(progressInterval);
                onComplete();
            }
        }, 400);
    }
};

// manager: ResultsManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ResultsManager'] = class ResultsManager {
    constructor(app) {
        this.game = app;
        this.game.resultsManager = this;                
    }

    showVictory(stats) {
        this.populateStats('victoryStats', stats, 'victory');
        this.game.screenManager.showVictoryScreen();
    }

    showDefeat(stats) {
        this.populateStats('defeatStats', stats, 'defeat');
        this.game.screenManager.showDefeatScreen();
    }

    populateStats(containerId, stats, type) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const statItems = type === 'victory' 
            ? this.getVictoryStats(stats)
            : this.getDefeatStats(stats);

        statItems.forEach(item => {
            const card = this.createStatCard(item.label, item.value);
            container.appendChild(card);
        });
    }

    getVictoryStats(stats) {
        return [
            { label: 'Round Reached', value: stats.round || 1 },
            { label: 'Gold Earned', value: stats.goldEarned || 0 },
            { label: 'Units Deployed', value: stats.unitsDeployed || 0 },
            { label: 'Time Played', value: this.formatTime(stats.totalPlayTime || 0) }
        ];
    }

    getDefeatStats(stats) {
        return [
            { label: 'Final Round', value: stats.round || 1 },
            { label: 'Total Gold', value: stats.goldEarned || 0 },
            { label: 'Units Lost', value: stats.unitsLost || 0 },
            { label: 'Survival Time', value: this.formatTime(stats.totalPlayTime || 0) }
        ];
    }

    createStatCard(label, value) {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
            <div class="stat-label">${label}</div>
            <div class="stat-value">${value}</div>
        `;
        return card;
    }

    formatTime(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
};

// manager: SaveManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SaveManager'] = class SaveManager {
    constructor(app) {
        this.game = app;
        this.game.saveManager = this;
        this.setupAutoSave();
    }

    setupAutoSave() {
        // Auto-save every 30 seconds
        setInterval(() => {
            this.saveGameState();
        }, 30000);
    }

    saveGameState() {
     
    }

    loadGameState() {
        // In a real implementation, you might load from localStorage here
        // const saved = localStorage.getItem('autoBattleArena_save');
        // return saved ? JSON.parse(saved) : null;
        return null;
    }
}
;

// manager: ScreenManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ScreenManager'] = class ScreenManager {
    constructor(app) {
        this.game = app;
        this.game.screenManager = this;
    }

    

    showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
            targetScreen.classList.add('active');
        }
    }

    showMainMenu() {
        this.setScreen('mainMenu');
    }

    showGameModeSelect() {
        this.setScreen('gameModeSelect');
        // Reset selection
        document.querySelectorAll('.mode-card').forEach(card => {
            card.classList.remove('selected');
        });
        this.selectedGameMode = null;
    }

    showLoadingScreen() {
        this.setScreen('loadingScreen');
    }

    showGameScreen() {
        this.setScreen('gameScreen');
    }

    showVictoryScreen() {
        this.setScreen('victoryScreen');
    }

    showDefeatScreen() {
        this.setScreen('defeatScreen');
    }


    
    reset() {
        this.currentScreen = 'mainMenu';
        this.selectedGameMode = null;
        this.gameStartTime = null;
        this.isPaused = false;
        this.stats = {
            round: 1,
            goldEarned: 0,
            unitsDeployed: 0,
            unitsLost: 0,
            totalPlayTime: 0
        };
    }

    setScreen(screenId) {
        this.currentScreen = screenId;
        this.showScreen(screenId);
    }

    setGameMode(mode) {
        this.selectedGameMode = mode;
    }

    onGameStarted() {
        this.gameStartTime = Date.now();
    }

    endGame(result, finalStats = {}) {
        if (this.gameStartTime) {
            this.stats.totalPlayTime = Date.now() - this.gameStartTime;
        }
        Object.assign(this.stats, finalStats);
    }

    pause() {
        this.isPaused = true;
    }

    resume() {
        this.isPaused = false;
    }
};

// manager: UnitCreationManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['UnitCreationManager'] = class UnitCreationManager {
    constructor(game) {
        this.game = game;
        this.game.unitCreationManager = this;
        this.SPEED_MODIFIER = 20;
        // Default component values for missing unit data
        this.defaults = {
            hp: 100,
            damage: 10,
            range: 30,
            speed: 40,
            attackSpeed: 1.0,
            size: 5,
            height: 50,
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0,
            element: 'physical',
            projectile: null,
            value: 50
        };
        
        // Equipment slot priorities for auto-equipping
        this.equipmentPriority = [
            'weapon',
            'armor',
            'helmet',
            'boots',
            'gloves',
            'accessory'
        ];
        
        // Team-specific configurations
        this.teamConfigs = {
            left: {
                initialFacing: 0,
                aiState: 'idle',
                colorTint: null
            },
            right: {
                initialFacing: Math.PI,
                aiState: 'idle',
                colorTint: 0xff4444
            }
        };
        
        // Component creation cache for performance
        this.componentCache = new Map();
        
        // Unit creation statistics
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Create a new unit entity with all required components
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier ('left' or 'right')
     * @returns {number} Entity ID
     */
    create(worldX, worldY, worldZ, targetPosition, placement, team) {
        const unitType = placement.unitType;
        try {
            // Round world coordinates to ensure deterministic entity IDs across client and server
            const roundedX = Math.round(worldX * 100) / 100;
            const roundedZ = Math.round(worldZ * 100) / 100;
            const entity = this.game.createEntity(`${unitType.id}_${roundedX}_${roundedZ}_${team}_${this.game.state.round}`);
            console.log('created unit', unitType.id, team, entity);
            const teamConfig = this.teamConfigs[team];
            // Add core components
            this.addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig);
            
            // Add combat components
            this.addCombatComponents(entity, unitType);
            
            // Add AI and behavior components
            this.addBehaviorComponents(entity, targetPosition, unitType);
            
            // Add visual and interaction components
            this.addVisualComponents(entity, unitType, teamConfig);
            
            // Schedule equipment and abilities (async to avoid blocking)
            this.schedulePostCreationSetup(entity, unitType);
            
            // Update statistics
            this.updateCreationStats(unitType, team);
            return entity;
        } catch (error) {
            console.error('Failed to create unit:', error);
            throw new Error(`Unit creation failed: ${error.message}`);
        }
    }


    /**
     * Create multiple squads efficiently from placement data
     * @param {Array} placements - Array of placement data from client
     * @param {string} team - Team identifier
     * @param {string|null} playerId - Optional player ID
     * @returns {Array} Array of created squad placement data
     */
    createSquadFromPlacement(placement, team, playerId = null) {

        const gridPosition = placement.gridPosition;
        const targetPosition = placement.targetPosition;
        const unitType = placement.unitType;

        try {
            // Get squad configuration
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                console.log("invalid squad config");
                return false;
            }

            // Calculate unit positions within the squad
            const unitPositions = this.game.squadManager.calculateUnitPositions(
                gridPosition,
                unitType
            );

            // Calculate cells occupied by the squad
            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);

            // Generate unique placement ID
            const placementId = `squad_${team}_${gridPosition.x}_${gridPosition.z}`;
            const squadUnits = [];

            
            // Create individual units for the squad
            for (const pos of unitPositions) {
                const terrainHeight = this.getTerrainHeight(pos.x, pos.z);
                const unitY = terrainHeight !== null ? terrainHeight : 0;

                const entityId = this.create(pos.x, unitY, pos.z, targetPosition, placement, team);

                // Add playerId to the team component if provided
                if (playerId && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    const teamComponent = this.game.getComponent(entityId, ComponentTypes.TEAM);
                    if (teamComponent) {
                        teamComponent.playerId = playerId;
                    }
                }
                if(unitType.collection == 'buildings'){
                    this.game.placementSystem.saveBuilding(entityId, team, gridPosition, unitType)
                }
                squadUnits.push(entityId);
                this.game.gameManager.call('reserveGridCells', cells, entityId);
            }

            // Occupy grid cells
            // Update squad creation statistics
            this.stats.squadsCreated++;

            // Initialize squad in experience system if available
            if (this.game.squadExperienceSystem) {
                this.game.squadExperienceSystem.initializeSquad(placementId, unitType, squadUnits, team);
            }

            // const squadInfo = this.game.squadManager.getSquadInfo(unitType);
         
            return {
                placementId: placementId,
                gridPosition: gridPosition,
                unitType: unitType,
                squadUnits: squadUnits,
                cells: cells,
                isSquad: squadUnits.length > 1,
                team: team,
                playerId: playerId,
                timestamp: Date.now()
            };

        } catch (error) {
            console.error('Squad creation failed:', error);
            throw new Error(`Squad creation failed: ${error.message}`);
        }
    
    }

    /**
     * Clean up squads by destroying their units and freeing grid cells
     * @param {Array} squads - Array of squad placement data
     */
    cleanupSquads(squads) {
        for (const squad of squads) {
            try {
                // Destroy squad units
                for (const unit of squad.squadUnits || []) {
                    if (this.game.destroyEntity && unit) {
                        this.game.destroyEntity(unit);
                    }
                }

                // Free grid cells
                if (this.game.gridSystem && squad.placementId) {
                    this.game.gridSystem.freeCells(squad.placementId);
                }

                // Remove from experience system
                if (this.game.squadExperienceSystem && squad.placementId) {
                    this.game.squadExperienceSystem.removeSquad(squad.placementId);
                }

            } catch (error) {
                console.warn(`Failed to cleanup squad ${squad.placementId}:`, error);
            }
        }
    }

    /**
     * Get squad information for a unit type
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad information
     */
    getSquadInfo(unitType) {
        if (this.game.squadManager) {
            return this.game.squadManager.getSquadInfo(unitType);
        }
        
        // Fallback squad info
        return {
            unitName: unitType.title || unitType.id || 'Unknown',
            squadSize: 1,
            formationType: 'single',
            spacing: 1
        };
    }

    /**
     * Validate if a squad can be placed at the given position
     * @param {Object} gridPosition - Grid position {x, z}
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @returns {boolean} True if placement is valid
     */
    canPlaceSquad(gridPosition, unitType, team) {
        if (!this.game.squadManager || !this.game.gridSystem) {
            return this.game.gridSystem ? 
                this.game.gridSystem.isValidPosition(gridPosition) : true;
        }

        try {
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                return false;
            }

            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);
            return this.game.gridSystem.isValidPlacement(cells, team);
            
        } catch (error) {
            console.warn('Squad placement validation failed:', error);
            return false;
        }
    }
    
    /**
     * Add core position and identity components
     * @param {number} entity - Entity ID
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @param {Object} teamConfig - Team configuration
     */
    addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig) {
        const unitType = placement.unitType;
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Position component
        this.game.addComponent(entity, ComponentTypes.POSITION, 
            Components.Position(worldX, worldY, worldZ));
        
        // Velocity component with movement capabilities
        const maxSpeed = (unitType.speed) * this.SPEED_MODIFIER;
        this.game.addComponent(entity, ComponentTypes.VELOCITY, 
            Components.Velocity(0, 0, 0, maxSpeed, true, unitType.collection == 'buildings' ? true : false));
        
        // Team identification
        this.game.addComponent(entity, ComponentTypes.TEAM, 
            Components.Team(team));
        
        this.game.addComponent(entity, ComponentTypes.PLACEMENT, 
            Components.Placement(placement));
        
        // Unit type information
        this.game.addComponent(entity, ComponentTypes.UNIT_TYPE, 
            Components.UnitType(
                unitType
            ));
        
        // Facing direction
        this.game.addComponent(entity, ComponentTypes.FACING, 
            Components.Facing(teamConfig.initialFacing));
    }
    
    /**
     * Add combat-related components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    addCombatComponents(entity, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // Health component
        const maxHP = unitType.hp || this.defaults.hp;
        this.game.addComponent(entity, ComponentTypes.HEALTH, 
            Components.Health(maxHP));
        
        // Combat component with all combat stats
        this.game.addComponent(entity, ComponentTypes.COMBAT, 
            Components.Combat(
                unitType.damage,
                unitType.range,
                unitType.attackSpeed,
                unitType.projectile,
                0, // Initial attack cooldown
                unitType.element,
                unitType.armor,
                unitType.fireResistance,
                unitType.coldResistance,
                unitType.lightningResistance, 
                0,
                unitType.visionRange
            ));
        
        // Collision component for physical interactions
        this.game.addComponent(entity, ComponentTypes.COLLISION, 
            Components.Collision(unitType.size || this.defaults.size, unitType.height));
    }
    
    /**
     * Add AI and behavior components
     * @param {number} entity - Entity ID
     */
    addBehaviorComponents(entity, targetPosition, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // AI state for behavior control
        this.game.addComponent(entity, ComponentTypes.AI_STATE, 
            Components.AIState('idle', targetPosition));
        
        // Animation state
        this.game.addComponent(entity, ComponentTypes.ANIMATION, 
            Components.Animation());
        
        // Equipment container
        this.game.addComponent(entity, ComponentTypes.EQUIPMENT, 
            Components.Equipment());
    }
    
    /**
     * Add visual and rendering components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     * @param {Object} teamConfig - Team configuration
     */
    addVisualComponents(entity, unitType, teamConfig) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Renderable component for visual representation
        this.game.addComponent(entity, ComponentTypes.RENDERABLE, 
            Components.Renderable(unitType.collection, unitType.id || 'default'));
        
        // Add team-specific visual modifications
        if (teamConfig.colorTint && this.game.addComponent) {
            // Optional: Add color tint component if available
            try {
                if (ComponentTypes.COLOR_TINT) {
                    this.game.addComponent(entity, ComponentTypes.COLOR_TINT,
                        Components.ColorTint(teamConfig.colorTint));
                }
            } catch (error) {
                // Color tint not available, continue without it
            }
        }
    }
    
    /**
     * Schedule post-creation setup (equipment and abilities)
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    schedulePostCreationSetup(entityId, unitType) {

        this.setupEquipment(entityId, unitType);
        this.setupAbilities(entityId, unitType);
    }
    
    /**
     * Equip unit with items from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    async setupEquipment(entityId, unitType) {

        if (!this.game.equipmentSystem || !unitType?.render?.equipment) {
            return;
        }
        
        try {
            // Sort equipment by priority for better equipping order
            const equipmentList = [...unitType.render.equipment].sort((a, b) => {
                const priorityA = this.equipmentPriority.indexOf(a.slot) || 999;
                const priorityB = this.equipmentPriority.indexOf(b.slot) || 999;
                return priorityA - priorityB;
            });
            
            // Equip each item
            for (const equippedItem of equipmentList) {
                const itemData = this.getItemFromCollection(equippedItem.item);
                if (itemData) {
                    try {
                        await this.game.equipmentSystem.equipItem(
                            entityId, 
                            equippedItem, 
                            itemData, 
                            equippedItem.item
                        );
                    } catch (equipError) {
                        console.warn(`Failed to equip ${equippedItem.item} on slot ${equippedItem.slot}:`, equipError);
                        this.stats.equipmentFailures++;
                    }
                } else {
                    console.warn(`Item ${equippedItem.item} not found in collections`);
                    this.stats.equipmentFailures++;
                }
            }
        } catch (error) {
            console.error(`Equipment setup failed for entity ${entityId}:`, error);
            this.stats.equipmentFailures++;
        }
    }
    
    /**
     * Add abilities to unit from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    setupAbilities(entityId, unitType) {
        if (!this.game.abilitySystem || !unitType?.abilities) {
            return;
        }
        
        try {
            // Validate abilities exist before adding
            const validAbilities = unitType.abilities.filter(abilityId => {
                const abilityData = this.getAbilityFromCollection(abilityId);
                if (!abilityData) {
                    console.warn(`Ability ${abilityId} not found in collections`);
                    this.stats.abilityFailures++;
                    return false;
                }
                return true;
            });
            
            if (validAbilities.length > 0) {
                this.game.abilitySystem.addAbilitiesToUnit(entityId, validAbilities);
            }
        } catch (error) {
            console.error(`Ability setup failed for entity ${entityId}:`, error);
            this.stats.abilityFailures++;
        }
    }
    
    /**
     * Get item data from game collections
     * @param {string} itemId - Item identifier
     * @returns {Object|null} Item data or null if not found
     */
    getItemFromCollection(itemId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.items?.[itemId]) {
                return null;
            }
            return collections.items[itemId];
        } catch (error) {
            console.warn(`Error accessing item collection for ${itemId}:`, error);
            return null;
        }
    }
    
    /**
     * Get ability data from game collections
     * @param {string} abilityId - Ability identifier
     * @returns {Object|null} Ability data or null if not found
     */
    getAbilityFromCollection(abilityId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.abilities?.[abilityId]) {
                return null;
            }
            return collections.abilities[abilityId];
        } catch (error) {
            console.warn(`Error accessing ability collection for ${abilityId}:`, error);
            return null;
        }
    }
    
    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeight(worldX, worldZ) {
        try {
            if (this.game.terrainSystem?.getTerrainHeightAtPosition) {
                return this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);
            }
        } catch (error) {
            console.warn(`Error getting terrain height at (${worldX}, ${worldZ}):`, error);
        }
        return 0; // Default to ground level
    }
    
    
    /**
     * Update creation statistics
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     */
    updateCreationStats(unitType, team) {
        this.stats.totalCreated++;
        
        // Track by team
        const teamCount = this.stats.createdByTeam.get(team) || 0;
        this.stats.createdByTeam.set(team, teamCount + 1);
        
        // Track by unit type
        const unitTypeId = unitType.id || 'unknown';
        const typeCount = this.stats.createdByType.get(unitTypeId) || 0;
        this.stats.createdByType.set(unitTypeId, typeCount + 1);
    }
    
    /**
     * Get creation statistics
     * @returns {Object} Statistics summary
     */
    getStats() {
        return {
            totalCreated: this.stats.totalCreated,
            createdByTeam: Object.fromEntries(this.stats.createdByTeam),
            createdByType: Object.fromEntries(this.stats.createdByType),
            equipmentFailures: this.stats.equipmentFailures,
            abilityFailures: this.stats.abilityFailures,
            squadsCreated: this.stats.squadsCreated,
            successRate: {
                equipment: 1 - (this.stats.equipmentFailures / Math.max(1, this.stats.totalCreated)),
                abilities: 1 - (this.stats.abilityFailures / Math.max(1, this.stats.totalCreated))
            }
        };
    }
    
    /**
     * Reset creation statistics
     */
    resetStats() {
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Validate unit type definition
     * @param {Object} unitType - Unit type to validate
     * @returns {Object} Validation result
     */
    validateUnitType(unitType) {
        const errors = [];
        const warnings = [];
        
        if (!unitType) {
            errors.push('Unit type is required');
            return { valid: false, errors, warnings };
        }
        
        // Check required fields
        if (!unitType.id) warnings.push('Unit ID missing, using default');
        if (!unitType.title) warnings.push('Unit title missing, using ID or default');
        
        // Validate numeric stats
        const numericFields = ['hp', 'damage', 'range', 'speed', 'armor', 'value'];
        numericFields.forEach(field => {
            if (unitType[field] !== undefined && (isNaN(unitType[field]) || unitType[field] < 0)) {
                errors.push(`${field} must be a non-negative number`);
            }
        });
        
        // Check equipment references
        if (unitType.render?.equipment) {
            unitType.render.equipment.forEach((item, index) => {
                if (!item.item) {
                    warnings.push(`Equipment item ${index} missing item ID`);
                }
                if (!item.slot) {
                    warnings.push(`Equipment item ${index} missing slot`);
                }
            });
        }
        
        // Check ability references
        if (unitType.abilities && !Array.isArray(unitType.abilities)) {
            errors.push('Abilities must be an array');
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    
    /**
     * Clean up resources and cache
     */
    dispose() {
        this.componentCache.clear();
        this.resetStats();
    }
};

// manager: SquadManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SquadManager'] = class SquadManager {
    constructor(app) {
        this.game = app;
        this.game.squadManager = this;
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };
        
        this.DEFAULT_SQUAD_CONFIG = {
            squadWidth: 1,
            squadHeight: 1,
            placementGridWidth: 1,
            placementGridHeight: 1
        };
    }
    
    /**
     * Extract squad configuration from unit type definition
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad configuration with dimensions
     */
    getSquadData(unitType) {
        return {
            squadWidth: unitType.squadWidth || this.DEFAULT_SQUAD_CONFIG.squadWidth,
            squadHeight: unitType.squadHeight || this.DEFAULT_SQUAD_CONFIG.squadHeight,
            placementGridWidth: unitType.placementGridWidth || this.DEFAULT_SQUAD_CONFIG.placementGridWidth,
            placementGridHeight: unitType.placementGridHeight || this.DEFAULT_SQUAD_CONFIG.placementGridHeight
        };
    }
    
    /**
     * Calculate which grid cells a squad would occupy
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @returns {Array} Array of cell positions {x, z}
     */
    getSquadCells(gridPos, squadData) {
        const cells = [];
        const { placementGridWidth, placementGridHeight } = squadData;
        
        if(squadData.collection == "buildings"){
            return this.calculateFootprintCells(gridPos, squadData);
        }
        // Calculate starting position to center the formation
        const startX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);
        
        for (let x = 0; x < placementGridWidth; x++) {
            for (let z = 0; z < placementGridHeight; z++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }
        
        return cells;
    }
      
    calculateFootprintCells(gridPos, building) {
        const cells = [];
        // Footprint is in terrain grid units - use directly for preview
        const footprintWidth = building.footprintWidth || building.placementGridWidth || 1;
        const footprintHeight = building.footprintHeight || building.placementGridHeight || 1;

        const startX = gridPos.x - Math.floor(footprintWidth * 2 / 2);
        const startZ = gridPos.z - Math.floor(footprintHeight * 2 / 2);

        // Calculate center position for each footprint cell in placement grid coordinates
        for (let z = 0; z < footprintHeight; z++) {
            for (let x = 0; x < footprintWidth; x++) {
                // Each footprint cell is centered in its 2x2 placement grid area
                cells.push({
                    x: startX + x * 2 + 1,  // Center of 2-cell width
                    z: startZ + z * 2 + 1   // Center of 2-cell height
                });
            }
        }

        return cells;
    }  
    /**
     * Calculate world positions for individual units within a squad formation
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance for coordinate conversion
     * @returns {Array} Array of world positions {x, z}
     */
    calculateUnitPositions(gridPos, unitType) {
        const squadData = this.getSquadData(unitType);
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        const positions = [];
        const cellSize = this.game.gridSystem.dimensions.cellSize;

        // Compute the top-left (min) cell of the formation footprint
        const startCellX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startCellZ = gridPos.z - Math.floor(placementGridHeight / 2);

        // Compute the true geometric center of the whole footprint, even for even sizes
        // Example: width=2 -> center at (start + 0.5); width=3 -> center at (start + 1)
        const centerCellX = startCellX + (placementGridWidth - 1) / 2;
        const centerCellZ = startCellZ + (placementGridHeight - 1) / 2;
        const centerWorldPos = this.game.gridSystem.gridToWorld(centerCellX, centerCellZ);

        // If squad footprint matches placement footprint, snap each unit to its cell center.
        if (squadWidth === placementGridWidth && squadHeight === placementGridHeight) {
            for (let row = 0; row < squadHeight; row++) {
                for (let col = 0; col < squadWidth; col++) {
                    const cellX = startCellX + col;
                    const cellZ = startCellZ + row;
                    const wp = this.game.gridSystem.gridToWorld(cellX, cellZ);
                    positions.push({ x: wp.x, z: wp.z });
                }
            }
            return positions;
        }

        // General case: distribute units evenly across the footprint bounds
        const formationWorldWidth  = placementGridWidth  * cellSize;
        const formationWorldHeight = placementGridHeight * cellSize;

        // Single unit: drop on the geometric center of the footprint
        if (squadWidth === 1 && squadHeight === 1) {
            positions.push({ x: centerWorldPos.x, z: centerWorldPos.z });
            return positions;
        }

        // Start from the top-left point of the unit grid *inside* the formation bounds
        const stepX = formationWorldWidth  / Math.max(1, squadWidth);
        const stepZ = formationWorldHeight / Math.max(1, squadHeight);

        const startX = centerWorldPos.x - (formationWorldWidth / 2) + (stepX / 2);
        const startZ = centerWorldPos.z - (formationWorldHeight / 2) + (stepZ / 2);

        console.log(stepX, formationWorldWidth, squadWidth, centerWorldPos, formationWorldWidth, stepX);

        for (let row = 0; row < squadHeight; row++) {
            for (let col = 0; col < squadWidth; col++) {
                const x = startX + col * stepX;
                const z = startZ + row * stepZ;
                positions.push({ x, z });
            }
        }

        return positions;
    }

    /**
     * Check if a squad can fit within given zone bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries {minX, maxX, minZ, maxZ}
     * @returns {boolean} True if squad can fit
     */
    canFitInZone(squadData, bounds) {
        const zoneWidth = bounds.maxX - bounds.minX + 1;
        const zoneHeight = bounds.maxZ - bounds.minZ + 1;
        
        return squadData.placementGridWidth <= zoneWidth && 
               squadData.placementGridHeight <= zoneHeight;
    }
    
    /**
     * Calculate the total number of units in a squad
     * @param {Object} squadData - Squad configuration
     * @returns {number} Total unit count
     */
    getSquadSize(squadData) {
        return squadData.squadWidth * squadData.squadHeight;
    }
    
    /**
     * Get formation type based on squad dimensions
     * @param {Object} squadData - Squad configuration
     * @returns {string} Formation type description
     */
    getFormationType(squadData) {
        const { squadWidth, squadHeight } = squadData;
        
        if (squadWidth === 1 && squadHeight === 1) {
            return 'single';
        } else if (squadWidth === 1) {
            return 'column';
        } else if (squadHeight === 1) {
            return 'line';
        } else if (squadWidth === squadHeight) {
            return 'square';
        } else {
            return 'rectangle';
        }
    }
    
    /**
     * Calculate formation density (units per grid cell)
     * @param {Object} squadData - Squad configuration
     * @returns {number} Units per grid cell ratio
     */
    getFormationDensity(squadData) {
        const totalUnits = this.getSquadSize(squadData);
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        return totalUnits / gridCells;
    }
    
    /**
     * Get optimal spacing between units in world coordinates
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance
     * @returns {Object} Spacing values {x, z}
     */
    getUnitSpacing(squadData, gridSystem) {
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        
        const formationWorldWidth = placementGridWidth * gridSystem.dimensions.cellSize;
        const formationWorldHeight = placementGridHeight * gridSystem.dimensions.cellSize;
        
        return {
            x: squadWidth > 1 ? formationWorldWidth / squadWidth : 0,
            z: squadHeight > 1 ? formationWorldHeight / squadHeight : 0
        };
    }
    
    /**
     * Validate squad configuration
     * @param {Object} squadData - Squad configuration to validate
     * @returns {Object} Validation result {valid, errors}
     */
    validateSquadConfig(squadData) {
        const errors = [];
        
        if (!squadData) {
            errors.push('Squad data is required');
            return { valid: false, errors };
        }
        
        const requiredFields = ['squadWidth', 'squadHeight', 'placementGridWidth', 'placementGridHeight'];
        for (const field of requiredFields) {
            if (typeof squadData[field] !== 'number' || squadData[field] < 1) {
                errors.push(`${field} must be a positive number`);
            }
        }
        
        // Logical validations
        if (squadData.squadWidth > squadData.placementGridWidth * 10) {
            errors.push('Squad width seems unreasonably large for grid size');
        }
        
        if (squadData.squadHeight > squadData.placementGridHeight * 10) {
            errors.push('Squad height seems unreasonably large for grid size');
        }
        
        // Check if formation makes sense
        const totalUnits = squadData.squadWidth * squadData.squadHeight;
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        
        if (totalUnits > gridCells * 4) {
            errors.push('Too many units for the allocated grid space');
        }
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
    
    /**
     * Generate squad info for display purposes
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Formatted squad information
     */
    getSquadInfo(unitType) {
        const squadData = this.getSquadData(unitType);
        const validation = this.validateSquadConfig(squadData);
        
        return {
            unitName: unitType.title || unitType.id || 'Unknown Unit',
            squadSize: this.getSquadSize(squadData),
            formationType: this.getFormationType(squadData),
            density: this.getFormationDensity(squadData),
            gridFootprint: `${squadData.placementGridWidth}x${squadData.placementGridHeight}`,
            unitFormation: `${squadData.squadWidth}x${squadData.squadHeight}`,
            isValid: validation.valid,
            errors: validation.errors,
            cost: unitType.value || 0,
            totalValue: (unitType.value || 0) * this.getSquadSize(squadData)
        };
    }
    
    /**
     * Check if two squads would overlap
     * @param {Object} pos1 - First squad position
     * @param {Object} squad1 - First squad data
     * @param {Object} pos2 - Second squad position  
     * @param {Object} squad2 - Second squad data
     * @returns {boolean} True if squads overlap
     */
    wouldSquadsOverlap(pos1, squad1, pos2, squad2) {
        const cells1 = this.getSquadCells(pos1, squad1);
        const cells2 = this.getSquadCells(pos2, squad2);
        
        for (const cell1 of cells1) {
            for (const cell2 of cells2) {
                if (cell1.x === cell2.x && cell1.z === cell2.z) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Find all valid positions for a squad within bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries
     * @param {Set} occupiedCells - Set of occupied cell keys "x,z"
     * @returns {Array} Array of valid grid positions
     */
    findValidPositions(squadData, bounds, occupiedCells = new Set()) {
        const validPositions = [];
        
        // Check each possible center position
        for (let x = bounds.minX; x <= bounds.maxX; x++) {
            for (let z = bounds.minZ; z <= bounds.maxZ; z++) {
                const gridPos = { x, z };
                const cells = this.getSquadCells(gridPos, squadData);
                
                // Check if all cells are within bounds and unoccupied
                const isValid = cells.every(cell => {
                    if (cell.x < bounds.minX || cell.x > bounds.maxX ||
                        cell.z < bounds.minZ || cell.z > bounds.maxZ) {
                        return false;
                    }
                    
                    const key = `${cell.x},${cell.z}`;
                    return !occupiedCells.has(key);
                });
                
                if (isValid) {
                    validPositions.push(gridPos);
                }
            }
        }
        
        return validPositions;
    }
};

// manager: MultiplayerNetworkManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MultiplayerNetworkManager'] = class MultiplayerNetworkManager {
    constructor(game) {
        this.game = game;
        this.game.networkManager = this;
        
        // State tracking
        this.roomId = null;
        this.isHost = false;
        this.gameState = null;
        // Store unsubscribe functions
        this.networkUnsubscribers = [];
    }

    // GUTS Manager Interface
    init(params) {
        this.params = params || {};
        this.connectToServer();        
        this.setupNetworkListeners();
    }

    async connectToServer() {
        try {
            await this.game.clientNetworkManager.connect();
            
            // Call server to get player ID
            this.game.clientNetworkManager.call(
                'CONNECT',
                null,
                'CONNECTED',
                (data, error) => {
                    if (error) {
                        console.error('Failed to get player ID:', error);
                        this.game.uiSystem.showNotification('Failed to get player ID from server', 'error');
                    } else if (data && data.playerId) {
                        this.game.clientNetworkManager.playerId = data.playerId;
                        this.game.state.playerId = data.playerId;
                    } else {
                        console.error('Server response missing player ID:', data);
                        this.game.uiSystem.showNotification('Server did not provide player ID', 'error');
                    }
                }
            );
            
        } catch (error) {
            console.error('Failed to connect to server:', error);
            this.game.uiSystem.showNotification('Failed to connect to server', 'error');
        }
    }

    setupNetworkListeners() {
        const nm = this.game.clientNetworkManager;
        if (!nm) {
            console.error('ClientNetworkManager not available');
            return;
        }

        // Listen to events that update the UI
        this.networkUnsubscribers.push(
            nm.listen('PLAYER_JOINED', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerJoined(data);
            }),

            nm.listen('PLAYER_LEFT', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerLeft(data);
            }),

            nm.listen('PLAYER_READY_UPDATE', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerReadyUpdate(data);
            }),

            nm.listen('GAME_STARTED', (data) => {
                this.syncWithServerState(data);   
                this.handleGameStarted(data);
            }),
            nm.listen('OPPONENT_SQUAD_TARGET_SET', (data) => {
                this.syncWithServerState(data);   
                this.handleOpponentSquadTarget(data);
            }),
            nm.listen('OPPONENT_SQUAD_TARGETS_SET', (data) => {
                this.syncWithServerState(data);   
                this.handleOpponentSquadTargets(data);
            }),
            nm.listen('READY_FOR_BATTLE_UPDATE', (data) => {
                this.syncWithServerState(data);   
                this.handleReadyForBattleUpdate(data);
            }),

            nm.listen('BATTLE_END', (data) => {
                this.syncWithServerState(data);   
                this.handleBattleEnd(data);
            }),

            nm.listen('GAME_END', (data) => {
                this.syncWithServerState(data);        
                this.handleGameEnd(data);
            })
        );
    }

    createRoom(playerName, maxPlayers = 2) {
        this.game.uiSystem.showNotification('Creating room...', 'info');
        
        this.game.clientNetworkManager.call(
            'CREATE_ROOM',
            { playerName, maxPlayers },
            'ROOM_CREATED',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Failed to create room: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Room created! Code: ${this.roomId}`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    joinRoom(roomId, playerName) {
        this.game.uiSystem.showNotification('Joining room...', 'info');
        
        this.game.clientNetworkManager.call(
            'JOIN_ROOM',
            { roomId, playerName },
            'ROOM_JOINED',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Failed to join room: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Joined room ${this.roomId}`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    startQuickMatch(playerName) {
        this.game.uiSystem.showNotification('Finding opponent...', 'info');
        
        this.game.clientNetworkManager.call(
            'QUICK_MATCH',
            { playerName },
            'QUICK_MATCH_FOUND',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Quick match failed: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Match found! Entering room...`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    getStartingState(callback){
        this.game.clientNetworkManager.call(
            'GET_STARTING_STATE',
            {},
            'GOT_STARTING_STATE',
            (data, error) => {           
                if (data.error) {
                    console.log('getStartingState error:', data.error);
                    callback(false, error);
                } else {
                    console.log('getStartingState response:', data);
                    callback(true, data);
                }
            }
        );
    }

    submitPlacement(placement, callback){
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SUBMIT_PLACEMENT',
            { placement },
            'SUBMITTED_PLACEMENT',
            (data, error) => {           
                if (data.error) {
                    console.log('Placement error:', data.error);
                    callback(false, error);
                } else {
                    console.log('Placement response:', data);
                    callback(true, data);
                }
            }
        );
    }

    purchaseUpgrade(data, callback){
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'PURCHASE_UPGRADE',
            { data },
            'PURCHASED_UPGRADE',
            (data, error) => {           
                if (data.error) {
                    console.log('Purchase error:', data.error);
                    callback(false, error);
                } else {
                    console.log('Purchase response:', data);
                    callback(true, data);
                }
            }
        );
    }

    setSquadTarget(data, callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SET_SQUAD_TARGET',
            data,
            'SQUAD_TARGET_SET',
            (data, error) => {
                if (error || data.error) {
                    console.log('Set target error:', error || data.error);
                    callback(false, error || data.error);
                } else {
                    console.log('Set target response:', data);
                    callback(true, data);
                }
            }
        );
    }

    setSquadTargets(data, callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SET_SQUAD_TARGETS',
            data,
            'SQUAD_TARGETS_SET',
            (data, error) => {
                if (error || data.error) {
                    console.log('Set target error:', error || data.error);
                    callback(false, error || data.error);
                } else {
                    console.log('Set target response:', data);
                    callback(true, data);
                }
            }
        );
    }

    toggleReadyForBattle(callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'READY_FOR_BATTLE',
            {},
            'READY_FOR_BATTLE_RESPONSE',
            (data, error) => {                                
                if (data.error) {
                    console.log('Battle ready state error:', data.error);
                    callback(false, data.error);
                } else {
                    console.log('Battle ready state updated:', data);
                    callback(true, data);
                }
            }
        );
    }

    toggleReady() {
        this.game.clientNetworkManager.call('TOGGLE_READY');
    }

    startGame() {
        if (!this.isHost) return;
        this.game.clientNetworkManager.call('START_GAME');
    }

    leaveRoom() {
        this.game.clientNetworkManager.call('LEAVE_ROOM');
    }

    handlePlayerJoined(data){

        this.game.uiSystem.showNotification(`${data.playerName} joined the room`, 'info');
        this.game.uiSystem.updateLobby(data.gameState);
    }

    handlePlayerLeft(data){

        this.game.uiSystem.showNotification('Player left the room', 'warning');
        this.game.uiSystem.updateLobby(data.gameState);
    }

    handlePlayerReadyUpdate(data){

        this.game.uiSystem.updateLobby(data.gameState);
        console.log('handlePlayerReadyUpdate', data);
        // Show notification for ready state changes
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.playerId === myPlayerId) {
            if(!data.ready){
                console.log("not ready", data);
            }
            this.game.uiSystem.showNotification(
                data.ready ? 'You are ready!' : 'Ready status removed',
                data.ready ? 'success' : 'info'
            );
        }
        
        if (data.allReady) {
            this.game.uiSystem.showNotification('All players ready! Game starting...', 'success');
        }
    }

    handleGameStarted(data){
        this.game.gameManager.initializeGame(data);
    }

    handleReadyForBattleUpdate(data) {
        this.game.placementSystem.handleReadyForBattleUpdate(data);
    }

    handleBattleEnd(data) {
        
        if (data.entitySync) {
            this.resyncEntities(data.entitySync);
        }
        this.game.triggerEvent('onBattleEnd');        
        console.log('battle result', data);
        this.game.desyncDebugger.displaySync(true); 
        this.game.desyncDebugger.enabled = false;
        const myPlayerId = this.game.clientNetworkManager.playerId;
        data.gameState?.players?.forEach((player) => {
            if(player.id == myPlayerId) {
                this.game.state.playerGold = player.stats.gold;
            }
        })
        this.game.state.round += 1;
        // Transition back to placement phase
        this.game.state.phase = 'placement';
        this.game.triggerEvent('onPlacementPhaseStart');   
    }

    resyncEntities(entitySync) {

        for (const [entityId, components] of Object.entries(entitySync)) {
        
            
            for (const [componentType, componentData] of Object.entries(components)) {
                if (this.game.hasComponent(entityId, componentType)) {
                    const existing = this.game.getComponent(entityId, componentType);
                    Object.assign(existing, componentData);
                } 
            }
        }
        
    }

    handleGameEnd(data) {
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.result.winner === myPlayerId) {
            this.game.uiSystem.showNotification('GAME WON! Congratulations!', 'success');
        } else {
            this.game.uiSystem.showNotification('Game lost. Better luck next time!', 'warning');
        }
    }
 
    handleRoundResult(roundResult) {
        const state = this.game.state;
        state.phase = 'ended';      
    }

    handleOpponentSquadTarget(data) {
        const { placementId, targetPosition, meta } = data;
        this.game.unitOrderSystem.applySquadTargetPosition(placementId, targetPosition, meta);        
    }

    handleOpponentSquadTargets(data) {
        const { placementIds, targetPositions, meta } = data;
        this.game.unitOrderSystem.applySquadsTargetPositions(placementIds, targetPositions, meta);        
    }

    syncWithServerState(data) {
        if(!data.gameState) return;
        const gameState = data.gameState;
        if (!gameState.players) return;
        console.log('sync with server', gameState);
        const myPlayerId = this.game.clientNetworkManager.playerId;
        const myPlayer = gameState.players.find(p => p.id === myPlayerId);
        
        if (myPlayer) {
            // Sync squad count and side
            if (this.game.state) {
                this.game.state.mySide = myPlayer.stats.side;
                this.game.state.playerGold = myPlayer.stats.gold;
                this.game.state.playerHealth = myPlayer.stats.health;
                this.game.state.round = gameState.round;
                this.game.state.serverGameState = gameState;
            }
            
            // Set team sides in grid system
            const opponent = gameState.players.find(p => p.id !== myPlayerId);
            if (opponent && this.game.gridSystem) {
                this.game.gridSystem.setTeamSides({
                    player: myPlayer.stats.side,
                    enemy: opponent.stats.side
                });
            }
            
            // Also set sides in placement system
            if (this.game.placementSystem ) {
                if(this.game.placementSystem.setTeamSides) {
                
                    this.game.placementSystem.setTeamSides({
                        player: myPlayer.stats.side,
                        enemy: opponent.stats.side
                    });
                }

                this.game.placementSystem.setPlacementExperience(myPlayer.placements);
            }

                
            // Update UI to reflect synced experience data
            if (this.game.shopSystem && this.game.shopSystem.updateGoldDisplay) {
                this.game.shopSystem.updateGoldDisplay();
            }
            
        }
    }
 
    dispose() {
        this.networkUnsubscribers.forEach(unsubscribe => {
            if (typeof unsubscribe === 'function') {
                unsubscribe();
            }
        });
        this.networkUnsubscribers = [];
        
    }

         
};

// manager: InputManager
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['InputManager'] = class InputManager {
    constructor(app) {
        this.game = app;
        this.game.inputManager = this;
        this.keyStates = {};
        this.mouseState = { x: 0, y: 0, pressed: false };
        this.shortcuts = new Map();
        
    }
    
    init() {
        this.setupCanvasEvents();
        this.setupButtonEvents();
        this.setupKeyboardEvents();
        this.setupMouseTracking();
        this.setupDefaultShortcuts();
    }
        
    setupCanvasEvents() {
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) return;
        
        canvas.addEventListener('click', (event) => {
            this.game.placementSystem.handleCanvasClick(event);
        });
        
        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            this.handleRightClick(event);
        });
    }
    
    setupButtonEvents() {        
        const mainMenuPlayGameBtn = document.getElementById('mainMenu_PlayGameBtn');
        const mainMenuTutorialBtn = document.getElementById('mainMenu_TutorialBtn');
        const mainMenuSettingsBtn = document.getElementById('mainMenu_SettingsBtn');
        const mainMenuCreditsBtn = document.getElementById('mainMenu_CreditsBtn');

        const gameModeBackBtn = document.getElementById('gameMode_BackBtn');

        const gamePauseBtn = document.getElementById('game_PauseBtn');
        const gameExitBtn = document.getElementById('game_ExitBtn');
        
        
        const victoryNextRoundBtn = document.getElementById('victory_NextRoundBtn');
        const victoryRestartBtn = document.getElementById('victory_RestartBtn');
        const victoryMainMenuBtn = document.getElementById('victory_MainMenuBtn');

        
        const defeatRetryBtn = document.getElementById('defeat_RetryBtn');
        const defeatChangeModeBtn = document.getElementById('defeat_ChangeModeBtn');
        const defeatMainMenuBtn = document.getElementById('defeat_MainMenuBtn');

        
        const pausedResumeBtn = document.getElementById('paused_ResumeBtn');
        const pausedRestartBtn = document.getElementById('paused_RestartBtn');
        const pausedMainMenuBtn = document.getElementById('paused_MainMenuBtn');

        mainMenuPlayGameBtn?.addEventListener('click', () => {
            this.game.screenManager.showGameModeSelect();
        });
        mainMenuTutorialBtn?.addEventListener('click', () => {
            alert('Tutorial coming soon! Check the battle log for basic instructions when you start playing.');
        });
        mainMenuSettingsBtn?.addEventListener('click', () => {
            this.showSettingsModal();
        });
        mainMenuCreditsBtn?.addEventListener('click', () => {
            alert('Auto Battle Arena\nDeveloped with Claude AI\n\nA tactical auto-battler game featuring strategic unit placement and AI opponents.');
        });

        gameModeBackBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        gamePauseBtn?.addEventListener('click', () => {
            this.game.gameManager.pauseGame();
        });
        gameExitBtn?.addEventListener('click', () => {
            this.game.gameManager.exitToMenu();
        });

        victoryNextRoundBtn?.addEventListener('click', () => {
            this.game.gameManager.continueGame();
        });
        victoryRestartBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        victoryMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        defeatRetryBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        defeatChangeModeBtn?.addEventListener('click', () => {
            this.game.screenManager.showGameModeSelect();
        });
        defeatMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        pausedResumeBtn?.addEventListener('click', () => {
            this.game.gameManager.resumeGame();
        });
        pausedRestartBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        pausedMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });



    }
    
    setupKeyboardEvents() {
        document.addEventListener('keydown', (event) => {
            this.keyStates[event.code] = true;
            this.handleKeyDown(event);
        });
        
        document.addEventListener('keyup', (event) => {
            this.keyStates[event.code] = false;
            this.handleKeyUp(event);
        });
        
        // Prevent default browser shortcuts that might interfere
        document.addEventListener('keydown', (event) => {
            if (this.shouldPreventDefault(event)) {
                event.preventDefault();
            }
        });
    }
        
    setupMouseTracking() {
        document.addEventListener('mousedown', (event) => {
            this.mouseState.pressed = true;
        });
        
        document.addEventListener('mouseup', (event) => {
            this.mouseState.pressed = false;
        });
        
        document.addEventListener('mousemove', (event) => {
            this.mouseState.x = event.clientX;
            this.mouseState.y = event.clientY;
        });
    }
    
    setupDefaultShortcuts() {
        // Define keyboard shortcuts
        this.shortcuts.set('Escape', () => this.handleEscapeKey());
        this.shortcuts.set('KeyH', () => this.showHelpModal());
        this.shortcuts.set('KeyP', () => this.game.phaseSystem.pauseGame());
        this.shortcuts.set('Space', () => this.handleSpaceKey());
        this.shortcuts.set('F1', () => this.showHelpModal());
    }
    
    handleKeyDown(event) {
        const shortcutKey = this.getShortcutKey(event);
        const shortcutHandler = this.shortcuts.get(shortcutKey);
        
        if (shortcutHandler) {
            event.preventDefault();
            shortcutHandler();
        }
        
        // Handle continuous key press actions
        this.handleContinuousKeys(event);
    }
    
    handleKeyUp(event) {
        // Handle key release actions if needed
        this.handleKeyRelease(event);
    }
    
    getShortcutKey(event) {
        let key = event.code;
        if (event.ctrlKey) key += '+Control';
        if (event.shiftKey) key += '+Shift';
        if (event.altKey) key += '+Alt';
        return key;
    }
    
    handleEscapeKey() {
        const pauseMenu = document.getElementById('pauseMenu');
        
        if (this.game.state.currentScreen === 'gameScreen') {
            this.game.phaseSystem.pauseGame();
        } else if (pauseMenu && pauseMenu.style.display === 'flex') {
            this.game.phaseSystem.resumeGame();
        }
        this.cancelSelectedUnit();
    }
    
    handleSpaceKey() {
        const state = this.game.state;
        if (state.phase === 'placement') {
            this.game.phaseSystem.toggleReady();
        }
    }
    
    handleSaveGame() {
        // Trigger save game functionality
        GUTS.NotificationSystem.show('Game saved!', 'success', 2000);
    }
    
    selectUnitShortcut(index) {
        const unitCards = document.querySelectorAll('.unit-card');
        if (unitCards[index] && !unitCards[index].classList.contains('disabled')) {
            unitCards[index].click();
        }
    }
    
    handleContinuousKeys(event) {
        // Handle keys that should trigger repeatedly while held
        if (this.keyStates['ArrowUp']) {
            this.scrollBattleLog(-1);
        }
        if (this.keyStates['ArrowDown']) {
            this.scrollBattleLog(1);
        }
    }
    
    handleKeyRelease(event) {
        // Handle specific key release events
        console.log(event.code);
        switch (event.code) {
            case 'Tab':
                this.cycleThroughUnits();
                break;
        }
    }
    
    shouldPreventDefault(event) {
        // Prevent certain browser shortcuts
        if (event.ctrlKey && event.code === 'KeyS') return true;
        if (event.code === 'F1') return true;
        return false;
    }
    
    handleRightClick(event) {
        // Handle right-click on canvas (e.g., cancel selection)

    }
        
    updateMousePosition(event) {
        this.mouseState.x = event.clientX;
        this.mouseState.y = event.clientY;
    }
   
    
    cancelSelectedUnit() {
        const state = this.game.state;
        if (state.selectedUnitType) {
            document.querySelectorAll('.selected').forEach(selected => {
                selected.classList.remove('selected');
            });
            state.selectedUnitType = null;
            this.game.placementSystem.handleUnitSelectionChange(null);
        }
    }
    cycleThroughUnits() {
        const unitCards = document.querySelectorAll('.unit-card:not(.disabled)');
        const currentSelected = document.querySelector('.unit-card.selected');
        
        if (unitCards.length === 0) return;
        
        let nextIndex = 0;
        if (currentSelected) {
            const currentIndex = Array.from(unitCards).indexOf(currentSelected);
            nextIndex = (currentIndex + 1) % unitCards.length;
        }
        
        unitCards[nextIndex].click();
    }
    
    scrollBattleLog(direction) {
        const battleLog = document.getElementById('battleLog');
        if (battleLog) {
            battleLog.scrollTop += direction * 20;
        }
    }
    
    handleMainMenuAction() {
        if (confirm('Return to main menu? Current progress will be lost.')) {
            // Trigger main menu navigation
            if (window.screenManager) {
                window.screenManager.showMainMenu();
            }
        }
    }
    
    showSettingsModal() {
        const settingsContent = `
            <h3>âš™ï¸ GAME SETTINGS</h3>
            <div class="settings-section">
                <h4>Graphics</h4>
                <label><input type="checkbox" id="particles-enabled" checked> Particle Effects</label>
                <label><input type="checkbox" id="screen-shake" checked> Screen Shake</label>
                <label><input type="range" id="particle-density" min="0.5" max="2" step="0.1" value="1"> Particle Density</label>
            </div>
            <div class="settings-section">
                <h4>Audio</h4>
                <label><input type="checkbox" id="sound-effects" checked> Sound Effects</label>
                <label><input type="range" id="volume" min="0" max="1" step="0.1" value="0.7"> Volume</label>
            </div>
            <div class="settings-section">
                <h4>Controls</h4>
                <p><strong>ESC</strong> - Pause/Resume</p>
                <p><strong>H</strong> - Help</p>
                <p><strong>Space</strong> - Ready</p>
                <p><strong>1-4</strong> - Select Units</p>
                <p><strong>Ctrl+R</strong> - Restart</p>
            </div>
        `;
        
        this.showModal('Settings', settingsContent, () => {
            this.applySettings();
        });
    }
    
    applySettings() {
        // Apply settings from modal
        const particlesEnabled = document.getElementById('particles-enabled')?.checked ?? true;
        const screenShake = document.getElementById('screen-shake')?.checked ?? true;
        const particleDensity = document.getElementById('particle-density')?.value ?? 1;
        const soundEffects = document.getElementById('sound-effects')?.checked ?? true;
        const volume = document.getElementById('volume')?.value ?? 0.7;
        
        // Save to localStorage
        localStorage.setItem('gameSettings', JSON.stringify({
            particlesEnabled,
            screenShake,
            particleDensity,
            soundEffects,
            volume
        }));
        
        GUTS.NotificationSystem.show('Settings saved!', 'success');
    }
    
    showHelpModal() {
        const helpContent = `
            <h3>ðŸŽ® CONTROLS</h3>
            <div class="help-section">
                <p><strong>ESC</strong> - Pause/Resume game</p>
                <p><strong>H or F1</strong> - Show this help</p>
                <p><strong>P</strong> - Pause game</p>
                <p><strong>Space</strong> - Ready for battle</p>
                <p><strong>Ctrl+R</strong> - Restart game</p>
                <p><strong>Ctrl+S</strong> - Save game</p>
                <p><strong>1-4</strong> - Quick select units</p>
                <p><strong>Tab</strong> - Cycle through units</p>
                <p><strong>Right Click</strong> - Cancel selection</p>
            </div>
            
            <h3>ðŸ“‹ HOW TO PLAY</h3>
            <div class="help-section">
                <p>1. <strong>Select units</strong> from the shop by clicking or using number keys</p>
                <p>2. <strong>Place units</strong> on your side of the battlefield (left half)</p>
                <p>3. <strong>Ready up</strong> when your army is prepared</p>
                <p>4. <strong>Watch the battle</strong> unfold automatically</p>
                <p>5. <strong>Earn gold</strong> from victories to build stronger armies</p>
            </div>
            
            <h3>ðŸ’¡ STRATEGY TIPS</h3>
            <div class="help-section">
                <p>â€¢ Balance offense and defense in your army</p>
                <p>â€¢ Position tanks in front to absorb damage</p>
                <p>â€¢ Place ranged units behind melee fighters</p>
                <p>â€¢ Spread units to avoid area damage</p>
                <p>â€¢ Save some gold for emergency purchases</p>
                <p>â€¢ Adapt your strategy based on enemy composition</p>
            </div>
        `;
        
        this.showModal('Game Help', helpContent);
    }
    
    showModal(title, content, onClose = null) {
        const modal = document.createElement('div');
        modal.className = 'game-modal';
        modal.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button class="modal-close" type="button">&times;</button>
                </div>
                <div class="modal-body">${content}</div>
            </div>
        `;
        
        const closeBtn = modal.querySelector('.modal-close');
        const backdrop = modal.querySelector('.modal-backdrop');
        
        const closeModal = () => {
            if (document.body.contains(modal)) {
                document.body.removeChild(modal);
                if (onClose) onClose();
            }
        };
        
        closeBtn.addEventListener('click', closeModal);
        backdrop.addEventListener('click', closeModal);
        
        // Close on ESC key
        const escHandler = (event) => {
            if (event.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
        this.addModalCSS();
    }
    
    addModalCSS() {
        if (document.querySelector('#modal-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'modal-styles';
        style.textContent = `
            .game-modal {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                z-index: 2000; display: flex; justify-content: center; align-items: center;
            }
            
            .modal-backdrop {
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(3px);
            }
            
            .modal-content {
                position: relative; background: linear-gradient(145deg, #1a1a2e, #16213e);
                border: 2px solid #00ffff; border-radius: 10px; max-width: 600px;
                width: 90%; max-height: 80%; overflow-y: auto;
                animation: modalAppear 0.3s ease-out;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            }
            
            @keyframes modalAppear {
                from { transform: scale(0.9); opacity: 0; }
                to { transform: scale(1); opacity: 1; }
            }
            
            .modal-header {
                padding: 1rem; border-bottom: 1px solid #333;
                display: flex; justify-content: space-between; align-items: center;
                background: rgba(0, 255, 255, 0.1);
            }
            
            .modal-header h2 { color: #00ffff; margin: 0; }
            
            .modal-close {
                background: none; border: none; color: #ccc; font-size: 1.5rem;
                cursor: pointer; padding: 0; width: 30px; height: 30px;
                display: flex; align-items: center; justify-content: center;
                border-radius: 50%; transition: all 0.2s;
            }
            
            .modal-close:hover { 
                color: #ff4444; background: rgba(255, 68, 68, 0.1); 
            }
            .modal-body {
                padding: 1.5rem; color: #ccc; line-height: 1.6;
            }
            
            .modal-body h3 { 
                color: #00ffff; margin-top: 1.5rem; margin-bottom: 0.8rem;
                border-bottom: 1px solid #333; padding-bottom: 0.5rem;
            }
            
            .modal-body h4 {
                color: #ffff88; margin-top: 1rem; margin-bottom: 0.5rem;
            }
            
            .modal-body p { margin-bottom: 0.6rem; }
            .modal-body strong { color: #ffff00; }
            
            .help-section {
                margin-bottom: 1rem; padding-left: 1rem;
            }
            
            .settings-section {
                margin-bottom: 1.5rem; padding: 1rem;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
            }
            
            .settings-section label {
                display: block; margin-bottom: 0.8rem;
                color: #ccc; cursor: pointer;
            }
            
            .settings-section input[type="checkbox"] {
                margin-right: 0.5rem; accent-color: #00ffff;
            }
            
            .settings-section input[type="range"] {
                width: 100%; margin-top: 0.3rem;
                accent-color: #00ffff;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Utility methods
    isKeyPressed(keyCode) {
        return this.keyStates[keyCode] || false;
    }
    
    getMousePosition() {
        return { ...this.mouseState };
    }
    
    addCustomShortcut(keyCombo, handler) {
        this.shortcuts.set(keyCombo, handler);
    }
    
    removeShortcut(keyCombo) {
        this.shortcuts.delete(keyCombo);
    }
}
;

// ========== Systems ==========

// system: TerrainSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TerrainSystem'] = class TerrainSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.terrainSystem = this;
        
        this.initialized = false;
        
        // Core terrain data
        this.level = null;
        this.world = null;
        this.tileMap = null;
        this.heightMapData = null;
        
        // Settings from collections
        this.heightMapSettings = null;
        
        // Terrain dimensions
        this.terrainSize = 0;
        this.extensionSize = 0;
        this.extendedSize = 0;
        this.heightStep = 0;
        
        // Height map canvas for processing (lightweight)
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
    }

    init() {
        if (this.initialized) return;

        this.game.gameManager.register('getTerrainHeightAtPosition', this.getTerrainHeightAtPosition.bind(this));
        this.game.gameManager.register('getTerrainSize', () => this.terrainSize);
        this.game.gameManager.register('getTerrainTypeAtPosition', this.getTerrainTypeAtPosition.bind(this));
        this.game.gameManager.register('getTileMapTerrainType', this.getTileMapTerrainType.bind(this));
        this.game.gameManager.register('getTerrainTypeAtGridPosition', this.getTerrainTypeAtGridPosition.bind(this));

        // Load world data
        this.loadWorldData();

        // Initialize height map processing
        this.initializeHeightMapProcessing();

        this.initialized = true;
    }

    loadWorldData() {
        const collections = this.game.getCollections();
        if (!collections) {
            console.error('TerrainSystem: No collections found');
            return;
        }

        const currentLevel = this.game.state?.level || 'level1';
        this.level = collections.levels?.[currentLevel];
        
        if (!this.level) {
            console.error(`TerrainSystem: Level '${currentLevel}' not found`);
            return;
        }

        this.world = collections.worlds?.[this.level.world];
        if (!this.world) {
            console.error(`TerrainSystem: World '${this.level.world}' not found`);
            return;
        }

        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];
        this.heightStep = this.heightMapSettings?.heightStep || 10;
        this.tileMap = this.level.tileMap;

        // Calculate world dimensions
        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;
        this.extensionSize = this.world.extensionSize || 0;
        this.extendedSize = this.terrainSize + 2 * this.extensionSize;
    }

    initializeHeightMapProcessing() {
        if (!this.heightMapSettings?.enabled) {
            console.log('TerrainSystem: Height map disabled, using flat terrain');
            return;
        }

        // Check if we're running in a browser environment
        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
        
        if (isBrowser) {
            // Create a small canvas for height map processing
            this.heightMapCanvas = document.createElement('canvas');
            this.heightMapCanvas.width = this.terrainSize;
            this.heightMapCanvas.height = this.terrainSize;
            this.heightMapCtx = this.heightMapCanvas.getContext('2d');
            this.processHeightMapFromCanvas();
        } else {
            // For server-side, we'll work directly with the terrain data
            console.log('TerrainSystem: Running in server mode, using data-only height processing');
            this.processHeightMapFromData();
        }
    }

    processHeightMapFromData() {
        if (!this.tileMap?.terrainMap) {
            console.warn('TerrainSystem: No terrain map data available');
            return;
        }

        // Initialize height map data array
        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);

        // Check if we have a separate heightMap in the tileMap
        const hasHeightMap = this.tileMap.heightMap && this.tileMap.heightMap.length > 0;

        // Set extension area height
        let extensionHeight;
        if (hasHeightMap) {
            // Use extension height from tileMap if available
            extensionHeight = (this.tileMap.extensionHeight || 0) * this.heightStep;
        } else {
            // Fall back to old behavior: derive from terrain type
            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
            extensionHeight = extensionTerrainType * this.heightStep;
        }

        // Initialize all points with extension height
        for (let z = 0; z < this.extendedSize; z++) {
            for (let x = 0; x < this.extendedSize; x++) {
                this.heightMapData[z * this.extendedSize + x] = extensionHeight;
            }
        }

        const gridSize = this.game.getCollections().configs.game.gridSize;

        if (hasHeightMap) {
            // NEW: Use separate heightMap data from tileMap
            const heightData = this.tileMap.heightMap;

            for (let z = 0; z < heightData.length; z++) {
                for (let x = 0; x < heightData[z].length; x++) {
                    const heightLevel = heightData[z][x];
                    const height = heightLevel * this.heightStep;

                    // Map terrain coordinates to extended coordinates
                    const extX = x * gridSize + this.extensionSize;
                    const extZ = z * gridSize + this.extensionSize;

                    // Apply height to a region around this tile
                    const halfGrid = Math.floor(gridSize / 2);
                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {
                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {
                            const finalX = extX + dx;
                            const finalZ = extZ + dz;

                            if (finalX >= 0 && finalX < this.extendedSize &&
                                finalZ >= 0 && finalZ < this.extendedSize) {

                                const heightIndex = finalZ * this.extendedSize + finalX;
                                this.heightMapData[heightIndex] = height;
                            }
                        }
                    }
                }
            }

            console.log(`TerrainSystem: Processed height map from separate heightMap data - ${this.extendedSize}x${this.extendedSize}`);
        } else {
            // OLD: Derive heights from terrain types (backwards compatibility)
            const terrainMap = this.tileMap.terrainMap;

            for (let z = 0; z < terrainMap.length; z++) {
                for (let x = 0; x < terrainMap[z].length; x++) {
                    const terrainType = terrainMap[z][x];
                    const height = terrainType * this.heightStep;

                    // Map terrain coordinates to extended coordinates
                    const extX = x * gridSize + this.extensionSize;
                    const extZ = z * gridSize + this.extensionSize;

                    // Apply height to a region around this tile
                    const halfGrid = Math.floor(gridSize / 2);
                    for (let dz = -halfGrid; dz <= halfGrid; dz++) {
                        for (let dx = -halfGrid; dx <= halfGrid; dx++) {
                            const finalX = extX + dx;
                            const finalZ = extZ + dz;

                            if (finalX >= 0 && finalX < this.extendedSize &&
                                finalZ >= 0 && finalZ < this.extendedSize) {

                                const heightIndex = finalZ * this.extendedSize + finalX;
                                this.heightMapData[heightIndex] = height;
                            }
                        }
                    }
                }
            }

            console.log(`TerrainSystem: Processed height map from terrain type data (legacy) - ${this.extendedSize}x${this.extendedSize}`);
        }
    }

    processHeightMapFromCanvas() {
        // This method would be used if running client-side with canvas support
        // For now, fall back to data processing
        this.processHeightMapFromData();
    }

    getTileMapTerrainType(terrainTypeId){
        if(this.tileMap.terrainTypes.length > terrainTypeId && terrainTypeId >= 0){
            return this.tileMap.terrainTypes[terrainTypeId];
        }
        return null;
    }
    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeightAtPosition(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates
        // The ground is centered at origin, so we need to offset by half the extended size
        const heightMapX = Math.floor(worldX + this.extendedSize / 2);
        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);
        
        // Ensure coordinates are within bounds
        if (heightMapX < 0 || heightMapX >= this.extendedSize || 
            heightMapZ < 0 || heightMapZ >= this.extendedSize) {
            // Outside terrain bounds, use extension terrain height
            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
            return extensionTerrainType * this.heightStep;
        }
        
        // Get height from height map
        const heightIndex = heightMapZ * this.extendedSize + heightMapX;
        return this.heightMapData[heightIndex] || 0;
    }

    /**
     * Get terrain height with bilinear interpolation for smoother transitions
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Smoothly interpolated terrain height
     */
    getTerrainHeightAtPositionSmooth(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates (with decimal precision)
        const heightMapX = worldX + this.extendedSize / 2;
        const heightMapZ = worldZ + this.extendedSize / 2;
        
        // Get the four surrounding grid points
        const x0 = Math.floor(heightMapX);
        const x1 = x0 + 1;
        const z0 = Math.floor(heightMapZ);
        const z1 = z0 + 1;
        
        // Get fractional parts for interpolation
        const fx = heightMapX - x0;
        const fz = heightMapZ - z0;
        
        // Helper function to get height at specific grid point
        const getHeightAt = (x, z) => {
            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {
                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
                return extensionTerrainType * this.heightStep;
            }
            const heightIndex = z * this.extendedSize + x;
            return this.heightMapData[heightIndex] || 0;
        };
        
        // Get heights at the four corners
        const h00 = getHeightAt(x0, z0);
        const h10 = getHeightAt(x1, z0);
        const h01 = getHeightAt(x0, z1);
        const h11 = getHeightAt(x1, z1);
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }

    /**
     * Get terrain type at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate  
     * @returns {number|null} Terrain type index, or null if outside bounds
     */
    getTerrainTypeAtPosition(worldX, worldZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const gridSize = this.game.getCollections().configs.game.gridSize;
        const terrainMap = this.tileMap.terrainMap;
        
        // Convert world coordinates to terrain grid coordinates
        const terrainX = Math.floor((worldX + this.terrainSize / 2) / gridSize);
        const terrainZ = Math.floor((worldZ + this.terrainSize / 2) / gridSize);
        
        // Check bounds
        if (terrainX < 0 || terrainX >= terrainMap[0]?.length || 
            terrainZ < 0 || terrainZ >= terrainMap.length) {
            // Outside terrain bounds, return extension terrain type
            return this.tileMap.extensionTerrainType || 0;
        }
        
        return terrainMap[terrainZ][terrainX];
    }

    getTerrainTypeAtGridPosition(gridX, gridZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const terrainMap = this.tileMap.terrainMap;

        if(terrainMap.length <= gridZ || gridZ < 0) {
            return null;
        }
        if(terrainMap[gridZ].length <= gridX || gridX < 0) {
            return null;
        }

        return terrainMap[gridZ][gridX];
    }

    /**
     * Get height level at grid position (not the actual height, but the level index)
     * @param {number} gridX - Grid X coordinate
     * @param {number} gridZ - Grid Z coordinate
     * @returns {number|null} Height level (0, 1, 2, etc.), or null if outside bounds
     */
    getHeightLevelAtGridPosition(gridX, gridZ) {
        // If we have a separate heightMap in tileMap, use it
        if (this.tileMap?.heightMap && this.tileMap.heightMap.length > 0) {
            const heightData = this.tileMap.heightMap;

            if (heightData.length <= gridZ || gridZ < 0) {
                return this.tileMap.extensionHeight || 0;
            }
            if (heightData[gridZ].length <= gridX || gridX < 0) {
                return this.tileMap.extensionHeight || 0;
            }

            return heightData[gridZ][gridX];
        }

        // Fall back to old behavior: derive from terrain type
        const terrainType = this.getTerrainTypeAtGridPosition(gridX, gridZ);
        return terrainType !== null ? terrainType : 0;
    }

    /**
     * Check if a position is within terrain bounds
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within terrain bounds
     */
    isWithinTerrainBounds(worldX, worldZ) {
        const halfTerrain = this.terrainSize / 2;
        return worldX >= -halfTerrain && worldX <= halfTerrain &&
               worldZ >= -halfTerrain && worldZ <= halfTerrain;
    }

    /**
     * Check if a position is within extended terrain bounds (including extension)
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within extended terrain bounds
     */
    isWithinExtendedBounds(worldX, worldZ) {
        const halfExtended = this.extendedSize / 2;
        return worldX >= -halfExtended && worldX <= halfExtended &&
               worldZ >= -halfExtended && worldZ <= halfExtended;
    }

    /**
     * Get terrain information at position including height, type, and bounds checking
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {Object} Terrain info object
     */
    getTerrainInfoAtPosition(worldX, worldZ) {
        return {
            height: this.getTerrainHeightAtPosition(worldX, worldZ),
            heightSmooth: this.getTerrainHeightAtPositionSmooth(worldX, worldZ),
            terrainType: this.getTerrainTypeAtPosition(worldX, worldZ),
            withinBounds: this.isWithinTerrainBounds(worldX, worldZ),
            withinExtendedBounds: this.isWithinExtendedBounds(worldX, worldZ)
        };
    }

    /**
     * Enforce terrain boundaries for movement
     * @param {Object} pos - Position object with x, z properties
     * @param {number} unitRadius - Unit radius for boundary checking
     */
    enforceBoundaries(pos, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }

    /**
     * Get safe spawn position within terrain bounds
     * @param {number} preferredX - Preferred X coordinate
     * @param {number} preferredZ - Preferred Z coordinate
     * @param {number} unitRadius - Unit radius for boundary checking
     * @returns {Object} Safe position with x, y, z coordinates
     */
    getSafeSpawnPosition(preferredX, preferredZ, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        // Clamp to safe bounds
        const safeX = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredX));
        const safeZ = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredZ));
        
        // Get terrain height at safe position
        const height = this.getTerrainHeightAtPosition(safeX, safeZ);
        
        return {
            x: safeX,
            y: height,
            z: safeZ
        };
    }

    update() {
        // TerrainSystem is mostly static, minimal update needed
        if (!this.initialized) {
            this.init();
        }
    }

    destroy() {
        // Clean up resources
        this.heightMapData = null;
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
        
        this.initialized = false;
    }
};

// system: WorldSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['WorldSystem'] = class WorldSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.worldSystem = this;
        
        this.initialized = false;
        
        // Core Three.js components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null;
        
        // Terrain and world objects
        this.ground = null;
        this.groundTexture = null;
        this.groundCanvas = null;
        this.groundCtx = null;
        this.grass = null;
        this.liquidMeshes = [];
        
        // Extension planes
        this.extensionPlanes = [];
        
        // Terrain canvas for tile mapping
        this.terrainCanvas = null;
        this.terrainCtx = null;
        
        // Lighting
        this.ambientLight = null;
        this.directionalLight = null;
        this.hemisphereLight = null;
        
        // Uniforms for shaders
        this.uniforms = {};
        
        // World data
        this.level = null;
        this.world = null;
        this.tileMap = null;
        this.heightMapData = null;
        // Settings from collections
        this.lightingSettings = null;
        this.shadowSettings = null;
        this.fogSettings = null;
        this.heightMapSettings = null;
        this.cameraSettings = null;
        
        this.heightStep = 0;
        // Timing
        this.clock = new THREE.Clock();
        this.timer = 0;
        this.terrainRendered = false;

        // Controls
        this.controls = null;

        // Window resize handler
        this.onWindowResizeHandler = this.onWindowResize.bind(this);
    }

    init() {
        if (this.initialized) return;

        this.game.gameManager.register('getTerrainHeightAtPosition', this.getTerrainHeightAtPosition.bind(this));
        this.game.gameManager.register('getWorldScene', this.getScene.bind(this));
        this.game.gameManager.register('getWorldExtendedSize', () => this.extendedSize);
        this.game.gameManager.register('getGroundTexture', () => this.groundTexture);
        this.game.gameManager.register('getGroundMesh', () => this.ground);
        this.game.gameManager.register('getHeightStep', () => this.heightStep);
        this.game.gameManager.register('getBaseTerrainHeight', () => this.heightStep * this.tileMap.extensionHeight);

        // Add the extension functions
        THREE.BufferGeometry.prototype.computeBoundsTree = THREE_.three_MeshBVH.computeBoundsTree;
        THREE.BufferGeometry.prototype.disposeBoundsTree = THREE_.three_MeshBVH.disposeBoundsTree;
        THREE.Mesh.prototype.raycast = THREE_.three_MeshBVH.acceleratedRaycast;

        THREE.BatchedMesh.prototype.computeBoundsTree = THREE_.three_MeshBVH.computeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.disposeBoundsTree = THREE_.three_MeshBVH.disposeBatchedBoundsTree;
        THREE.BatchedMesh.prototype.raycast = THREE_.three_MeshBVH.acceleratedRaycast;
        this.initializeThreeJS();

        this.loadWorldData();
    }

    getScene() {
        return this.scene;
    }

    initializeThreeJS() {
        const gameCanvas = document.getElementById('gameCanvas');
        if (!gameCanvas) {
            console.error('WorldRenderSystem: gameCanvas not found!');
            return;
        }

        this.scene = new THREE.Scene();
        this.uiScene = new THREE.Scene();
        const currentLevel = this.game.state?.level || 'level1';
        this.level = this.game.getCollections().levels?.[currentLevel];
        this.world = this.game.getCollections().worlds[this.level.world];
        this.cameraData = this.game.getCollections().cameras[this.world.camera]; 
        const width = window.innerWidth;
        const height = window.innerHeight; 
      // Camera setup
        if(this.cameraData.fov){
            this.camera = new THREE.PerspectiveCamera(
                this.cameraData.fov,
                width / height,
                this.cameraData.near,
                this.cameraData.far
            );
        } else if(this.cameraData.zoom){
            this.camera = new THREE.OrthographicCamera(
                width / - 2, 
                width / 2, 
                height / 2, 
                height / - 2, 
                this.cameraData.near,
                this.cameraData.far
            );
            this.camera.zoom = this.cameraData.zoom;
            this.camera.updateProjectionMatrix();
        }

        this.renderer = new THREE.WebGLRenderer({ 
            canvas: gameCanvas,
            antialias: false,
            alpha: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        window.addEventListener('resize', this.onWindowResizeHandler);
        
        this.game.camera = this.camera;
        this.game.scene = this.scene;
        this.game.uiScene = this.uiScene;
        this.game.renderer = this.renderer;
    }

    initializeTerrainCanvas() {
        this.terrainCanvas = document.createElement('canvas');
        this.terrainCanvas.width = 700;
        this.terrainCanvas.height = 500;
        this.terrainCtx = this.terrainCanvas.getContext('2d');
    }

    loadWorldData() {
        const collections = this.game.getCollections();
        if (!collections) {
            console.error('WorldRenderSystem: No collections found');
            return;
        }

        const currentLevel = this.game.state?.level || 'level1';
        this.level = collections.levels?.[currentLevel];
        
        if (!this.level) {
            console.error(`WorldRenderSystem: Level '${currentLevel}' not found`);
            return;
        }

        this.world = collections.worlds?.[this.level.world];
        if (!this.world) {
            console.error(`WorldRenderSystem: World '${this.level.world}' not found`);
            return;
        }

        this.lightingSettings = collections.lightings?.[this.world.lighting];
        this.shadowSettings = collections.shadows?.[this.world.shadow];
        this.fogSettings = collections.fogs?.[this.world.fog];
        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];
        this.cameraSettings = collections.cameras?.[this.world.camera];
        this.heightStep = this.heightMapSettings.heightStep;
        this.tileMap = this.level.tileMap;

        // Calculate world dimensions
        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;
        this.extensionSize = this.world.extensionSize || 0;
        this.extendedSize = this.terrainSize + 2 * this.extensionSize;
        this.heightMapResolution = this.extendedSize / (this.heightMapSettings?.resolutionDivisor || 1);
        
        this.renderer.shadowMap.enabled = this.shadowSettings?.enabled;
    }

    onGameStarted() {      
        this.initializeTerrainCanvas();

        if (this.world?.backgroundColor) {
            this.scene.background = new THREE.Color(this.world.backgroundColor);
        }

        this.setupFog();
        this.setupLighting();
        this.setupCamera();
        this.setupGround();
        
        this.createExtensionPlanes();
        
        if (this.tileMap?.terrainMap) {
            this.renderTerrain();
        } else {
            console.warn('WorldRenderSystem: No terrain map available during setup');
        }
        
        this.initialized = true;  
    }

    setupFog() {
        if (this.fogSettings?.enabled) {
            this.scene.fog = new THREE.FogExp2(
                this.fogSettings.color, 
                this.fogSettings.density
            );
        }
    }

    setupLighting() {
        if (!this.lightingSettings) {
            this.lightingSettings = {
                ambientColor: '#404040',
                ambientIntensity: 0.6,
                directionalColor: '#ffffff',
                directionalIntensity: 1.0,
                skyColor: '#87CEEB',
                groundColor: '#ffffff',
                hemisphereIntensity: 0.4
            };
        }

        this.ambientLight = new THREE.AmbientLight(
            this.lightingSettings.ambientColor,
            this.lightingSettings.ambientIntensity
        );
        this.scene.add(this.ambientLight);

        this.directionalLight = new THREE.DirectionalLight(
            this.lightingSettings.directionalColor,
            this.lightingSettings.directionalIntensity
        );
        if(this.lightingSettings.direction){
            this.lightingSettings.direction = JSON.parse(this.lightingSettings.direction);
            this.directionalLight.position.set(
                -this.lightingSettings.direction.x * this.extendedSize,  
                -this.lightingSettings.direction.y * this.extendedSize, 
                -this.lightingSettings.direction.z * this.extendedSize
            );
        }

        this.directionalLight.castShadow = this.shadowSettings?.enabled || false;

        if (this.shadowSettings?.enabled) {
            this.directionalLight.shadow.mapSize.width = this.shadowSettings.mapSize;
            this.directionalLight.shadow.mapSize.height = this.shadowSettings.mapSize;
            this.directionalLight.shadow.camera.near = 0.5;
            this.directionalLight.shadow.camera.far = 20000;
            this.directionalLight.shadow.bias = this.shadowSettings.bias;
            this.directionalLight.shadow.normalBias = this.shadowSettings.normalBias;
            this.directionalLight.shadow.radius = this.shadowSettings.radius;

            const d = this.extendedSize * 0.75;
            this.directionalLight.shadow.camera.left = -d;
            this.directionalLight.shadow.camera.right = d;
            this.directionalLight.shadow.camera.top = d;
            this.directionalLight.shadow.camera.bottom = -d;

            this.directionalLight.target.position.set(
                0, 
                0, 
                0
            );
            this.directionalLight.target.updateMatrixWorld();
            this.directionalLight.shadow.camera.updateProjectionMatrix();
        }

        this.scene.add(this.directionalLight);
        this.scene.add(this.directionalLight.target);

        this.hemisphereLight = new THREE.HemisphereLight(
            this.lightingSettings.skyColor,
            this.lightingSettings.groundColor,
            this.lightingSettings.hemisphereIntensity
        );
        this.scene.add(this.hemisphereLight);

    }

    postAllInit(){
        
        this.setupPostProcessing();
    }

    setupPostProcessing() {
        const gameConfig = this.game.getCollections()?.configs?.game;
        if (!gameConfig) return;

        const pixelSize = gameConfig.pixelSize || 1;
        this.game.gameManager.call('registerPostProcessingPass', 'render', {
            enabled: true,
            create: () => {
                return {
                    enabled: true,
                    needsSwap: true,
                    clear: true,
                    renderToScreen: false,
                    
                    render: (renderer, writeBuffer, readBuffer, deltaTime, maskActive) => {
                        renderer.setRenderTarget(writeBuffer);
                        renderer.clear(true, true, true); // Clear color, depth, and stencil
                        renderer.render(this.scene, this.camera);
                    },
                    
                    setSize: (width, height) => {
                        // No-op
                    }
                };
            }
        });
        // Register pixel pass
        this.game.gameManager.call('registerPostProcessingPass', 'pixel', {
            enabled: pixelSize !== 1,
            create: () => {
                const pixelPass = new THREE_.RenderPixelatedPass(pixelSize, this.scene, this.camera);
                pixelPass.enabled = pixelSize !== 1;
                pixelPass.normalEdgeStrength = 0;
                return pixelPass;
            }
        });

        // Register output pass (always last)
        this.game.gameManager.call('registerPostProcessingPass', 'output', {
            enabled: true,
            create: () => {
                return new THREE_.OutputPass();
            }
        });
        
        console.log('[WorldSystem] Registered post-processing passes');
    }

    setupCamera() {
        if (!this.cameraSettings) {
            this.cameraSettings = {
                position: '{"x":0,"y":200,"z":300}',
                lookAt: '{"x":0,"y":0,"z":0}',
                fov: 60,
                near: 1,
                far: 30000
            };
        }

        const cameraPos = JSON.parse(this.cameraSettings.position);
       // this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);

        const lookAt = JSON.parse(this.cameraSettings.lookAt);
       // this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);

        if (this.cameraSettings.fov && this.camera.isPerspectiveCamera) {
            this.camera.fov = this.cameraSettings.fov;
            this.camera.near = this.cameraSettings.near || 0.1;
            this.camera.far = this.cameraSettings.far || 30000;
            this.camera.updateProjectionMatrix();
        }

       // this.setupOrbitControls(lookAt);

     
    }

    setupOrbitControls(lookAt) {
        if (typeof THREE_.OrbitControls === 'undefined') {
            console.warn('WorldRenderSystem: THREE.OrbitControls not found.');
            return;
        }

        this.controls = new THREE_.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.mouseButtons = {
            LEFT: null,                           // Disable left click
            MIDDLE: THREE.MOUSE.ROTATE,          // Middle mouse for rotation
            RIGHT: THREE.MOUSE.PAN               // Right mouse for panning (optional)
        };
        this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);
        this.controls.maxPolarAngle = Math.PI / 2.05;
        this.controls.minPolarAngle = 0.1;
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.screenSpacePanning = false;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 1000;
        
        this.controls.update();
        
    }

    setupGround() {
        if (!this.tileMap) {
            console.warn('WorldRenderSystem: No tile map found');
            return;
        }

        this.groundCanvas = document.createElement('canvas');
        this.groundCanvas.width = this.extendedSize;
        this.groundCanvas.height = this.extendedSize;
        this.groundCtx = this.groundCanvas.getContext('2d');

        // Fill extension area with sprite texture pattern instead of solid color
        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
        const tileMapper = this.game.terrainTileMapper;

        if (tileMapper && tileMapper.layerSpriteSheets && tileMapper.layerSpriteSheets[extensionTerrainType]) {
            // Use the Full sprite (index 0) from the extension terrain type
            const fullSprite = tileMapper.layerSpriteSheets[extensionTerrainType].sprites[0];

            if (fullSprite) {
                // Tile the sprite across the entire ground canvas
                const spriteSize = fullSprite.width;
                for (let y = 0; y < this.extendedSize; y += spriteSize) {
                    for (let x = 0; x < this.extendedSize; x += spriteSize) {
                        this.groundCtx.drawImage(fullSprite, x, y);
                    }
                }
            }
        }

        this.groundTexture = new THREE.CanvasTexture(this.groundCanvas);
        this.groundTexture.wrapS = THREE.ClampToEdgeWrapping;
        this.groundTexture.wrapT = THREE.ClampToEdgeWrapping;
        this.groundTexture.minFilter = THREE.NearestFilter;
        this.groundTexture.magFilter = THREE.NearestFilter;

        const segments = this.heightMapResolution || 1;
        const groundGeometry = new THREE.PlaneGeometry(
            this.extendedSize,
            this.extendedSize,
            segments,
            segments
        );

        this.groundVertices = groundGeometry.attributes.position;
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: this.groundTexture,
            side: THREE.DoubleSide,
            metalness: 0.0,
            roughness: 1
        });

        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        this.ground.rotation.x = -Math.PI / 2;
        // Center the ground at origin instead of offset
        this.ground.position.set(0, 0, 0);
        this.ground.receiveShadow = true;
        this.ground.castShadow = true;

        this.scene.add(this.ground);

        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);
    }

    getGroundMesh() {
        return this.ground;
    }

    createExtensionPlanes() {
        if (!this.tileMap) return;

        // Get the extension terrain type
        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;

        // Extension settings
        const extensionDistance = 19000; // How far the planes extend
        const detailedGroundSize = this.extendedSize; // Size of your existing detailed ground
        const halfDetailedSize = detailedGroundSize / 2;

        // Get the sprite texture for the extension terrain type
        const tileMapper = this.game.terrainTileMapper;
        let extensionTexture;

        if (tileMapper && tileMapper.layerSpriteSheets && tileMapper.layerSpriteSheets[extensionTerrainType]) {
            // Use the Full sprite (index 0) from the extension terrain type
            const fullSprite = tileMapper.layerSpriteSheets[extensionTerrainType].sprites[0];

            if (fullSprite) {
                // Create texture from the sprite canvas
                extensionTexture = new THREE.CanvasTexture(fullSprite);
                extensionTexture.wrapS = THREE.RepeatWrapping;
                extensionTexture.wrapT = THREE.RepeatWrapping;
                extensionTexture.minFilter = THREE.NearestFilter;
                extensionTexture.magFilter = THREE.NearestFilter;
            }
        }

        // Fallback to solid color if sprite not available
        if (!extensionTexture) {
            const terrainTypes = this.tileMap.terrainTypes || [];
            let bgColor = terrainTypes[extensionTerrainType]?.color;

            if (bgColor?.paletteColor && this.game.palette) {
                bgColor = this.game.palette[bgColor.paletteColor];
            }

            const extensionColor = bgColor || '#333333';
            const extensionCanvas = document.createElement('canvas');
            extensionCanvas.width = 1;
            extensionCanvas.height = 1;
            const extensionCtx = extensionCanvas.getContext('2d');
            extensionCtx.fillStyle = extensionColor;
            extensionCtx.fillRect(0, 0, 1, 1);

            extensionTexture = new THREE.CanvasTexture(extensionCanvas);
            extensionTexture.wrapS = THREE.RepeatWrapping;
            extensionTexture.wrapT = THREE.RepeatWrapping;
            extensionTexture.minFilter = THREE.NearestFilter;
            extensionTexture.magFilter = THREE.NearestFilter;
        }

        // Create material for extension planes with repeating texture
        const extensionMaterial = new THREE.MeshStandardMaterial({
            map: extensionTexture,
            side: THREE.DoubleSide,
            metalness: 0.0,
            roughness: 0.8,
            fog: false
        });
        
        // Store extension planes for cleanup
        this.extensionPlanes = [];
    
        const extensionHeight = extensionTerrainType * this.heightStep;

        // 1. North plane (positive Z)
        const northGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);
        const northPlane = new THREE.Mesh(northGeometry, extensionMaterial.clone());
        northPlane.rotation.x = -Math.PI / 2;
        northPlane.position.set(0, extensionHeight, halfDetailedSize + extensionDistance / 2);
        northPlane.receiveShadow = true;
        this.scene.add(northPlane);
        this.extensionPlanes.push(northPlane);
        
        // 2. South plane (negative Z)
        const southGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);
        const southPlane = new THREE.Mesh(southGeometry, extensionMaterial.clone());
        southPlane.rotation.x = -Math.PI / 2;
        southPlane.position.set(0, extensionHeight, -halfDetailedSize - extensionDistance / 2);
        southPlane.receiveShadow = true;
        this.scene.add(southPlane);
        this.extensionPlanes.push(southPlane);
        
        // 3. East plane (positive X)
        const eastGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);
        const eastPlane = new THREE.Mesh(eastGeometry, extensionMaterial.clone());
        eastPlane.rotation.x = -Math.PI / 2;
        eastPlane.position.set(halfDetailedSize + extensionDistance / 2, extensionHeight, 0);
        eastPlane.receiveShadow = true;
        this.scene.add(eastPlane);
        this.extensionPlanes.push(eastPlane);
        
        // 4. West plane (negative X)  
        const westGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);
        const westPlane = new THREE.Mesh(westGeometry, extensionMaterial.clone());
        westPlane.rotation.x = -Math.PI / 2;
        westPlane.position.set(-halfDetailedSize - extensionDistance / 2, extensionHeight, 0);
        westPlane.receiveShadow = true;
        this.scene.add(westPlane);
        this.extensionPlanes.push(westPlane);
        
    }

    renderTerrain() {
        if (!this.tileMap?.terrainMap) {
            console.warn('WorldRenderSystem: No terrain map data found');
            return;
        }

        
        // Clear terrain canvas
        this.terrainCtx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);
        
        // Draw terrain tiles
        this.drawTerrainTiles(this.tileMap.terrainMap);
        
        // Update ground texture with terrain data
        this.updateGroundTexture();
        
        this.terrainRendered = true;
        
    }

    drawTerrainTiles(terrainMap) {
        // NEW: Pass heightMap if available (now in tileMap)
        const heightMap = this.tileMap?.heightMap || null;
        this.game.terrainTileMapper.draw(terrainMap, heightMap);
    }

    updateGroundTexture() {
        if (!this.terrainCanvas) {
            console.warn('WorldRenderSystem: No terrain canvas available for ground texture update');
            return;
        }

        // Draw terrain data onto ground canvas
        this.groundCtx.drawImage(
            this.game.terrainTileMapper.canvas, 
            this.extensionSize, 
            this.extensionSize
        );
        this.groundTexture.needsUpdate = true;
        
        if (this.heightMapSettings?.enabled) {
            this.updateHeightMap();
        }
        
        // Generate liquid surfaces
        if (this.tileMap?.terrainTypes) {
            this.generateLiquidSurfaceMesh(0); // Water
            this.generateLiquidSurfaceMesh(1); // Lava/other liquid
        }

        // Add grass
       // this.addGrassToTerrain();

        // Render environment objects
        this.renderEnvironmentObjects();
    }


    renderEnvironmentObjects() {
        if (!this.scene || !this.tileMap.environmentObjects || this.tileMap.environmentObjects.length === 0) {
            return;
        }

        // Create entities for each environment object
        this.tileMap.environmentObjects.forEach(obj => {
            this.createEnvironmentEntity(obj);
        });
    }

    createEnvironmentEntity(envObj) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();

        const unitType = this.game.getCollections().worldObjects[envObj.type];
        unitType.collection = "worldObjects";
        unitType.id = envObj.type;
        // Calculate world position (matching your existing offset logic)
        const worldX = (envObj.x + this.extensionSize) - this.extendedSize / 2;
        const worldZ = (envObj.y + this.extensionSize) - this.extendedSize / 2;
        
        // Get terrain height
        let height = 0;
        if (this.heightMapSettings?.enabled) {
            height = this.game.gameManager.call('getTerrainHeightAtPosition', worldX, worldZ);
        }

        // Create entity with unique ID
        const entityId = this.game.createEntity(`env_${envObj.type}_${envObj.x}_${envObj.y}`);
        
        // Add Position component
        this.game.addComponent(entityId, ComponentTypes.POSITION, 
            Components.Position(worldX, height, worldZ));
                
        // Add Renderable component
        this.game.addComponent(entityId, ComponentTypes.RENDERABLE, 
            Components.Renderable('worldObjects', envObj.type, 1024));
        
        // Add Animation component for rotation and scale
        const rotation = Math.random() * Math.PI * 2;
        const scale = (0.8 + Math.random() * 0.4) * (envObj.type === 'rock' ? 1 : 50);
        this.game.addComponent(entityId, ComponentTypes.ANIMATION, 
            Components.Animation(scale, rotation, 0));
        
        // Add Facing component for rotation
        this.game.addComponent(entityId, ComponentTypes.FACING, 
            Components.Facing(rotation));
        
         this.game.addComponent(entityId, ComponentTypes.UNIT_TYPE, 
            Components.UnitType(
                unitType
            ));
        
        // Add Team component (neutral for environment objects)
        this.game.addComponent(entityId, ComponentTypes.TEAM, 
            Components.Team('neutral'));

        console.log('created tree');
        this.game.triggerEvent('onEntityPositionUpdated', entityId);
    }

    onWindowResize() {
        if (!this.camera || !this.renderer) return;
        
        const width = window.innerWidth;
        const height = window.innerHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        
        if (this.composer) {
            this.composer.setSize(width, height);
        }
    }

    update() {
        if (!this.initialized) return;

        this.timer += this.game.state.deltaTime;

        if (this.controls) {
            this.controls.update();
        }

        for (const key in this.uniforms) {
            if (this.uniforms[key].time) {
                this.uniforms[key].time.value = this.timer;
            }
        }

        this.render();
    }

    render() {
        if (!this.scene || !this.camera || !this.renderer) {
            console.warn('WorldRenderSystem: Missing components for rendering');
            return;
        }

        const composer = this.game.gameManager.call('getPostProcessingComposer');
        if (composer) {
            this.game.gameManager.call('renderPostProcessing');
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }

    updateHeightMap() {
        if (!this.heightMapSettings.enabled || !this.game.terrainTileMapper.heightMapCanvas) {
            console.warn('Height map not available from TileMapper');
            return;
        }

        try {
            const heightMapCanvas = this.game.terrainTileMapper.heightMapCanvas;
            const heightMapCtx = heightMapCanvas.getContext('2d', { willReadFrequently: true });
            
            // Get the height map image data directly from TileMapper
            const heightMapImageData = heightMapCtx.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height);
            const heightData = heightMapImageData.data;

            this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);

            // Set extension area to extension terrain height
            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
            const extensionHeight = extensionTerrainType * this.heightStep;

            // Initialize all points with extension height
            for (let z = 0; z < this.extendedSize; z++) {
                for (let x = 0; x < this.extendedSize; x++) {
                    this.heightMapData[z * this.extendedSize + x] = extensionHeight;
                }
            }

            // Process the actual terrain area using height map data
            const scaleX = heightMapCanvas.width / this.terrainSize;
            const scaleZ = heightMapCanvas.height / this.terrainSize;

            for (let z = 0; z < this.terrainSize; z++) {
                for (let x = 0; x < this.terrainSize; x++) {
                    // Sample from height map
                    const heightMapX = Math.floor(x * scaleX);
                    const heightMapZ = Math.floor(z * scaleZ);
                    
                    const pixelIndex = (heightMapZ * heightMapCanvas.width + heightMapX) * 4;
                    const heightValue = heightData[pixelIndex]; // Red channel (grayscale)
                    
                    // Convert grayscale value back to height index
                    const heightIndex = Math.floor(heightValue / 32); // Inverse of scaling in TileMapper
                    let height = heightIndex * this.heightStep;

                    // Check neighboring pixels for cliff smoothing if needed
                    let neighborCheckDist = this.heightMapSettings.resolutionDivisor || 1;
                    const neighbors = [
                        { x: x - neighborCheckDist, z: z },   // left
                        { x: x + neighborCheckDist, z: z },   // right
                        { x: x, z: z - neighborCheckDist },   // top
                        { x: x, z: z + neighborCheckDist },   // bottom
                        { x: x - neighborCheckDist, z: z - neighborCheckDist }, // top-left
                        { x: x + neighborCheckDist, z: z - neighborCheckDist }, // top-right
                        { x: x - neighborCheckDist, z: z + neighborCheckDist }, // bottom-left
                        { x: x + neighborCheckDist, z: z + neighborCheckDist }  // bottom-right
                    ];

                    let lowestNeighborHeight = height;
                    for (const neighbor of neighbors) {
                        if (neighbor.x >= 0 && neighbor.x < this.terrainSize && 
                            neighbor.z >= 0 && neighbor.z < this.terrainSize) {
                            
                            const neighborHMapX = Math.floor(neighbor.x * scaleX);
                            const neighborHMapZ = Math.floor(neighbor.z * scaleZ);
                            const neighborIndex = (neighborHMapZ * heightMapCanvas.width + neighborHMapX) * 4;
                            const neighborHeightValue = heightData[neighborIndex];
                            const neighborHeightIndex = Math.floor(neighborHeightValue / 32);
                            const neighborHeight = neighborHeightIndex * this.heightStep;
                            
                            if (neighborHeight < lowestNeighborHeight) {
                                lowestNeighborHeight = neighborHeight;
                            }
                        }
                    }
                    
                    // Use the lowest neighbor height for cliff smoothing
                    height = lowestNeighborHeight;
                    // Set height in extended coordinate system
                    const extX = x + this.extensionSize;
                    const extZ = z + this.extensionSize;
                    this.heightMapData[extZ * this.extendedSize + extX] = height;
                }
            }

            this.applyHeightMapToGeometry();

        } catch (e) {
            console.warn('Failed to update height map from TileMapper:', e);
        }
    }
    findClosestTerrainType(r, g, b, terrainTypeColors) {
        let minDistance = Infinity;
        let bestTypeIndex = null;
        const toleranceSquared = 36;

        for (const [colorKey, typeIndex] of Object.entries(terrainTypeColors)) {
            const [cr, cg, cb] = colorKey.split(',').map(Number);
            const distance = ((r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2);
            
            if (distance < minDistance && distance < toleranceSquared) {
                minDistance = distance;
                bestTypeIndex = typeIndex;
            }
        }

        return bestTypeIndex;
    }

    createTerrainTypeColorMap() {
        const colorMap = {};
        const terrainTypes = this.tileMap.terrainTypes || [];

        for (let i = 0; i < terrainTypes.length; i++) {
            const terrainType = terrainTypes[i];
            let color = terrainType.color || {};

            if (color.paletteColor && this.game.palette) {
                const hexColor = this.game.palette[color.paletteColor];
                if (hexColor) {
                    const r = parseInt(hexColor.slice(1, 3), 16);
                    const g = parseInt(hexColor.slice(3, 5), 16);
                    const b = parseInt(hexColor.slice(5, 7), 16);
                    colorMap[`${r},${g},${b}`] = i;
                }
            } else {
                const hexColor = color;
                if (hexColor) {
                    const r = parseInt(hexColor.slice(1, 3), 16);
                    const g = parseInt(hexColor.slice(3, 5), 16);
                    const b = parseInt(hexColor.slice(5, 7), 16);
                    colorMap[`${r},${g},${b}`] = i;
                }
            }
        }

        return colorMap;
    }

    /**
     * Decimates a mesh by reducing vertex count while preserving form
     * Uses a simplified quadric error metrics approach
     * @param {THREE.BufferGeometry} geometry - The geometry to decimate
     * @param {number} targetReduction - Target reduction ratio (0.0 to 1.0), default 0.5
     */
    decimateMesh(geometry, targetReduction = 0.5) {
        if (!geometry.index) {
            console.warn('Mesh decimation requires indexed geometry');
            return;
        }

        const startTime = performance.now();
        const positions = geometry.attributes.position.array;
        const indices = geometry.index.array;
        const originalVertexCount = positions.length / 3;
        const originalTriangleCount = indices.length / 3;

        console.log(`[MeshDecimation] Starting decimation:`, {
            vertices: originalVertexCount,
            triangles: originalTriangleCount,
            targetReduction: targetReduction
        });

        // Build edge list and adjacency information
        const edges = new Map(); // key: "v1,v2" -> {v1, v2, triangles: []}
        const vertexTriangles = new Map(); // vertex -> triangle indices

        // Initialize vertex triangle lists
        for (let i = 0; i < originalVertexCount; i++) {
            vertexTriangles.set(i, []);
        }

        // Build edge and adjacency data
        for (let i = 0; i < indices.length; i += 3) {
            const v0 = indices[i];
            const v1 = indices[i + 1];
            const v2 = indices[i + 2];
            const triIndex = i / 3;

            vertexTriangles.get(v0).push(triIndex);
            vertexTriangles.get(v1).push(triIndex);
            vertexTriangles.get(v2).push(triIndex);

            // Add edges
            this._addEdge(edges, v0, v1, triIndex);
            this._addEdge(edges, v1, v2, triIndex);
            this._addEdge(edges, v2, v0, triIndex);
        }

        // Calculate quadric error matrices for each vertex
        const quadrics = new Array(originalVertexCount);
        for (let i = 0; i < originalVertexCount; i++) {
            quadrics[i] = this._calculateVertexQuadric(i, positions, indices, vertexTriangles);
        }

        // Calculate error for each edge and sort by error
        const edgeErrors = [];
        edges.forEach((edge, key) => {
            const error = this._calculateEdgeCollapseError(edge, positions, quadrics);
            edgeErrors.push({ edge, error, key });
        });

        // Sort edges by error (lowest first)
        edgeErrors.sort((a, b) => a.error - b.error);

        // Collapse edges until target reduction is reached
        const targetVertexCount = Math.floor(originalVertexCount * (1 - targetReduction));
        const removedVertices = new Set();
        const vertexMapping = new Map(); // maps old vertex to new vertex

        let currentVertexCount = originalVertexCount;
        let collapsedEdges = 0;

        for (const { edge, key } of edgeErrors) {
            if (currentVertexCount <= targetVertexCount) break;

            const { v1, v2 } = edge;

            // Skip if either vertex has already been removed
            if (removedVertices.has(v1) || removedVertices.has(v2)) continue;

            // Skip boundary edges (edges with only one triangle)
            if (edge.triangles.length < 2) continue;

            // Collapse edge: keep v1, remove v2
            removedVertices.add(v2);
            vertexMapping.set(v2, v1);

            // Merge position to midpoint
            const i1 = v1 * 3;
            const i2 = v2 * 3;
            positions[i1] = (positions[i1] + positions[i2]) / 2;
            positions[i1 + 1] = (positions[i1 + 1] + positions[i2 + 1]) / 2;
            positions[i1 + 2] = (positions[i1 + 2] + positions[i2 + 2]) / 2;

            currentVertexCount--;
            collapsedEdges++;
        }

        // Rebuild index buffer, removing degenerate triangles
        const newIndices = [];
        for (let i = 0; i < indices.length; i += 3) {
            let v0 = indices[i];
            let v1 = indices[i + 1];
            let v2 = indices[i + 2];

            // Remap vertices
            while (vertexMapping.has(v0)) v0 = vertexMapping.get(v0);
            while (vertexMapping.has(v1)) v1 = vertexMapping.get(v1);
            while (vertexMapping.has(v2)) v2 = vertexMapping.get(v2);

            // Skip degenerate triangles
            if (v0 === v1 || v1 === v2 || v2 === v0) continue;

            newIndices.push(v0, v1, v2);
        }

        // Update geometry
        geometry.setIndex(newIndices);
        geometry.attributes.position.needsUpdate = true;

        // Recompute normals
        geometry.computeVertexNormals();

        const endTime = performance.now();
        const finalTriangleCount = newIndices.length / 3;

        console.log(`[MeshDecimation] Completed in ${(endTime - startTime).toFixed(2)}ms:`, {
            originalVertices: originalVertexCount,
            remainingVertices: currentVertexCount,
            originalTriangles: originalTriangleCount,
            finalTriangles: finalTriangleCount,
            reduction: ((1 - finalTriangleCount / originalTriangleCount) * 100).toFixed(1) + '%',
            collapsedEdges: collapsedEdges
        });
    }

    _addEdge(edges, v1, v2, triIndex) {
        // Ensure consistent edge key (lower index first)
        const [min, max] = v1 < v2 ? [v1, v2] : [v2, v1];
        const key = `${min},${max}`;

        if (!edges.has(key)) {
            edges.set(key, { v1: min, v2: max, triangles: [] });
        }
        edges.get(key).triangles.push(triIndex);
    }

    _calculateVertexQuadric(vertexIndex, positions, indices, vertexTriangles) {
        // Quadric error matrix (4x4 symmetric matrix, stored as 10 values)
        const Q = new Float32Array(10); // [a,b,c,d,e,f,g,h,i,j] representing symmetric 4x4

        const triangles = vertexTriangles.get(vertexIndex);

        for (const triIndex of triangles) {
            const i = triIndex * 3;
            const v0 = indices[i];
            const v1 = indices[i + 1];
            const v2 = indices[i + 2];

            // Get triangle vertices
            const p0 = new THREE.Vector3(
                positions[v0 * 3],
                positions[v0 * 3 + 1],
                positions[v0 * 3 + 2]
            );
            const p1 = new THREE.Vector3(
                positions[v1 * 3],
                positions[v1 * 3 + 1],
                positions[v1 * 3 + 2]
            );
            const p2 = new THREE.Vector3(
                positions[v2 * 3],
                positions[v2 * 3 + 1],
                positions[v2 * 3 + 2]
            );

            // Calculate plane equation: ax + by + cz + d = 0
            const edge1 = new THREE.Vector3().subVectors(p1, p0);
            const edge2 = new THREE.Vector3().subVectors(p2, p0);
            const normal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();

            const a = normal.x;
            const b = normal.y;
            const c = normal.z;
            const d = -normal.dot(p0);

            // Add to quadric (sum of plane equations)
            Q[0] += a * a; Q[1] += a * b; Q[2] += a * c; Q[3] += a * d;
            Q[4] += b * b; Q[5] += b * c; Q[6] += b * d;
            Q[7] += c * c; Q[8] += c * d;
            Q[9] += d * d;
        }

        return Q;
    }

    _calculateEdgeCollapseError(edge, positions, quadrics) {
        const { v1, v2 } = edge;

        // Get midpoint of edge
        const i1 = v1 * 3;
        const i2 = v2 * 3;
        const x = (positions[i1] + positions[i2]) / 2;
        const y = (positions[i1 + 1] + positions[i2 + 1]) / 2;
        const z = (positions[i1 + 2] + positions[i2 + 2]) / 2;

        // Sum quadrics of both vertices
        const Q = new Float32Array(10);
        const Q1 = quadrics[v1];
        const Q2 = quadrics[v2];

        for (let i = 0; i < 10; i++) {
            Q[i] = Q1[i] + Q2[i];
        }

        // Calculate error: v^T * Q * v where v = [x, y, z, 1]
        const error =
            Q[0] * x * x + 2 * Q[1] * x * y + 2 * Q[2] * x * z + 2 * Q[3] * x +
            Q[4] * y * y + 2 * Q[5] * y * z + 2 * Q[6] * y +
            Q[7] * z * z + 2 * Q[8] * z +
            Q[9];

        return Math.abs(error);
    }

    applyHeightMapToGeometry() {
        if (!this.ground || !this.groundVertices) return;

        const positions = this.groundVertices.array;
        const geometry = this.ground.geometry;
        const segments = this.heightMapResolution;
        const verticesPerRow = segments + 1;

        // First pass: Update vertex heights
        for (let z = 0; z < verticesPerRow; z++) {
            for (let x = 0; x < verticesPerRow; x++) {
                const vertexIndex = (z * verticesPerRow + x);
                const idx = vertexIndex * 3;

                const nx = x / segments;
                const nz = z / segments;

                const terrainX = Math.floor(nx * (this.extendedSize));
                const terrainZ = Math.floor(nz * (this.extendedSize));

                const heightIndex = terrainZ * this.extendedSize + terrainX;
                const height = this.heightMapData[heightIndex] || 0;

                positions[idx + 2] = height;
            }
        }

        this.groundVertices.needsUpdate = true;
        geometry.computeVertexNormals();

        // Decimate the mesh to reduce vertex count
      //  this.decimateMesh(geometry);

        // Rebuild BVH tree after geometry modification for accurate raycasting
        if (geometry.boundsTree) {
            geometry.disposeBoundsTree();
        }
        geometry.computeBoundsTree();

        // Second pass: Generate cliff entities using TileMap analysis
        this.generateCliffEntities();
    }


    generateCliffEntities() {
        if (!this.heightMapData || !this.tileMap?.terrainMap || !this.game.terrainTileMapper) return;

        const terrainMap = this.tileMap.terrainMap;
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const rows = terrainMap.length;
        const cols = terrainMap[0].length;

        const mapAnalysis = this.game.terrainTileMapper.analyzeMap();

        mapAnalysis.forEach((tile, index) => {
            const x = (index % cols);
            const z = Math.floor(index / cols);

            // Use heightAnalysis for cliff placement (cliffs are based on height differences)
            const heightAnalysis = tile.heightAnalysis;

            // Only process tiles that have lower neighbors (cliff edges)
            if (heightAnalysis.neighborLowerCount > 0 || heightAnalysis.cornerLowerCount > 0) {
                this.placeCliffAtomsForTile(x, z, heightAnalysis, gridSize);
            }
        });
    }

    placeCliffAtomsForTile(x, z, heightAnalysis, gridSize) {

        if(this.game.gameManager.call('hasRampAt', x, z)){
            return;
        }
        // Convert grid coordinates to world coordinates
        const worldX = (x * gridSize + this.extensionSize) - this.extendedSize / 2;
        const worldZ = (z * gridSize + this.extensionSize) - this.extendedSize / 2;
        const offset = 0;
        const halfOffset = offset / 2;
        const halfGrid = gridSize / 2 + halfOffset;
        const quarterGrid = gridSize / 4 + halfOffset / 2; // Center of each quadrant


        // Calculate cliff bottom height
        let cliffBottomHeightIndex = heightAnalysis.heightIndex - 2;
        if (heightAnalysis.neighborLowerCount == 0 && heightAnalysis.cornerLowerCount == 0) {
            cliffBottomHeightIndex += 1;
        }
        const cliffHeight = cliffBottomHeightIndex * this.heightStep;

        // Array to store atom placements
        const atomPlacements = [];

        // Helper function to add atom
        const addAtom = (type, localX, localZ, rotation) => {
            atomPlacements.push({
                type,
                x: worldX + localX - halfOffset,
                z: worldZ + localZ - halfOffset,
                rotation
            });
        };

        // Track which quadrants are occupied by corners
        const topLeftOccupied = (heightAnalysis.topLess && heightAnalysis.leftLess) ||
                                (heightAnalysis.cornerTopLeftLess && !heightAnalysis.topLess && !heightAnalysis.leftLess);
        const topRightOccupied = (heightAnalysis.topLess && heightAnalysis.rightLess) ||
                                (heightAnalysis.cornerTopRightLess && !heightAnalysis.topLess && !heightAnalysis.rightLess);
        const botLeftOccupied = (heightAnalysis.botLess && heightAnalysis.leftLess) ||
                                (heightAnalysis.cornerBottomLeftLess && !heightAnalysis.botLess && !heightAnalysis.leftLess);
        const botRightOccupied = (heightAnalysis.botLess && heightAnalysis.rightLess) ||
                                (heightAnalysis.cornerBottomRightLess && !heightAnalysis.botLess && !heightAnalysis.rightLess);

        // Place corners first (they take priority) - CENTERED in their quadrants
        // Outer corners
        if (heightAnalysis.topLess && heightAnalysis.leftLess) {
            addAtom('atom_one', quarterGrid, quarterGrid, 0);
        }

        if (heightAnalysis.topLess && heightAnalysis.rightLess) {
            addAtom('atom_one', quarterGrid * 3, quarterGrid, Math.PI / 2);
        }

        if (heightAnalysis.botLess && heightAnalysis.leftLess) {
            addAtom('atom_one', quarterGrid, quarterGrid * 3, -Math.PI / 2);
        }

        if (heightAnalysis.botLess && heightAnalysis.rightLess) {
            addAtom('atom_one', quarterGrid * 3, quarterGrid * 3, Math.PI);
        }

        // Inner corners - CENTERED in their quadrants
        if (heightAnalysis.cornerTopLeftLess && !heightAnalysis.topLess && !heightAnalysis.leftLess) {
            addAtom('atom_three', quarterGrid, quarterGrid, 0);
        }

        if (heightAnalysis.cornerTopRightLess && !heightAnalysis.topLess && !heightAnalysis.rightLess) {
            addAtom('atom_three', quarterGrid * 3, quarterGrid, Math.PI / 2);
        }

        if (heightAnalysis.cornerBottomLeftLess && !heightAnalysis.botLess && !heightAnalysis.leftLess) {
            addAtom('atom_three', quarterGrid, quarterGrid * 3, -Math.PI / 2);
        }

        if (heightAnalysis.cornerBottomRightLess && !heightAnalysis.botLess && !heightAnalysis.rightLess) {
            addAtom('atom_three', quarterGrid * 3, quarterGrid * 3, Math.PI);
        }

        // Place edges in empty quadrants - CENTERED in their quadrants
        // Top edge uses top-left and top-right quadrants
        if (heightAnalysis.topLess) {
            if (!topLeftOccupied) {
                addAtom('atom_two', quarterGrid, quarterGrid, Math.PI / 2);
            }
            if (!topRightOccupied) {
                addAtom('atom_two', quarterGrid * 3, quarterGrid, Math.PI / 2);
            }
        }

        // Bottom edge uses bottom-left and bottom-right quadrants
        if (heightAnalysis.botLess) {
            if (!botLeftOccupied) {
                addAtom('atom_two', quarterGrid, quarterGrid * 3, -Math.PI / 2);
            }
            if (!botRightOccupied) {
                addAtom('atom_two', quarterGrid * 3, quarterGrid * 3, -Math.PI / 2);
            }
        }

        // Left edge uses top-left and bottom-left quadrants
        if (heightAnalysis.leftLess) {
            if (!topLeftOccupied) {
                addAtom('atom_two', quarterGrid, quarterGrid, 0);
            }
            if (!botLeftOccupied) {
                addAtom('atom_two', quarterGrid, quarterGrid * 3, 0);
            }
        }

        // Right edge uses top-right and bottom-right quadrants
        if (heightAnalysis.rightLess) {
            if (!topRightOccupied) {
                addAtom('atom_two', quarterGrid * 3, quarterGrid, Math.PI);
            }
            if (!botRightOccupied) {
                addAtom('atom_two', quarterGrid * 3, quarterGrid * 3, Math.PI);
            }
        }

        // Create entities for all atoms
        atomPlacements.forEach(atom => {
            this.createCliffEntity(atom.type, atom.x, cliffHeight, atom.z, atom.rotation);
        });
    }


    resetCliffs() {
        this.destroyAllCliffs();
        this.generateCliffEntities();
    }

    destroyAllCliffs() {
        const cliffs = this.game.getEntitiesWith('cliff');
        cliffs.forEach((cliff) => {
            this.game.destroyEntity(cliff);
        });
    }

    createCliffEntity(type, worldX, worldY, worldZ, rotation) {
        const cliffsType = "cliffs";
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();

        const unitType = this.game.getCollections()[cliffsType]?.[type];
        if (!unitType) {
            console.warn(`Cliff type ${type} not found in cliffs collection`);
            return;
        }

        unitType.collection = cliffsType;
        unitType.id = type;        

        // Create entity with unique ID
        const entityId = this.game.createEntity(`${cliffsType}_${type}_${Math.round(worldX)}_${Math.round(worldZ)}_${Math.random()}`);

        // Add Position component
        this.game.addComponent(entityId, ComponentTypes.POSITION, 
            Components.Position(worldX, worldY, worldZ));

        // Add Renderable component
        this.game.addComponent(entityId, ComponentTypes.RENDERABLE, 
            Components.Renderable(cliffsType, type, 1024));

        // Add Animation component for rotation and scale
        this.game.addComponent(entityId, ComponentTypes.ANIMATION, 
            Components.Animation(1, rotation, 0));

        // Add Facing component for rotation
        this.game.addComponent(entityId, ComponentTypes.FACING, 
            Components.Facing(rotation));

        // Add UnitType component
        this.game.addComponent(entityId, ComponentTypes.UNIT_TYPE, 
            Components.UnitType(unitType));

        // Add Team component (neutral for cliffs)
        this.game.addComponent(entityId, ComponentTypes.TEAM, 
            Components.Team('cliff'));

        this.game.addComponent(entityId, "cliff", { type });

        this.game.triggerEvent('onEntityPositionUpdated', entityId);
    }

    generateLiquidSurfaceMesh(terrainType) {
        const terrainMap = this.tileMap.terrainMap;
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const rows = terrainMap.length;
        const cols = terrainMap[0].length;
        
        // Arrays to store vertices, indices, and UVs for the BufferGeometry
        const vertices = [];
        const indices = [];
        const uvs = [];
        
        // Amount to extend the perimeter (e.g., 10% of gridSize)
        const extensionAmount = gridSize * 0.25; // Adjust as needed        

        // Calculate centering offset to match ground positioning
        const terrainWorldWidth = cols * gridSize;
        const terrainWorldHeight = rows * gridSize;
        const centerOffsetX = -terrainWorldWidth / 2;
        const centerOffsetZ = -terrainWorldHeight / 2;

        // Helper function to check if a tile is a water tile
        const isWaterTile = (x, z) => {
            if (x < 0 || x >= cols || z < 0 || z >= rows) return false;
            return terrainMap[z][x] === terrainType;
        };
        
        // Step 1: Generate a grid of vertices, but only for positions needed by water tiles
        const usedPositions = new Set();
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    usedPositions.add(`${x},${z}`);     // Bottom-left
                    usedPositions.add(`${x + 1},${z}`); // Bottom-right
                    usedPositions.add(`${x + 1},${z + 1}`); // Bottom-right in your view (+z is south)
                    usedPositions.add(`${x},${z + 1}`); // Top-left
                }
            }
        }
        
        // Step 2: Create vertices for all used positions and store their original positions
        const positionToVertexIndex = new Map();
        const originalPositions = []; // Store original (x, z) for each vertex
        let vertexIndex = 0;
        for (const pos of usedPositions) {
            const [x, z] = pos.split(',').map(Number);
            positionToVertexIndex.set(pos, vertexIndex++);
            
            // Apply centering offset to match ground positioning
            const worldX = x * gridSize + centerOffsetX;
            const worldZ = z * gridSize + centerOffsetZ;
            
            vertices.push(worldX, 0.1, worldZ);
            originalPositions.push([x, z]); // Store original grid position
            uvs.push(x, z); // UVs based on grid position
        }
        
        // Step 3: Generate indices for water tiles, connecting them into a single mesh
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    const bl = positionToVertexIndex.get(`${x},${z}`);
                    const br = positionToVertexIndex.get(`${x + 1},${z}`);
                    const tr = positionToVertexIndex.get(`${x + 1},${z + 1}`); // Bottom-right in your view
                    const tl = positionToVertexIndex.get(`${x},${z + 1}`);

                    indices.push(bl, br, tl);
                    indices.push(br, tr, tl);
                }
            }
        }
        
        // Step 4: Identify perimeter vertices and their extension directions
        const perimeterExtensions = new Map(); // Map vertexIndex to { extendLeft, extendRight, extendUp, extendDown }
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    const isLeftEdge = !isWaterTile(x - 1, z);
                    const isRightEdge = !isWaterTile(x + 1, z);
                    const isBottomEdge = !isWaterTile(x, z - 1); // North
                    const isTopEdge = !isWaterTile(x, z + 1);    // South

                    // Bottom-left vertex (x, z)
                    if (isLeftEdge || isBottomEdge) {
                        const vIdx = positionToVertexIndex.get(`${x},${z}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isLeftEdge) ext.extendLeft = true;
                        if (isBottomEdge) ext.extendUp = true; // North
                    }

                    // Bottom-right vertex (x + 1, z)
                    if (isRightEdge || isBottomEdge) {
                        const vIdx = positionToVertexIndex.get(`${x + 1},${z}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isRightEdge) ext.extendRight = true;
                        if (isBottomEdge) ext.extendUp = true; // North
                    }

                    // Top-right vertex (x + 1, z + 1) - Bottom-right in your view
                    if (isRightEdge || isTopEdge) {
                        const vIdx = positionToVertexIndex.get(`${x + 1},${z + 1}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isRightEdge) ext.extendRight = true;
                        if (isTopEdge) ext.extendDown = true; // South
                    }

                    // Top-left vertex (x, z + 1)
                    if (isLeftEdge || isTopEdge) {
                        const vIdx = positionToVertexIndex.get(`${x},${z + 1}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isLeftEdge) ext.extendLeft = true;
                        if (isTopEdge) ext.extendDown = true; // South
                    }
                }
            }
        }
        
        // Step 5: Apply perimeter extensions
        perimeterExtensions.forEach((ext, vertexIndex) => {
            const idx = vertexIndex * 3;
            const [origX, origZ] = originalPositions[vertexIndex];     

            if (ext.extendLeft) vertices[idx] -= extensionAmount; // Extend left
            if (ext.extendRight) vertices[idx] += extensionAmount; // Extend right
            if (ext.extendUp) vertices[idx + 2] -= extensionAmount; // Extend north (decrease z)
            if (ext.extendDown) vertices[idx + 2] += extensionAmount; // Extend south (increase z)

       
        });
        
        // Step 6: Create the BufferGeometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geometry.setIndex(indices);
        geometry.computeVertexNormals(); // For lighting
        
        // Parse the hex color to RGB
        const parseHexColor = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return { r, g, b };
        };
        
        const waterShader = this.game.getCollections().shaders[this.level.waterShader];
        
        // Use the hex color in a ShaderMaterial
        this.uniforms[terrainType] = JSON.parse(waterShader.uniforms);
        let vectorizeProps = JSON.parse(waterShader.vectors);
        vectorizeProps.forEach((prop => {
            if (this.uniforms[terrainType][prop]) {
                if( prop.toLowerCase().endsWith("color")){
                    const colorToUse = this.tileMap.terrainTypes[terrainType].color;
                    const { r, g, b } = parseHexColor(colorToUse);
                    this.uniforms[terrainType][prop].value = new THREE.Vector3(r, g, b);
                } else {
                    let arr = this.uniforms[terrainType][prop].value;
                    this.uniforms[terrainType][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);
                }
            }
        }));
        
        this.uniforms[terrainType].fogColor = { value: new THREE.Color(this.fogSettings.color) };
        this.uniforms[terrainType].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;
        
        // Reference the uniforms
        const uniforms = this.uniforms[terrainType];
        
        // Create the shader material
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: waterShader.vertexScript,
            fragmentShader: waterShader.fragmentScript,
            side: THREE.DoubleSide,
            transparent: true
        });

        // Replace the MeshBasicMaterial with this ShaderMaterial in the mesh creation
        const waterMesh = new THREE.Mesh(geometry, material);        
        waterMesh.position.y = (terrainType + 1) * this.heightMapSettings.heightStep;
        
        // No additional position offset needed since vertices are already centered
        waterMesh.position.x = 0;
        waterMesh.position.z = 0;
        
        this.scene.add(waterMesh);
        this.liquidMeshes.push(waterMesh);

    }

    addGrassToTerrain() {
        const bladeWidth = 12;
        const bladeHeight = 18;
        const grassGeometry = this.createCurvedBladeGeometry(bladeWidth, bladeHeight);
        grassGeometry.translate(0, bladeHeight / 2, 0);
        const grassCount = 50000;

        const gridSize = this.game.getCollections().configs.game.gridSize;
        const phases = new Float32Array(grassCount);
        for (let i = 0; i < grassCount; i++) {
            phases[i] = Math.random() * Math.PI * 2;
        }
        grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(phases, 1));

        const grassTexture = this.createGrassTexture();
        const grassShader = this.game.getCollections().shaders[this.level.grassShader];
        this.uniforms['grass'] = JSON.parse(grassShader.uniforms);
        
        this.uniforms['grass'].windDirection = { value: new THREE.Vector2(this.uniforms['grass'].windDirection.value[0], this.uniforms['grass'].windDirection.value[1]).normalize()};
        this.uniforms['grass'].map = { value: grassTexture };
        this.uniforms['grass'].fogColor = { value: new THREE.Color(this.fogSettings.color) };
        this.uniforms['grass'].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;
        const lightDirection = new THREE.Vector3();
        lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);
        lightDirection.normalize();

        this.uniforms['grass'].skyColor =  { value: new THREE.Color(this.lightingSettings.skyColor) }; // HemisphereLight sky color
        this.uniforms['grass'].groundColor = { value: new THREE.Color(this.lightingSettings.groundColor) }; // HemisphereLight ground color
        this.uniforms['grass'].hemisphereIntensity = { value: this.lightingSettings.hemisphereIntensity };

        const uniforms = this.uniforms['grass'];
        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassShader.vertexScript,
            fragmentShader: grassShader.fragmentScript,
            uniforms: uniforms,
            transparent: true
        });

        this.grassShader = this.grassMaterial;
        
        grassGeometry.computeVertexNormals(); 
        const grass = new THREE.InstancedMesh(grassGeometry, this.grassMaterial, grassCount);
        grass.castShadow = true;
        grass.receiveShadow = false;

        const dummy = new THREE.Object3D();
        const grassArea = this.extendedSize;  
        const ctx = this.groundCanvas.getContext('2d');
        const terrainData = ctx.getImageData(0, 0, this.groundCanvas.width, this.groundCanvas.height).data;

        // Create a density map for grass placement
        const densityMap = new Float32Array(this.extendedSize * this.extendedSize);
        for (let z = 0; z < this.extendedSize; z++) {
            for (let x = 0; x < this.extendedSize; x++) {
                // Check current pixel for green dominance
                const pixelIndex = (z * this.groundCanvas.width + x) * 4;
                const isGreenDominant = (pixel) => {
                    const r = terrainData[pixel];
                    const g = terrainData[pixel + 1];
                    const b = terrainData[pixel + 2];
                    return g > r && g > b;
                };

                // Only set density if current pixel and all neighbors are green
                if (isGreenDominant(pixelIndex)) {
                    // Check 8 neighboring pixels
                    let checkDist = Math.ceil(gridSize / 10);
                    const neighbors = [
                        [-checkDist, -checkDist], [0, -checkDist], [checkDist, -checkDist],
                        [-checkDist,  0],                           [checkDist,  0],
                        [-checkDist,  checkDist], [0,  checkDist], [checkDist,  checkDist]
                    ];

                    let allNeighborsGreen = true;
                    for (const [dx, dz] of neighbors) {
                        const nx = x + dx;
                        const nz = z + dz;
                        
                        // Skip if neighbor is outside bounds
                        if (nx < 0 || nx >= this.extendedSize || nz < 0 || nz >= this.extendedSize) {
                            allNeighborsGreen = false;
                            break;
                        }

                        const neighborIndex = (nz * this.groundCanvas.width + nx) * 4;
                        if (!isGreenDominant(neighborIndex)) {
                            allNeighborsGreen = false;
                            break;
                        }
                    }

                    densityMap[z * this.extendedSize + x] = allNeighborsGreen ? 1 : 0;
                } else {
                    densityMap[z * this.extendedSize + x] = 0;
                }
            }
        }

        // Place grass based on density
        let placed = 0;
        for (let i = 0; i < grassCount * 2 && placed < grassCount; i++) {
            const x = Math.floor(Math.random() * grassArea);
            const z = Math.floor(Math.random() * grassArea);
            if (densityMap[z * this.extendedSize + x] > 0) {
                const rotationY = Math.random() * Math.PI * 2;
                const scale = 0.7 + Math.random() * 0.5;
                let height = this.heightMapSettings.enabled
                    ? this.heightMapData[Math.min(z, this.extendedSize - 1) * this.extendedSize + Math.min(x, this.extendedSize - 1)] || 0
                    : 0;
                dummy.position.set(x - grassArea / 2 , height - bladeHeight, z - grassArea / 2);
                dummy.rotation.set(0, rotationY, 0);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                grass.setMatrixAt(placed++, dummy.matrix);
            }
        }

        grass.instanceMatrix.needsUpdate = true;
        this.scene.add(grass);
        this.grass = grass;
    }
    
    createCurvedBladeGeometry(width = 0.1, height = 1) {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);
    
        const shapeGeom = new THREE.ShapeGeometry(shape, 12);
        const positions = shapeGeom.attributes.position.array;
        const uvs = shapeGeom.attributes.uv.array;
        const vertexCount = positions.length / 3;
    
        const newUVs = new Float32Array(uvs.length);
        const newNormals = new Float32Array(positions.length);
    
        for (let i = 0; i < vertexCount; i++) {
            const posIndex = i * 3;
            const uvIndex = i * 2;
            const x = positions[posIndex];
            const y = positions[posIndex + 1];
            const normalizedY = y / height;
    
            newUVs[uvIndex] = uvs[uvIndex];
            newUVs[uvIndex + 1] = normalizedY;
    
            // Compute normal: approximate outward direction along curve
            const t = y / height; // Parameter along curve
            const curveX = width * 0.5 * (1 - t); // Quadratic curve approximation
            const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();
            const normal = new THREE.Vector2(-tangent.y, tangent.x); // Perpendicular to tangent
            newNormals[posIndex] = normal.x;
            newNormals[posIndex + 1] = 0;
            newNormals[posIndex + 2] = normal.y;
        }
    
        shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));
        shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
        return shapeGeom;
    }

    createGrassTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 4;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0.0, this.game.palette["greenMColor"]);
        gradient.addColorStop(0.8, this.game.palette["greenMColor"]);
        gradient.addColorStop(1.0, this.game.palette["redLColor"]);

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        return texture;
    }

    // Utility methods for external systems
    setControlsEnabled(enabled) {
        if (this.controls) {
            this.controls.enabled = enabled;
        }
    }

    resetCamera() {
        if (!this.cameraSettings) return;

        const cameraPos = JSON.parse(this.cameraSettings.position);
        const lookAt = JSON.parse(this.cameraSettings.lookAt);

        if (this.controls) {
            this.controls.reset();
            this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
            this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);
            this.controls.update();
        } else {
         //   this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
        //    this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);
        }

    }

    // Terrain update methods for dynamic changes
    updateTerrain() {
        this.terrainRendered = false;
        this._cachedColorMap = null;
        this.renderTerrain();
    }

    destroy() {

        // Clean up extension planes
        if (this.extensionPlanes) {
            this.extensionPlanes.forEach(plane => {
                this.scene.remove(plane);
                plane.geometry?.dispose();
                plane.material?.dispose();
            });
            this.extensionPlanes = [];
        }

        // Clean up ground
        if (this.ground) {
            this.scene.remove(this.ground);
            this.ground.geometry?.dispose();
            this.ground.material?.dispose();
        }

        // Clean up grass
        if (this.grass) {
            this.scene.remove(this.grass);
            this.grass.geometry?.dispose();
            this.grass.material?.dispose();
        }

        // Clean up liquid meshes
        this.liquidMeshes.forEach(mesh => {
            this.scene.remove(mesh);
            mesh.geometry?.dispose();
            mesh.material?.dispose();
        });
        this.liquidMeshes = [];

        // Clean up textures
        this.groundTexture?.dispose();

        // Clean up lights
        if (this.ambientLight) this.scene.remove(this.ambientLight);
        if (this.directionalLight) {
            this.scene.remove(this.directionalLight);
            this.scene.remove(this.directionalLight.target);
        }
        if (this.hemisphereLight) this.scene.remove(this.hemisphereLight);

        // Clean up Three.js core
        if (this.renderer) {
            this.renderer.dispose();
        }

        // Clean up composer
        if (this.composer) {
            this.composer.dispose();
        }

        // Clean up orbit controls
        if (this.controls) {
            this.controls.dispose();
            this.controls = null;
        }

        // Remove event listeners
        window.removeEventListener('resize', this.onWindowResizeHandler);

        // Clear references
        this.groundCanvas = null;
        this.terrainCanvas = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null;

        this.initialized = false;
    }

    // Add this method to the WorldSystem class

    getTerrainHeightAtPosition(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates
        // The ground is centered at origin, so we need to offset by half the extended size
        const heightMapX = Math.floor(worldX + this.extendedSize / 2);
        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);
        
        // Ensure coordinates are within bounds
        if (heightMapX < 0 || heightMapX >= this.extendedSize || heightMapZ < 0 || heightMapZ >= this.extendedSize) {
            // Outside terrain bounds, use extension terrain height
            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
            return extensionTerrainType * this.heightStep;
        }
        
        // Get height from height map
        const heightIndex = heightMapZ * this.extendedSize + heightMapX;
        return this.heightMapData[heightIndex] || 0;
    }

    // Optional: Add bilinear interpolation for smoother height transitions
    getTerrainHeightAtPositionSmooth(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates (with decimal precision)
        const heightMapX = worldX + this.extendedSize / 2;
        const heightMapZ = worldZ + this.extendedSize / 2;
        
        // Get the four surrounding grid points
        const x0 = Math.floor(heightMapX);
        const x1 = x0 + 1;
        const z0 = Math.floor(heightMapZ);
        const z1 = z0 + 1;
        
        // Get fractional parts for interpolation
        const fx = heightMapX - x0;
        const fz = heightMapZ - z0;
        
        // Helper function to get height at specific grid point
        const getHeightAt = (x, z) => {
            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {
                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
                return extensionTerrainType * this.heightStep;
            }
            const heightIndex = z * this.extendedSize + x;
            return this.heightMapData[heightIndex] || 0;
        };
        
        // Get heights at the four corners
        const h00 = getHeightAt(x0, z0);
        const h10 = getHeightAt(x1, z0);
        const h01 = getHeightAt(x0, z1);
        const h11 = getHeightAt(x1, z1);
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }
};

// system: PostProcessingSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PostProcessingSystem'] = class PostProcessingSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.postProcessingSystem = this;
        
        this.composer = null;
        this.passes = new Map();
        this.passOrder = ['render', 'pixel', 'fog', 'output'];
    }

    init(params = {}) {
        this.params = params;

        this.game.gameManager.register('registerPostProcessingPass', this.registerPass.bind(this));
        this.game.gameManager.register('removePostProcessingPass', this.removePass.bind(this));
        this.game.gameManager.register('renderPostProcessing', this.render.bind(this));
        this.game.gameManager.register('getPostProcessingComposer', this.getPostProcessingComposer.bind(this));
    }

    postAllInit() {
        
        if (!this.game.renderer || !this.game.scene || !this.game.camera) {
            console.error('[PostProcessingSystem] Missing renderer, scene, or camera in postAllInit');
            return;
        }
        
        
        this.composer = new THREE_.EffectComposer(this.game.renderer);
        
        // Create depth textures for both render targets
        const depthTexture1 = new THREE.DepthTexture();
        depthTexture1.format = THREE.DepthFormat;
        depthTexture1.type   = THREE.UnsignedIntType; // 24/32-bit depth

        const depthTexture2 = new THREE.DepthTexture();
        depthTexture2.format = THREE.DepthFormat;
        depthTexture2.type   = THREE.UnsignedIntType;

        this.composer.renderTarget1.depthTexture = depthTexture1;
        this.composer.renderTarget1.depthBuffer  = true;
        this.composer.renderTarget2.depthTexture = depthTexture2;
        this.composer.renderTarget2.depthBuffer  = true;

        // Make sure sizes are synced after attaching:
        const size = this.game.renderer.getSize(new THREE.Vector2());
        this.composer.setSize(size.x, size.y);
        
        if (this.passes.size > 0) {
            this.rebuildComposer();
        }
        
    }

    getPostProcessingComposer() {
        return this.composer;
    }

    registerPass(name, passConfig) {
        
        if (this.passes.has(name)) {
            console.warn(`[PostProcessingSystem] Pass ${name} already exists, replacing`);
        }
        
        this.passes.set(name, passConfig);
        
        if (this.composer) {
            this.rebuildComposer();
        } 
    }

    removePass(name) {
        
        if (this.passes.has(name)) {
            const passConfig = this.passes.get(name);
            if (passConfig.dispose) {
                passConfig.dispose();
            }
            this.passes.delete(name);
            
            if (this.composer) {
                this.rebuildComposer();
            }
        }
    }

    rebuildComposer() {
        if (!this.composer) {
            console.warn('[PostProcessingSystem] Composer not initialized yet');
            return;
        }
        
        
        this.composer.passes = [];
        
        for (const passName of this.passOrder) {
            const passConfig = this.passes.get(passName);
            
            if (!passConfig) continue;
            
            if (passConfig.enabled === false) {
                continue;
            }
            
            if (typeof passConfig.create === 'function') {
                const pass = passConfig.create();
                this.composer.addPass(pass);
            } else if (passConfig.pass) {
                this.composer.addPass(passConfig.pass);
            }
        }
        
    }

    render() {
        if (this.composer) {
            // Render main scene with all post-processing (including fog)
            this.composer.render();
            
            if (this.game.uiScene) {
                this.game.renderer.autoClear = false;  // Don't clear the screen    
                this.game.renderer.clearDepth();             
                this.game.renderer.render(this.game.uiScene, this.game.camera);
                this.game.renderer.autoClear = true;   // Reset for next frame
            }
        }
    }

    setSize(width, height) {
        if (this.composer) {
            this.composer.setSize(width, height);
        }
    }

    dispose() {
        if (this.composer) {
            this.composer.passes.forEach(pass => {
                if (pass.dispose) pass.dispose();
            });
        }
        this.passes.clear();
    }
};

// system: RenderSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['RenderSystem'] = class RenderSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.renderSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        this.vatBatches = new Map();
        this.entityToInstance = new Map();
        this.batchCreationPromises = new Map();
        
        this.modelScale = 32;
        this.DEFAULT_CAPACITY = 128;
        this.MIN_MOVEMENT_THRESHOLD = 0.1;

        this.DEBUG = true;
        this.DEBUG_LEVEL = 1;
        this._frame = 0;
        this._stats = {
            entitiesProcessed: 0,
            instancesCreated: 0,
            instancesRemoved: 0,
            batchesActive: 0
        };

        this._bindDebugHelpers();
        this.hiddenEntities = new Set();
    }

    init() {
        this.game.gameManager.register('setInstanceClip', this.setInstanceClip.bind(this));
        this.game.gameManager.register('setInstanceSpeed', this.setInstanceSpeed.bind(this));
        this.game.gameManager.register('isInstanced', this.isInstanced.bind(this));
        this.game.gameManager.register('getEntityAnimationState', this.getEntityAnimationState.bind(this));
        this.game.gameManager.register('setInstanceAnimationTime', this.setInstanceAnimationTime.bind(this));
    }

    _bindDebugHelpers() {
        if (typeof window !== "undefined") {
            window.VATRenderDebug = {
                dumpBatches: () => this.dumpBatches(),
                dumpInstances: () => this.dumpInstances(),
                setDebugLevel: (level) => this.DEBUG_LEVEL = level,
                getStats: () => this._stats
            };
        }
    }

    async update() {
        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;

        this._frame++;
        await this.updateEntities();
        this.updateAnimations();
        this.finalizeUpdates();
    }

    async updateEntities() {
        const CT = this.componentTypes;
        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);
        this._stats.entitiesProcessed = entities.length;
        entities.forEach(async (entityId) => {
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
            const velocity = this.game.getComponent(entityId, CT.VELOCITY);
            const facing = this.game.getComponent(entityId, CT.FACING);
            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);

            if (!unitType) return;

            const fow = this.game.fogOfWarSystem;            
            const isVisible = fow ? fow.isVisibleAt(pos.x, pos.z) : true;
            if (unitType.collection != "worldObjects" && unitType.collection != "cliffs" && !isVisible) {
                if (this.entityToInstance.has(entityId)) {
                    this.hideEntityInstance(entityId);
                }
                return;
            } else {
                if (this.hiddenEntities.has(entityId)) {
                    this.showEntityInstance(entityId);
                }
            }

            if (typeof renderable.spawnType !== 'string') {
                console.error(`[RenderSystem] Unit entity ${entityId} has invalid spawnType:`, {
                    objectType: renderable.objectType,
                    spawnType: renderable.spawnType,
                    spawnTypeType: typeof renderable.spawnType
                });
                return;
            }

            let instance = this.entityToInstance.get(entityId);
            if (!instance) {
                await this.createInstance(entityId, renderable.objectType, renderable.spawnType, renderable.capacity);
                instance = this.entityToInstance.get(entityId);
            }

            if (instance && !this.hiddenEntities.has(entityId)) {
                this.updateInstanceTransform(instance, pos, velocity, facing);
            }
        });

        this.cleanupRemovedEntities(new Set(entities));
    }

    async createInstance(entityId, objectType, spawnType, capacity = this.DEFAULT_CAPACITY) {
        if (typeof spawnType !== 'string') {
            console.error(`[RenderSystem] CRITICAL: spawnType should be string but got ${typeof spawnType}:`, spawnType);
            return null;
        }

        const batchKey = `${objectType}_${spawnType}`;
        let batch = this.vatBatches.get(batchKey);
        if (!batch) {
            if (this.batchCreationPromises.has(batchKey)) {
                try {
                    batch = await this.batchCreationPromises.get(batchKey);
                } catch (error) {
                    return null;
                }
            } else {
                const creationPromise = this.createVATBatch(batchKey, objectType, spawnType, capacity);
                this.batchCreationPromises.set(batchKey, creationPromise);
                
                try {
                    batch = await creationPromise;
                    if (!batch) {
                        console.error(`[RenderSystem] Failed to create batch for ${batchKey}`);
                        return null;
                    }
                } finally {
                    this.batchCreationPromises.delete(batchKey);
                }
            }
        }

        if (!batch || !batch.capacity) {
            console.error(`[RenderSystem] Batch has no capacity property:`, batch);
            return null;
        }

        let instanceIndex = -1;
        for (let i = 0; i < batch.capacity; i++) {
            if (!batch.entityMap.has(i)) {               
                instanceIndex = i;
                break;
            }
        }

        if (instanceIndex === -1) {
            console.warn(`[RenderSystem] Batch ${batchKey} is full (${batch.capacity} instances)`);
            return null;
        }

        batch.entityMap.set(instanceIndex, entityId);
        batch.count = Math.max(batch.count, instanceIndex + 1);
        batch.mesh.count = batch.count;

        if (batch.attributes && batch.attributes.clipIndex) {
            batch.attributes.clipIndex.setX(instanceIndex, 0);
            batch.attributes.animTime.setX(instanceIndex, 0);
            batch.attributes.animSpeed.setX(instanceIndex, 1);
            
            batch.attributes.clipIndex.array[instanceIndex] = 0;
            batch.attributes.animTime.array[instanceIndex] = 0;
            batch.attributes.animSpeed.array[instanceIndex] = 1;
            
            batch.dirty.animation = true; 
        }

        const instance = { batchKey, instanceIndex };
        this.entityToInstance.set(entityId, instance);
        this._stats.instancesCreated++;
    
        return instance;
    }

    async createVATBatch(batchKey, objectType, spawnType, capacity) {
        const collections = this.game.getCollections?.();
        let objectDef = null;
        
        if (collections[objectType]) {
            objectDef = collections[objectType][spawnType];
            if (!objectDef && typeof spawnType === 'number') {
                const objectKeys = Object.keys(collections[objectType]);
                if (spawnType < objectKeys.length) {
                    const unitKey = objectKeys[spawnType];
                    objectDef = collections[objectType][unitKey];
                }
            }
            if (!objectDef) {
                objectDef = collections[objectType][String(spawnType)];
            }
        }
        
        if (!objectDef) {
            console.error(`[RenderSystem] No object definition found for ${objectType} - ${spawnType}`);
            return null;
        }

        let bundleResult;
        try {
            bundleResult = await this.game.modelManager.requestVATBundle(objectType, spawnType, objectDef);
        } catch (error) {
            console.error(`[RenderSystem] VAT bundle request failed for ${batchKey}:`, error);
            return null;
        }
        
        if (!bundleResult.ready) {
            console.warn(`[RenderSystem] VAT bundle not ready for ${batchKey}`);
            return null;
        }

        const bundle = bundleResult.bundle;
        if (!bundle) {
            console.error(`[RenderSystem] No bundle in result for ${batchKey}`, bundleResult);
            return null;
        }
        
        if (!bundle.geometry || !bundle.material) {
            console.error(`[RenderSystem] Invalid VAT bundle for ${batchKey} - missing geometry or material:`, {
                hasGeometry: !!bundle.geometry,
                hasMaterial: !!bundle.material,
                bundle
            });
            return null;
        }

        if (bundle.meta) {
            if (bundle.meta.clips && bundle.meta.clipIndexByName) {
                bundle.meta.clips.forEach((clip, arrayIndex) => {
                    const mappedIndex = bundle.meta.clipIndexByName[clip.name];
                    const match = mappedIndex === arrayIndex;
                    if (!match) {
                        console.error(`[RenderSystem] METADATA CORRUPTION: Clip "${clip.name}" index mismatch!`);
                    }
                });
            }
        } else {
            console.error(`[RenderSystem] CRITICAL: No meta object in VAT bundle for ${batchKey}`);
        }

        const geometry = bundle.geometry.clone();
        const material = bundle.material;

        material.uuid = THREE.MathUtils.generateUUID();
        material.needsUpdate = true;

        material.userData = {
            batchKey: batchKey,
            createdAt: Date.now(),
            vatTexture: bundle.meta.vatTextureId || 'unknown'
        };

        this.setupVATAttributes(geometry, capacity);

        const mesh = new THREE.InstancedMesh(geometry, material, capacity);
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        mesh.count = 0;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        mesh.frustumCulled = false;
        
        const boundingBox = new THREE.Box3();
        const size = this.modelScale * 2;
        boundingBox.setFromCenterAndSize(new THREE.Vector3(0, 0, 0), new THREE.Vector3(size, size, size));
        geometry.boundingBox = boundingBox;
        geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), this.modelScale);

        if (!material.side || material.side === THREE.FrontSide) {
            material.side = THREE.DoubleSide;
        }

        this.game.scene.add(mesh);

        const batch = {
            mesh,
            geometry,
            material,
            capacity,
            count: 0,
            entityMap: new Map(),
            attributes: {
                clipIndex: geometry.getAttribute('aClipIndex'),
                animTime: geometry.getAttribute('aAnimTime'),
                animSpeed: geometry.getAttribute('aAnimSpeed')
            },
            dirty: {
                matrices: false,
                animation: false
            },
            meta: bundle.meta,
            bundleSource: `${objectType}/${spawnType}`
        };

        for (let i = 0; i < capacity; i++) {
            batch.attributes.clipIndex.setX(i, 0);
            batch.attributes.animTime.setX(i, 0);
            batch.attributes.animSpeed.setX(i, 1);
        }
        batch.dirty.animation = true;

        this.vatBatches.set(batchKey, batch);
        this._stats.batchesActive = this.vatBatches.size;
  
        return batch;
    }

    setupVATAttributes(geometry, capacity) {
        const clipIndexArray = new Float32Array(capacity).fill(0);
        const animTimeArray = new Float32Array(capacity).fill(0);
        const animSpeedArray = new Float32Array(capacity).fill(1);

        const clipIndexAttr = new THREE.InstancedBufferAttribute(clipIndexArray, 1);
        const animTimeAttr = new THREE.InstancedBufferAttribute(animTimeArray, 1);
        const animSpeedAttr = new THREE.InstancedBufferAttribute(animSpeedArray, 1);
        
        clipIndexAttr.setUsage(THREE.DynamicDrawUsage);
        animTimeAttr.setUsage(THREE.DynamicDrawUsage);
        animSpeedAttr.setUsage(THREE.DynamicDrawUsage);
        
        geometry.setAttribute('aClipIndex', clipIndexAttr);
        geometry.setAttribute('aAnimTime', animTimeAttr);
        geometry.setAttribute('aAnimSpeed', animSpeedAttr);
    }

    updateInstanceTransform(instance, pos, velocity, facing) {
        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const matrix = new THREE.Matrix4();
        const baseScale = (batch.meta && batch.meta.baseScale) ? batch.meta.baseScale : new THREE.Vector3(1, 1, 1);
        const basePosition = (batch.meta && batch.meta.basePos) ? batch.meta.basePos : new THREE.Vector3(0, 0, 0);

        const position = new THREE.Vector3(
            pos.x + basePosition.x,
            pos.y + basePosition.y,
            pos.z + basePosition.z
        );
        
        const quaternion = new THREE.Quaternion();
        const facingAngle = this.calculateFacingAngle(velocity, facing);
        if (facingAngle !== null) {
            const isProjectile = !facing || facing.angle === undefined;
			if(isProjectile) {
                const direction = new THREE.Vector3(velocity.vx, velocity.vy, velocity.vz).normalize();
                const defaultForward = new THREE.Vector3(0, 1, 0);
                quaternion.setFromUnitVectors(defaultForward, direction);
            } else {
				quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -facingAngle + Math.PI / 2);
			}
        }

        const scale = new THREE.Vector3(
            this.modelScale * baseScale.x,
            this.modelScale * baseScale.y,
            this.modelScale * baseScale.z
        );

        matrix.compose(position, quaternion, scale);
        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);
        batch.dirty.matrices = true;
    }

    calculateFacingAngle(velocity, facing) {
        if (velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD)) {
            return Math.atan2(velocity.vz, velocity.vx);
        }
        
        if (facing && facing.angle !== undefined) {
            return facing.angle;
        }

        return null;
    }

    updateAnimations() {
        const dt = this.game.state?.deltaTime;
        if (!dt) return;

        for (const [batchKey, batch] of this.vatBatches) {
            if (batchKey.startsWith('buildings_')) continue;
            const clipIndexAttr = batch.attributes.clipIndex;
            const animTimeAttr = batch.attributes.animTime;
            const animSpeedAttr = batch.attributes.animSpeed;
            
            let hasAnimationUpdates = false;

            for (const [instanceIndex, entityId] of batch.entityMap) {
                const currentTime = animTimeAttr.array[instanceIndex];
                const speed = animSpeedAttr.array[instanceIndex];
                const clipIndex = clipIndexAttr.array[instanceIndex];

                if (speed > 0) {
                    const clip = batch.meta.clips[clipIndex];
                    const duration = clip?.duration || 1.0;
                    
                    const newTime = (currentTime + dt * speed) % duration;
                    animTimeAttr.array[instanceIndex] = newTime;
                    hasAnimationUpdates = true;
                }
            }

            if (hasAnimationUpdates) {
                animTimeAttr.needsUpdate = true;
                batch.dirty.animation = true;
            }
        }
    }

    finalizeUpdates() {
        for (const batch of this.vatBatches.values()) {
            if (batch.dirty.matrices) {
                batch.mesh.instanceMatrix.needsUpdate = true;
                batch.dirty.matrices = false;
            }
            
            if (batch.dirty.animation) {
                batch.attributes.clipIndex.needsUpdate = true;
                batch.attributes.animSpeed.needsUpdate = true;
                batch.dirty.animation = false;
            }
        }
    }

    setInstanceClip(entityId, clipName, resetTime = true) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) {
            console.warn(`[RenderSystem] No instance found for entity ${entityId}`);
            return false;
        }

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) {
            console.warn(`[RenderSystem] No batch found for key ${instance.batchKey}`);
            return false;
        }

        const clipIndex = batch.meta.clipIndexByName[clipName];
        if (clipIndex === undefined) {
            console.warn(`[RenderSystem] Clip '${clipName}' not found in batch ${instance.batchKey}.`);
            console.warn(`Available:`, Object.keys(batch.meta.clipIndexByName));
            console.warn(`  - Batch meta clips array:`, batch.meta.clips?.map(c => c.name || 'unnamed'));
            console.warn(`  - Bundle source:`, batch.bundleSource || 'unknown');
            return false;
        }

        const currentEntity = batch.entityMap.get(instance.instanceIndex);
        
        if (currentEntity !== entityId) {
            console.error(`[RenderSystem] SLOT CORRUPTION! Slot ${instance.instanceIndex} maps to ${currentEntity} but trying to write for ${entityId}`);
            
            let correctSlot = -1;
            for (const [slot, mappedEntityId] of batch.entityMap.entries()) {
                if (mappedEntityId === entityId) {
                    correctSlot = slot;
                    break;
                }
            }
            if (correctSlot !== -1) {
                console.warn(`[RenderSystem] RECOVERY: Found correct slot ${correctSlot} for entity ${entityId}`);
                instance.instanceIndex = correctSlot;
                this.entityToInstance.set(entityId, instance);
            } else {
                console.error(`[RenderSystem] CORRUPTION: Entity ${entityId} not found in any slot!`);
                return false;
            }
        }

        batch.attributes.clipIndex.setX(instance.instanceIndex, clipIndex);
        batch.attributes.clipIndex.array[instance.instanceIndex] = clipIndex;
        
        if (resetTime) {
            batch.attributes.animTime.setX(instance.instanceIndex, 0);
            batch.attributes.animTime.array[instance.instanceIndex] = 0;
        }
        batch.dirty.animation = true;

        const verifyClipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];
  
        if (verifyClipIndex !== clipIndex) {
            console.error(`[RenderSystem] WRITE FAILED! Expected ${clipIndex} but got ${verifyClipIndex}`);
        }

        return true;
    }

    setInstanceSpeed(entityId, speed) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return false;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return false;

        batch.attributes.animSpeed.setX(instance.instanceIndex, speed);
        batch.dirty.animation = true;
    
        return true;
    }

    setInstanceAnimationTime(entityId, time) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return false;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return false;

        batch.attributes.animTime.setX(instance.instanceIndex, time);
        batch.attributes.animTime.array[instance.instanceIndex] = time;
        batch.dirty.animation = true;

        return true;
    }

    getEntityAnimationState(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return null;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return null;

        try {
            const clipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];
            const animTime = batch.attributes.animTime.array[instance.instanceIndex];
            const animSpeed = batch.attributes.animSpeed.array[instance.instanceIndex];

            if (clipIndex === undefined || clipIndex === null) return null;

            const clipName = Object.keys(batch.meta.clipIndexByName).find(
                name => batch.meta.clipIndexByName[name] === clipIndex
            );

            return {
                clipName,
                clipIndex,
                animTime,
                animSpeed,
                clipDuration: batch.meta.clips[clipIndex]?.duration || 1.0
            };
        } catch (error) {
            return null;
        }
    }

    cleanupRemovedEntities(currentEntities) {
        const toRemove = [];
        
        for (const [entityId, instance] of this.entityToInstance) {
            if (!currentEntities.has(entityId)) {
                toRemove.push(entityId);
            }
        }

        toRemove.forEach(entityId => {
            this.removeInstance(entityId);
        });
    }

    removeInstance(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const mappedEntity = batch.entityMap.get(instance.instanceIndex);
        if (mappedEntity !== entityId) {
            console.error(`[RenderSystem] CORRUPTION DETECTED! Instance ${instance.instanceIndex} maps to ${mappedEntity} but trying to remove ${entityId}`);
        }

        batch.entityMap.delete(instance.instanceIndex);
        this.entityToInstance.delete(entityId);

        const matrix = new THREE.Matrix4();
        matrix.scale(new THREE.Vector3(0, 0, 0));
        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);
        batch.dirty.matrices = true;

        batch.attributes.clipIndex.setX(instance.instanceIndex, 0);
        batch.attributes.animTime.setX(instance.instanceIndex, 0);
        batch.attributes.animSpeed.setX(instance.instanceIndex, 0);
        
        batch.attributes.clipIndex.array[instance.instanceIndex] = 0;
        batch.attributes.animTime.array[instance.instanceIndex] = 0;
        batch.attributes.animSpeed.array[instance.instanceIndex] = 0;
        
        batch.dirty.animation = true;

        this._stats.instancesRemoved++;
    }

    isInstanced(entityId) {
        return this.entityToInstance.has(entityId);
    }

    getBatchInfo(objectType, spawnType) {
        const batchKey = `${objectType}_${spawnType}`;
        const batch = this.vatBatches.get(batchKey);
        if (!batch) return null;

        return {
            batchKey,
            capacity: batch.capacity,
            count: batch.count,
            activeInstances: batch.entityMap.size,
            availableClips: Object.keys(batch.meta.clipIndexByName)
        };
    }

    dumpBatches() {
        const batches = [];
        for (const [key, batch] of this.vatBatches) {
            batches.push({
                key,
                capacity: batch.capacity,
                count: batch.count,
                activeInstances: batch.entityMap.size,
                clips: Object.keys(batch.meta.clipIndexByName),
                entityMappings: Array.from(batch.entityMap.entries())
            });
        }
        return batches;
    }

    dumpInstances() {
        const instances = [];
        for (const [entityId, instance] of this.entityToInstance) {
            const state = this.getEntityAnimationState(entityId);
            instances.push({
                entityId,
                batchKey: instance.batchKey,
                instanceIndex: instance.instanceIndex,
                animationState: state
            });
        }
        return instances;
    }

    entityDestroyed(entityId) {
        this.removeInstance(entityId);
    }

    isEnemy(teamComp) {
        const myTeam = this.game?.state?.mySide;
        if (!teamComp || myTeam == null) return false;
        return teamComp.team !== myTeam && teamComp.team !== "neutral";
    }


    hideEntityInstance(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return;
        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const m = new THREE.Matrix4();
        m.scale(new THREE.Vector3(0, 0, 0));
        batch.mesh.setMatrixAt(instance.instanceIndex, m);
        batch.dirty.matrices = true;

        this.hiddenEntities.add(entityId);
    }

    showEntityInstance(entityId) {
        this.hiddenEntities.delete(entityId);
    }

    destroy() {
        for (const batch of this.vatBatches.values()) {
            if (batch.mesh) {
                this.game.scene.remove(batch.mesh);
                batch.mesh.geometry?.dispose();
                batch.mesh.material?.dispose();
            }
        }
        
        this.vatBatches.clear();
        this.entityToInstance.clear();
        this.batchCreationPromises.clear();
    }
};

// system: AISystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['AISystem'] = class AISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.aiSystem = this;
        this.entityAIControllers = new Map();
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('getAIControllerData', this.getAIControllerData.bind(this));
        this.game.gameManager.register('setAIControllerData', this.setAIControllerData.bind(this));
        this.game.gameManager.register('setCurrentAIController', this.setCurrentAIController.bind(this));
        this.game.gameManager.register('getCurrentAIController', this.getCurrentAIController.bind(this));
        this.game.gameManager.register('getCurrentAIControllerId', this.getCurrentAIControllerId.bind(this));
        this.game.gameManager.register('removeAIController', this.removeAIController.bind(this));
        this.game.gameManager.register('removeCurrentAIController', this.removeCurrentAIController.bind(this));
        this.game.gameManager.register('hasAIControllerData', this.hasAIControllerData.bind(this));
    }

    setAIControllerData(entityId, aiControllerId, data, overwriteControllerId = true) {
        let entityControllersMap = this.getEntityAIControllers(entityId);
        if(overwriteControllerId) {
            data.aiControllerId = aiControllerId;
        }
        entityControllersMap.set(aiControllerId, data);
    }

    hasAIControllerData(entityId, aiControllerId){
        let entityControllersMap = this.getEntityAIControllers(entityId);
        const CT = this.game.componentManager.getComponents();        
        return entityControllersMap.has(aiControllerId);
    }

    getAIControllerData(entityId, aiControllerId) {
        let entityControllersMap = this.getEntityAIControllers(entityId);
        const CT = this.game.componentManager.getComponents();        
        return entityControllersMap.get(aiControllerId) || CT.AIState('idle');
    }

    setCurrentAIController(entityId, aiControllerId, data) {
        this.setAIControllerData(entityId, aiControllerId, data);
        this.setAIControllerData(entityId, "AISystem", data, false);

        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);
        aiState.targetPosition = data.targetPosition;
        aiState.target = data.target;
        aiState.meta = data.meta;
        aiState.aiControllerId = aiControllerId;

        // CRITICAL: Always clear path when switching controllers
        // This prevents units from continuing old paths before executing new commands
        aiState.path = [];
        aiState.pathIndex = 0;
        aiState.useDirectMovement = false;
        console.log('setCurrentAIController:', entityId, data.targetPosition, aiState.targetPosition);

        // Update state based on new target
        if (data.targetPosition || data.target) {
            aiState.state = data.state || 'chasing';
        } else {
            aiState.state = data.state || 'idle';
        }
    }

    getCurrentAIController(entityId) {
        return this.getAIControllerData(entityId, "AISystem");
    }

    getCurrentAIControllerId(entityId) {
        return this.getAIControllerData(entityId, "AISystem").aiControllerId;
    }

    removeAIController(entityId, aiControllerId){
        let entityControllersMap = this.getEntityAIControllers(entityId);
        entityControllersMap.delete(aiControllerId);
    }

    removeCurrentAIController(entityId){    
        const currentAiControllerId = this.getCurrentAIControllerId();
        this.removeAIController(entityId, currentAiControllerId);
        const CT = this.game.componentManager.getComponents();        
        this.setAIControllerData(entityId, "AISystem", CT.AIState('idle'), false);
    }

    getEntityAIControllers(entityId) {
        let entityControllersMap = this.entityAIControllers.get(entityId);
        if(!entityControllersMap){
            entityControllersMap = new Map();
            this.entityAIControllers.set(entityId, entityControllersMap);
        }
        return entityControllersMap;
    }

    entityDestroyed(entityId) {
        this.entityAIControllers.delete(entityId);
    }

};

// system: CommandQueueSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CommandQueueSystem'] = class CommandQueueSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.commandQueueSystem = this;

        // Command priority levels
        this.PRIORITY = {
            IDLE: 0,           // Default/automatic behavior (mining, patrolling)
            MOVE: 10,          // Player move commands
            BUILD: 20,         // Building construction
            ATTACK: 30,        // Attack commands
            ABILITY: 40,       // Special abilities
            FORCED: 100        // Force commands (cannot be interrupted)
        };
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('queueCommand', this.queueCommand.bind(this));
        this.game.gameManager.register('executeCommand', this.executeCommand.bind(this));
        this.game.gameManager.register('clearCommands', this.clearCommands.bind(this));
        this.game.gameManager.register('getCurrentCommand', this.getCurrentCommand.bind(this));
        this.game.gameManager.register('canInterruptCommand', this.canInterruptCommand.bind(this));
    }

    /**
     * Queue a command for a unit
     * @param {string} entityId - The unit entity ID
     * @param {object} commandData - Command data (type, controllerId, targetPosition, etc.)
     * @param {boolean} interrupt - Whether to interrupt current command if priority is higher
     * @returns {boolean} - Whether the command was queued/executed
     */
    queueCommand(entityId, commandData, interrupt = true) {
        const ComponentTypes = this.game.componentTypes;
        const Components = this.game.componentManager.getComponents();
;
        // Ensure unit has a command queue
        let commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        if (!commandQueue) {
            commandQueue = Components.CommandQueue();
            this.game.addComponent(entityId, ComponentTypes.COMMAND_QUEUE, commandQueue);
        }

        // Create the command
        const command = Components.Command(
            commandData.type,
            commandData.controllerId,
            commandData.targetPosition,
            commandData.target,
            commandData.meta || {},
            commandData.priority || this.PRIORITY.MOVE,
            commandData.interruptible !== false, // Default to true
            this.game.state.now
        );

        // Check if we should interrupt current command
        if (interrupt && commandQueue.currentCommand) {
            if (this.canInterruptCommand(entityId, command.priority)) {
                // Store current command as cancelled in history
                commandQueue.commandHistory.push({
                    ...commandQueue.currentCommand,
                    cancelled: true,
                    cancelTime: this.game.state.now
                });

                // Execute new command immediately
                this.executeCommand(entityId, command);
                return true;
            } else {
                // Queue it for later
                commandQueue.commands.push(command);
                // Sort by priority (highest first)
                commandQueue.commands.sort((a, b) => b.priority - a.priority);
                return true;
            }
        } else if (!commandQueue.currentCommand) {
            // No current command, execute immediately
            this.executeCommand(entityId, command);
            return true;
        } else {
            // Queue it for later
            commandQueue.commands.push(command);
            commandQueue.commands.sort((a, b) => b.priority - a.priority);
            return true;
        }
    }

    /**
     * Execute a command for a unit
     * @param {string} entityId - The unit entity ID
     * @param {object} command - The command to execute
     */
    executeCommand(entityId, command) {
        const ComponentTypes = this.game.componentTypes;
        const Components = this.game.componentManager.getComponents();

        // Get command queue
        let commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        if (!commandQueue) {
            commandQueue = Components.CommandQueue();
            this.game.addComponent(entityId, ComponentTypes.COMMAND_QUEUE, commandQueue);
        }

        // Set as current command
        commandQueue.currentCommand = command;

        // Get AI state
        const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
        if (!aiState) return;

        // CRITICAL: Always clear the path when executing a new command
        aiState.path = [];
        aiState.pathIndex = 0;
        aiState.useDirectMovement = false;

        // Get controller data for this command
        let controllerData = this.game.aiSystem.getAIControllerData(entityId, command.controllerId);

        // Update controller data with command parameters
        controllerData.targetPosition = command.targetPosition;
        controllerData.target = command.target;
        controllerData.meta = command.meta;
        controllerData.state = command.targetPosition || command.target ? 'chasing' : 'idle';

        // Switch to the command's controller
        this.game.aiSystem.setCurrentAIController(entityId, command.controllerId, controllerData);

        // Debug logging
        if (this.game.debug) {
            console.log(`[CommandQueue] Executing ${command.type} command for ${entityId}`, {
                controllerId: command.controllerId,
                targetPosition: command.targetPosition,
                priority: command.priority
            });
        }
    }

    /**
     * Clear all commands for a unit
     * @param {string} entityId - The unit entity ID
     */
    clearCommands(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);

        if (commandQueue) {
            commandQueue.commands = [];
            if (commandQueue.currentCommand) {
                commandQueue.commandHistory.push({
                    ...commandQueue.currentCommand,
                    cancelled: true,
                    cancelTime: this.game.state.now
                });
                commandQueue.currentCommand = null;
            }
        }
    }

    /**
     * Get current command for a unit
     * @param {string} entityId - The unit entity ID
     * @returns {object|null} - The current command or null
     */
    getCurrentCommand(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
        return commandQueue?.currentCommand || null;
    }

    /**
     * Check if a command can be interrupted by a higher priority command
     * @param {string} entityId - The unit entity ID
     * @param {number} newPriority - Priority of the new command
     * @returns {boolean} - Whether the current command can be interrupted
     */
    canInterruptCommand(entityId, newPriority) {
        const currentCommand = this.getCurrentCommand(entityId);

        if (!currentCommand) return true;
        if (!currentCommand.interruptible) return false;

        return newPriority > currentCommand.priority;
    }

    /**
     * Complete the current command and move to next in queue
     * @param {string} entityId - The unit entity ID
     */
    completeCurrentCommand(entityId) {
        const ComponentTypes = this.game.componentTypes;
        const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);

        if (!commandQueue) return;

        // Move current command to history
        if (commandQueue.currentCommand) {
            commandQueue.commandHistory.push({
                ...commandQueue.currentCommand,
                completedTime: this.game.state.now
            });
            commandQueue.currentCommand = null;
        }

        // Execute next command in queue if available
        if (commandQueue.commands.length > 0) {
            const nextCommand = commandQueue.commands.shift();
            this.executeCommand(entityId, nextCommand);
        } else {
            // No more commands, return to idle
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
                aiState.target = null;
                aiState.path = [];
                aiState.pathIndex = 0;
                aiState.meta = {};
                aiState.aiControllerId = "";
            }
        }
    }

    /**
     * Update command queue system
     * Called every frame to check if commands need to be processed
     */
    onPlacementPhaseStart() {
        const ComponentTypes = this.game.componentTypes;
        const entities = this.game.getEntitiesWith(ComponentTypes.COMMAND_QUEUE, ComponentTypes.AI_STATE);

        for (let i = 0; i < entities.length; i++) {
            const entityId = entities[i];
            const commandQueue = this.game.getComponent(entityId, ComponentTypes.COMMAND_QUEUE);
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);

            // Check if current command is complete
            if (commandQueue.currentCommand) {
                // Command completion is handled by individual systems (BuildAbility, MineGoldAbility, etc.)
                // They should call completeCurrentCommand when done

                // However, we can check for some automatic completions:
                // - If target position is reached and no special state
                if (aiState.state === 'idle' && commandQueue.currentCommand.type === 'move') {
                    // Move command completed
                    this.completeCurrentCommand(entityId);
                }
            }
        }
    }

    /**
     * Clean up command queue when entity is destroyed
     */
    entityDestroyed(entityId) {
        // Nothing to clean up - component will be removed automatically
    }
}
;

// system: MovementSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MovementSystem'] = class MovementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.movementSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.MIN_MOVEMENT_THRESHOLD = 0.1;
        
        this.AI_SPEED_MULTIPLIER = 0.1;
        this.DEFAULT_AI_SPEED = 50;
        this.POSITION_UPDATE_MULTIPLIER = 1;
        this.DEFAULT_TERRAIN_SIZE = 768 * 2;
        
        this.GRAVITY = 200;
        this.GROUND_LEVEL = 0;
        this.GROUND_IMPACT_THRESHOLD = 5;
        this.TERRAIN_FOLLOW_SPEED = 8;
        
        this.SEPARATION_FORCE = 80;
        this.SEPARATION_RADIUS_MULTIPLIER = 0.1;
        this.MAX_SEPARATION_CHECKS = 8;
        this.AVOIDANCE_SMOOTHING = 0.15;
        
        this.PATHFINDING_LOOKAHEAD = 100;
        this.OBSTACLE_AVOIDANCE_FORCE = 70;
        this.AVOIDANCE_ANGLE = Math.PI / 3;
        this.STUCK_THRESHOLD = 5;
        this.STUCK_TIME_LIMIT = 2000;
        this.REPATH_DISTANCE = 50;
        
        this.PATH_REACHED_DISTANCE = 3;
        this.PATH_REREQUEST_INTERVAL = 0.5;
        
        this.SPATIAL_GRID_SIZE = 80;
        this.MAX_PATHFINDING_CHECKS = 6;
        this.PATHFINDING_CHECK_POINTS = 3;
        this.PATHFINDING_UPDATE_INTERVAL = 3;
        this.NEAR_UNIT_RADIUS = 150;
        
        this.VELOCITY_SMOOTHING = 0.9;
        this.DIRECTION_SMOOTHING = 0.9;
        this.FORCE_DAMPING = 0.85;
        this.MIN_DIRECTION_CHANGE = 0.1;
        this.OSCILLATION_DETECTION_FRAMES = 5;
        this.OSCILLATION_THRESHOLD = Math.PI / 6;
        
        this.unitStates = new Map();
        this.frameCounter = 0;
        this.pathfindingQueue = [];
        this.pathfindingQueueIndex = 0;
        
        this.movementHistory = new Map();
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        this.frameCounter++;
        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.VELOCITY);        
        
        const unitData = new Map();
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            
            if (!projectile) {
                const unitRadius = this.getUnitRadius(collision);

                const isAnchored = vel.anchored ||
                    (!!aiState &&
                    (aiState.state === 'attacking' || aiState.state === 'waiting') &&
                    aiState.aiBehavior &&
                    !!aiState.target);

                unitData.set(entityId, {
                    pos, vel, unitType, collision, aiState, projectile,
                    unitRadius,
                    isAnchored,
                    desiredVelocity: { vx: 0, vy: 0, vz: 0 },
                    separationForce: { x: 0, y: 0, z: 0 },
                    avoidanceForce: { x: 0, y: 0, z: 0 }
                });
                
                this.updateUnitState(entityId, pos, vel);
                this.updateMovementHistory(entityId, vel);
            }
        });
        
        const sortedEntityIds = Array.from(unitData.keys());

        sortedEntityIds.forEach((entityId) => {
            this.calculateDesiredVelocity(entityId, unitData.get(entityId));
        });
        
        sortedEntityIds.forEach((entityId) => {
            this.calculateSeparationForceOptimized(entityId, unitData.get(entityId));
        });
        
        this.updatePathfindingStaggered(unitData);
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            const isAffectedByGravity = vel.affectedByGravity;
            
            if (!projectile && unitData.has(entityId)) {
                let entityData = unitData.get(entityId);
                if(vel.vx != 0 || vel.vz != 0 || entityData.desiredVelocity.vx != 0 || entityData.desiredVelocity.vz != 0){
                    this.applyUnitMovementWithSmoothing(entityId, unitData.get(entityId));
                }
            }
            
            if (isAffectedByGravity) {
                vel.vy -= this.GRAVITY * this.game.state.deltaTime;
            }
            
            pos.x += vel.vx * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.y += vel.vy * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.z += vel.vz * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
      
            if(!projectile){
                this.handleGroundInteraction(pos, vel);
                if(!vel.anchored){
                    this.enforceBoundaries(pos, collision);
                }
                 
                this.game.triggerEvent("onEntityPositionUpdated", entityId);
            }
        });
    }
    
    updateMovementHistory(entityId, vel) {
        if (!this.movementHistory.has(entityId)) {
            this.movementHistory.set(entityId, {
                velocityHistory: [],
                smoothedDirection: { x: 0, z: 0 },
                dampedForces: { separation: { x: 0, z: 0 }, avoidance: { x: 0, z: 0 } }
            });
        }
        
        const history = this.movementHistory.get(entityId);
        
        history.velocityHistory.push({ 
            vx: vel.vx, 
            vz: vel.vz, 
            frame: this.frameCounter 
        });
        
        if (history.velocityHistory.length > this.OSCILLATION_DETECTION_FRAMES) {
            history.velocityHistory.shift();
        }
    }
    
    isUnitOscillating(entityId) {
        const history = this.movementHistory.get(entityId);
        if (!history || history.velocityHistory.length < this.OSCILLATION_DETECTION_FRAMES) {
            return false;
        }
        
        let directionChanges = 0;
        let lastDirection = null;
        
        for (const vel of history.velocityHistory) {
            const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
            if (speed < 0.1) continue;
            
            const direction = Math.atan2(vel.vz, vel.vx);
            if (lastDirection !== null) {
                let angleDiff = Math.abs(direction - lastDirection);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                if (angleDiff > this.OSCILLATION_THRESHOLD) {
                    directionChanges++;
                }
            }
            lastDirection = direction;
        }
        
        return directionChanges >= 2;
    }
    
    updatePathfindingStaggered(unitData) {
        if (this.pathfindingQueue.length === 0) {
            const sortedEntityIds = Array.from(unitData.keys()).sort((a, b) => String(a).localeCompare(String(b)));
            sortedEntityIds.forEach(entityId => {
                const data = unitData.get(entityId);
                if (data.aiState?.state === 'chasing') {
                    this.pathfindingQueue.push(entityId);
                }
            });
        }
        
        const unitsPerFrame = Math.max(1, Math.ceil(this.pathfindingQueue.length / this.PATHFINDING_UPDATE_INTERVAL));
        
        for (let i = 0; i < unitsPerFrame && this.pathfindingQueueIndex < this.pathfindingQueue.length; i++) {
            const entityId = this.pathfindingQueue[this.pathfindingQueueIndex];
            if (unitData.has(entityId)) {
                this.calculatePathfindingAvoidanceOptimized(entityId, unitData.get(entityId), unitData);
            }
            this.pathfindingQueueIndex++;
        }
        
        if (this.pathfindingQueueIndex >= this.pathfindingQueue.length) {
            this.pathfindingQueueIndex = 0;
            this.pathfindingQueue = [];
        }
    }
    
    updateUnitState(entityId, pos, vel) {
        const currentTime = this.game.state.now;
        
        if (!this.unitStates.has(entityId)) {
            this.unitStates.set(entityId, {
                lastPosition: { x: pos.x, z: pos.z },
                lastMovementTime: currentTime,
                stuckTime: 0,
                lastPathTime: 0,
                avoidanceDirection: 0
            });
            return;
        }
        
        const state = this.unitStates.get(entityId);
        const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        const distanceMoved = Math.sqrt(
            Math.pow(pos.x - state.lastPosition.x, 2) + 
            Math.pow(pos.z - state.lastPosition.z, 2)
        );
        
        if (speed < this.STUCK_THRESHOLD && distanceMoved < 1) {
            state.stuckTime += this.game.state.deltaTime;
        } else {
            state.stuckTime = 0;
            state.lastPosition.x = pos.x;
            state.lastPosition.z = pos.z;
        }
        
        if (distanceMoved > this.REPATH_DISTANCE) {
            state.avoidanceDirection = 0;
            state.lastPathTime = currentTime;
        }
    }
    
    calculateSeparationForceOptimized(entityId, data) {
        const { pos, unitRadius, isAnchored } = data;

        if (isAnchored) {
            data.separationForce.x = 0;
            data.separationForce.y = 0;
            data.separationForce.z = 0;
            return;
        }
        
        const separationRadius = unitRadius * this.SEPARATION_RADIUS_MULTIPLIER;
        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, separationRadius, entityId);
        
        let separationForceX = 0;
        let separationForceZ = 0;
        let neighborCount = 0;
        let checksPerformed = 0;
        
        for (const otherEntityId of nearbyUnits) {
            if (checksPerformed >= this.MAX_SEPARATION_CHECKS) break;
            
            checksPerformed++;
            
            const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
            const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
            
            if (!otherPos) continue;
            
            const otherRadius = this.getUnitRadius(otherCollision);
            
            const dx = pos.x - otherPos.x;
            const dz = pos.z - otherPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            const minDistance = unitRadius + otherRadius;
            const influenceDistance = Math.max(minDistance, separationRadius);
            
            if (distance < influenceDistance && distance > 0.1) {
                const force = this.SEPARATION_FORCE * (influenceDistance - distance) / influenceDistance;
                
                const dirX = dx / distance;
                const dirZ = dz / distance;
                
                separationForceX += dirX * force;
                separationForceZ += dirZ * force;
                neighborCount++;
            }
        }
        
        if (neighborCount > 0) {
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedSeparation = history.dampedForces.separation;
                dampedSeparation.x *= this.FORCE_DAMPING;
                dampedSeparation.z *= this.FORCE_DAMPING;
                
                separationForceX = (separationForceX / neighborCount) * 0.7 + dampedSeparation.x * 0.3;
                separationForceZ = (separationForceZ / neighborCount) * 0.7 + dampedSeparation.z * 0.3;
                
                dampedSeparation.x = separationForceX;
                dampedSeparation.z = separationForceZ;
            } else {
                separationForceX /= neighborCount;
                separationForceZ /= neighborCount;
            }
        }
        
        data.separationForce.x = separationForceX;
        data.separationForce.z = separationForceZ;
    }
    
    calculatePathfindingAvoidanceOptimized(entityId, data, allUnitData) {
        const { pos, vel, aiState, unitRadius, isAnchored } = data;

        if (isAnchored || !aiState || aiState.state !== 'chasing') {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        let targetPos = aiState.targetPosition;
        const targetEntityId = aiState.target;

        if(targetEntityId){
            targetPos = this.game.getComponent(targetEntityId, this.componentTypes.POSITION);
        }
        
        if (!targetPos) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        const desiredDirection = {
            x: targetPos.x - pos.x,
            z: targetPos.z - pos.z
        };
        
        const desiredDistance = Math.sqrt(desiredDirection.x * desiredDirection.x + desiredDirection.z * desiredDirection.z);
        
        if (desiredDistance < 0.1) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        desiredDirection.x /= desiredDistance;
        desiredDirection.z /= desiredDistance;
        
        const obstacleInfo = this.findObstaclesInPathOptimized(pos, desiredDirection, unitRadius, entityId, targetEntityId);
        
        if (obstacleInfo.hasObstacle) {
            const unitState = this.unitStates.get(entityId);
            const avoidanceForce = this.calculateAvoidanceVector(
                pos, desiredDirection, obstacleInfo, unitState, unitRadius
            );
            
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedAvoidance = history.dampedForces.avoidance;
                dampedAvoidance.x *= this.FORCE_DAMPING;
                dampedAvoidance.z *= this.FORCE_DAMPING;
                
                const blendedX = avoidanceForce.x * 0.6 + dampedAvoidance.x * 0.4;
                const blendedZ = avoidanceForce.z * 0.6 + dampedAvoidance.z * 0.4;
                
                dampedAvoidance.x = blendedX;
                dampedAvoidance.z = blendedZ;
                
                data.avoidanceForce.x = blendedX;
                data.avoidanceForce.z = blendedZ;
            } else {
                data.avoidanceForce.x = avoidanceForce.x;
                data.avoidanceForce.z = avoidanceForce.z;
            }
        } else {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
        }
    }
    
    findObstaclesInPathOptimized(pos, direction, unitRadius, entityId, targetEntityId = null) {
        const lookaheadDistance = this.PATHFINDING_LOOKAHEAD;
        const checkRadius = unitRadius * 1.5;
        
        const nearbyUnits = this.game.gameManager.call('getNearbyUnits', pos, lookaheadDistance + checkRadius, entityId);
        
        let closestObstacle = null;
        let closestDistance = Infinity;
        let checksPerformed = 0;
        
        for (let i = 1; i <= this.PATHFINDING_CHECK_POINTS; i++) {
            const checkDistance = (lookaheadDistance / this.PATHFINDING_CHECK_POINTS) * i;
            const checkPos = {
                x: pos.x + direction.x * checkDistance,
                z: pos.z + direction.z * checkDistance
            };
            
            for (const otherEntityId of nearbyUnits) {
                if (targetEntityId && otherEntityId === targetEntityId) continue;
                if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
                
                checksPerformed++;
                
                const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
                const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
                
                if (!otherPos) continue;
                
                const otherRadius = this.getUnitRadius(otherCollision);
                
                const dx = checkPos.x - otherPos.x;
                const dz = checkPos.z - otherPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = checkRadius + otherRadius;
                
                if (distance < minDistance && distance < closestDistance) {
                    closestDistance = distance;
                    closestObstacle = {
                        pos: otherPos,
                        radius: otherRadius,
                        distance: distance,
                        entityId: otherEntityId
                    };
                }
            }
            
            if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
        }
        
        return {
            hasObstacle: closestObstacle !== null,
            obstacle: closestObstacle
        };
    }
    
    calculateAvoidanceVector(pos, desiredDirection, obstacleInfo, unitState, unitRadius) {
        if (!obstacleInfo.hasObstacle) {
            return { x: 0, z: 0 };
        }
        
        const obstacle = obstacleInfo.obstacle;
        const toObstacle = {
            x: obstacle.pos.x - pos.x,
            z: obstacle.pos.z - pos.z
        };
        
        const obstacleDistance = Math.sqrt(toObstacle.x * toObstacle.x + toObstacle.z * toObstacle.z);
        
        if (obstacleDistance < 0.1) {
            return { x: 0, z: 0 };
        }
        
        toObstacle.x /= obstacleDistance;
        toObstacle.z /= obstacleDistance;
        
        let avoidanceDirection = unitState?.avoidanceDirection || 0;
        
        if (avoidanceDirection === 0) {
            const perpLeft = { x: -toObstacle.z, z: toObstacle.x };
            const perpRight = { x: toObstacle.z, z: -toObstacle.x };
            
            const leftAlignment = perpLeft.x * desiredDirection.x + perpLeft.z * desiredDirection.z;
            const rightAlignment = perpRight.x * desiredDirection.x + perpRight.z * desiredDirection.z;
            
            avoidanceDirection = leftAlignment > rightAlignment ? 1 : -1;
            
            if (unitState) {
                unitState.avoidanceDirection = avoidanceDirection;
            }
        }
        
        const avoidanceVector = {
            x: -toObstacle.z * avoidanceDirection,
            z: toObstacle.x * avoidanceDirection
        };
        
        const minDistance = unitRadius + obstacle.radius + 10;
        const avoidanceStrength = Math.max(0, (minDistance - obstacleDistance) / minDistance);
        const force = this.OBSTACLE_AVOIDANCE_FORCE * avoidanceStrength;
        
        return {
            x: avoidanceVector.x * force,
            z: avoidanceVector.z * force
        };
    }
    
    calculateDesiredVelocity(entityId, data) {
        const { pos, vel, aiState, isAnchored } = data;

        if (isAnchored || !aiState) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'waiting' || aiState.state === 'idle') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'chasing' && aiState.aiBehavior && (aiState.targetPosition || aiState.target)) {
            // Check if we should use direct movement (line of sight to target)
            if (aiState.useDirectMovement) {
                // Move directly toward target using steering behaviors
                this.moveDirectlyToTarget(entityId, data);
            } else {
                // Use pathfinding for navigation
                this.requestPathIfNeeded(entityId, data);

                if (aiState.path && aiState.path.length > 0) {
                    this.followPath(entityId, data);
                } else {
                    data.desiredVelocity.vx = 0;
                    data.desiredVelocity.vy = 0;
                    data.desiredVelocity.vz = 0;
                }
            }
        } else if (aiState.state === 'attacking') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        } else {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        }
    }
    
    moveDirectlyToTarget(entityId, data) {
        const { pos, vel, aiState } = data;

        let targetPos = aiState.targetPosition;
        if (aiState.target) {
            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
            if (currentTargetPos) {
                targetPos = currentTargetPos;
            }
        }

        if (!targetPos) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }

        const dx = targetPos.x - pos.x;
        const dz = targetPos.z - pos.z;
        const distToTarget = Math.sqrt(dx * dx + dz * dz);

        if (distToTarget < 0.1) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }

        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);
        data.desiredVelocity.vx = (dx / distToTarget) * moveSpeed;
        data.desiredVelocity.vz = (dz / distToTarget) * moveSpeed;
        data.desiredVelocity.vy = 0;
    }

    requestPathIfNeeded(entityId, data) {
        const { pos, aiState } = data;
        const now = this.game.state.now;
        if(!aiState.aiBehavior){
            aiState.aiBehavior = {};
        }
        if (!aiState.aiBehavior.lastPathRequest || (now - aiState.aiBehavior.lastPathRequest) > this.PATH_REREQUEST_INTERVAL) {
            aiState.aiBehavior.lastPathRequest = now;

            let targetPos = aiState.targetPosition;
            if (aiState.target) {
                targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
            }

            if ((!aiState.path || aiState.path.length == 0) && targetPos) {
                aiState.path = this.game.gameManager.call('requestPath',
                    entityId,
                    pos.x,
                    pos.z,
                    targetPos.x,
                    targetPos.z,
                    1
                );
            }
        }
    }
    
    followPath(entityId, data) {
        const { pos, vel, aiState } = data;
        
        if (aiState.pathIndex === undefined) {
            aiState.pathIndex = 0;
        }
        
        if (aiState.pathIndex >= aiState.path.length) {
            aiState.path = null;
            aiState.pathIndex = 0;
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }
        const waypoint = aiState.path[aiState.pathIndex];
        const dx = waypoint.x - pos.x;
        const dz = waypoint.z - pos.z;
        const distToWaypoint = Math.sqrt(dx * dx + dz * dz);
        
        if (distToWaypoint < this.PATH_REACHED_DISTANCE) {
            aiState.pathIndex++;
            if (aiState.pathIndex >= aiState.path.length) {
                aiState.path = null;
                aiState.pathIndex = 0;
            }
            return;
        }
        
        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);
        data.desiredVelocity.vx = (dx / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vz = (dz / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vy = 0;
    }
    
    applyUnitMovementWithSmoothing(entityId, data) {
        const { vel, desiredVelocity, separationForce, avoidanceForce, isAnchored } = data;

        if (isAnchored) {
            vel.vx = 0;
            vel.vz = 0;
            vel.vy = desiredVelocity.vy || vel.vy || 0;
            return;
        }
        
        const history = this.movementHistory.get(entityId);
        const isOscillating = this.isUnitOscillating(entityId);
        
        let targetVx = desiredVelocity.vx + separationForce.x + avoidanceForce.x;
        let targetVz = desiredVelocity.vz + separationForce.z + avoidanceForce.z;
        
        if (isOscillating) {
            targetVx = desiredVelocity.vx + (separationForce.x + avoidanceForce.x) * 0.3;
            targetVz = desiredVelocity.vz + (separationForce.z + avoidanceForce.z) * 0.3;
        }
        
        const velocitySmoothing = isOscillating ? this.VELOCITY_SMOOTHING * 0.5 : this.VELOCITY_SMOOTHING;
        const directionSmoothing = isOscillating ? this.DIRECTION_SMOOTHING * 0.3 : this.DIRECTION_SMOOTHING;
        
        const newVx = this.lerp(vel.vx, targetVx, velocitySmoothing);
        const newVz = this.lerp(vel.vz, targetVz, velocitySmoothing);

        // Only apply direction smoothing if there's actual desired movement
        // If targetVx and targetVz are both near zero, skip smoothing to preserve current facing
        const targetSpeedSqrd = targetVx * targetVx + targetVz * targetVz;
        const hasTargetMovement = targetSpeedSqrd > 0.01;

        if (history && history.smoothedDirection && hasTargetMovement) {
            const targetDirection = Math.atan2(targetVz, targetVx);

            let currentDirection;
            const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);

            if (currentSpeed < this.MIN_MOVEMENT_THRESHOLD) {
                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                currentDirection = facing ? facing.angle : 0;
            } else {
                currentDirection = Math.atan2(vel.vz, vel.vx);
            }

            let directionDiff = targetDirection - currentDirection;
            if (directionDiff > Math.PI) directionDiff -= 2 * Math.PI;
            if (directionDiff < -Math.PI) directionDiff += 2 * Math.PI;

            if (Math.abs(directionDiff) > this.MIN_DIRECTION_CHANGE) {
                const smoothedDirection = currentDirection + directionDiff * directionSmoothing;
                const speed = Math.sqrt(newVx * newVx + newVz * newVz);

                if (speed > 0.1) {
                    vel.vx = Math.cos(smoothedDirection) * speed;
                    vel.vz = Math.sin(smoothedDirection) * speed;

                    const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                    if (facing) {
                        facing.angle = smoothedDirection;
                    }
                } else {
                    vel.vx = newVx;
                    vel.vz = newVz;
                }
            } else {
                vel.vx = newVx;
                vel.vz = newVz;
            }
        } else {
            vel.vx = newVx;
            vel.vz = newVz;
        }
        
        vel.vy = desiredVelocity.vy;

        const speedSqrd = vel.vx * vel.vx + vel.vz * vel.vz;
        if (speedSqrd < this.MIN_MOVEMENT_THRESHOLD * this.MIN_MOVEMENT_THRESHOLD) {
            // Preserve facing direction before zeroing velocity
            if (speedSqrd > 0.001) {
                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                if (facing) {
                    facing.angle = Math.atan2(vel.vz, vel.vx);
                }
            }
            vel.vx = 0;
            vel.vz = 0;
        }
        
        const maxSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED) * 1.4;
        const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        if (currentSpeed > maxSpeed) {
            const speedRatio = maxSpeed / currentSpeed;
            vel.vx *= speedRatio;
            vel.vz *= speedRatio;
        }
    }
    
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    shouldApplyGravity(entityId, projectile, unitType) {
        if (projectile) {
            return true;
        }
        
        if (unitType) {
            const collections = this.game.getCollections && this.game.getCollections();
            if (collections && collections.units) {
                const unitDef = collections.units[unitType.id];
                if (unitDef && unitDef.flying) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    handleGroundInteraction(pos, vel) {
        const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z);
        
        if (terrainHeight !== null) {
            const targetHeight = terrainHeight;   
            pos.y = targetHeight;
            
            if (pos.y <= targetHeight + 0.1) {
                vel.vy = Math.max(0, vel.vy);
            }
        } else {
            if (pos.y < this.GROUND_LEVEL) {
                pos.y = this.GROUND_LEVEL;
                vel.vy = Math.max(0, vel.vy);
            }
        }
    }
    
    
    enforceBoundaries(pos, collision) {
        const collections = this.game.getCollections();
        const currentLevel = this.game.state.level;
        const level = collections.levels[currentLevel];        
        const tileMap = level.tileMap;

        const terrainSize = tileMap.size * collections.configs.game.gridSize;
        const halfTerrain = terrainSize / 2;
        const unitRadius = this.getUnitRadius(collision);
        

        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }
    
    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }
    
    entityDestroyed(entityId) {
        
        if (this.unitStates) {
            this.unitStates.delete(entityId);
        }
        
        if (this.movementTracking) {
            this.movementTracking.delete(entityId);
        }
        
        if (this.movementHistory) {
            this.movementHistory.delete(entityId);
        }
    }

    ping() {
        console.log('pong');
    }
};

// system: CombatAISystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CombatAISystem'] = class CombatAISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.combatAISystems = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.ATTACK_RANGE_BUFFER = 10;
        this.ALLY_SPACING_DISTANCE = 10;
        this.ENEMY_SPACING_DISTANCE = 5;
        this.AVOIDANCE_RADIUS_MULTIPLIER = 1;
        this.STRONG_AVOIDANCE_FORCE = 50;
        this.GENTLE_AVOIDANCE_FORCE = 10;

        this.TARGET_SWITCH_COOLDOWN = 0.3;
        this.MOVEMENT_DECISION_INTERVAL = 0.05;

        this.MIN_ATTACK_ANIMATION_TIME = 0.4;
        this.STATE_CHANGE_COOLDOWN = 0.1;

        this.DAMAGE_TIMING_RATIO = 0.5;

        // Use placement grid size (half of terrain grid) for position threshold
        this.TARGET_POSITION_THRESHOLD = this.game.getCollections().configs.game.gridSize / 2 * 0.5;
        // Debug logging
        this.DEBUG_ENEMY_DETECTION = true; // Set to false to disable debug

    }

    init() {
        this.game.gameManager.register('setRetaliatoryTarget', this.setRetaliatoryTarget.bind(this));
        this.game.gameManager.register('startDeathProcess', this.startDeathProcess.bind(this));
        this.game.gameManager.register('calculateAnimationSpeed', this.calculateAnimationSpeed.bind(this));
    }

    update() {
        const CT = this.componentTypes;
        if (this.game.state.phase !== 'battle'){
            const combatUnits = this.game.getEntitiesWith(
               CT.AI_STATE
            );
            for (let i = 0; i < combatUnits.length; i++) {
                const entityId = combatUnits[i];
                const aiState = this.game.getComponent(entityId, CT.AI_STATE);
                if (aiState.state !== 'idle') {
                    this.changeAIState(aiState, 'idle');
                }
                aiState.target = null;
            }
            return;
        }

        const combatUnits = this.game.getEntitiesWith(
            CT.POSITION, CT.COMBAT, CT.TEAM, CT.AI_STATE
        );
        for (let i = 0; i < combatUnits.length; i++) {
            const entityId = combatUnits[i];
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const team = this.game.getComponent(entityId, CT.TEAM);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const collision = this.game.getComponent(entityId, CT.COLLISION);
            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);

            if (!pos || !vel || !combat || !team || !aiState){
                 continue;
            }
            
            // DEBUG: Log combat range and position
            const preventEnemiesInRangeCheck = aiState.meta ? aiState.meta.preventEnemiesInRangeCheck : false; 
            if (!aiState.meta.initialized) {
                aiState.meta = {
                    lastDecisionTime: 0,
                    targetLockTime: 0,
                    lastStateChange: 0,
                    lastAttackStart: 0,
                    initialized: true
                };
            }
            const aiMeta = aiState.meta;

            const enemiesInVisionRange = preventEnemiesInRangeCheck ? [] : (this.getAllEnemiesInVision(entityId, pos, unitType, team, combat) || []);
            
            // DEBUG: Log enemies found
            if (aiState.target) {
                const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
                if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                    aiState.target = null;                                    
                    this.onLostTarget(entityId);  
                }
            }
            if(aiState.targetPosition){
                const distance = Math.sqrt(
                    Math.pow( aiState.targetPosition.x - pos.x, 2) + 
                    Math.pow( aiState.targetPosition.z - pos.z, 2)
                );
                aiState.targetDistance = distance;
            } else {
                aiState.targetDistance = 0;
            }
            if (enemiesInVisionRange.length === 0) {
                if(aiState.targetPosition){
                    if(aiState.targetDistance > this.TARGET_POSITION_THRESHOLD && !vel.anchored){
                        if(aiState.state !== 'chasing'){
                            this.changeAIState(aiState, 'chasing');
                        }
                    } else {
                        if (aiState.state !== 'idle') {
                            
                            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);
                            if(currentAI == "CombatAISystem"){
                                this.onLostTarget(entityId);
                            }
                            this.changeAIState(aiState, 'idle');
                        }
                    }
                }   
            }

            if (aiMeta.nextMoveTime == null) aiMeta.nextMoveTime = 0;
    
            if (aiState.state !== 'waiting') {
                aiMeta.nextMoveTime = this.game.state.now + this.MOVEMENT_DECISION_INTERVAL;
                this.makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision);
                aiMeta.lastDecisionTime = this.game.state.now;
            }

            this.handleCombat(entityId, pos, combat, aiState, collision);
        }
    }

    getAllEnemiesInVision(entityId, pos, unitType, team, combat) {
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const visionRange = combat.visionRange;
        
        return allUnits.filter(otherId => {
            if (otherId === entityId) return false;
            
            const otherTeam = this.game.getComponent(otherId, this.componentTypes.TEAM);
            const otherHealth = this.game.getComponent(otherId, this.componentTypes.HEALTH);
            const otherDeathState = this.game.getComponent(otherId, this.componentTypes.DEATH_STATE);
            const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
            
            if (!otherTeam || otherTeam.team === team.team) return false;
            if (!otherHealth || otherHealth.current <= 0) return false;
            if (otherDeathState && otherDeathState.isDying) return false;
            if (!otherPos) return false;
            
            return this.isInVisionRange(entityId, otherId, visionRange) && this.game.gameManager.call('hasLineOfSight', pos, otherPos, unitType, entityId);                   
        });
    }


    changeAIState(aiState, newState) {

        const aiMeta = aiState.meta;
        if (this.game.state.now - aiMeta.lastStateChange < this.STATE_CHANGE_COOLDOWN) return false;
        if (aiState.state === 'attacking') {
            const attackDuration = this.game.state.now - aiMeta.lastAttackStart;
            if (attackDuration < this.MIN_ATTACK_ANIMATION_TIME) return false;
        }
        if (aiState.state !== newState) {
            aiState.state = newState;
            aiMeta.lastStateChange = this.game.state.now;
            if (newState === 'attacking') aiMeta.lastAttackStart = this.game.state.now;
            return true;
        }
        return false;
    }

    makeAIDecision(entityId, pos, combat, team, aiState, enemiesInVisionRange, collision) {
        // CHANGED: Always try to find the best target from ALL enemies
        let targetEnemy = this.findBestTarget(entityId, pos, combat.range, enemiesInVisionRange, aiState);
        
        if (!targetEnemy) {
            aiState.target = null;
            this.onLostTarget(entityId);
            return;
        }
        
        const targetHealth = this.game.getComponent(targetEnemy, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetEnemy, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            return;
        }
        
        const enemyPos = this.game.getComponent(targetEnemy, this.componentTypes.POSITION);
        if (!enemyPos) return;

        let currentCombatAi = this.game.gameManager.call('getAIControllerData', entityId, "CombatAISystem");
        let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);

        // Set the target
        currentCombatAi.target = targetEnemy;
        aiState.target = targetEnemy;

        // Check if we have direct line of sight to the target
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const hasLOS = this.game.gameManager.call('hasLineOfSight', pos, enemyPos, unitType, entityId);
        const hasDirectPath = this.game.gameManager.call('hasDirectWalkablePath', pos, enemyPos, entityId);

        if (hasLOS && hasDirectPath) {
            // Can see AND walk directly - use steering only
            aiState.path = null;
            aiState.useDirectMovement = true;
        } 

        if(currentAI != "CombatAISystem"){
            // Check if we can interrupt current command with combat AI
            // Only take control if current command is interruptible or has lower priority
            const ComponentTypes = this.game.componentTypes;

            if (this.game.commandQueueSystem) {
                // Use command queue - combat has lower priority than player commands
                const canTakeControl = this.game.gameManager.call('canInterruptCommand', entityId, this.game.commandQueueSystem.PRIORITY.IDLE);

                if (canTakeControl || !aiState.meta?.preventEnemiesInRangeCheck) {
                    // Queue combat command with IDLE priority (won't interrupt player commands)
                    this.game.gameManager.call('queueCommand', entityId, {
                        type: 'combat',
                        controllerId: "CombatAISystem",
                        targetPosition: null,
                        target: targetEnemy,
                        meta: {},
                        priority: this.game.commandQueueSystem.PRIORITY.IDLE,
                        interruptible: true
                    }, false); // false = don't force interrupt
                }
            } else {
                // Fallback to old method - only switch if no preventEnemiesInRangeCheck
                if (!aiState.meta?.preventEnemiesInRangeCheck) {
                    this.game.gameManager.call('setCurrentAIController', entityId, "CombatAISystem", currentCombatAi);
                }
            }
        }
        if (this.isInAttackRange(entityId, targetEnemy, combat)) {
            // Check if this is a spell caster and if abilities are available
   
            this.changeAIState(aiState, 'attacking');
        } else {
            if(aiState.state !== 'chasing'){
                this.changeAIState(aiState, 'chasing');
            }
        }
    }

    findBestTarget(entityId, pos, range, enemiesInVisionRange, aiState) {
        const aiMeta = aiState.meta;
        let bestTarget = null;
        let bestScore = -Infinity;
        
        // If unit is currently attacking, stick with current target unless switching would be much better
        if (aiState.target && enemiesInVisionRange.includes(aiState.target)) {
            const currentTargetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
            const currentTargetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);

            const isCurrentTargetValid = currentTargetHealth && 
                                       currentTargetHealth.current > 0 && 
                                       (!currentTargetDeathState || !currentTargetDeathState.isDying) &&
                                       currentTargetPos;
            
            if (isCurrentTargetValid) {
                // Calculate current target score
                const currentDistance = Math.sqrt(
                    Math.pow(currentTargetPos.x - pos.x, 2) + 
                    Math.pow(currentTargetPos.z - pos.z, 2)
                );
                const currentHealthRatio = currentTargetHealth.current / (currentTargetHealth.max || currentTargetHealth.current);
                const currentScore = this.calculateTargetScore(currentDistance, currentHealthRatio, true);
                
                // Only switch if we find a significantly better target
                bestScore = currentScore * 1.2; // 20% bonus for current target (sticky targeting)
                bestTarget = aiState.target;
            }
        }
        
        // Evaluate all enemies to find the best target
        enemiesInVisionRange.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            const enemyDeathState = this.game.getComponent(enemyId, this.componentTypes.DEATH_STATE);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            if (enemyDeathState && enemyDeathState.isDying) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - pos.x, 2) + 
                Math.pow(enemyPos.z - pos.z, 2)
            );

            const healthRatio = enemyHealth.current / (enemyHealth.max || enemyHealth.current);
            const isCurrentTarget = (enemyId === aiState.target);
            
            const score = this.calculateTargetScore(distance, healthRatio, isCurrentTarget);
            
            if (score > bestScore) {
                bestScore = score;
                bestTarget = enemyId;
            }
            
        });
        
        if (bestTarget !== aiState.target) {
            aiMeta.targetLockTime = this.game.state.now;
        }
        
        return bestTarget;
    }

    calculateTargetScore(distance, healthRatio, isCurrentTarget) {
        let score = 0;
        
        // Distance factor - closer is better, but not overwhelmingly so
        // Use logarithmic scaling so very far enemies are still viable
        const maxDistance = 20000; // Assume max battlefield size
        const distanceFactor = Math.max(0, (maxDistance - distance) / maxDistance);
        score += distanceFactor * 100;    

        
        // Current target bonus for stability
        if (isCurrentTarget) {
            score += 50000;
        }
        
        
        return score;
    }

    onLostTarget(entityId) {
        let aiState = this.game.getComponent(entityId, this.game.componentTypes.AI_STATE);
        aiState.useDirectMovement = false;
        let currentCombatAI = this.game.gameManager.call('getAIControllerData', entityId, "CombatAISystem");
        currentCombatAI.target = null;
        if(this.game.gameManager.call('hasAIControllerData', entityId, "UnitOrderSystem")){
            let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, "UnitOrderSystem");
            let currentAI = this.game.gameManager.call('getCurrentAIControllerId', entityId);
            if(currentAI == "CombatAISystem"){
                this.game.gameManager.call('setCurrentAIController', entityId, "UnitOrderSystem", currentOrderAI);
            }
        }
    }

    handleCombat(entityId, pos, combat, aiState, collision) {
        const aiMeta = aiState.meta;
        if (!aiState.target || aiState.state !== 'attacking'){
           // console.log('no target or not attacking', aiState); 
            return;
        }
        
        const targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
        const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
        
        if (!targetPos || !targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            this.onLostTarget(entityId);       
            return;
        }
        
        if (!this.isInAttackRange(entityId, aiState.target, combat, 5)) {
            this.changeAIState(aiState, 'chasing');
            console.log('not in attack range');
            return;
        }
        
        // Handle melee units with damage > 0
        if (combat.damage > 0) {
            const effectiveAttackSpeed = this.getEffectiveAttackSpeed(entityId, combat.attackSpeed);
            if ((this.game.state.now - combat.lastAttack) >= 1 / effectiveAttackSpeed) {
                this.initiateAttack(entityId, aiState.target, combat);
                combat.lastAttack = this.game.state.now;
                aiMeta.lastAttackStart = this.game.state.now;
            }
        }           
    }

    log(){
        if(arguments[0].indexOf("barbarian") >= 0){
            console.log(...arguments)
        }
    }
    
    initiateAttack(attackerId, targetId, combat) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) return;

        // Make the attacker face the target
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const facing = this.game.getComponent(attackerId, this.componentTypes.FACING);

        if (attackerPos && targetPos && facing) {
            const dx = targetPos.x - attackerPos.x;
            const dz = targetPos.z - attackerPos.z;
            const angleToTarget = Math.atan2(dz, dx);
            facing.angle = angleToTarget;
        }

        if(this.game.gameManager.has('triggerSinglePlayAnimation')){
            const animationSpeed = this.calculateAnimationSpeed(attackerId, combat.attackSpeed);
            const minAnimationTime = 1 / combat.attackSpeed * 0.8; // 80% of attack interval
            this.game.gameManager.call('triggerSinglePlayAnimation', attackerId, 'attack', animationSpeed, minAnimationTime);
        }

        if (combat.projectile) {
            this.scheduleProjectileLaunch(attackerId, targetId, combat);
        } else {
            this.scheduleMeleeDamage(attackerId, targetId, combat);
        }
    }

    calculateAnimationSpeed(attackerId, animationSpeed) {
        const attackInterval = 1 / animationSpeed;
        
        // Default fallback duration
        let baseAnimationDuration = 0.8;
        
        if (this.game.gameManager.has('getEntityAnimations')) {
            // NEW: Get duration from VAT bundle instead of mixer actions
            const CT = this.componentTypes;
            const renderable = this.game.getComponent(attackerId, CT.RENDERABLE);
            
            if (renderable) {
                const batchInfo = this.game.renderSystem?.getBatchInfo(
                    renderable.objectType, 
                    renderable.spawnType
                );
                
                if (batchInfo) {
                    const bundle = this.game.modelManager?.getVATBundle(
                        renderable.objectType, 
                        renderable.spawnType
                    );
                    
                    if (bundle?.meta?.clips) {
                        // Find attack clip duration
                        const attackClip = bundle.meta.clips.find(clip => 
                            clip.name === 'attack' || clip.name === 'combat' || clip.name === 'fight'
                        );
                        if (attackClip) {
                            baseAnimationDuration = attackClip.duration;
                        }
                    }
                }
            }
            
            // OLD SYSTEM COMPATIBILITY (remove this once VAT is working):
            // Keep this as fallback in case you need it temporarily
            const entityAnimations = this.game.gameManager.call('getEntityAnimations');
            if (entityAnimations) {
                const animationActions = entityAnimations.get(attackerId);
                if (animationActions && animationActions.attack) {
                    const attackAction = animationActions.attack;
                    if (attackAction.getClip) {
                        baseAnimationDuration = attackAction.getClip().duration;
                    }
                }
            }
        }
        
        // Calculate speed to fit animation into attack interval
        const targetAnimationDuration = Math.max(attackInterval * 0.9, 0.2);
        let resultSpeed = baseAnimationDuration / targetAnimationDuration;
        
        return resultSpeed;
    }

    scheduleMeleeDamage(attackerId, targetId, combat) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot schedule melee damage');
            return;
        }

        const attackInterval = 1 / combat.attackSpeed;
        const damageDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
    
        const element = this.getDamageElement(attackerId, combat);
        
        this.game.gameManager.call('scheduleDamage',
            attackerId,
            targetId,
            combat.damage,
            element,
            damageDelay,
            {
                isMelee: true,
                weaponRange: combat.range + this.ATTACK_RANGE_BUFFER + 1
            }
        );
    }

    scheduleProjectileLaunch(attackerId, targetId, combat) {
        const attackInterval = 1 / combat.attackSpeed;
        const launchDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
        
        // Clean generic scheduling
        this.game.gameManager.call('scheduleAction', () => {
            this.fireProjectileAttack(attackerId, targetId, combat.projectile);
        }, launchDelay, attackerId);
    }

    fireProjectileAttack(attackerId, targetId, projectileTypeId) {
        if (!this.game.projectileSystem) return;
        const projectileData = this.game.getCollections().projectiles[projectileTypeId];
        if (!projectileData) return;
        this.game.gameManager.call('fireProjectile', attackerId, targetId, {
            id: projectileTypeId,
            ...projectileData
        });
    }

    getDamageElement(entityId, combat) {
        if (combat.element) {
            return combat.element;
        }
        
        const weaponElement = this.getWeaponElement(entityId);
        if (weaponElement) {
            return weaponElement;
        }
        
        return this.game.damageSystem?.ELEMENT_TYPES?.PHYSICAL || 'physical';
    }

    getWeaponElement(entityId) {
        if (!this.game.equipmentSystem) return null;
        
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (!equipment) return null;
        
        const mainHandItem = equipment.slots.mainHand;
        if (mainHandItem) {
            const itemData = this.game.gameManager.call('getItemData', mainHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }

        const offHandItem = equipment.slots.offHand;
        if (offHandItem) {
            const itemData = this.game.gameManager.call('getItemData', offHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }
        
        return null;
    }

    calculateDistances(pos1, pos2, collision1, collision2) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos1.z;
        const centerToCenterDistance = Math.sqrt(dx * dx + dz * dz);
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        const edgeToEdgeDistance = Math.max(0, centerToCenterDistance - radius1 - radius2);
        const distanceToTargetEdge = Math.max(0, centerToCenterDistance - radius2);
        return {
            centerToCenter: centerToCenterDistance,
            edgeToEdge: edgeToEdgeDistance,
            attackerCenterToTargetEdge: distanceToTargetEdge,
            attackerRadius: radius1,
            targetRadius: radius2
        };
    }

    isInAttackRange(attackerId, targetId, combat, extraBuffer = 0) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;

        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        const effectiveRange = combat.range + this.ATTACK_RANGE_BUFFER + extraBuffer;
        return distances.attackerCenterToTargetEdge <= effectiveRange;
    }

    isInVisionRange(viewerId, targetId, visionRange) {
        const viewerPos = this.game.getComponent(viewerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const viewerCollision = this.game.getComponent(viewerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!viewerPos || !targetPos) return false;

        const distances = this.calculateDistances(viewerPos, targetPos, viewerCollision, targetCollision);
        return distances.attackerCenterToTargetEdge <= visionRange;
    }

    isWithinEdgeToEdgeRange(attackerId, targetId, maxRange) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;
        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        return distances.edgeToEdge <= maxRange;
    }

    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }

    startDeathProcess(entityId) {

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const existingDeathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
        if (existingDeathState && existingDeathState.isDying) return;
        
        if (this.game.damageSystem) {
            this.game.gameManager.call('clearAllStatusEffects', entityId);
        }
        
        this.game.addComponent(entityId, ComponentTypes.DEATH_STATE, Components.DeathState(true, this.game.state.now, 2.0));
        if (this.game.hasComponent(entityId, ComponentTypes.AI_STATE)) {
            this.game.removeComponent(entityId, ComponentTypes.AI_STATE);
        }
        const velocity = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        if (velocity) { velocity.x = 0; velocity.y = 0; velocity.z = 0; }
        
        if (this.game.hasComponent(entityId, ComponentTypes.COMBAT)) {
            this.game.removeComponent(entityId, ComponentTypes.COMBAT);
        }
        
        if (this.game.animationSystem) {
            this.game.gameManager.call('playDeathAnimation', entityId);
        }
        if(this.game.abilitySystem){
            this.game.gameManager.call('removeEntityAbilities', entityId);
        }
    }
    
    applyDamage(sourceId, targetId, damage, element, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply damage');
            return { damage: 0, prevented: true, reason: 'no_damage_system' };
        }
                
        return this.game.gameManager.call('applyDamage', sourceId, targetId, damage, element, options);
    }

    applySplashDamage(sourceId, centerPos, damage, element, radius, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply splash damage');
            return [];
        }
        
        return this.game.gameManager.call('applySplashDamage', sourceId, centerPos, damage, element, radius, options);
    }

    curePoison(targetId, stacksToRemove = null) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot cure poison');
            return false;
        }

        return this.game.gameManager.call('curePoison', targetId, stacksToRemove);
    }

    getPoisonStacks(entityId) {
        if (!this.game.damageSystem) {
            return 0;
        }

        return this.game.gameManager.call('getPoisonStacks', entityId);
    }

    getEffectiveAttackSpeed(entityId, baseAttackSpeed) {
        const attackerMods = this.game.gameManager.call('getAttackerModifiers', entityId);
        return baseAttackSpeed * (attackerMods.attackSpeedMultiplier || 1.0);
    }

    getStatusEffects(entityId) {
        if (!this.game.damageSystem) {
            return { poison: [] };
        }

        return this.game.gameManager.call('getStatusEffects', entityId);
    }

    setRetaliatoryTarget(entityId, attackerId) {
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (!aiState) return;
        
        if (aiState.target) return;
        
        const attackerHealth = this.game.getComponent(attackerId, this.componentTypes.HEALTH);
        const attackerDeathState = this.game.getComponent(attackerId, this.componentTypes.DEATH_STATE);
        if (!attackerHealth || attackerHealth.current <= 0) return;
        if (attackerDeathState && attackerDeathState.isDying) return;
        
        const attackerTeam = this.game.getComponent(attackerId, this.componentTypes.TEAM);
        const defenderTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        if (attackerTeam && defenderTeam && attackerTeam.team === defenderTeam.team) return;
        
        aiState.target = attackerId;
    }

    debugStatusEffects() {
        if (!this.game.damageSystem) {
            return;
        }

        this.game.gameManager.call('debugStatusEffects');
    }
};

// system: ProjectileSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ProjectileSystem'] = class ProjectileSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.projectileSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        // Configuration
        this.HIT_DETECTION_RADIUS = 24;
        this.TRAIL_UPDATE_INTERVAL = 0.05;
        
        // Ballistic configuration
        this.DEFAULT_LAUNCH_ANGLE = Math.PI / 4; // 45 degrees
        this.MIN_LAUNCH_ANGLE = Math.PI / 6; // 30 degrees
        this.MAX_LAUNCH_ANGLE = Math.PI / 3; // 60 degrees
        this.BALLISTIC_HEIGHT_MULTIPLIER = 0.3; // How high the arc goes relative to distance
        this.PROJECTILE_LIFETIME = 200;
        
        // Ground impact detection
        this.GROUND_IMPACT_THRESHOLD = 0; // Distance from ground to trigger impact
        
        // Trail tracking for visual effects
        this.projectileTrails = new Map();
        
        // Get gravity from movement system
        this.GRAVITY = this.game.movementSystem?.GRAVITY;
    }
    
    // Deterministic rounding helper
    roundForDeterminism(value, precision = 6) {
        return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);
    }

    init() {
        this.game.gameManager.register('deleteProjectileTrail', this.deleteProjectileTrail.bind(this));
        this.game.gameManager.register('fireProjectile', this.fireProjectile.bind(this));
    }

    deleteProjectileTrail(entityId) {
        if (this.projectileTrails) {
            this.projectileTrails.delete(entityId);
        }
    }

    fireProjectile(sourceId, targetId, projectileData = {}) {
        const sourcePos = this.game.getComponent(sourceId, this.componentTypes.POSITION);
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!sourcePos || !sourceCombat || !targetPos) return null;
        
        // Create projectile entity
        const projectileId = this.game.createEntity();
        const components = this.game.componentManager.getComponents();
        
        // Determine projectile element (from weapon, combat component, or projectile data)
        const projectileElement = this.determineProjectileElement(sourceId, projectileData);
        
        // Pass source ID to trajectory calculation for ballistic projectiles
        const projectileDataWithSource = { ...projectileData, sourceId: sourceId };
        
        // Calculate trajectory based on projectile type
        const trajectory = this.calculateTrajectory(sourcePos, targetPos, projectileDataWithSource);
        
        // Determine spawn height - ballistic projectiles start above ground to avoid immediate impact
        const spawnHeight = Math.max(sourcePos.y + 20, 20);           
        
        // Add components with full 3D support
        this.game.addComponent(projectileId, this.componentTypes.POSITION, 
            components.Position(sourcePos.x, spawnHeight, sourcePos.z));
        
        this.game.addComponent(projectileId, this.componentTypes.VELOCITY, 
            components.Velocity(trajectory.vx, trajectory.vy, trajectory.vz, projectileData.speed, projectileData.ballistic || false));
        
         // Enhanced projectile component with element
        this.game.addComponent(projectileId, this.componentTypes.PROJECTILE, {
            damage: sourceCombat.damage,
            speed: projectileData.speed,
            range: sourceCombat.range * 1.5,
            target: targetId,
            source: sourceId,
            startTime: this.game.state.now,
            startX: sourcePos.x,
            startY: spawnHeight,
            startZ: sourcePos.z,
            isBallistic: projectileData.ballistic || false,
            targetX: targetPos.x,
            targetY: targetPos.y + 20,
            targetZ: targetPos.z,
            launchAngle: trajectory.launchAngle,
            timeToTarget: trajectory.timeToTarget,
            weaponRange: trajectory.weaponRange || sourceCombat.range,
            element: projectileElement
        });

        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        // Add UNIT_TYPE component for projectiles
        this.game.addComponent(projectileId, this.componentTypes.UNIT_TYPE, 
            components.UnitType(projectileData.id, projectileData.title, 0));
        
        // Add TEAM component (same team as source)
        if (sourceTeam) {
            this.game.addComponent(projectileId, this.componentTypes.TEAM, 
                components.Team(sourceTeam.team));
        }

        // Visual component        
        this.game.addComponent(projectileId, this.componentTypes.RENDERABLE, 
            components.Renderable("projectiles", projectileData.id));
        
        // Use LifetimeSystem instead of direct component
        if (this.game.gameManager) {
            this.game.gameManager.call('addLifetime', projectileId, this.PROJECTILE_LIFETIME, {
                fadeOutDuration: 1.0, // Fade out in last second
                onDestroy: (entityId) => {
                    // Custom cleanup for projectiles
                    this.cleanupProjectileData(entityId);
                }
            });
        } else {
            // Fallback to old method if LifetimeSystem not available
            this.game.addComponent(projectileId, this.componentTypes.LIFETIME,
                components.Lifetime(this.PROJECTILE_LIFETIME, this.game.state.now));
        }
        
        // Homing component if specified
        if (projectileData.homing && projectileData.homingStrength > 0) {
            const homingStrength = projectileData.ballistic ? 
                projectileData.homingStrength * 0.3 : projectileData.homingStrength;
            this.game.addComponent(projectileId, this.componentTypes.HOMING_TARGET, 
                components.HomingTarget(targetId, homingStrength, { x: targetPos.x, y: targetPos.y, z: targetPos.z }));
        }
        
        return projectileId;
    }
    
    cleanupProjectileData(projectileId) {
        // Clean up trail data
        this.projectileTrails.delete(projectileId);
    }

    /**
     * Determine the element of a projectile based on various sources
     */
    determineProjectileElement(sourceId, projectileData) {
        // Priority order: projectile data > weapon element > combat element > default physical
        
        // 1. Check projectile data for explicit element
        if (projectileData.element) {
            return projectileData.element;
        }
        
        // 2. Check combat component element
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        if (sourceCombat && sourceCombat.element) {
            return sourceCombat.element;
        }
        
        // 3. Default to physical
        const elementTypes = this.game.gameManager ? this.game.gameManager.call('getDamageElementTypes') : null;
        return elementTypes?.PHYSICAL || 'physical';
    }

    calculateTrajectory(sourcePos, targetPos, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        const projectileSpeed = projectileData.speed;
        
        // For ballistic projectiles, calculate arc trajectory based on weapon range
        if (projectileData.ballistic) {
            return this.calculateBallisticTrajectory(sourcePos, targetPos, projectileSpeed, projectileData);
        } else {
            // Direct trajectory for non-ballistic projectiles
            const totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (totalDistance === 0) {
                return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
            }
            
            const initialVx = (dx / totalDistance) * projectileSpeed;
            const initialVy = (dy / totalDistance) * projectileSpeed;
            const initialVz = (dz / totalDistance) * projectileSpeed;
            
            return {
                vx: this.roundForDeterminism(initialVx),
                vy: this.roundForDeterminism(initialVy),
                vz: this.roundForDeterminism(initialVz),
                launchAngle: this.roundForDeterminism(Math.atan2(Math.sqrt(dx * dx + dz * dz), dy)),
                timeToTarget: this.roundForDeterminism(totalDistance / projectileSpeed)
            };
        }
    }
    
    calculateBallisticTrajectory(sourcePos, targetPos, speed, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        
        const horizontalDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (horizontalDistance === 0) {
            return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
        }
        
        // Get the firing unit's combat range to determine proper ballistic trajectory
        const sourceId = projectileData.sourceId;
        const sourceCombat = sourceId ? this.game.getComponent(sourceId, this.componentTypes.COMBAT) : null;
        const weaponRange = sourceCombat ? sourceCombat.range : horizontalDistance;
        
        // Use 45-degree angle for optimal range (gives maximum distance for given initial velocity)
        const launchAngle = Math.PI / 4; // 45 degrees
        const g = this.GRAVITY;
        
        // Calculate the initial velocity needed to reach the weapon's maximum range at 45 degrees
        const optimalInitialVelocity = Math.sqrt(weaponRange * g);
        
        // Calculate what range this velocity would achieve at our target distance
        const actualRange = Math.min(horizontalDistance, weaponRange);
        
        // If target is within range, calculate trajectory to hit it exactly
        let initialVelocity;
        let actualLaunchAngle = launchAngle;
        
        if (horizontalDistance <= weaponRange) {
            // Target is within range - calculate exact trajectory
            const maxRangeAtOptimalVelocity = (optimalInitialVelocity * optimalInitialVelocity) / g;
            
            if (horizontalDistance <= maxRangeAtOptimalVelocity) {
                // We can reach this distance with our optimal velocity
                initialVelocity = optimalInitialVelocity;
                // Calculate the required angle: sin(2Î¸) = (range * g) / vâ‚€Â²
                const sin2Theta = (horizontalDistance * g) / (initialVelocity * initialVelocity);
                
                // We want the lower trajectory angle (there are two solutions)
                const angle2Theta = Math.asin(Math.min(1, sin2Theta));
                actualLaunchAngle = angle2Theta / 2;
                
                // Prefer angles between 15Â° and 75Â° for realistic artillery
                if (actualLaunchAngle < Math.PI / 12) { // Less than 15Â°
                    actualLaunchAngle = Math.PI / 12;
                } else if (actualLaunchAngle > 5 * Math.PI / 12) { // More than 75Â°
                    actualLaunchAngle = 5 * Math.PI / 12;
                }
            } else {
                // Use 45Â° and calculate required velocity for this specific distance
                actualLaunchAngle = Math.PI / 4;
                initialVelocity = Math.sqrt(horizontalDistance * g);
            }
        } else {
            // Target is beyond weapon range - fire at maximum range in target direction
            initialVelocity = optimalInitialVelocity;
            actualLaunchAngle = Math.PI / 4; // 45Â° for maximum range
        }
        
        // Calculate time of flight
        const timeToTarget = (2 * initialVelocity * Math.sin(actualLaunchAngle)) / g;
        
        // Calculate horizontal direction unit vector
        const horizontalDirectionX = dx / horizontalDistance;
        const horizontalDirectionZ = dz / horizontalDistance;
        
        // Calculate initial velocity components
        const horizontalVelocity = initialVelocity * Math.cos(actualLaunchAngle);
        const vx = horizontalDirectionX * horizontalVelocity;
        const vz = horizontalDirectionZ * horizontalVelocity;
        const vy = initialVelocity * Math.sin(actualLaunchAngle); // Initial upward velocity
        
        // Adjust for height difference if target is at different elevation
        if (Math.abs(dy) > 5) { // Only adjust for significant height differences
            const heightAdjustment = dy / timeToTarget;
            const adjustedVy = vy + heightAdjustment;
            
            return {
                vx: this.roundForDeterminism(vx),
                vy: this.roundForDeterminism(adjustedVy),
                vz: this.roundForDeterminism(vz),
                launchAngle: this.roundForDeterminism(actualLaunchAngle),
                timeToTarget: this.roundForDeterminism(timeToTarget),
                weaponRange: this.roundForDeterminism(weaponRange),
                calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
            };
        }
        
        return {
            vx: this.roundForDeterminism(vx),
            vy: this.roundForDeterminism(vy),
            vz: this.roundForDeterminism(vz),
            launchAngle: this.roundForDeterminism(actualLaunchAngle),
            timeToTarget: this.roundForDeterminism(timeToTarget),
            weaponRange: this.roundForDeterminism(weaponRange),
            calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
        };
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        const projectiles = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.VELOCITY, 
            this.componentTypes.PROJECTILE
        );        
        projectiles.forEach(projectileId => {
            const pos = this.game.getComponent(projectileId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(projectileId, this.componentTypes.VELOCITY);
            const projectile = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE);
            const homing = this.game.getComponent(projectileId, this.componentTypes.HOMING_TARGET);
                        
            // Update homing behavior
            if (homing && homing.targetId && projectile.isBallistic) {
                this.updateBallisticHoming(projectileId, pos, vel, projectile, homing);
            } else if (homing && homing.targetId) {
                this.updateHomingProjectile(projectileId, pos, vel, projectile, homing);
            }
            
            // Handle different collision types based on projectile type
            if (projectile.isBallistic) {
                // Ballistic projectiles ONLY check for ground impact
                this.handleProjectileGroundImpact(projectileId, pos, projectile);
            } else {
                // Non-ballistic projectiles check for direct unit hits
                this.checkProjectileCollisions(projectileId, pos, projectile);
            }
            
            // Update visual trail
            this.updateProjectileTrail(projectileId, pos);
        });
    }
    
    updateBallisticHoming(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // For ballistic projectiles, we adjust the trajectory mid-flight
            // Calculate time elapsed since launch
            const timeElapsed = this.game.state.now - projectile.startTime;
            const remainingTime = Math.max(0.1, projectile.timeToTarget - timeElapsed);
            
            // Calculate where we need to be to hit the moving target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            
            // Adjust horizontal velocity to reach new target position
            const requiredHorizontalVelX = dx / remainingTime;
            const requiredHorizontalVelZ = dz / remainingTime;
            
            // Apply homing adjustment with strength factor
            const homingStrength = homing.homingStrength * this.game.state.deltaTime * 2; // Reduced for ballistic
            vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + requiredHorizontalVelX * homingStrength);
            vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + requiredHorizontalVelZ * homingStrength);
            
            // For vertical homing, we need to be more careful to maintain ballistic arc
            // Only adjust if we're in the descending phase
            if (vel.vy < 0) { // Falling down
                const requiredVerticalVel = (dy + 0.5 * this.GRAVITY * remainingTime * remainingTime) / remainingTime;
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength * 0.5) + requiredVerticalVel * (homingStrength * 0.5));
            }
        } else if (homing.lastKnownPosition) {
            // Target is gone, continue toward last known position
            const dx = homing.lastKnownPosition.x - pos.x;
            const dy = homing.lastKnownPosition.y - pos.y;
            const dz = homing.lastKnownPosition.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < 20) {
                // Close enough to last known position, destroy projectile
                this.destroyProjectile(projectileId);
                return;
            }
        }
    }
    
    updateHomingProjectile(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // Calculate direction to target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance > 0) {
                // Calculate desired velocity direction
                const desiredVx = (dx / distance) * projectile.speed;
                const desiredVy = (dy / distance) * projectile.speed;
                const desiredVz = (dz / distance) * projectile.speed;
                
                // Blend current velocity with desired velocity based on homing strength
                const homingStrength = homing.homingStrength * this.game.state.deltaTime * 5; // Adjust responsiveness
                vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + desiredVx * homingStrength);
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength) + desiredVy * homingStrength);
                vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + desiredVz * homingStrength);
                
                // Maintain speed
                const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy + vel.vz * vel.vz);
                if (currentSpeed > 0) {
                    const speedRatio = projectile.speed / currentSpeed;
                    vel.vx = this.roundForDeterminism(vel.vx * speedRatio);
                    vel.vy = this.roundForDeterminism(vel.vy * speedRatio);
                    vel.vz = this.roundForDeterminism(vel.vz * speedRatio);
                }
            }
        } else {
            homing.targetId = null;
        }
    }
    
    checkProjectileCollisions(projectileId, pos, projectile) {
        // Only for NON-ballistic projectiles
        if (projectile.isBallistic) return; // Skip collision check for ballistic
        
        // Get all potential targets
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const sourceTeam = this.game.getComponent(projectile.source, this.componentTypes.TEAM);
        if (!sourceTeam) return;
        
        let hitDetected = false;

        for (const entityId of allEntities) {
            if (hitDetected) break; // Stop after first hit to ensure consistency
            if (entityId === projectile.source) continue; // Don't hit the source
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            
            if (!entityPos || !entityTeam || !entityHealth) continue;
            if (entityTeam.team === sourceTeam.team) continue; // Don't hit allies
            
            // Calculate 3D distance with consistent precision
            const dx = Math.round((entityPos.x - pos.x) * 1000) / 1000;
            const dy = Math.round((entityPos.y - pos.y) * 1000) / 1000;
            const dz = Math.round((entityPos.z - pos.z) * 1000) / 1000;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            // Get entity radius for collision detection
            const entityUnitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const entityRadius = this.getUnitRadius(entityUnitType);

            // Check collision for direct hit
            if (distance <= entityRadius + this.HIT_DETECTION_RADIUS) {
                // Direct hit detected!
                this.handleProjectileHit(projectileId, entityId, entityPos, projectile);
                hitDetected = true;
                break;
            }
        }
    }
    
    handleProjectileGroundImpact(entityId, pos, projectile) {
        // Only for ballistic projectiles
        if (!projectile.isBallistic) return;
        
        // Get actual terrain height for projectile impact
        const terrainHeight = this.game.gameManager ? this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z) : null;
        const actualGroundLevel = terrainHeight !== null ? terrainHeight : this.game.movementSystem?.GROUND_LEVEL || 0;
        
        // Check if projectile hit the ground
        if (pos.y <= actualGroundLevel + this.GROUND_IMPACT_THRESHOLD) {
            // Ballistic projectiles explode on ground impact
            this.triggerBallisticExplosion(entityId, pos, projectile, actualGroundLevel);
            return;
        }
    }

    handleProjectileHit(projectileId, targetId, targetPos, projectile) {
        if (this.game.gameManager) {
            const damage = projectile.damage;
            const elementTypes = this.game.gameManager.call('getDamageElementTypes');
            const element = projectile.element || elementTypes.PHYSICAL;

            this.game.gameManager.call('applyDamage', projectile.source, targetId, damage, element, {
                isProjectile: true,
                projectileId: projectileId
            });
            if(!this.game.isServer){
                this.game.gameManager.call('createParticleEffect', targetPos.x, targetPos.y, targetPos.z, 'magic', {
                    color: this.getElementalEffectColor(element),
                    count: 3
                });
            }
        }


        this.destroyProjectile(projectileId);
    }

    triggerBallisticExplosion(entityId, pos, projectile, groundLevel) {
        this.createGroundExplosion(entityId, pos, projectile, groundLevel);

        if (this.game.gameManager) {
            const splashRadius = 80;
            const splashDamage = Math.floor(projectile.damage);
            const elementTypes = this.game.gameManager.call('getDamageElementTypes');
            const element = projectile.element || elementTypes.PHYSICAL;

            const results = this.game.gameManager.call('applySplashDamage',
                projectile.source,
                pos,
                splashDamage,
                element,
                splashRadius,
                {
                    isBallistic: true,
                    projectileId: entityId,
                    allowFriendlyFire: false
                }
            );

            if (this.game.combatAISystems && projectile.source && results) {
                for (const result of results) {
                    if (result.targetId && result.actualDamage > 0) {
                        this.game.combatAISystems.setRetaliatoryTarget(result.targetId, projectile.source);
                    }
                }
            }
        }

        this.destroyProjectile(entityId);
    }
    
 

    createGroundExplosion(projectileId, pos, projectile, groundLevel) {

    }

    // Get visual effect color based on element
    getElementalEffectColor(element) {
        if (!this.game.gameManager) return '#ff2200'; // blood-red

        const elementTypes = this.game.gameManager.call('getDamageElementTypes');

        switch (element) {
            case elementTypes.FIRE:
                return '#ffaa00'; // Default orange
            case elementTypes.COLD:
                return '#44aaff'; // Light blue
            case elementTypes.LIGHTNING:
                return '#ffff44'; // Bright yellow
            case elementTypes.POISON:
                return '#44ff44'; // Green
            case elementTypes.DIVINE:
                return '#ffddaa'; // Golden
            case elementTypes.PHYSICAL:
            default:
                return '#ff2200'; // Default orange
        }
    }

    // Get explosion effect type based on element
    getElementalExplosionEffect(element) {
        if (!this.game.gameManager) return 'explosion';

        const elementTypes = this.game.gameManager.call('getDamageElementTypes');

        switch (element) {
            case elementTypes.FIRE:
                return 'fire_explosion';
            case elementTypes.COLD:
                return 'ice_explosion';
            case elementTypes.LIGHTNING:
                return 'lightning_explosion';
            case elementTypes.POISON:
                return 'poison_explosion';
            case elementTypes.DIVINE:
                return 'divine_explosion';
            case elementTypes.PHYSICAL:
            default:
                return 'explosion';
        }
    }
    
    updateProjectileTrail(projectileId, pos) {
        const projectileVisual = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE_VISUAL);
        if (!projectileVisual || projectileVisual.trailLength <= 0) return;
        
        if (!this.projectileTrails.has(projectileId)) {
            this.projectileTrails.set(projectileId, []);
        }
        
        const trail = this.projectileTrails.get(projectileId);
        
        // Add current position to trail (full 3D)
        trail.push({ x: pos.x, y: pos.y, z: pos.z, time: (this.game.state.now || 0) });
        
        // Remove old trail points
        while (trail.length > projectileVisual.trailLength) {
            trail.shift();
        }
    }
        
    destroyProjectile(projectileId) {
        this.game.gameManager.call('destroyEntityImmediately', projectileId, true);    
        this.game.destroyEntity(projectileId);
        this.cleanupProjectileData(projectileId);
    }
    
    getUnitRadius(unitType) {
        const DEFAULT_UNIT_RADIUS = 15;
        
        if (unitType && unitType.size) {
            return Math.max(DEFAULT_UNIT_RADIUS, unitType.size);
        }
        
        const collections = this.game.getCollections && this.game.getCollections();
        if (collections && collections.units && unitType) {
            const unitDef = collections.units[unitType.id];
            if (unitDef && unitDef.size) {
                return Math.max(DEFAULT_UNIT_RADIUS, unitDef.size);
            }
        }
        
        return DEFAULT_UNIT_RADIUS;
    }
    
    getProjectileTrail(projectileId) {
        return this.projectileTrails.get(projectileId) || [];
    }
    entityDestroyed(entityId) {
        // Clean up projectile trails
        if (this.projectileTrails) {
            this.projectileTrails.delete(entityId);
        }
        
        // Clean up any projectile tracking
        if (this.activeProjectiles) {
            this.activeProjectiles.delete(entityId);
        }
    }
};

// system: AnimationSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['AnimationSystem'] = class AnimationSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.animationSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        // Animation state tracking (VAT-only, no mixers)
        this.entityAnimationStates = new Map(); // entityId -> { currentClip, lastStateChange, flags, etc. }
        
        // Animation configuration
        this.MIN_MOVEMENT_THRESHOLD = 0.1;
        this.MIN_ATTACK_ANIMATION_TIME = 0.4;
        this.STATE_CHANGE_COOLDOWN = 0.1;

        // Single-play animations (play once then stop/transition)
        this.SINGLE_PLAY_ANIMATIONS = new Set([
            'attack', 'cast', 'death'
        ]);

    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('triggerSinglePlayAnimation', this.triggerSinglePlayAnimation.bind(this));
        this.game.gameManager.register('isAnimationFinished', this.isAnimationFinished.bind(this));
        this.game.gameManager.register('setCorpseAnimation', this.setCorpseAnimation.bind(this));
        this.game.gameManager.register('startCelebration', this.startCelebration.bind(this));
        this.game.gameManager.register('stopCelebration', this.stopCelebration.bind(this));
        this.game.gameManager.register('playDeathAnimation', this.playDeathAnimation.bind(this));
        this.game.gameManager.register('getEntityAnimations', () => this.entityAnimationStates);
    }

    update() {
        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;
        this.updateEntityAnimations();
    }

    updateEntityAnimations() {
        const CT = this.componentTypes;
        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);

        entities.forEach(entityId => {
            // Only process instanced entities
            if (!this.game.renderSystem?.isInstanced(entityId)) return;

            const velocity = this.game.getComponent(entityId, CT.VELOCITY);
            const health = this.game.getComponent(entityId, CT.HEALTH);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);

            // Ensure entity has animation state
            if (!this.entityAnimationStates.has(entityId)) {
                this.initializeEntityAnimationState(entityId);
            }

            // Update animation logic
            this.updateEntityAnimationLogic(entityId, velocity, health, combat, aiState);
        });

        // Clean up removed entities
        this.cleanupRemovedEntities(new Set(entities));
    }

    initializeEntityAnimationState(entityId) {
        const state = {
            currentClip: 'idle',
            lastStateChange: this.game.state?.now || 0,
            animationTime: 0,
            minAnimationTime: 0,
            pendingClip: null,
            pendingSpeed: null,
            pendingMinTime: null,
            isTriggered: false,
            isDying: false,
            isCorpse: false,
            isCelebrating: false,
            // NEW: Track fallback usage to prevent thrashing
            lastRequestedClip: null,    // What was originally requested
            lastResolvedClip: null,     // What actually got set
            fallbackCooldown: 0         // Time remaining before allowing re-request of failed clip
        };

        this.entityAnimationStates.set(entityId, state);

        // Set initial animation
        this.game.renderSystem?.setInstanceClip(entityId, 'idle', true);
        this.game.renderSystem?.setInstanceSpeed(entityId, 1);

    }

    updateEntityAnimationLogic(entityId, velocity, health, combat, aiState) {
    
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        const currentTime = this.game.state?.now || 0;
        const deltaTime = this.game.state?.deltaTime || 1/60;
        animState.animationTime += deltaTime;

        // NEW: Handle animation completion for locked states
        if (animState.isDying || animState.isCorpse || animState.isCelebrating) {
            // Handle celebration completion ONLY
            if (animState.isCelebrating && this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
                const isFinished = this.isAnimationFinished(entityId, animState.currentClip);
                
                if (isFinished) {
                    this.stopCelebration(entityId);
                    return;
                }
            }
            
            return; // Still locked, don't process normal animation logic
        }
        // Handle pending triggered animations (from external calls)
        if (animState.isTriggered && animState.pendingClip) {
            this.applyTriggeredAnimation(entityId, animState);
            return;
        }

        // Determine desired animation based on game state
        const desired = this.determineDesiredAnimation(entityId, velocity, health, combat, aiState);
    
        // Check if we should change animation
        const shouldChange = this.shouldChangeAnimation(entityId, animState, desired, currentTime);
        

        if (shouldChange) {
            this.changeAnimation(entityId, desired.clip, desired.speed, desired.minTime);
        } else {
            // Update animation speed if needed (for continuous animations)
            this.updateAnimationSpeed(entityId, desired.speed);
        }
    }

    determineDesiredAnimation(entityId, velocity, health, combat, aiState) {
        let clip = 'idle';
        let speed = 1.0;
        let minTime = 0;

        if(this.game.state.phase == 'battle'){
            // Check movement first
            const isMoving = velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD);
            
            if (isMoving) {
                clip = 'walk';
                speed = this.calculateWalkSpeed(velocity);
            }

            // AI state overrides
            if (aiState) {
                switch (aiState.state) {
                    case 'attacking':
                    case 'combat':
                        // During combat, prefer walking if moving, otherwise idle
                        if (!isMoving) {
                            clip = 'idle';
                            speed = 1.0;
                        }
                        break;
                        
                    case 'chasing':
                    case 'moving':
                        clip = 'walk';
                        speed = this.calculateWalkSpeed(velocity);
                        break;
                        
                    case 'waiting':
                        clip = isMoving ? 'walk' : 'idle';
                        if (isMoving) speed = this.calculateWalkSpeed(velocity);
                        break;
                }
            }
        }

        return { clip, speed, minTime };
    }

    shouldChangeAnimation(entityId, animState, desired, currentTime) {
        // 1) If we are in a single-play clip, don't allow state changes until it's finished
        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            const finished = this.isAnimationFinished(entityId, animState.currentClip);

            // Respect explicit minAnimationTime as an additional guard
            const minTimeSatisfied = (animState.minAnimationTime <= 0) || (animState.animationTime >= animState.minAnimationTime);

            // Block changes until BOTH: (a) clip finished OR (b) min time satisfied (use whichever is stricter for your game)
            // If you want strictly "finished", change to: if (!finished) return false;
            if (!finished && !minTimeSatisfied) {
                return false;
            }
            // Once finished (or min time hit), we can flow through to normal logic below.
        }

        // 2) Cooldown: prevent thrashing even for continuous animations
        const timeSinceLastChange = currentTime - animState.lastStateChange;
        if(timeSinceLastChange < 0){
            return true;

        }
        if (timeSinceLastChange < this.STATE_CHANGE_COOLDOWN) {
            return false;
        }

        // 3) If the desired clip differs, allow change (this now runs AFTER the single-play guard)
        if (animState.currentClip !== desired.clip) {
            return true;
        }

        // 4) For single-play, if somehow the clip finished (edge case) allow refresh
        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            if (this.isAnimationFinished(entityId, animState.currentClip)) {
                return true;
            }
        }

        // 5) Respect minAnimationTime for non-single-play too
        if (animState.minAnimationTime > 0 && animState.animationTime < animState.minAnimationTime) {
            return false;
        }

        return false;
    }

    changeAnimation(entityId, clipName, speed = 1.0, minTime = 0) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return false;

        // Try to resolve clip name to available clip
        const resolvedClip = this.resolveClipName(entityId, clipName);
        
        // Apply animation change
        const success = this.game.renderSystem?.setInstanceClip(entityId, resolvedClip, true);
        if (success) {
            this.game.renderSystem?.setInstanceSpeed(entityId, speed);
            
            // Update state
            animState.currentClip = resolvedClip;
            animState.lastStateChange = this.game.state?.now || 0;
            animState.animationTime = 0;
            animState.minAnimationTime = minTime;
            
            return true;
        } else {
            console.warn(`[AnimationSystem] âŒ Failed to change animation for entity ${entityId}: ${clipName} -> ${resolvedClip}`);
        }

        return false;
    }

    updateAnimationSpeed(entityId, targetSpeed) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        // Only update speed for continuous animations
        if (!this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            this.game.renderSystem?.setInstanceSpeed(entityId, targetSpeed);
        }
    }

    applyTriggeredAnimation(entityId, animState) {
        const clip = animState.pendingClip;
        const speed = animState.pendingSpeed || 1.0;
        const minTime = animState.pendingMinTime || 0;

        // Clear pending state
        animState.pendingClip = null;
        animState.pendingSpeed = null;
        animState.pendingMinTime = null;
        animState.isTriggered = false;

        // Apply the animation
        this.changeAnimation(entityId, clip, speed, minTime);
    }

    // Public API methods
    
    triggerSinglePlayAnimation(entityId, clipName, speed = 1.0, minTime = 0) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) {
            console.warn(`[AnimationSystem] No animation state for entity ${entityId}`);
            return false;
        }

        
        // Queue the animation
        animState.pendingClip = clipName;
        animState.pendingSpeed = speed;
        animState.pendingMinTime = minTime;
        animState.isTriggered = true;

        return true;
    }

    playDeathAnimation(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) {
            console.warn(`[AnimationSystem] âŒ No animation state found for entity ${entityId} during death`);
            return;
        }

        // Set death state
        animState.isDying = true;
        animState.isCorpse = false;
        animState.isCelebrating = false;
        
        // Clear any pending animations
        animState.isTriggered = false;
        animState.pendingClip = null;
        animState.pendingSpeed = null;
        animState.pendingMinTime = null;
        
        // Reset fallback tracking for death animation
        animState.lastRequestedClip = null;
        animState.lastResolvedClip = null;
        animState.fallbackCooldown = 0;
        
        // Apply death animation immediately
        this.changeAnimation(entityId, 'death', 1.0, 0);
        
    }

    setCorpseAnimation(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        // Update animation state flags
        animState.isDying = false;
        animState.isCorpse = true;
        
        // Get the current clip's duration and set to last frame
        const animationStateData = this.game.gameManager.call('getEntityAnimationState', entityId);
        
        if (animationStateData && animationStateData.clipDuration > 0) {
            // Set to 99% through the animation (last frame before loop)
            const lastFrameTime = animationStateData.clipDuration * 0.99;
            this.game.gameManager.call('setInstanceAnimationTime', entityId, lastFrameTime);
        }
        
        // Now freeze it at that frame
        this.game.gameManager.call('setInstanceSpeed', entityId, 0);
    }

    startCelebration(entityId, teamType = null) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        animState.isCelebrating = true;
        
        // Try celebration animations, fallback to idle
        const celebrationClips = ['celebrate'];
        let clipToUse = 'idle';
        
        for (const clip of celebrationClips) {
            if (this.hasClip(entityId, clip)) {
                clipToUse = clip;
                break;
            }
        }

        this.changeAnimation(entityId, clipToUse, 1.0, 0);
    }

    stopCelebration(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        animState.isCelebrating = false;
        this.changeAnimation(entityId, 'idle', 1.0, 0);
    }

    entityJump(entityId, speed = 1.0) {
        if (this.hasClip(entityId, 'leap')) {
            this.triggerSinglePlayAnimation(entityId, 'leap', speed, 0.5);
        }
    }

    entityThrow(entityId, speed = 1.0) {
        if (this.hasClip(entityId, 'throw')) {
            this.triggerSinglePlayAnimation(entityId, 'throw', speed, 0.3);
        }
    }

    stopAllAnimations(entityId) {
        this.game.renderSystem?.setInstanceSpeed(entityId, 0);
    }

    // Utility methods

    calculateWalkSpeed(velocity) {
        if (!velocity) return 1.0;
        const speed = Math.sqrt((velocity.vx || 0) ** 2 + (velocity.vz || 0) ** 2);
        return Math.min(2.0, Math.max(0.5, speed / 30)); // Adjust divisor based on your units
    }

    isAnimationFinished(entityId, clipName) {
        if (!this.SINGLE_PLAY_ANIMATIONS.has(clipName)) {
            return false; // Continuous animations never finish
        }

        const animationState = this.game.gameManager.call('getEntityAnimationState', entityId);
        if (!animationState) {
            return true;
        }

        // Check if we've played through most of the clip
        const progress = animationState.animTime / animationState.clipDuration;
        const isFinished = progress >= 0.9; // Consider finished at 90%
        
        return isFinished;
    }

    hasClip(entityId, clipName) {
        const CT = this.componentTypes;
        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
        if (!renderable) return false;

        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);
        return batchInfo?.availableClips?.includes(clipName) || false;
    }

    resolveClipName(entityId, desiredClip) {
        const CT = this.componentTypes;
        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
        if (!renderable) return 'idle';

        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);
        if (!batchInfo) return 'idle';

        const availableClips = batchInfo.availableClips;

        // Return if exact match exists
        if (availableClips.includes(desiredClip)) {
            return desiredClip;
        }

        // Try fallbacks
        const fallbacks = {
            'attack': ['combat', 'fight', 'swing', 'strike', 'idle'],
            'shoot': ['bow', 'cast', 'throw', 'attack', 'idle'],
            'bow': ['shoot', 'cast', 'throw', 'attack', 'idle'],
            'cast': ['shoot', 'throw', 'attack', 'idle'],
            'walk': ['run', 'move', 'step', 'idle'],
            'hurt': ['damage', 'hit', 'pain', 'idle'],
            'death': ['die', 'idle'],
            'celebrate': ['victory', 'cheer', 'dance', 'happy', 'win', 'idle']
        };

        const fallbackList = fallbacks[desiredClip] || ['idle'];
        for (const fallback of fallbackList) {
            if (availableClips.includes(fallback)) {
                return fallback;
            }
        }

        // Final fallback
        return availableClips[0] || 'idle';
    }

    // Cleanup methods

    cleanupRemovedEntities(currentEntities) {
        const toRemove = [];
        
        for (const entityId of this.entityAnimationStates.keys()) {
            if (!currentEntities.has(entityId)) {
                toRemove.push(entityId);
            }
        }

        toRemove.forEach(entityId => {
            this.removeEntityAnimations(entityId);
        });
    }

    entityDestroyed(entityId){
        this.removeEntityAnimations(entityId);
    }
    removeEntityAnimations(entityId) {
        this.entityAnimationStates.delete(entityId);        
    }

    destroy() {
        this.entityAnimationStates.clear();
    }

};

// system: ArmyDisplaySystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ArmyDisplaySystem'] = class ArmyDisplaySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);  
        this.game.armyDisplaySystem = this;
        this.updateInterval = null;
        this.lastUpdateData = null;
    }
    
    initialize() {
        this.addArmyDisplayCSS();
        this.setupUpdateLoop();
    }
    
    setupUpdateLoop() {
        // Update army display every 500ms to avoid performance issues
        this.updateInterval = setInterval(() => {
            this.update();
        }, 500);
    }
    
    update() {
        const playerArmy = document.getElementById('playerArmy');
        const enemyArmy = document.getElementById('enemyArmy');
        
        if (!playerArmy || !enemyArmy) return;
        
        const armyData = this.getArmyData();
        
        // Only update if data has changed to avoid unnecessary DOM manipulation
        if (this.hasDataChanged(armyData)) {
            this.displayArmy(playerArmy, armyData.playerUnits, 'player');
            this.displayArmy(enemyArmy, armyData.enemyUnits, 'enemy');
            this.lastUpdateData = armyData;
        }
        
        this.updateArmyStats(armyData);
    }
    
    hasDataChanged(newData) {
        if (!this.lastUpdateData) return true;
        
        return (
            JSON.stringify(newData.playerUnits) !== JSON.stringify(this.lastUpdateData.playerUnits) ||
            JSON.stringify(newData.enemyUnits) !== JSON.stringify(this.lastUpdateData.enemyUnits)
        );
    }
    
    getArmyData() {
        try {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const allUnits = this.game.getEntitiesWith(
                ComponentTypes.TEAM, 
                ComponentTypes.UNIT_TYPE, 
                ComponentTypes.HEALTH
            ) || [];
            
            const playerUnits = [];
            const enemyUnits = [];
            
            allUnits.forEach(entityId => {
                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);
                const unitType = this.game.getComponent(entityId, ComponentTypes.UNIT_TYPE);
                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                const combat = this.game.getComponent(entityId, ComponentTypes.COMBAT);
                
                const unitInfo = {
                    id: entityId,
                    type: unitType?.type || 'Unknown',
                    name: unitType?.name || unitType?.type || 'Unit',
                    health: health?.current || 0,
                    maxHealth: health?.max || 1,
                    position: position ? { x: position.x, z: position.z } : null,
                    damage: combat?.damage || 0,
                    status: this.getUnitStatus(entityId)
                };
                
                if (team?.team === 'player') {
                    playerUnits.push(unitInfo);
                } else if (team?.team === 'enemy') {
                    enemyUnits.push(unitInfo);
                }
            });
            
            // Sort by health percentage (wounded units first, then by position)
            const sortUnits = (units) => {
                return units.sort((a, b) => {
                    const healthPercentA = a.health / a.maxHealth;
                    const healthPercentB = b.health / b.maxHealth;
                    
                    // Wounded units first
                    if (healthPercentA < 1 && healthPercentB >= 1) return -1;
                    if (healthPercentB < 1 && healthPercentA >= 1) return 1;
                    
                    // Then sort by position (front to back)
                    if (a.position && b.position) {
                        return a.position.x - b.position.x;
                    }
                    
                    return 0;
                });
            };
            
            return {
                playerUnits: sortUnits(playerUnits),
                enemyUnits: sortUnits(enemyUnits)
            };
        } catch (error) {
            console.warn('Error getting army data:', error);
            return { playerUnits: [], enemyUnits: [] };
        }
    }
    
    getUnitStatus(entityId) {
        try {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
            
            if (health?.current <= 0) return 'dead';
            if (aiState?.state === 'attacking') return 'attacking';
            if (aiState?.state === 'moving') return 'moving';
            if (aiState?.state === 'idle') return 'idle';
            
            return 'unknown';
        } catch (error) {
            return 'unknown';
        }
    }
    
    displayArmy(container, units, armyType) {
        // Clear container
        container.innerHTML = '';
        
        if (units.length === 0) {
            this.displayEmptyArmy(container, armyType);
            return;
        }
        
        // Create army header
        this.createArmyHeader(container, units, armyType);
        
        // Display units
        units.forEach((unit, index) => {
            const unitElement = this.createUnitElement(unit, index, armyType);
            container.appendChild(unitElement);
        });
    }
    
    displayEmptyArmy(container, armyType) {
        const emptyDiv = document.createElement('div');
        emptyDiv.className = 'army-empty';
        emptyDiv.innerHTML = `
            <div class="empty-icon">${armyType === 'player' ? 'ðŸ›¡ï¸' : 'âš”ï¸'}</div>
            <div class="empty-text">
                ${armyType === 'player' ? 'No units deployed' : 'Enemy preparing...'}
            </div>
        `;
        container.appendChild(emptyDiv);
    }
    
    createArmyHeader(container, units, armyType) {
        const header = document.createElement('div');
        header.className = `army-header army-header-${armyType}`;
        
        const totalHealth = units.reduce((sum, unit) => sum + unit.health, 0);
        const maxHealth = units.reduce((sum, unit) => sum + unit.maxHealth, 0);
        const healthPercent = maxHealth > 0 ? Math.round((totalHealth / maxHealth) * 100) : 0;
        
        const aliveCount = units.filter(unit => unit.health > 0).length;
        
        header.innerHTML = `
            <div class="army-summary">
                <span class="unit-count">${aliveCount}/${units.length} Units</span>
                <span class="health-percent ${this.getHealthPercentClass(healthPercent)}">${healthPercent}% HP</span>
            </div>
            <div class="army-health-bar">
                <div class="health-bar-fill" style="width: ${healthPercent}%"></div>
            </div>
        `;
        
        container.appendChild(header);
    }
    
    createUnitElement(unit, index, armyType) {
        const unitDiv = document.createElement('div');
        unitDiv.className = `army-unit army-unit-${armyType}`;
        unitDiv.dataset.unitId = unit.id;
        
        const healthPercent = unit.health / unit.maxHealth;
        const healthClass = this.getHealthClass(healthPercent);
        const statusIcon = this.getStatusIcon(unit.status);
        
        unitDiv.innerHTML = `
            <div class="unit-info">
                <div class="unit-name-row">
                    <span class="unit-name">${unit.name}</span>
                    <span class="unit-status">${statusIcon}</span>
                </div>
                <div class="unit-health-row">
                    <span class="unit-health ${healthClass}">${unit.health}/${unit.maxHealth}</span>
                    <span class="unit-damage">âš”ï¸${unit.damage}</span>
                </div>
                <div class="unit-health-bar">
                    <div class="health-bar-fill ${healthClass}" 
                         style="width: ${Math.max(0, healthPercent * 100)}%"></div>
                </div>
            </div>
        `;
        
        // Add click handler for unit selection/info
        unitDiv.addEventListener('click', () => {
            this.showUnitDetails(unit, armyType);
        });
        
        // Add hover effects
        unitDiv.addEventListener('mouseenter', () => {
            this.highlightUnit(unit.id);
        });
        
        unitDiv.addEventListener('mouseleave', () => {
            this.unhighlightUnit(unit.id);
        });
        
        return unitDiv;
    }
    
    getHealthClass(healthPercent) {
        if (healthPercent <= 0) return 'health-dead';
        if (healthPercent <= 0.25) return 'health-critical';
        if (healthPercent <= 0.5) return 'health-wounded';
        if (healthPercent <= 0.75) return 'health-damaged';
        return 'health-full';
    }
    
    getHealthPercentClass(percent) {
        if (percent <= 25) return 'health-critical';
        if (percent <= 50) return 'health-wounded';
        if (percent <= 75) return 'health-damaged';
        return 'health-full';
    }
    
    getStatusIcon(status) {
        const icons = {
            attacking: 'âš”ï¸',
            moving: 'ðŸƒ',
            idle: 'ðŸ›¡ï¸',
            dead: 'ðŸ’€',
            unknown: 'â“'
        };
        return icons[status] || icons.unknown;
    }
    
    showUnitDetails(unit, armyType) {
        const details = `
            <h3>${unit.name} Details</h3>
            <div class="unit-details">
                <div class="detail-row">
                    <span>Health:</span>
                    <span class="${this.getHealthClass(unit.health / unit.maxHealth)}">
                        ${unit.health}/${unit.maxHealth}
                    </span>
                </div>
                <div class="detail-row">
                    <span>Damage:</span>
                    <span>${unit.damage}</span>
                </div>
                <div class="detail-row">
                    <span>Status:</span>
                    <span>${this.getStatusIcon(unit.status)} ${unit.status}</span>
                </div>
                ${unit.position ? `
                <div class="detail-row">
                    <span>Position:</span>
                    <span>(${unit.position.x.toFixed(1)}, ${unit.position.z.toFixed(1)})</span>
                </div>
                ` : ''}
            </div>
        `;

        // Use the input handler to show modal
        this.game.gameManager.call('showModal', `${armyType === 'player' ? 'ðŸ›¡ï¸' : 'âš”ï¸'} Unit Info`, details);
    }
    
    highlightUnit(unitId) {
        // Visual highlight on the battlefield (could integrate with effects system)
        if (this.game.effectsSystem) {
            // Get unit position and show highlight effect
            try {
                const ComponentTypes = this.game.componentManager.getComponentTypes();
                const position = this.game.getComponent(unitId, ComponentTypes.POSITION);
                if (position) {
                    // Convert world position to screen position and show highlight
                    // This is a placeholder - actual implementation would depend on rendering system
                    console.log(`Highlighting unit ${unitId} at position (${position.x}, ${position.z})`);
                }
            } catch (error) {
                console.warn('Could not highlight unit:', error);
            }
        }
    }
    
    unhighlightUnit(unitId) {
        // Remove highlight
        console.log(`Unhighlighting unit ${unitId}`);
    }
    
    updateArmyStats(armyData) {
        this.updateArmyStrength(armyData);
        this.updateArmyComposition(armyData);
    }
    
    updateArmyStrength(armyData) {
        // Update army strength indicators
        const playerStrength = this.calculateArmyStrength(armyData.playerUnits);
        const enemyStrength = this.calculateArmyStrength(armyData.enemyUnits);
        
        // Update strength displays if they exist
        const playerStrengthEl = document.getElementById('playerArmyStrength');
        const enemyStrengthEl = document.getElementById('enemyArmyStrength');
        
        if (playerStrengthEl) {
            playerStrengthEl.textContent = playerStrength;
            playerStrengthEl.className = this.getStrengthClass(playerStrength);
        }
        
        if (enemyStrengthEl) {
            enemyStrengthEl.textContent = enemyStrength;
            enemyStrengthEl.className = this.getStrengthClass(enemyStrength);
        }
    }
    
    calculateArmyStrength(units) {
        return units.reduce((total, unit) => {
            const healthFactor = unit.health / unit.maxHealth;
            return total + (unit.damage * healthFactor);
        }, 0);
    }
    
    getStrengthClass(strength) {
        if (strength >= 100) return 'strength-very-high';
        if (strength >= 75) return 'strength-high';
        if (strength >= 50) return 'strength-medium';
        if (strength >= 25) return 'strength-low';
        return 'strength-very-low';
    }
    
    updateArmyComposition(armyData) {
        // Update army composition displays
        const playerComposition = this.analyzeComposition(armyData.playerUnits);
        const enemyComposition = this.analyzeComposition(armyData.enemyUnits);
        
        // Could update composition indicators here
        console.log('Player composition:', playerComposition);
        console.log('Enemy composition:', enemyComposition);
    }
    
    analyzeComposition(units) {
        const composition = {};
        units.forEach(unit => {
            composition[unit.type] = (composition[unit.type] || 0) + 1;
        });
        return composition;
    }
    
    addArmyDisplayCSS() {
        if (document.querySelector('#army-display-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'army-display-styles';
        style.textContent = `
            .army-empty {
                text-align: center; padding: 2rem; color: #666;
            }
            
            .empty-icon {
                font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.5;
            }
            
            .empty-text {
                font-size: 0.9rem; opacity: 0.7;
            }
            
            .army-header {
                background: rgba(255, 255, 255, 0.05);
                padding: 0.8rem; margin-bottom: 0.5rem;
                border-radius: 5px; border-left: 3px solid;
            }
            
            .army-header-player { border-left-color: #00ff00; }
            .army-header-enemy { border-left-color: #ff4444; }
            
            .army-summary {
                display: flex; justify-content: space-between;
                align-items: center; margin-bottom: 0.5rem;
            }
            
            .unit-count {
                font-weight: bold; color: #ccc;
            }
            
            .health-percent {
                font-weight: bold; font-size: 0.9rem;
            }
            
            .army-health-bar {
                height: 4px; background: #333; border-radius: 2px; overflow: hidden;
            }
            
            .health-bar-fill {
                height: 100%; transition: width 0.3s ease;
            }
            
            .army-unit {
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid transparent;
                border-radius: 4px; padding: 0.6rem;
                margin: 0.3rem 0; cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .army-unit:hover {
                background: rgba(255, 255, 255, 0.08);
                border-color: rgba(255, 255, 255, 0.2);
                transform: translateX(2px);
            }
            
            .army-unit-player:hover { border-left-color: #00ff00; }
            .army-unit-enemy:hover { border-left-color: #ff4444; }
            
            .unit-info {
                font-size: 0.85rem;
            }
            
            .unit-name-row, .unit-health-row {
                display: flex; justify-content: space-between;
                align-items: center; margin-bottom: 0.3rem;
            }
            
            .unit-name {
                font-weight: bold; color: #ccc;
            }
            
            .unit-status {
                opacity: 0.8;
            }
            
            .unit-health {
                font-weight: bold;
            }
            
            .unit-damage {
                font-size: 0.8rem; opacity: 0.8;
            }
            
            .unit-health-bar {
                height: 3px; background: #333;
                border-radius: 2px; overflow: hidden;
            }
            
            /* Health color classes */
            .health-full, .health-full .health-bar-fill { color: #00ff00; background-color: #00ff00; }
            .health-damaged, .health-damaged .health-bar-fill { color: #88ff88; background-color: #88ff88; }
            .health-wounded, .health-wounded .health-bar-fill { color: #ffff00; background-color: #ffff00; }
            .health-critical, .health-critical .health-bar-fill { color: #ff8800; background-color: #ff8800; }
            .health-dead, .health-dead .health-bar-fill { color: #ff0000; background-color: #ff0000; opacity: 0.5; }
            
            /* Strength classes */
            .strength-very-high { color: #00ff88; }
            .strength-high { color: #88ff88; }
            .strength-medium { color: #ffff88; }
            .strength-low { color: #ff8888; }
            .strength-very-low { color: #ff4444; }
            
            /* Unit details modal content */
            .unit-details {
                font-family: monospace;
            }
            
            .detail-row {
                display: flex; justify-content: space-between;
                padding: 0.5rem 0; border-bottom: 1px solid #333;
            }
            
            .detail-row:last-child {
                border-bottom: none;
            }
        `;
        document.head.appendChild(style);
    }
    
    cleanup() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
    }
}
;

// system: EffectsSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['EffectsSystem'] = class EffectsSystem extends engine.BaseSystem {
    constructor(game) {
        super(game); 
        this.game.effectsSystem = this;
        
        // Screen effect tracking
        this.screenEffects = [];
        this.shakeActive = false;
        this.flashActive = false;
        
        // UI notifications
        this.notifications = [];
        
        // Single array for all active effects with unified update loop
        this.activeEffects = [];
        
        // Object pools for reuse
        this.geometryPool = new Map(); // type -> geometry[]
        this.materialPool = new Map(); // key -> material[]
        this.effectPool = []; // Reusable effect objects        
        this.activeAuras = new Map();
        
        // Batching system
        this.batchedEffects = new Map(); // type -> effects[]
        
        this.effectOffset = { x: 0, y: 75, z: 0 };
        this.shakeData = null;
        this.flashData = null;
        // Performance tracking
        this.stats = {
            activeEffects: 0,
            pooledObjects: 0
        };
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('createParticleEffect', this.createParticleEffect.bind(this));
        this.game.gameManager.register('clearAllEffects', this.clearAllEffects.bind(this));
        this.game.gameManager.register('showNotification', this.showNotification.bind(this));
        this.game.gameManager.register('createLineEffect', this.createLineEffect.bind(this));
        this.game.gameManager.register('createLightningBolt', this.createLightningBolt.bind(this));
        this.game.gameManager.register('createEnergyBeam', this.createEnergyBeam.bind(this));
        this.game.gameManager.register('playScreenShake', this.playScreenShake.bind(this));
        this.game.gameManager.register('playScreenFlash', this.playScreenFlash.bind(this));
        this.game.gameManager.register('initializeEffectsSystem', this.initialize.bind(this));
    }

    initialize() {
        this.addEffectsCSS();
        console.log('EffectsSystem initialized');
    }
    
    // Batch process all effects using game time
    updateAllEffects() {
        if (!this.game.state) return;
        
        const currentTime = this.game.state.now;
        if (!currentTime) return;
        
        const toRemove = [];
        
        for (let i = this.activeEffects.length - 1; i >= 0; i--) {
            const effect = this.activeEffects[i];
            const elapsed = currentTime - effect.startTime;
            const progress = elapsed / effect.duration;
            
            if (progress >= 1) {
                toRemove.push(i);
                continue;
            }
            
            this.updateEffect(effect, elapsed, progress);
        }
        
        // Remove completed effects and return to pool
        toRemove.forEach(index => {
            const effect = this.activeEffects[index];
            this.recycleEffect(effect);
            this.activeEffects.splice(index, 1);
        });
        
        this.stats.activeEffects = this.activeEffects.length;
    }
    
    updateEffect(effect, elapsed, progress) {
        const { material, animation } = effect;
        
        // Batch similar updates together
        switch (effect?.animationType) {
            case 'flicker':
                this.updateFlickerEffect(effect, elapsed, animation);
                break;
            case 'pulse':
                this.updatePulseEffect(effect, elapsed, animation);
                break;
            case 'fade':
                this.updateFadeEffect(effect, progress, animation);
                break;
        }
    }
    
    updateFlickerEffect(effect, elapsed, animation) {
        if (animation?.flickerCount > 0 && effect?.flickerCount < animation?.flickerCount) {
            if (elapsed % animation.flickerSpeed < animation.flickerSpeed / 2) {
                if (animation.opacityFlicker) {
                    effect.material.opacity = Math.random() * 0.6 + 0.4;
                }
                if (animation.colorFlicker) {
                    const colors = [0x00ddff, 0x88aaff, 0xaaffff];
                    effect.material.color.setHex(colors[Math.floor(Math.random() * colors.length)]);
                }
                effect.flickerCount++;
            }
        }
    }
    
    updatePulseEffect(effect, elapsed, animation) {
        if (animation?.pulseEffect) {
            const pulseIntensity = Math.sin(elapsed * 0.01) * 0.3 + 0.7;
            effect.material.opacity = pulseIntensity;
        }
    }
    
    updateFadeEffect(effect, progress, animation) {
        if (animation?.fadeOut && progress > 0.7) {
            const fadeProgress = (progress - 0.7) / 0.3;
            effect.material.opacity = effect.originalOpacity * (1 - fadeProgress);
        }
    }
    
    // Object pooling system
    getPooledGeometry(type, points) {
        const poolKey = `${type}_${points.length}`;
        let pool = this.geometryPool.get(poolKey);
        
        if (!pool) {
            pool = [];
            this.geometryPool.set(poolKey, pool);
        }
        
        if (pool.length > 0) {
            const geometry = pool.pop();
            geometry.setFromPoints(points);
            geometry.computeBoundingSphere();
            return geometry;
        }
        
        return new THREE.BufferGeometry().setFromPoints(points);
    }
    
    getPooledMaterial(config) {
        const poolKey = `${config.color}_${config.linewidth}_${config.blending}`;
        let pool = this.materialPool.get(poolKey);
        
        if (!pool) {
            pool = [];
            this.materialPool.set(poolKey, pool);
        }
        
        if (pool.length > 0) {
            const material = pool.pop();
            material.opacity = config.opacity || 1.0;
            material.color.setHex(config.color || 0xffffff);
            return material;
        }
        
        return new THREE.LineBasicMaterial({
            color: config.color || 0xffffff,
            linewidth: config.linewidth || 2,
            transparent: true,
            opacity: config.opacity || 1.0,
            blending: config.blending || THREE.AdditiveBlending
        });
    }
    
    getPooledEffect() {
        if (this.effectPool.length > 0) {
            return this.effectPool.pop();
        }
        
        return {
            line: null,
            geometry: null,
            material: null,
            startTime: 0,
            duration: 0,
            flickerCount: 0,
            originalOpacity: 1,
            animationType: null
        };
    }
    
    recycleEffect(effect) {
        if (!effect) return;
        
        try {
            // Remove from scene
            if (this.game?.scene && effect.line) {
                this.game.scene.remove(effect.line);
            }
            
            // Return to pools
            if (effect.geometry) {
                const poolKey = `${effect.type}_${effect.geometry.attributes.position.count}`;
                let pool = this.geometryPool.get(poolKey);
                if (!pool) {
                    pool = [];
                    this.geometryPool.set(poolKey, pool);
                }
                if (pool.length < 10) { // Limit pool size
                    pool.push(effect.geometry);
                }
            }
            
            if (effect.material) {
                const poolKey = `${effect.material.color.getHex()}_${effect.material.linewidth}_${effect.material.blending}`;
                let pool = this.materialPool.get(poolKey);
                if (!pool) {
                    pool = [];
                    this.materialPool.set(poolKey, pool);
                }
                if (pool.length < 10) { // Limit pool size
                    pool.push(effect.material);
                }
            }
            
            // Reset effect object and return to pool
            effect.line = null;
            effect.geometry = null;
            effect.material = null;
            effect.startTime = 0;
            effect.duration = 0;
            effect.flickerCount = 0;
            effect.originalOpacity = 1;
            effect.animationType = null;
            
            if (this.effectPool.length < 50) { // Limit pool size
                this.effectPool.push(effect);
            }
            
        } catch (e) {
            console.warn('recycleEffect error:', e);
        }
    }
    
    // Main line effect creation (same interface, better performance)
    createLineEffect(config) {
        if (!this.game.scene) return null;
        
        const {
            startPos,
            endPos,
            type = 'lightning',
            style = {},
            animation = {}
        } = config;
        
        const lineConfig = this.getLineEffectConfig(type);
        const mergedStyle = { ...lineConfig.style, ...style };
        const mergedAnimation = { ...lineConfig.animation, ...animation };
        
        // Generate path based on type
        const points = this.generateLinePath(startPos, endPos, type, mergedStyle);
        
        // Use pooled objects
        const geometry = this.getPooledGeometry(type, points);
        const material = this.getPooledMaterial(mergedStyle);
        const effect = this.getPooledEffect();
        
        // Create line object
        const lineEffect = new THREE.Line(geometry, material);
        this.game.scene.add(lineEffect);
        
        // Setup effect tracking
        effect.line = lineEffect;
        effect.geometry = geometry;
        effect.material = material;
        effect.startTime = this.game.state.now;
        effect.duration = mergedAnimation.duration || 1000;
        effect.originalOpacity = material.opacity;
        effect.type = type;
        
        // Determine animation type for efficient batching
        if (mergedAnimation.flickerCount > 0) {
            effect.animationType = 'flicker';
        } else if (mergedAnimation.pulseEffect) {
            effect.animationType = 'pulse';
        } else if (mergedAnimation.fadeOut) {
            effect.animationType = 'fade';
        }
        
        this.activeEffects.push(effect);
        
        return effect;
    }
    
    // Batch creation for multiple effects
    createBatchedEffects(effects) {
        const results = [];
        
        for (const config of effects) {
            const effect = this.createLineEffect(config);
            if (effect) {
                results.push(effect);
            }
        }
        
        return results;
    }
    
    // Keep existing interface methods unchanged
    createLightningBolt(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'lightning',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createEnergyBeam(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'beam',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createMagicArc(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'arc',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createChainLink(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'chain',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    // Line effect configuration (unchanged)
    getLineEffectConfig(type) {
        const configs = {
            lightning: {
                style: {
                    color: 0x88aaff,
                    linewidth: 3,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    segments: 8,
                    deviation: 15,
                    jaggedIntensity: 1.2
                },
                animation: {
                    duration: 0.3,
                    flickerCount: 3,
                    flickerSpeed: 50,
                    opacityFlicker: true,
                    colorFlicker: true,
                    fadeOut: true
                }
            },
            beam: {
                style: {
                    color: 0xff4444,
                    linewidth: 4,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    segments: 3,
                    deviation: 2,
                    jaggedIntensity: 0.1
                },
                animation: {
                    duration: 0.5,
                    pulseEffect: true,
                    fadeOut: true
                }
            },
            arc: {
                style: {
                    color: 0x44ff44,
                    linewidth: 2,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending,
                    segments: 12,
                    deviation: 25,
                    jaggedIntensity: 0.3,
                    arcHeight: 30
                },
                animation: {
                    duration: 0.8,
                    fadeOut: true
                }
            },
            chain: {
                style: {
                    color: 0xffaa00,
                    linewidth: 3,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    segments: 6,
                    deviation: 8,
                    jaggedIntensity: 0.8
                },
                animation: {
                    duration: 0.6,
                    flickerCount: 2,
                    flickerSpeed: 80,
                    fadeOut: true
                }
            }
        };
        
        return configs[type] || configs.lightning;
    }
    
    // Path generation (unchanged but more efficient)
    generateLinePath(start, end, type, style) {
        const points = [start.clone()];
        const segments = style.segments || 5;
        const deviation = style.deviation || 10;
        const jaggedIntensity = style.jaggedIntensity || 1;
        
        // Different path generation based on type
        if (type === 'arc') {
            return this.generateArcPath(start, end, style.arcHeight || 20, segments);
        }
        
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const basePos = start.clone().lerp(end, t);
            
            // Add jagged deviation
            if (deviation > 0 && jaggedIntensity > 0) {
                const actualDeviation = deviation * jaggedIntensity;
                basePos.x += (Math.random() - 0.5) * actualDeviation;
                basePos.y += (Math.random() - 0.5) * actualDeviation * 0.5;
                basePos.z += (Math.random() - 0.5) * actualDeviation;
            }
            
            points.push(basePos);
        }
        
        points.push(end.clone());
        return points;
    }
    
    generateArcPath(start, end, height, segments) {
        const points = [];
        const midPoint = start.clone().lerp(end, 0.5);
        midPoint.y += height;
        
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = this.quadraticBezier(start, midPoint, end, t);
            points.push(point);
        }
        
        return points;
    }
    
    quadraticBezier(p0, p1, p2, t) {
        const point = new THREE.Vector3();
        point.x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;
        point.y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;
        point.z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z + t * t * p2.z;
        return point;
    }
    
    // Clear effects efficiently
    clearAllEffects() {
        // Clear all active line effects
        for (const effect of this.activeEffects) {
            this.recycleEffect(effect);
        }
        this.activeEffects = [];
        
        // Clear all active auras
        if (this.activeAuras) {
            this.activeAuras.clear();
        }

        // Clear particle effects
        this.game.gameManager.call('clearAllParticles');

        // Clear notifications
        this.notifications.forEach(notification => {
            this.removeNotification(notification);
        });
        
        this.shakeActive = false;
        this.flashActive = false;
    }
    
    // Force cleanup with pool clearing
    forceCleanup() {
        this.clearAllEffects();
        
        // Clear pools
        for (const [key, pool] of this.geometryPool) {
            pool.forEach(geo => geo.dispose());
            pool.length = 0;
        }
        
        for (const [key, pool] of this.materialPool) {
            pool.forEach(mat => mat.dispose());
            pool.length = 0;
        }
        
        this.effectPool.length = 0;
        this.stats.pooledObjects = 0;
    }
    
    // Performance monitoring
    getPerformanceStats() {
        const poolSize = Array.from(this.geometryPool.values()).reduce((sum, pool) => sum + pool.length, 0) +
                        Array.from(this.materialPool.values()).reduce((sum, pool) => sum + pool.length, 0) +
                        this.effectPool.length;
        
        this.stats.pooledObjects = poolSize;
        
        return {
            ...this.stats,
            memoryUsage: {
                geometryPools: this.geometryPool.size,
                materialPools: this.materialPool.size,
                effectPool: this.effectPool.length
            }
        };
    }
    
    // Keep all existing particle and screen effect methods unchanged
    getEffectConfig(effectType) {
        const configs = {
            victory: {
                count: 5,
                shape: 'star',
                color: 0x00ff00,
                colorRange: { start: 0x00ff00, end: 0xffff00 },
                lifetime: 1.5,
                velocity: { speed: 8, spread: 0.5, pattern: 'burst' },
                scale: 2,
                scaleVariation: 0.3,
                physics: { gravity: -0.5, drag: 0.99 },
                rotation: { enabled: true, speed: 5 },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            },
            defeat: {
                count: 8,
                shape: 'spark',
                color: 0xff0000,
                colorRange: { start: 0xff0000, end: 0x440000 },
                lifetime: 2,
                velocity: { speed: 6, spread: 0.8, pattern: 'burst' },
                scale: 1.5,
                scaleVariation: 0.4,
                physics: { gravity: 0.3, drag: 0.95 },
                rotation: { enabled: true, speed: 3 },
                visual: { fadeOut: true, scaleOverTime: false, blending: 'normal' }
            },
            levelup: {
                count: 12,
                shape: 'glow',
                color: 0xffaa00,
                colorRange: { start: 0xffaa00, end: 0xffffff },
                lifetime: 2.5,
                velocity: { speed: 4, spread: 0.3, pattern: 'fountain' },
                scale: 3,
                scaleVariation: 0.2,
                physics: { gravity: -0.2, drag: 0.98 },
                rotation: { enabled: false },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            }
        };
        
        return configs[effectType] || configs.victory;
    }
    
    // Screen effects (unchanged)
    playScreenShake(duration = 0.3, intensity = 2) {
        if (this.shakeActive) return;
        
        const gameContainer = document.getElementById('gameContainer');
        if (!gameContainer) return;
        
        this.shakeActive = true;
        this.shakeData = {
            startTime: this.game.state.now,
            duration: duration, 
            intensity: intensity,
            originalTransform: gameContainer.style.transform
        };
    }

    playScreenFlash(color = '#ffffff', duration = 0.3) {
        // Disabled for now
        // if (this.flashActive) return;
        // return;
        // this.flashActive = true;
        // const flash = document.createElement('div');
        // flash.className = 'screen-flash';
        // flash.style.cssText = `
        //     position: fixed;
        //     top: 0;
        //     left: 0;
        //     width: 100%;
        //     height: 100%;
        //     background-color: ${color};
        //     pointer-events: none;
        //     z-index: 999;
        //     opacity: 0.6;
        // `;
        
        // document.body.appendChild(flash);
        
        // // Store flash data for game loop processing
        // this.flashData = {
        //     element: flash,
        //     startTime: this.game.state.now,
        //     duration: duration,
        //     startOpacity: 0.6
        // };
    }
    
    // Particle effects - delegate to particle system
    createParticleEffect(x, y, z, type, options = {}) {
        // Convert to the config format that ParticleSystem.createParticles expects
        const config = {
            position: new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z),
            count: options.count || 3,
            shape: options.shape || 'circle',
            color: options.color || 0xffffff,
            colorRange: options.colorRange || null,
            lifetime: options.lifetime || 1.5,
            velocity: options.velocity || { speed: 5, spread: 1, pattern: 'burst' },
            scale: (options.scaleMultiplier || 1) * 1.0,
            scaleVariation: options.scaleVariation || 0.5,
            physics: options.physics || { gravity: 0.5, drag: 0.98 },
            rotation: options.rotation || { enabled: false, speed: 0 },
            visual: options.visual || { fadeOut: true, scaleOverTime: true, blending: 'additive' }
        };

        this.game.gameManager.call('createParticles', config);
    }
    
    showVictoryEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'victory', options);
        this.playScreenFlash('#44ff44', 0.3);
        this.showGameNotification('Victory!', 'You won!', 'success', 2000);
    }
    
    showDefeatEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'defeat', options);
        this.playScreenFlash('#ff4444', 0.5);
        this.showGameNotification('Defeat!', 'You lost!', 'error', 2000);
    }
    
    showExplosionEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'explosion', options);
        this.playScreenShake(0.2, 3);
    }
    
    showHealEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'heal', options);
    }
    
    showMagicEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'magic', options);
    }
    
    showDamageEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'damage', options);
    }
    
    showLevelUpEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'levelup', options);
        this.playScreenShake(0.4, 1);
        this.showGameNotification('Level Up!', 'Character advanced!', 'success', 3000);
    }
    
    // Missing method that abilities are calling
    createAuraEffect(x, y, z, type, duration) {
        if (!this.game.particleSystem) return;
        const auraId = `aura_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const startTime = this.game.state.now;
        const position = new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z);
        
        // Create aura configuration
        const config = this.getEffectConfig(type);
        const auraData = {
            id: auraId,
            position: position.clone(),
            type: type,
            startTime: startTime,
            duration: duration,
            lastParticleTime: startTime,
            particleInterval: 1, // 1 second between particle bursts
            isActive: true,
            config: {
                count: 4,
                shape: 'circle',
                color: config.color || 0xffffff,
                colorRange: config.colorRange || null,
                lifetime: 2.0,
                velocity: { speed: 2, spread: 0.8, pattern: 'burst' },
                scale: (config.scale || 1) * 0.8,
                scaleVariation: 0.3,
                physics: { gravity: -0.1, drag: 0.98 },
                rotation: { enabled: true, speed: 1 },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            }
        };
        
        // Add to active auras tracking
        if (!this.activeAuras) {
            this.activeAuras = new Map();
        }
        this.activeAuras.set(auraId, auraData);
        
        return auraId;
    }
    
    // Missing methods that were in the original EffectsSystem
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `game-notification notification-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 1000;
            animation: notificationSlideIn 0.5s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        `;
        
        switch (type) {
            case 'victory':
                notification.style.background = 'linear-gradient(145deg, #001100, #003300)';
                notification.style.border = '2px solid #00ff00';
                notification.style.color = '#00ff00';
                notification.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                break;
            case 'defeat':
                notification.style.background = 'linear-gradient(145deg, #110000, #330000)';
                notification.style.border = '2px solid #ff0000';
                notification.style.color = '#ff4444';
                notification.style.textShadow = '0 0 10px rgba(255, 68, 68, 0.5)';
                break;
            case 'levelup':
                notification.style.background = 'linear-gradient(145deg, #111100, #333300)';
                notification.style.border = '2px solid #ffd700';
                notification.style.color = '#ffd700';
                notification.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                break;
            default:
                notification.style.background = 'linear-gradient(145deg, #001122, #003344)';
                notification.style.border = '2px solid #00aaff';
                notification.style.color = '#00aaff';
                notification.style.textShadow = '0 0 10px rgba(0, 170, 255, 0.5)';
        }
        
        document.body.appendChild(notification);
        this.notifications.push(notification);
        this.repositionNotifications();
        
        setTimeout(() => {
            this.removeNotification(notification);
        }, duration);
    }
    
    showGameNotification(title, message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `game-notification notification-${type}`;
        notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
            <div>${message}</div>
        `;
        
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid ${this.getNotificationColor(type)};
            max-width: 300px;
            z-index: 1001;
            animation: notificationSlideIn 0.3s ease-out;
        `;
        
        document.body.appendChild(notification);
        this.notifications.push(notification);
        
        setTimeout(() => {
            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                    const index = this.notifications.indexOf(notification);
                    if (index > -1) {
                        this.notifications.splice(index, 1);
                    }
                }
            }, 300);
        }, duration);
    }
    
    getNotificationColor(type) {
        const colors = {
            info: '#4444ff',
            success: '#44ff44',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        return colors[type] || '#4444ff';
    }
    
    removeNotification(notification) {
        if (document.body.contains(notification)) {
            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
                const index = this.notifications.indexOf(notification);
                if (index > -1) {
                    this.notifications.splice(index, 1);
                }
                this.repositionNotifications();
            }, 300);
        }
    }
    
    repositionNotifications() {
        this.notifications.forEach((notification, index) => {
            notification.style.top = `${20 + index * 80}px`;
        });
    }
    
    getDamageColor(type) {
        switch (type) {
            case 'heal': return 0x00ff88;
            case 'critical': return 0xff0044;
            case 'poison': return 0x8a2be2;
            case 'fire': return 0xff4400;
            case 'cold': return 0x00bfff;
            case 'lightning': return 0xffff00;
            case 'divine': return 0xffd700;
            default: return 0xff4444;
        }
    }
    
    addEffectsCSS() {
        const style = document.createElement('style');
        style.id = 'effects-styles';
        style.textContent = `
            .screen-flash {
                transition: opacity 0.3s ease-out;
            }
            
            @keyframes battleStartTransition {
                0% { transform: translateX(-100%); }
                100% { transform: translateX(100%); }
            }
            
            @keyframes flashFade {
                0% { opacity: 0.6; }
                100% { opacity: 0; }
            }
            
            @keyframes notificationSlideIn {
                from { 
                    transform: translateX(100%);
                    opacity: 0; 
                }
                to { 
                    transform: translateX(0);
                    opacity: 1; 
                }
            }
            
            @keyframes notificationSlideOut {
                from { 
                    transform: translateX(0);
                    opacity: 1; 
                }
                to { 
                    transform: translateX(100%);
                    opacity: 0; 
                }
            }
            
            .game-notification {
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(5px);
            }
        `;
        document.head.appendChild(style);
    }
    
    // Main update method called by game loop
    update() {
        this.updateAllEffects();
        this.updateAuras(); 
        this.updateScreenEffects();
    }
    
    updateAuras() {
        if (!this.activeAuras || !this.game.state) return;
        
        const currentTime = this.game.state.now;
        const aurasToRemove = [];
        
        for (const [auraId, auraData] of this.activeAuras) {
            const elapsed = currentTime - auraData.startTime;
            
            // Check if aura has expired
            if (elapsed >= auraData.duration) {
                aurasToRemove.push(auraId);
                continue;
            }
            
            // Check if it's time to create new particles
            const timeSinceLastParticle = currentTime - auraData.lastParticleTime;
            if (timeSinceLastParticle >= auraData.particleInterval) {
                this.createAuraParticles(auraData);
                auraData.lastParticleTime = currentTime;
            }
        }
        
        // Remove expired auras
        aurasToRemove.forEach(auraId => {
            this.activeAuras.delete(auraId);
        });
    }
    
    updateScreenEffects() {
        // Handle screen shake
        if (this.shakeActive && this.shakeData) {
            const gameContainer = document.getElementById('gameContainer');
            if (!gameContainer) {
                this.shakeActive = false;
                return;
            }
            
            const elapsed = this.game.state.now - this.shakeData.startTime;
            const progress = elapsed / this.shakeData.duration;
            
            if (progress >= 1) {
                gameContainer.style.transform = this.shakeData.originalTransform;
                this.shakeActive = false;
                this.shakeData = null;
            } else {
                const diminishingIntensity = this.shakeData.intensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * diminishingIntensity;
                const shakeY = (Math.random() - 0.5) * diminishingIntensity;
                gameContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            }
        }
        
        // Handle screen flash
        if (this.flashActive && this.flashData) {
            const elapsed = this.game.state.now - this.flashData.startTime;
            const progress = elapsed / this.flashData.duration;
            
            if (progress >= 1) {
                // Flash finished
                if (document.body.contains(this.flashData.element)) {
                    document.body.removeChild(this.flashData.element);
                }
                this.flashActive = false;
                this.flashData = null;
            } else {
                // Fade out the flash
                const opacity = this.flashData.startOpacity * (1 - progress);
                this.flashData.element.style.opacity = opacity;
            }
        }
    }
    
    createAuraParticles(auraData) {
        const particleConfig = {
            position: auraData.position,
            ...auraData.config
        };

        this.game.gameManager.call('createParticles', particleConfig);
    }
    
    destroy() {
        this.forceCleanup();
        
        // Clean up damage number system
        if (this.damageNumberMesh) {
            this.game.scene.remove(this.damageNumberMesh);
            this.damageTextGeometry.dispose();
            this.damageTextMaterial.dispose();
            this.damageTexture.dispose();
        }
        
        const styleElement = document.querySelector('#effects-styles');
        if (styleElement) {
            styleElement.remove();
        }
        
        console.log('EffectsSystem destroyed');
    }
    
    entityDestroyed(entityId) {
        // Clean up any auras associated with this entity
        if (this.activeAuras) {
            const aurasToRemove = [];
            for (const [auraId, auraData] of this.activeAuras) {
                if (auraData.sourceEntityId === entityId || auraData.targetEntityId === entityId) {
                    aurasToRemove.push(auraId);
                }
            }
            aurasToRemove.forEach(auraId => this.activeAuras.delete(auraId));
        }
        
        // Clean up any particle effects tracking
        if (this.entityEffects) {
            this.entityEffects.delete(entityId);
        }
    }
};

// system: GridSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GridSystem'] = class GridSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.gridSystem = this;
        
        this.state = new Map();

        // NEW: track which half each team owns
        this.teamSides = { player: 'left', enemy: 'right' };
        this.leftBounds = null;
        this.rightBounds = null;
    }
    
    init() {
        this.game.gameManager.register('getNearbyUnits', this.getNearbyUnits.bind(this));
        this.game.gameManager.register('convertGridToWorldPosition', this.gridToWorld.bind(this));
        this.game.gameManager.register('convertWorldToGridPosition', this.worldToGrid.bind(this));
        this.game.gameManager.register('isValidGridPlacement', this.isValidGridPlacement.bind(this));
        this.game.gameManager.register('reserveGridCells', this.occupyCells.bind(this));
        this.game.gameManager.register('releaseGridCells', this.freeCells.bind(this));
        this.game.gameManager.register('getUnitGridCells', this.getUnitCells.bind(this));

        const collections = this.game.getCollections();

        const terrainGridSize = collections.configs.game.gridSize;
        const placementGridSize = terrainGridSize / 2; // Placement grid is always half the terrain grid
        const currentLevel = collections.configs.state.level;
        const terrainSize = collections.levels[currentLevel]?.tileMap?.size * terrainGridSize;

        this.cellSize = placementGridSize;
        this.terrainGridSize = terrainGridSize;
        this.showGrid = true;
        this.snapToGrid = true;
        this.highlightValidCells = true;
        
        this.dimensions = {
            width: Math.floor(terrainSize / placementGridSize),
            height: Math.floor(terrainSize / placementGridSize),
            cellSize: placementGridSize,
            startX: -terrainSize / 2,
            startZ: -terrainSize / 2
        };
        console.log("dimensions", this.dimensions);
        
        this.gridVisualization = null;

        // Compute half-splits once
        const half = Math.floor(this.dimensions.width / 2);
        this.leftBounds = {
            minX: 0,
            maxX: half - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };
        this.rightBounds = {
            minX: half,
            maxX: this.dimensions.width - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };

        // Default: player=left, enemy=right (can be swapped later)
        this.playerBounds = this.leftBounds;
        this.enemyBounds  = this.rightBounds;
        
        // Pre-calculate world bounds for faster collision detection
        this.worldBounds = {
            minX: this.dimensions.startX,
            maxX: this.dimensions.startX + (this.dimensions.width * placementGridSize),
            minZ: this.dimensions.startZ,
            maxZ: this.dimensions.startZ + (this.dimensions.height * placementGridSize)
        };
    }

    // NEW: set which half each team owns (call this when you learn sides from the server)
    setTeamSides(sides) {
        if (sides?.player === 'left' || sides?.player === 'right') {
            this.teamSides.player = sides.player;
        }
        if (sides?.enemy === 'left' || sides?.enemy === 'right') {
            this.teamSides.enemy = sides.enemy;
        }

        // Point player/enemy bounds at the correct half
        this.playerBounds = (this.teamSides.player === 'left') ? this.leftBounds : this.rightBounds;
        this.enemyBounds  = (this.teamSides.enemy  === 'left') ? this.leftBounds : this.rightBounds;

    }
    
    createVisualization(scene) {
        if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
        }
        
        const group = new THREE.Group();
        const { width, height, cellSize, startX, startZ } = this.dimensions;
        
        // Use BufferGeometry for better performance
        const linePositions = [];
        
        // Vertical lines
        for (let x = 0; x <= width; x++) {
            const worldX = startX + (x * cellSize);
            linePositions.push(
                worldX, 1, startZ,
                worldX, 1, startZ + (height * cellSize)
            );
        }
        
        // Horizontal lines
        for (let z = 0; z <= height; z++) {
            const worldZ = startZ + (z * cellSize);
            linePositions.push(
                startX, 1, worldZ,
                startX + (width * cellSize), 1, worldZ
            );
        }
        
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x444444, 
            transparent: true, 
            opacity: 0.3 
        });
        
        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        group.add(lines);
        
        // Center divider line
        const dividerPositions = [
            startX + (width * cellSize / 2), 2, startZ,
            startX + (width * cellSize / 2), 2, startZ + (height * cellSize)
        ];
        
        const dividerGeometry = new THREE.BufferGeometry();
        dividerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dividerPositions, 3));
        
        const dividerMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0.5 
        });
        
        const dividerLine = new THREE.LineSegments(dividerGeometry, dividerMaterial);
        group.add(dividerLine);
        
        this.gridVisualization = group;
        scene.add(this.gridVisualization);
    }
    
    worldToGrid(worldX, worldZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: Math.floor((worldX - startX) / cellSize),
            z: Math.floor((worldZ - startZ) / cellSize)
        };
    }
    
    gridToWorld(gridX, gridZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: startX + (gridX * cellSize),
            z: startZ + (gridZ * cellSize)
        };
    }
    
    // OPTIMIZED: Early bounds checking
    isValidPosition(gridPos) {
        return gridPos.x >= 0 && gridPos.x < this.dimensions.width &&
               gridPos.z >= 0 && gridPos.z < this.dimensions.height;
    }

    isValidGridPlacement(cells, team) {
        if (!cells || cells.length === 0) return false;
        
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            const cellState = this.state.get(key);
            if (cellState && cellState.occupied) {
                return false;
            }
        }

        
        return true;
    }

    getUnitCells(entityId) {

        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
        const pos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);

        if(!unitType) return null;
        const cells = [];

        // For buildings, convert footprint (terrain grid units) to placement grid cells
        // For units, use placementGridWidth/Height directly (already in placement grid units)
        let placementGridWidth, placementGridHeight;

        if (unitType.collection === 'buildings') {
            // Buildings use footprint in terrain grid units, convert to placement grid cells (2x)
            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 1;
            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 1;
            placementGridWidth = footprintWidth * 2;
            placementGridHeight = footprintHeight * 2;
        } else {
            // Units use placement grid units directly
            placementGridWidth = unitType.placementGridWidth || 1;
            placementGridHeight = unitType.placementGridHeight || 1;
        }

        const gridPos = this.worldToGrid(pos.x, pos.z);
        // Calculate starting position to center the formation
        const startX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);
        for (let x = 0; x < placementGridWidth; x++) {
            for (let z = 0; z < placementGridHeight; z++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    getNearbyUnits(pos, radius, excludeEntityId = null, collection = null) {
        const gridPos = this.worldToGrid(pos.x, pos.z);
        const cellRadius = Math.ceil(radius / this.cellSize);
        
        const nearbyUnits = [];
        const radiusSq = radius * radius;
        const seen = new Set(); // Prevent duplicates

        for (let gz = gridPos.z - cellRadius; gz <= gridPos.z + cellRadius; gz++) {
            for (let gx = gridPos.x - cellRadius; gx <= gridPos.x + cellRadius; gx++) {
                if (!this.isValidPosition({ x: gx, z: gz })) continue;
                
                const cellState = this.getCellState(gx, gz);
                if (!cellState?.entities?.length) continue;

                for (const entityId of cellState.entities) {
                    if (entityId === excludeEntityId || seen.has(entityId)) continue;

                    const entityPos = this.game.getComponent(entityId, this.game.componentTypes.POSITION);
                    const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
                    
                    if (!entityPos || !unitType) continue;

                    const dx = entityPos.x - pos.x;
                    const dz = entityPos.z - pos.z;
                    const distSq = dx * dx + dz * dz;
                    
                    if(collection && unitType.collection != collection) continue;

                    if (distSq <= radiusSq) {
                        seen.add(entityId);
                        nearbyUnits.push({
                            x: entityPos.x,
                            z: entityPos.z,
                            y: entityPos.y,
                            id: entityId,
                            ...unitType
                        });
                    }
                }
            }
        }
        return nearbyUnits.sort((a, b) => a.id.localeCompare(b.id));
    }

    onEntityPositionUpdated(entityId) {
        const cells = this.getUnitCells(entityId);
        this.freeCells(entityId);
        this.occupyCells(cells, entityId);
    }

    occupyCells(cells, entityId) {       
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            let cellState = this.state.get(key);

            if (!cellState) {
                cellState = { occupied: true, entities: [] };
                this.state.set(key, cellState);
            }

            // Add entity if not already present
            if (!cellState.entities.includes(entityId)) {
                cellState.entities.push(entityId);
            }
            cellState.entities.sort((a, b) => a.localeCompare(b));     
        }           
    }
        
    freeCells(entityId) {
        for (const [key, cellState] of this.state.entries()) {
            if (cellState.entities.includes(entityId)) {
                cellState.entities = cellState.entities.filter(id => id !== entityId);
                
                // Clean up empty cell
                if (cellState.entities.length === 0) {
                    this.state.delete(key);
                } else {                    
                    cellState.entities.sort((a, b) => a.localeCompare(b));
                }
            }
        }
    }

    clear() {
        console.log('grid system cleared');
        this.state.clear();
    }
    
    toggleVisibility(scene) {
        this.showGrid = !this.showGrid;
        
        if (this.showGrid) {
            this.createVisualization(scene);
        } else if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
            this.gridVisualization = null;
        }
    }
    
    getBounds(team) {
        // Keep API compatibility; these references are updated by setTeamSides()
        return team === 'right' ? this.rightBounds : this.leftBounds;
    }
        
    getCellState(gridX, gridZ) {
        return this.state.get(`${gridX},${gridZ}`);
    }

    getOccupiedCells() {
        return Array.from(this.state.entries()).map(([key, value]) => {
            const [x, z] = key.split(',').map(Number);
            return { x, z, ...value };
        });
    }
    
    getGridInfo() {
        return {
            dimensions: this.dimensions,
            leftBounds: this.leftBounds,
            rightBounds: this.rightBounds,
            teamSides: { ...this.teamSides },
            occupiedCells: this.getOccupiedCells(),
            totalCells: this.dimensions.width * this.dimensions.height,
            occupiedCount: this.state.size
        };
    }
    
    // OPTIMIZED: Batch cell queries for better performance
    areCellsOccupied(cells) {
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            if (this.state.has(key)) {
                return true;
            }
        }
        return false;
    }

    onDestroyBuilding(entityId){ 
        this.freeCells(entityId);
    }

    onUnitKilled(entityId){  
        this.freeCells(entityId);
    }

    
    // OPTIMIZED: Fast world bounds check
    isInWorldBounds(worldX, worldZ) {
        return worldX >= this.worldBounds.minX && worldX <= this.worldBounds.maxX &&
               worldZ >= this.worldBounds.minZ && worldZ <= this.worldBounds.maxZ;
    }
};

// system: MultiplayerPlacementSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MultiplayerPlacementSystem'] = class MultiplayerPlacementSystem extends engine.BaseSystem {
    constructor(game, sceneManager) {
        super(game);
        this.sceneManager = sceneManager;
        this.game.placementSystem = this;
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.canvas = this.game.canvas;
        
        this.playerPlacements = [];
        this.opponentPlacements = [];        
        this.undoStack = [];
        this.maxUndoSteps = 10;
        
        this.game.state.targetPositions = new Map();
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;
        
        this.lastMouseMoveTime = 0;
        this.lastValidationTime = 0;
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        this.lastUpdateTime = 0;
        this.config = {
            maxSquadsPerRound: 2,
            enablePreview: true,
            enableUndo: true,
            validationThrottle: .32
        };
        this.elements = {};
        this.mouseWorldOffset = { x: 0, z: 0 };
        this.mouseWorldPos = { x: 0, y: 0, z: 0 };
        this.mouseScreenPos = { x: 0, y: 0 };
    }

    init(params) {
        this.params = params || {};

        this.game.gameManager.register('getPlacementById', this.getPlacementById.bind(this));
        this.game.gameManager.register('getPlacementsForSide', this.getPlacementsForSide.bind(this));
        this.game.gameManager.register('createPlacementData', this.createPlacementData.bind(this));
        this.game.gameManager.register('placeSquadOnBattlefield', this.placeSquad.bind(this));
        this.game.gameManager.register('getOpponentPlacements', () => this.opponentPlacements);
        this.game.gameManager.register('getWorldPositionFromMouse', () => this.mouseWorldPos);
        this.mouseWorldOffset = { x: this.game.getCollections().configs.game.gridSize / 4, z: this.game.getCollections().configs.game.gridSize / 4 };

    }

    setupEventListeners() {
        
        this.elements.readyButton = document.getElementById('placementReadyBtn');
        this.elements.undoButton = document.getElementById('undoBtn');

        this.elements.readyButton.addEventListener('click', () => {
            this.togglePlacementReady();
        });
        
        this.elements.undoButton.addEventListener('click', () => {
            this.undoLastPlacement();

            this.elements.undoButton.style.transform = 'scale(0.95)';
            setTimeout(() => {
                this.elements.undoButton.style.transform = 'scale(1)';
            }, 150);
            
            this.game.gameManager.call('showNotification', 'â†¶ Last deployment undone', 'info', 2000);
         
        });
        
        this.elements.undoButton.addEventListener('mouseenter', () => {
            if (!this.elements.undoButton.disabled) {
                this.elements.undoButton.style.background = 'linear-gradient(135deg, #616161, #757575)';
                this.elements.undoButton.style.transform = 'translateY(-2px)';
                this.elements.undoButton.style.boxShadow = '0 4px 12px rgba(117, 117, 117, 0.3)';
            }
        });
        
        this.elements.undoButton.addEventListener('mouseleave', () => {
            if (!this.elements.undoButton.disabled) {
                this.elements.undoButton.style.background = 'linear-gradient(135deg, var(--stone-gray), #616161)';
                this.elements.undoButton.style.transform = 'translateY(0)';
                this.elements.undoButton.style.boxShadow = 'none';
            }
        });
        if (this.config.enableUndo) {
            document.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
                    event.preventDefault();
                    this.undoLastPlacement();
                }
            });
        }

        if (this.config.enablePreview && this.placementPreview) {       
            
            this.canvas.addEventListener('mousemove', (event) => {
                const rect = this.canvas.getBoundingClientRect();
                this.mouseScreenPos.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouseScreenPos.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;    
            });
            
            this.canvas.addEventListener('mouseleave', () => {                
                this.placementPreview.clear();
                this.cachedValidation = null;
                this.cachedGridPos = null;
                document.body.style.cursor = 'default';
            });
        }
        
        this.mouseRayCastInterval = setInterval(() => {                    
            
            this.mouseWorldPos = this.rayCastGround(this.mouseScreenPos.x, this.mouseScreenPos.y);
            this.mouseWorldPos.x += this.mouseWorldOffset.x;
            this.mouseWorldPos.z += this.mouseWorldOffset.z;
            if (this.game.state.phase === 'placement' && 
                this.game.state.selectedUnitType) {
                this.updatePlacementPreview();
            }
                            
        }, 100);
        
    }

    initializeSubsystems() {
       
        this.squadManager = this.game.squadManager;
        this.unitCreator = this.game.unitCreationManager;
         
        if (this.config.enablePreview) {
            this.placementPreview = new GUTS.PlacementPreview(this.game);
        }
        
        this.groundMeshCache = this.findGroundMesh();
    }

    onGameStarted() {
        this.initializeSubsystems();
        this.setupEventListeners();
        this.getStartingState();
        this.onPlacementPhaseStart();
    }

    getStartingState() {
         this.game.networkManager.getStartingState((success, response) => {
            if(success){
                const buildingTypes = this.game.getCollections().buildings;
                const unitTypes = this.game.getCollections().buildings;
                response.startingUnits.forEach((unitData) => {
                    const unitId = unitData.type;
                    const unitPos = unitData.position;
                    const collection = this.game.getCollections()[unitData.collection];
                    if(collection){
                        const unitDef = collection[unitId];
                        const placementData = { id: unitId, collection: unitData.collection, ...unitDef };       
                        const placement = this.createPlacementData(unitPos, placementData, this.game.state.mySide);
                        placement.isStartingState = true;
                        this.game.networkManager.submitPlacement(placement, (success, response) => {
                            if(success){
                                this.placeSquad(placement);
                                if(placement.unitType.collection == "buildings"){
                                    this.game.gameManager.call('addBuilding', placement.unitType.id, placement.squadUnits[0]);
                                }
                            }
                        });            
                    }          
                });
                const pos = response.camera.position;
                const look = response.camera.lookAt;
                this.game.camera.position.set(pos.x, pos.y, pos.z);
                this.game.camera.lookAt(look.x, look.y, look.z);
            }
        });   
    }

    getPlacementsForSide(side){
        if(side == this.game.state.mySide){
            return this.playerPlacements;
        } else {
            return this.opponentPlacements;
        }
    }

    onPlacementPhaseStart() {
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;

        this.game.gameManager.call('resetShop');
        this.game.gameManager.call('clearAllDamageEffects');
        this.game.gameManager.call('clearAllEffects');

        this.enablePlacementUI();
        this.elements.readyButton.textContent = 'Ready for Battle';
    }
    
    respawnEnemyUnits() {
        this.respawnSquads(this.opponentPlacements, this.game.state.mySide == 'left' ? 'right' : 'left');
    }
          
    getTotalUnitCount(placements) {
        return placements.reduce((sum, placement) => {
            return sum + (placement.isSquad ? placement.squadUnits.length : 1);
        }, 0);
    }     
    
    createRespawnEffect(position, team) {
        const effectType = team === 'player' ? 'magic' : 'heal';
        this.game.gameManager.call('createParticleEffect',
            position.x,
            position.y,
            position.z,
            effectType,
            { count: 3, speedMultiplier: 0.6 }
        );
    }
        
    enablePlacementUI() {
        this.elements.readyButton.disabled = false;   
        this.elements.undoButton.disabled = false;      
    }
        
    disablePlacementUI() {
        this.elements.readyButton.disabled = true; 
        this.elements.undoButton.disabled = true;        
    }

    updatePlacementUI() {
        if (this.elements.undoButton) {
            this.elements.undoButton.disabled = this.undoStack.length === 0;
            this.elements.undoButton.style.opacity = this.undoStack.length === 0 ? '0.5' : '1';
        }
    }

    togglePlacementReady(callback) {
        if (this.elements.readyButton) {
            this.elements.readyButton.disabled = true;
            this.elements.readyButton.textContent = 'Updating...';
        }
        this.game.networkManager.toggleReadyForBattle((success, response) => {
            if(success){
                this.hasSubmittedPlacements = true;
                this.elements.readyButton.textContent = 'Waiting for Opponent...';
            } else {
                if (this.elements.readyButton) {
                    this.elements.readyButton.disabled = false;
                    this.elements.readyButton.textContent = 'Ready for Battle';
                }
            }
        });
    }

    handleReadyForBattleUpdate(data) {
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.playerId === myPlayerId) {
            this.isPlayerReady = data.ready;
            this.updatePlacementUI();
        } 
        
        if (data.allReady) {
            let opponentPlacements = null;
            data.gameState.players.forEach((player) => {
                if(player.id != myPlayerId){
                    opponentPlacements = player.placements;
                }
            });
            this.applyOpponentPlacements(opponentPlacements);
            this.applyTargetPositions();
            this.game.state.phase = 'battle';
            this.game.triggerEvent("onBattleStart");
            this.game.resetCurrentTime();
            this.resetAI();
            this.game.desyncDebugger.enabled = true;
            this.game.desyncDebugger.displaySync(true);
            if (this.elements.readyButton) {
                this.elements.readyButton.disabled = true;
                this.elements.readyButton.textContent = 'Battling!';
            }
        } else {
            const opponentReady = data.gameState?.players?.find(p => p.id !== myPlayerId)?.ready;
            if (opponentReady) {
                this.game.gameManager.call('showNotification', 'Opponent is ready for battle!', 'info');
            }
        }
    }

    resetAI() {
        const componentTypes = this.game.componentManager.getComponentTypes();            
        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      
        AIEntities.forEach((entityId) => {
            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);
            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
            combat.lastAttack = 0;
            aiState.aiBehavior = {};
        });
    }

    applyTargetPositions(){
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const allPlacements = [...this.playerPlacements, ...this.opponentPlacements];
        allPlacements.forEach((placement) => {
            placement.squadUnits.forEach(entityId => {
                const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                if (aiState && position) {
                    let targetPosition = aiState.targetPosition;
                    let meta = aiState.meta;
                    let tempMoveOrders = this.game.gameManager.call('getTemporaryOpponentMoveOrders').get(placement.placementId);
                    if(tempMoveOrders){
                        targetPosition = tempMoveOrders.targetPosition;
                        meta = tempMoveOrders.meta;
                        this.game.gameManager.call('deleteTemporaryOpponentMoveOrder', placement.placementId);                    
                    }
                    if(targetPosition){
                        const currentAIController = this.game.gameManager.call('getCurrentAIControllerId', entityId);

                        if(!currentAIController || currentAIController == "UnitOrderSystem"){
                            const dx = position.x - targetPosition.x;
                            const dz = position.z - targetPosition.z;
                            const distSq = dx * dx + dz * dz;
                            const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;
                            const threshold = placementGridSize * 0.5;

                            if (distSq <= threshold * threshold) {
                                this.game.gameManager.call('removeCurrentAIController', entityId);
                                placement.targetPosition = null;
                            } else {
                                let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, "UnitOrderSystem");
                                currentOrderAI.targetPosition = targetPosition;
                                currentOrderAI.path = [];
                                  if(entityId == "peasant_1224_1368_right_1"){
                                    console.log("applyTargetPositions");
                                }
                                currentOrderAI.meta = { ...meta };
                                this.game.gameManager.call('setCurrentAIController', entityId, "UnitOrderSystem", currentOrderAI);
                            }
                        }
                    }                    
                }
            });
        });
    }

    update() {
        if (this.game.state.phase !== 'placement') {
            this.lastRaycastTime = 0;
            this.lastValidationTime = 0;
            this.lastUpdateTime = 0;            
            this.disablePlacementUI();
            return;
        }
        
        if (this.game.state.now - this.lastValidationTime > this.config.validationThrottle) {
            this.updateCursorState();
            this.updatePlacementUI();
            this.lastValidationTime = this.game.state.now;
        }
    }

    applyOpponentPlacements(opponentData) {
        opponentData.forEach(placement => {
            if(this.game.gameManager.call('getOpponentPlacements').find(p => p.placementId === placement.placementId)) {
                return;
            }
            this.placeSquad(placement);         
        });

        if (this.game.state) {
            this.game.state.enemyPlacementComplete = true;
        }
    }

    createEnemyFromOpponentPlacement(opponentPlacement) {
        this.game.gameManager.call('setSquadInfo', opponentPlacement.placementId, opponentPlacement.experience);

        if (this.game.squadManager && this.game.unitCreationManager) {
            const unitPositions = this.game.squadManager.calculateUnitPositions(
                opponentPlacement.gridPosition,
                opponentPlacement.unitType
            );

            let squadUnits = [];
            unitPositions.forEach((pos, index) => {
                const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
                const unitY = terrainHeight !== null ? terrainHeight : 0;

                let entityId = this.game.unitCreationManager.create(
                    pos.x,
                    unitY,
                    pos.z,
                    opponentPlacement.targetPosition,
                    opponentPlacement,
                    this.game.state.mySide == 'right' ? 'left' : 'right'
                );
                if (opponentPlacement.unitType.id === 'goldMine') {
                    // Convert footprint (terrain grid units) to placement grid cells
                    const footprintWidth = opponentPlacement.unitType.footprintWidth || opponentPlacement.unitType.placementGridWidth || 2;
                    const footprintHeight = opponentPlacement.unitType.footprintHeight || opponentPlacement.unitType.placementGridHeight || 2;
                    const gridWidth = footprintWidth * 2;
                    const gridHeight = footprintHeight * 2;

                    const opponentSide = this.game.state.mySide === 'right' ? 'left' : 'right';

                    this.game.gameManager.call('buildGoldMine',
                        entityId,
                        opponentSide,
                        opponentPlacement.gridPosition,
                        gridWidth,
                        gridHeight
                    );
                }                
                this.game.gameManager.call('reserveGridCells', opponentPlacement.cells, entityId);
                squadUnits.push(entityId);
            });
            opponentPlacement.squadUnits = squadUnits;
        }

  

        this.opponentPlacements.push(opponentPlacement);
    }

    handleUnitSelectionChange() {
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.cachedWorldPos = null;
        this.lastMouseX = null;
        this.lastMouseY = null;
        this.lastRaycastTime = null;
        this.lastRaycastMouseX = null;
        this.lastRaycastMouseY = null;
        this.approximateWorldScale = null;
        this.previousWorldPos = null;
        this.previousMouseX = null;
        this.previousMouseY = null;
        
        if (this.squadValidationCache) {
            this.squadValidationCache.clear();
        }
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }
        
        document.body.style.cursor = 'default';
    }

    onActivateBuildingPlacement(){
        this.handleUnitSelectionChange();
    }

    handleCanvasClick(event) {
        const state = this.game.state;
        
        if (this.settingTargetPosition) {
            return;
        }
        
        if (state.phase !== 'placement') {
            return;
        }
        if(!state.selectedUnitType) {
            return;
        }
        
        if (this.isPlayerReady) {
            return;
        }
        
        if (!this.canPlayerPlaceSquad()) {
            return;
        }
        
        if (state.playerGold < state.selectedUnitType.value) {
            return;
        }
        if (this.game.supplySystem && !this.game.supplySystem.canAffordSupply(this.game.state.mySide, state.selectedUnitType)) {
            console.log('Not enough supply to place this unit');
            return;
        }

        let gridPos = this.game.gameManager.call('convertWorldToGridPosition', this.mouseWorldPos.x, this.mouseWorldPos.z);

        let isValidPlacement = this.isValidGridPlacement(this.mouseWorldPos);
       
        if (!isValidPlacement) {
            return;
        }
    
        if (this.game.squadManager) {
            const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
        
            if (!validation.valid) {
                return;
            }
        }
        
        const placement = this.createPlacementData(gridPos, state.selectedUnitType, this.game.state.mySide);

        this.game.networkManager.submitPlacement(placement, (success, response) => {
            if(success){
                this.placeSquad(placement);
            }
        });        
    }

    canPlayerPlaceSquad() {
        return true;
    }

    placeSquad(placement) {
        const unitPositions = this.game.squadManager.calculateUnitPositions(placement.gridPosition, placement.unitType);
        const undoInfo = this.createUndoInfo(placement);
        
        const squadUnits = this.createSquadUnits(placement, unitPositions, placement.team, undoInfo);
        placement.squadUnits = squadUnits;
        placement.isSquad = squadUnits.length > 1;
        this.updateGameStateForPlacement(placement, undoInfo);

        this.game.gameManager.call('initializeSquad', placement.placementId, placement.unitType, squadUnits, placement.team);

        if (squadUnits.length <= 8) {
            this.createPlacementEffects(unitPositions.slice(0, 8), placement.team);
        }
        
        this.cachedValidation = null;
        this.cachedGridPos = null;
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }

        this.game.state.selectedUnitType = null;
        this.handleUnitSelectionChange();
        
        return placement;
    }

    createSquadUnits(placement, unitPositions, team, undoInfo) {
        const createdUnits = [];
        
        const maxUnits = Math.min(unitPositions.length, 16);
        const positions = unitPositions.slice(0, maxUnits);
        
        positions.forEach(pos => {
            const terrainHeight = this.game.gameManager.call('getTerrainHeightAtPosition', pos.x, pos.z) || 0;
            const unitY = terrainHeight !== null ? terrainHeight : 0;

            const entityId = this.game.unitCreationManager.create(pos.x, unitY, pos.z, pos, placement, team);
            createdUnits.push(entityId);
            undoInfo.unitIds.push(entityId);

            this.game.gameManager.call('reserveGridCells', placement.cells, entityId);

            if(placement.unitType.id == 'goldMine'){
                // Convert footprint (terrain grid units) to placement grid cells
                const footprintWidth = placement.unitType.footprintWidth || placement.unitType.placementGridWidth || 2;
                const footprintHeight = placement.unitType.footprintHeight || placement.unitType.placementGridHeight || 2;
                const gridWidth = footprintWidth * 2;
                const gridHeight = footprintHeight * 2;
                this.game.gameManager.call('buildGoldMine', entityId, team, placement.gridPosition, gridWidth, gridHeight);
            }
            if (placement.peasantInfo && placement.collection === 'buildings') {
                const peasantInfo = placement.peasantInfo;
                const peasantId = peasantInfo.peasantId;
                const peasantAbilities = this.game.gameManager.call('getEntityAbilities', peasantId);
                if (peasantAbilities) {
                    const buildAbility = peasantAbilities.find(a => a.id === 'build');
                    if (buildAbility) {
                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);
                    }
                }
                
                this.game.state.peasantBuildingPlacement = null;
            }
        });
        
        return createdUnits;
    }

    createUndoInfo(placement) {
        return {
            type: 'squad_placement',
            placementId: placement.placementId,
            collection: placement.collection,
            unitType: { ...placement.unitType },
            cost: placement.unitType.value || 0,
            gridPosition: { ...placement.gridPosition },
            cells: [...placement.cells],
            unitIds: [],
            team: this.game.state.mySide,
            timestamp: this.game.state.now
        };
    }

    createPlacementData(gridPos, unitType, team) {
        const squadData = this.game.squadManager.getSquadData(unitType);
        const cells = this.game.squadManager.getSquadCells(gridPos, squadData);
        
        const placementId = `squad_${team}_${gridPos.x}_${gridPos.z}_${this.game.state.round}`;
        return {
            placementId: placementId,
            gridPosition: gridPos,
            cells: cells,
            collection: unitType.collection,
            unitType: { ...unitType },
            squadUnits: [],
            team: team,
            targetPosition: this.game.state.targetPositions.get(placementId),
            roundPlaced: this.game.state.round,
            timestamp: this.game.state.now,
            peasantInfo: this.game.state.peasantBuildingPlacement
        };
    }

    updateGameStateForPlacement(placement, undoInfo) {                
        if (this.isMyTeam(placement.team)) {
            this.addToUndoStack(undoInfo);
            if(!placement.isStartingState){
                this.game.state.playerGold -= (placement.unitType.value || 0);
            }
            this.playerPlacements.push(placement);
        } else {
            this.opponentPlacements.push(placement);
        }
    }

    setPlacementExperience(placements) {
        if (placements) {
            placements.forEach(placement => {
                if (placement.experience && placement.placementId) {
                    const experienceData = placement.experience;
                    let squadData = this.game.gameManager.call('getSquadInfo', placement.placementId);
                    
                    if (squadData) {
                        squadData.level = experienceData.level;
                        squadData.experience = experienceData.experience;
                        squadData.experienceToNextLevel = experienceData.experienceToNextLevel;
                        squadData.canLevelUp = experienceData.canLevelUp;                    
                    }
                }
            });            
        }
    }

    isMyTeam(team){
        return team == this.game.state.mySide;
    }

    createPlacementEffects(unitPositions, team) {
        const effectType = this.isMyTeam(team) ? 'magic' : 'defeat';
        const maxEffects = Math.min(unitPositions.length, 6);

        for (let i = 0; i < maxEffects; i++) {
            const pos = unitPositions[i];
            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
            const unitY = terrainHeight !== null ? terrainHeight : 0;

            this.game.gameManager.call('createParticleEffect',
                pos.x,
                unitY,
                pos.z,
                effectType,
                { count: 3, speedMultiplier: 0.8 }
            );
        }
    }

    undoLastPlacement() {
        if (!this.config.enableUndo) return;
        
        const state = this.game.state;
        
        if (state.phase !== 'placement') {
            return;
        }
        
        if (this.isPlayerReady) {
            return;
        }
        
        if (this.undoStack.length === 0) {
            return;
        }
        
        const undoInfo = this.undoStack.pop();

        try {
            undoInfo.unitIds.forEach(entityId => {
                if (this.game.destroyEntity) {
                    this.game.destroyEntity(entityId);
                }
            });

            state.playerGold += undoInfo.cost;

            const placementIndex = this.playerPlacements.findIndex(p => p.placementId === undoInfo.placementId);
            if (placementIndex !== -1) {
                this.playerPlacements.splice(placementIndex, 1);
            }

            this.game.gameManager.call('removeSquad', undoInfo.placementId);

            this.game.gameManager.call('releaseGridCells', undoInfo.placementId);
            this.createUndoEffects(undoInfo);

            this.cachedValidation = null;
            this.cachedGridPos = null;
            
        } catch (error) {
            console.error('Undo failed:', error);
        }
    }

    createUndoEffects(undoInfo) {
        const maxEffects = Math.min(undoInfo.cells.length, 4);

        for (let i = 0; i < maxEffects; i++) {
            const cell = undoInfo.cells[i];
            const worldPos = this.game.gameManager.call('convertGridToWorldPosition', cell.x, cell.z);
            this.game.gameManager.call('createParticleEffect',
                worldPos.x,
                0,
                worldPos.z,
                'magic',
                { count: 3, speedMultiplier: 0.7 }
            );
        }
    }

    getPlacementById(placementId) {
        const playerPlacement = this.playerPlacements.find(placement => placement.placementId === placementId);
        if (playerPlacement) {
            return playerPlacement;
        }
        
        const opponentPlacement = this.opponentPlacements.find(placement => placement.placementId === placementId);
        if (opponentPlacement) {
            return opponentPlacement;
        }
        
        return null;
    }

    collectPlayerPlacements() {
        return this.playerPlacements;
    }

   
    updatePlacementPreview(event) {
        if (!this.placementPreview) return;
    
        if (!this.mouseWorldPos) {
            this.placementPreview.clear();
            document.body.style.cursor = 'not-allowed';
            return;
        }

        // Adjust world position to account for camera angle and cell centering
        // Add half cell size to snap to nearest cell center

        const gridPos = this.game.gameManager.call('convertWorldToGridPosition', this.mouseWorldPos.x, this.mouseWorldPos.z);
        const state = this.game.state;
        
        let isValid = this.isValidGridPlacement(this.mouseWorldPos);
        let unitPositions = null;
        let isBuilding = state.selectedUnitType.collection === 'buildings';

        const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);
        const cells = this.game.squadManager.getSquadCells(gridPos, squadData);
        if (this.game.squadManager.getSquadSize(squadData) > 1) {
            unitPositions = this.game.squadManager.calculateUnitPositions(gridPos, state.selectedUnitType);
        }
        
        // For buildings, show footprint-sized preview. For units, show placement grid cells.
        const worldPositions = cells.map(cell =>
            this.game.gameManager.call('convertGridToWorldPosition', cell.x, cell.z)
        );

        if (unitPositions && unitPositions.length > 0) {
            this.placementPreview.showWithUnitMarkers(worldPositions, unitPositions, isValid, isBuilding);
        } else {
            this.placementPreview.showAtWorldPositions(worldPositions, isValid, isBuilding);
        }

        document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';
    }

    rayCastGround(mouseX, mouseY) {
        if (!this.game.scene || !this.game.camera) return null;

        if (!this.mouse) {
            this.mouse = new THREE.Vector2();
        }
        this.mouse.set(mouseX, mouseY);

        if (!this.raycaster) {
            this.raycaster = new THREE.Raycaster();
        }
        this.raycaster.setFromCamera(this.mouse, this.game.camera);

        // Try to raycast directly against the terrain mesh (most efficient)
        const ground = this.game.gameManager.call('getGroundMesh');
        if (ground) {
            const intersects = this.raycaster.intersectObject(ground, false);
            if (intersects.length > 0) {
                return intersects[0].point;
            }
        }
        return { x: 0, y: 0, z: 0 };
    }

    getFlatWorldPositionFromMouse(event, mouseX, mouseY) {
        if (!this.game.scene || !this.game.camera) return null;

        const mouse = new THREE.Vector2();
        

        mouse.set(mouseX, mouseY);
        if (!this.raycaster) {
            this.raycaster = new THREE.Raycaster();
        }
        this.raycaster.setFromCamera(mouse, this.game.camera);

        // Fallback: raycast to flat plane at y=0 if ground mesh not available
        const ray = this.raycaster.ray;

        if (Math.abs(ray.direction.y) < 0.0001) {
            return null;
        }
        const baseHeight = this.game.gameManager.call('getBaseTerrainHeight');
        const distance = (baseHeight - ray.origin.y) / ray.direction.y;

        if (distance < 0) {
            return null;
        }

        const intersectionPoint = ray.origin.clone().add(
            ray.direction.clone().multiplyScalar(distance)
        );

        return intersectionPoint;
    }

    findGroundMesh() {
        for (let child of this.game.scene.children) {
            if (child.isMesh && child.geometry?.type === 'PlaneGeometry') {
                return child;
            }
        }
        return null;
    }

    isValidGridPlacement(worldPos, unitDef) {
        const selectedUnitType = unitDef || this.game.state.selectedUnitType;

        let gridPos = this.game.gameManager.call('convertWorldToGridPosition', worldPos.x, worldPos.z);
        let cells = [];
        let isValid = false;
        let gridValid = false;

        if (selectedUnitType.collection === 'buildings') {
            cells = this.calculateBuildingCells(gridPos, selectedUnitType);

            if (selectedUnitType.id === 'goldMine') {
                // Convert footprint to placement grid cells
                const footprintWidth = selectedUnitType.footprintWidth || selectedUnitType.placementGridWidth || 2;
                const footprintHeight = selectedUnitType.footprintHeight || selectedUnitType.placementGridHeight || 2;
                const gridWidth = footprintWidth * 2;
                const gridHeight = footprintHeight * 2;
                const validation = this.game.gameManager.call('isValidGoldMinePlacement', gridPos, gridWidth, gridHeight);
                isValid = validation.valid;
            } else {
                gridValid = this.game.gameManager.call('isValidGridPlacement', cells, this.game.state.mySide);

                let terrainValid = true;
                cells.forEach((cell) => {
                    // Convert placement grid coordinates to terrain grid coordinates
                    const terrainGridX = Math.floor(cell.x / 2);
                    const terrainGridZ = Math.floor(cell.z / 2);
                    const terrainTypeId = this.game.gameManager.call('getTerrainTypeAtGridPosition', terrainGridX, terrainGridZ);
                    if(!terrainTypeId) {
                        terrainValid = false;
                        return;
                    }
                    const terrainType = this.game.gameManager.call('getTileMapTerrainType', terrainTypeId);
                    // Check walkability using placement grid cell (already in placement grid coords)
                    const isPositionWalkable = this.game.gameManager.call('isGridPositionWalkable', cell);
                    terrainValid = terrainValid && terrainType.buildable && isPositionWalkable;
                });

                isValid = gridValid && terrainValid;
            }
        } else {
            const squadData = this.game.squadManager.getSquadData(selectedUnitType);
            cells = this.game.squadManager.getSquadCells(gridPos, squadData);
            gridValid = this.game.gameManager.call('isValidGridPlacement', cells, this.game.state.mySide);
            isValid = gridValid;
        }
        return isValid;
    }

    addToUndoStack(undoInfo) {
        if (!this.config.enableUndo) return;
        
        this.undoStack.push(undoInfo);
        
        if (this.undoStack.length > this.maxUndoSteps) {
            this.undoStack.shift();
        }
    }

    clearUndoStack() {
        this.undoStack = [];
    }

    getUndoStatus() {
        return {
            canUndo: this.undoStack.length > 0 && this.config.enableUndo && !this.isPlayerReady,
            undoCount: this.undoStack.length,
            maxUndoSteps: this.maxUndoSteps,
            lastAction: this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1] : null
        };
    }

    setTeamSides(sides) {
        this.teamSides = {
            player: sides?.player || 'left',
            enemy: sides?.enemy || 'right'
        };
    }

    calculateBuildingCells(gridPos, building) {
        const cells = [];
        // Convert footprint (terrain grid units) to placement grid cells (multiply by 2)
        const footprintWidth = building.footprintWidth || building.placementGridWidth || 1;
        const footprintHeight = building.footprintHeight || building.placementGridHeight || 1;
        const gridWidth = footprintWidth * 2;
        const gridHeight = footprintHeight * 2;

        const startX = gridPos.x - Math.floor(gridWidth / 2);
        const startZ = gridPos.z - Math.floor(gridHeight / 2);

        for (let z = 0; z < gridHeight; z++) {
            for (let x = 0; x < gridWidth; x++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }


    updateCursorState(isValid) {
        if (this.isPlayerReady) {
            document.body.style.cursor = 'not-allowed';
        } else if (this.game.state.selectedUnitType) {
            document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';
        } else {
            document.body.style.cursor = 'default';
        }
    }

    onBattleEnd() {        
        this.removeDeadSquadsAfterRound();
    }
        
    removeDeadSquadsAfterRound() {
        if (!this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        this.playerPlacements = this.filterDeadSquads(this.playerPlacements, ComponentTypes);
        this.opponentPlacements = this.filterDeadSquads(this.opponentPlacements, ComponentTypes);
    }

    filterDeadSquads(placements, ComponentTypes) {
        return placements.filter(placement => {
            if (!placement.squadUnits || placement.squadUnits.length === 0) {
                this.cleanupDeadSquad(placement);
                return false;
            }

            const aliveUnits = placement.squadUnits.filter(entityId => {
                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
                if(buildingState) return true;
                return health && health.current > 0 && (!deathState || !deathState.isDying);
            });

            if (aliveUnits.length === 0) {
                this.cleanupDeadSquad(placement);
                return false;
            }

            placement.squadUnits = aliveUnits;
            return true;
        });
    }

    cleanupDeadSquad(placement) {
        if (placement.placementId) {
            this.game.gameManager.call('releaseGridCells', placement.placementId);
            this.game.gameManager.call('removeSquad', placement.placementId);
        }
    }

    resetAllPlacements() {
        this.game.gameManager.call('resetSquadExperience');

        this.playerPlacements = [];
        this.opponentPlacements = [];
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;
        this.clearUndoStack();
        
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        this.groundMeshCache = this.findGroundMesh();
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }
    }

    dispose() {
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        
        if (this.placementPreview) {
            this.placementPreview.dispose();
        }
                
        this.resetAllPlacements();
    }

    getUnitAtWorldPosition(worldPos) {
        const clickRadius = 30;
        let closestEntityId = null;
        let closestDistance = clickRadius;
        
        const entities = this.game.getEntitiesWith(
            this.game.componentManager.getComponentTypes().POSITION,
            this.game.componentManager.getComponentTypes().TEAM
        );
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            const team = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().TEAM);
            
            const dx = pos.x - worldPos.x;
            const dz = pos.z - worldPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEntityId = entityId;
            }
        });
        
        return closestEntityId;
    }
};

// system: MultiplayerUISystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MultiplayerUISystem'] = class MultiplayerUISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.uiSystem = this;
        
        // State tracking
        this.currentScreen = null;
        this.gameState = null;
        this.config = {
            maxSquadsPerRound: 2,
            numBackgrounds: 5
        };
    }

    // GUTS Manager Interface
    init(params) {
        this.params = params || {};
        this.initializeUI();
    }

    initializeUI() {
        let randomBG = Math.floor(Math.random() * (this.config.numBackgrounds + 1));
        document.body.classList.add(`bg${randomBG}`);
        // Add multiplayer UI elements to existing interface
        const multiplayerHTML = `
            <div id="multiplayerHUD" style="display: none; position: absolute; top: 10px; right: 330px; z-index: 1000;">
                <div class="opponent-info">
                    <h4>Opponent</h4>
                    <div class="opponent-stats">
                        <div>Name: <span id="opponentName">-</span></div>
                        <div>Health: <span id="opponentHealth">100</span></div>
                        <div>Gold: <span id="opponentGold">-</span></div>
                    </div>
                </div>
            </div>
            
            <div id="multiplayerNotifications" style="position: fixed; top: 50px; left: 50%; transform: translateX(-50%); z-index: 2000;">
                <!-- Notifications appear here -->
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', multiplayerHTML);
    }

    handleMultiplayerModeSelection(mode) {
        // Create setup dialog for multiplayer
        const setupDialog = document.createElement('div');
        setupDialog.className = 'multiplayer-setup-dialog modal';

        const interfaceConfig = this.game.getCollections().interfaces[mode.interfaceId]
        setupDialog.innerHTML = interfaceConfig?.html || `Interface ${mode.interfaceId} not found`;

        document.body.appendChild(setupDialog);
        this.setupMultiplayerDialogEvents(setupDialog, mode);
    }

    setupMultiplayerDialogEvents(dialog, mode) {
        const playerNameInput = dialog.querySelector('#playerName');
        const quickMatchBtn = dialog.querySelector('#quickMatchBtn');
        const createRoomBtn = dialog.querySelector('#createRoomBtn');
        const joinRoomBtn = dialog.querySelector('#joinRoomBtn');
        const roomIdInput = dialog.querySelector('#roomIdInput');
        const cancelBtn = dialog.querySelector('#cancelMultiplayerBtn');

        const getPlayerName = () => playerNameInput.value.trim() || 'Player';

        if (quickMatchBtn) {
            quickMatchBtn.addEventListener('click', () => {
                this.game.networkManager.startQuickMatch(getPlayerName());
                dialog.remove();
            });
        }

        if (createRoomBtn) {
            createRoomBtn.addEventListener('click', () => {
                this.game.networkManager.createRoom(getPlayerName(), mode.maxPlayers);
                dialog.remove();
            });
        }

        if (joinRoomBtn) {
            joinRoomBtn.addEventListener('click', () => {
                const roomId = roomIdInput.value.trim().toUpperCase();
                if (roomId) {
                    this.game.networkManager.joinRoom(roomId, getPlayerName());
                    dialog.remove();
                } else {
                    this.showNotification('Please enter a Room ID', 'error');
                }
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                dialog.remove();
            });
        }

        playerNameInput.focus();
        playerNameInput.select();
    }

    toggleReady() {
        // Disable button while updating
        const btn = document.getElementById('player1ReadyBtn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Updating...';
        }
        this.game.networkManager.toggleReady(() => {
        });
    }
    leaveRoom() {
        this.game.networkManager.leaveRoom();
        this.exitToMainMenu();
    }


    setupEventListeners() {
        // Store bound handlers to enable proper cleanup
        if (!this.boundHandlers) {
            this.boundHandlers = {
                readyClick: this.toggleReady.bind(this),
                leaveClick: this.leaveRoom.bind(this)
            };
        }

        // Clean up any existing listeners
        const readyBtn = document.getElementById('player1ReadyBtn');
        const leaveBtn = document.getElementById('leaveLobbyBtn');

        if (readyBtn) {
            // Remove old listener if it exists
            readyBtn.removeEventListener('click', this.boundHandlers.readyClick);
            // Add new listener
            readyBtn.addEventListener('click', this.boundHandlers.readyClick);
        } 

        if (leaveBtn) {
            leaveBtn.removeEventListener('click', this.boundHandlers.leaveClick);
            leaveBtn.addEventListener('click', this.boundHandlers.leaveClick);
        }
    }

    showLobby(gameState, roomId) {
        this.currentScreen = 'lobby';
        this.roomId = roomId;
          
        // Show lobby screen
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        document.getElementById('multiplayerLobby').classList.add('active');

        this.updateLobby(gameState);
    }

    updateLobby(gameState) {
        if (!gameState) return;

        const myPlayerId = this.game.clientNetworkManager.playerId;
        
        // Update room ID
        const lobbyRoomId = document.getElementById('lobbyRoomId');
        if (lobbyRoomId) {
            lobbyRoomId.textContent = this.roomId || '------';
        }
        
        // Update player count
        const playerCount = document.getElementById('playerCount');
        if (playerCount) {
            playerCount.textContent = gameState.players?.length || 0;
        }

        // Update player cards
        if (gameState.players) {
            const myPlayer = gameState.players.find(p => p.id === myPlayerId);
            const opponent = gameState.players.find(p => p.id !== myPlayerId);

            // Update my player card (Player 1)
            if (myPlayer) {
                const player1Name = document.getElementById('player1Name');
                const player1Status = document.getElementById('player1Status');
                const player1ReadyBtn = document.getElementById('player1ReadyBtn');
                const player1Info = document.getElementById('player1Info');

                if (player1Name) {
                    player1Name.textContent = `${myPlayer.name} (You)${myPlayer.isHost ? ' - Host' : ''}`;
                }
                if (player1Status) {
                    player1Status.textContent = myPlayer.ready ? 'ðŸŸ¢ Ready for Battle!' : 'ðŸŸ¡ Preparing...';
                    player1Status.className = `player-status ${myPlayer.ready ? 'ready' : 'waiting'}`;
                }
                if (player1ReadyBtn) {
                    player1ReadyBtn.disabled = false;
                    player1ReadyBtn.textContent = myPlayer.ready ? 'â³ CANCEL READY' : 'ðŸ›¡ï¸ READY FOR BATTLE';
                    player1ReadyBtn.className = myPlayer.ready ? 'ready-btn ready-state' : 'ready-btn';
                }
                if (player1Info) {
                    player1Info.className = `player-card ${myPlayer.ready ? 'ready' : 'waiting'}`;
                }
            }

            // Update opponent card (Player 2)
            if (opponent) {
                const player2Name = document.getElementById('player2Name');
                const player2Status = document.getElementById('player2Status');
                const player2Info = document.getElementById('player2Info');

                if (player2Info) {
                    player2Info.style.display = 'block';
                    player2Info.className = `player-card ${opponent.ready ? 'ready' : 'waiting'}`;
                }
                if (player2Name) {
                    player2Name.textContent = `${opponent.name}${opponent.isHost ? ' - Host' : ''}`;
                }
                if (player2Status) {
                    player2Status.textContent = opponent.ready ? 'ðŸŸ¢ Ready for Battle!' : 'ðŸŸ¡ Preparing...';
                    player2Status.className = `player-status ${opponent.ready ? 'ready' : 'waiting'}`;
                }
            } else {
                // Hide opponent card if no second player
                const player2Info = document.getElementById('player2Info');
                if (player2Info) {
                    player2Info.style.display = 'none';
                }
            }

            // Update start game button (only for host)
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn && myPlayer?.isHost) {
                const allReady = gameState.players.every(p => p.ready);
                const canStart = gameState.players.length === 2 && allReady;
                
                startBtn.style.display = gameState.players.length === 2 ? 'block' : 'none';
                startBtn.disabled = !canStart;
                startBtn.textContent = allReady ? 'âš¡ COMMENCE WAR' : 'Waiting for Ready';
            }

            // Update lobby status message
            const statusMsg = document.getElementById('lobbyStatusMessage');
            if (statusMsg) {
                if (gameState.players.length === 1) {
                    statusMsg.textContent = 'Waiting for worthy opponents...';
                } else if (gameState.players.length === 2) {
                    const allReady = gameState.players.every(p => p.ready);
                    statusMsg.textContent = allReady ? 
                        'All warriors ready! Prepare for battle!' : 
                        'Opponent found! Awaiting ready status...';
                }
            }
        }

        // Set up event listeners after DOM is updated
        this.setupEventListeners();
    }

    onGameStarted(data) {

        this.currentScreen = 'game';
        
        // Hide lobby, show game
        document.getElementById('multiplayerLobby')?.classList.remove('active');
        document.getElementById('gameScreen')?.classList.add('active');
        
        
    }

    showNotification(message, type = 'info', duration = 4000) {
        const notification = document.createElement('div');
        notification.textContent = message;
        
        const colors = {
            info: '#00aaff',
            success: '#00ff00',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        
        const color = colors[type] || colors.info;
        notification.style.cssText = `
            background: rgba(0, 0, 0, 0.9); border: 2px solid ${color};
            color: ${color}; padding: 12px 16px; border-radius: 6px;
            margin-bottom: 8px; font-weight: bold; pointer-events: auto; cursor: pointer;
        `;
        
        notification.onclick = () => notification.remove();
        
        const container = document.getElementById('multiplayerNotifications') || document.body;
        container.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, duration);
    }
    
    start() {
        this.game.gameManager.call('initializeParticleSystem');
        this.game.gameManager.call('initializeEffectsSystem');
    }

    exitToMainMenu() {
        this.currentScreen = null;
        this.roomId = null;
        this.isHost = false;
        this.gameState = null;

        if (this.game.screenManager?.showMainMenu) {
            this.game.screenManager.showMainMenu();
        } else {
            window.location.reload();
        }
    }

 
    dispose() {
        this.networkUnsubscribers.forEach(unsubscribe => {
            if (typeof unsubscribe === 'function') {
                unsubscribe();
            }
        });
        this.networkUnsubscribers = [];
        
    }
    onPlacementPhaseStart() {
        const state = this.game.state;
        state.phase = 'placement';
        state.phaseTimeLeft = null; // No timer in multiplayer
        state.playerReady = false;
        state.enemyPlacementComplete = false; // Actually opponent placement
        state.roundEnding = false;          
    }
    
    onBattleEnd() {

            
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entitiesToDestroy = new Set();
        
        [
            ComponentTypes.CORPSE
        ].forEach(componentType => {
            const entities = this.game.getEntitiesWith(componentType);
            entities.forEach(id => entitiesToDestroy.add(id));
        });
        
        entitiesToDestroy.forEach(entityId => {
            try {
                this.game.destroyEntity(entityId); 
            } catch (error) {
                console.warn(`Error destroying entity ${entityId}:`, error);
            }
        });
        
        
    }
       
    startVictoryCelebration(victoriousUnits) {
        // Determine which team won
        const firstUnit = victoriousUnits[0];
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const team = this.game.getComponent(firstUnit, ComponentTypes.TEAM);
        const teamType = team?.team || 'player';

        victoriousUnits.forEach(entityId => {
            this.game.gameManager.call('startCelebration', entityId, teamType);
        });
    }

    update() {
        this.updatePhaseUI();
        this.updateGoldDisplay();
        this.updateRoundDisplay();
        this.updateSideDisplay();
    }

    handleRoundResult(roundResult) {
        const state = this.game.state;
        state.phase = 'ended'; 
    }

    updatePhaseUI() {
        const state = this.game.state;
        
        // Update round number
 
         
        // Update phase status
        const phaseStatusEl = document.getElementById('phaseStatus');
        if (phaseStatusEl) {
            if (state.phase === 'placement') {
                if (state.playerReady) {
                    phaseStatusEl.textContent = 'Army deployed! Waiting for opponent...';
                } else {
                    phaseStatusEl.textContent = 'Deploy your units and get ready!';
                }
            } else if (state.phase === 'battle') {
                phaseStatusEl.textContent = 'Battle in progress! Watch your units fight!';
            }
        }
    }
    
    updateGoldDisplay() {
        const goldDisplay = document.getElementById('playerGold');
        if (goldDisplay) {
            goldDisplay.textContent = this.game.state.playerGold || 0;
        }
    }
    
    updateRoundDisplay() {
        const roundNumberEl = document.getElementById('currentRound');
        if (roundNumberEl) {
            roundNumberEl.textContent = this.game.state.round || 1;
        }
    }
    updateSideDisplay() {
        const sideDisplay = document.getElementById('playerSide');
        if (sideDisplay) {
            sideDisplay.textContent = this.game.state.mySide || 0;
        }
    }
   
};

// system: ShopSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ShopSystem'] = class ShopSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.shopSystem = this;
        
        this.ownedBuildings = new Map();
        this.buildingUpgrades = new Map();
        this.buildingProductionProgress = new Map();
        this.game.state.selectedEntity = {
            "collection": null,
            "entityId": null
        };
        this.townHallLevel = 0;
        
        this.lastExperienceUpdate = 0;
        this.uiEnhancements = new GUTS.FantasyUIEnhancements(game);
    }

    init() {
        this.game.gameManager.register('addBuilding', this.addBuilding.bind(this));
        this.game.gameManager.register('resetShop', this.reset.bind(this));
        this.game.gameManager.register('updateSquadExperience', this.updateSquadExperience.bind(this));
    }

    updateSquadExperience() {
        this.createExperiencePanel();
    }

    clearActionPanel() {
        const container = document.getElementById('actionPanel');
        if (!container) return;
        container.innerHTML = '';
    }

    clearSelectedEntity() {    
        this.game.state.selectedEntity.entityId = null;
        this.game.state.selectedEntity.collection = null;
    }
    onUnitSelected(entityId){
        const CT = this.game.componentManager.getComponentTypes();
        const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);
        if(unitType.collection == "buildings") {
            const placement = this.game.getComponent(entityId, CT.PLACEMENT);        
            this.renderBuildingActions(placement);
        }
    }
    renderBuildingActions(placement) {
        const building = placement.unitType;
        const container = document.getElementById('actionPanel');  
        if (!container) return;
        container.innerHTML = '';
        if (!building) {
            this.clearSelectedEntity();
            return;
        }
       
        const buildingId = this.game.state.selectedEntity.entityId;
        if(this.buildingProductionProgress.has(buildingId)){
            const hasUnits = building.units && building.units.length > 0;
            const hasUpgrades = building.upgrades && building.upgrades.length > 0;
            if (hasUnits) {
                const unitsSection = this.createUnitsSection(building);
                container.appendChild(unitsSection);
            }

            if (hasUpgrades) {
                const upgradesSection = this.createUpgradesSection(building);
                container.appendChild(upgradesSection);
            }

            if (!hasUnits && !hasUpgrades) {
                const empty = document.createElement('div');
                empty.className = 'action-empty';
                empty.textContent = 'No actions available';
                container.appendChild(empty);
            }
        } else {
            const empty = document.createElement('div');
            empty.className = 'action-empty';
            empty.textContent = 'Under Construction';
            container.appendChild(empty);
        }
        
        container.removeAttribute('style');
    }

    createUnitsSection(building) {
        const section = document.createElement('div');
        section.className = 'action-section';

        const grid = document.createElement('div');
        grid.className = 'action-grid';
        const UnitTypes = this.game.getCollections().units;
        
        const buildingId = this.game.state.selectedEntity.entityId;
        const productionProgress = this.buildingProductionProgress.get(buildingId);
        const remainingCapacity = 1 - productionProgress;
        
        building.units.forEach(unitId => {
            const unit = UnitTypes[unitId];
            const buildTime = unit.buildTime || 1;
            const canAfford = this.game.state.playerGold >= unit.value;
            const hasCapacity = buildTime <= remainingCapacity + 0.001;
            
            const hasSupply = !this.game.supplySystem || this.game.supplySystem.canAffordSupply(this.game.state.mySide, unit);
            
            let locked = !canAfford || !hasCapacity || !hasSupply;
            let lockReason = null;
            if (!canAfford) {
                lockReason = "Can't afford";
            } else if (!hasCapacity) {
                lockReason = `Need ${buildTime.toFixed(1)} rounds`;
            } else if (!hasSupply) {
                lockReason = "Not enough supply";
            }
            
            const btn = this.createActionButton({
                iconId: unit.icon,
                title: unit.title,
                cost: unit.value,
                buildTime: buildTime,
                locked: locked,
                lockReason: lockReason,
                onClick: () => this.purchaseUnit(unitId, unit)
            });
            grid.appendChild(btn);
        });

        section.appendChild(grid);
        return section;
    }

    createUpgradesSection(building) {
        const section = document.createElement('div');
        section.className = 'action-section';

        const header = document.createElement('div');
        header.className = 'action-section-header';
        header.textContent = 'UPGRADES';
        section.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'action-grid';

        const buildingId = this.game.state.selectedEntity.entityId;
        const purchasedUpgrades = this.buildingUpgrades.get(buildingId) || new Set();

        building.upgrades.forEach(upgradeId => {
            const upgrade = this.game.getCollections().upgrades[upgradeId];
            if (!upgrade) return;

            const isOwned = purchasedUpgrades.has(upgradeId);
            const locked = isOwned || this.game.state.playerGold < upgrade.value;

            const btn = this.createActionButton({
                icon: upgrade.icon || 'â­',
                title: upgrade.title,
                cost: upgrade.value,
                locked: locked,
                lockReason: isOwned ? 'Owned' : (locked ? "Can't afford" : null),
                owned: isOwned,
                onClick: () => !isOwned && this.purchaseUpgrade(upgradeId, upgrade, buildingId)
            });
            grid.appendChild(btn);
        });

        section.appendChild(grid);
        return section;
    }

    createActionButton(options) {
        const {
            iconId,
            title,
            cost,
            buildTime,
            locked = false,
            lockReason = null,
            onClick
        } = options;

        const btn = document.createElement('button');
        btn.className = 'action-btn';
        if (locked) btn.classList.add('locked');

        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(iconId){
            const icon = this.game.getCollections().icons[iconId];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  'âš”ï¸';
            }
        } else {
            iconEl.textContent =  'âš”ï¸';
        }

        
        btn.appendChild(iconEl);
        let costTxt = `ðŸ’° ${cost}`;
        if (lockReason) {
            costTxt = lockReason;
        } 
        btn.title = `${title} ${costTxt}`;
        

        if (!locked) {
            btn.addEventListener('click', onClick);
        }

        return btn;
    }

    isBuildingLocked(buildingId, building) {
        return this.game.state.playerGold < building.value ||
               (building.requires && !this.hasRequirements(building.requires));
    }

    getLockReason(buildingId, building) {
        if (this.game.state.playerGold < building.value) return "Can't afford";
        if (building.requires && !this.hasRequirements(building.requires)) {
            return 'Missing requirements';
        }
        return null;
    }

    hasRequirements(requirements) {
        if (requirements.townHallLevel) {
            if (this.townHallLevel < requirements.townHallLevel) return false;
        }
        if (requirements.buildings) {
            for (const reqBuilding of requirements.buildings) {
                if (!this.ownedBuildings.has(reqBuilding)) return false;
            }
        }
        return true;
    }

    addBuilding(buildingId, entityId){
        if(!this.ownedBuildings.has(buildingId)){
            this.ownedBuildings.set(buildingId, [entityId]);
        } else {
            this.ownedBuildings.get(buildingId).push(entityId)            
        }

        this.buildingProductionProgress.set(entityId, 0);
        this.buildingUpgrades.set(buildingId, new Set());        
    }

    purchaseUnit(unitId, unit) {
        const buildingId = this.game.state.selectedEntity.entityId;
        const placementId = this.getBuildingPlacementId(buildingId);
        
        if (!placementId) {
            console.log('no building selected');
            this.showNotification('No building selected!', 'error');
            return;
        }

        const buildTime = unit.buildTime || 1;
        const productionProgress = this.buildingProductionProgress.get(buildingId);
        const remainingCapacity = 1 - productionProgress;
        
        if (buildTime > remainingCapacity + 0.001) {
            this.showNotification(`Not enough production capacity! Need ${buildTime.toFixed(1)} rounds`, 'error');
            return;
        }

        unit.id = unitId;
        unit.collection = 'units';
        const placementPos = this.findBuildingPlacementPosition(placementId, unit);
        if (!placementPos) {
            console.log('no valid placement');
            this.showNotification('No valid placement near building!', 'error');
            return;
        }
        const placement = this.game.gameManager.call('createPlacementData', placementPos, unit, this.game.state.mySide);

        this.game.networkManager.submitPlacement(placement, (success, response) => {
            if(success){
                const newProgress = productionProgress + buildTime;
                this.buildingProductionProgress.set(buildingId, newProgress);
                this.game.gameManager.call('placeSquadOnBattlefield', placement);
            }
        });       
    }

    findBuildingPlacementPosition(placementId, unitDef) {
        const buildingGridPos = this.getBuildingGridPosition(placementId);
        const placement = this.game.gameManager.call('getPlacementById', placementId);
        if (!buildingGridPos) return null;

        const gridSystem = this.game.gridSystem;
        const placementSystem = this.game.placementSystem;
        if (!gridSystem || !placementSystem) return null;

        const buildingCells = placement.cells || [];
        const buildingCellSet = new Set(buildingCells.map(cell => `${cell.x},${cell.z}`));

        const searchRadius = 12;
        const spiralOffsets = this.generateSpiralOffsets(searchRadius);

        for (const offset of spiralOffsets) {
            const testPos = {
                x: buildingGridPos.x + offset.x,
                z: buildingGridPos.z + offset.z
            };
            
            const testCellKey = `${testPos.x},${testPos.z}`;
            if (buildingCellSet.has(testCellKey)) {
                continue;
            }
            
            const unitSquadData = this.game.squadManager.getSquadData(unitDef);
            const unitCells = this.game.squadManager.getSquadCells(testPos, unitSquadData);
            
            const overlapsBuilding = unitCells.some(cell => 
                buildingCellSet.has(`${cell.x},${cell.z}`)
            );
            
            if (overlapsBuilding) {
                continue;
            }

            const worldPos = gridSystem.gridToWorld(testPos.x, testPos.z);
            if (placementSystem.isValidGridPlacement(worldPos, unitDef)) {
                return testPos;
            }
        }

        return null;
    }

    generateSpiralOffsets(maxRadius) {
        const offsets = [];
        let x = 0, z = 0;
        let dx = 0, dz = -1;
        
        for (let i = 0; i < (maxRadius * 2) * (maxRadius * 2); i++) {
            if ((-maxRadius < x && x <= maxRadius) && (-maxRadius < z && z <= maxRadius)) {
                offsets.push({ x, z });
            }
            
            if (x === z || (x < 0 && x === -z) || (x > 0 && x === 1 - z)) {
                const temp = dx;
                dx = -dz;
                dz = temp;
            }
            
            x += dx;
            z += dz;
        }
        
        return offsets;
    }

    getBuildingPlacementId(buildingId) {
        const state = this.game.state;
        const mySide = state.mySide;
        const placements = this.game.gameManager.call('getPlacementsForSide', mySide);
        if (!placements) return null;

        for (const [placementIndex, placement] of Object.entries(placements)) {
            for(const squadUnit of placement.squadUnits){
                if (squadUnit === buildingId) {
                    return placement.placementId;
                }
            }
        }
        return null;
    }

    getBuildingGridPosition(placementId) {
        const placement = this.game.gameManager.call('getPlacementById', placementId);
        console.log('got placement', placement);
        return placement.gridPosition;
    }

    purchaseUpgrade(upgradeId, upgrade) {
        this.game.networkManager.purchaseUpgrade({ 
            upgradeId, 
            buildingId: this.game.state.selectedEntity.entityId 
        }, (success, response) => {
            if (success) {
                if (!this.buildingUpgrades.has(this.game.state.selectedEntity.entityId)) {
                    this.buildingUpgrades.set(this.game.state.selectedEntity.entityId, new Set());
                }
                this.buildingUpgrades.get(this.game.state.selectedEntity.entityId).add(upgradeId);
                this.game.state.playerGold -= upgrade.value;
                this.applyUpgradeEffects(this.game.state.mySide, upgrade);
                this.showNotification(`${upgrade.title} purchased!`, 'success');
            }
        });
    }

    applyUpgradeEffects(team, upgrade) {
        if (upgrade.effects) {
            upgrade.effects.forEach(effectId => {
                const effect = this.game.getCollections().effects[effectId];
                if (effect) {
                    effect.id = effectId;
                    this.applyEffect(team, effect);
                }
            });
        }
    }

    applyEffect(team, effectData) {
        if(!this.game.state.teams){
            this.game.state.teams = {};
        }
        if(!this.game.state.teams[team]) {
            this.game.state.teams[team] = {};
        } 
        if(!this.game.state.teams[team].effects) {
            this.game.state.teams[team].effects = {};
        }
        this.game.state.teams[team].effects[effectData.id] = effectData;
    }

    onPlacementPhaseStart() {
        this.ownedBuildings.keys().forEach(buildingType => {
            this.ownedBuildings.get(buildingType).forEach((buildingEntityId) => {
                this.buildingProductionProgress.set(buildingEntityId, 0);
            });
        });
    }

    createExperiencePanel() {
        const container = document.getElementById('unitPromotions');
        if (!container) return;

        container.innerHTML = '';

        const squadsReadyToLevelUp = this.game.gameManager.call('getSquadsReadyToLevelUp');
        
        if (squadsReadyToLevelUp.length === 0) return;

        squadsReadyToLevelUp.forEach(squad => {
            const panel = this.createExperienceCard(squad);
            if (panel) {
                container.appendChild(panel);
            }
        });
    }

    createExperienceCard(squad) {
        const currentUnitType = this.getCurrentUnitType(squad.placementId, squad.team);
        if (!currentUnitType) return null;

        const hasSpecializations = currentUnitType.specUnits && currentUnitType.specUnits.length > 0;
        const isSpecializationLevel = (squad.level) == 2;
        const canSpecialize = isSpecializationLevel && hasSpecializations;
        
        const card = document.createElement('div');
        card.className = 'experience-panel';

        if (canSpecialize) {
            const shimmer = document.createElement('div');
            shimmer.classList.add("shimmer");
            card.appendChild(shimmer);
        }

        const currentLevelText = ` (Lvl ${squad.level})`;
        const nextLevelText = canSpecialize ? 'â­ Ascend!' : ` Level ${squad.level + 1}`;

        const header = document.createElement('div');
        header.className = 'experience-header';

        const unitIcon = document.createElement('div');
        unitIcon.className = 'experience-unit-icon';
        unitIcon.textContent = currentUnitType.icon || 'âš”ï¸';
        header.appendChild(unitIcon);

        const info = document.createElement('div');
        info.className = 'experience-info';

        const title = document.createElement('div');
        title.className = 'experience-title';
        title.textContent = this.getSquadDisplayName(squad.placementId);
        info.appendChild(title);

        const subtitle = document.createElement('div');
        subtitle.className = 'experience-subtitle';
        subtitle.textContent = `${currentUnitType.title}${currentLevelText}`;
        info.appendChild(subtitle);

        header.appendChild(info);
        card.appendChild(header);

        const progress = document.createElement('div');
        progress.className = 'experience-progress';

        const progressBar = document.createElement('div');
        progressBar.className = 'experience-progress-bar';

        const progressFill = document.createElement('div');
        progressFill.className = 'experience-progress-fill';
        progressFill.style.width = '100%';
        progressBar.appendChild(progressFill);

        progress.appendChild(progressBar);

        const xpText = document.createElement('div');
        xpText.className = 'experience-xp-text';
        xpText.textContent = 'Ready to advance!';
        progress.appendChild(xpText);

        card.appendChild(progress);

        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'experience-buttons';

        if (canSpecialize) {
            const specBtn = document.createElement('button');
            specBtn.className = 'btn btn-primary experience-btn';
            specBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;
            specBtn.onclick = () => {
                this.game.gameManager.call('showSpecializationSelection',
                    squad.placementId,
                    squad,
                    squad.levelUpCost
                );
            };
            buttonContainer.appendChild(specBtn);
        } else {
            const levelUpBtn = document.createElement('button');
            levelUpBtn.className = 'btn btn-primary experience-btn';
            levelUpBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;
            levelUpBtn.onclick = () => {
                this.game.gameManager.call('levelUpSquad', squad.placementId, squad.team);
            };
            buttonContainer.appendChild(levelUpBtn);
        }

        card.appendChild(buttonContainer);
        return card;
    }

    getCurrentUnitType(placementId, team) {
        const state = this.game.state;
        const placement = state.placements?.[team]?.[placementId];
        if (!placement) return null;
        
        const UnitTypes = this.game.getCollections().units;
        return placement.unitType ? UnitTypes[placement.unitType] : null;
    }

    getSquadDisplayName(placementId) {
        const match = placementId.match(/^([a-z]+)_(\d+)$/);
        if (match) {
            const side = match[1];
            const index = parseInt(match[2], 10);
            const sideLabel = side === 'left' ? 'Left' : side === 'right' ? 'Right' : side === 'center' ? 'Center' : 'Unknown';
            return `${sideLabel} Squad ${index + 1}`;
        }
        return placementId;
    }

    showNotification(message, type) {
        if (this.uiEnhancements) {
            this.uiEnhancements.showNotification(message, type);
        } 
    }

    update() {
        const state = this.game.state;
        const inPlacementPhase = state.phase === 'placement';

        if (inPlacementPhase) {
            if (this.game.state.now - this.lastExperienceUpdate > 2) {
                const squadsReadyToLevelUp = this.game.gameManager.call('getSquadsReadyToLevelUp');
                const hasReadySquads = squadsReadyToLevelUp && squadsReadyToLevelUp.length > 0;
                const hasExperiencePanel = document.querySelector('.experience-panel') !== null;

                if (hasReadySquads !== hasExperiencePanel) {
                    this.createExperiencePanel();
                }

                this.lastExperienceUpdate = this.game.state.now;
            }
        }
    }

    reset() {
        this.clearSelectedEntity();
    }

  
};

// system: TeamHealthSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TeamHealthSystem'] = class TeamHealthSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.teamHealthSystem = this;
        
        
        // Team health configuration
        this.MAX_TEAM_HEALTH = 2500;
        this.teamHealth = {
            left: this.MAX_TEAM_HEALTH,
            right: this.MAX_TEAM_HEALTH
        };
        
        // Track if we've already processed this round's result
        this.roundProcessed = false;
        
        if(!this.game.isServer){
            console.log('this.game', this.game);
            this.initializeUI();
        }
    }
    
    initializeUI() {
        // Delay creation to ensure DOM is ready
        setTimeout(() => {
            this.updateHealthDisplay();
        }, 100);
    }
    
    updateHealthDisplay() {
        const playerFill = document.getElementById('playerHealthFill');
        const playerText = document.getElementById('playerHealthText');
        const opponentFill = document.getElementById('opponentHealthFill');
        const opponentText = document.getElementById('opponentHealthText');
        
        let myHealth = this.teamHealth[this.game.state.mySide] || this.MAX_TEAM_HEALTH;
        let opponentHealth = this.teamHealth[this.game.state.mySide == 'left' ? 'right' : 'left'] || this.MAX_TEAM_HEALTH;
        if (playerFill && playerText) {
            const playerPercent = (myHealth / this.MAX_TEAM_HEALTH) * 100;
            playerFill.style.width = `${playerPercent}%`;
            playerText.textContent = `${myHealth}/${this.MAX_TEAM_HEALTH}`;
        }
        
        if (opponentFill && opponentText) {
            const opponentPercent = (opponentHealth / this.MAX_TEAM_HEALTH) * 100;
            opponentFill.style.width = `${opponentPercent}%`;
            opponentText.textContent = `${opponentHealth}/${this.MAX_TEAM_HEALTH}`;
        }
    }
    
    onBattleStart() {
        this.roundProcessed = false;
     
    }
    
    // Apply damage when PhaseSystem tells us a round ended
    applyRoundDamage(winningTeam, survivingUnits) {
        
        // Calculate damage based on surviving squads' base values
        const damageResult = this.calculateSquadBasedDamage(survivingUnits);
        const losingTeam = winningTeam === 'left' ? 'right' : 'left';
        
        // Apply damage to losing team
        this.dealDamageToTeam(losingTeam, damageResult.totalDamage);
        
        // Return result object
        return {
            result: winningTeam === this.game.state.mySide ? 'victory' : 'defeat',
            winningTeam: winningTeam,
            losingTeam: losingTeam,
            damage: damageResult.totalDamage,
            survivingSquads: damageResult.survivingSquads,
            gameOver: this.teamHealth[losingTeam] <= 0,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    // Apply no damage for draws
    applyRoundDraw() {
        if (this.roundProcessed) return null;
        this.roundProcessed = true;

        
        // Return draw result
        return {
            result: 'draw',
            winningTeam: null,
            losingTeam: null,
            damage: 0,
            gameOver: false,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    /**
     * Calculate damage based on squads, not individual units
     * If ANY units from a squad survive, the entire squad's base value counts as damage
     * @param {Array} survivingUnits - Array of surviving unit entity IDs
     * @returns {Object} Damage calculation results
     */
    calculateSquadBasedDamage(survivingUnits) {
        const squadMap = new Map(); // squadId -> {unitType, survivors, totalUnits}
        let totalDamage = 0;
        let survivingSquadCount = 0;
        const squadDetails = [];
        if(!survivingUnits){ 
            return {
                totalDamage: 0,
                survivingSquads: 0,
                squadDetails: []
            };
        }
        // Group surviving units by their squad placement ID
        survivingUnits.forEach(unitId => {
            // Find which squad this unit belongs to
            const squadInfo = this.findSquadForUnit(unitId);
            if (squadInfo) {
                const { placementId, unitType } = squadInfo;
                
                if (!squadMap.has(placementId)) {
                    squadMap.set(placementId, {
                        unitType: unitType,
                        survivors: 0,
                        totalUnits: this.getOriginalSquadSize(placementId),
                        placementId: placementId
                    });
                }
                
                squadMap.get(placementId).survivors++;
            }
        });
        
        // Calculate damage for each squad that has survivors
        squadMap.forEach((squadData, placementId) => {
            if (squadData.survivors > 0) {
                // Entire squad's base value counts as damage
                const squadBaseDamage = squadData.unitType.value || 50;
                totalDamage += squadBaseDamage;
                survivingSquadCount++;
                
                squadDetails.push({
                    name: squadData.unitType.title || squadData.unitType.id || 'Unknown Squad',
                    damage: squadBaseDamage,
                    survivingUnits: squadData.survivors,
                    totalUnits: squadData.totalUnits,
                    placementId: placementId
                });
                
            }
        });
        
        return {
            totalDamage: totalDamage,
            survivingSquads: survivingSquadCount,
            squadDetails: squadDetails
        };
    }
    
    /**
     * Find which squad a unit belongs to
     * @param {number} unitId - Unit entity ID
     * @returns {Object|null} Squad info or null
     */
    findSquadForUnit(unitId) {
        // Check with experience system first (most reliable)
        const squadData = this.game.gameManager.call('findSquadByUnitId', unitId);
        if (squadData) {
            const unitType = this.getCurrentUnitTypeForSquad(squadData.placementId);
            return {
                placementId: squadData.placementId,
                unitType: unitType || { value: squadData.squadValue, title: 'Unknown', id: 'unknown' }
            };
        }

        // Fallback: search placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const allPlacements = [...playerPlacements, ...opponentPlacements];

        for (const placement of allPlacements) {
            if (placement.squadUnits) {
                const unitMatch = placement.squadUnits.find(entityId => entityId === unitId);
                if (unitMatch) {
                    return {
                        placementId: placement.placementId,
                        unitType: placement.unitType
                    };
                }
            }
        }

        // Last resort: use unit type component directly
        const unitTypeComponent = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);
        if (unitTypeComponent) {
            return {
                placementId: `unknown_${unitId}`,
                unitType: {
                    value: unitTypeComponent.value || 50,
                    title: unitTypeComponent.type || 'Unknown Unit',
                    id: unitTypeComponent.id || 'unknown'
                }
            };
        }

        return null;
    }
    
    /**
     * Get the current unit type for a squad (handles specializations)
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Current unit type
     */
    getCurrentUnitTypeForSquad(placementId) {
        const unitType = this.game.gameManager.call('getCurrentUnitTypeForSquad', placementId);
        if (unitType) {
            return unitType;
        }

        // Fallback to placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const placement = playerPlacements.find(p => p.placementId === placementId) ||
                         opponentPlacements.find(p => p.placementId === placementId);
        return placement ? placement.unitType : null;
    }
    
    /**
     * Get the original size of a squad when it was placed
     * @param {string} placementId - Squad placement ID
     * @returns {number} Original squad size
     */
    getOriginalSquadSize(placementId) {
        // Check experience system first
        const squadData = this.game.gameManager.call('getSquadExperienceData', placementId);
        if (squadData) {
            return squadData.totalUnitsInSquad || squadData.squadSize;
        }

        // Fallback to placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', 'left') || [];
        const opponentPlacements = this.game.gameManager.call('getPlacementsForSide', 'right') || [];
        const placement = playerPlacements.find(p => p.placementId === placementId) ||
                         opponentPlacements.find(p => p.placementId === placementId);
        if (placement) {
            return placement.squadUnits ? placement.squadUnits.length : 1;
        }

        return 1; // Default fallback
    }
    
    dealDamageToTeam(team, damage) {
        this.teamHealth[team] = Math.max(0, this.teamHealth[team] - damage);
        if(!this.game.isServer){
            this.updateHealthDisplay();
            this.showDamageEffect(team, damage);
        }
    }
    
    showDamageEffect(team, damage) {
        // Create floating damage text
        const damageText = document.createElement('div');
        damageText.className = `damage-popup ${team}-damage`;
        damageText.textContent = `-${damage}`;
        
        // Position based on team
        const healthBar = document.querySelector(`.${team}-health`);
        if (healthBar) {
            const rect = healthBar.getBoundingClientRect();
            damageText.style.position = 'fixed';
            damageText.style.left = `${rect.left + rect.width / 2}px`;
            damageText.style.top = `${rect.top}px`;
            damageText.style.zIndex = '1000';
            
            document.body.appendChild(damageText);
            
            // Animate and remove
            setTimeout(() => {
                if (damageText.parentNode) {
                    damageText.parentNode.removeChild(damageText);
                }
            }, 2000);
        }
    }
    
    resetTeamHealth() {
        this.teamHealth.left = this.MAX_TEAM_HEALTH;
        this.teamHealth.right = this.MAX_TEAM_HEALTH;
        this.roundProcessed = false;
        this.updateHealthDisplay();
    }
    
    getTeamHealth(team) {
        return this.teamHealth[team] || 0;
    }
    
    getHealthPercentage(team) {
        return (this.teamHealth[team] / this.MAX_TEAM_HEALTH) * 100;
    }
    
    // Get health status for UI
    getHealthStatus() {
        return {
            left: {
                current: this.teamHealth.left,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('left')
            },
            right: {
                current: this.teamHealth.right,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('right')
            }
        };
    }

    getLeftHealth() {
        return this.teamHealth.left || 0;
    }

    // Method for multiplayer compatibility - returns current right health  
    getRightHealth() {
        return this.teamHealth.right || 0;
    }

    // Method to set left health (for multiplayer server updates)
    setLeftHealth(health) {
        this.teamHealth.left = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Method to set right health (for multiplayer server updates)
    setRightHealth(health) {
        this.teamHealth.right = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Multiplayer-specific method to sync both team healths from server
    syncHealthFromServer(leftHealth, rightHealth) {
        this.teamHealth.left = Math.max(0, Math.min(leftHealth, this.MAX_TEAM_HEALTH));
        this.teamHealth.right = Math.max(0, Math.min(rightHealth, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Check if either team is eliminated (for multiplayer game end conditions)
    isGameOver() {
        return this.teamHealth.left <= 0 || this.teamHealth.right <= 0;
    }

    // Get the winning team (for multiplayer results)
    getWinningTeam() {
        if (this.teamHealth.left <= 0) return 'right';
        if (this.teamHealth.right <= 0) return 'left';
        return null; // No winner yet
    }
};

// system: HealthBarSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['HealthBarSystem'] = class HealthBarSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.healthBarSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Health bar configuration
        this.HEALTH_BAR_WIDTH = 32;
        this.HEALTH_BAR_HEIGHT = 4;
        this.HEALTH_BAR_OFFSET_Y = 50; // Units above unit
        this.BACKGROUND_DEPTH = 2; // Slight offset to prevent z-fighting
        
        // Track health bar meshes
        this.healthBars = new Map(); // entityId -> { background, fill, group, lastHealth }
        
        // Initialize only after world system is ready
        this.initialized = false;
    }
    
    initialize() {
        if (this.initialized || !this.game.scene) return;
        
        this.initialized = true;
        console.log('Simple Quad HealthBarSystem initialized');
    }
    
    update() {
        // Wait for scene to be available from WorldSystem
        if (!this.game.scene || !this.game.camera) {
            return;
        }
        
        // Initialize if not done yet
        if (!this.initialized) {
            this.initialize();
        }
        
        // Get all entities with health and position
        const healthEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.UNIT_TYPE
        );
        
        // Update existing health bars and create new ones
        healthEntities.forEach(entityId => {
            const pos    = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const team   = this.game.getComponent(entityId, this.componentTypes.TEAM);
            if (!pos || !health) return;

            // === Fog-of-war visibility filter (enemies only) ===
            const isEnemy = this.isEnemy(team);
            const isVisible = !isEnemy || this.isVisibleAt(pos);

            // If enemy not visible: hide existing bar (if any) and skip work
            if (!isVisible) {
                const hb = this.healthBars.get(entityId);
                if (hb) hb.group.visible = false;
                return;
            }
            // Coming back into vision: unhide if we already have one
            const existing = this.healthBars.get(entityId);
            if (existing) existing.group.visible = true;
            // === end FOW filter ===

            // Create health bar if it doesn't exist
            if (!existing) {
                this.createHealthBarMesh(entityId, team);
            }

            // Update health bar
            this.updateHealthBarMesh(entityId, pos, health, team);
        });
        
        // Clean up health bars for destroyed entities
        this.cleanupRemovedHealthBars(healthEntities);
    }
    
    createHealthBarMesh(entityId, team) {
        // Create group to hold both background and fill
        const group = new THREE.Group();
        
        // Create background quad (dark background)
        const backgroundGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);
        const backgroundMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222
        });
        const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        background.position.z = -this.BACKGROUND_DEPTH; // Slightly behind
        
        // Create health fill quad
        const fillGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);
        const fillMaterial = new THREE.MeshBasicMaterial({
            color: this.getHealthColor(team)
        });
        const fill = new THREE.Mesh(fillGeometry, fillMaterial);
        
        // Add both to group
        group.add(background);
        group.add(fill);
        
        // Add to scene
        this.game.scene.add(group);
        
        // Store references
        this.healthBars.set(entityId, {
            background: background,
            fill: fill,
            group: group,
            fillGeometry: fillGeometry,
            fillMaterial: fillMaterial,
            lastHealth: -1, // Force initial update
            lastHealthPercent: -1,
            lastMaxHealth: -1, // Track max health changes for notch updates
            notches: [] // Array to hold notch meshes
        });
        
        // Set high render order to ensure health bars render on top of everything
        background.renderOrder = 9999;
        fill.renderOrder = 10000;
    }
    
    updateHealthBarMesh(entityId, pos, health, team) {
        const healthBarData = this.healthBars.get(entityId);
        if (!healthBarData) return;
        
        const { background, fill, group, fillGeometry, fillMaterial } = healthBarData;
        

        // Position group above unit
        const unitType  = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const collections = this.game.getCollections?.();
        const unitData = (unitType && collections && collections[unitType.collection])
            ? collections[unitType.collection][unitType.id]
            : null;

        const baseY   = pos.y || 0;
        const heightY = (unitData && unitData.height != null)
            ? unitData.height
            : this.HEALTH_BAR_OFFSET_Y;

        group.position.set(pos.x, baseY + heightY, pos.z);

        
        // Make health bar always face camera (billboard effect)
        const cameraPosition = this.game.camera.position;
        group.lookAt(cameraPosition.x, cameraPosition.y, cameraPosition.z);
        
        // Calculate health percentage
        const currentHealthPercent = Math.max(0, Math.min(100, (health.current / health.max) * 100));
        
        // Only update if health changed
        if (healthBarData.lastHealthPercent !== currentHealthPercent) {
            // Update fill width by scaling
            const healthRatio = currentHealthPercent / 100;
            fill.scale.x = healthRatio;
            
            // Adjust position to keep fill left-aligned
            fill.position.x = -(this.HEALTH_BAR_WIDTH * (1 - healthRatio)) / 2;
            
            // Update color based on health percentage
            fillMaterial.color.setHex(this.getHealthColorByPercent(currentHealthPercent, team));
            
            healthBarData.lastHealthPercent = currentHealthPercent;
        }
        
        // Hide health bar if unit is at full health (optional)
        if (this.shouldHideFullHealthBars() && health.current >= health.max) {
            group.visible = false;
        } else {
            group.visible = true;
        }
        
        // Update notches based on max health
        this.updateHealthBarNotches(entityId, health.max);
    }
    
    getHealthColor(team) {
        const teamColors = {
            'player': 0x00ff00,  // Green for player
            'enemy': 0x00ff00,   // Green for enemy (all start green)
            'neutral': 0x00ff00  // Green for neutral
        };
        return teamColors[team?.team] || teamColors.neutral;
    }
    
    getHealthColorByPercent(percent, team) {
        // All units start with green, then transition based on health
        if (percent > 75) {
            return 0x00ff00; // Green
        } else if (percent > 50) {
            return 0x88ff00; // Yellow-green
        } else if (percent > 25) {
            return 0xffff00; // Yellow
        } else if (percent > 10) {
            return 0xff8800; // Orange
        } else {
            return 0xff0000; // Red for critical health
        }
    }
    
    updateHealthBarNotches(entityId, maxHealth) {
        const healthBarData = this.healthBars.get(entityId);
        if (!healthBarData) return;
        
        // Only update notches if max health changed
        if (healthBarData.lastMaxHealth === maxHealth) return;
        
        // Remove existing notches
        healthBarData.notches.forEach(notch => {
            healthBarData.group.remove(notch);
            notch.geometry.dispose();
            notch.material.dispose();
        });
        healthBarData.notches = [];
        
        // Calculate how many 100 HP marks we need
        const numNotches = Math.floor(maxHealth / 100);

        if (numNotches >= 1) { // Create notches for any unit with 100+ HP
            const notchWidth = 1; // Make notches wider so they're more visible
            const notchHeight = this.HEALTH_BAR_HEIGHT; // Make them shorter
            
            for (let i = 1; i <= numNotches; i++) { // i represents the HP value (100, 200, 300, etc.)
                const hpValue = i * 100; // 100, 200, 300, etc.
                
                // Calculate position as percentage of max health
                const positionPercent = hpValue / maxHealth; // 100/140 = 0.714 for your archer
                
                // Convert to X offset (-50% to +50% of bar width)
                const xOffset = (positionPercent - 0.5) * this.HEALTH_BAR_WIDTH;
                
                
                // Create notch geometry
                const notchGeometry = new THREE.PlaneGeometry(notchWidth, notchHeight);
                const notchMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000, // White notch lines for better visibility
                    transparent: false
                });
                
                const notch = new THREE.Mesh(notchGeometry, notchMaterial);
                notch.position.set(xOffset, -this.HEALTH_BAR_HEIGHT * 0.5 + notchHeight * 0.5, 0.2); // Further in front
                notch.renderOrder = 10001; // Above fill
                
                healthBarData.group.add(notch);
                healthBarData.notches.push(notch);
                
            }
        }
        
        healthBarData.lastMaxHealth = maxHealth;
    }
    
    shouldHideFullHealthBars() {
        // You can make this configurable
        return false; // Set to true to hide health bars when units are at full health
    }
    
    cleanupRemovedHealthBars(currentEntities) {
        const currentEntitySet = new Set(currentEntities);
        
        for (const [entityId] of this.healthBars.entries()) {
            if (!currentEntitySet.has(entityId)) {
                this.removeHealthBarMesh(entityId);
            }
        }
    }
    
    removeHealthBarMesh(entityId) {
        const healthBarData = this.healthBars.get(entityId);
        if (healthBarData) {
            // Remove group from scene
            if (this.game.scene) {
                this.game.scene.remove(healthBarData.group);
            }
            
            // Dispose of main geometries and materials
            healthBarData.background.geometry.dispose();
            healthBarData.background.material.dispose();
            healthBarData.fill.geometry.dispose();
            healthBarData.fill.material.dispose();
            
            // Dispose of notches
            healthBarData.notches.forEach(notch => {
                notch.geometry.dispose();
                notch.material.dispose();
            });
            
            // Remove from map
            this.healthBars.delete(entityId);
        }
    }
    
    // Utility methods for configuration
    setHealthBarScale(scale = 1.0) {
        this.healthBars.forEach(healthBarData => {
            const newWidth = this.HEALTH_BAR_WIDTH * scale;
            const newHeight = this.HEALTH_BAR_HEIGHT * scale;
            
            // Update background geometry
            healthBarData.background.geometry.dispose();
            healthBarData.background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
            
            // Update fill geometry 
            healthBarData.fillGeometry.dispose();
            healthBarData.fillGeometry = new THREE.PlaneGeometry(newWidth, newHeight);
            healthBarData.fill.geometry = healthBarData.fillGeometry;
            
            // Force position update
            healthBarData.lastHealthPercent = -1;
        });
    }
    isEnemy(teamComp) {
        const myTeam = this.game?.state?.mySide;
        if (myTeam == null || !teamComp) return false;
        return teamComp.team !== myTeam;
    }

    isVisibleAt(pos) {
        const fow = this.game?.fogOfWarSystem;
        if (!fow || !pos) return true; // if no FOW, default to visible
        return fow.isVisibleAt(pos.x, pos.z);
    }

    toggleHealthBars(visible = true) {
        this.healthBars.forEach(healthBarData => {
            healthBarData.group.visible = visible;
        });
    }
    
    setHealthBarOffset(offsetY) {
        this.HEALTH_BAR_OFFSET_Y = offsetY;
        // Positions will be updated on next frame
    }
    
    // Update all health bar colors (useful for team color changes)
    updateAllHealthBarColors() {
        this.healthBars.forEach((healthBarData, entityId) => {
            // Force color update
            healthBarData.lastHealthPercent = -1;
        });
    }
    
    // Set render order to ensure health bars appear on top
    setRenderOrder(order = 1000) {
        this.healthBars.forEach(healthBarData => {
            healthBarData.background.renderOrder = order;
            healthBarData.fill.renderOrder = order + 1;
        });
    }
    
    destroy() {
        // Clean up all health bar meshes
        for (const [entityId] of this.healthBars.entries()) {
            this.removeHealthBarMesh(entityId);
        }
        
        this.healthBars.clear();
        this.initialized = false;
        
        console.log('Simple Quad HealthBarSystem destroyed');
    }
};

// system: UnitRadiusSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['UnitRadiusSystem'] = class UnitRadiusSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.unitRadiusSystem = this;        
        this.componentTypes = this.game.componentManager.getComponentTypes();
        this.debugCircles = new Map(); // entityId -> { sizeCircle, attackCircle }
        this.enabled = false; // Toggle this to show/hide circles
        
        // Visual configuration
        this.SIZE_CIRCLE_COLOR = 0x00ff00;      // Green for unit size
        this.ATTACK_CIRCLE_COLOR = 0xff0000;    // Red for attack range
        this.CIRCLE_OPACITY = 0.3;
        this.CIRCLE_LINE_WIDTH = 2;
    }
    
    update() {
        if (!this.enabled ) return;
        if(this.game.state.phase !== 'battle') {
            this.hideAllCircles();
            return;
        }
        
        const entities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.UNIT_TYPE
        );
        
        entities.forEach(entityId => {
            this.updateEntityCircles(entityId);
        });
        
        // Clean up circles for destroyed entities
        this.cleanupDestroyedEntities(entities);
    }
    
    updateEntityCircles(entityId) {
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
        const combat = this.game.getComponent(entityId, this.componentTypes.COMBAT);
        
        if (!pos || !collision) return;
        
        // Get or create debug circles for this entity
        let circles = this.debugCircles.get(entityId);
        if (!circles) {
            circles = this.createDebugCircles(entityId);
            this.debugCircles.set(entityId, circles);
        }
        
        if (!circles.sizeCircle || !circles.attackCircle) {
            return;
        }
        
        // Update positions
        circles.sizeCircle.position.set(pos.x, pos.y + 50, pos.z); // y=1 to avoid z-fighting
        circles.attackCircle.position.set(pos.x, pos.y + 60, pos.z); // y=2 to be above size circle
        
        // Update sizes
        const unitRadius = this.getUnitRadius(collision);
        const attackRange = this.getAttackRange(combat, collision);
        
        //console.log(`Entity ${entityId}: unitRadius=${unitRadius}, attackRange=${attackRange}, pos=(${pos.x}, ${pos.y})`);
        
        // Scale the circles - base circle is 50 units radius, so scale accordingly
        circles.sizeCircle.scale.setScalar(unitRadius / 50);
        circles.attackCircle.scale.setScalar(attackRange / 50);
        
        // Always show size circle
        circles.sizeCircle.visible = true;
        
        // Show/hide attack circle based on entity state
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (aiState && (aiState.state === 'attacking' || aiState.state === 'chasing')) {
            circles.attackCircle.visible = true;
            if (aiState.state === 'attacking') {
                circles.attackCircle.material.color.setHex(0xff0000); // Bright red when attacking
            } else {
                circles.attackCircle.material.color.setHex(0xffaa00); // Orange when chasing
            }
        } else {
            circles.attackCircle.visible = true; // Show it anyway for debugging
            circles.attackCircle.material.color.setHex(0x0000ff); // Blue when idle
        }
    }
    
    createDebugCircles(entityId) {
        const scene = this.game.gameManager.call('getWorldScene');
        if (!scene) {
            console.error('No scene found!');
            return { sizeCircle: null, attackCircle: null };
        }

        // Create size circle (unit radius)
        const sizeGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring
        const sizeMaterial = new THREE.MeshBasicMaterial({
            color: this.SIZE_CIRCLE_COLOR,
            transparent: true,
            opacity: this.CIRCLE_OPACITY,
            side: THREE.DoubleSide
        });
        const sizeCircle = new THREE.Mesh(sizeGeometry, sizeMaterial);
        sizeCircle.rotation.x = -Math.PI / 2; // Lay flat on ground

        // Create attack range circle
        const attackGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring
        const attackMaterial = new THREE.MeshBasicMaterial({
            color: this.ATTACK_CIRCLE_COLOR,
            transparent: true,
            opacity: this.CIRCLE_OPACITY,
            side: THREE.DoubleSide
        });
        const attackCircle = new THREE.Mesh(attackGeometry, attackMaterial);
        attackCircle.rotation.x = -Math.PI / 2; // Lay flat on ground

        // Add to scene
        scene.add(sizeCircle);
        scene.add(attackCircle);

        return { sizeCircle, attackCircle };
    }
    
    getUnitRadius(collision) {
        // Use the same logic as your MovementSystem
        if (collision && collision.radius) {
            return collision.radius; 
        }
        
        return 0.1;
    }
    
    getAttackRange(combat, collision) {
        if (!combat) return 0;
        
        const unitRadius = this.getUnitRadius(collision);
        const attackRange = Math.max(combat.range, unitRadius);
        
        return attackRange;
    }
    
    cleanupDestroyedEntities(activeEntities) {
        const activeIds = new Set(activeEntities);
        const scene = this.game.gameManager.call('getWorldScene');

        for (const [entityId, circles] of this.debugCircles) {
            if (!activeIds.has(entityId)) {
                // Remove from scene
                if (circles.sizeCircle && scene) {
                    scene.remove(circles.sizeCircle);
                    circles.sizeCircle.geometry.dispose();
                    circles.sizeCircle.material.dispose();
                }
                if (circles.attackCircle && scene) {
                    scene.remove(circles.attackCircle);
                    circles.attackCircle.geometry.dispose();
                    circles.attackCircle.material.dispose();
                }

                // Remove from map
                this.debugCircles.delete(entityId);
            }
        }
    }
    
    hideAllCircles() {
        for (const [entityId, circles] of this.debugCircles) {
            if (circles.sizeCircle) circles.sizeCircle.visible = false;
            if (circles.attackCircle) circles.attackCircle.visible = false;
        }
    }
    
    showAllCircles() {
        for (const [entityId, circles] of this.debugCircles) {
            if (circles.sizeCircle) circles.sizeCircle.visible = true;
            if (circles.attackCircle) circles.attackCircle.visible = true;
        }
    }
    
    toggle() {
        this.enabled = !this.enabled;
        if (this.enabled) {
            this.showAllCircles();
        } else {
            this.hideAllCircles();
        }
        console.log(`Unit debug circles ${this.enabled ? 'enabled' : 'disabled'}`);
    }
    
    cleanup() {
        this.hideAllCircles();
        this.cleanupDestroyedEntities([]);
    }
};

// system: EquipmentSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['EquipmentSystem'] = class EquipmentSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.equipmentSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.entityEquipment = new Map();
        this.equipmentCache = new Map();
        this.equipmentBatches = new Map();
        this.equipmentInstances = new Map();
        
        this.scaleFactor = 32;
        this.DEFAULT_CAPACITY = 128;
        this.bonePrefix = 'mixamorig';
        
        this.boneNameMappings = {
            default: {
                mainHand: ['RightHand', 'Hand_R', 'hand_R', 'R_Hand'],
                offHand: ['LeftHand', 'Hand_L', 'hand_L', 'L_Hand'],
                head: ['Head', 'head', 'Head_M'],
                chest: ['Spine2', 'spine2', 'Chest', 'chest'],
                back: ['Spine', 'spine', 'Back', 'back']
            }
        };
        
        this.slotDefaultOffsets = {
            mainHand: { x: 0, y: 0, z: 0 },
            offHand: { x: 0, y: 0, z: 0 },
            head: { x: 0, y: 0.15, z: 0 },
            chest: { x: 0, y: 0, z: 0 },
            back: { x: 0, y: 0, z: -0.2 }
        };
        
        console.log('[Equipment] System initialized with bone attachment texture');
    }

    init() {
        this.game.gameManager.register('getItemData', this.getItemData.bind(this));
    }

    getItemData(itemId) {
        if (!itemId) return null;
        const collections = this.game.getCollections();
        return collections.items?.[itemId] || null;
    }

    update() {
        const entities = this.game.getEntitiesWith(
            this.componentTypes.EQUIPMENT,
            this.componentTypes.POSITION
        );
        
        entities.forEach(entityId => {
            this.updateEntityEquipment(entityId);
        });
        
        this.cleanupRemovedEntities(entities);
    }
    
    updateEntityEquipment(entityId) {
        const equipmentData = this.equipmentInstances.get(entityId);
        if (!equipmentData) return;
        
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
        
        if (!pos) return;
        
        const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);
        if (!unitInstance) return;
        
        const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);
        if (!unitBatch) return;
        
        for (const [slotType, equipInstance] of equipmentData.entries()) {
            this.updateEquipmentTransformWithBone(
                equipInstance, 
                pos, 
                facing, 
                unitBatch,
                unitInstance
            );
        }
    }
    
    sampleAttachmentMatrix(attachmentTexture, cols, rows, rowIndex, attachmentBoneIndex) {
        if (!attachmentTexture?.image?.data) return null;
        
        const textureData = attachmentTexture.image.data;
        const boneColStart = attachmentBoneIndex * 4;
        
        const matrix = new THREE.Matrix4();
        const elements = matrix.elements;
        
        for (let col = 0; col < 4; col++) {
            const pixelX = Math.floor(boneColStart + col);
            const pixelY = Math.floor(rowIndex);
            
            if (pixelX >= cols || pixelY >= rows || pixelY < 0) {
                return null;
            }
            
            const pixelIndex = (pixelY * cols + pixelX) * 4;
            
            elements[col * 4 + 0] = textureData[pixelIndex + 0];
            elements[col * 4 + 1] = textureData[pixelIndex + 1];
            elements[col * 4 + 2] = textureData[pixelIndex + 2];
            elements[col * 4 + 3] = textureData[pixelIndex + 3];
        }
        
        return matrix;
    }
        
    updateEquipmentTransformWithBone(equipInstance, pos, facing, unitBatch, unitInstance) {
        const batch = this.equipmentBatches.get(equipInstance.batchKey);
        if (!batch || equipInstance.instanceIndex === null) return;
        
        if (!unitBatch?.meta?.attachmentTexture) return;
        
        const clipIndex = unitBatch.attributes.clipIndex.array[unitInstance.instanceIndex];
        const animTime = unitBatch.attributes.animTime.array[unitInstance.instanceIndex];
        
        if (clipIndex === undefined || animTime === undefined) return;
        
        const clipInfo = unitBatch.meta.clips[clipIndex];
        if (!clipInfo) return;
        
        const fps = unitBatch.meta.fps || 30;
        const frame = Math.floor((animTime * fps) % clipInfo.frames);
        const rowIndex = clipInfo.startRow + frame;
        
        const attachmentBoneIndex = equipInstance.attachmentBoneIndex;
        if (attachmentBoneIndex === undefined || attachmentBoneIndex < 0) return;
        
        const skinningMatrix = this.sampleAttachmentMatrix(
            unitBatch.meta.attachmentTexture,
            unitBatch.meta.attachmentTexture.image.width,
            unitBatch.meta.attachmentTexture.image.height,
            rowIndex,
            attachmentBoneIndex
        );
        
        if (!skinningMatrix) return;
        
        const skeleton = unitBatch.meta.skeleton;
        const originalBoneIndex = unitBatch.meta.attachmentBones[attachmentBoneIndex].index;
        const bindInverse = skeleton.boneInverses[originalBoneIndex];

        const bindPose = new THREE.Matrix4().copy(bindInverse).invert();
        const boneWorldLocal = new THREE.Matrix4().multiplyMatrices(skinningMatrix, bindPose);
        
        const bonePos = new THREE.Vector3();
        const boneQuat = new THREE.Quaternion();
        const boneScale = new THREE.Vector3();
        boneWorldLocal.decompose(bonePos, boneQuat, boneScale);
        
        const baseScale = unitBatch.meta.baseScale || new THREE.Vector3(1, 1, 1);
        const basePosition = unitBatch.meta.basePos || new THREE.Vector3(0, 0, 0);
        
        bonePos.multiply(baseScale);
        bonePos.multiplyScalar(this.scaleFactor);
        
        const slotDefaults = this.slotDefaultOffsets[equipInstance.slotType] || { x: 0, y: 0, z: 0 };
        const offsetVec = new THREE.Vector3(
            slotDefaults.x,
            slotDefaults.y,
            slotDefaults.z
        );
        
        if (equipInstance.attachmentData?.offset) {
            offsetVec.x += (equipInstance.attachmentData.offset.x * 0.5);
            offsetVec.y += (equipInstance.attachmentData.offset.y * 0.5);
            offsetVec.z += (equipInstance.attachmentData.offset.z * 0.5);
        }
        const boneRotation = boneQuat.clone();
        if (equipInstance.attachmentData?.rotation) {
            const offsetRot = new THREE.Quaternion();
            offsetRot.setFromEuler(new THREE.Euler(
                (equipInstance.attachmentData.rotation.x) * Math.PI / 180,
                (equipInstance.attachmentData.rotation.y) * Math.PI / 180,
                (equipInstance.attachmentData.rotation.z) * Math.PI / 180,
                'XYZ'
            ));
            boneRotation.multiply(offsetRot);
        }
        
        offsetVec.applyQuaternion(boneRotation);
        bonePos.add(offsetVec);
        
        const rotationY = facing ? (-facing.angle + Math.PI / 2) : (Math.PI / 2);
        const worldRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
        
        bonePos.applyQuaternion(worldRotation);
        
        const worldPos = new THREE.Vector3(
            pos.x + basePosition.x * this.scaleFactor,
            (pos.y || 0) + basePosition.y * this.scaleFactor,
            pos.z + basePosition.z * this.scaleFactor
        );
        bonePos.add(worldPos);
        
        const finalRotation = new THREE.Quaternion().multiplyQuaternions(worldRotation, boneRotation);
        
        const finalScale = new THREE.Vector3(this.scaleFactor * 0.25, this.scaleFactor * 0.25, this.scaleFactor * 0.25);
        
        const matrix = new THREE.Matrix4();
        matrix.compose(bonePos, finalRotation, finalScale);
        
        batch.mesh.setMatrixAt(equipInstance.instanceIndex, matrix);
        batch.mesh.instanceMatrix.needsUpdate = true;
    }
    
    findAttachmentBoneIndex(attachmentBones, boneName) {
        if (!attachmentBones) return -1;
        
        for (let i = 0; i < attachmentBones.length; i++) {
            const bone = attachmentBones[i];
            if (bone.name === boneName || 
                bone.name.replace(this.bonePrefix, '') === boneName ||
                bone.name.includes(boneName)) {
                console.log(`[Equipment] Found attachment bone "${boneName}" at index ${i} (original: ${bone.index})`);
                return i;
            }
        }
        
        console.warn(`[Equipment] Attachment bone not found: ${boneName}`);
        return -1;
    }
   
    async equipItem(entityId, slotData, itemData) {
        return false;
        // const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        // const slotType = slotData.slot;
        // if (!equipment) return false;
        
        // if (equipment.slots[slotType]) {
        //     await this.unequipItem(entityId, slotType);
        // }
        
        // const spawnType = slotData.item;
        // const equipmentModel = await this.loadEquipmentModel(spawnType);
        // if (!equipmentModel) return false;
        
        // const batchKey = `equipment_${spawnType}`;
        // let batch = this.equipmentBatches.get(batchKey);
        
        // if (!batch) {
        //     batch = this.createEquipmentBatch(batchKey, equipmentModel);
        //     if (!batch) return false;
        // }
        
        // const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);
        // if (!unitInstance) return false;
        
        // const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);
        // if (!unitBatch?.meta?.attachmentBones) {
        //     console.error('[Equipment] Unit has no attachment bone data');
        //     return false;
        // }
        
        // const boneNames = this.boneNameMappings.default[slotType];
        // let attachmentBoneIndex = -1;
        
        // for (const boneName of boneNames) {
        //     attachmentBoneIndex = this.findAttachmentBoneIndex(unitBatch.meta.attachmentBones, boneName);
        //     if (attachmentBoneIndex >= 0) break;
        // }
        
        // if (attachmentBoneIndex < 0) {
        //     console.error(`[Equipment] No valid attachment bone found for slot ${slotType}`);
        //     return false;
        // }
        
        // const instanceIndex = this.allocateEquipmentInstance(batch);
        // if (instanceIndex === null) return false;
        
        // const equipInstance = {
        //     batchKey,
        //     instanceIndex,
        //     slotType,
        //     attachmentBoneIndex,
        //     attachmentData: slotData.attachmentData
        // };
        
        // if (!this.equipmentInstances.has(entityId)) {
        //     this.equipmentInstances.set(entityId, new Map());
        // }
        // this.equipmentInstances.get(entityId).set(slotType, equipInstance);
        
        // if (!this.entityEquipment.has(entityId)) {
        //     this.entityEquipment.set(entityId, new Map());
        // }
        
        // this.entityEquipment.get(entityId).set(slotType, {
        //     itemData,
        //     spawnType,
        //     instanceIndex,
        //     batchKey
        // });
        
        // equipment.slots[slotType] = {
        //     itemData,
        //     equippedItem: itemData
        // };
        
        // console.log(`[Equipment] Equipped ${spawnType} to entity ${entityId} slot ${slotType} attachment bone ${attachmentBoneIndex}`);
        // return true;
    }
    
    createEquipmentBatch(batchKey, equipmentModel) {
        let geometry = null;
        let material = null;
            
        equipmentModel.updateMatrixWorld(true);

        equipmentModel.traverse(child => {
            if (child.isMesh && !geometry) {
                geometry = child.geometry.clone();
                child.updateMatrixWorld(true);
                geometry.applyMatrix4(child.matrixWorld);
                material = child.material.clone();
            }
        });
        
        if (!geometry || !material) return null;
        
        material.metalness = material.metalness || 0;
        material.roughness = material.roughness || 1;
        
        const instancedMesh = new THREE.InstancedMesh(geometry, material, this.DEFAULT_CAPACITY);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        instancedMesh.castShadow = true;
        instancedMesh.receiveShadow = true;
        instancedMesh.frustumCulled = false;
        
        const hiddenMatrix = new THREE.Matrix4();
        hiddenMatrix.makeTranslation(0, -10000, 0);
        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        
        for (let i = 0; i < this.DEFAULT_CAPACITY; i++) {
            instancedMesh.setMatrixAt(i, hiddenMatrix);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
        
        if (this.game.scene) {
            this.game.scene.add(instancedMesh);
        }
        
        const batch = {
            mesh: instancedMesh,
            capacity: this.DEFAULT_CAPACITY,
            count: 0,
            availableIndices: Array.from({ length: this.DEFAULT_CAPACITY }, (_, i) => i),
            usedIndices: new Set()
        };
        
        this.equipmentBatches.set(batchKey, batch);
        return batch;
    }
    
    allocateEquipmentInstance(batch) {
        if (batch.availableIndices.length === 0) return null;
        const instanceIndex = batch.availableIndices.shift();
        batch.usedIndices.add(instanceIndex);
        batch.count++;
        return instanceIndex;
    }
    
    releaseEquipmentInstance(batch, instanceIndex) {
        if (!batch.usedIndices.has(instanceIndex)) return;
        
        const hiddenMatrix = new THREE.Matrix4();
        hiddenMatrix.makeTranslation(0, -10000, 0);
        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        batch.mesh.setMatrixAt(instanceIndex, hiddenMatrix);
        batch.mesh.instanceMatrix.needsUpdate = true;
        
        batch.usedIndices.delete(instanceIndex);
        batch.availableIndices.push(instanceIndex);
        batch.count--;
    }
    
    async unequipItem(entityId, slotType) {
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (!equipment || !equipment.slots[slotType]) return true;
        
        const equipInstance = this.equipmentInstances.get(entityId)?.get(slotType);
        
        if (equipInstance) {
            const batch = this.equipmentBatches.get(equipInstance.batchKey);
            if (batch) {
                this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);
            }
            this.equipmentInstances.get(entityId)?.delete(slotType);
        }
        
        const entityEquip = this.entityEquipment.get(entityId);
        if (entityEquip) {
            entityEquip.delete(slotType);
        }
        
        equipment.slots[slotType] = null;
        return true;
    }
    
    async loadEquipmentModel(spawnType) {
        const cacheKey = `items_${spawnType}`;
        
        if (this.equipmentCache.has(cacheKey)) {
            return this.equipmentCache.get(cacheKey).clone();
        }
        
        try {
            const model = this.game.modelManager.getModel("items", spawnType);
            
            if (model) {
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.metalness = child.material.metalness || 0;
                            child.material.roughness = child.material.roughness || 1;
                        }
                    }
                });
                
                this.equipmentCache.set(cacheKey, model);
                return model.clone();
            }
        } catch (error) {
            console.error(`Error loading equipment model ${cacheKey}:`, error);
        }
        
        return null;
    }
    
    cleanupRemovedEntities(activeEntities) {
        const activeSet = new Set(activeEntities);
        
        for (const [entityId, equipmentMap] of this.equipmentInstances.entries()) {
            if (!activeSet.has(entityId)) {
                for (const [slotType, equipInstance] of equipmentMap.entries()) {
                    const batch = this.equipmentBatches.get(equipInstance.batchKey);
                    if (batch) {
                        this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);
                    }
                }
                this.equipmentInstances.delete(entityId);
                this.entityEquipment.delete(entityId);
            }
        }
    }
    
    destroy() {
        for (const [batchKey, batch] of this.equipmentBatches.entries()) {
            if (batch.mesh) {
                if (this.game.scene) {
                    this.game.scene.remove(batch.mesh);
                }
                batch.mesh.geometry.dispose();
                if (Array.isArray(batch.mesh.material)) {
                    batch.mesh.material.forEach(mat => mat.dispose());
                } else {
                    batch.mesh.material.dispose();
                }
            }
        }
        
        for (const [key, model] of this.equipmentCache.entries()) {
            model.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        this.equipmentBatches.clear();
        this.equipmentInstances.clear();
        this.entityEquipment.clear();
        this.equipmentCache.clear();
    }
};

// system: DeathSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DeathSystem'] = class DeathSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.deathSystem = this;
    }
    
    update() {
        // Get all entities with death state
        const dyingEntities = this.game.getEntitiesWith(this.componentTypes.DEATH_STATE);
        dyingEntities.forEach(entityId => {
            const deathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        
            if (deathState.isDying) {
                const timeSinceDeath = this.game.state.now - deathState.deathStartTime;
                
                // Remove health (corpses can't be damaged)
                if (this.game.hasComponent(entityId, this.componentTypes.HEALTH)) {
                    this.game.removeComponent(entityId, this.componentTypes.HEALTH);
                }
                
                // Remove velocity (corpses don't move)
                if (this.game.hasComponent(entityId, this.componentTypes.VELOCITY)) {
                    this.game.removeComponent(entityId, this.componentTypes.VELOCITY);
                }
                
                const timerExpired = timeSinceDeath >= deathState.deathAnimationDuration * 0.975;
                
                if (timerExpired) {
                    console.log(entityId, "DIED");
                    if(unitType && unitType.collection == "buildings"){
                        this.destroyBuilding(entityId);
                    } else {
                        this.convertToCorpse(entityId);
                    }
                }
            }
        });
    }



    destroyBuilding(entityId) {
        this.game.triggerEvent('onDestroyBuilding', entityId);
        this.game.destroyEntity(entityId);  
        return { success: true };
    }
    
    convertToCorpse(entityId) {
        const Components = this.game.componentManager.getComponents();
        
        // Get current components before conversion
        const position = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const renderable = this.game.getComponent(entityId, this.componentTypes.RENDERABLE);
        
        if (!position || !unitType || !team) return;

        // CRITICAL: Notify AnimationSystem FIRST to set corpse state
        if(this.game.gameManager.has('setCorpseAnimation')){
            this.game.gameManager.call('setCorpseAnimation', entityId);
        }

        // Remove death state
        this.game.removeComponent(entityId, this.componentTypes.DEATH_STATE);        
        
        this.game.triggerEvent('onUnitKilled', entityId);
        // Add corpse component
        this.game.addComponent(entityId, this.componentTypes.CORPSE, Components.Corpse(
            { ...unitType }, 
            (this.game.state.now || 0), 
            team.team
        ));
        
    }
    
    // Rest of your existing methods remain the same...
    getCorpsesInRange(position, range, teamFilter = null) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        const nearbyCorpses = [];
        
        corpses.forEach(corpseId => {
            const corpsePos = this.game.getComponent(corpseId, this.componentTypes.POSITION);
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            
            if (!corpsePos || !corpse) return;
            
            // Check team filter if specified
            if (teamFilter && corpse.teamAtDeath !== teamFilter) return;
            
            // Check distance
            const dx = corpsePos.x - position.x;
            const dz = corpsePos.z - position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance <= range) {
                nearbyCorpses.push({
                    entityId: corpseId,
                    position: corpsePos,
                    corpse: corpse,
                    distance: distance
                });
            }
        });
        
        return nearbyCorpses;
    }
    
    consumeCorpse(corpseId) {
        // Remove corpse from battlefield (for abilities that consume corpses)
        const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
        if (!corpse) return null;
        
        // Return corpse data for the ability to use
        const corpseData = { ...corpse };
        
        // Destroy the corpse entity
        this.game.destroyEntity(corpseId);
        
        return corpseData;
    }
    
    getAllCorpses() {
        return this.game.getEntitiesWith(this.componentTypes.CORPSE);
    }
    
    getCorpsesByTeam(team) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        return corpses.filter(corpseId => {
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            return corpse && corpse.teamAtDeath === team;
        });
    }
};

// system: DamageSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DamageSystem'] = class DamageSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.damageSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Element types
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };

        // Poison DoT configuration
        this.POISON_CONFIG = {
            DEFAULT_DURATION: 5.0,  // seconds
            DEFAULT_TICKS: 5,       // number of damage instances
            STACK_LIMIT: 50,         // maximum poison stacks
            STACK_REFRESH: true     // new poison refreshes duration
        };

        // Status effect tracking
        this.activeStatusEffects = new Map(); // entityId -> { poison: [...], other effects }
        
        // Damage event queue for delayed damage (melee attacks, etc.)
        this.pendingDamageEvents = new Map();
        
        // Configuration
        this.RESISTANCE_CAP = 0.9; // Maximum resistance (90%)
        this.MIN_DAMAGE = 1; // Minimum damage that can be dealt
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('applyDamage', this.applyDamage.bind(this));
        this.game.gameManager.register('applySplashDamage', this.applySplashDamage.bind(this));
        this.game.gameManager.register('getDamageElementTypes', () => this.ELEMENT_TYPES);
        this.game.gameManager.register('scheduleDamage', this.scheduleDamage.bind(this));
        this.game.gameManager.register('curePoison', this.curePoison.bind(this));
        this.game.gameManager.register('getPoisonStacks', this.getPoisonStacks.bind(this));
        this.game.gameManager.register('clearAllDamageEffects', this.clearAllDamageEffects.bind(this));
        this.game.gameManager.register('clearAllStatusEffects', this.clearAllStatusEffects.bind(this));
        this.game.gameManager.register('getAttackerModifiers', this.getAttackerModifiers.bind(this));
    }

    // =============================================
    // CORE DAMAGE APPLICATION METHODS
    // =============================================

    /**
     * Main damage application method - handles all damage types and resistances
     * @param {number} sourceId - Entity dealing damage
     * @param {number} targetId - Entity receiving damage  
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element type
     * @param {Object} options - Additional options (splash, crit, etc.)
     */
    applyDamage(sourceId, targetId, baseDamage, element = this.ELEMENT_TYPES.PHYSICAL, options = {}) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);

        if (!targetHealth || (targetDeathState && targetDeathState.isDying)) {
            return { damage: 0, prevented: true, reason: 'target_invalid' };
        }
        
        const defenderMods = this.getDefenderModifiers(targetId);
        // Get target's defenses
        const defenses = this.getEntityDefenses(targetId, defenderMods);
        const attackerMods = this.getAttackerModifiers(sourceId);
        let buffedDamage = baseDamage * attackerMods.damageMultiplier;

        

        if (options.isCritical) {
            buffedDamage *= options.criticalMultiplier || 2.0;
        }
        // Handle poison as special case (DoT)
        if (element === this.ELEMENT_TYPES.POISON) {
            return this.applyPoisonDoT(sourceId, targetId, buffedDamage, options);
        }
        // Calculate final damage after resistances/armor
        const damageResult = this.calculateFinalDamage(sourceId, targetId, buffedDamage, element, defenses, defenderMods, options);

        // Apply immediate damage
        targetHealth.current -= damageResult.finalDamage;

        // Visual feedback
        this.applyVisualFeedback(targetId, damageResult, element);

        // Check for death
        if (targetHealth.current <= 0) {
            this.handleEntityDeath(targetId);
        }

        this.game.gameManager.call('setRetaliatoryTarget', targetId, sourceId);
        
        this.game.gameManager.call('showDamageNumber', targetPos.x, targetPos.y + targetUnitType.height, targetPos.z, damageResult.finalDamage, element);
        
        return {
            damage: damageResult.finalDamage,
            originalDamage: baseDamage,
            buffedDamage: buffedDamage,
            mitigated: damageResult.mitigated,
            element: element,
            fatal: targetHealth.current <= 0
        };
    }
    getAttackerModifiers(attackerId) {
        const buff = this.game.getComponent(attackerId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        return {
            damageMultiplier: buff.modifiers?.damageMultiplier || 1.0,
            attackSpeedMultiplier: buff.modifiers?.attackSpeedMultiplier || 1.0
        };
    }
    getDefenderModifiers(defenderId) {
        const buff = this.game.getComponent(defenderId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        return {
            armorMultiplier: buff.modifiers?.armorMultiplier || buff.armorMultiplier || 1.0,
            damageTakenMultiplier: buff.modifiers?.damageTakenMultiplier || buff.damageTakenMultiplier || 1.0,
            damageReduction: buff.modifiers?.damageReduction || buff.damageReduction || 0,
            additionalLightningResistance: buff.modifiers?.additionalLightningResistance || buff.additionalLightningResistance || 0,
            additionalFireResistance: buff.modifiers?.additionalFireResistance || buff.additionalFireResistance || 0,
            additionalColdResistance: buff.modifiers?.additionalColdResistance || buff.additionalColdResistance || 0,
            additionalElementalResistance: buff.modifiers?.additionalElementalResistance || buff.additionalElementalResistance || 0
        };
    }
    /**
     * Apply splash/area damage around a point
     * @param {number} sourceId - Source of the damage
     * @param {Object} centerPos - Center position {x, y, z}
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element
     * @param {number} radius - Splash radius
     * @param {Object} options - Additional options
     */
    applySplashDamage(sourceId, centerPos, baseDamage, element, radius, options = {}) {
        const results = [];
        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        if (!sourceTeam) return results;

        // Find all entities within splash radius
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        allEntities.forEach(entityId => {
            if (entityId === sourceId && !options.allowSelfDamage) return; // Don't damage source by default
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityTeam) return;
            if (entityTeam.team === sourceTeam.team && !options.allowFriendlyFire) return;

            // Calculate 3D distance from explosion center
            const distance = this.calculateDistance3D(centerPos, entityPos);
            
            if (distance <= radius) {
                // Calculate damage based on distance (closer = more damage)
                const damageMultiplier = Math.max(0.2, 1 - (distance / radius));
                const adjustedDamage = Math.floor(baseDamage * damageMultiplier);
           
                // Apply damage (experience will be awarded inside applyDamage)
                const result = this.applyDamage(sourceId, entityId, adjustedDamage, element, {
                    ...options,
                    isSplash: true,
                    splashDistance: distance,
                    splashMultiplier: damageMultiplier
                });
                

                if (result.damage > 0) {
                    results.push({
                        entityId,
                        ...result,
                        distance
                    });
                }
            }
        });

        return results;
    }

    // =============================================
    // DAMAGE CALCULATION METHODS
    // =============================================

    /**
     * Calculate final damage after all resistances and modifiers
     */
    calculateFinalDamage(sourceId, targetId, baseDamage, element, defenses, defenderMods, options = {}) {
        let finalDamage = baseDamage;
        let mitigated = 0;

        // Apply element-specific damage reduction
        switch (element) {
            case this.ELEMENT_TYPES.PHYSICAL:
                const armor = defenses.armor || 0;
                mitigated = Math.min(armor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - armor);
                break;

            case this.ELEMENT_TYPES.FIRE:
                const fireResist = this.capResistance(defenses.fireResistance || 0);
                mitigated = Math.floor(finalDamage * fireResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - fireResist)));
                break;

            case this.ELEMENT_TYPES.COLD:
                const coldResist = this.capResistance(defenses.coldResistance || 0);
                mitigated = Math.floor(finalDamage * coldResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - coldResist)));
                break;

            case this.ELEMENT_TYPES.LIGHTNING:
                const lightningResist = this.capResistance(defenses.lightningResistance || 0);
                mitigated = Math.floor(finalDamage * lightningResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - lightningResist)));
                break;

            case this.ELEMENT_TYPES.DIVINE:
                // Divine damage cannot be reduced
                mitigated = 0;
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage));
                break;

            default:
                console.warn(`Unknown damage element: ${element}, treating as physical`);
                const defaultArmor = defenses.armor || 0;
                mitigated = Math.min(defaultArmor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - defaultArmor);
                break;
        }
        // Apply damage taken multiplier (from marks, etc.)
        finalDamage *= defenderMods.damageTakenMultiplier;
        
        // Apply flat damage reduction (from intimidation, shield wall, etc.)
        if (defenderMods.damageReduction > 0) {
            const reductionAmount = Math.floor(finalDamage * defenderMods.damageReduction);
            finalDamage -= reductionAmount;
            mitigated += reductionAmount;
        }
        return {
            finalDamage,
            mitigated,
            originalDamage: baseDamage
        };
    }

    /**
     * Get entity's defensive stats from all sources
     */
    getEntityDefenses(entityId, defenderMods) {
        const defenses = {
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0
        };

        // Get base defenses from combat component
        const combatComponent = this.game.getComponent(entityId, this.componentTypes.COMBAT);
        if (combatComponent) {
            defenses.armor = combatComponent.armor || 0;
            defenses.fireResistance = combatComponent.fireResistance || 0;
            defenses.coldResistance = combatComponent.coldResistance || 0;
            defenses.lightningResistance = combatComponent.lightningResistance || 0;
        }

        // Add temporary resistance bonuses from status effects
        defenses.armor *= defenderMods.armorMultiplier; // Apply armor multiplier from buffs
        defenses.fireResistance = defenses.fireResistance + defenderMods.additionalFireResistance + defenderMods.additionalElementalResistance;
        defenses.coldResistance = defenses.coldResistance + defenderMods.additionalColdResistance + defenderMods.additionalElementalResistance;
        defenses.lightningResistance = defenses.lightningResistance + defenderMods.additionalLightningResistance + defenderMods.additionalElementalResistance;

        return defenses;
    }

    // =============================================
    // POISON SYSTEM METHODS
    // =============================================

    /**
     * Apply poison damage over time - poison cannot be resisted, only cured
     */
    applyPoisonDoT(sourceId, targetId, totalDamage, options = {}) {
        const duration = options.duration || this.POISON_CONFIG.DEFAULT_DURATION;
        const ticks = options.ticks || this.POISON_CONFIG.DEFAULT_TICKS;
        
        // Poison cannot be resisted - it always applies at full strength
        const perTickDamage = Math.max(1, Math.ceil(totalDamage / ticks));

        // Initialize status effects for target if needed
        if (!this.activeStatusEffects.has(targetId)) {
            this.activeStatusEffects.set(targetId, { poison: [] });
        }

        const statusEffects = this.activeStatusEffects.get(targetId);
        
        // Check current poison stacks
        if (statusEffects.poison.length >= this.POISON_CONFIG.STACK_LIMIT) {
            if (this.POISON_CONFIG.STACK_REFRESH) {
                // Remove oldest poison stack and add new one
                statusEffects.poison.shift();
            } else {
                // Cannot add more poison
                return { damage: 0, prevented: true, reason: 'stack_limit' };
            }
        }
        const poisonEffect = {
            sourceId,
            remainingTicks: ticks,
            damagePerTick: perTickDamage,
            tickInterval: duration / ticks,
            nextTickTime: this.game.state.now + (duration / ticks),
            startTime: this.game.state.now,
            totalDamage: perTickDamage * ticks
        };

        statusEffects.poison.push(poisonEffect);

      
        return {
            damage: poisonEffect.totalDamage,
            isPoison: true,
            stacks: statusEffects.poison.length,
            tickDamage: perTickDamage,
            duration: duration
        };
    }

    /**
     * Process ongoing poison damage
     */
    processStatusEffects() {     

        
        for (const [entityId, statusEffects] of this.activeStatusEffects.entries()) {
            const targetHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const targetDeathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            
            if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                // Entity is dead or dying, remove all status effects
                this.activeStatusEffects.delete(entityId);
                continue;
            }
            // Process poison effects
            statusEffects.poison = statusEffects.poison.filter(poisonEffect => {
                if (this.game.state.now >= poisonEffect.nextTickTime) {
                    // Apply poison damage
                    targetHealth.current -= poisonEffect.damagePerTick;
                    
                    // Visual feedback for poison
                    this.applyVisualFeedback(entityId, { finalDamage: poisonEffect.damagePerTick }, this.ELEMENT_TYPES.POISON);

                    // Check for death from poison
                    if (targetHealth.current <= 0) {
                        this.handleEntityDeath(entityId);
                        return false; // Remove this poison effect
                    }

                    // Update for next tick
                    poisonEffect.remainingTicks--;
                    poisonEffect.nextTickTime = this.game.state.now + poisonEffect.tickInterval;

                    // Keep poison if ticks remain
                    return poisonEffect.remainingTicks > 0;
                }
                return true; // Keep poison effect
            });

            // Remove entity from status effects if no effects remain
            if (statusEffects.poison.length === 0) {
                this.activeStatusEffects.delete(entityId);
            }
        }
    }

    /**
     * Cure poison effects
     */
    curePoison(targetId, stacksToRemove = null) {
        const statusEffects = this.activeStatusEffects.get(targetId);
        if (!statusEffects || statusEffects.poison.length === 0) return false;

        const removeCount = stacksToRemove || statusEffects.poison.length;
        const removedStacks = statusEffects.poison.splice(0, removeCount);

        if (statusEffects.poison.length === 0) {
            this.activeStatusEffects.delete(targetId);
        }

        return true;
    }

    // =============================================
    // DELAYED DAMAGE SYSTEM
    // =============================================

    /**
     * Schedule damage to be applied later (for melee attacks, timed effects, etc.)
     */
    scheduleDamage(sourceId, targetId, damage, element, delay, options = {}) {
        const triggerTime = this.game.state.now + delay;
        const eventId = `${sourceId}_${targetId}_${this.game.state.now}_${Math.random()}`;
        
        this.pendingDamageEvents.set(eventId, {
            sourceId,
            targetId,
            damage,
            element: element || this.ELEMENT_TYPES.PHYSICAL,
            triggerTime,
            options,
            eventId
        });
        
        return eventId;
    }

    /**
     * Process pending damage events
     */
    processPendingDamage() {        

        const eventsToRemove = [];
        
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {

            if (this.game.state.now >= event.triggerTime) {
                // Check if target is still valid
                const targetHealth = this.game.getComponent(event.targetId, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(event.targetId, this.componentTypes.DEATH_STATE);
                
                if (targetHealth && targetHealth.current > 0 && (!targetDeathState || !targetDeathState.isDying)) {
                    // Apply the delayed damage
                     this.applyDamage(event.sourceId, event.targetId, event.damage, event.element, {
                        ...event.options,
                        isDelayed: true
                    });
                }
                
                eventsToRemove.push(eventId);
            }
        }
        
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
    }


    calculateDistance3D(pos1, pos2) {
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dz = pos2.z - pos1.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    capResistance(resistance) {
        return Math.min(this.RESISTANCE_CAP, Math.max(-1.0, resistance));
    }

    getPoisonStacks(entityId) {
        const statusEffects = this.activeStatusEffects.get(entityId);
        return statusEffects ? statusEffects.poison.length : 0;
    }


    applyVisualFeedback(targetId, damageResult, element) {
        const targetAnimation = this.game.getComponent(targetId, this.componentTypes.ANIMATION);
        if (targetAnimation) {
            // Different flash intensities based on element
            switch (element) {
                case this.ELEMENT_TYPES.FIRE:
                    targetAnimation.flash = 0.6;
                    break;
                case this.ELEMENT_TYPES.COLD:
                    targetAnimation.flash = 0.5;
                    break;
                case this.ELEMENT_TYPES.LIGHTNING:
                    targetAnimation.flash = 0.8;
                    break;
                case this.ELEMENT_TYPES.POISON:
                    targetAnimation.flash = 0.3; // Subtle for DoT
                    break;
                case this.ELEMENT_TYPES.DIVINE:
                    targetAnimation.flash = 0.7;
                    break;
                default:
                    targetAnimation.flash = 0.5;
                    break;
            }
        }
    }


    handleEntityDeath(entityId) {
        // Notify other systems about death
        this.game.gameManager.call('startDeathProcess', entityId);
    }

    entityDestroyed(entityId) {
        // Clear pending damage events for this entity
        const eventsToRemove = [];
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {
            if (event.sourceId === entityId || event.targetId === entityId) {
                eventsToRemove.push(eventId);
            }
        }
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
        
        // Clear status effects
        this.activeStatusEffects.delete(entityId);
    }

    update() {
        this.processStatusEffects();
        this.processPendingDamage();
    }

    clearAllStatusEffects(entityId) {
        this.activeStatusEffects.delete(entityId);
    }

    clearAllDamageEffects() {        
        this.activeStatusEffects.clear();  
        this.pendingDamageEvents.clear();
    }

    getStatusEffects(entityId) {
        return this.activeStatusEffects.get(entityId) || { poison: [] };
    }

};

// system: AbilitySystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['AbilitySystem'] = class AbilitySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.abilitySystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        this.abilityActionCounter = 0;
        this.entityAbilities = new Map();
        this.abilityCooldowns = new Map();
        this.abilityQueue = new Map();
        this.abilityActions = new Map();
    }

    init() {
        this.game.gameManager.register('getEntityAbilities', this.getEntityAbilities.bind(this));
        this.game.gameManager.register('removeEntityAbilities', this.removeEntityAbilities.bind(this));
    }

    addAbilitiesToUnit(entityId, abilityIds) {
        if (!Array.isArray(abilityIds)) {
            abilityIds = [abilityIds];
        }
        const unitAbilities = [];
        
        abilityIds.forEach(abilityId => {
            const AbilityClass = this.game.app.appClasses[abilityId];
            if (AbilityClass) {
                const abilityInstance = new AbilityClass(this.game, this.game.getCollections().abilities[abilityId]);
                unitAbilities.push(abilityInstance);
            } else {
                console.warn(`Ability '${abilityId}' not found`);
            }
        });
        
        if (unitAbilities.length > 0) {
            this.entityAbilities.set(entityId, unitAbilities);
        }
    }

    update() {
        if (this.game.state.phase !== 'battle') return;

        this.processAbilityQueue();
        this.processAbilityActions();
        this.updateAIAbilityUsage();
    }
    processAbilityQueue() {        
        for (const [entityId, queuedAbility] of this.abilityQueue.entries()) {
            if (this.game.state.now >= queuedAbility.executeTime) {
                const abilities = this.entityAbilities.get(entityId);
                if (abilities) {
                    const ability = abilities.find(a => a.id === queuedAbility.abilityId);
                    if (ability) {
                        // Execute ability and get potential callback
                        const abilityAction = ability.execute(entityId, queuedAbility.targetData);
                        
                        // If ability returns a callback, schedule it deterministically
                        if (typeof abilityAction === 'function') {
                            // Add to a delayed effects queue
                            this.scheduleAbilityAction(abilityAction, ability.castTime);
                        }
                    }
                }
                this.abilityQueue.delete(entityId);
            }
        }
    }
    scheduleAbilityAction(action, castTime) {        
        const executeTime = this.game.state.now + castTime;
        const effectId = `${this.game.state.now}_${this.abilityActionCounter++}`;
    
        this.abilityActions.set(effectId, {
            callback: action,
            executeTime: executeTime
        });
    }
    processAbilityActions() {
        if (!this.abilityActions) return;
        
        for (const [effectId, abilityAction] of this.abilityActions.entries()) {
            if (this.game.state.now >= abilityAction.executeTime) {
                abilityAction.callback();
                this.abilityActions.delete(effectId);
            }
        }
    }
    updateAIAbilityUsage() {
        const sortedEntityIds = Array.from(this.entityAbilities.keys()).sort((a, b) => 
            String(a).localeCompare(String(b))
        );
        
        sortedEntityIds.forEach(entityId => {
            const abilities = this.entityAbilities.get(entityId);
            this.considerAbilityUsage(entityId, abilities);
        });
    }
    
    considerAbilityUsage(entityId, abilities) {
        if (this.abilityQueue.has(entityId)) {
            return; // Entity is already casting an ability, wait for it to finish
        }
        
        const availableAbilities = abilities
            .filter(ability => this.isAbilityOffCooldown(entityId, ability.id))
            .filter(ability => ability.canExecute(entityId))
            .sort((a, b) => b.priority - a.priority);
        
        // Check if unit is waiting and now has abilities available
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (aiState && aiState.state === 'waiting' && availableAbilities.length > 0) {
            // Transition back to attacking state since we have abilities ready
            if (this.game.combatAISystems) {
                this.game.combatAISystems.changeAIState(aiState, 'attacking');
                
                // Re-enable movement decisions by resetting decision time
                aiState.aiBehavior.lastDecisionTime = 0;
                
            }
        }
        
        if (availableAbilities.length > 0) {
            this.useAbility(entityId, availableAbilities[0].id);
        }
    }
    
    useAbility(entityId, abilityId, targetData = null) {
        const abilities = this.entityAbilities.get(entityId);
        if (!abilities) return false;
        
        const ability = abilities.find(a => a.id === abilityId);
        if (!ability) return false;
        

        
        if (!this.isAbilityOffCooldown(entityId, abilityId)) {
            return false;
        }
        
        if (!ability.canExecute(entityId, targetData)) {
            return false;
        }

        if (!ability.isPassive) {
            this.startAbilityAnimation(entityId, ability);
        }
        this.abilityQueue.set(entityId, {
            abilityId: abilityId,
            targetData: targetData,
            executeTime: this.game.state.now + ability.castTime
        });
        
        this.setCooldown(entityId, abilityId, ability.cooldown);
        ability.logAbilityUsage(entityId);
        
        return true;
    }
    
    startAbilityAnimation(entityId, ability) {
        const animationsToTry = ['attack', 'idle'];

        for (const anim of animationsToTry) {

            // For abilities, use normal speed unless it's an attack-based ability
            let animationSpeed = 1.0;
            let minAnimationTime = 1.5;

            if (ability) {
                animationSpeed = this.game.gameManager.call('calculateAnimationSpeed', entityId, ability.castTime);
                minAnimationTime = 1 / ability.castTime;
            }
            if(this.game.gameManager.has('triggerSinglePlayAnimation')){
                this.game.gameManager.call('triggerSinglePlayAnimation', entityId, anim, animationSpeed, minAnimationTime);
            }
            break;

        }
    }
    
    setCooldown(entityId, abilityId, cooldownDuration) {
        const key = `${entityId}_${abilityId}`;
        this.abilityCooldowns.set(key, this.game.state.now + cooldownDuration);
    }
    
    isAbilityOffCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd || this.game.state.now >= cooldownEnd;
    }
    
    getRemainingCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd ? 0 : Math.max(0, cooldownEnd - this.game.state.now);
    }
    
    getEntityAbilities(entityId) {
        return this.entityAbilities.get(entityId) || [];
    }
    
    getAbilityCooldowns(entityId) {
        const abilities = this.getEntityAbilities(entityId);

        return abilities.map(ability => ({
            id: ability.id,
            name: ability.name,
            remainingCooldown: this.getRemainingCooldown(entityId, ability.id),
            totalCooldown: ability.cooldown
        }));
    }
    
    createAbility(abilityId) {
        const AbilityClass = this.game.app.appClasses[abilityId];
        return AbilityClass ? new AbilityClass() : null;
    }
    
    getAvailableAbilityIds() {
        return Object.keys(this.game.getCollections().abilities);
    }
        
    removeEntityAbilities(entityId) {
        this.entityAbilities.delete(entityId);
        this.abilityQueue.delete(entityId);
        
        // Clean up cooldowns
        const keysToRemove = [];
        for (const key of this.abilityCooldowns.keys()) {
            if (key.startsWith(`${entityId}_`)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => this.abilityCooldowns.delete(key));
        
    }
    onPlacementPhaseStart() {
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onPlacementPhaseStart === 'function') {
                    ability.onPlacementPhaseStart(entityId);
                }
            });
        }            
    }     
    onBattleEnd() {
        
        // Call onBattleEnd on all ability instances
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onBattleEnd === 'function') {
                    ability.onBattleEnd(entityId);
                }
            });
        }
        
        // Clear all ability queues and cooldowns
        this.abilityQueue.clear();
        this.abilityActions.clear();
        this.abilityCooldowns.clear();
        this.abilityActionCounter = 0;
        
    }

    destroy() {
        this.entityAbilities.clear();
        this.abilityCooldowns.clear();
        this.abilityQueue.clear();
        this.abilityActions.clear();
    }
    entityDestroyed(entityId) {
        this.removeEntityAbilities(entityId);
    }
};

// system: ParticleSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ParticleSystem'] = class ParticleSystem extends engine.BaseSystem {
  constructor(game) {
    super(game);
    this.game.particleSystem = this;

    this.CAPACITY = 2000;
    this.initialized = false;
    this.activeCount = 0;
    this.freeList = [];

    this.positions = new Array(this.CAPACITY);
    this.velocities = new Array(this.CAPACITY);
    this.gravityArr = new Float32Array(this.CAPACITY);
    this.dragArr = new Float32Array(this.CAPACITY);

    this.aColorStart = new Float32Array(this.CAPACITY * 3);
    this.aColorEnd   = new Float32Array(this.CAPACITY * 3);
    this.aLifetime   = new Float32Array(this.CAPACITY);
    this.aStartTime  = new Float32Array(this.CAPACITY);
    this.aInitScale  = new Float32Array(this.CAPACITY);
    this.aFlags      = new Float32Array(this.CAPACITY * 2);

    this._tmpMat = new THREE.Matrix4();
    this._cursor = 0;

    this.UPDATE_STRIDE = 2;
  }

  init() {
    // Register methods with GameManager
    this.game.gameManager.register('createParticles', this.createParticles.bind(this));
    this.game.gameManager.register('clearAllParticles', this.clearAllParticles.bind(this));
    this.game.gameManager.register('initializeParticleSystem', this.initialize.bind(this));
  }

  initialize() {
    if (this.initialized || !this.game.scene) return;

    const geometry = new THREE.PlaneGeometry(0.25, 0.25);

    const vertexShader = `
      attribute vec3 aColorStart;
      attribute vec3 aColorEnd;
      attribute float aLifetime;
      attribute float aStartTime;
      attribute float aInitScale;
      attribute vec2 aFlags; // x: fadeOut, y: scaleOverTime
      varying vec3 vColor;
      varying float vAlpha;
      varying vec2 vUv;
      uniform float uTime;

      vec3 camRight() { return vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]); }
      vec3 camUp()    { return vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]); }

      void main() {
        vUv = uv;
        float age = max(uTime - aStartTime, 0.0);
        float lifeT = clamp(1.0 - age / max(aLifetime, 0.0001), 0.0, 1.0);

        vColor = mix(aColorEnd, aColorStart, lifeT);
        vAlpha = aFlags.x > 0.5 ? lifeT : 1.0;

        float s = aInitScale;
        if (aFlags.y > 0.5) {
          if (lifeT > 0.8)       s *= (1.0 - lifeT) * 5.0;
          else if (lifeT > 0.2)  s *= 1.0;
          else                   s *= lifeT * 5.0;
        }

        vec3 right = camRight();
        vec3 up    = camUp();

        vec3 instT = vec3(instanceMatrix[3][0], instanceMatrix[3][1], instanceMatrix[3][2]);
        vec3 worldPos = instT + right * (position.x * s) + up * (position.y * s);

        gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);
      }
    `;

    const fragmentShader = `
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      varying vec2 vUv;

      void main() {
        vec2 c = vUv - vec2(0.5);
        float r = length(c) * 2.0;
        float mask = smoothstep(1.0, 0.6, r);
        float a = vAlpha * mask;

        if (a <= 0.001) discard;

        // CHANGED: simple straight output (no tone mapping), alpha not premultiplied here
        gl_FragColor = vec4(vColor, a); // CHANGED
      }
    `;

    this.material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.NormalBlending,          // CHANGED: sane default; per-effect override allowed
      uniforms: { uTime: { value: 0 } },
      toneMapped: false                        // CHANGED: ensure shader output isn't remapped
    });

    this.mesh = new THREE.InstancedMesh(geometry, this.material, this.CAPACITY);
    this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    const addAttr = (arr, itemSize, name) => {
      const a = new THREE.InstancedBufferAttribute(arr, itemSize);
      this.mesh.geometry.setAttribute(name, a);
      return a;
    };
    this.attrColorStart = addAttr(this.aColorStart, 3, 'aColorStart');
    this.attrColorEnd   = addAttr(this.aColorEnd,   3, 'aColorEnd');
    this.attrLifetime   = addAttr(this.aLifetime,   1, 'aLifetime');
    this.attrStartTime  = addAttr(this.aStartTime,  1, 'aStartTime');
    this.attrInitScale  = addAttr(this.aInitScale,  1, 'aInitScale');
    this.attrFlags      = addAttr(this.aFlags,      2, 'aFlags');

    for (let i = 0; i < this.CAPACITY; i++) {
      this._writeTranslation(i, 1e9, 1e9, 1e9);
      this.positions[i]  = new THREE.Vector3(1e9, 1e9, 1e9);
      this.velocities[i] = new THREE.Vector3(0, 0, 0);
      this.gravityArr[i] = 0.0;
      this.dragArr[i]    = 1.0;
      this.freeList.push(i);
    }

    this.mesh.frustumCulled = false;
    this.game.scene.add(this.mesh);

    this.initialized = true;
  }

  _writeTranslation(index, x, y, z) {
    const m = this._tmpMat;
    m.identity();
    m.setPosition(x, y, z);
    this.mesh.setMatrixAt(index, m);
  }

  /**
   * createParticles(config)
   * Config preserved:
   *   position, count, lifetime,
   *   visual.{color|colorRange{start,end}|scale|fadeOut|scaleOverTime|blending|scaleMultiplier},
   *   velocityRange, gravity, drag, speedMultiplier, heightOffset, shape? (ignored)
   */
  createParticles(config) {
    if (!this.initialized) {
      this.initialize();
      if (!this.initialized) return;
    }

    const {
      position = new THREE.Vector3(0, 0, 0),
      count = 10,
      lifetime = 1.25,
      visual = {},
      velocityRange = { x: [-30, 30], y: [50, 120], z: [-30, 30] },
      gravity = -100.0,
      drag = 0.98,
      speedMultiplier: speedMulTop = 1.0,
      heightOffset = 0
    } = config;

    // ---------- COLOR RESOLUTION (broad compatibility) ----------
    // CHANGED: find start/end colors across multiple common fields
    const { startColorResolved, endColorResolved } = this._resolveColorPair(config, visual); // CHANGED

    // ---------- SCALE / SPEED ----------
    const scaleMul = (visual.scaleMultiplier != null ? visual.scaleMultiplier : 1.0);
    const initScale = ((visual.scale != null) ? visual.scale : 16.0) * scaleMul;

    const speedMulVisual = (visual.speedMultiplier != null ? visual.speedMultiplier : 1.0);
    const speedMul = speedMulTop * speedMulVisual;

    const fadeOut = (visual.fadeOut === undefined) ? true : !!visual.fadeOut;
    const scaleOverTime = (visual.scaleOverTime === undefined) ? true : !!visual.scaleOverTime;

    // Per-effect blending (global switch for the single material)
    if (visual.blending) {
      const b = String(visual.blending).toLowerCase();
      const target =
        b === 'additive' ? THREE.AdditiveBlending :
        b === 'multiply' ? THREE.MultiplyBlending :
                           THREE.NormalBlending;
      if (this.material.blending !== target) {
        this.material.blending = target;
        this.material.needsUpdate = true;
      }
    }

    const rv = (min, max) => min + Math.random() * (max - min);
    const now = this._now();

    let spawned = 0;
    const want = Math.max(1, Math.floor(count));
    while (spawned < want && this.freeList.length > 0) {
      const i = this.freeList.pop();

      const px = position.x;
      const py = position.y + heightOffset;
      const pz = position.z;

      this.positions[i].set(px, py, pz);
      this._writeTranslation(i, px, py, pz);

      const vx = rv(velocityRange.x[0], velocityRange.x[1]) * speedMul;
      const vy = rv(velocityRange.y[0], velocityRange.y[1]) * speedMul;
      const vz = rv(velocityRange.z[0], velocityRange.z[1]) * speedMul;
      this.velocities[i].set(vx, vy, vz);
      this.gravityArr[i] = gravity;
      this.dragArr[i]    = drag;

      // CHANGED: write resolved colors
      const si = i * 3;
      this.aColorStart[si    ] = startColorResolved.r;
      this.aColorStart[si + 1] = startColorResolved.g;
      this.aColorStart[si + 2] = startColorResolved.b;

      this.aColorEnd[si    ] = endColorResolved.r;
      this.aColorEnd[si + 1] = endColorResolved.g;
      this.aColorEnd[si + 2] = endColorResolved.b;

      this.aLifetime[i]  = lifetime;
      this.aStartTime[i] = now;
      this.aInitScale[i] = initScale;
      this.aFlags[i * 2    ] = fadeOut ? 1.0 : 0.0;
      this.aFlags[i * 2 + 1] = scaleOverTime ? 1.0 : 0.0;

      spawned++;
      this.activeCount++;
    }

    this.attrColorStart.needsUpdate = true;
    this.attrColorEnd.needsUpdate   = true;
    this.attrLifetime.needsUpdate   = true;
    this.attrStartTime.needsUpdate  = true;
    this.attrInitScale.needsUpdate  = true;
    this.attrFlags.needsUpdate      = true;
    this.mesh.instanceMatrix.needsUpdate = true;
  }

  clearAllParticles() {
    if (!this.initialized) return;
    for (let i = 0; i < this.CAPACITY; i++) {
      this.aLifetime[i] = 0.0;
      this._writeTranslation(i, 1e9, 1e9, 1e9);
      this.positions[i].set(1e9, 1e9, 1e9);
      this.velocities[i].set(0, 0, 0);
      this.gravityArr[i] = 0.0;
      this.dragArr[i] = 1.0;
      if (!this.freeList.includes(i)) this.freeList.push(i);
    }
    this.activeCount = 0;
    this.attrLifetime.needsUpdate = true;
    this.mesh.instanceMatrix.needsUpdate = true;
  }

  update() {
    if (!this.initialized) return;

    const dt = this.game?.state?.deltaTime || 0.016;
    const now = this._now();
    this.material.uniforms.uTime.value = now;

    if (this.activeCount === 0) return;

    const total = this.CAPACITY;
    let processed = 0;
    const target = Math.max(1, Math.floor(this.activeCount / this.UPDATE_STRIDE));

    for (let loop = 0; loop < total && processed < target; loop++) {
      const i = this._cursor;
      this._cursor = (this._cursor + 1) % total;

      const life = this.aLifetime[i];
      if (life <= 0.0) continue;

      if ((now - this.aStartTime[i]) >= life) {
        this.aLifetime[i] = 0.0;
        this.attrLifetime.needsUpdate = true;

        this._writeTranslation(i, 1e9, 1e9, 1e9);
        this.mesh.instanceMatrix.needsUpdate = true;

        this.positions[i].set(1e9, 1e9, 1e9);
        this.velocities[i].set(0, 0, 0);
        this.gravityArr[i] = 0.0;
        this.dragArr[i] = 1.0;

        this.freeList.push(i);
        this.activeCount--;
        processed++;
        continue;
      }

      const vel = this.velocities[i];
      vel.y += this.gravityArr[i] * dt;
      vel.x *= this.dragArr[i];
      vel.y *= this.dragArr[i];
      vel.z *= this.dragArr[i];

      const pos = this.positions[i];
      pos.x += vel.x * dt;
      pos.y += vel.y * dt;
      pos.z += vel.z * dt;

      this._writeTranslation(i, pos.x, pos.y, pos.z);
      processed++;
    }

    this.mesh.instanceMatrix.needsUpdate = true;
  }

  destroy() {
    if (!this.initialized) return;
    this.game.scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.material.dispose();
    this.initialized = false;
  }

  // ===== helpers =====

  // CHANGED: resolve *pair* of colors from many possible config shapes
  _resolveColorPair(config, visual) {
    // Try pairs first (most explicit)
    const pairCandidates = [
      visual?.colorRange,
      config?.colorRange,
      (visual && (visual.startColor || visual.endColor)) ? { start: visual.startColor, end: visual.endColor } : null,
      (config && (config.startColor || config.endColor)) ? { start: config.startColor, end: config.endColor } : null
    ].filter(Boolean);

    for (const pair of pairCandidates) {
      if (pair?.start != null && pair?.end != null) {
        return {
          startColorResolved: this._resolveColor(pair.start),
          endColorResolved:   this._resolveColor(pair.end)
        };
      }
    }

    // Single color fallbacks (use same for start/end)
    const singleCandidates = [
      visual?.color,
      config?.color
    ].filter((v) => v != null);

    if (singleCandidates.length) {
      const c = this._resolveColor(singleCandidates[0]);
      return { startColorResolved: c, endColorResolved: c };
    }

    // Default white
    const white = { r: 1, g: 1, b: 1 };
    return { startColorResolved: white, endColorResolved: white };
  }

  // Normalize many color forms to {r,g,b} floats (0..1)
  _resolveColor(input) {
    if (input instanceof THREE.Color) {
      return { r: input.r, g: input.g, b: input.b };
    }
    if (typeof input === 'number' || typeof input === 'string') {
      const c = new THREE.Color(input);
      return { r: c.r, g: c.g, b: c.b };
    }
    if (Array.isArray(input) && input.length >= 3) {
      let [r, g, b] = input;
      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }
      return { r, g, b };
    }
    if (input && typeof input === 'object' && 'r' in input && 'g' in input && 'b' in input) {
      let { r, g, b } = input;
      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }
      return { r, g, b };
    }
    return { r: 1, g: 1, b: 1 };
  }

  _now() {
    if (this.game?.state?.simTime != null) return this.game.state.simTime;
    return performance.now() / 1000;
  }
};

// system: SquadExperienceSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SquadExperienceSystem'] = class SquadExperienceSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.squadExperienceSystem = this;
        
        // Squad experience tracking
        this.squadExperience = new Map(); // placementId -> experience data
        this.savedSquadExperience = new Map(); // placementId -> saved experience data
        
        // Experience configuration
        this.config = {
            experiencePerLevel: 15,     // Base experience needed per level
            maxLevel: 10,                // Maximum squad level
            levelUpCostRatio: 0.5,       // Cost to level up = squad value * ratio
            experienceMultiplier: 1.0,   // Global experience gain multiplier
            baselineXPPerSecond: 1,   // tune: ~1â€“3% of a cheap unitâ€™s value per 10s
            baselineXPCombatOnly: true  // only tick during combat phase
        };
        
        // Level bonuses (applied to all units in squad)
        this.levelBonuses = {
            1: { hp: 1.0, damage: 1.0, name: "Rookie" },            
            2: { hp: 1.15, damage: 1.15, name: "Veteran" },
            3: { hp: 1.3, damage: 1.3, name: "Ascended" },
            4: { hp: 1.4, damage: 1.4, name: "Elite" },
            5: { hp: 1.5, damage: 1.5, name: "Champion" },
            6: { hp: 1.6, damage: 1.6, name: "Legendary" },
            7: { hp: 1.7, damage: 1.7, name: "Mythic" },
            8: { hp: 1.8, damage: 1.8, name: "Divine" },
            9: { hp: 1.9, damage: 1.9, name: "Transcendent" },
            10: { hp: 2.0, damage: 2.0, name: "Godlike" }
        };
        
        // UI update throttling
        this.lastUIUpdate = 0;
        this.UI_UPDATE_INTERVAL = 500; // Update UI every 500ms

    }

    init() {
        this.game.gameManager.register('canAffordLevelUp', this.canAffordLevelUp.bind(this));
        this.game.gameManager.register('applySpecialization', this.applySpecialization.bind(this));
        this.game.gameManager.register('levelUpSquad', this.levelUpSquad.bind(this));
        this.game.gameManager.register('getLevelUpCost', this.getLevelUpCost.bind(this));
        this.game.gameManager.register('initializeSquad', this.initializeSquad.bind(this));
        this.game.gameManager.register('removeSquad', this.removeSquad.bind(this));
        this.game.gameManager.register('getSquadsReadyToLevelUp', this.getSquadsReadyToLevelUp.bind(this));
        this.game.gameManager.register('showSpecializationSelection', this.showSpecializationSelection.bind(this));
        this.game.gameManager.register('findSquadByUnitId', this.findSquadByUnitId.bind(this));
        this.game.gameManager.register('getCurrentUnitType', this.getCurrentUnitType.bind(this));
        this.game.gameManager.register('getSquadInfo', this.getSquadInfo.bind(this));
        this.game.gameManager.register('resetSquadExperience', this.reset.bind(this));
    }

    /**
     * Initialize experience tracking for a new squad
     * @param {string} placementId - Unique placement identifier
     * @param {Object} unitType - Unit type definition (not squadData)
     * @param {Array} unitIds - Array of entity IDs in the squad
     * @param {string} team - Team identifier
     */
    initializeSquad(placementId, unitType, unitIds, team) {
        // Check if we already have experience data for this placement ID
        const existingData = this.squadExperience.get(placementId);
        if (existingData) {
       
            // Update unit IDs and size for respawned squad
            existingData.unitIds = [...unitIds];
            existingData.squadSize = unitIds.length;
            
            // Apply level bonuses to new units
            this.applyLevelBonuses(placementId);
            return existingData;
        }
        
        // Create new squad data
        const squadValue = this.calculateSquadValue(unitType);
        
        const experienceData = {
            placementId: placementId,
            level: 1,
            experience: 0,
            experienceToNextLevel: this.calculateExperienceNeeded(0),
            squadValue: squadValue,
            unitIds: [...unitIds],
            team: team,
            squadSize: unitIds.length,
            canLevelUp: false,
            totalUnitsInSquad: unitIds.length, // Just use actual unit count
            lastExperienceGain: 0,
            creationTime: this.game.state.now
        };
        
        this.squadExperience.set(placementId, experienceData);
        
        // Try to restore saved experience for player squads
  
        this.restoreSquadExperience(placementId, experienceData);
        
        // Apply initial bonuses if any
        this.applyLevelBonuses(placementId);
         return experienceData;
    }
    /**
     * Add experience to a squad
     * @param {string} placementId - Squad placement ID
     * @param {number} experience - Experience to add
     */
    addExperience(placementId, experience) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return;
        
        // Don't gain experience if already at max level or ready to level up
        if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) {
            return;
        }
        
        squadData.experience += experience;
        squadData.lastExperienceGain = this.game.state.now;
        
        // Check if squad can level up
        if (squadData.experience >= squadData.experienceToNextLevel) {
            squadData.canLevelUp = true;
            // Stop gaining experience until manually leveled up
            squadData.experience = squadData.experienceToNextLevel;
                
        }
        
        // Update UI periodically
        if (this.game.state.now - this.lastUIUpdate > this.UI_UPDATE_INTERVAL) {
            this.updateSquadUI();
            this.lastUIUpdate = this.game.state.now;
        }
    }
    getLevelUpCost(placementId){
        
        const squadData = this.squadExperience.get(placementId);
        if(squadData){
            const levelUpCost = this.getLevelUpCostBySquadValue(squadData.squadValue)

            return levelUpCost;
        } else {
            return -1;
        }
    }
    getLevelUpCostBySquadValue(squadValue){
        return Math.floor(squadValue * this.config.levelUpCostRatio);
    }
    canAffordLevelUp(placementId, playerGold){
                
        const levelUpCost = this.getLevelUpCost(placementId);

         if (levelUpCost < 0 || playerGold < levelUpCost) {    
            return false;
         }
         return true;
    }
    /**
     * Level up a squad (only during placement phase)
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Optional specialization unit ID (for level 3+)
     * @returns {boolean} Success status
     */
    async levelUpSquad(placementId, specializationId = null, playerId = null, callback) {
        if (this.game.state.phase !== 'placement') {
            console.log("incorrect phase to level up");
            callback(false);
        }
        
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || !squadData.canLevelUp) {
            console.log("squad cant level up", placementId, squadData, this.squadExperience);
            callback(false);
        };        
                        
        // Check for specialization selection UI (unchanged)
        const isSpecializationLevel = squadData.level >= 2;
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        const hasSpecializations = currentUnitType && currentUnitType.specUnits && currentUnitType.specUnits.length > 0;
        if (!this.game.isServer && isSpecializationLevel && hasSpecializations && !specializationId) {
            this.showSpecializationSelection(placementId, squadData, callback);
            console.log('showing spec selection');
            return;
        }
        
        
        try {
            if (!this.game.isServer) {
                // Handle specialization case
                if (specializationId && isSpecializationLevel && hasSpecializations) {
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId, specializationId }, 'SQUAD_LEVELED');
       
                    if (!success) {
                        console.log('no success making network call apply_spec or level_squad');
                        callback(false);
                    } 
                    this.applySpecialization(placementId, specializationId, playerId);
                } else {
                    // Handle regular level up
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId }, 'SQUAD_LEVELED');
                    
                    if (!success) {
                        console.log('no success making network call level_squad');
                        callback(false);
                    }
                }
            } 
                
            // Deduct cost optimistically
            callback(this.finishLevelingSquad(squadData, placementId, specializationId));
            
        } catch (error) {
            // Refund gold on any error
            console.log('failed to level squad', error);
            callback(false);
        }
    }

    // Helper method to promisify network calls
    makeNetworkCall(action, data, expectedResponse) {
        return new Promise((resolve, reject) => {
            this.game.clientNetworkManager.call(action, data, expectedResponse, (responseData, error) => {
                if(responseData && responseData.success) {
                    resolve(responseData);
                } else {
                    reject(error);
                }
            });
        });
    }

    finishLevelingSquad(squadData, placementId, specializationId) {
        console.log('finishLevelingSquad');
        // Level up
        squadData.level++;
        squadData.experience = 0;
        squadData.experienceToNextLevel = this.calculateExperienceNeeded(squadData.level);
        squadData.canLevelUp = false;
        
        // Apply level bonuses to all units in squad
        this.applyLevelBonuses(placementId);
        
        const levelUpCost = this.getLevelUpCost(placementId);  
        this.game.state.playerGold -= levelUpCost;
            
        console.log('leveling squad for cost', placementId, levelUpCost);
        // Visual effects
        squadData.unitIds.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            if (pos) {
                const effectType = specializationId ? 'magic' : 'heal';
                this.game.gameManager.call('createParticleEffect',
                    pos.x, pos.y + 20, pos.z,
                    effectType,
                    { count: 3, speedMultiplier: specializationId ? 1.5 : 1.2 }
                );
            }
        });
        return true;
    }
    
    /**
     * Apply specialization transformation to a squad
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Specialization unit type ID
     * @returns {boolean} Success status
     */
    applySpecialization(placementId, specializationId, playerId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return false;
        
        // Get the specialization unit type
        const collections = this.game.getCollections();
        if (!collections || !collections.units || !collections.units[specializationId]) {
            console.error(`Specialization unit type ${specializationId} not found`);
            return false;
        }
        
        const specializationUnitType = collections.units[specializationId];
        
        // Find the placement in PlacementSystem to update the unit type
        const placement = this.game.gameManager.call('getPlacementById', placementId);
        if (!placement) {
            console.error(`Placement ${placementId} not found`);
            return false;
        }
        
        // Update the placement's unit type
        const oldUnitType = placement.unitType;
        placement.unitType = { id: specializationId, ...specializationUnitType };
        
        // Recreate all units in the squad with the new unit type
        const componentTypes = this.game.componentManager.getComponentTypes();
        const newUnitIds = [];
        
        console.log('applying specialization to ', squadData, squadData.unitIds);
        console.log('placement', placement);
        // Store positions of old units
        const positions = [];
        squadData.unitIds.forEach(entityId => {
            const pos = this.game.getComponent(entityId, componentTypes.POSITION);
            if (pos) {
                positions.push({ x: pos.x, y: pos.y, z: pos.z });
            }
            // Destroy old unit
            if (this.game.destroyEntity) {
                this.game.destroyEntity(entityId);
            }
        });
        
        // Create new specialized units at the same positions
        positions.forEach(pos => {
            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
            const unitY = terrainHeight !== null ? terrainHeight : pos.y;
            
            const entityId = this.game.unitCreationManager.create(
                pos.x, unitY, pos.z, 
                placement.targetPosition,
                placement, 
                squadData.team
            );
            console.log('created new unit', placement.unitType, entityId);
            newUnitIds.push(entityId);
        });
        
        // Update squad data with new unit IDs
        squadData.unitIds = newUnitIds;
        
        // Update squad value based on new unit type
        squadData.squadValue = this.calculateSquadValue(placement.unitType);

        return true;
    }
    
    /**
     * Show specialization selection UI
     * @param {string} placementId - Squad placement ID
     * @param {Object} squadData - Squad experience data
     */
    showSpecializationSelection(placementId, squadData, callback) {
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        if (!currentUnitType || !currentUnitType.specUnits) return;
        
        const collections = this.game.getCollections();
        if (!collections || !collections.units) return;
        
        // Create specialization selection modal
        const modal = document.createElement('div');
        modal.className = 'specialization-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 10000;
            display: flex; justify-content: center; align-items: center;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #ffaa00; border-radius: 10px;
            padding: 20px; max-width: 600px; width: 90%;
            color: #fff; text-align: center;
        `;
        
        const squadName = this.getSquadDisplayName(placementId);
        content.innerHTML = `
            <h3 style="color: #ffaa00; margin-bottom: 15px;">â­ SPECIALIZATION AVAILABLE! â­</h3>
            <p style="margin-bottom: 20px;">Choose a specialization for your ${squadName}:</p>
            <div id="specialization-options" style="margin-bottom: 20px;"></div>
            <button id="cancel-specialization" style="
                background: #666; color: #fff; border: none; padding: 8px 16px;
                border-radius: 4px; cursor: pointer; margin-right: 10px;
            ">Cancel</button>
        `;
        
        modal.appendChild(content);
        
        // Add specialization options
        const optionsContainer = content.querySelector('#specialization-options');
        currentUnitType.specUnits.forEach(specId => {
            const specUnit = collections.units[specId];
            if (specUnit) {
                const optionButton = document.createElement('button');
                optionButton.style.cssText = `
                    display: block; width: 100%; margin: 8px 0; padding: 12px;
                    background: linear-gradient(135deg, #006600, #008800);
                    color: white; border: 1px solid #00aa00; border-radius: 4px;
                    cursor: pointer; transition: all 0.2s ease;
                `;
                
                const squadValue = this.calculateSquadValue(specUnit);
                const levelUpCost = this.getLevelUpCostBySquadValue(squadValue);
                optionButton.innerHTML = `
                    <strong>${specUnit.title || specId}</strong><br>
                    <small style="opacity: 0.8;">${specUnit.hp || 100} HP, ${specUnit.damage || 10} DMG - Cost: ${levelUpCost}g</small>
                `;
                
                optionButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    this.levelUpSquad(placementId, specId, null, callback);
                });
                
                optionButton.addEventListener('mouseenter', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #008800, #00aa00)';
                    optionButton.style.transform = 'translateY(-2px)';
                });
                
                optionButton.addEventListener('mouseleave', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #006600, #008800)';
                    optionButton.style.transform = 'translateY(0)';
                });
                
                optionsContainer.appendChild(optionButton);
            }
        });
        
        // Cancel button
        content.querySelector('#cancel-specialization').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Close on escape
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
    }
    
    /**
     * Get the current unit type for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Unit type or null if not found
     */
    getCurrentUnitType(placementId, side) {
        const placements = this.game.gameManager.call('getPlacementsForSide', side);
        if(placements){
            const placement = placements.find(p => p.placementId === placementId);
            return placement ? placement.unitType : null;
        }
        return null;
    }
    
    /**
     * Apply level bonuses to all units in a squad
     * @param {string} placementId - Squad placement ID
     */
    applyLevelBonuses(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || squadData.level <= 1) {
            return;
        }
        
        const bonuses = this.levelBonuses[squadData.level];
        if (!bonuses) {
            return;
        }
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        squadData.unitIds.forEach(entityId => {
            const unitType = this.game.getComponent(entityId, componentTypes.UNIT_TYPE);
            if (unitType) {
                const baseUnitData = this.game.getCollections().units[unitType.id];
            
                // Apply health bonus
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                if (health && bonuses.hp > 1) {
                    const newMaxHealth = Math.floor(baseUnitData.hp * bonuses.hp);
                    const healthIncrease = newMaxHealth - health.max;
                    health.max = newMaxHealth;
                    health.current += healthIncrease; // Also increase current health
                }
                
                // Apply damage bonus
                const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
                if (combat && bonuses.damage > 1) {
                    combat.damage = Math.floor(baseUnitData.damage * bonuses.damage);
                }
                
                // Visual indicator (flash effect)
                const animation = this.game.getComponent(entityId, componentTypes.ANIMATION);
                if (animation) {
                    animation.flash = 0.8;
                }
            }
        });
    }
    
    /**
     * Calculate total health of all units in a squad
     * @param {string} placementId - Squad placement ID
     * @returns {number} Total health
     */
    calculateSquadTotalHealth(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return 100; // Default fallback
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        let totalHealth = 0;
        
        squadData.unitIds.forEach(entityId => {
            const health = this.game.getComponent(entityId, componentTypes.HEALTH);
            if (health) {
                totalHealth += health.max;
            }
        });
        
        return Math.max(1, totalHealth); // Avoid division by zero
    }
    
    /**
     * Calculate squad value based on unit type
     * @param {Object} unitType - Unit type definition
     * @returns {number} Squad value (just the unit's base cost)
     */
    calculateSquadValue(unitType) {
        return unitType.value || 0;
    }
    
    /**
     * Calculate experience needed for next level
     * @param {number} currentLevel - Current level
     * @returns {number} Experience needed
     */
    calculateExperienceNeeded(currentLevel) {
        // Exponential scaling: level 1 = 100, level 2 = 150, level 3 = 225, etc.
        return Math.floor(this.config.experiencePerLevel * Math.pow(1.5, currentLevel));
    }
    
    /**
     * Find squad data by unit entity ID
     * @param {number} entityId - Unit entity ID
     * @returns {Object|null} Squad experience data
     */
    findSquadByUnitId(entityId) {
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.unitIds.includes(entityId)) {
                return squadData;
            }
        }
        return null;
    }
    
    /**
     * Get display name for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {string} Display name
     */
    getSquadDisplayName(placementId) {
        // Try to get the name from placement system
        const playerPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide);
        if (playerPlacements) {
            const placement = playerPlacements.find(p => p.placementId === placementId);
            if (placement && placement.unitType) {
                return placement.unitType.title || placement.unitType.id || 'Squad';
            }
        }

        const enemyPlacements = this.game.gameManager.call('getPlacementsForSide', this.game.state.mySide === 'left' ? 'right' : 'left');
        if (enemyPlacements) {
            const enemyPlacement = enemyPlacements.find(p => p.placementId === placementId);
            if (enemyPlacement && enemyPlacement.unitType) {
                return enemyPlacement.unitType.title || enemyPlacement.unitType.id || 'Enemy Squad';
            }
        }

        return `Squad ${placementId.slice(-4)}`;
    }
    
    /**
     * Get level bonus name
     * @param {number} level - Squad level
     * @returns {string} Bonus name
     */
    getLevelBonusName(level) {
        return this.levelBonuses[level]?.name || '';
    }
    
    /**
     * Update squad experience UI
     */
    updateSquadUI() {
        // This method could update a dedicated squad experience panel
        // For now, we'll just ensure the shop system can access this data
        this.game.gameManager.call('updateSquadExperience');
    }
    
    /**
     * Get all player squads that can level up
     * @returns {Array} Array of squad data that can level up
     */
    getSquadsReadyToLevelUp() {
        const readySquads = [];
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.canLevelUp && squadData.team == this.game.state.mySide) {
                readySquads.push({
                    ...squadData,
                    displayName: this.getSquadDisplayName(placementId),
                    levelUpCost: Math.floor(squadData.squadValue * this.config.levelUpCostRatio),
                    nextLevelName: this.getLevelBonusName(squadData.level + 1)
                });
            }
        }
        
        return readySquads;
    }
    
    /**
     * Get squad experience info for display
     * @param {string} placementId - Squad placement ID
     * @returns {Object} Experience info
     */
    getSquadInfo(placementId) {
        return this.squadExperience.get(placementId);        
    }

    setSquadInfo(placementId, placementExperience){
        if(placementExperience){
            this.squadExperience.set(placementId, placementExperience);
            console.log('applying opponent level bonuses', placementId);
            this.applyLevelBonuses(placementId);
        }
    }

    getExperienceFromPlacements(placements){
        let experience = {};
        placements.forEach((placement) => {
            experience[placement.placementId] = this.getSquadInfo(placement.placementId)
        });
        return experience;
    }
    
    /**
     * Clean up squad data when units are destroyed
     * MODIFIED: Only remove on explicit request, not automatic cleanup
     * @param {string} placementId - Squad placement ID
     */
    removeSquad(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (squadData) {
           this.squadExperience.delete(placementId);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {

        this.tickBaselineXP();
    }
    tickBaselineXP() {
        // Optional: restrict to combat only
        if (this.config.baselineXPCombatOnly && this.game?.state?.phase !== 'battle') return;

        for (const [placementId, squadData] of this.squadExperience.entries()) {
            // Respect caps: no gain if at max or waiting for manual level-up
            if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) continue;

            const unitsAliveInSquad = this.unitsAliveInSquad(squadData);
            if (unitsAliveInSquad > 0) {
                const squadLivingRatio = unitsAliveInSquad / squadData.totalUnitsInSquad;                
                const xp = squadLivingRatio * this.config.baselineXPPerSecond * this.game.state.deltaTime * this.config.experienceMultiplier;
                if (xp > 0) this.addExperience(placementId, xp);
            }
        }
    }
    unitsAliveInSquad(squadData) {
        if (!squadData || !squadData.unitIds?.length) return 0;
        const componentTypes = this.game.componentManager.getComponentTypes();
        let count = 0;
        for (const id of squadData.unitIds) {
            const h = this.game.getComponent(id, componentTypes.HEALTH);
            if (h && h.current > 0) count++;
        }
        return count;
    }
    /**
     * Clean up experience data for squads with dead/missing units
     * MODIFIED: Never remove experience data, just update unit lists
     */
    onPlacementPhaseStart() {
        
        this.saveSquadExperience();
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            const validUnits = squadData.unitIds.filter(entityId => {
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                return health && health.current > 0;
            });
            
            if (validUnits.length < squadData.unitIds.length) {             
                squadData.unitIds = validUnits;
                squadData.squadSize = validUnits.length;
            }
        }
    }
    
    /**
     * Reset all experience data (for new game)
     */
    reset() {
        this.squadExperience.clear();
        this.savedSquadExperience.clear();
    }

    /**
     * Save player squad experience before round cleanup
     */
    saveSquadExperience() {
        this.savedSquadExperience = new Map();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {

            // Save the experience data
            this.savedSquadExperience.set(placementId, {
                level: squadData.level,
                experience: squadData.experience,
                experienceToNextLevel: squadData.experienceToNextLevel,
                canLevelUp: squadData.canLevelUp,
                squadValue: squadData.squadValue,
                totalUnitsInSquad: squadData.totalUnitsInSquad
            });
            
        }
    }

    /**
     * Restore saved player experience to a respawned squad
     */
    restoreSquadExperience(placementId, squadData) {
        const saved = this.savedSquadExperience.get(placementId);
        if (saved) {
            squadData.level = saved.level;
            squadData.experience = saved.experience;
            squadData.experienceToNextLevel = saved.experienceToNextLevel;
            squadData.canLevelUp = saved.canLevelUp;
            
          
            // Apply level bonuses if squad has levels
            if (squadData.level > 0) {
                this.applyLevelBonuses(placementId);
            }
            
            return true;
        }
        return false;
    }
    /**
     * Get debug information
     * @returns {Object} Debug info
     */
    getDebugInfo() {
        const squads = Array.from(this.squadExperience.values());
        return {
            totalSquads: squads.length,
            leftSquads: squads.filter(s => s.team === 'left').length,
            rightSquads: squads.filter(s => s.team === 'right').length,
            squadsReadyToLevelUp: squads.filter(s => s.canLevelUp).length,
            averageLevel: squads.length > 0 ? squads.reduce((sum, s) => sum + s.level, 0) / squads.length : 0,
            maxLevel: Math.max(0, ...squads.map(s => s.level))
        };
    }
};

// system: LifetimeSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['LifetimeSystem'] = class LifetimeSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.lifetimeSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Configuration
        this.CHECK_INTERVAL = 0.1; // Check lifetimes every 100ms for performance
        this.lastCheck = 0;
        
        // Track entities with custom destruction callbacks
        this.destructionCallbacks = new Map(); // entityId -> callback function
        
        // Track entities that should fade out before destruction
        this.fadeOutEntities = new Map(); // entityId -> fade data
        
        // Statistics
        this.stats = {
            entitiesDestroyed: 0,
            entitiesExpired: 0,
            entitiesFaded: 0
        };
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('addLifetime', this.addLifetime.bind(this));
        this.game.gameManager.register('destroyEntityImmediately', this.destroyEntityImmediately.bind(this));
        this.game.gameManager.register('extendLifetime', this.extendLifetime.bind(this));
    }

    update() {        
        // Only check periodically for performance
        if (this.game.state.now - this.lastCheck < this.CHECK_INTERVAL) return;
        this.lastCheck = this.game.state.now;
        
        // Get all entities with lifetime components
        const lifetimeEntities = this.game.getEntitiesWith(this.componentTypes.LIFETIME);
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (!lifetime) return;
            
            const age = (this.game.state.now - lifetime.startTime);
            
            // Check if entity has expired
            if (age >= lifetime.duration) {
                this.handleExpiredEntity(entityId, lifetime);
            } 
        });
    }
    
    // =============================================
    // ENTITY EXPIRATION HANDLING
    // =============================================
    
    handleExpiredEntity(entityId, lifetime) {
        // Call custom destruction callback if registered
        const callback = this.destructionCallbacks.get(entityId);
        if (callback) {
            try {
                callback(entityId, lifetime);
            } catch (error) {
                console.warn(`Lifetime destruction callback error for entity ${entityId}:`, error);
            }
            this.destructionCallbacks.delete(entityId);
        }
        
        // Special handling for different entity types
        this.handleSpecialEntityTypes(entityId, lifetime);
        
        // Create destruction effects if specified
        this.createDestructionEffects(entityId, lifetime);
        
        // Log destruction if enabled
        this.logEntityDestruction(entityId, lifetime);
        
        // Remove from fade tracking
        this.fadeOutEntities.delete(entityId);
        
        // Destroy the entity
        this.game.destroyEntity(entityId);
        
        // Update statistics
        this.stats.entitiesDestroyed++;
        this.stats.entitiesExpired++;
    }
    
    handleSpecialEntityTypes(entityId, lifetime) {
        // Handle projectiles
        if (this.game.hasComponent(entityId, this.componentTypes.PROJECTILE)) {
            // Clean up projectile-specific data 
            this.game.gameManager.call('deleteProjectileTrail', entityId);
            
        }
        
        // Handle summons
        if (this.game.hasComponent(entityId, this.componentTypes.SUMMONED)) {
            this.handleSummonExpiration(entityId);
        }
        
        // Handle mirror images
        if (this.game.hasComponent(entityId, this.componentTypes.MIRROR_IMAGE)) {
            this.handleMirrorImageExpiration(entityId);
        }
        
        // Handle traps
        if (this.game.hasComponent(entityId, this.componentTypes.TRAP)) {
            this.handleTrapExpiration(entityId);
        }
        
        // Handle temporary effects
        if (this.game.hasComponent(entityId, this.componentTypes.TEMPORARY_EFFECT)) {
            this.handleTemporaryEffectExpiration(entityId);
        }
        
        // Handle mind controlled entities
        if (this.game.hasComponent(entityId, this.componentTypes.MIND_CONTROLLED)) {
            this.handleMindControlExpiration(entityId);
        }
        
        // Handle thorns effect
        if (this.game.thornsEntities && this.game.thornsEntities.has(entityId)) {
            this.game.thornsEntities.delete(entityId);
        }
    }
    
    handleSummonExpiration(entityId) {
        const summonPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (summonPos) {
            // Create disappearing effect
            this.game.gameManager.call('createParticleEffect',
                summonPos.x, summonPos.y, summonPos.z,
                'magic',
                { count: 3, color: 0x9370DB, scaleMultiplier: 1.5 }
            );
        }

    }
    
    handleMirrorImageExpiration(entityId) {
        const imagePos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (imagePos) {
            // Create shimmering dissolution effect
            this.game.gameManager.call('createParticleEffect',
                imagePos.x, imagePos.y, imagePos.z,
                'magic',
                { count: 3, color: 0x6495ED, scaleMultiplier: 1.2 }
            );
        }
    }
    
    handleTrapExpiration(entityId) {
        const trapPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (trapPos) {
            // Create fizzling effect for expired trap
            this.game.gameManager.call('createParticleEffect',
                trapPos.x, trapPos.y, trapPos.z,
                'magic',
                { count: 3, color: 0x696969, scaleMultiplier: 0.8 }
            );
        }


    }
    
    handleTemporaryEffectExpiration(entityId) {
        // For visual effect entities, just let them fade naturally
        const effectPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (effectPos) {
            this.game.gameManager.call('createParticleEffect',
                effectPos.x, effectPos.y, effectPos.z,
                'magic',
                { count: 3, color: 0xFFFFFF, scaleMultiplier: 0.5 }
            );
        }
    }
    
    handleMindControlExpiration(entityId) {
        const mindControl = this.game.getComponent(entityId, this.componentTypes.MIND_CONTROLLED);
        const targetTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        
        if (mindControl && targetTeam) {
            // Restore original team
            targetTeam.team = mindControl.originalTeam;
            
            // Clear AI target
            const targetAI = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            if (targetAI && targetAI.aiBehavior) {
                targetAI.target = null;
                targetAI.targetPosition = null;
                targetAI.path = [];
                targetAI.meta = {};
            }
            
            // Visual effect
            if (targetPos) {
                this.game.gameManager.call('createParticleEffect',
                    targetPos.x, targetPos.y, targetPos.z,
                    'magic',
                    { count: 3, color: 0xDA70D6, scaleMultiplier: 1.0 }
                );
            }
            
            // Remove mind control component
            this.game.removeComponent(entityId, this.componentTypes.MIND_CONTROLLED);
            
          
        }
    }

    
    // =============================================
    // DESTRUCTION EFFECTS
    // =============================================
    
    createDestructionEffects(entityId, lifetime) {
        if (!lifetime.destructionEffect) return;

        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (!pos) return;

        const effectConfig = lifetime.destructionEffect;

        // Create particle effect
        this.game.gameManager.call('createParticleEffect',
            pos.x, pos.y, pos.z,
            effectConfig.type || 'magic',
            {
                count: effectConfig.count || 3,
                color: effectConfig.color || 0xFFFFFF,
                scaleMultiplier: effectConfig.scaleMultiplier || 1.0,
                speedMultiplier: effectConfig.speedMultiplier || 1.0
            }
        );

        // Screen effects if specified
        if (effectConfig.screenShake) {
            this.game.gameManager.call('playScreenShake',
                effectConfig.screenShake.duration || 0.2,
                effectConfig.screenShake.intensity || 1
            );
        }

        if (effectConfig.screenFlash) {
            this.game.gameManager.call('playScreenFlash',
                effectConfig.screenFlash.color || '#FFFFFF',
                effectConfig.screenFlash.duration || 0.2
            );
        }
    }
    
    // =============================================
    // PUBLIC API METHODS
    // =============================================
    
    /**
     * Add a lifetime component to an entity
     * @param {number} entityId - Entity to add lifetime to
     * @param {number} duration - Duration in seconds
     * @param {Object} options - Additional options
     */
    addLifetime(entityId, duration, options = {}) {
        
        const lifetimeData = {
            duration: duration,
            startTime: this.game.state.now,
            fadeOutDuration: options.fadeOutDuration || 0,
            destructionEffect: options.destructionEffect || null,
            onDestroy: options.onDestroy || null
        };
        
        this.game.addComponent(entityId, this.componentTypes.LIFETIME, lifetimeData);
        
        // Register destruction callback if provided
        if (options.onDestroy && typeof options.onDestroy === 'function') {
            this.destructionCallbacks.set(entityId, options.onDestroy);
        }
        
        return entityId;
    }
    
    /**
     * Extend the lifetime of an entity
     * @param {number} entityId - Entity to extend
     * @param {number} additionalDuration - Additional time in seconds
     */
    extendLifetime(entityId, additionalDuration) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration += additionalDuration;
            return true;
        }
        return false;
    }
    
    /**
     * Reduce the lifetime of an entity
     * @param {number} entityId - Entity to reduce
     * @param {number} reductionAmount - Time to reduce in seconds
     */
    reduceLifetime(entityId, reductionAmount) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration = Math.max(0, lifetime.duration - reductionAmount);
            return true;
        }
        return false;
    }
    
    /**
     * Get remaining lifetime of an entity
     * @param {number} entityId - Entity to check
     * @returns {number} Remaining time in seconds, or -1 if no lifetime component
     */
    getRemainingLifetime(entityId) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            const age = (this.game.state.now - lifetime.startTime);
            return Math.max(0, (lifetime.duration) - age);
        }
        return -1;
    }
    
    /**
     * Check if an entity will expire soon
     * @param {number} entityId - Entity to check
     * @param {number} threshold - Time threshold in seconds
     * @returns {boolean} True if entity will expire within threshold
     */
    willExpireSoon(entityId, threshold = 5.0) {
        const remaining = this.getRemainingLifetime(entityId);
        return remaining >= 0 && remaining <= threshold;
    }
    
    /**
     * Remove lifetime component from an entity (makes it permanent)
     * @param {number} entityId - Entity to make permanent
     */
    makeEntityPermanent(entityId) {
        if (this.game.hasComponent(entityId, this.componentTypes.LIFETIME)) {
            this.game.removeComponent(entityId, this.componentTypes.LIFETIME);
            this.destructionCallbacks.delete(entityId);
            this.fadeOutEntities.delete(entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Force immediate destruction of an entity with lifetime
     * @param {number} entityId - Entity to destroy
     * @param {boolean} triggerEffects - Whether to trigger destruction effects
     */
    destroyEntityImmediately(entityId, triggerEffects = true) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            if (triggerEffects) {
                this.handleExpiredEntity(entityId, lifetime);
            } else {
                this.destructionCallbacks.delete(entityId);
                this.fadeOutEntities.delete(entityId);
                this.game.destroyEntity(entityId);
                this.stats.entitiesDestroyed++;
            }
            return true;
        }
        return false;
    }
    
    /**
     * Register a custom destruction callback for an entity
     * @param {number} entityId - Entity to register callback for
     * @param {Function} callback - Function to call on destruction
     */
    registerDestructionCallback(entityId, callback) {
        if (typeof callback === 'function') {
            this.destructionCallbacks.set(entityId, callback);
        }
    }
    
    /**
     * Get all entities with lifetime components
     * @returns {Array} Array of entity IDs
     */
    getAllLifetimeEntities() {
        return this.game.getEntitiesWith(this.componentTypes.LIFETIME);
    }
    
    /**
     * Get entities that will expire within a time threshold
     * @param {number} threshold - Time threshold in seconds
     * @returns {Array} Array of entity IDs
     */
    getExpiringEntities(threshold = 5.0) {
        const expiringEntities = [];
        
        const lifetimeEntities = this.getAllLifetimeEntities();
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (lifetime) {
                const age = (this.game.state.now - lifetime.startTime);
                const remaining = lifetime.duration - age;
                
                if (remaining <= threshold && remaining > 0) {
                    expiringEntities.push(entityId);
                }
            }
        });
        
        return expiringEntities;
    }
    
    // =============================================
    // LOGGING AND STATISTICS
    // =============================================
    
    logEntityDestruction(entityId, lifetime) {
       
    }
    
    getStatistics() {
        return { ...this.stats };
    }
    
    resetStatistics() {
        this.stats.entitiesDestroyed = 0;
        this.stats.entitiesExpired = 0;
        this.stats.entitiesFaded = 0;
    }
    
    // =============================================
    // SYSTEM MANAGEMENT
    // =============================================
    
    destroy() {
        // Clean up all tracking maps
        this.destructionCallbacks.clear();
        this.fadeOutEntities.clear();
        this.resetStatistics();
    }
};

// system: SchedulingSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SchedulingSystem'] = class SchedulingSystem extends engine.BaseSystem {
   constructor(game) {
        super(game);
        this.game.schedulingSystem = this;
        
        // Scheduled actions storage
        this.scheduledActions = new Map();
        this.actionIdCounter = 0;
        
        // Entity tracking for cleanup
        this.entityActions = new Map(); // entityId -> Set of actionIds
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('scheduleAction', this.scheduleAction.bind(this));
        this.game.gameManager.register('cancelScheduledAction', this.cancelAction.bind(this));
    }

    update() {
        this.processScheduledActions();
    }
    
    /**
     * Schedule an action to execute after a delay
     * @param {Function} callback - Function to execute
     * @param {number} delaySeconds - Delay in seconds (game time)
     * @param {string|null} entityId - Optional entity ID for tracking/cleanup
     * @returns {string} actionId - Unique identifier for this action
     */
    scheduleAction(callback, delaySeconds, entityId = null) {
        const executeTime = this.game.state.now + delaySeconds;
        const actionId = `action_${this.actionIdCounter++}_${executeTime.toFixed(6)}`;
        
        this.scheduledActions.set(actionId, {
            callback: callback,
            executeTime: executeTime,
            entityId: entityId
        });
        
        // Track entity associations for cleanup
        if (entityId) {
            if (!this.entityActions.has(entityId)) {
                this.entityActions.set(entityId, new Set());
            }
            this.entityActions.get(entityId).add(actionId);
        }
        
        return actionId;
    }
    
    /**
     * Process all scheduled actions that are ready to execute
     */
    processScheduledActions() {
        const actionsToExecute = [];
        
        // Find all actions ready to execute
        for (const [actionId, action] of this.scheduledActions.entries()) {
            if (this.game.state.now >= action.executeTime) {
                actionsToExecute.push({ id: actionId, action: action });
            }
        }
        
        // Sort actions for deterministic execution order
        actionsToExecute.sort((a, b) => {
            // Primary sort: by execution time
            if (Math.abs(a.action.executeTime - b.action.executeTime) > 0.000001) {
                return a.action.executeTime - b.action.executeTime;
            }
            // Secondary sort: by action ID for deterministic tie-breaking
            return a.id.localeCompare(b.id);
        });
        
        // Execute actions in deterministic order
        actionsToExecute.forEach(({ id, action }) => {
            try {
                action.callback();
            } catch (error) {
                console.error(`Error executing scheduled action ${id}:`, error);
            }
            
            // Clean up
            this.removeAction(id, action.entityId);
        });
    }
    
    /**
     * Cancel a scheduled action
     * @param {string} actionId - Action to cancel
     * @returns {boolean} - True if action was found and cancelled
     */
    cancelAction(actionId) {
        const action = this.scheduledActions.get(actionId);
        if (action) {
            this.removeAction(actionId, action.entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Cancel all actions associated with an entity
     * @param {string} entityId - Entity whose actions should be cancelled
     * @returns {number} - Number of actions cancelled
     */
    entityDestroyed(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        if (!entityActionIds) return 0;
        
        let cancelledCount = 0;
        for (const actionId of entityActionIds) {
            if (this.scheduledActions.has(actionId)) {
                this.scheduledActions.delete(actionId);
                cancelledCount++;
            }
        }
        
        this.entityActions.delete(entityId);
        return cancelledCount;
    }
    
    /**
     * Internal method to remove action and clean up tracking
     * @param {string} actionId 
     * @param {string|null} entityId 
     */
    removeAction(actionId, entityId) {
        this.scheduledActions.delete(actionId);
        
        if (entityId && this.entityActions.has(entityId)) {
            this.entityActions.get(entityId).delete(actionId);
            
            // Clean up empty entity tracking
            if (this.entityActions.get(entityId).size === 0) {
                this.entityActions.delete(entityId);
            }
        }
    }
    
    /**
     * Get info about scheduled actions (for debugging)
     * @returns {Object} - Statistics about scheduled actions
     */
    getSchedulingStats() {
        return {
            totalActions: this.scheduledActions.size,
            entitiesWithActions: this.entityActions.size,
            nextActionTime: this.getNextActionTime()
        };
    }
    
    /**
     * Get the time of the next scheduled action
     * @returns {number|null} - Time of next action, or null if none scheduled
     */
    getNextActionTime() {
        let nextTime = null;
        for (const action of this.scheduledActions.values()) {
            if (nextTime === null || action.executeTime < nextTime) {
                nextTime = action.executeTime;
            }
        }
        return nextTime;
    }
    
    /**
     * Check if an entity has scheduled actions
     * @param {string} entityId 
     * @returns {boolean}
     */
    hasEntityActions(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        return entityActionIds && entityActionIds.size > 0;
    }
    
    /**
     * Clear all scheduled actions (useful for game reset)
     */
    clearAllActions() {
        this.scheduledActions.clear();
        this.entityActions.clear();
    }
    
    /**
     * Convenience method: Schedule a delayed function call
     * @param {Object} obj - Object to call method on
     * @param {string} methodName - Method name to call
     * @param {Array} args - Arguments to pass
     * @param {number} delaySeconds - Delay in seconds
     * @param {string|null} entityId - Optional entity ID
     * @returns {string} actionId
     */
    scheduleMethodCall(obj, methodName, args = [], delaySeconds, entityId = null) {
        return this.scheduleAction(() => {
            if (obj && typeof obj[methodName] === 'function') {
                obj[methodName](...args);
            }
        }, delaySeconds, entityId);
    }
}
;

// system: GoldMineSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['GoldMineSystem'] = class GoldMineSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.goldMineSystem = this;
        this.goldVeinLocations = [];
        this.claimedGoldMines = new Map();
        
        console.log('[GoldMineSystem] Initialized', this.game.isServer ? '(SERVER)' : '(CLIENT)');
    }

    init(params) {
        this.params = params || {};

        this.game.gameManager.register('buildGoldMine', this.buildGoldMine.bind(this));
        this.game.gameManager.register('isValidGoldMinePlacement', this.isValidGoldMinePlacement.bind(this));
        this.game.gameManager.register('getGoldVeinLocations', () => this.goldVeinLocations);

        this.findGoldVeinLocations();
        console.log('[GoldMineSystem] Init complete. Found', this.goldVeinLocations.length, 'gold veins');
    }

    findGoldVeinLocations() {
        const tileMap = this.game.terrainSystem?.tileMap;
        if (!tileMap?.environmentObjects) {
            console.warn('[GoldMineSystem] No environment objects found');
            return;
        }

        const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        const extendedSize = this.game.terrainSystem?.extendedSize || 0;

        this.goldVeinLocations = tileMap.environmentObjects
            .filter(obj => obj.type === 'goldVein')
            .map(obj => {
                const worldX = (obj.x + extensionSize) - extendedSize / 2;
                const worldZ = (obj.y + extensionSize) - extendedSize / 2;

                const gridPos = this.game.gameManager.call('convertWorldToGridPosition', worldX, worldZ);

                // Gold veins use placementGridWidth which is already in placement grid units
                // But we need to match how buildings calculate their cells (footprintWidth * 2)
                // Since gold veins have placementGridWidth=2, and buildings have footprintWidth=2,
                // we need to convert: footprintWidth * 2 = 2 * 2 = 4 placement grid cells
                const veinPlacementGridWidth = obj.placementGridWidth || 2;
                const veinPlacementGridHeight = obj.placementGridHeight || 2;
                // Convert to match building footprint calculation
                const gridWidth = veinPlacementGridWidth * 2;
                const gridHeight = veinPlacementGridHeight * 2;

                const cells = this.calculateGoldVeinCells(gridPos, gridWidth, gridHeight);

                return {
                    x: obj.x,
                    y: obj.y,
                    worldX: worldX,
                    worldZ: worldZ,
                    gridPos: gridPos,
                    gridWidth: gridWidth,  // 4 (placement grid cells)
                    gridHeight: gridHeight,  // 4 (placement grid cells)
                    cells: cells,
                    claimed: false,
                    claimedBy: null,
                    instanceIndex: null,
                    originalIndex: tileMap.environmentObjects.indexOf(obj)
                };
            });

        console.log('[GoldMineSystem] Found gold veins:', this.goldVeinLocations);

        if (!this.game.isServer) {
            this.mapGoldVeinInstances();
        }
    }

    calculateGoldVeinCells(gridPos, gridWidth, gridHeight) {
        const cells = [];
        const startX = gridPos.x - Math.round(gridWidth / 2);
        const startZ = gridPos.z - Math.round(gridHeight / 2);

        for (let z = 0; z < gridHeight; z++) {
            for (let x = 0; x < gridWidth; x++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight) {
        const buildingCells = this.calculateGoldVeinCells(gridPos, buildingGridWidth, buildingGridHeight);

        for (const vein of this.goldVeinLocations) {
            if (vein.claimed) continue;

            if (this.cellsMatch(buildingCells, vein.cells)) {
                return { valid: true, vein: vein };
            }
        }

        return { valid: false };
    }

    cellsMatch(cells1, cells2) {
        if (cells1.length !== cells2.length) return false;

        const cellSet = new Set(cells2.map(c => `${c.x},${c.z}`));
        
        for (const cell of cells1) {
            if (!cellSet.has(`${cell.x},${cell.z}`)) {
                return false;
            }
        }

        return true;
    }

    mapGoldVeinInstances() {
        if (!this.game.gameManager.call('getWorldScene')) {
            console.warn('[GoldMineSystem] No scene available for mapping instances');
            return;
        }

        const goldVeinInstancedMeshes = [];
        this.game.gameManager.call('getWorldScene').traverse(child => {
            if (child instanceof THREE.InstancedMesh && child.userData.objectType === 'goldVein') {
                goldVeinInstancedMeshes.push(child);
            }
        });

        let globalIndex = 0;
        for (const vein of this.goldVeinLocations) {
            vein.instanceIndex = globalIndex;
            vein.instancedMeshes = goldVeinInstancedMeshes;
            globalIndex++;
        }
    }

    buildGoldMine(entityId, team, gridPos, buildingGridWidth, buildingGridHeight) {

        const validation = this.isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight);
        if (!validation.valid) {
            console.warn('[GoldMineSystem] Invalid placement - no matching unclaimed vein');
            return { success: false, error: 'Must be placed on a gold vein' };
        }

        const vein = validation.vein;

        vein.claimed = true;
        vein.claimedBy = team;

        let mineModel = null;
        if (!this.game.isServer) {
            mineModel = this.replaceVeinWithMine(vein);
        }

        this.claimedGoldMines.set(entityId, {
            entityId: entityId,
            position: { x: vein.x, z: vein.y },
            worldPosition: { x: vein.worldX, z: vein.worldZ },
            gridPos: vein.gridPos,
            cells: vein.cells,
            veinIndex: vein.originalIndex,
            veinData: vein,
            team: team,
            model: mineModel
        });

        return { success: true };
    }

    destroyGoldMine(entityId) {
        const goldMine = this.claimedGoldMines.get(entityId);
        if (!goldMine) {
            return { success: false, error: 'No gold mine to destroy' };
        }

        // Clear any miners targeting this mine
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && miningState.targetMineEntityId === entityId) {
                miningState.targetMineEntityId = null;
                miningState.targetMinePosition = null;
                miningState.waitingPosition = null;
                miningState.state = 'idle';
            }
        }

        if (!this.game.isServer) {
            console.log('[GoldMineSystem] CLIENT: Restoring vein');
            this.restoreVein(goldMine.veinData);
        } else {
            console.log('[GoldMineSystem] SERVER: Releasing mine claim');
            goldMine.veinData.claimed = false;
            goldMine.veinData.claimedBy = null;
        }
        
        this.claimedGoldMines.delete(entityId);

        console.log('[GoldMineSystem] Gold mine destroyed. Remaining mines:', this.claimedGoldMines.size);
        return { success: true };
    }

    // Check if a mine is currently occupied by looking at component states
    isMineOccupied(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return true;
            }
        }
        
        return false;
    }

    // Get the current miner at a mine by checking component states
    getCurrentMiner(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return minerEntityId;
            }
        }
        
        return null;
    }

    // Get all miners in queue (waiting_at_mine state) for a specific mine
    getMinersInQueue(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        const queuedMiners = [];
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'waiting_at_mine') {
                queuedMiners.push(minerEntityId);
            }
        }
        
        return queuedMiners;
    }

    // Get queue position for a specific miner
    getQueuePosition(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.indexOf(minerEntityId);
    }

    // Check if a miner is next in queue
    isNextInQueue(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.length > 0 && queue[0] === minerEntityId;
    }

    // Process next miner in queue when mine becomes available
    processNextInQueue(mineEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        
        if (queue.length === 0) {
            return;
        }
        
        const nextMinerId = queue[0];
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miningState = this.game.getComponent(nextMinerId, ComponentTypes.MINING_STATE);
        
        if (miningState && miningState.state === 'waiting_at_mine') {
            const aiState = this.game.getComponent(nextMinerId, ComponentTypes.AI_STATE);
            const pos = this.game.getComponent(nextMinerId, ComponentTypes.POSITION);
            const vel = this.game.getComponent(nextMinerId, ComponentTypes.VELOCITY);
            
            if (pos && vel && miningState.targetMinePosition) {
                miningState.waitingPosition = null;
                
                pos.x = miningState.targetMinePosition.x;
                pos.z = miningState.targetMinePosition.z;
                vel.vx = 0;
                vel.vz = 0;
                
                miningState.state = 'mining';
                miningState.miningStartTime = this.game.state.now;
                
                if (aiState) {
                    aiState.state = 'idle';
                    aiState.targetPosition = null;
                }
            }
        }
    }

    replaceVeinWithMine(vein) {
        return;
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         const position = new THREE.Vector3(0, -10000, 0);
        //         matrix.makeTranslation(position.x, position.y, position.z);
        //         matrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });
        // } 
    }

    restoreVein(vein) {
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        //     const extendedSize = this.game.terrainSystem?.extendedSize || 0;
        //     const heightMapSettings = this.game.worldSystem?.heightMapSettings;
            
        //     let height = 0;
        //     if (heightMapSettings?.enabled) {
        //         height = heightMapSettings.heightStep * this.game.terrainSystem.tileMap.extensionTerrainType;
        //     }

        //     const worldX = (vein.x + extensionSize) - extendedSize / 2;
        //     const worldZ = (vein.y + extensionSize) - extendedSize / 2;

        //     const dummy = new THREE.Object3D();
        //     dummy.position.set(worldX, height, worldZ);
        //     dummy.rotation.y = Math.random() * Math.PI * 2;
        //     dummy.scale.set(50, 50, 50);
        //     dummy.updateMatrix();

        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         matrix.copy(dummy.matrix);
        //         if (mesh.userData.relativeMatrix) {
        //             matrix.multiply(mesh.userData.relativeMatrix);
        //         }
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });            
        // }

        vein.claimed = false;
        vein.claimedBy = null;
    }

    
    onBattleEnd() {
        const entities = this.game.getEntitiesWith(this.game.componentTypes.MINING_STATE);        
        entities.forEach(entityId => {
            const miningState = this.game.getComponent(entityId, this.game.componentTypes.MINING_STATE);
            if (miningState) {
                miningState.miningStartTime = 0;
                miningState.depositStartTime = 0;
            }
        });
    }

    onDestroyBuilding(entityId){
        const unitType = this.game.getComponent(entityId, this.game.componentTypes.UNIT_TYPE);
        if (unitType.id === 'goldMine') {
            this.game.goldMineSystem.destroyGoldMine(entityId);
        } 
    }

    reset() {
        
        if (!this.game.isServer) {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                this.restoreVein(goldMine.veinData, goldMine.model);
            }
        } else {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                goldMine.veinData.claimed = false;
                goldMine.veinData.claimedBy = null;
            }
        }
        
        this.claimedGoldMines.clear();
        
    }
};

// system: PathfindingSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PathfindingSystem'] = class PathfindingSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.pathfindingSystem = this;

        this.navMesh = null;
        this.navGridSize = null; // Will be set from config
        this.navGridWidth = 0;
        this.navGridHeight = 0;
        
        this.terrainTypes = null;
        this.walkabilityCache = new Map();
        this.ramps = new Set(); // Stores ramp locations in "x,z" format (terrain grid coords)

        this.pathCache = new Map();
        this.MAX_CACHE_SIZE = 1000;
        this.CACHE_EXPIRY_TIME = 5000;

        this.pathRequests = [];
        this.MAX_PATHS_PER_FRAME = 100;

        // Path smoothing configuration
        // Lower values = less aggressive smoothing = less corner cutting
        // Higher values = more aggressive smoothing = smoother but riskier paths
        this.MAX_SMOOTH_LOOKAHEAD = 3; // Maximum waypoints to look ahead when smoothing
        
        this.initialized = false;
    }

    init() {
        if (this.initialized) return;

        this.game.gameManager.register('isPositionWalkable', this.isPositionWalkable.bind(this));
        this.game.gameManager.register('isGridPositionWalkable', this.isGridPositionWalkable.bind(this));
        this.game.gameManager.register('requestPath', this.requestPath.bind(this));  
        this.game.gameManager.register('hasRampAt', this.hasRampAt.bind(this));  
        this.game.gameManager.register('hasDirectWalkablePath', this.hasDirectWalkablePath.bind(this)); // ADD THIS


        const collections = this.game.getCollections();
        if (!collections) {
            console.warn('PathfindingSystem: Collections not available');
            return;
        }
        
        const level = collections.levels?.[this.game.state.level];
        if (!level || !level.tileMap) {
            console.warn('PathfindingSystem: Level or tileMap not available');
            return;
        }
        
        if (!this.game.terrainSystem || !this.game.terrainSystem.initialized) {
            console.warn('PathfindingSystem: Waiting for terrain system...');
            return;
        }
        
        this.terrainTypes = level.tileMap.terrainTypes;
        if (!this.terrainTypes) {
            console.warn('PathfindingSystem: No terrain types found in level');
            return;
        }

        // Set navigation grid size to half of terrain grid (matches placement grid)
        this.navGridSize = collections.configs.game.gridSize / 2;
        console.log('PathfindingSystem: Using nav grid size', this.navGridSize);

        // Load ramps data
        this.loadRamps(level.tileMap);

        this.buildWalkabilityCache();
        this.bakeNavMesh();
        this.initialized = true;
        console.log('PathfindingSystem: Initialized with', this.terrainTypes.length, 'terrain types');
    }

    loadRamps(tileMap) {
        this.ramps.clear();

        const ramps = tileMap.ramps || [];
        for (const ramp of ramps) {
            const key = `${ramp.x},${ramp.z}`;
            this.ramps.add(key);
        }

        console.log(`PathfindingSystem: Loaded ${ramps.length} ramps`);
    }

    buildWalkabilityCache() {
        // This cache is now deprecated in favor of height-based walkability
        // Kept for backwards compatibility with old level data
        this.walkabilityCache.clear();

        for (let i = 0; i < this.terrainTypes.length; i++) {
            const terrainType = this.terrainTypes[i];
            const walkableNeighbors = terrainType.walkableNeighbors || [];

            for (let j = 0; j < this.terrainTypes.length; j++) {
                const targetType = this.terrainTypes[j].type;
                const canWalk = walkableNeighbors.includes(targetType);

                const key = `${i}-${j}`;
                this.walkabilityCache.set(key, canWalk);
            }
        }
    }

    canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex) {
        // NEW: Use height-based walkability if heightMap is available
        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {
            // Always walkable between same terrain types
            return true;
        }

        // OLD: Fall back to walkableNeighbors cache for backwards compatibility
        const key = `${fromTerrainIndex}-${toTerrainIndex}`;
        return this.walkabilityCache.get(key) === true;
    }

    // Convert nav grid coordinates to terrain grid coordinates
    navGridToTerrainGrid(navGridX, navGridZ) {
        const worldPos = this.navGridToWorld(navGridX, navGridZ);
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const terrainSize = this.game.gameManager.call('getTerrainSize');

        const terrainX = Math.floor((worldPos.x + terrainSize / 2) / gridSize);
        const terrainZ = Math.floor((worldPos.z + terrainSize / 2) / gridSize);

        return { x: terrainX, z: terrainZ };
    }

    // Check if there's a ramp at the given nav grid position
    hasRampAtNav(navGridX, navGridZ) {
        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);
        const key = `${terrainGrid.x},${terrainGrid.z}`;
        return this.ramps.has(key);
    }
    
    hasRampAt(gridX, gridZ) {
        return this.ramps.has(`${gridX},${gridZ}`);
    }

    // Get height level at nav grid position
    getHeightLevelAtNavGrid(navGridX, navGridZ) {
        const terrainGrid = this.navGridToTerrainGrid(navGridX, navGridZ);
        return this.game.terrainSystem?.getHeightLevelAtGridPosition(terrainGrid.x, terrainGrid.z) || 0;
    }

    // Check if movement between terrains is allowed (either through height + ramps or walkableNeighbors)
    canWalkBetweenTerrainsWithRamps(fromTerrainIndex, toTerrainIndex, fromNavGridX, fromNavGridZ, toNavGridX, toNavGridZ) {
        // NEW: Use height-based walkability if heightMap is available
        if (this.game.terrainSystem?.tileMap?.heightMap && this.game.terrainSystem.tileMap.heightMap.length > 0) {
            const fromHeight = this.getHeightLevelAtNavGrid(fromNavGridX, fromNavGridZ);
            const toHeight = this.getHeightLevelAtNavGrid(toNavGridX, toNavGridZ);

            // Same height level = always walkable
            if (fromHeight === toHeight) {
                return true;
            }

            // Different heights = only walkable with a ramp
            // Ramps allow movement between any adjacent height levels
            if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {
                return true;
            }

            return false;
        }

        // OLD: Use walkableNeighbors logic for backwards compatibility
        // First check normal walkability
        if (this.canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex)) {
            return true;
        }

        // If not normally walkable, check if there's a ramp at either position
        // Ramps allow movement between any terrain heights
        if (this.hasRampAtNav(fromNavGridX, fromNavGridZ) || this.hasRampAtNav(toNavGridX, toNavGridZ)) {
            return true;
        }

        return false;
    }

    bakeNavMesh() {
        const terrainSize = this.game.gameManager.call('getTerrainSize');
        
        this.navGridWidth = Math.ceil(terrainSize / this.navGridSize);
        this.navGridHeight = Math.ceil(terrainSize / this.navGridSize);
        
        this.navMesh = new Uint8Array(this.navGridWidth * this.navGridHeight);
        
        const halfTerrain = terrainSize / 2;
        
        // First pass: populate the navmesh with terrain types
        for (let z = 0; z < this.navGridHeight; z++) {
            for (let x = 0; x < this.navGridWidth; x++) {
                const worldX = (x * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                const worldZ = (z * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                
                const terrainType = this.game.gameManager.call('getTerrainTypeAtPosition', worldX, worldZ);
                
                const idx = z * this.navGridWidth + x;
                this.navMesh[idx] = terrainType !== null ? terrainType : 0;
            }
        }
        
        // Second pass: mark cells adjacent to impassable terrain as impassable
        // Create a copy to read from while we modify
        const originalNavMesh = new Uint8Array(this.navMesh);
        
        // for (let z = 0; z < this.navGridHeight; z++) {
        //     for (let x = 0; x < this.navGridWidth; x++) {
        //         const idx = z * this.navGridWidth + x;
        //         const currentTerrain = originalNavMesh[idx];
                
        //         // Check if this cell is walkable
        //         if (this.isTerrainWalkable(currentTerrain)) {
        //             // Check all 8 neighbors
        //             const neighbors = [
        //                 {dx: 1, dz: 0}, {dx: -1, dz: 0}, 
        //                 {dx: 0, dz: 1}, {dx: 0, dz: -1},
        //                 {dx: 1, dz: 1}, {dx: -1, dz: 1}, 
        //                 {dx: 1, dz: -1}, {dx: -1, dz: -1}
        //             ];
                    
        //             for (const {dx, dz} of neighbors) {
        //                 const nx = x + dx;
        //                 const nz = z + dz;
                        
        //                 if (nx >= 0 && nx < this.navGridWidth && nz >= 0 && nz < this.navGridHeight) {
        //                     const neighborIdx = nz * this.navGridWidth + nx;
        //                     const neighborTerrain = originalNavMesh[neighborIdx];
                            
        //                     // If neighbor is impassable or we can't walk to it
        //                     if (!this.isTerrainWalkable(neighborTerrain) || 
        //                         !this.canWalkBetweenTerrains(currentTerrain, neighborTerrain)) {
        //                         // Mark this cell as impassable (use 255 as a special marker)
        //                         this.navMesh[idx] = 255;
        //                         break;
        //                     }
        //                 }
        //             }
        //         }
        //     }
        // }
        
        console.log(`PathfindingSystem: Baked nav mesh ${this.navGridWidth}x${this.navGridHeight} with buffer zones`);
    }
    
    isTerrainWalkable(terrainIndex) {
        if (terrainIndex === null || terrainIndex === 255) return false;
        
        // A terrain is walkable if it has at least one walkable neighbor defined
        const terrainType = this.terrainTypes[terrainIndex];
        if (!terrainType) return false;
        
        const walkableNeighbors = terrainType.walkableNeighbors || [];
        return walkableNeighbors.length > 0;
    }

    worldToNavGrid(worldX, worldZ) {
        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;
        const gridX = Math.floor((worldX + halfTerrain) / this.navGridSize);
        const gridZ = Math.floor((worldZ + halfTerrain) / this.navGridSize);
        return { x: gridX, z: gridZ };
    }

    navGridToWorld(gridX, gridZ) {
        const halfTerrain = this.game.gameManager.call('getTerrainSize') / 2;
        const worldX = (gridX * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        const worldZ = (gridZ * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        return { x: worldX, z: worldZ };
    }

    getTerrainAtNavGrid(gridX, gridZ) {
        if (gridX < 0 || gridX >= this.navGridWidth || gridZ < 0 || gridZ >= this.navGridHeight) {
            return null;
        }
        return this.navMesh[gridZ * this.navGridWidth + gridX];
    }

    requestPath(entityId, startX, startZ, endX, endZ, priority = 0) {
        const cacheKey = `${Math.floor(startX/50)},${Math.floor(startZ/50)}-${Math.floor(endX/50)},${Math.floor(endZ/50)}`;
        
        const cached = this.pathCache.get(cacheKey);
        if (cached && (this.game.state.now - cached.timestamp) < this.CACHE_EXPIRY_TIME) {
            return cached.path;
        }
        
        this.pathRequests.push({
            entityId,
            startX,
            startZ,
            endX,
            endZ,
            priority,
            cacheKey,
            timestamp: this.game.state.now
        });
        
        return null;
    }

    findPath(startX, startZ, endX, endZ, cacheKey = null) {
        const startGrid = this.worldToNavGrid(startX, startZ);
        const endGrid = this.worldToNavGrid(endX, endZ);
        
        if (startGrid.x === endGrid.x && startGrid.z === endGrid.z) {
            return [{ x: endX, z: endZ }];
        }
        
        const openSet = new GUTS.MinHeap();
        const closedSet = new Set();
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();
        
        const startKey = `${startGrid.x},${startGrid.z}`;
        const endKey = `${endGrid.x},${endGrid.z}`;
        
        gScore.set(startKey, 0);
        fScore.set(startKey, this.heuristic(startGrid, endGrid));
        openSet.push({ key: startKey, x: startGrid.x, z: startGrid.z, f: fScore.get(startKey) });
        
        const directions = [
            {dx: 1, dz: 0}, {dx: -1, dz: 0}, {dx: 0, dz: 1}, {dx: 0, dz: -1},
            {dx: 1, dz: 1}, {dx: -1, dz: 1}, {dx: 1, dz: -1}, {dx: -1, dz: -1}
        ];
        
        let iterations = 0;
        const maxIterations = this.navGridWidth * this.navGridHeight;
        
        // Track the closest point we've found to the destination
        let closestNode = { key: startKey, x: startGrid.x, z: startGrid.z };
        let closestDistance = this.heuristic(startGrid, endGrid);
        
        while (!openSet.isEmpty() && iterations < maxIterations) {
            iterations++;
            
            const current = openSet.pop();
            const currentKey = current.key;
            
            if (currentKey === endKey) {
                const path = this.reconstructPath(cameFrom, currentKey, endX, endZ);
                
                if (cacheKey) {
                    this.addToCache(cacheKey, path);
                }
                
                return path;
            }
            
            closedSet.add(currentKey);
            
            // Check if this is closer to the destination than previous closest
            const distToEnd = this.heuristic({ x: current.x, z: current.z }, endGrid);
            if (distToEnd < closestDistance) {
                closestDistance = distToEnd;
                closestNode = current;
            }
            
            const currentTerrain = this.getTerrainAtNavGrid(current.x, current.z);
            
            for (const dir of directions) {
                const neighborX = current.x + dir.dx;
                const neighborZ = current.z + dir.dz;
                const neighborKey = `${neighborX},${neighborZ}`;
                
                if (closedSet.has(neighborKey)) continue;
                
                const neighborTerrain = this.getTerrainAtNavGrid(neighborX, neighborZ);
                if (neighborTerrain === null || neighborTerrain === 255) continue;

                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, neighborTerrain, current.x, current.z, neighborX, neighborZ)) {
                    continue;
                }
                
                const isDiagonal = dir.dx !== 0 && dir.dz !== 0;
                
                // For diagonal moves, check both adjacent cells to prevent corner cutting
                if (isDiagonal) {
                    const terrainX = this.getTerrainAtNavGrid(current.x + dir.dx, current.z);
                    const terrainZ = this.getTerrainAtNavGrid(current.x, current.z + dir.dz);

                    // Both adjacent cells must exist and be walkable
                    if (terrainX === null || terrainX === 255 ||
                        terrainZ === null || terrainZ === 255) {
                        continue;
                    }

                    if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, current.x, current.z, current.x + dir.dx, current.z) ||
                        !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, current.x, current.z, current.x, current.z + dir.dz)) {
                        continue;
                    }
                }
                
                const moveCost = isDiagonal ? 1.414 : 1;
                const tentativeGScore = gScore.get(currentKey) + moveCost;
                
                if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeGScore);
                    
                    const h = this.heuristic({x: neighborX, z: neighborZ}, endGrid);
                    const f = tentativeGScore + h;
                    fScore.set(neighborKey, f);
                    
                    openSet.push({ key: neighborKey, x: neighborX, z: neighborZ, f });
                }
            }
        }
        
        // No path found to exact destination - return path to closest reachable point
        if (closestNode.key !== startKey) {
            const closestWorld = this.navGridToWorld(closestNode.x, closestNode.z);
            const path = this.reconstructPath(cameFrom, closestNode.key, closestWorld.x, closestWorld.z);
            
            if (cacheKey) {
                this.addToCache(cacheKey, path);
            }
            
            console.log(`PathfindingSystem: No path to destination, returning path to closest point (distance: ${closestDistance.toFixed(1)})`);
            return path;
        }
        
        return null;
    }

    reconstructPath(cameFrom, currentKey, endX, endZ) {
        const path = [];
        const gridPath = [];
        
        let current = currentKey;
        while (current) {
            const [x, z] = current.split(',').map(Number);
            gridPath.unshift({ x, z });
            current = cameFrom.get(current);
        }
        
        for (const gridPoint of gridPath) {
            const worldPos = this.navGridToWorld(gridPoint.x, gridPoint.z);
            path.push(worldPos);
        }
        
        if (path.length > 0) {
            path[path.length - 1] = { x: endX, z: endZ };
        }
        
        return this.smoothPath(path);
    }

    smoothPath(path) {
        if (path.length <= 2) return path;

        const smoothed = [path[0]];
        let currentIdx = 0;

        while (currentIdx < path.length - 1) {
            let farthestVisible = currentIdx + 1;

            // Limit how far ahead we look to prevent aggressive corner cutting
            const maxLookahead = Math.min(
                path.length - 1,
                currentIdx + this.MAX_SMOOTH_LOOKAHEAD
            );

            // Check from far to near within the limited lookahead range
            // This still prioritizes smoother paths but prevents excessive shortcuts
            for (let i = maxLookahead; i > currentIdx + 1; i--) {
                if (this.hasLineOfSight(path[currentIdx], path[i])) {
                    farthestVisible = i;
                    break;
                }
            }

            smoothed.push(path[farthestVisible]);
            currentIdx = farthestVisible;
        }

        return smoothed;
    }
    hasDirectWalkablePath(fromPos, toPos, entityId = null) {
        if (!this.initialized || !this.navMesh) return false;
        
        const fromGrid = this.worldToNavGrid(fromPos.x, fromPos.z);
        const toGrid = this.worldToNavGrid(toPos.x, toPos.z);
        
        // Same grid cell = direct path
        if (fromGrid.x === toGrid.x && fromGrid.z === toGrid.z) {
            return true;
        }
        
        // Bresenham's line algorithm to check every grid cell along the path
        const dx = Math.abs(toGrid.x - fromGrid.x);
        const dz = Math.abs(toGrid.z - fromGrid.z);
        const sx = fromGrid.x < toGrid.x ? 1 : -1;
        const sz = fromGrid.z < toGrid.z ? 1 : -1;
        let err = dx - dz;
        
        let x = fromGrid.x;
        let z = fromGrid.z;
        let lastX = x;
        let lastZ = z;
        let lastTerrain = this.getTerrainAtNavGrid(x, z);

        // If starting position isn't walkable, fail immediately
        if (!this.isTerrainWalkable(lastTerrain)) {
            return false;
        }

        while (true) {
            // Reached destination
            if (x === toGrid.x && z === toGrid.z) {
                return true;
            }

            const currentTerrain = this.getTerrainAtNavGrid(x, z);

            // Hit impassable terrain or out of bounds
            if (currentTerrain === null || currentTerrain === 255) {
                return false;
            }

            // Check if current terrain is walkable
            if (!this.isTerrainWalkable(currentTerrain)) {
                return false;
            }

            // Check if we can transition from last terrain to current terrain
            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {
                return false;
            }
            
            const e2 = 2 * err;
            const willMoveX = e2 > -dz;
            const willMoveZ = e2 < dx;
            
            // For diagonal movement, check both adjacent cells to prevent corner cutting
            if (willMoveX && willMoveZ) {
                const terrainX = this.getTerrainAtNavGrid(x + sx, z);
                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);

                // Both adjacent cells must be valid and walkable
                if (terrainX === null || terrainX === 255 ||
                    terrainZ === null || terrainZ === 255) {
                    return false;
                }

                if (!this.isTerrainWalkable(terrainX) || !this.isTerrainWalkable(terrainZ)) {
                    return false;
                }

                // Check terrain transitions for both adjacent cells
                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||
                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {
                    return false;
                }
            }

            lastTerrain = currentTerrain;
            lastX = x;
            lastZ = z;

            // Move along the line
            if (willMoveX) {
                err -= dz;
                x += sx;
            }
            if (willMoveZ) {
                err += dx;
                z += sz;
            }
        }
    }
    hasLineOfSight(from, to) {
        const fromGrid = this.worldToNavGrid(from.x, from.z);
        const toGrid = this.worldToNavGrid(to.x, to.z);
        
        const dx = Math.abs(toGrid.x - fromGrid.x);
        const dz = Math.abs(toGrid.z - fromGrid.z);
        const sx = fromGrid.x < toGrid.x ? 1 : -1;
        const sz = fromGrid.z < toGrid.z ? 1 : -1;
        let err = dx - dz;
        
        let x = fromGrid.x;
        let z = fromGrid.z;
        let lastX = x;
        let lastZ = z;
        let lastTerrain = this.getTerrainAtNavGrid(x, z);

        while (true) {
            if (x === toGrid.x && z === toGrid.z) return true;

            const currentTerrain = this.getTerrainAtNavGrid(x, z);
            if (currentTerrain === null || currentTerrain === 255) return false;

            if (!this.canWalkBetweenTerrainsWithRamps(lastTerrain, currentTerrain, lastX, lastZ, x, z)) {
                return false;
            }
            
            const e2 = 2 * err;
            const willMoveX = e2 > -dz;
            const willMoveZ = e2 < dx;
            
            // Check for diagonal movement (corner cutting)
            if (willMoveX && willMoveZ) {
                // We're moving diagonally - check both adjacent cells to prevent corner cutting
                const terrainX = this.getTerrainAtNavGrid(x + sx, z);
                const terrainZ = this.getTerrainAtNavGrid(x, z + sz);
                
                // Both adjacent cells must be valid and walkable from current position
                if (terrainX === null || terrainX === 255 ||
                    terrainZ === null || terrainZ === 255) {
                    return false;
                }

                if (!this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainX, x, z, x + sx, z) ||
                    !this.canWalkBetweenTerrainsWithRamps(currentTerrain, terrainZ, x, z, x, z + sz)) {
                    return false;
                }
            }

            lastTerrain = currentTerrain;
            lastX = x;
            lastZ = z;

            if (willMoveX) {
                err -= dz;
                x += sx;
            }
            if (willMoveZ) {
                err += dx;
                z += sz;
            }
        }
    }

    heuristic(a, b) {
        const dx = Math.abs(a.x - b.x);
        const dz = Math.abs(a.z - b.z);
        return Math.sqrt(dx * dx + dz * dz);
    }

    addToCache(key, path) {
        if (this.pathCache.size >= this.MAX_CACHE_SIZE) {
            const oldestKey = null;
            let oldestTime = Infinity;
            
            for (const [k, v] of this.pathCache.entries()) {
                if (v.timestamp < oldestTime) {
                    oldestTime = v.timestamp;
                    oldestKey = k;
                }
            }
            
            if (oldestKey) {
                this.pathCache.delete(oldestKey);
            }
        }
        
        this.pathCache.set(key, {
            path: path,
            timestamp: this.game.state.now
        });
    }

    clearPathCache() {
        this.pathCache.clear();
    }

    update() {
        if (!this.initialized) {
            this.init();
            return;
        }
        
        const now = this.game.state.now;
        const keysToDelete = [];
        
        for (const [key, data] of this.pathCache.entries()) {
            if (now - data.timestamp > this.CACHE_EXPIRY_TIME) {
                keysToDelete.push(key);
            }
        }
        
        keysToDelete.sort();
        for (const key of keysToDelete) {
            this.pathCache.delete(key);
        }
        
        if (this.pathRequests.length === 0) return;
        
        this.pathRequests.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return String(a.entityId).localeCompare(String(b.entityId));
        });
        
        const pathsToProcess = Math.min(this.MAX_PATHS_PER_FRAME, this.pathRequests.length);
        
        for (let i = 0; i < pathsToProcess; i++) {
            const request = this.pathRequests.shift();
            
            const path = this.findPath(
                request.startX,
                request.startZ,
                request.endX,
                request.endZ,
                request.cacheKey
            );
            
            if (path && this.game.componentManager) {
                const componentTypes = this.game.componentManager.getComponentTypes();
                const aiState = this.game.getComponent(request.entityId, componentTypes.AI_STATE);
                
                if (aiState) {
                    aiState.path = path;
                    aiState.pathIndex = 0;
                }
            }
        }
    }

    isGridPositionWalkable(gridPos) {
        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', gridPos.x, gridPos.z);
        return this.isPositionWalkable(worldPos);
    }

    isPositionWalkable(pos) {
        const grid = this.worldToNavGrid(pos.x, pos.z);
        
        // Check bounds
        if (grid.x < 0 || grid.x >= this.navGridWidth || 
            grid.z < 0 || grid.z >= this.navGridHeight) {
            return false;
        }
        
        const terrain = this.getTerrainAtNavGrid(grid.x, grid.z);
        return this.isTerrainWalkable(terrain);
    }

    ping() {
        console.log('pong');
    }
};

// system: FogOfWarSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FogOfWarSystem'] = class FogOfWarSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.fogOfWarSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        this.VISION_RADIUS = 500;
        this.WORLD_SIZE = this.game.gameManager.call('getWorldExtendedSize');
        this.FOG_TEXTURE_SIZE = 64;

        // Line of sight settings (optimized)
        this.LOS_ENABLED = true;
        this.LOS_RAYS_PER_UNIT = 16;
        this.LOS_SAMPLE_DISTANCE = 12;
        this.LOS_UNIT_BLOCKING_ENABLED = true;
        this.LOS_UNIT_HEIGHT = 25;
        this.LOS_UNIT_BLOCK_RADIUS = 25;

        this.fogRenderTarget = null;
        this.explorationRenderTarget = null;
        this.explorationRenderTargetPingPong = null;
        this.fogScene = null;
        this.fogCamera = null;
        this.fogPass = null;

        // LOS mesh pool with geometry reuse
        this.losGeometryPool = [];
        this.losMeshPool = [];
        this.losMaterial = null;
        
        this.accumulationMaterial = null;
        this.accumulationQuad = null;
        this.accumulationScene = null;
        this.accumulationCamera = null;
        
        this.cachedVisibilityBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE);
        this.cachedExplorationBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE);
        this.visibilityCacheValid = false;
        this.explorationCacheValid = false;
        
        // Pre-allocate reusable arrays
        this.tempVisiblePoints = new Array(this.LOS_RAYS_PER_UNIT);
        for (let i = 0; i < this.LOS_RAYS_PER_UNIT; i++) {
            this.tempVisiblePoints[i] = { x: 0, z: 0 };
        }
       
    }

    init(params = {}) {
        this.params = params;
        this.initRendering();

        // Register getter methods
        this.game.gameManager.register('getExplorationTexture', this.getExplorationTexture.bind(this));
        this.game.gameManager.register('getFogTexture', this.getFogTexture.bind(this));
    }

    getExplorationTexture() {
        return this.explorationRenderTarget?.texture || null;
    }

    getFogTexture() {
        return this.fogRenderTarget?.texture || null;
    }
    initRendering(){
        this.fogRenderTarget = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RedFormat
            }
        );
        
        this.explorationRenderTarget = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RedFormat
            }
        );
        
        this.explorationRenderTargetPingPong = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RedFormat
            }
        );
        
        const halfSize = this.WORLD_SIZE / 2;
        this.fogCamera = new THREE.OrthographicCamera(
            -halfSize, halfSize,
            halfSize, -halfSize,
            0.1, 1000
        );
        this.fogCamera.position.set(0, 500, 0);
        this.fogCamera.lookAt(0, 0, 0);
        this.fogScene = new THREE.Scene();
        this.fogScene.background = new THREE.Color(0x000000);
                
        this.losMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 1.0,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        
        this.accumulationMaterial = new THREE.ShaderMaterial({
            uniforms: {
                currentExploration: { value: null },
                newVisibility: { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D currentExploration;
                uniform sampler2D newVisibility;
                varying vec2 vUv;
                
                void main() {
                    float explored = texture2D(currentExploration, vUv).r;
                    float visible = texture2D(newVisibility, vUv).r;
                    float newExploration = max(explored, visible);
                    gl_FragColor = vec4(newExploration, newExploration, newExploration, 1.0);
                }
            `
        });
        
        this.accumulationQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            this.accumulationMaterial
        );
        this.accumulationScene = new THREE.Scene();
        this.accumulationScene.add(this.accumulationQuad);
        this.accumulationCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        console.log('[FogOfWarSystem] Optimized GPU fog with LOS initialized');
    }

    postAllInit() {
        if (this.game.postProcessingSystem) {
            this.createFogPass();
            this.game.gameManager.call('registerPostProcessingPass', 'fog', {
                enabled: true,
                pass: this.fogPass
            });
        }
    }


    generateLOSVisibilityShape(unitPos, visionRadius, unitType, entityId) {
        const angleStep = (Math.PI * 2) / this.LOS_RAYS_PER_UNIT;
        
        for (let i = 0; i < this.LOS_RAYS_PER_UNIT; i++) {
            const angle = i * angleStep;
            const dirX = Math.cos(angle);
            const dirZ = Math.sin(angle);
            
            // Binary search with reduced iterations (4 instead of 6)
            let minDist = 0;
            let maxDist = visionRadius;
            let visibleDist = visionRadius;
            
            // First check max distance
            const maxX = unitPos.x + dirX * visionRadius;
            const maxZ = unitPos.z + dirZ * visionRadius;
            if (!this.game.gameManager.call('hasLineOfSight',
                { x: unitPos.x, z: unitPos.z },
                { x: maxX, z: maxZ },
                unitType,
                entityId
            )) {
                // Binary search with 4 iterations (instead of 6)
                for (let iter = 0; iter < 4; iter++) {
                    const midDist = (minDist + maxDist) / 2;
                    const midX = unitPos.x + dirX * midDist;
                    const midZ = unitPos.z + dirZ * midDist;
                    if (this.game.gameManager.call('hasLineOfSight',
                        { x: unitPos.x, z: unitPos.z },
                        { x: midX, z: midZ },
                        unitType,
                        entityId
                    )) {
                        minDist = midDist;
                    } else {
                        maxDist = midDist;
                    }
                }
                visibleDist = minDist;
            }
            
            // Reuse pre-allocated point objects
            this.tempVisiblePoints[i].x = unitPos.x + dirX * visibleDist;
            this.tempVisiblePoints[i].z = unitPos.z + dirZ * visibleDist;
        }
        
        return this.tempVisiblePoints;
    }

    updateVisibilityMesh(points, meshIndex) {
        if (points.length < 3) return null;
        
        const vertexCount = points.length * 3 * 3; // triangles * 3 vertices * 3 coords
        
        // Try to reuse existing geometry
        let geometry;
        if (meshIndex < this.losGeometryPool.length) {
            geometry = this.losGeometryPool[meshIndex];
            // Resize if needed
            const currentSize = geometry.attributes.position?.array.length || 0;
            if (currentSize !== vertexCount) {
                geometry.dispose();
                geometry = new THREE.BufferGeometry();
                this.losGeometryPool[meshIndex] = geometry;
            }
        } else {
            geometry = new THREE.BufferGeometry();
            this.losGeometryPool.push(geometry);
        }
        
        // Calculate center
        let centerX = 0, centerZ = 0;
        for (let i = 0; i < points.length; i++) {
            centerX += points[i].x;
            centerZ += points[i].z;
        }
        centerX /= points.length;
        centerZ /= points.length;
        
        // Create or update vertex buffer
        let vertices;
        if (geometry.attributes.position) {
            vertices = geometry.attributes.position.array;
            // Expand array if needed
            if (vertices.length !== vertexCount) {
                vertices = new Float32Array(vertexCount);
            }
        } else {
            vertices = new Float32Array(vertexCount);
        }
        
        // Fill vertices (triangle fan from center)
        // The fog camera looks down from Y=500, so we create a flat mesh in XZ plane at Y=0
        let vertIdx = 0;
        for (let i = 0; i < points.length; i++) {
            const nextI = (i + 1) % points.length;
            
            // Center point
            vertices[vertIdx++] = centerX;
            vertices[vertIdx++] = 0;
            vertices[vertIdx++] = centerZ;
            
            // Current point
            vertices[vertIdx++] = points[i].x;
            vertices[vertIdx++] = 0;
            vertices[vertIdx++] = points[i].z;
            
            // Next point
            vertices[vertIdx++] = points[nextI].x;
            vertices[vertIdx++] = 0;
            vertices[vertIdx++] = points[nextI].z;
        }
        
        if (!geometry.attributes.position || geometry.attributes.position.array !== vertices) {
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        }
        geometry.attributes.position.needsUpdate = true;
        geometry.computeBoundingSphere();
        
        // Reuse or create mesh
        let mesh;
        if (meshIndex < this.losMeshPool.length) {
            mesh = this.losMeshPool[meshIndex];
            if (mesh.geometry !== geometry) {
                mesh.geometry = geometry;
            }
        } else {
            mesh = new THREE.Mesh(geometry, this.losMaterial);
            this.losMeshPool.push(mesh);
            this.fogScene.add(mesh);
        }
        
        // Position mesh at origin (vertices are already in world space)
        mesh.position.set(0, 0, 0);
        mesh.rotation.set(0, 0, 0);
        mesh.scale.set(1, 1, 1);
        mesh.visible = true;
        
        return mesh;
    }

    createFogPass() {
        this.fogPass = {
            enabled: true,
            needsSwap: true,
            clear: false,
                                    
            uniforms: {
                tDiffuse: { value: null },
                tDepth: { value: null },
                fogTexture: { value: this.fogRenderTarget.texture },
                explorationTexture: { value: this.explorationRenderTarget.texture },
                worldSize: { value: this.WORLD_SIZE },
                cameraNear: { value: 1 },
                cameraFar: { value: 100 },
                cameraWorldMatrix: { value: new THREE.Matrix4() },
                cameraProjectionMatrixInv: { value: new THREE.Matrix4() }
            },
            
            material: null,
            fsQuad: null,
            fsQuadScene: null,
            fsQuadCamera: null
        };

        this.fogPass.material = new THREE.ShaderMaterial({
            uniforms: this.fogPass.uniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform sampler2D fogTexture;
                uniform sampler2D explorationTexture;
                uniform float worldSize;
                uniform float cameraNear;
                uniform float cameraFar;
                uniform mat4 cameraWorldMatrix;
                uniform mat4 cameraProjectionMatrixInv;

                varying vec2 vUv;
                
                float readDepth(vec2 coord) {
                    return texture2D(tDepth, coord).x;
                }
                
                vec3 getWorldPosition(vec2 uv, float depth) {
                    float x = uv.x * 2.0 - 1.0;
                    float y = uv.y * 2.0 - 1.0;
                    float z = depth * 2.0 - 1.0;
                    
                    vec4 clipPos = vec4(x, y, z, 1.0);
                    vec4 viewPos = cameraProjectionMatrixInv * clipPos;
                    viewPos /= viewPos.w;
                    vec4 worldPos = cameraWorldMatrix * viewPos;
                    
                    return worldPos.xyz;
                }

                void main() {
                    vec4 sceneColor = texture2D(tDiffuse, vUv);
                    float unexploredIntensity = 0.025;
                    float exploredIntensity = 0.2;
                    
                    float depth = readDepth(vUv);
                    vec3 worldPos = getWorldPosition(vUv, depth);
                    
                    float halfSize = worldSize * 0.5;
                    vec2 fogUV = vec2(
                        (worldPos.x + halfSize) / worldSize,
                        (-worldPos.z + halfSize) / worldSize
                    );
                    
                    vec3 grayscale = vec3(dot(sceneColor.rgb, vec3(0.299, 0.587, 0.114)));
                    
                    float inset = 1e-4;
                    if (fogUV.x < inset || fogUV.x > 1.0 - inset ||
                        fogUV.y < inset || fogUV.y > 1.0 - inset) {
                        gl_FragColor = vec4(grayscale * unexploredIntensity, 1.0);
                        return;
                    }
                    
                    vec4 fogSample = texture2D(fogTexture, fogUV);
                    float visibleGradient = fogSample.r;
                    
                    vec4 explorationSample = texture2D(explorationTexture, fogUV);
                    float explorationGradient = explorationSample.r;
                    
                    vec3 exploredColor = sceneColor.rgb * exploredIntensity;
                    vec3 visibleColor = mix(exploredColor, sceneColor.rgb, visibleGradient);
                    vec3 finalColor = mix(grayscale * unexploredIntensity, visibleColor, explorationGradient);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `
        });
        
        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, this.fogPass.material);
        const scene = new THREE.Scene();
        scene.add(mesh);
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        this.fogPass.fsQuadScene = scene;
        this.fogPass.fsQuadCamera = camera;
        
        const fogPassObj = this.fogPass;
        const fogSystemRef = this;
        
        this.fogPass.fsQuad = {
            render: (renderer) => {
                renderer.render(fogPassObj.fsQuadScene, fogPassObj.fsQuadCamera);
            }
        };
        
        this.fogPass.render = function(renderer, writeBuffer, readBuffer) {
            if (fogSystemRef.game.camera) {
                fogPassObj.uniforms.cameraWorldMatrix.value.copy(fogSystemRef.game.camera.matrixWorld);
                fogPassObj.uniforms.cameraProjectionMatrixInv.value.copy(fogSystemRef.game.camera.projectionMatrixInverse);
                fogPassObj.uniforms.cameraNear.value = fogSystemRef.game.camera.near;
                fogPassObj.uniforms.cameraFar.value = fogSystemRef.game.camera.far;
            }
            
            fogSystemRef.renderFogTexture();
            
            fogPassObj.uniforms.tDiffuse.value = readBuffer.texture;
            fogPassObj.uniforms.tDepth.value = readBuffer.depthTexture;
            
            if (fogPassObj.needsSwap) {
                renderer.setRenderTarget(writeBuffer);
            } else {
                renderer.setRenderTarget(null);
            }
            
            fogPassObj.fsQuad.render(renderer);
        };
                
        this.fogPass.setSize = function(width, height) {
            // No-op
        };
    }

    renderFogTexture() {
        const myTeam = this.game.state.mySide;
        if (!myTeam) return;

        const myUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        ).filter(id => {
            const team = this.game.getComponent(id, this.componentTypes.TEAM);
            return team?.team === myTeam;
        });

        // Hide all meshes
        this.losMeshPool.forEach(mesh => mesh.visible = false);

        let meshIndex = 0;

        myUnits.forEach((entityId) => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            if (!pos) return;

            const visionRadius = unitType?.visionRange || this.VISION_RADIUS;

            const visiblePoints = this.generateLOSVisibilityShape(
                { x: pos.x, z: pos.z },
                visionRadius,
                unitType,
                entityId
            );
            
            this.updateVisibilityMesh(visiblePoints, meshIndex);
    
            meshIndex++;
            
        });

        // Render visibility
        this.game.renderer.setRenderTarget(this.fogRenderTarget);
        this.game.renderer.render(this.fogScene, this.fogCamera);
        
        // Accumulate exploration
        this.accumulationMaterial.uniforms.currentExploration.value = this.explorationRenderTarget.texture;
        this.accumulationMaterial.uniforms.newVisibility.value = this.fogRenderTarget.texture;
        
        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);
        this.game.renderer.render(this.accumulationScene, this.accumulationCamera);
        
        const temp = this.explorationRenderTarget;
        this.explorationRenderTarget = this.explorationRenderTargetPingPong;
        this.explorationRenderTargetPingPong = temp;
        
        this.fogPass.uniforms.explorationTexture.value = this.explorationRenderTarget.texture;
        
        this.game.renderer.setRenderTarget(null);
        
        this.visibilityCacheValid = false;
        this.explorationCacheValid = false;
    }

    updateVisibilityCache() {
        if (this.visibilityCacheValid) return;
        
        this.game.renderer.readRenderTargetPixels(
            this.fogRenderTarget,
            0, 0,
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            this.cachedVisibilityBuffer
        );
        
        this.visibilityCacheValid = true;
    }

    updateExplorationCache() {
        if (this.explorationCacheValid) return;
        
        this.game.renderer.readRenderTargetPixels(
            this.explorationRenderTarget,
            0, 0,
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            this.cachedExplorationBuffer
        );
        
        this.explorationCacheValid = true;
    }

    //only available on CLIENT
    isVisibleAt(x, z) {
        const uv = this.worldToUV(x, z);
        if (!uv) return false;
        
        this.updateVisibilityCache();
        
        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);
        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);
        const index = (py * this.FOG_TEXTURE_SIZE + px);
        
        return this.cachedVisibilityBuffer[index] > 0;
    }

    //only available on CLIENT
    isExploredAt(x, z) {
        const uv = this.worldToUV(x, z);
        if (!uv) return false;
        
        this.updateExplorationCache();
        
        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);
        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);
        const index = (py * this.FOG_TEXTURE_SIZE + px);
        
        return this.cachedExplorationBuffer[index] > 0;
    }

    worldToUV(x, z) {
        const half = this.WORLD_SIZE * 0.5;
        let u = (x + half) / this.WORLD_SIZE;
        let v = (-z + half) / this.WORLD_SIZE;

        if (u < 0 || u > 1 || v < 0 || v > 1) {
            return null;
        }

        return { x: u, y: v };
    }

    resetExploration() {
        this.game.renderer.setRenderTarget(this.explorationRenderTarget);
        this.game.renderer.clear();
        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);
        this.game.renderer.clear();
        this.game.renderer.setRenderTarget(null);
        this.explorationCacheValid = false;
    }

    dispose() {
        if (this.fogRenderTarget) this.fogRenderTarget.dispose();
        if (this.explorationRenderTarget) this.explorationRenderTarget.dispose();
        if (this.explorationRenderTargetPingPong) this.explorationRenderTargetPingPong.dispose();
        if (this.game.postProcessingSystem) this.game.gameManager.call('removePostProcessingPass', 'fog');
        if (this.accumulationMaterial) this.accumulationMaterial.dispose();
        if (this.accumulationQuad) this.accumulationQuad.geometry.dispose();
        if (this.losMaterial) this.losMaterial.dispose();

        this.losGeometryPool.forEach(geom => geom.dispose());
        this.losMeshPool = [];
        this.losGeometryPool = [];
    }
};

// system: SelectedUnitSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SelectedUnitSystem'] = class SelectedUnitSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.selectedUnitSystem = this;
        this.canvas = this.game.canvas;
        
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Selection circle configuration
        this.CIRCLE_RADIUS = 25;
        this.CIRCLE_SEGMENTS = 32;
        this.CIRCLE_THICKNESS = 2;
        this.CIRCLE_COLOR = 0x00ff00; // Green selection color
        this.CIRCLE_OFFSET_Y = 1;   // Slightly above ground to prevent z-fighting
        
        // Track selection circles
        this.selectionCircles = new Map(); // entityId -> { circle, group, lastPosition }
        
        // Currently highlighted units
        this.highlightedUnits = new Set();
        
        // Box selection state
        this.boxSelection = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            element: null
        };
        
        // Selection mode tracking
        this.selectedUnitIds = new Set(); // Track multiple selected squads
        
        this.currentSelectedIndex = 0;
        // Initialize flag
        this.initialized = false;
    }

    init() {
        this.game.gameManager.register('getSelectedSquads', this.getSelectedSquads.bind(this));
    }

    initialize() {
        if (this.initialized || !this.game.scene) return;
        
        this.initialized = true;
        this.createBoxSelectionElement();
        this.setupBoxSelectionListeners();
        
        const unitPortrait = document.getElementById('unitPortrait');   
        unitPortrait.addEventListener('click', () => {
            if(this.game.cameraControlSystem) {
                if(this.game.state.selectedEntity.entityId){
                    const pos = this.game.getComponent(this.game.state.selectedEntity.entityId, this.game.componentManager.getComponentTypes().POSITION);
                    if(pos){
                        this.game.gameManager.call('cameraLookAt', pos.x, pos.z);
                    }
                }
            }
        });
    }
    
    createBoxSelectionElement() {
        // Create the visual selection box element
        const boxElement = document.createElement('div');
        boxElement.id = 'unitSelectionBox';
        boxElement.style.cssText = `
            position: absolute;
            border: 2px solid rgba(0, 255, 0, 0.8);
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            display: none;
            z-index: 10000;
        `;
        document.body.appendChild(boxElement);
        this.boxSelection.element = boxElement;
    }
    
    setupBoxSelectionListeners() {
        // Mouse down - start box selection
        this.canvas.addEventListener('mousedown', (event) => {
            // Only left click, and not clicking on UI elements
            if (event.button !== 0) return;
            
            const rect = this.canvas.getBoundingClientRect();
            this.boxSelection.startX = event.clientX;
            this.boxSelection.startY = event.clientY;
            this.boxSelection.currentX = event.clientX;
            this.boxSelection.currentY = event.clientY;
            this.boxSelection.active = true;
            
            // Don't show box immediately - wait for drag
        });
        
        // Mouse move - update box selection
        this.canvas.addEventListener('mousemove', (event) => {
            if (!this.boxSelection.active) return;
            
            this.boxSelection.currentX = event.clientX;
            this.boxSelection.currentY = event.clientY;
            
            // Calculate distance dragged
            const dx = this.boxSelection.currentX - this.boxSelection.startX;
            const dy = this.boxSelection.currentY - this.boxSelection.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Only show box if dragged more than 5 pixels (prevents accidental box on click)
            if (distance > 5) {
                this.updateBoxSelectionVisual();
            }
        });
        
        // Mouse up - complete box selection
        this.canvas.addEventListener('mouseup', (event) => {
            if (!this.boxSelection.active) return;
            
            const dx = this.boxSelection.currentX - this.boxSelection.startX;
            const dy = this.boxSelection.currentY - this.boxSelection.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If dragged significantly, do box selection
            if (distance > 5) {
                requestAnimationFrame(() => {
                    this.completeBoxSelection(event);
                });
            } else {
                // Single click selection
                
                requestAnimationFrame(() => {
                    this.checkUnitSelectionClick(event);
                });
            }
            
            // Reset box selection state
            this.boxSelection.active = false;
            this.boxSelection.element.style.display = 'none';
        });
        
        // Cancel box selection on context menu or escape
        this.canvas.addEventListener('contextmenu', (event) => {
            if (this.boxSelection.active) {
                event.preventDefault();
                this.cancelBoxSelection();
            }
        });
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && this.boxSelection.active) {
                this.cancelBoxSelection();
            }
        });
    }
    
    updateBoxSelectionVisual() {
        const box = this.boxSelection;
        const element = box.element;
        
        // Calculate box dimensions
        const left = Math.min(box.startX, box.currentX);
        const top = Math.min(box.startY, box.currentY);
        const width = Math.abs(box.currentX - box.startX);
        const height = Math.abs(box.currentY - box.startY);
        
        // Update element
        element.style.left = left + 'px';
        element.style.top = top + 'px';
        element.style.width = width + 'px';
        element.style.height = height + 'px';
        element.style.display = 'block';
    }
        
    completeBoxSelection(event) {
        const box = this.boxSelection;
        
        // Get box boundaries in screen space (client coordinates)
        const left = Math.min(box.startX, box.currentX);
        const right = Math.max(box.startX, box.currentX);
        const top = Math.min(box.startY, box.currentY);
        const bottom = Math.max(box.startY, box.currentY);
        
        // Find all units within the selection box
        const selectedUnits = this.getUnitsInScreenBox(left, top, right, bottom);
        
        // Check if shift is held for additive selection
        const isAdditive = event.shiftKey;
        
        if (!isAdditive) {
            this.selectedUnitIds.clear();
        }
        selectedUnits.forEach((unitId) => {
            this.selectedUnitIds.add(unitId);
        });
        this.currentSelectedIndex = 0;
        if (this.selectedUnitIds.size > 0) {
            this.updateMultipleSquadSelection();
        } else {            
            this.deselectAll();
        }
        
    }


    getUnitsInScreenBox(left, top, right, bottom) {
        const selectedUnits = [];
        const selectedBuildings = [];
        const rect = this.canvas.getBoundingClientRect();
        
        // Get all entities with position component
        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION);
        
        entities.forEach(entityId => {
            // Only select units on player's team
            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
            if (!team) return;
            
            // Try multiple ways to check team
            const unitTeam = team.team || team.side || team.teamId;
            const myTeam = this.game.state.mySide || this.game.state.playerSide || this.game.state.team;
            
            if (unitTeam !== myTeam) {
                return;
            }
            
            // Get position component
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            if (!pos || !unitType) return;
            
            // Convert world position to screen position
            const screenPos = this.worldToScreen(pos.x, pos.y, pos.z);
            if (!screenPos) return;
            
            // Convert normalized screen coords (0-1) to client coordinates
            const screenX = screenPos.x * rect.width + rect.left;
            const screenY = screenPos.y * rect.height + rect.top;
            
            // Check if within selection box (in client coordinates)
            if (screenX >= left && screenX <= right && 
                screenY >= top && screenY <= bottom) {
                if(unitType.collection == 'units'){
                    selectedUnits.push(entityId);
                } else {
                    selectedBuildings.push(entityId);
                }
            }
        });
        
        return selectedUnits.length > 0 ? selectedUnits : selectedBuildings;
    }
    worldToScreen(x, y, z) {
        if (!this.game.camera || !this.game.canvas) return null;
        
        try {
            // Create a 3D vector
            const vector = new THREE.Vector3(x, y, z);
            
            // Project to screen space
            vector.project(this.game.camera);
            
            // Check if behind camera
            if (vector.z > 1) return null;
            
            // Convert to screen coordinates (0 to 1 range)
            // (0,0) is top-left, (1,1) is bottom-right
            return {
                x: (vector.x + 1) / 2,
                y: (-vector.y + 1) / 2
            };
        } catch (error) {
            console.warn('[SelectedUnitSystem] worldToScreen error:', error);
            return null;
        }
    }
    findSquadForUnit(entityId) {           
        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
        return team?.placementId || null;
    }
    updateMultipleSquadSelection() {        
        this.currentSelectedIndex = 0;
        const unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];
    
        this.setSelectedEntity(unitId);         
        this.highlightUnits(Array.from(this.selectedUnitIds)); 
        this.game.triggerEvent("onMultipleUnitsSelected", this.selectedUnitIds);
        if(this.selectedUnitIds.size > 0){
            let unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];
            this.game.triggerEvent("onUnitSelected", unitId);
        }
    }
    
    
    cancelBoxSelection() {
        this.boxSelection.active = false;
        this.boxSelection.element.style.display = 'none';
    }

    checkUnitSelectionClick(event) {
        const worldPos = this.game.gameManager.call('getWorldPositionFromMouse');
    
        if (!worldPos) return;
    
        const placementId = this.getPlacementAtWorldPosition(worldPos);
    
        if (placementId) {
            const placement = this.game.gameManager.call('getPlacementById', placementId);
            if (placement && placement.team === this.game.state.mySide) {
                let entityId = placement.squadUnits[0];
                // Check if shift is held for additive selection
                if (event.shiftKey) {
                    if (this.selectedUnitIds.has(entityId)) {
                        // Deselect if already selected
                        this.selectedUnitIds.delete(entityId);
                    } else {
                        // Add to selection
                        this.selectedUnitIds.add(entityId);
                    }
                    this.updateMultipleSquadSelection();
                } else {
                    // Single selection (clear others)
                    this.deselectAll();
                    this.selectedUnitIds.add(entityId);
                    this.selectUnit(entityId, placementId);
                }
            }
        } else {
            // Clicked on empty space - deselect all
            if (!event.shiftKey) {
                this.deselectAll();
            }
        }
    }
    
    deselectAll() {
        this.clearAllHighlights();
        this.selectedUnitIds.clear();                
        this.game.state.selectedEntity.entityId = null;
        this.game.state.selectedEntity.collection = null;

        const actionPanel = document.getElementById('actionPanel');     
        if(actionPanel) {
            actionPanel.innerHTML = "";
        }

        const selectedUnits = document.getElementById('selectedUnits');        
        if(selectedUnits) {
            selectedUnits.innerHTML = "";
        }

        const unitPortrait = document.getElementById('unitPortrait');        
        if(unitPortrait){
            unitPortrait.innerHTML = "";
        }
        
        this.game.triggerEvent('onDeSelectAll');
    }

    getPlacementAtWorldPosition(worldPos) {
        const clickRadius = 30;
        let closestPlacementId = null;
        let closestDistance = clickRadius;
        
        const entities = this.game.getEntitiesWith(
            this.game.componentManager.getComponentTypes().POSITION,
            this.game.componentManager.getComponentTypes().PLACEMENT
        );
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            const placement = this.game.getComponent(entityId, this.componentTypes.PLACEMENT);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            const dx = pos.x - worldPos.x;
            const dz = pos.z - worldPos.z;
            let distance = Math.sqrt(dx * dx + dz * dz);
            
            if(unitType.size) {
                distance -= unitType.size;
            }
                

            if (distance < closestDistance) {
                closestDistance = distance;
                closestPlacementId = placement.placementId;
            }
        });
        
        return closestPlacementId;
    }

    selectUnit(entityId, placementId) {
        if (!entityId) return;
        
        const squadData = this.game.gameManager.call('getSquadInfo', placementId);
        
        if (squadData) {
            const placement = this.game.gameManager.call('getPlacementById', placementId);
            squadData.unitIds = placement.squadUnits;
            this.setSelectedEntity(entityId);
            this.highlightUnits(placement.squadUnits);              
            this.game.triggerEvent("onUnitSelected", entityId)
        }
    }

    setSelectedEntity(entityId){         
        const CT = this.game.componentManager.getComponentTypes();
        const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);     
        this.game.state.selectedEntity.entityId = entityId;
        this.game.state.selectedEntity.collection = unitType.collection;      
    }

    update() {
        // Wait for scene to be available
        if (!this.game.scene || !this.game.camera) {
            return;
        }
        
        // Initialize if not done yet
        if (!this.initialized) {
            this.initialize();
        }
        
        
        // Update all active selection circles
        this.updateSelectionCircles();
        
        // Clean up circles for units that no longer exist or are deselected
        this.cleanupRemovedCircles();
    }
    
    highlightUnits(unitIds) {
        if (!unitIds || !Array.isArray(unitIds)) {
            this.clearAllHighlights();
            return;
        }
        
        // Convert to Set for easy comparison
        const newHighlightSet = new Set(unitIds);
        
        // Remove circles for units no longer selected
        for (const entityId of this.highlightedUnits) {
            if (!newHighlightSet.has(entityId)) {
                this.removeSelectionCircle(entityId);
            }
        }
        
        // Add circles for newly selected units
        for (const entityId of unitIds) {
            if (!this.highlightedUnits.has(entityId)) {
                this.createSelectionCircle(entityId);
            }
        }
        
        if(document){
            const container = document.getElementById('unitPortrait');
            container.innerHTML = ``;
            const portrait = this.createPortrait(unitIds[this.currentSelectedIndex]);
            if(portrait){
                container.append(portrait);
            }
            const selectedUnitsContainer = document.getElementById('selectedUnits');
            selectedUnitsContainer.innerHTML = ``;
            
            unitIds.forEach((unitId, index) => {
                const selectedPortrait = this.createPortrait(unitId);
                if(selectedPortrait){
                    const selectedUnitIconContainer = document.createElement('div');
                    if(index == this.currentSelectedIndex){                        
                        selectedUnitIconContainer.classList.add('selected');
                    }
                    selectedUnitIconContainer.append(selectedPortrait);
                    selectedUnitsContainer.append(selectedUnitIconContainer);
                    selectedUnitIconContainer.addEventListener('click', () => {
                        this.deselectAll();
                        this.selectedUnitIds.add(unitId);
                        const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);
                        this.selectUnit(unitId, placement.placementId);
                    });
                }            
            });            
        }
        // Update tracked set
        this.highlightedUnits = newHighlightSet;
        
    }

    createPortrait(entityId){
        if(document) {
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const icon = this.game.getCollections().icons[unitType.icon];

            if(icon){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                return img;
            }
        }
        return null;
    }
    
    clearAllHighlights() {
        // Remove all selection circles
        for (const entityId of this.highlightedUnits) {
            this.removeSelectionCircle(entityId);
        }
        
        this.currentSelectedIndex = 0;
        this.highlightedUnits.clear();
    }
    
    createSelectionCircle(entityId) {
        // Don't create if already exists
        if (this.selectionCircles.has(entityId)) return;
        
        // Get entity position to determine size
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Determine radius based on unit type
        const radius = this.getUnitRadius(entityId);
        
        // Create ring geometry (donut shape)
        const geometry = new THREE.RingGeometry(
            radius - this.CIRCLE_THICKNESS / 2,
            radius + this.CIRCLE_THICKNESS / 2,
            this.CIRCLE_SEGMENTS
        );
        
        // Create material
        const material = new THREE.MeshBasicMaterial({
            color: this.CIRCLE_COLOR,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        
        // Create mesh
        const circle = new THREE.Mesh(geometry, material);
        circle.rotation.x = -Math.PI / 2; // Lay flat on ground
        circle.renderOrder = 9998; // Render before health bars
        
        // Create group to hold circle
        const group = new THREE.Group();
        group.add(circle);
        
        // Add to UI scene
        this.game.scene.add(group);
        
        // Store reference
        this.selectionCircles.set(entityId, {
            circle: circle,
            group: group,
            geometry: geometry,
            material: material,
            radius: radius,
            lastPosition: { x: pos.x, y: pos.y, z: pos.z },
            baseOpacity: 0.8
        });
        
        console.log(`[SelectedUnitSystem] Created selection circle for entity ${entityId}`);
    }
    
    updateSelectionCircles() {
        for (const [entityId, circleData] of this.selectionCircles) {
            // Check if entity still exists
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) {
                this.removeSelectionCircle(entityId);
                continue;
            }
            
            // Update position
            circleData.group.position.set(pos.x, pos.y + this.CIRCLE_OFFSET_Y, pos.z);
        }
    }
    
    getUnitRadius(entityId) {
        // Try to get unit type to determine appropriate radius
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        
        if (unitType) {
            const collections = this.game.getCollections?.();
            const unitData = (collections && collections[unitType.collection])
                ? collections[unitType.collection][unitType.id]
                : null;
            
            if (unitData && unitData.size) {
                return unitData.size + 2; // Slightly larger than unit
            }
        }
        
        // Default radius if no unit data
        return this.CIRCLE_RADIUS;
    }
    
    cleanupRemovedCircles() {
        for (const [entityId] of this.selectionCircles) {
            // Check if entity still exists
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) {
                this.removeSelectionCircle(entityId);
            }
            
            // Check if entity is still highlighted
            if (!this.highlightedUnits.has(entityId)) {
                this.removeSelectionCircle(entityId);
            }
        }
    }
    
    removeSelectionCircle(entityId) {
        const circleData = this.selectionCircles.get(entityId);
        if (!circleData) return;
        
        // Remove from scene
        if (this.game.scene) {
            this.game.scene.remove(circleData.group);
        }
        
        // Dispose of resources
        circleData.geometry.dispose();
        circleData.material.dispose();
        
        // Remove from map
        this.selectionCircles.delete(entityId);
        
        console.log(`[SelectedUnitSystem] Removed selection circle for entity ${entityId}`);
    }
    
    // Configuration methods
    setSelectionColor(color) {
        this.CIRCLE_COLOR = color;
        
        // Update existing circles
        for (const [_, circleData] of this.selectionCircles) {
            circleData.material.color.setHex(color);
        }
    }
    
    
    setCircleThickness(thickness) {
        this.CIRCLE_THICKNESS = thickness;
        
        // Would need to recreate all circles to apply
        // For now, just update the config for future circles
    }
    
    toggleAnimation(enabled) {
        if (!enabled) {
            // Reset all circles to default state
            for (const [_, circleData] of this.selectionCircles) {
                circleData.circle.scale.set(1, 1, 1);
                circleData.circle.rotation.z = 0;
                circleData.material.opacity = circleData.baseOpacity;
            }
        }
    }
    
    // Utility to check if a unit is currently highlighted
    isHighlighted(entityId) {
        return this.highlightedUnits.has(entityId);
    }
    
    // Get all currently highlighted unit IDs
    getHighlightedUnits() {
        return Array.from(this.highlightedUnits);
    }
    
    // Get all currently selected squad IDs
    getSelectedSquads() {
        let placementIds = new Set();
        const CT = this.game.componentManager.getComponentTypes();
        Array.from(this.selectedUnitIds).forEach((unitId) => {
            const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);
            placementIds.add(placement.placementId);
        });
        return [...placementIds];
    }
    getSelectedUnits() {
        return Array.from(this.selectedUnitIds);
    }

    
    onBattleStart() {
        this.deselectAll();
    }
    onKeyDown(key) {
        if (key === 'Escape') {
            this.deselectAll();
        }
    }
    
    destroy() {
        // Clean up box selection element
        if (this.boxSelection.element && this.boxSelection.element.parentElement) {
            this.boxSelection.element.parentElement.removeChild(this.boxSelection.element);
        }
        
        // Clean up all selection circles
        for (const [entityId] of this.selectionCircles) {
            this.removeSelectionCircle(entityId);
        }
        
        this.selectionCircles.clear();
        this.highlightedUnits.clear();
        this.selectedUnitIds.clear();
        this.initialized = false;
        
        console.log('[SelectedUnitSystem] Destroyed');
    }
};

// system: UnitOrderSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['UnitOrderSystem'] = class UnitOrderSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game = game;
        this.game.unitOrderSystem = this;

        this.CT = this.game.componentManager.getComponentTypes();

        this.isTargeting = false;
        this.isForceMove = false;
        this.pendingCallbacks = 0;

        this._onCanvasClick = this._onCanvasClick.bind(this);
       // this._onCanvasMouseMove = this._onCanvasMouseMove.bind(this);

        this.cursorWhenTargeting = 'crosshair';
        this.pingEffect = { count: 12, color: 0x00ff00 };
        this.temporaryOpponentMoveOrders = new Map();
        this.targetingPreview = new GUTS.PlacementPreview(this.game);
        this.targetingPreview.updateConfig({
            cellOpacity: 0.3,
            borderOpacity: 0.6
        });
    }

    init() {
        // Register methods with GameManager
        this.game.gameManager.register('getTemporaryOpponentMoveOrders', () => this.temporaryOpponentMoveOrders);
        this.game.gameManager.register('deleteTemporaryOpponentMoveOrder', (placementId) => {
            this.temporaryOpponentMoveOrders.delete(placementId);
        });
    }

    showSquadActionPanel(placementId) {
        const actionPanel = document.getElementById('actionPanel');
        if (!actionPanel) return;


        const placement = this.game.gameManager.call('getPlacementById', placementId);
        
        actionPanel.innerHTML = "";
          
        
        const firstUnit = placement.squadUnits[0];
        const unitType = firstUnit ? this.game.getComponent(firstUnit, this.CT.UNIT_TYPE) : null;
        
        let squadPanel = document.createElement('div');
        squadPanel.id = 'squadActionPanel';
        
        actionPanel.appendChild(squadPanel);
        
        this.displayActionSet(null, squadPanel, firstUnit, unitType);
    }

    displayActionSet(actionSetId, panel, selectedUnitId, unitType) {
        panel.innerHTML = ``;
        const actionSection = document.createElement('div');
        actionSection.className = 'action-section';

        const grid = document.createElement('div');
        grid.className = 'action-grid';
        
        let actions = [];

        if(!unitType.actionSet){
            if(unitType.collection == 'units'){
                unitType.actionSet = 'defaultUnitActions';
            } 
        } 

        if(actionSetId || unitType.actionSet){
            if(!actionSetId) {
                actionSetId = unitType.actionSet;
            }
            let currentActionSet = this.game.getCollections().actionSets[actionSetId];
            if(currentActionSet.actions){
                actions = currentActionSet.actions;
                const actionsCollection = this.game.getCollections().actions;
                actions.forEach((actionId) => {
                    let action = actionsCollection[actionId];
                    const btn = this.createActionButton(action, panel, selectedUnitId, unitType);
                    grid.appendChild(btn);
                });
            } else if(currentActionSet.buildings){
                const buildings = this.game.getCollections().buildings;
                currentActionSet.buildings.forEach(buildingId => {
                    if (buildingId === 'underConstruction') return;
                    
                    const building = buildings[buildingId];            
                    if (!building.buildTime) building.buildTime = 1;
                    
                    building.id = buildingId;
                    building.collection = "buildings";
                    const canAfford = this.game.state.playerGold >= (building.value || 0);
                    const isLocked = this.game.shopSystem?.isBuildingLocked(buildingId, building);
                    const lockReason = this.game.shopSystem?.getLockReason(buildingId, building);
                    
                    const btn = this.createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId);
                    grid.appendChild(btn);
                });
            }
        }
        actionSection.appendChild(grid);
    
        panel.appendChild(actionSection);
    }

    createActionButton(action, panel, selectedUnitId, unitType) {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.title = `${action.title}`;

        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(action.icon){
            const icon = this.game.getCollections().icons[action.icon];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  'ðŸ›ï¸';
            }
        } else {
            iconEl.textContent =  'ðŸ›ï¸';
        }
        btn.append(iconEl);

        if(action.order){
            btn.addEventListener('click', () => {
                this[action.order]();
            });
        } else if(action.actionSet){
            btn.addEventListener('click', () => {
                this.displayActionSet(action.actionSet, panel, selectedUnitId, unitType);
            });
        }
        return btn;
    }

    createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId) {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.title = `${building.title} ðŸ’°${building.value}`;
        const locked = isLocked || !canAfford;
        if (locked) {
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
            btn.title = `${building.title} ${lockReason}`;
        }
        
        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(building.icon){
            const icon = this.game.getCollections().icons[building.icon];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  'ðŸ›ï¸';
            }
        } else {
            iconEl.textContent =  'ðŸ›ï¸';
        }
        btn.append(iconEl);

        if (!locked) {
            btn.addEventListener('click', () => {
                this.activateBuildingPlacement(building, selectedUnitId);
            });
            
            btn.addEventListener('mouseenter', () => {
                btn.style.border = '2px solid var(--primary-gold)';
                btn.style.transform = 'translateY(-2px)';
            });
            
            btn.addEventListener('mouseleave', () => {
                btn.style.border = '2px solid rgba(255, 170, 0, 0.3)';
                btn.style.transform = 'translateY(0)';
            });
        }

        return btn;
    }

    activateBuildingPlacement(building, selectedUnitId) {
        this.game.state.selectedUnitType = {...building};
        
        this.game.state.peasantBuildingPlacement = {
            peasantId: selectedUnitId,
            buildTime: building.buildTime
        };
        
        this.stopTargeting();
        
        this.game.triggerEvent('onActivateBuildingPlacement', this.game.state.selectedUnitType);
    }
    moveOrderAction() {
        this.startTargeting({preventEnemiesInRangeCheck: true});
    }

    startTargeting(meta = {}) {
        this.stopTargeting();
        if(this.game.state.phase != 'placement') return;
        this.isTargeting = true;
        this.orderMeta = meta;
        this.pendingCallbacks = 0;

        const canvas = this.game.canvas;
        if (canvas) {
            canvas.addEventListener('contextmenu', this._onCanvasClick, { once: true });
           // canvas.addEventListener('mousemove', this._onCanvasMouseMove);
        }

    }

    stopTargeting() {
        if (!this.isTargeting) return;
        this.isTargeting = false;

        const canvas = this.game.canvas;
        if (canvas) {
            canvas.removeEventListener('contextmenu', this._onCanvasClick, { once: true });
       //     canvas.removeEventListener('mousemove', this._onCanvasMouseMove);
        }
        
        this.targetingPreview.clear();
    }

    holdPosition() {
        this.stopTargeting();

        let placementIds = this.game.gameManager.call('getSelectedSquads') || [];
        
        if (!placementIds || placementIds.length === 0) {
            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);
            return;
        }
        placementIds.forEach((placementId) => {
            const placement = this.game.gameManager.call('getPlacementById', placementId);
            placement.squadUnits.forEach((unitId) => {
                const position = this.game.getComponent(unitId, this.CT.POSITION);
                const aiState = this.game.getComponent(unitId, this.CT.AI_STATE);
                if (this.game.effectsSystem && position) {
                    this.game.gameManager.call('createParticleEffect', position.x, 0, position.z, 'magic', { ...this.pingEffect });
                }
                let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, "UnitOrderSystem");
                currentOrderAI.targetPosition = position;
                currentOrderAI.path = [];
                currentOrderAI.meta = {
                    allowMovement: false
                };
                this.game.gameManager.call('setCurrentAIController', unitId, "UnitOrderSystem", currentOrderAI);   
            });
        });
        
    }

    onKeyDown(key) {
        if (key === 'Escape' && this.isTargeting) {
            this.game.uiSystem?.showNotification('âŒ Targeting canceled', 'warning', 800);
            this.stopTargeting();
        }
    }
    onUnitSelected(entityId){
        const unitType = this.game.getComponent(entityId, this.CT.UNIT_TYPE);
        if(unitType.collection == "units") {
            const placement = this.game.getComponent(entityId, this.CT.PLACEMENT);        
            const placementId = placement.placementId;
            this.showSquadActionPanel(placementId);   
            this.startTargeting();     
        } else {
            this.stopTargeting();
        }
        this.showMoveTargets();
    }
    showMoveTargets() {
        this.targetingPreview.clear();
        const placementIds = this.game.gameManager.call('getSelectedSquads') || [];
        const targetPositions = [];
        placementIds.forEach((placementId) => {
            const placement = this.game.gameManager.call('getPlacementById', placementId);
            placement.squadUnits.forEach((entityId) => {                
                const aiState = this.game.getComponent(entityId, this.CT.AI_STATE);   
                if(aiState.targetPosition && aiState.aiControllerId == "UnitOrderSystem"){
                    targetPositions.push(aiState.targetPosition);
                }
            });            
        });

        this.targetingPreview.showAtWorldPositions(targetPositions, true);
    }
    // _onCanvasMouseMove(event) {
    //     if (!this.isTargeting) return;

    //     const canvas = this.game.canvas;
    //     if (!canvas) {
    //         this.stopTargeting();
    //         this.targetingPreview.clear();
    //         return;
    //     }

    //     const rect = canvas.getBoundingClientRect();
    //     const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    //     const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    //     const worldPos = this.game.placementSystem?.getWorldPositionFromMouse?.(event, mouseX, mouseY);
    //     if (!worldPos) {
    //         this.game.uiSystem?.showNotification('Could not find ground under cursor.', 'error', 1000);
    //         this.targetingPreview.clear();
    //         this.stopTargeting();
    //         return;
    //     }
    //     const placementIds = this.game.selectedUnitSystem.getSelectedSquads() || [];
    //     let isBuilding = false;
    //     placementIds.forEach((placementId) => {
    //         const placement = this.game.placementSystem.getPlacementById(placementId);
    //         if(placement.unitType.collection == "buildings"){
    //             isBuilding = true;
    //         }
    //         targetPositions.push(placement.targetPosition);
    //     });
    //     if(isBuilding){
    //         const targetPosition = { x: worldPos.x, z: worldPos.z };
    //         const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);
    //         this.targetingPreview.showAtWorldPositions(targetPositions, true);
    //     }
    // }

    _onCanvasClick(event) {
        if (!this.isTargeting) return;

        const canvas = this.game.canvas;
        if (!canvas) {
            this.stopTargeting();
            return;
        }
 
        const worldPos = this.game.gameManager.call('getWorldPositionFromMouse');
        if (!worldPos) {
            this.game.uiSystem?.showNotification('Could not find ground under cursor.', 'error', 1000);
            this.stopTargeting();
            return;
        }

        let placementIds = this.game.gameManager.call('getSelectedSquads') || [];
        
        if (!placementIds || placementIds.length === 0) {
            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);
            this.stopTargeting();
            return;
        }

        const targetPosition = { x: worldPos.x, y: 0, z: worldPos.z };

        if (this.game.effectsSystem) {
            this.game.gameManager.call('createParticleEffect', worldPos.x, 0, worldPos.z, 'magic', { ...this.pingEffect });
        }

        this.issueMoveOrders(placementIds, targetPosition);
    }

    issueMoveOrders(placementIds, targetPosition) {
        if(this.game.state.phase != "placement") {
            return;
        };
        const meta = { ...this.orderMeta };
        this.orderMeta = {};
        const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);
        this.game.networkManager.setSquadTargets(
            { placementIds, targetPositions, meta },
            (success) => {
                if (success) {
                    for(let i = 0; i < placementIds.length; i++){
                        let placementId = placementIds[i];
                        const targetPosition = targetPositions[i];
                        const placement = this.game.gameManager.call('getPlacementById', placementId);
                        placement.squadUnits.forEach((unitId) => {
                            if (this.game.effectsSystem && targetPosition) {
                                this.game.gameManager.call('createParticleEffect', targetPosition.x, 0, targetPosition.z, 'magic', { ...this.pingEffect });
                            }
                            if(targetPosition){
                                this.game.gameManager.call('clearCommands', unitId);
                                this.game.gameManager.call('queueCommand', unitId, {
                                    type: 'move',
                                    controllerId: "UnitOrderSystem",
                                    targetPosition: targetPosition,
                                    target: null,
                                    meta: meta,
                                    priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                                    interruptible: true
                                }, true); // true = interrupt current command
                            
                            }
                        });

                    }
                    this.startTargeting();
                    this.showMoveTargets();
                }
            }
        );
    }

    getFormationTargetPositions(targetPosition, placementIds){
        let targetPositions = [];
        // Use placement grid size (half of terrain grid) for unit formation spacing
        const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;
        const unitPadding = 1;

        for(let i = 0; i < placementIds.length; i++){
            targetPositions.push({
                x: targetPosition.x,
                z: i % 2 == 0 ? targetPosition.z + i * placementGridSize * unitPadding : targetPosition.z - i * placementGridSize * unitPadding
            });
        }
        return targetPositions;
    }

    applySquadTargetPosition(placementId, targetPosition, meta) {
        const placement = this.game.gameManager.call('getPlacementById', placementId);
        if(!placement){
            this.temporaryOpponentMoveOrders.set(placementId, { targetPosition: targetPosition, meta: meta });
            return;
        }
        placement.targetPosition = targetPosition;
        placement.squadUnits.forEach((unitId) => {
            if(targetPosition){
                // Use command queue system for move orders
                if (this.game.commandQueueSystem) {
                    this.game.gameManager.call('queueCommand', unitId, {
                        type: 'move',
                        controllerId: "UnitOrderSystem",
                        targetPosition: targetPosition,
                        target: null,
                        meta: meta,
                        priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                        interruptible: true
                    }, true); // true = interrupt current command
                } else {
                    // Fallback to old method
                    let currentOrderAI = this.game.gameManager.call('getAIControllerData', unitId, "UnitOrderSystem");
                    currentOrderAI.targetPosition = targetPosition;
                    currentOrderAI.path = [];
                    currentOrderAI.meta = meta;
                    this.game.gameManager.call('setCurrentAIController', unitId, "UnitOrderSystem", currentOrderAI);
                }
            }
        });
    }

    applySquadsTargetPositions(placementIds, targetPositions, meta) {     
        for(let i = 0; i < placementIds.length; i++){  
            let placementId = placementIds[i];
            let targetPosition = targetPositions[i];
            this.applySquadTargetPosition(placementId, targetPosition, meta);
        }
    }
    onBattleStart() {
        this.stopTargeting();
    }
    onDeSelectAll() {        
        this.targetingPreview.clear();
    }

    destroy() {
        this.stopTargeting();
        if (this.targetingPreview) {
            this.targetingPreview.dispose();
        }
    }
};

// system: MiniMapSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MiniMapSystem'] = class MiniMapSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.miniMapSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.MINIMAP_SIZE = 200;
        this.MINIMAP_PADDING = 10;
        
        this.container = null;
        this.canvas = null;
        this.ctx = null;
        
        this.minimapCamera = null;
        this.minimapScene = null;
        this.minimapRenderTarget = null;
        
        this.unitIconGeometry = null;
        this.buildingIconGeometry = null;
        this.goldVeinIconGeometry = null;
        this.friendlyIconMaterial = null;
        this.friendlyInstancedMesh = null;
        this.enemyIconMaterial = null;
        this.enemyInstancedMesh = null;
        this.friendlyBuildingMaterial = null;
        this.friendlyBuildingMesh = null;
        this.enemyBuildingMaterial = null;
        this.enemyBuildingMesh = null;
        this.goldVeinMaterial = null;
        this.goldVeinMesh = null;
        this.tempMatrix = null;
        
        this.isDragging = false;
        this.minimapWorldSize = 0;
        this.initialized = false;
        this.MINIMAP_ROTATION = -45;
    }

    onGameStarted() {
        // Get the container and its actual width
        this.container = document.getElementById('miniMapContainer');
        const rect = this.container.getBoundingClientRect();
       // this.MINIMAP_SIZE = rect.width; // use actual displayed size

        // Use that size for both the canvas and render target
        this.minimapWorldSize = this.game.gameManager.call('getWorldExtendedSize');
        
        this.createMinimapCamera();
        this.addTerrainBackground(); 
        this.createIconMaterials();
        this.createMinimapUI();
        this.setupEventListeners();
        this.initialized = true;
    }


    createMinimapCamera() {
        const halfSize = this.minimapWorldSize / 2;
        
        this.minimapCamera = new THREE.OrthographicCamera(
            -halfSize, halfSize,
            halfSize, -halfSize,
            0.1, 1000
        );
        this.minimapCamera.position.set(0, 500, 0);
        this.minimapCamera.lookAt(0, 0, 0);
        
        this.minimapScene = new THREE.Scene();
        
        this.minimapRenderTarget = new THREE.WebGLRenderTarget(
            this.MINIMAP_SIZE,
            this.MINIMAP_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );
        
        this.addFogBackground();
    }

    addFogBackground() {
        const fogQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),
            new THREE.ShaderMaterial({
                uniforms: {
                    explorationTexture: { value: null },
                    visibilityTexture: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D explorationTexture;
                    uniform sampler2D visibilityTexture;
                    varying vec2 vUv;
                    
                    void main() {
                        float explored = texture2D(explorationTexture, vUv).r;
                        float visible = texture2D(visibilityTexture, vUv).r;
                        
                        vec3 color;
                        float alpha;
                        if (visible > 0.0) {
                            // Fully visible - make it transparent so terrain shows through
                            color = vec3(0.0);
                            alpha = 0.0;
                        } else if (explored > 0.0) {
                            // Explored but not visible - dark overlay
                            color = vec3(0.0);
                            alpha = 0.6;
                        } else {
                            // Unexplored - black
                            color = vec3(0.0);
                            alpha = 1.0;
                        }
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                depthTest: false
            })
        );
        fogQuad.rotation.x = -Math.PI / 2;
        fogQuad.position.y = -1;
        fogQuad.renderOrder = 100;
        
        this.minimapScene.add(fogQuad);
        this.fogQuad = fogQuad;
    }

    createIconMaterials() {
        const gridSize = this.game.getCollections().configs.game.gridSize;
        // Unit icons - slightly bigger
        this.unitIconGeometry = new THREE.CircleGeometry(gridSize, 4);
        
        // Building icons - much bigger
        this.buildingIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);
        
        // Gold vein icons - medium size
        this.goldVeinIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);
        
        const MAX_UNITS = 1000;
        const MAX_BUILDINGS = 200;
        
        // Friendly units
        this.friendlyIconMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.friendlyInstancedMesh = new THREE.InstancedMesh(
            this.unitIconGeometry,
            this.friendlyIconMaterial,
            MAX_UNITS
        );
        this.friendlyInstancedMesh.renderOrder = 100;
        this.friendlyInstancedMesh.count = 0;
        this.minimapScene.add(this.friendlyInstancedMesh);
        
        // Enemy units
        this.enemyIconMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.enemyInstancedMesh = new THREE.InstancedMesh(
            this.unitIconGeometry,
            this.enemyIconMaterial,
            MAX_UNITS
        );
        this.enemyInstancedMesh.renderOrder = 100;
        this.enemyInstancedMesh.count = 0;
        this.minimapScene.add(this.enemyInstancedMesh);
        
        // Friendly buildings
        this.friendlyBuildingMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.friendlyBuildingMesh = new THREE.InstancedMesh(
            this.buildingIconGeometry,
            this.friendlyBuildingMaterial,
            MAX_BUILDINGS
        );
        this.friendlyBuildingMesh.renderOrder = 100;
        this.friendlyBuildingMesh.count = 0;
        this.minimapScene.add(this.friendlyBuildingMesh);
        
        // Enemy buildings
        this.enemyBuildingMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.enemyBuildingMesh = new THREE.InstancedMesh(
            this.buildingIconGeometry,
            this.enemyBuildingMaterial,
            MAX_BUILDINGS
        );
        this.enemyBuildingMesh.renderOrder = 100;
        this.enemyBuildingMesh.count = 0;
        this.minimapScene.add(this.enemyBuildingMesh);
        
        // Gold veins (yellow)
        this.goldVeinMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFD700,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.goldVeinMesh = new THREE.InstancedMesh(
            this.goldVeinIconGeometry,
            this.goldVeinMaterial,
            100
        );
        this.goldVeinMesh.renderOrder = 50;
        this.goldVeinMesh.count = 0;
        this.minimapScene.add(this.goldVeinMesh);
        
        this.tempMatrix = new THREE.Matrix4();
        this.rotationMatrix = new THREE.Matrix4();
        this.rotationMatrix.makeRotationX(-Math.PI / 2);
    }

    createMinimapUI() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.MINIMAP_SIZE;
        this.canvas.height = this.MINIMAP_SIZE;
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.display = 'block';
        this.ctx = this.canvas.getContext('2d');

        if (this.container) {
            this.container.appendChild(this.canvas);
        }

        // Update render target to match
        if (this.minimapRenderTarget) {
            this.minimapRenderTarget.setSize(this.MINIMAP_SIZE, this.MINIMAP_SIZE);
        }
    }


    setupEventListeners() {
        this.container.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.handleMinimapClick(e);
        });
        
        this.container.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                this.handleMinimapClick(e);
            }
        });
        
        this.container.addEventListener('mouseup', () => {
            this.isDragging = false;
        });
        
        this.container.addEventListener('mouseleave', () => {
            this.isDragging = false;
        });
    }

    handleMinimapClick(event) {
        const rect = this.canvas.getBoundingClientRect();
         const camera = this.game.camera;
     
        // Get click position relative to canvas center (in pixels)
        const clickX = event.clientX - rect.left - rect.width / 2;
        const clickY = event.clientY - rect.top - rect.height / 2;
        
        // Apply inverse rotation to compensate for CSS rotation
        const angle = -this.MINIMAP_ROTATION * Math.PI / 180;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        const rotatedX = clickX * cos - clickY * sin;
        const rotatedY = clickX * sin + clickY * cos;

        // Convert back to normalized coordinates (0..1)
        const nx = (rotatedX + rect.width / 2) / rect.width;
        const ny = (rotatedY + rect.height / 2) / rect.height;

        let worldSize = this.game.gameManager.call('getTerrainSize') * 2;
        // Map to world coordinates
        const half = worldSize * 0.5;
        const worldX = nx * worldSize - half;
        const worldZ = ny * worldSize - half;
        this.game.gameManager.call('cameraLookAt', worldX, worldZ);
    }

    update() {
        if(!this.initialized) return;
        this.updateFogTextures();
        this.updateUnitIcons();
        this.updateGoldVeinIcons();
        this.renderMinimap();
    }

    updateFogTextures() {
        if (!this.game.fogOfWarSystem || !this.fogQuad) return;

        this.fogQuad.material.uniforms.explorationTexture.value =
            this.game.gameManager.call('getExplorationTexture');
        this.fogQuad.material.uniforms.visibilityTexture.value =
            this.game.gameManager.call('getFogTexture');

        const groundTexture = this.game.gameManager.call('getGroundTexture');
        if (this.terrainQuad && groundTexture) {
            this.terrainQuad.material.map = groundTexture;
            this.terrainQuad.material.needsUpdate = true;
        }
    }

    updateUnitIcons() {
        const myTeam = this.game.state.mySide;
        if (!myTeam) return;
        
        const entities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.UNIT_TYPE
        ).filter(id => {
            const unitType = this.game.getComponent(id, this.componentTypes.UNIT_TYPE);
            return unitType.collection == "units" || unitType.collection == "buildings"
        });
        
        let friendlyUnitIndex = 0;
        let enemyUnitIndex = 0;
        let friendlyBuildingIndex = 0;
        let enemyBuildingIndex = 0;
        
        for (const entityId of entities) {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            if (!pos || !team || projectile) continue;
            
            const isMyUnit = team.team === myTeam;
            const visible = this.game.fogOfWarSystem?.isVisibleAt(pos.x, pos.z);
            
            if (!isMyUnit && !visible) continue;
            
            this.tempMatrix.makeTranslation(pos.x, 0, pos.z);
            this.tempMatrix.multiply(this.rotationMatrix);
            
            if (unitType.collection == 'buildings') {
                // It's a building
                if (isMyUnit) {
                    this.friendlyBuildingMesh.setMatrixAt(friendlyBuildingIndex, this.tempMatrix);
                    friendlyBuildingIndex++;
                } else {
                    this.enemyBuildingMesh.setMatrixAt(enemyBuildingIndex, this.tempMatrix);
                    enemyBuildingIndex++;
                }
            } else if(unitType.collection == 'units') {
                // It's a unit
                if (isMyUnit) {
                    this.friendlyInstancedMesh.setMatrixAt(friendlyUnitIndex, this.tempMatrix);
                    friendlyUnitIndex++;
                } else {
                    this.enemyInstancedMesh.setMatrixAt(enemyUnitIndex, this.tempMatrix);
                    enemyUnitIndex++;
                }
            }
        }
        
        this.friendlyInstancedMesh.count = friendlyUnitIndex;
        this.enemyInstancedMesh.count = enemyUnitIndex;
        this.friendlyBuildingMesh.count = friendlyBuildingIndex;
        this.enemyBuildingMesh.count = enemyBuildingIndex;
        
        if (friendlyUnitIndex > 0) {
            this.friendlyInstancedMesh.instanceMatrix.needsUpdate = true;
        }
        if (enemyUnitIndex > 0) {
            this.enemyInstancedMesh.instanceMatrix.needsUpdate = true;
        }
        if (friendlyBuildingIndex > 0) {
            this.friendlyBuildingMesh.instanceMatrix.needsUpdate = true;
        }
        if (enemyBuildingIndex > 0) {
            this.enemyBuildingMesh.instanceMatrix.needsUpdate = true;
        }
    }

    updateGoldVeinIcons() {
        const goldVeins = this.game.gameManager.call('getGoldVeinLocations');
        if (!goldVeins) {
            return;
        }
        let goldIndex = 0;
        
        for (const vein of goldVeins) {
            // Skip if claimed (has a gold mine built on it)
            if (vein.claimed) continue;
            
            const explored = this.game.fogOfWarSystem?.isExploredAt(vein.worldX, vein.worldZ);
            if (!explored) continue;
            
            this.tempMatrix.makeTranslation(vein.worldX, 0, vein.worldZ);
            this.tempMatrix.multiply(this.rotationMatrix);
            this.goldVeinMesh.setMatrixAt(goldIndex, this.tempMatrix);
            goldIndex++;
        }
        
        this.goldVeinMesh.count = goldIndex;
        
        if (goldIndex > 0) {
            this.goldVeinMesh.instanceMatrix.needsUpdate = true;
        }
    }

    updateCameraView() {
        if (!this.game.camera) return;
        
        const camera = this.game.camera;
        const cameraPos = camera.position;
        
        if (!cameraPos || isNaN(cameraPos.x) || isNaN(cameraPos.y) || isNaN(cameraPos.z)) {
            return;
        }
        
        const fov = camera.fov * (Math.PI / 180);
        const aspect = camera.aspect;
        const distance = camera.position.y;
        
        if (isNaN(fov) || isNaN(aspect) || isNaN(distance) || distance <= 0) {
            return;
        }
        
        const viewHeight = 2 * Math.tan(fov / 2) * distance;
        const viewWidth = viewHeight * aspect;
        
        const halfWidth = viewWidth / 2;
        const halfHeight = viewHeight / 2;
        
        const points = [
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight),
            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z - halfHeight),
            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z + halfHeight),
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z + halfHeight),
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight)
        ];
        
        if (this.cameraViewMesh) {
            this.cameraViewMesh.geometry.setFromPoints(points);
        } else {
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 3,
                depthWrite: false,
                depthTest: false
            });
            this.cameraViewMesh = new THREE.Line(geometry, material);
            this.cameraViewMesh.renderOrder = 1000;
            this.minimapScene.add(this.cameraViewMesh);
        }
    }

    addTerrainBackground() {
        // Get the ground texture from the world system
        const groundTexture = this.game.gameManager.call('getGroundTexture');
        if (!groundTexture) {
            console.warn('MiniMapSystem: Ground texture not available');
            return;
        }

        const terrainQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),
            new THREE.MeshBasicMaterial({
                map: groundTexture,
                depthWrite: false,
                depthTest: false
            })
        );
        terrainQuad.rotation.x = -Math.PI / 2;
        terrainQuad.position.y = -2; // Below fog
        terrainQuad.renderOrder = -2000;
        
        this.minimapScene.add(terrainQuad);
        this.terrainQuad = terrainQuad;
    }

    renderMinimap() {
        this.game.renderer.setRenderTarget(this.minimapRenderTarget);
        this.game.renderer.render(this.minimapScene, this.minimapCamera);
        
        const pixels = new Uint8Array(this.MINIMAP_SIZE * this.MINIMAP_SIZE * 4);
        this.game.renderer.readRenderTargetPixels(
            this.minimapRenderTarget,
            0, 0,
            this.MINIMAP_SIZE, this.MINIMAP_SIZE,
            pixels
        );
        
        this.game.renderer.setRenderTarget(null);
        
        const imageData = this.ctx.createImageData(this.MINIMAP_SIZE, this.MINIMAP_SIZE);
        
        for (let y = 0; y < this.MINIMAP_SIZE; y++) {
            for (let x = 0; x < this.MINIMAP_SIZE; x++) {
                const srcIdx = (y * this.MINIMAP_SIZE + x) * 4;
                const dstIdx = ((this.MINIMAP_SIZE - 1 - y) * this.MINIMAP_SIZE + x) * 4;
                
                imageData.data[dstIdx + 0] = pixels[srcIdx + 0];
                imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
                imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
                imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
        }
        
        this.ctx.putImageData(imageData, 0, 0);
        
        this.drawCameraOutline();
    }
        
    drawCameraOutline() {
        const camera = this.game.camera;
        if (!camera || !camera.isOrthographicCamera) return;

        // Frustum corners in NDC (CCW)
        const corners = [
            { x: -1, y: -1 }, // left-bottom
            { x:  1, y: -1 }, // right-bottom
            { x:  1, y:  1 }, // right-top
            { x: -1, y:  1 }, // left-top
        ];

        // Intersect each corner "ray" with the ground plane (y=0)
        const hits = [];
        for (const c of corners) {
            const hit = this.orthoCornerToGround(camera, c.x, c.y);
            if (!hit) return; // early out if any corner can't hit the ground
            hits.push(hit);
        }

        // Convert to canvas space
        const pts = hits.map(h => this.worldToCanvas(h.x, h.z));

        // Draw polygon overlay
        this.ctx.save();
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.restore();
    }

    orthoCornerToGround(camera, ndcX, ndcY) {
        // Point on near plane in world space
        const p = new THREE.Vector3(ndcX, ndcY, -1).unproject(camera);

        // Camera forward (world)
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

        const EPS = 1e-6;
        if (Math.abs(forward.y) < EPS) return null; // looking exactly parallel to ground

        // Move along forward so y -> 0
        const t = -p.y / forward.y;
        if (t <= 0) return null;                    // corner ray goes upward/behind
        return p.addScaledVector(forward, t);       // world-space hit (x, 0, z)
    }
    
    worldToCanvas(x, z) {
        const half = this.minimapWorldSize / 2;
        const nx = (x + half) / this.minimapWorldSize;
        const nz = (z + half) / this.minimapWorldSize;
        const cx = nx * this.MINIMAP_SIZE;
        const cy = nz * this.MINIMAP_SIZE;
        return { x: cx, y: cy };
    }
    
    dispose() {
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
        
        if (this.minimapRenderTarget) {
            this.minimapRenderTarget.dispose();
        }
        
        if (this.unitIconGeometry) {
            this.unitIconGeometry.dispose();
        }
        
        if (this.buildingIconGeometry) {
            this.buildingIconGeometry.dispose();
        }
        
        if (this.goldVeinIconGeometry) {
            this.goldVeinIconGeometry.dispose();
        }
        
        if (this.friendlyIconMaterial) {
            this.friendlyIconMaterial.dispose();
        }
        
        if (this.friendlyInstancedMesh) {
            this.minimapScene.remove(this.friendlyInstancedMesh);
            this.friendlyInstancedMesh.dispose();
        }
        
        if (this.enemyIconMaterial) {
            this.enemyIconMaterial.dispose();
        }
        
        if (this.enemyInstancedMesh) {
            this.minimapScene.remove(this.enemyInstancedMesh);
            this.enemyInstancedMesh.dispose();
        }
        
        if (this.friendlyBuildingMaterial) {
            this.friendlyBuildingMaterial.dispose();
        }
        
        if (this.friendlyBuildingMesh) {
            this.minimapScene.remove(this.friendlyBuildingMesh);
            this.friendlyBuildingMesh.dispose();
        }
        
        if (this.enemyBuildingMaterial) {
            this.enemyBuildingMaterial.dispose();
        }
        
        if (this.enemyBuildingMesh) {
            this.minimapScene.remove(this.enemyBuildingMesh);
            this.enemyBuildingMesh.dispose();
        }
        
        if (this.goldVeinMaterial) {
            this.goldVeinMaterial.dispose();
        }
        
        if (this.goldVeinMesh) {
            this.minimapScene.remove(this.goldVeinMesh);
            this.goldVeinMesh.dispose();
        }
        
        if (this.terrainQuad) {
            this.minimapScene.remove(this.terrainQuad);
            this.terrainQuad.geometry.dispose();
            this.terrainQuad.material.dispose();
        }
    }
};

// system: CameraControlSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CameraControlSystem'] = class CameraControlSystem extends engine.BaseSystem {
  constructor(game) {
    super(game);
    this.game.cameraControlSystem = this;

    this.SPEED = 900; // world units per second

    // Mouse state
    this.mouseX = -1;
    this.mouseY = -1;
    this.inside = false;

    // When mouse leaves the window, keep panning in these directions
    this.holdDirX = 0; // -1 left, +1 right
    this.holdDirZ = 0; // +1 up/forward, -1 down/backward

    this.vertical_threshold = 10;

    // Reusable vectors
    this.right = new THREE.Vector3();
    this.fwd   = new THREE.Vector3();
    this.delta = new THREE.Vector3();
  }

  init() {
    this.game.gameManager.register('cameraLookAt', this.lookAt.bind(this));

    this.onMove  = (e)=>this.onMouseMove(e);
    this.onEnter = ()=>{ this.inside = true; this.holdDirX = 0; this.holdDirZ = 0; };
    this.onLeave = ()=>this.onMouseLeave();
    this.onBlur  = ()=>{ this.inside = false; this.holdDirX = 0; this.holdDirZ = 0; };

    window.addEventListener('mousemove', this.onMove, { passive: true });
    window.addEventListener('mouseenter', this.onEnter);
    window.addEventListener('mouseleave', this.onLeave);
    window.addEventListener('blur',      this.onBlur);
    window.addEventListener('wheel', (e) => {
      let dy = e.deltaY;
      if(dy > 0){
        //scrolling down
        this.game.camera.zoom = this.game.camera.zoom * 0.9;
      } else {
        this.game.camera.zoom = this.game.camera.zoom * 1.1;
      }
      this.game.camera.zoom = Math.min(2, this.game.camera.zoom);
      this.game.camera.updateProjectionMatrix();
    });
  }

  dispose() {
    window.removeEventListener('mousemove', this.onMove);
    window.removeEventListener('mouseenter', this.onEnter);
    window.removeEventListener('mouseleave', this.onLeave);
    window.removeEventListener('blur',       this.onBlur);
  }

  onMouseMove(e) {
    this.mouseX = e.clientX;
    this.mouseY = e.clientY;
    this.inside = true;
  }

  onMouseLeave() {
    // Decide which edge we left from and â€œholdâ€ that pan direction
    const w = window.innerWidth  || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;

    // X hold
    if (this.mouseX <= 0)            this.holdDirX = -1;
    else if (this.mouseX >= w - 1)   this.holdDirX =  1;
    else                              this.holdDirX =  0;

    // Z hold (reversed per your request: top = +forward, bottom = -backward)
    if (this.mouseY <= this.vertical_threshold)            this.holdDirZ =  1;  // went off top -> forward
    else if (this.mouseY >= h - this.vertical_threshold)   this.holdDirZ = -1;  // went off bottom -> backward
    else                              this.holdDirZ =  0;

    this.inside = false;
  }

  clampCamera(camera, padding = 0) {
    const extendedSize = this.game.gameManager.call('getWorldExtendedSize');
    const half = extendedSize ? extendedSize * 0.5 : 1000;
    camera.position.x = Math.max(-half + padding, Math.min(half - padding, camera.position.x));
    camera.position.z = Math.max(-half + padding, Math.min(half - padding, camera.position.z));

    if (camera.userData?.lookAt instanceof THREE.Vector3) {
      camera.userData.lookAt.x = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.x));
      camera.userData.lookAt.z = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.z));
    }
  }

  updateGroundBasis(camera) {
    this.right.set(1,0,0).applyQuaternion(camera.quaternion);
    this.fwd.set(0,0,-1).applyQuaternion(camera.quaternion);
    this.right.y = 0; this.fwd.y = 0;
    if (this.right.lengthSq() > 0) this.right.normalize();
    if (this.fwd.lengthSq() > 0) this.fwd.normalize();
  }

  lookAt(worldX, worldZ){
    const pitch = 35.264 * Math.PI / 180;
    const yaw = 135 * Math.PI / 180;
    const distance = 10240;

    const cdx = Math.sin(yaw) * Math.cos(pitch);
    const cdz = Math.cos(yaw) * Math.cos(pitch);

    const cameraPosition = {
        x: worldX - cdx * distance,
        y: distance,
        z: worldZ - cdz * distance
    };

    const lookAt = { x: worldX, y: 0, z: worldZ };

    this.game.camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.game.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);
  }


  moveCamera() {
    const cam = this.game.camera;
    if (!cam) return;

    const dt = this.game.state.deltaTime || 1/60;

    const w = window.innerWidth  || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;

    // Compute directions from current mouse position (supports off-screen values too)
    let dirX = 0;
    let dirZ = 0;

    if (this.inside) {
      if (this.mouseX <= 0)           dirX = -1;
      else if (this.mouseX >= w - 1)  dirX =  1;

      // Z reversed: top edge -> +1 (forward), bottom -> -1 (backward)
      if (this.mouseY <= this.vertical_threshold)           dirZ =  1;
      else if (this.mouseY >= h - this.vertical_threshold)  dirZ = -1;

      // Clear holds while inside; weâ€™ll recompute every frame
      this.holdDirX = 0;
      this.holdDirZ = 0;
    } else {
      // Outside windowâ€”keep moving in the last known edge direction
      dirX = this.holdDirX;
      dirZ = this.holdDirZ;
    }

    if (dirX === 0 && dirZ === 0) return;

    this.updateGroundBasis(cam);

    this.delta.set(0,0,0)
      .addScaledVector(this.right, dirX * this.SPEED * dt)
      .addScaledVector(this.fwd,   dirZ * this.SPEED * dt);

    cam.position.add(this.delta);

    if (cam.userData?.lookAt instanceof THREE.Vector3) {
      cam.userData.lookAt.add(this.delta);
      cam.lookAt(cam.userData.lookAt);
    }

    this.clampCamera(cam, 0);
  }
}
;

// system: DamageNumberSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DamageNumberSystem'] = class DamageNumberSystem extends engine.BaseSystem {
    constructor(game) {
        super(game); 
        this.game.damageNumberSystem = this;
              
        // Damage number system
        this.damageNumbers = [];
        this.damageNumberPool = [];
        this.maxDamageNumbers = 20;
        
        // Text atlas/sprite approach for damage numbers
        this.damageTextMaterial = null;
        this.damageTextGeometry = null;
        this.damageNumberMesh = null;
        this.activeCharInstances = 0;
        this.VERTICAL_SPEED = 48;
        this.CHAR_SIZE = 12;
        this.effectOffset = { x: 0, y: 0, z: 0 };       
        // Performance tracking
        this.stats = {
            activeDamageNumbers: 0
        };
    }

    init() {
        this.game.gameManager.register('showDamageNumber', this.showDamageNumber.bind(this));
        this.initializeDamageNumberSystem();
    }
    
    initializeDamageNumberSystem() {
        // Create texture atlas with all characters we need
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Store canvas for reference
        this.damageTextCanvas = canvas;
        this.damageTextContext = ctx;
        
        // Character set for damage numbers
        this.damageChars = '0123456789,-+!CRITICAL';
        this.charWidth = 64; // Each character is 64px wide
        this.charHeight = 128;
        this.atlasColumns = Math.floor(canvas.width / this.charWidth);
        
        // Draw all characters into the atlas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = 'bold 100px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.damageChars.length; i++) {
            const char = this.damageChars[i];
            const x = (i % this.atlasColumns) * this.charWidth + this.charWidth / 2;
            const y = Math.floor(i / this.atlasColumns) * this.charHeight + this.charHeight / 2;
            
            // Draw outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 8;
            ctx.strokeText(char, x, y);
            
            // Draw character (white, we'll tint with vertex colors)
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText(char, x, y);
        }
        
        // Create texture
        this.damageTexture = new THREE.CanvasTexture(canvas);
        this.damageTexture.minFilter = THREE.LinearFilter;
        this.damageTexture.magFilter = THREE.LinearFilter;
        this.damageTexture.needsUpdate = true;
        
        // Create instanced geometry for quads
        // Each damage number can have up to 10 characters
        const maxCharsPerNumber = 10;
        const maxNumbers = 20; // Max simultaneous damage numbers
        const maxInstances = maxNumbers * maxCharsPerNumber;
        
        this.maxDamageNumbers = maxNumbers;
        this.maxDamageChars = maxCharsPerNumber;
        this.maxDamageInstances = maxInstances;
        
        const geometry = new THREE.PlaneGeometry(1, 1);
        this.damageTextGeometry = new THREE.InstancedBufferGeometry().copy(geometry);
        
        // Instance attributes
        const instancePositions = new Float32Array(maxInstances * 3);
        const instanceColors = new Float32Array(maxInstances * 3);
        const instanceOpacities = new Float32Array(maxInstances);
        const instanceScales = new Float32Array(maxInstances * 2);
        const instanceUVOffsets = new Float32Array(maxInstances * 4); // x, y, width, height
        
        this.damageTextGeometry.setAttribute('instancePosition', 
            new THREE.InstancedBufferAttribute(instancePositions, 3));
        this.damageTextGeometry.setAttribute('instanceColor', 
            new THREE.InstancedBufferAttribute(instanceColors, 3));
        this.damageTextGeometry.setAttribute('instanceOpacity', 
            new THREE.InstancedBufferAttribute(instanceOpacities, 1));
        this.damageTextGeometry.setAttribute('instanceScale', 
            new THREE.InstancedBufferAttribute(instanceScales, 2));
        this.damageTextGeometry.setAttribute('instanceUVOffset', 
            new THREE.InstancedBufferAttribute(instanceUVOffsets, 4));
        
        // Create material with custom shader
        this.damageTextMaterial = new THREE.ShaderMaterial({
            uniforms: {
                map: { value: this.damageTexture },
                cameraRight: { value: new THREE.Vector3(1, 0, 0) },
                cameraUp: { value: new THREE.Vector3(0, 1, 0) }
            },
            vertexShader: `
                attribute vec3 instancePosition;
                attribute vec3 instanceColor;
                attribute float instanceOpacity;
                attribute vec2 instanceScale;
                attribute vec4 instanceUVOffset;
                
                uniform vec3 cameraRight;
                uniform vec3 cameraUp;
                
                varying vec2 vUv;
                varying vec3 vColor;
                varying float vOpacity;
                
                void main() {
                    vUv = uv * instanceUVOffset.zw + instanceUVOffset.xy;
                    vColor = instanceColor;
                    vOpacity = instanceOpacity;
                    
                    // For orthographic camera, build billboard in view space
                    vec3 viewRight = normalize((modelViewMatrix * vec4(cameraRight, 0.0)).xyz);
                    vec3 viewUp = normalize((modelViewMatrix * vec4(cameraUp, 0.0)).xyz);
                    
                    vec4 viewPos = modelViewMatrix * vec4(instancePosition, 1.0);
                    viewPos.xyz += viewRight * position.x * instanceScale.x;
                    viewPos.xyz += viewUp * position.y * instanceScale.y;
                    
                    gl_Position = projectionMatrix * viewPos;
                }
            `,
            fragmentShader: `
                uniform sampler2D map;
                
                varying vec2 vUv;
                varying vec3 vColor;
                varying float vOpacity;
                
                void main() {
                    vec4 texColor = texture2D(map, vUv);
                    
                    // Use texture alpha and tint with color
                    gl_FragColor = vec4(vColor * texColor.rgb, texColor.a * vOpacity);
                    
                    if (gl_FragColor.a < 0.01) discard;
                }
            `,
            transparent: true,
            depthWrite: false,
            side: THREE.DoubleSide
        });
        
        this.damageNumberMesh = new THREE.Mesh(this.damageTextGeometry, this.damageTextMaterial);
        this.damageNumberMesh.frustumCulled = false;
        this.game.scene.add(this.damageNumberMesh);
        
        // Initially hide all instances
        this.damageTextGeometry.instanceCount = 0;
        
        // Track active character instances
        this.activeCharInstances = 0;
    }
    
    getCharUVOffset(char) {
        const index = this.damageChars.indexOf(char);
        if (index === -1) return { x: 0, y: 0, width: 0, height: 0 }; // Hide unknown chars
        
        const col = index % this.atlasColumns;
        const row = Math.floor(index / this.atlasColumns);
        
        const uWidth = this.charWidth / this.damageTextCanvas.width;
        const uHeight = this.charHeight / this.damageTextCanvas.height;
        
        return {
            x: col * uWidth,
            y: row * uHeight,
            width: uWidth,
            height: uHeight
        };
    }
    
    showDamageNumber(x, y, z, damage, type = 'physical') {
        console.log('showing damage number', x, y, z, damage, type);
        // Get or create damage number object
        let damageObj = this.damageNumberPool.pop();
        
        if (!damageObj) {
            damageObj = {
                charStartIndex: 0, // Index in instance buffer where this number's chars start
                charCount: 0,
                startTime: 0,
                duration: 1.5,
                startPos: new THREE.Vector3(),
                velocity: new THREE.Vector3(),
                color: new THREE.Color(),
                text: ''
            };
        }
        
        // Setup damage number
        damageObj.text = Math.abs(Math.round(damage)).toString();
        damageObj.charCount = damageObj.text.length;
        damageObj.startTime = this.game.state.now;
        damageObj.startPos.set(x + (Math.random() - 0.5) * 12, y + 10, z + (Math.random() - 0.5) * 12);
        damageObj.velocity.set(
            0, // Slight random horizontal drift
            this.VERTICAL_SPEED, // Initial upward velocity
            0
        );
        
        // Set color based on type
        switch (type) {
            case 'heal':
                damageObj.color.setHex(0x00ff88);
                break;
            case 'critical':
                damageObj.color.setHex(0xff0044);
                damageObj.velocity.y = 12;
                break;
            case 'poison':
                damageObj.color.setHex(0x8a2be2);
                break;
            case 'fire':
                damageObj.color.setHex(0xff4400);
                break;
            case 'cold':
                damageObj.color.setHex(0x00bfff);
                break;
            case 'lightning':
                damageObj.color.setHex(0xffff00);
                break;
            case 'divine':
                damageObj.color.setHex(0xffd700);
                break;
            default:
                damageObj.color.setHex(0xffffff);
        }
        
        // Allocate character instances
        if (this.activeCharInstances + damageObj.charCount > this.maxDamageInstances) {
            // Pool is full, can't show this damage number
            console.warn('Damage number pool full');
            this.damageNumberPool.push(damageObj);
            return;
        }
        
        damageObj.charStartIndex = this.activeCharInstances;
        this.activeCharInstances += damageObj.charCount;
        
        // Add to active list
        this.damageNumbers.push(damageObj);
        
        // Update instance count
        this.damageTextGeometry.instanceCount = this.activeCharInstances;
        
        // Initialize character instances
        this.updateDamageNumberInstance(damageObj, 0);
        
    }
    
    updateDamageNumberInstance(damageObj, progress) {
        if (!this.game.camera) return;
        
        // Calculate position with simple upward motion
        const pos = damageObj.startPos.clone();
        const elapsed = progress * damageObj.duration;
        pos.x += damageObj.velocity.x * elapsed;
        pos.y += damageObj.velocity.y * elapsed;
        pos.z += damageObj.velocity.z * elapsed;
        
        // Calculate opacity with fade out
        let opacity = 1.0;
        if (progress > 0.6) {
            opacity = 1.0 - ((progress - 0.6) / 0.4);
        }
        
        // No scaling - constant size
        const scale = 1.0;
        
        // Character size (world units)
        const charWidth = this.CHAR_SIZE * scale;
        const charHeight = this.CHAR_SIZE * scale * 2;
        
        // Update each character instance
        const positions = this.damageTextGeometry.attributes.instancePosition;
        const colors = this.damageTextGeometry.attributes.instanceColor;
        const opacities = this.damageTextGeometry.attributes.instanceOpacity;
        const scales = this.damageTextGeometry.attributes.instanceScale;
        const uvOffsets = this.damageTextGeometry.attributes.instanceUVOffset;
        
        // Get camera right vector for horizontal spacing
        const camera = this.game.camera;
        const cameraRight = new THREE.Vector3();
        const cameraUp = new THREE.Vector3();
        camera.matrixWorld.extractBasis(cameraRight, cameraUp, new THREE.Vector3());
        
        // Center the entire text string at pos
        const totalWidth = damageObj.charCount * charWidth;
        const startOffset = -totalWidth / 2 + charWidth / 2;
        
        for (let i = 0; i < damageObj.charCount; i++) {
            const instanceIdx = damageObj.charStartIndex + i;
            const char = damageObj.text[i];
            
            // Position each character along camera right vector, centered
            const offset = startOffset + i * charWidth;
            const charPos = pos.clone().add(cameraRight.clone().multiplyScalar(offset));
            positions.setXYZ(instanceIdx, charPos.x, charPos.y, charPos.z);
            
            // Color
            colors.setXYZ(instanceIdx, damageObj.color.r, damageObj.color.g, damageObj.color.b);
            
            // Opacity
            opacities.setX(instanceIdx, opacity);
            
            // Scale
            scales.setXY(instanceIdx, charWidth, charHeight);
            
            // UV offset for this character
            const uvOffset = this.getCharUVOffset(char);
            uvOffsets.setXYZW(instanceIdx, uvOffset.x, uvOffset.y, uvOffset.width, uvOffset.height);
        }
        
        positions.needsUpdate = true;
        colors.needsUpdate = true;
        opacities.needsUpdate = true;
        scales.needsUpdate = true;
        uvOffsets.needsUpdate = true;
    }
    
    updateDamageNumbers() {
        if (!this.game.state || this.damageNumbers.length === 0 || !this.game.camera) return;
        console.log('update');
        // Update camera vectors for billboarding
        const camera = this.game.camera;
        const cameraRight = new THREE.Vector3();
        const cameraUp = new THREE.Vector3();
        
        camera.matrixWorld.extractBasis(cameraRight, cameraUp, new THREE.Vector3());
        
        this.damageTextMaterial.uniforms.cameraRight.value.copy(cameraRight);
        this.damageTextMaterial.uniforms.cameraUp.value.copy(cameraUp);
        
        const currentTime = this.game.state.now;
        const toRemove = [];
        
        for (let i = 0; i < this.damageNumbers.length; i++) {
            const damageObj = this.damageNumbers[i];
            const elapsed = currentTime - damageObj.startTime;
            const progress = elapsed / damageObj.duration;
            
            if (progress >= 1) {
                toRemove.push(i);
                continue;
            }
            
            this.updateDamageNumberInstance(damageObj, progress);
        }
        
        // Remove completed damage numbers (backwards to maintain indices)
        for (let i = toRemove.length - 1; i >= 0; i--) {
            const idx = toRemove[i];
            const damageObj = this.damageNumbers[idx];
            
            // Free up character instances
            const charsToRemove = damageObj.charCount;
            const startIdx = damageObj.charStartIndex;
            
            // Shift all subsequent characters back in the buffer
            if (startIdx + charsToRemove < this.activeCharInstances) {
                const positions = this.damageTextGeometry.attributes.instancePosition;
                const colors = this.damageTextGeometry.attributes.instanceColor;
                const opacities = this.damageTextGeometry.attributes.instanceOpacity;
                const scales = this.damageTextGeometry.attributes.instanceScale;
                const uvOffsets = this.damageTextGeometry.attributes.instanceUVOffset;
                
                for (let j = startIdx + charsToRemove; j < this.activeCharInstances; j++) {
                    const sourceIdx = j;
                    const destIdx = j - charsToRemove;
                    
                    // Copy position
                    positions.setXYZ(destIdx, 
                        positions.getX(sourceIdx),
                        positions.getY(sourceIdx),
                        positions.getZ(sourceIdx)
                    );
                    
                    // Copy color
                    colors.setXYZ(destIdx,
                        colors.getX(sourceIdx),
                        colors.getY(sourceIdx),
                        colors.getZ(sourceIdx)
                    );
                    
                    // Copy opacity
                    opacities.setX(destIdx, opacities.getX(sourceIdx));
                    
                    // Copy scale
                    scales.setXY(destIdx,
                        scales.getX(sourceIdx),
                        scales.getY(sourceIdx)
                    );
                    
                    // Copy UV offset
                    uvOffsets.setXYZW(destIdx,
                        uvOffsets.getX(sourceIdx),
                        uvOffsets.getY(sourceIdx),
                        uvOffsets.getZ(sourceIdx),
                        uvOffsets.getW(sourceIdx)
                    );
                }
                
                positions.needsUpdate = true;
                colors.needsUpdate = true;
                opacities.needsUpdate = true;
                scales.needsUpdate = true;
                uvOffsets.needsUpdate = true;
            }
            
            this.activeCharInstances -= charsToRemove;
            
            // Update indices for remaining damage numbers
            for (let j = idx + 1; j < this.damageNumbers.length; j++) {
                this.damageNumbers[j].charStartIndex -= charsToRemove;
            }
            
            // Return to pool
            this.damageNumberPool.push(damageObj);
            
            // Remove from active array
            this.damageNumbers.splice(idx, 1);
        }
        
        // Update instance count
        this.damageTextGeometry.instanceCount = this.activeCharInstances;
        this.stats.activeDamageNumbers = this.damageNumbers.length;
    }
    
    // Keep all existing particle and screen effect methods unchanged
    getEffectConfig(effectType) {
        const configs = {
            victory: {
                count: 5,
                shape: 'star',
                color: 0x00ff00,
                colorRange: { start: 0x00ff00, end: 0xffff00 },
                lifetime: 1.5,
                velocity: { speed: 8, spread: 0.5, pattern: 'burst' },
                scale: 2,
                scaleVariation: 0.3,
                physics: { gravity: -0.5, drag: 0.99 },
                rotation: { enabled: true, speed: 5 },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            },
            defeat: {
                count: 8,
                shape: 'spark',
                color: 0xff0000,
                colorRange: { start: 0xff0000, end: 0x440000 },
                lifetime: 2,
                velocity: { speed: 6, spread: 0.8, pattern: 'burst' },
                scale: 1.5,
                scaleVariation: 0.4,
                physics: { gravity: 0.3, drag: 0.95 },
                rotation: { enabled: true, speed: 3 },
                visual: { fadeOut: true, scaleOverTime: false, blending: 'normal' }
            },
            levelup: {
                count: 12,
                shape: 'glow',
                color: 0xffaa00,
                colorRange: { start: 0xffaa00, end: 0xffffff },
                lifetime: 2.5,
                velocity: { speed: 4, spread: 0.3, pattern: 'fountain' },
                scale: 3,
                scaleVariation: 0.2,
                physics: { gravity: -0.2, drag: 0.98 },
                rotation: { enabled: false },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            }
        };
        
        return configs[effectType] || configs.victory;
    }
        
    getDamageColor(type) {
        switch (type) {
            case 'heal': return 0x00ff88;
            case 'critical': return 0xff0044;
            case 'poison': return 0x8a2be2;
            case 'fire': return 0xff4400;
            case 'cold': return 0x00bfff;
            case 'lightning': return 0xffff00;
            case 'divine': return 0xffd700;
            default: return 0xff4444;
        }
    }
        
    // Main update method called by game loop
    update() {
        this.updateDamageNumbers();
    }

    destroy() {
        // Clean up damage number system
        if (this.damageNumberMesh) {
            this.game.scene.remove(this.damageNumberMesh);
            this.damageTextGeometry.dispose();
            this.damageTextMaterial.dispose();
            this.damageTexture.dispose();
        }

    }

};

// system: VisionSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['VisionSystem'] = class VisionSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.visionSystem = this;

        // Default unit height for line of sight calculations
        this.DEFAULT_UNIT_HEIGHT = 25;
    }

    init() {
        this.game.gameManager.register('hasLineOfSight', this.hasLineOfSight.bind(this));
    }


    hasLineOfSight(from, to, unitType, viewerEntityId = null) {
        const dx = to.x - from.x;
        const dz = to.z - from.z;
        const distanceSq = dx * dx + dz * dz;
        const distance = Math.sqrt(distanceSq);
        const gridSize = this.game.getCollections().configs.game.gridSize;

        if (distance < gridSize*2) return true;

        const terrainSystem = this.game.terrainSystem;
        if (!terrainSystem) {
            console.warn('[hasLineOfSight] No terrain system found!');
            return true;
        }

        // Get discrete heightmap levels for from and to positions
        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);
        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);
        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);
        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);

        const fromHeightLevel = terrainSystem.getHeightLevelAtGridPosition(fromGridX, fromGridZ);
        const toHeightLevel = terrainSystem.getHeightLevelAtGridPosition(toGridX, toGridZ);

        // Cannot see up to tiles with higher heightmap values
        if (toHeightLevel > fromHeightLevel) {
            return false;
        }

        const fromTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(from.x, from.z);
        const toTerrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(to.x, to.z);

        // Use unit height from unitType, or fall back to default if not available
        const unitHeight = (unitType && unitType.height) ? unitType.height : this.DEFAULT_UNIT_HEIGHT;

        const fromEyeHeight = fromTerrainHeight + unitHeight;
        const toEyeHeight = toTerrainHeight + unitHeight;

        // Check for terrain blocking along the path (for same-level or downward vision)
        if (!this.checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel)) {
            return false;
        }
        
        let nearbyTrees = [];

        const midX = (from.x + to.x) / 2;
        const midZ = (from.z + to.z) / 2;
        const unitSize = (unitType && unitType.size) ? unitType.size : gridSize;
        nearbyTrees = this.game.gameManager.call('getNearbyUnits', { x: midX, y: 0, z: midZ} , distance / 2 + unitSize, viewerEntityId, 'worldObjects');


        if (nearbyTrees.length > 0) {
            const numSamples = Math.max(2, Math.ceil(distance / (gridSize * 0.5)));
            const stepX = dx / numSamples;
            const stepZ = dz / numSamples;
            
            for (let i = 1; i < numSamples; i++) {
                const t = i / numSamples;
                const sampleX = from.x + stepX * i;
                const sampleZ = from.z + stepZ * i;
                const rayHeight = fromEyeHeight + (toEyeHeight - fromEyeHeight) * t;
                
                for (const unit of nearbyTrees) {                    
                    const dx = sampleX - unit.x;
                    const dz = sampleZ - unit.z;
                    const distSq = dx * dx + dz * dz;
                    if(!unit.size) unit.size = gridSize;
                    if (distSq < unit.size * unit.size) {            
                        if (rayHeight < unit.y+unit.height) {
                            return false;
                        }
                    }
                }
            }
        }
        
        return true;
    }

    checkTileBasedLOS(from, to, fromEyeHeight, toTerrainHeight, fromHeightLevel) {
        const terrainSystem = this.game.terrainSystem;
        const gridSize = this.game.getCollections().configs.game.gridSize;

        const fromGridX = Math.floor((from.x + terrainSystem.terrainSize / 2) / gridSize);
        const fromGridZ = Math.floor((from.z + terrainSystem.terrainSize / 2) / gridSize);
        const toGridX = Math.floor((to.x + terrainSystem.terrainSize / 2) / gridSize);
        const toGridZ = Math.floor((to.z + terrainSystem.terrainSize / 2) / gridSize);

        const tiles = this.bresenhamLine(fromGridX, fromGridZ, toGridX, toGridZ);

        // Check intermediate tiles along the path
        for (let i = 1; i < tiles.length - 1; i++) {
            const tile = tiles[i];

            // Check if this intermediate tile has a higher heightmap level than the viewer
            const tileHeightLevel = terrainSystem.getHeightLevelAtGridPosition(tile.x, tile.z);
            if (tileHeightLevel > fromHeightLevel) {
                // Cannot see through a tile with higher elevation
                return false;
            }

            // Also check if the ray goes below the terrain at this point (for smooth terrain variations)
            const t = i / (tiles.length - 1);
            const worldX = tile.x * gridSize - terrainSystem.terrainSize / 2;
            const worldZ = tile.z * gridSize - terrainSystem.terrainSize / 2;
            const rayHeight = fromEyeHeight + (toTerrainHeight - fromEyeHeight) * t;
            const terrainHeight = terrainSystem.getTerrainHeightAtPositionSmooth(worldX, worldZ);

            if (rayHeight <= terrainHeight) {
                return false;
            }
        }

        return true;
    }

    bresenhamLine(x0, z0, x1, z1) {
        const tiles = [];
        
        const dx = Math.abs(x1 - x0);
        const dz = Math.abs(z1 - z0);
        const sx = x0 < x1 ? 1 : -1;
        const sz = z0 < z1 ? 1 : -1;
        let err = dx - dz;
        
        let x = x0;
        let z = z0;
        
        while (true) {
            tiles.push({ x, z });
            
            if (x === x1 && z === z1) break;
            
            const e2 = 2 * err;
            if (e2 > -dz) {
                err -= dz;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                z += sz;
            }
        }
        
        return tiles;
    }
};

// system: SupplySystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SupplySystem'] = class SupplySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.supplySystem = this;
        this.supplyElement = null;
    }

    init() {
        this.game.gameManager.register('getCurrentSupply', this.getCurrentSupply.bind(this));
        this.game.gameManager.register('getCurrentPopulation', this.getCurrentPopulation.bind(this));
        this.game.gameManager.register('canAffordSupply', this.canAffordSupply.bind(this));
        if(!this.game.isServer){
            this.supplyElement = document.getElementById('playerSupplies');
        }
        
    }

    updateSupplyDisplay() {
        if (!this.supplyElement) return;

        const team = this.game.state.mySide;
        if (!team) return;

        const currentPop = this.getCurrentPopulation(team);
        const currentSupply = this.getCurrentSupply(team);

        const isAtLimit = currentPop >= currentSupply;

        this.supplyElement.innerHTML = `${currentPop}/${currentSupply}`;
    }

    update() {
        if(this.game.isServer) return;
        if (this.game.state.phase === 'placement') {
            this.updateSupplyDisplay();
        }
    }

    getCurrentSupply(team) {
        const placements = this.game.gameManager.call('getPlacementsForSide', team);
        if (!placements) return 0;

        let totalSupply = 0;

        placements.forEach(placement => {     
            if(placement.unitType.supplyProvided){      
                totalSupply += placement.unitType.supplyProvided;            
            }
        });
        return totalSupply;
    }


    getCurrentPopulation(team) {
        const placements = this.game.gameManager.call('getPlacementsForSide', team);
        if (!placements) return 0;

        let totalPopulation = 0;

        placements.forEach(placement => {     
            if(placement.unitType.supplyCost){      
                totalPopulation += placement.unitType.supplyCost;            
            }
        });
        return totalPopulation;
    }

    canAffordSupply(team, unitType) {
        const currentPop = this.getCurrentPopulation(team);
        const currentSupply = this.getCurrentSupply(team);
        const supplyCost = unitType.supplyCost || 0;

        return (currentPop + supplyCost) <= currentSupply;
    }


};

// system: ServerBattlePhaseSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ServerBattlePhaseSystem'] = class ServerBattlePhaseSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.engine = this.game.app;    
        this.game.serverBattlePhaseSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;
        
        // Battle configuration
        this.maxBattleDuration = 30; // 90 seconds max
        this.minBattleDuration = 29;
        this.currentBattleTime = 0;
        // Battle state tracking
        this.battleResults = new Map();
        this.createdSquads = new Map();
        this.maxRounds = 5;
        this.baseGoldPerRound = 50;
    }

    init(params) {
        this.params = params || {};

        this.game.gameManager.register('startBattle', this.startBattle.bind(this));
        this.game.gameManager.register('spawnSquadFromPlacement', this.spawnSquadFromPlacement.bind(this));
    }

    startBattle(room) {
        try {

            this.game.state.isPaused = false;
            // Change room phase
            this.game.state.phase = 'battle';
            
            return { success: true };
            
        } catch (error) {
            console.error('Error in startBattle:', error);
            return { success: false, error: error.message };
        }
    }
    spawnSquadFromPlacement(playerId, placement) {
        try {
            const player = this.game.room.getPlayer(playerId);
            
            if (!this.game.unitCreationManager) {
                throw new Error('Unit creation manager not available');
            }
            
            // Get placements from placement phase manager
            const placementManager = this.game.placementSystem;
            if (!placementManager) {
                throw new Error('Placement phase manager not available');
            }
            let createdSquad = null;
      
            // Create squads using unit creation manager
            createdSquad = this.game.unitCreationManager.createSquadFromPlacement(
                placement,
                player.stats.side,
                playerId
            );

            if(!createdSquad){
                console.log("Failed to create squads");
                return { success: false };
            } else {
                // Store created squads for tracking
                let playerSquads = this.createdSquads.get(playerId);
                if(playerSquads){
                    playerSquads.push(createdSquad);
                } else {
                    playerSquads = [createdSquad];                    
                }
                this.createdSquads.set(playerId, playerSquads);
                return { success: true, squad: createdSquad };
            }
            
        } catch (error) {
            console.error('Error spawning units from placements:', error);
            return { success: false, error: `Failed to spawn units: ${error.message}` };
        }
    }

    // Called by game update loop to check for battle end
    update() {
        if (this.game.state?.phase !== 'battle') {
            return;
        }
        this.currentBattleTime += this.game.state.deltaTime;
        // Check for battle end conditions
        this.checkForBattleEnd();
    }

    checkForBattleEnd() {
        if (!this.game.componentManager) return;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const allBattleEntities = this.game.getEntitiesWith(
            ComponentTypes.TEAM,
            ComponentTypes.HEALTH,
            ComponentTypes.UNIT_TYPE
        );

        const aliveEntities = allBattleEntities.filter(entityId => {
            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
            const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
            return health && health.current > 0 && (!deathState || !deathState.isDying);
        });

        const teams = new Map();
        for (const entityId of aliveEntities) {
            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);
            if (team) {
                if (!teams.has(team.team)) {
                    teams.set(team.team, []);
                }
                teams.get(team.team).push(entityId);
            }
        }
        const aliveTeams = Array.from(teams.keys());
           
        const noCombatActive = this.checkNoCombatActive(aliveEntities);
        const allUnitsAtTarget = this.checkAllUnitsAtTargetPosition(aliveEntities);
        
        if( this.currentBattleTime < this.minBattleDuration){
            return;
        }
        if( this.currentBattleTime > this.maxBattleDuration){
            this.endBattle(this.game.room, null);
            return;
        }

        if (aliveEntities.length === 0) {
            console.log('no alive entities');
            this.endBattle(this.game.room, null);
            return;
        }
        
        if (aliveTeams.length === 1 && allUnitsAtTarget) {
            console.log('aliveTeams length is 1', aliveTeams, aliveEntities);
            console.log('all entities', allBattleEntities);
            console.log('aliveEntities', aliveEntities);
            this.endBattle(this.game.room, aliveTeams[0]);
            return;
        }
     
        if (noCombatActive && allUnitsAtTarget) {
            console.log('no combat active and all units at target');
            this.endBattle(this.game.room, null);
        }
    }

    checkNoCombatActive(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        
        for (const entityId of aliveEntities) {
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
         //   console.log(entityId, 'currentTarget', aiState.target);
            if (aiState && aiState.target) {
                return false;
            }
        }
        
        return true;
    }

    checkAllUnitsAtTargetPosition(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const TARGET_POSITION_THRESHOLD = 20;
        
        for (const entityId of aliveEntities) {
            const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            const targetPos = aiState?.targetPosition;

            if (!pos || !targetPos) {
                continue;
            }
            const distance = Math.sqrt(
                Math.pow(targetPos.x - pos.x, 2) + 
                Math.pow(targetPos.z - pos.z, 2)
            );
  
            if (distance > TARGET_POSITION_THRESHOLD) {
                return false;
            }
        }
        
        return true;
    }

    endBattle(room, winner = null, reason = 'unknown') {

        this.game.triggerEvent('onBattleEnd');        
        const playerStats = this.getPlayerStats(room);
        let battleResult = {
            winner: winner,
            reason: reason,
            round: this.game.state.round,
            survivingUnits: this.getSurvivingUnits(),
            playerStats: playerStats
        };
        
        const entitySync = this.serializeAllEntities();
        // Broadcast with updated health values
        this.serverNetworkManager.broadcastToRoom(room.id, 'BATTLE_END', {
            result: battleResult,
            gameState: room.getGameState(), // This will also have updated player health
            entitySync: entitySync
        });
        // Check for game end or continue to next round
        if (this.shouldEndGame(room)) {
            this.endGame(room);
        } else {
            this.game.state.round += 1;
            // Transition back to placement phase
            this.game.state.phase = 'placement';
            // Reset placement ready states
            for (const [playerId, player] of room.players) {
                player.placementReady = false;
            }
            this.game.triggerEvent('onPlacementPhaseStart');
        }
    }


    serializeAllEntities() {
        const serialized = {};
        
        for (const [entityId, componentTypes] of this.game.entities) {
            serialized[entityId] = {};
            
            for (const componentType of componentTypes) {
                const component = this.game.getComponent(entityId, componentType);
                if (component) {
                    serialized[entityId][componentType] = JSON.parse(JSON.stringify(component));
                }
            }
        }
        
        return serialized;
    }
    calculateRoundGold(round) {
        return this.baseGoldPerRound + (round * this.baseGoldPerRound);
    }
    getSurvivingUnits() {
        const survivors = {};
        
        // Count surviving units from created squads
        for (const [playerId, squads] of this.createdSquads) {
            let survivingCount = 0;
            let sideSurvivors = [];
            for (const squad of squads) {
                if (squad.squadUnits && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    
                    for (const entityId of squad.squadUnits) {
                        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                        const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                  
                        if (health && health.current > 0 && (!deathState || !deathState.isDying)) {
                            sideSurvivors.push(entityId);
                            survivingCount++;
                        }
                    }
                }
            }
            
            survivors[playerId] = sideSurvivors;
        }
        
        return survivors;
    }

    getPlayerStats(room) {
        const stats = {};
        for (const [playerId, player] of room.players) {
            stats[playerId] = {
                name: player.name,
                stats: player.stats
            };
        }
        return stats;
    }

    shouldEndGame(room) {
        const alivePlayers = Array.from(room.players.values()).filter(p => (p.stats.health) > 0);
        return alivePlayers.length <= 1;
    }

  
    addGoldForTeam(goldAmt, team){
        for (const [playerId, player] of room.players) {
            if(player.side == team){
                player.stats.gold = player.stats.gold + goldAmt;
                break;
            }
        }
    }

    endGame(room) {
        this.game.state.phase = 'ended';
        
        // Determine final winner
        let finalWinner = null;
        let maxHealth = -1;
        
        for (const [playerId, player] of room.players) {
            const health = player.stats.health;
            if (health > maxHealth) {
                maxHealth = health;
                finalWinner = playerId;
            }
        }
        
        const gameResult = {
            winner: finalWinner,
            finalStats: this.getPlayerStats(room),
            totalRounds: this.game.state.round
        };
        
        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_END', {
            result: gameResult,
            gameState: room.getGameState()
        });
        
        // Mark room as inactive after delay
        setTimeout(() => {
            room.isActive = false;
        }, 10000);
    }

    onBattleEnd() {

        if (!this.game.componentManager) return;
        
        this.currentBattleTime = 0;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entitiesToDestroy = new Set();
        
        // Collect battle entities (but not players)
        [
            ComponentTypes.CORPSE
        ].forEach(componentType => {
            const entities = this.game.getEntitiesWith(componentType);
            entities.forEach(id => {
                entitiesToDestroy.add(id);                
            });
        });
        
        // Destroy entities
        entitiesToDestroy.forEach(entityId => {
            try {
                this.game.destroyEntity(entityId);
            } catch (error) {
                console.warn(`Error destroying entity ${entityId}:`, error);
            }
        });
  
        // Clear squad references
        this.createdSquads.clear();
    }

};

// system: ServerPlacementSystem
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ServerPlacementSystem'] = class ServerPlacementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);  
        this.game.placementSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;  
        this.playerPlacements = new Map();
        this.leftPlacements = [];
        this.rightPlacements = [];
        this.placementReadyStates = new Map();
        this.numPlayers = 2;
     }

    init(params) {
        this.params = params || {};
        this.game.gameManager.register('getPlacementsForSide', this.getPlacementsForSide.bind(this));
        this.game.gameManager.register('getPlacementById', this.getPlacementById.bind(this));
        this.subscribeToEvents();
    }
    subscribeToEvents() {
        if (!this.game.serverEventManager) {
            console.error('No event manager found on engine');
            return;
        }

        // Subscribe to room management events
        this.game.serverEventManager.subscribe('GET_STARTING_STATE', this.handleGetStartingState.bind(this));
        this.game.serverEventManager.subscribe('SUBMIT_PLACEMENT', this.handleSubmitPlacement.bind(this));
        this.game.serverEventManager.subscribe('PURCHASE_UPGRADE', this.handlePurchaseUpgrade.bind(this));
        this.game.serverEventManager.subscribe('READY_FOR_BATTLE', this.handleReadyForBattle.bind(this));
        this.game.serverEventManager.subscribe('LEVEL_SQUAD', this.handleLevelSquad.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGET', this.handleSetSquadTarget.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGETS', this.handleSetSquadTargets.bind(this));
    
    }

    getPlacementById(placementId) {
        // Search in player placements first
        const leftPlacements = this.leftPlacements.find(placement => placement.placementId === placementId);
        if (leftPlacements) {
            return leftPlacements;
        }
        
        // Search in opponent placements
        const rightPlacements = this.rightPlacements.find(placement => placement.placementId === placementId);
        if (rightPlacements) {
            return rightPlacements;
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlayerIdByPlacementId(placementId) {
        // Iterate through all players and their placements
        for (const [playerId, placements] of this.playerPlacements) {
            // Check if any placement in this player's placements matches the placementId
            const foundPlacement = placements.find(placement => placement.placementId === placementId);
            if (foundPlacement) {
                return playerId;
            }
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlacementsForSide(side){
        if(side == 'left'){
            return this.leftPlacements;
        } else {
            return this.rightPlacements;
        }
    }

    handleGetStartingState(eventData) {
        try {
            const { playerId, data } = eventData;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            if(player){
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', this.getStartingState(player));
            }
            
        } catch (error) {
            console.error('Error getting starting state:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'GOT_STARTING_STATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data,
                success: false
            });
        }
    }

    async handleLevelSquad(eventData){
        const { playerId, data } = eventData;
        const { placementId, specializationId } = data;
        let playerGold = 0;
        if(playerId){
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);         
            if(roomId){
                const room = this.engine.getRoom(roomId);
                if(room){
                    const player = room.players.get(playerId);                    
                    playerGold = player.stats.gold;
                    console.log('got player gold', playerGold);
            
                    if (!this.game.gameManager.call('canAffordLevelUp', placementId, playerGold)) {
                        console.log("not enough gold to level up");
                        this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                            playerId: playerId,
                            error: "gold_low_error",
                            success: false
                        });
                        return false;
                    }
                    const success1 = specializationId ? this.game.gameManager.call('applySpecialization', placementId, specializationId, playerId) : true;

                    await this.game.gameManager.call('levelUpSquad', placementId, null, playerId, (success) => {
                        console.log('success?: ', success1, success);
                        if(success1 && success){
                            const levelUpCost = this.game.gameManager.call('getLevelUpCost', placementId);        
                            
                            player.stats.gold -= levelUpCost;
                            console.log('leveled, new gold amt:', player.stats.gold);
                            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                                playerId: playerId,
                                currentGold: player.stats.gold,
                                success: true
                            });
                        }
                    });
           
                }
            }
        } 
    }

    handleSubmitPlacement(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placement, ready } = data;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', this.submitPlayerPlacement(playerId, player, placement, true));
            
        } catch (error) {
            console.error('Error submitting placements:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'READY_FOR_BATTLE_UPDATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handlePurchaseUpgrade(eventData) {
        try {
            const { playerId, data } = eventData;
            
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', this.purchaseUpgrade(playerId, player, data.data, true));
            
        } catch (error) {
            console.error('Error purchasing upgrades:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'PURCHASED_UPGRADE', { 
                error: 'Server error while purchasing upgrades',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handleSetSquadTarget(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementId, targetPosition, meta } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            // Validate placement belongs to player            
            const placement = this.getPlacementById(placementId);
            
            if (!placement) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Placement not found'
                });
                return;
            }
            
            // Store target position in placement data
            placement.targetPosition = targetPosition;
            placement.squadUnits.forEach((unitId) => {
                   
                this.game.gameManager.call('clearCommands', unitId);
                this.game.gameManager.call('queueCommand', unitId, {
                    type: 'move',
                    controllerId: "UnitOrderSystem",
                    targetPosition: targetPosition,
                    target: null,
                    meta: meta,
                    priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                    interruptible: true
                }, true); // true = interrupt current command
            
            });
                    
               
            
            // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                success: true,
                placementId,
                targetPosition,
                meta
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGET_SET', {
                        placementId,
                        targetPosition,
                        meta
                    });
                }
            }
            
            console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGET_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }

    handleSetSquadTargets(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementIds, targetPositions, meta } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            for(let i = 0; i < placementIds.length; i++){
                let placementId = placementIds[i];
                let targetPosition = targetPositions[i];
                // Validate placement belongs to player            
                const placement = this.getPlacementById(placementId);
                
                if (!placement) {
                    console.log(placementId, 'not found');
                    this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                        error: 'Placement not found'
                    });
                    return;
                }
                
                // Store target position in placement data
                placement.targetPosition = targetPosition;
                placement.squadUnits.forEach((unitId) => {
                    this.game.gameManager.call('clearCommands', unitId);
                    this.game.gameManager.call('queueCommand', unitId, {
                        type: 'move',
                        controllerId: "UnitOrderSystem",
                        targetPosition: targetPosition,
                        target: null,
                        meta: meta,
                        priority: this.game.commandQueueSystem.PRIORITY.MOVE,
                        interruptible: true
                    }, true); // true = interrupt current command
                
                });
                        

                
                console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            }

                        // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                success: true
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGETS_SET', {
                        placementIds,
                        targetPositions,
                        meta
                    });
                }
            }
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGETS_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }


    handleReadyForBattle(eventData) {
        const { playerId, data } = eventData; 
        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
        if (!roomId) { 
            this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { 
                error: 'Room not found'
            });
            return;
        }
        const room = this.engine.getRoom(roomId);
          
        const player = room.getPlayer(playerId);
        // Update ready state
        player.ready = true;
        this.placementReadyStates.set(playerId, true);
        
        this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { success: true });
            
        // Check if all players are ready and start battle if so
        if (this.areAllPlayersReady() && this.game.state.phase === 'placement') {

            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: true
            });
            this.placementReadyStates.clear();
            // Small delay to ensure clients receive the ready update

            this.game.resetCurrentTime();
            this.applyTargetPositions();
            this.game.desyncDebugger.enabled = true;
            this.game.desyncDebugger.displaySync(true);
            this.resetAI();
            this.game.gameManager.call('startBattle', room);
        } else {
            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: false
            });
        }

    }
    
    resetAI() {
        const componentTypes = this.game.componentManager.getComponentTypes();            
        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      
        AIEntities.forEach((entityId) => {
            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);
            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
            combat.lastAttack = 0;
            aiState.aiBehavior = {};
        });
    }

    applyTargetPositions() {
     //   console.log('APPLY TARGET POSITIONS');
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        for (const [playerId, placements] of this.playerPlacements) {
            placements.forEach((placement) => {     
                const targetPosition = placement.targetPosition;         
                placement.squadUnits.forEach(entityId => {
                    const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
                    const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                    if (aiState && position) {
                        
                        if(targetPosition){
                            const currentAIController = this.game.gameManager.call('getCurrentAIControllerId', entityId);

                            if(!currentAIController || currentAIController == "UnitOrderSystem"){
                                const dx = position.x - targetPosition.x;
                                const dz = position.z - targetPosition.z;
                                const distSq = dx * dx + dz * dz;
                                const placementGridSize = this.game.getCollections().configs.game.gridSize / 2;
                                const threshold = placementGridSize * 0.5;

                                if (distSq <= threshold * threshold) {
                                    this.game.gameManager.call('removeCurrentAIController', entityId);
                                    placement.targetPosition = null;
                                } else {
                                    let currentOrderAI = this.game.gameManager.call('getAIControllerData', entityId, "UnitOrderSystem");
                                    currentOrderAI.targetPosition = targetPosition;
                                    currentOrderAI.path = [];
                                    this.game.gameManager.call('setCurrentAIController', entityId, "UnitOrderSystem", currentOrderAI);
                                }
                            }
                        }
                    }
                });
            });
        }
    }

    areAllPlayersReady() {
        let states = [...this.placementReadyStates.values()]
        return states.length == this.numPlayers && states.every(ready => ready === true);
    }


    submitPlayerPlacement(playerId, player, placement) {
        // console.log(`=== SUBMIT PLACEMENT DEBUG ===`);
        // console.log(`Player ID: ${playerId}`);
        // console.log(`Room ID: ${this.game.room?.id || 'NO ROOM'}`);
        // console.log(`Game phase: ${this.game.state.phase}`);
        // console.log(`================================`);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }
        
        // Validate placements if provided
        if ( !this.validatePlacement(placement, player)) {
            return { success: false, error: 'Invalid placement' };
        }


        // Deduct gold only for new units
        if (placement.unitType?.value > 0 && !placement.isStartingState) {
            player.stats.gold -= placement.unitType?.value;
        }            
        
        
        // Store placements
        let playerPlacements = this.playerPlacements.get(playerId);
        if(playerPlacements){
            playerPlacements.push(placement);
        } else {
            playerPlacements = [placement];
        }
        this.playerPlacements.set(playerId, playerPlacements);

        if(player.stats.side == 'left'){
            this.leftPlacements = this.playerPlacements.get(playerId);
        } else {
            this.rightPlacements = this.playerPlacements.get(playerId);
        }

        const result = this.game.gameManager.call('spawnSquadFromPlacement', playerId, placement);

        if(result.success && result.squad){
            let squadUnits = [];
            result.squad.squadUnits.forEach((entityId) => {
                squadUnits.push(entityId);
            })
            placement.squadUnits = squadUnits;
            if (placement.placementId) {
                this.game.gameManager.call('initializeSquad',
                    placement.placementId,
                    placement.unitType,
                    placement.squadUnits,
                    placement.team
                );
            }
            if (placement.peasantInfo && placement.collection === 'buildings') {
                const peasantInfo = placement.peasantInfo;
                const peasantId = peasantInfo.peasantId;
                const entityId = placement.squadUnits[0];

                // Get the build ability from the peasant's abilities

                const peasantAbilities = this.game.gameManager.call('getEntityAbilities', peasantId);
                if (peasantAbilities) {
                    //console.log("peasantAbilities", peasantAbilities);
                    const buildAbility = peasantAbilities.find(a => a.id === 'build');
                    if (buildAbility) {
                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);
                    }
                }
                
                
                // Clear the flag (only once for first building entity)
                this.game.state.peasantBuildingPlacement = null;
            }
        }


        return { success: result.success };
    }


    onBattleEnd() {        
        this.removeDeadSquadsAfterRound();
       
        this.game.desyncDebugger.displaySync(true);
        this.game.desyncDebugger.enabled = false;
    }
    
    removeDeadSquadsAfterRound() {
        if (!this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();

        this.playerPlacements.forEach((placements, playerId) => {
            const survivingPlacements = placements.filter(placement => {
                if (!placement.experience?.unitIds || placement.experience.unitIds.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                const aliveUnits = placement.experience.unitIds.filter(entityId => {
                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                    const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
                    if(buildingState) return true;
                    return health && health.current > 0 && (!deathState || !deathState.isDying);
                });

                if (aliveUnits.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                placement.experience.unitIds = aliveUnits;
                return true;
            });

            this.playerPlacements.set(playerId, survivingPlacements);
        });
    }

    cleanupDeadSquad(placement) {
        if (placement.placementId) {
            this.game.gameManager.call('releaseGridCells', placement.placementId);
            this.game.gameManager.call('removeSquad', placement.placementId);
        }

       // console.log(`Squad eliminated: ${placement.unitType?.title || placement.placementId}`);
    }


    validatePlacement(placement, player) {
       
        if(placement.isStartingState) return true;
        // Calculate cost of only NEW units
        const newUnitCost =  placement.unitType?.value;
        
        
        if (newUnitCost > player.stats.gold) {
            console.log(`Player ${player.id} insufficient gold: ${newUnitCost} > ${player.stats.gold}`);
            return false;
        }
        if (this.game.gameManager.has('canAffordSupply') && !this.game.gameManager.call('canAffordSupply', player.stats.side, placement.unitType)) {
            console.log(`Player ${player.id} insufficient supply for unit: ${placement.unitType.id}`);
            return false;
        }
        if (!placement.gridPosition || !placement.unitType) {
            console.log(`Player ${player.id} invalid placement data:`, placement);
            return false;
        }
        
        // Validate side placement - no mirroring, direct side enforcement
        const squadData = this.game.squadManager.getSquadData(placement.unitType);
        const cells = this.game.squadManager.getSquadCells(placement.gridPosition, squadData);
        if(!this.game.gameManager.call('isValidGridPlacement', cells, player.stats.side)){
            console.log('Invalid Placement', placement);
            for (const cell of cells) {
                const key = `${cell.x},${cell.z}`;
                const cellState = this.game.gridSystem.state.get(key);
                if (cellState && cellState.occupied) {
                    console.log('occupied:', cell, cellState);
                }
            }

            return false;
        }
    
        
        return true;
    }
    clearAllPlacements(){

        this.playerPlacements.keys().forEach((playerId) => {
            this.clearPlayerPlacements(playerId);
        });

        this.playerPlacements = new Map();
        this.leftPlacements = new Map();
        this.rightPlacements = new Map();
        this.placementReadyStates = new Map();  
    }
    clearPlayerPlacements(playerId) {
        try {
            // Get player's placements
            const placements = this.playerPlacements.get(playerId) || [];
            
            // Remove entities created by this player's placements
            placements.forEach(placement => {
                if (placement.squadUnits) {
                    placement.squadUnits.forEach(entityId => {
                        try {
                            if (this.game.destroyEntity) {
                                this.game.destroyEntity(entityId);
                            }
                        } catch (error) {
                            console.warn(`Error destroying entity ${entityId}:`, error);
                        }
                    });
                }

                // Free grid cells
                if (placement.placementId) {
                    this.game.gameManager.call('releaseGridCells', placement.placementId);
                }
            });
            
            // Clear from maps
            this.playerPlacements.delete(playerId);
            
            // Clear from undo stack if it's this player
            if (this.undoStack) {
                this.undoStack = this.undoStack.filter(undo => undo.playerId !== playerId);
            }
            
            console.log(`Cleared placements for player ${playerId}`);
            
        } catch (error) {
            console.error(`Error clearing placements for player ${playerId}:`, error);
        }
    }

    saveBuilding(entityId, team, gridPosition, unitType) {
        console.log(`=== Purchase Building DEBUG ===`);     
        console.log(`Data received:`, entityId, team, unitType);

        if (unitType.id === 'goldMine') {
            // Convert footprint (terrain grid units) to placement grid cells
            const footprintWidth = unitType.footprintWidth || unitType.placementGridWidth || 2;
            const footprintHeight = unitType.footprintHeight || unitType.placementGridHeight || 2;
            const gridWidth = footprintWidth * 2;
            const gridHeight = footprintHeight * 2;

            const result = this.game.gameManager.call('buildGoldMine', entityId, team, gridPosition, gridWidth, gridHeight);
            if (!result.success) {
                return result;
            }
        }            
        console.log(`SUCCESS`);
        console.log(`================================`);
        return { success: true };
    }

    purchaseUpgrade(playerId, player, data) {
        console.log(`=== Purchase Upgrade DEBUG ===`);       
        console.log(`Data received:`, data);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }

        const upgrade = this.game.getCollections().upgrades[data.upgradeId];
        if(upgrade?.value <= player.stats.gold){
            player.stats.gold -= upgrade.value;
            if(!this.game.state.teams){
                this.game.state.teams = {};
            }
            if(!this.game.state.teams[player.stats.side]) {
                this.game.state.teams[player.stats.side] = {};
            } 
            if(!this.game.state.teams[player.stats.side].effects) {
                this.game.state.teams[player.stats.side].effects = {};
            }
            upgrade.effects.forEach((effectId) => {
                const effect = this.game.getCollections().effects[effectId];
                this.game.state.teams[player.stats.side].effects[effectId] = effect;
            })
            
            console.log(`SUCCESS`);
            console.log(`================================`);
            return { success: true };
        }

        console.log(`ERROR`);    
        console.log(`================================`);
        
        return { success: false, error: "Not enough gold." };
    }

    getStartingPositionFromLevel(side) {
        // Try to get level data from game collections
        const level = this.game.getCollections().levels[this.game.state.level];
        if (!level || !level.tileMap || !level.tileMap.startingLocations) {
            return null;
        }
        
        // Find starting location for this side
        const startingLoc = level.tileMap.startingLocations.find(loc => loc.side === side);
        if (startingLoc && startingLoc.gridPosition) {
            return { x: startingLoc.gridPosition.x, z: startingLoc.gridPosition.z };
        }

        return null;
    }

    getStartingState(player){
        // Get starting position from level data if available
        let startPosition = this.getStartingPositionFromLevel(player.stats.side);

        // Find nearest unclaimed gold vein
        let nearestGoldVeinLocation = null;
        let minDistance = Infinity;

        const goldVeinLocations = this.game.gameManager.call('getGoldVeinLocations');
        if (goldVeinLocations) {
            goldVeinLocations.forEach(vein => {
                // Skip if already claimed
                if (vein.claimed) return;
                
                // Calculate distance from start position to vein
                const dx = vein.gridPos.x - startPosition.x;
                const dz = vein.gridPos.z - startPosition.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestGoldVeinLocation = vein.gridPos;
                }
            });
        }
        
        
        // Calculate peasant positions on the same side as gold mine
        // TownHall is 2x2, so it occupies a 2x2 area centered at startPosition
        const dx = nearestGoldVeinLocation.x - startPosition.x;
        const dz = nearestGoldVeinLocation.z - startPosition.z;
        
        let peasantPositions = [];
        
        // Determine which side the gold mine is on and place peasants accordingly
        if (Math.abs(dx) > Math.abs(dz)) {
            // Gold mine is more to the east or west
            if (dx > 0) {
                // Gold mine is to the EAST, place peasants on east side
                // TownHall occupies x to x+1, so peasants start at x+2
                peasantPositions = [
                    { x: startPosition.x + 2, z: startPosition.z - 1 },
                    { x: startPosition.x + 2, z: startPosition.z },
                    { x: startPosition.x + 2, z: startPosition.z + 1 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the WEST, place peasants on west side
                // TownHall occupies x-1 to x, so peasants start at x-2
                peasantPositions = [
                    { x: startPosition.x - 2, z: startPosition.z - 1 },
                    { x: startPosition.x - 2, z: startPosition.z },
                    { x: startPosition.x - 2, z: startPosition.z + 1 },
                    { x: startPosition.x - 2, z: startPosition.z + 2 }
                ];
            }
        } else {
            // Gold mine is more to the north or south
            if (dz > 0) {
                // Gold mine is to the SOUTH, place peasants on south side
                // TownHall occupies z to z+1, so peasants start at z+2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z + 2 },
                    { x: startPosition.x, z: startPosition.z + 2 },
                    { x: startPosition.x + 1, z: startPosition.z + 2 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the NORTH, place peasants on north side
                // TownHall occupies z-1 to z, so peasants start at z-2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z - 2 },
                    { x: startPosition.x, z: startPosition.z - 2 },
                    { x: startPosition.x + 1, z: startPosition.z - 2 },
                    { x: startPosition.x + 2, z: startPosition.z - 2 }
                ];
            }
        }
        
        const startingUnits = [
            {
                type: "townHall",
                collection: "buildings",
                position: startPosition
            },
            {
                type: "goldMine",
                collection: "buildings",
                position: nearestGoldVeinLocation
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[0]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[1]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[2]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[3]
            }
        ];

        const pitch = 35.264 * Math.PI / 180;
        const yaw = 135 * Math.PI / 180;
        const distance = 10240;

        const cdx = Math.sin(yaw) * Math.cos(pitch);
        const cdz = Math.cos(yaw) * Math.cos(pitch);



        const worldPos = this.game.gameManager.call('convertGridToWorldPosition', startPosition.x, startPosition.z);

        const cameraPosition = {
            x: worldPos.x - cdx * distance,
            y: distance,
            z: worldPos.z - cdz * distance
        };

        const lookAt = {
            x: worldPos.x,
            y: 0, 
            z: worldPos.z
        };

        return {
            success: true,
            startingUnits,
            camera: {
                position: cameraPosition,
                lookAt
            }
        };
    }
}
;

// ========== Abilities ==========

// ability: BaseAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BaseAbility'] = class BaseAbility {
    constructor(game, config = {}) {
        this.game = game;
        this.id = config.id || 'unknown';
        this.name = config.name || 'Unknown Ability';
        this.description = config.description || '';
        this.cooldown = config.cooldown || 10.0;
        this.range = config.range || 100;
        this.manaCost = config.manaCost || 0;
        this.targetType = config.targetType || 'auto';
        this.animation = config.animation || 'cast';
        this.priority = config.priority || 5;
        this.castTime = config.castTime || 1.5;
        this.autoTrigger = config.autoTrigger || 'combat';
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.effects = this.defineEffects();
    }
    
    defineEffects() {
        return {
            cast: { type: 'magic', options: { count: 15, scaleMultiplier: 0.8, speedMultiplier: 0.6 } },
            impact: { type: 'magic', options: { count: 10, scaleMultiplier: 1.2 } }
        };
    }
    
    createVisualEffect(position, effectName = 'cast', customOptions = {}) {
        if (!this.game.effectsSystem) return;
        
        const effectDef = this.effects[effectName];
        if (effectDef) {
            const mergedOptions = { ...effectDef.options, ...customOptions, heightOffset: customOptions.heightOffset || 0 };
            this.game.effectsSystem.createParticleEffect(position.x, position.y + mergedOptions.heightOffset, position.z, effectDef.type, mergedOptions);
        } else {
            this.game.effectsSystem.createParticleEffect(position.x, position.y + customOptions.heightOffset || 0, position.z, 'magic', customOptions);
        }
    }
    
    logAbilityUsage(casterEntity, message = null, showScreenEffect = false) {
      
    }
    
    dealDamageWithEffects(sourceId, targetId, damage, element = 'physical', options = {}) {
        if (this.game.damageSystem) {
            const result = this.game.damageSystem.applyDamage(sourceId, targetId, damage, element, { isSpell: true, ...options });
            
            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (targetPos && this.game.effectsSystem) {
                const effectType = result.isCritical ? 'critical' : 'damage';
                this.game.effectsSystem.showDamageNumber(targetPos.x, targetPos.y + 15, targetPos.z, result.damage, effectType);
                this.createVisualEffect(targetPos, 'impact');
            }
            
            return result;
        }
        return null;
    }
    
    // FIXED: Entities already sorted from getEntitiesWith()
    getEnemiesInRange(casterEntity, range = null) {
        const effectiveRange = range || this.range;
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return [];
        
        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)
            .filter(entityId => {
                if (entityId === casterEntity) return false;
                
                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
                
                if (!pos || !team || !health || health.current <= 0) return false;
                if (team.team === casterTeam.team) return false;
                
                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));
                return distance <= effectiveRange;
            });
    }
    
    // FIXED: Entities already sorted from getEntitiesWith()
    getAlliesInRange(casterEntity, range = null) {
        const effectiveRange = range || this.range;
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return [];
        
        return this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.TEAM, this.componentTypes.HEALTH)
            .filter(entityId => {
                const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
                const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
                const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
                
                if (!pos || !team || !health || health.current <= 0) return false;
                if (team.team !== casterTeam.team) return false;
                
                const distance = Math.sqrt(Math.pow(pos.x - casterPos.x, 2) + Math.pow(pos.z - casterPos.z, 2));
                return distance <= effectiveRange;
            });
    }
    
    // FIXED: Entities already sorted, remove redundant sorting
    findBestClusterPosition(entities, minCluster = 2) {
        if (entities.length < minCluster) return null;
        
        let bestPos = null;
        let bestScore = 0;
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) return;
            
            let nearbyCount = 0;
            entities.forEach(otherId => {
                if (otherId === entityId) return;
                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
                if (!otherPos) return;
                
                const distance = Math.sqrt(Math.pow(pos.x - otherPos.x, 2) + Math.pow(pos.z - otherPos.z, 2));
                if (distance <= 80) nearbyCount++;
            });
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {
                bestScore = nearbyCount;
                bestPos = { x: pos.x, y: pos.y, z: pos.z };
            }
        });
        
        return bestPos;
    }
    onBattleEnd() {
    }
    canExecute(casterEntity) { return true; }
    execute(casterEntity, targetData = null) { console.log(`${this.name} executed by entity ${casterEntity}`); }
};

// ability: ArenaPresenceAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ArenaPresenceAbility'] = class ArenaPresenceAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'arena_presence',
            name: 'Arena Presence',
            description: 'Intimidate nearby enemies, reducing their damage and accuracy (does not stack)',
            cooldown: 10.0,
            range: 120,
            manaCost: 25,
            targetType: 'area',
            animation: 'cast',
            priority: 5,
            castTime: 1.2,
            ...params
        });
        
        this.intimidationDuration = 15.0;
        this.damageReduction = 0.25; // 25% damage reduction
        this.accuracyReduction = 0.2; // 20% accuracy reduction
        this.fearRadius = this.range;
        this.element = 'psychological';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    colorRange: { start: 0x8B0000, end: 0xFF4500 },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.0
                }
            },
            intimidation_aura: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x800000,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 0.6
                }
            },
            fear_effect: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            presence_wave: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x660000,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need enemies nearby to intimidate
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Gladiator's presence fills the arena with dread...`);
        
        // Schedule the intimidation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.unleashArenaPresence(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    unleashArenaPresence(casterEntity, targetEnemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create intimidation aura effect
        this.createVisualEffect(casterPos, 'intimidation_aura');
        
        // Create expanding presence wave
        this.createVisualEffect(casterPos, 'presence_wave');
        
        // Sort enemies deterministically for consistent processing
        const sortedEnemies = targetEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let intimidatedCount = 0;
        let refreshedCount = 0;
        
        // Apply intimidation to each enemy in deterministic order
        sortedEnemies.forEach((enemyId, index) => {
            const intimidationResult = this.applyIntimidation(casterEntity, enemyId);
            
            if (intimidationResult.success) {
                if (intimidationResult.wasRefreshed) {
                    refreshedCount++;
                } else {
                    intimidatedCount++;
                }
                
                // Schedule staggered fear effects for visual appeal
                this.game.schedulingSystem.scheduleAction(() => {
                    const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                    if (enemyPos) {
                        this.createVisualEffect(enemyPos, 'fear_effect');
                    }
                }, index * 0.1, enemyId);
            }
        });
        
        // Screen effects for dramatic presence
        if (this.game.effectsSystem && (intimidatedCount > 0 || refreshedCount > 0)) {
            this.game.effectsSystem.playScreenShake(0.4, 2);
            this.game.effectsSystem.playScreenFlash('#8B0000', 0.6);
        }
        
       
    }
    
    applyIntimidation(casterEntity, enemyId) {
        // Validate enemy still exists and is alive
        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
        const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
        
        if (!enemyHealth || enemyHealth.current <= 0 || !enemyPos) {
            return { success: false, reason: 'target_invalid' };
        }
        
        // Check if already intimidated - don't stack multiple intimidations
        const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.intimidationDuration;
        
        if (existingBuff && existingBuff.buffType === 'intimidated') {
            // Refresh duration instead of stacking
            existingBuff.endTime = endTime;
            existingBuff.appliedTime = currentTime;
            
         
            
            return { success: true, wasRefreshed: true };
        } else {
            // Apply new intimidation buff
            const Components = this.game.componentManager.getComponents();
            
            this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                Components.Buff(
                    'intimidated', 
                    { 
                        damageReduction: this.damageReduction,
                        accuracyReduction: this.accuracyReduction,
                        intimidatedBy: casterEntity,
                        fearLevel: 1
                    }, 
                    endTime,      // End time
                    false,        // Not stackable
                    1,            // Single stack
                    currentTime   // Applied time
                )
            );
            
       
            
            return { success: true, wasRefreshed: false };
        }
    }
    
    // Helper method to check intimidation effectiveness
    getIntimidationEffectiveness(casterEntity, enemyId) {
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
        
        if (!casterCombat || !enemyCombat || !casterHealth || !enemyHealth) {
            return 1.0; // Default effectiveness
        }
        
        // Calculate intimidation effectiveness based on relative power
        const casterPower = (casterCombat.damage || 1) * (casterHealth.current || 1);
        const enemyPower = (enemyCombat.damage || 1) * (enemyHealth.current || 1);
        
        const powerRatio = casterPower / Math.max(enemyPower, 1);
        
        // Effectiveness between 0.5 and 1.5 based on power difference
        return Math.max(0.5, Math.min(1.5, 0.7 + (powerRatio * 0.3)));
    }
    
    // Helper method to get current intimidation status
    getIntimidationStatus(enemyId) {
        const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
        
        if (!buff || buff.buffType !== 'intimidated') {
            return { isIntimidated: false };
        }
        
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const timeRemaining = Math.max(0, buff.endTime - currentTime);
        
        return {
            isIntimidated: true,
            timeRemaining: timeRemaining,
            damageReduction: buff.modifiers?.damageReduction || this.damageReduction,
            accuracyReduction: buff.modifiers?.accuracyReduction || this.accuracyReduction,
            intimidatedBy: buff.modifiers?.intimidatedBy
        };
    }
};

// ability: BloodlustAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BloodlustAbility'] = class BloodlustAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'bloodlust',
            name: 'Bloodlust',
            description: 'Heal when dealing damage and gain stacking damage bonuses',
            cooldown: 5.0,
            range: 0,
            manaCost: 0,
            targetType: 'self',
            animation: 'cast',
            priority: 7,
            castTime: 1.0,
            ...params
        });
        
        this.lifeStealAmount = 0.3; // 30% life steal
        this.damagePerKill = 5; // Damage bonus per kill
        this.maxStacks = 10; // Maximum kill stacks
        this.duration = 30.0; // 30 seconds duration
    }
    
    defineEffects() {
        return {
            cast: { 
                type: 'magic', 
                options: { 
                    count: 3, 
                    color: 0x880000, 
                    colorRange: { start: 0x880000, end: 0xDC143C },
                    scaleMultiplier: 1.4,
                    speedMultiplier: 1.2
                } 
            },
            bloodlust: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB22222,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if already has bloodlust active to prevent stacking
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        return !existingBuff || existingBuff.buffType !== 'bloodlust';
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Berserker enters a bloodthirsty frenzy!", true);
        
        // DESYNC SAFE: Use scheduling system for bloodlust activation
        this.game.schedulingSystem.scheduleAction(() => {
            this.activateBloodlust(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    activateBloodlust(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // Check if already has bloodlust to prevent double application
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'bloodlust') {
            // DESYNC SAFE: Refresh duration instead of stacking
            existingBuff.endTime = this.game.state.now + this.duration;
            existingBuff.appliedTime = this.game.state.now;
            
            // Visual refresh effect
            this.createVisualEffect(casterPos, 'bloodlust');
            return;
        }
        
        // Apply bloodlust buff
        const Components = this.game.componentManager.getComponents();
        this.game.addComponent(casterEntity, this.componentTypes.BUFF, 
            Components.Buff('bloodlust', { 
                lifeSteal: this.lifeStealAmount, 
                damagePerKill: this.damagePerKill, 
                maxStacks: this.maxStacks,
                currentStacks: 0 // Start with 0 kill stacks
            }, this.game.state.now + this.duration, true, 1, this.game.state.now));
        
        // Visual bloodlust effect
        this.createVisualEffect(casterPos, 'bloodlust');
        
        // Screen effect for dramatic activation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1.5);
            this.game.effectsSystem.playScreenFlash('#8B0000', 0.3);
        }
        
        // DESYNC SAFE: Schedule buff removal
        this.game.schedulingSystem.scheduleAction(() => {
            this.removeBloodlust(casterEntity);
        }, this.duration, casterEntity);
        
 
    }
    
    // DESYNC SAFE: Remove bloodlust buff
    removeBloodlust(casterEntity) {
        // Check if entity still exists and has the bloodlust buff
        if (this.game.hasComponent(casterEntity, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'bloodlust') {
                const stacksGained = buff.modifiers.currentStacks || 0;
                
                this.game.removeComponent(casterEntity, this.componentTypes.BUFF);
                
                // Visual effect when bloodlust expires
                const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
                if (casterPos) {
                    this.createVisualEffect(casterPos, 'bloodlust', { 
                        count: 5, 
                        scaleMultiplier: 0.8,
                        color: 0x696969 
                    });
                }
                
             
            }
        }
    }
    
    // Helper method to handle kill stacking (called by damage system when enemy dies)
    onEnemyKilled(killerId) {
        if (!this.game.hasComponent(killerId, this.componentTypes.BUFF)) return;
        
        const buff = this.game.getComponent(killerId, this.componentTypes.BUFF);
        if (!buff || buff.buffType !== 'bloodlust') return;
        
        // Increase kill stacks up to maximum
        const currentStacks = buff.modifiers.currentStacks || 0;
        if (currentStacks < this.maxStacks) {
            buff.modifiers.currentStacks = currentStacks + 1;
            
            // Visual effect for gaining a kill stack
            const killerPos = this.game.getComponent(killerId, this.componentTypes.POSITION);
            if (killerPos) {
                this.createVisualEffect(killerPos, 'bloodlust', { 
                    count: 3, 
                    scaleMultiplier: 1.2,
                    heightOffset: 10 
                });
            }
    
        }
    }
};

// ability: ChargeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ChargeAbility'] = class ChargeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'charge',
            name: 'Charge',
            description: 'Rush forward dealing damage and stunning enemies',
            cooldown: 5.0,
            range: 150,
            manaCost: 0,
            targetType: 'enemy',
            animation: 'attack',
            priority: 8,
            castTime: 0.5,
            ...params
        });
        
        this.chargeDamage = 55;
        this.chargeSpeed = 300;
        this.chargeDuration = 0.8; // How long the charge takes
        this.stunDuration = 2.0; // How long enemies are stunned
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xC0C0C0,
                    colorRange: { start: 0xC0C0C0, end: 0xFFFFFF },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            charge: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Don't charge if already charging
        const charging = this.game.getComponent(casterEntity, this.componentTypes.CHARGING);
        if (charging && charging.isCharging) return false;
        
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Select closest enemy deterministically
        const target = this.findClosestEnemy(casterEntity, enemies);
        if (!target) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Knight charges into battle!", true);
        
        // DESYNC SAFE: Use scheduling system for charge execution
        this.game.schedulingSystem.scheduleAction(() => {
            this.initiateCharge(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    initiateCharge(casterEntity, targetId) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        
        if (!pos || !targetPos || !velocity) return;
        
        // DESYNC SAFE: Calculate charge direction deterministically
        const dx = targetPos.x - pos.x;
        const dz = targetPos.z - pos.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance === 0) return; // Avoid division by zero
        
        // DESYNC SAFE: Add charging component for state tracking
        const Components = this.game.componentManager.getComponents();
        this.game.addComponent(casterEntity, this.componentTypes.CHARGING, 
            Components.Charging(targetId, this.chargeSpeed, this.chargeDamage, 
                this.game.state.now, 0, distance));
        
        // Set velocity for charge
        velocity.vx = (dx / distance) * this.chargeSpeed;
        velocity.vz = (dz / distance) * this.chargeSpeed;
        
        // Visual charge effect
        this.createVisualEffect(pos, 'charge');
        
        // Screen effect for dramatic charge
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1);
        }
        
        // DESYNC SAFE: Schedule charge completion
        this.game.schedulingSystem.scheduleAction(() => {
            this.completeCharge(casterEntity, targetId);
        }, this.chargeDuration, casterEntity);
    }
    
    completeCharge(casterEntity, targetId) {
        // Stop the charge by removing charging component and resetting velocity
        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {
            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);
        }
        
        // Stop movement
        const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        if (velocity) {
            velocity.vx = 0;
            velocity.vz = 0;
        }
        
        // Check if target still exists and is in range for impact
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        
        if (!casterPos || !targetPos || !targetHealth || targetHealth.current <= 0) return;
        
        // Check if we're close enough to hit the target
        const distance = Math.sqrt(
            Math.pow(targetPos.x - casterPos.x, 2) + 
            Math.pow(targetPos.z - casterPos.z, 2)
        );
        
        if (distance <= 50) { // Hit range
            // Visual impact effect
            this.createVisualEffect(targetPos, 'impact');
            
            // Deal damage
            this.dealDamageWithEffects(casterEntity, targetId, this.chargeDamage, 'physical', {
                isCharge: true,
                knockback: true
            });
            
            // DESYNC SAFE: Apply stun using buff system
            const Components = this.game.componentManager.getComponents();
            this.game.addComponent(targetId, this.componentTypes.BUFF, 
                Components.Buff('stunned', { 
                    movementDisabled: true, 
                    attackDisabled: true 
                }, this.game.state.now + this.stunDuration, false, 1, this.game.state.now));
            
            // DESYNC SAFE: Schedule stun removal
            this.game.schedulingSystem.scheduleAction(() => {
                this.removeStun(targetId);
            }, this.stunDuration, targetId);
            
            // Screen effect for impact
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenShake(0.4, 2);
            }
            
        
        }
    }
    
    // DESYNC SAFE: Remove stun effect
    removeStun(targetId) {
        // Check if target still exists and has the stun buff
        if (this.game.hasComponent(targetId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(targetId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'stunned') {
                this.game.removeComponent(targetId, this.componentTypes.BUFF);
                
                // Visual effect when stun expires
                const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
                if (targetPos) {
                    this.createVisualEffect(targetPos, 'cast', { 
                        count: 3, 
                        scaleMultiplier: 0.8,
                        color: 0x87CEEB 
                    });
                }
          
            }
        }
    }
    
    // Helper method to handle charge interruption (e.g., if caster dies mid-charge)
    cancelCharge(casterEntity) {
        if (this.game.hasComponent(casterEntity, this.componentTypes.CHARGING)) {
            this.game.removeComponent(casterEntity, this.componentTypes.CHARGING);
            
            // Stop movement
            const velocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
            if (velocity) {
                velocity.vx = 0;
                velocity.vz = 0;
            }
        }
    }
};

// ability: ConsecrationAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ConsecrationAbility'] = class ConsecrationAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'consecration',
            name: 'Consecration',
            description: 'Sanctify the ground, creating a zone that damages undead and heals the living',
            cooldown: 18.0,
            range: 0, // Centered on caster
            manaCost: 50,
            targetType: 'area',
            animation: 'cast',
            priority: 7,
            castTime: 2.0,
            ...params
        });
        
        this.consecrationRadius = 120;
        this.duration = 15.0; // 15 seconds
        this.tickInterval = 2.0; // Every 2 seconds
        this.tickDamage = 12; // Damage to undead per tick
        this.tickHeal = 8; // Healing to living per tick
    }
    
    defineEffects() {
        return {
            cast: { 
                type: 'magic', 
                options: { 
                    count: 3, 
                    color: 0xffffaa, 
                    colorRange: { start: 0xffffaa, end: 0xffffff },
                    scaleMultiplier: 1.6,
                    speedMultiplier: 1.2
                } 
            },
            consecration: { 
                type: 'heal', 
                options: { 
                    count: 3, 
                    color: 0xffffdd, 
                    scaleMultiplier: 0.6,
                    speedMultiplier: 1.0
                } 
            },
            purge: { 
                type: 'damage', 
                options: { 
                    count: 3, 
                    color: 0xffffff, 
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                } 
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if there are units nearby that would benefit from consecration
        const nearbyUnits = this.getUnitsInRange(casterEntity, this.consecrationRadius);
        return nearbyUnits.length >= 2; // At least 2 units to affect
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Templar consecrates the battlefield with holy power!", true);
        
        // DESYNC SAFE: Use scheduling system for consecration creation
        this.game.schedulingSystem.scheduleAction(() => {
            this.createConsecration(casterEntity, pos);
        }, this.castTime, casterEntity);
    }
    
    createConsecration(casterEntity, consecrationPos) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // Create consecrated ground entity
        const consecrationId = this.game.createEntity();
        const Components = this.game.componentManager.getComponents();
        
        this.game.addComponent(consecrationId, this.componentTypes.POSITION, 
            Components.Position(consecrationPos.x, consecrationPos.y, consecrationPos.z));
        
        this.game.addComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT, 
            Components.TemporaryEffect('consecrated_ground', {
                caster: casterEntity,
                radius: this.consecrationRadius,
                tickInterval: this.tickInterval,
                tickDamage: this.tickDamage,
                tickHeal: this.tickHeal
            }, this.game.state.now));
        
        this.game.addComponent(consecrationId, this.componentTypes.RENDERABLE, 
            Components.Renderable("effects", "consecration"));
        
        // DESYNC SAFE: Schedule all consecration ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex);
            }, tickDelay, consecrationId);
        }
        
        // DESYNC SAFE: Schedule consecration cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupConsecration(consecrationId);
        }, this.duration, consecrationId);
        
        // Screen effect for consecration creation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.5);
        }
    }
    
    // DESYNC SAFE: Execute a single consecration tick deterministically
    executeConsecrationTick(consecrationId, casterEntity, consecrationPos, tickIndex) {
        // Check if consecration entity still exists
        if (!this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {
            return;
        }
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterTeam) {
            // Caster died, end consecration early
            this.cleanupConsecration(consecrationId);
            return;
        }
        
        // DESYNC SAFE: Get all units in area deterministically
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        // Sort units for consistent processing order
        const sortedUnits = allUnits.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let undeadDamaged = 0;
        let livingHealed = 0;
        
        sortedUnits.forEach(unitId => {
            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);
            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);
            const team = this.game.getComponent(unitId, this.componentTypes.TEAM);
            const unitType = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);
            
            if (!unitPos || !health || !team || health.current <= 0) return;
            
            // Check if unit is in consecration radius
            const distance = Math.sqrt(
                Math.pow(unitPos.x - consecrationPos.x, 2) + 
                Math.pow(unitPos.z - consecrationPos.z, 2)
            );
            
            if (distance <= this.consecrationRadius) {
                // DESYNC SAFE: Determine if unit is undead/evil deterministically
                const isUndead = this.isUndeadUnit(unitType);
                
                if (isUndead) {
                    // Damage undead/evil units
                    this.dealDamageWithEffects(casterEntity, unitId, this.tickDamage, 'divine', {
                        isConsecration: true,
                        tickIndex: tickIndex
                    });
                    this.createVisualEffect(unitPos, 'purge', { heightOffset: 10 });
                    undeadDamaged++;
                } else if (team.team === casterTeam.team) {
                    // Heal living allies
                    if (health.current < health.max) {
                        const healAmount = Math.min(this.tickHeal, health.max - health.current);
                        health.current += healAmount;
                        
                        this.createVisualEffect(unitPos, 'consecration', { heightOffset: 10 });
                        
                        if (this.game.effectsSystem) {
                            this.game.effectsSystem.showDamageNumber(
                                unitPos.x, unitPos.y + 15, unitPos.z, 
                                healAmount, 'heal'
                            );
                        }
                        livingHealed++;
                    }
                }
            }
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(consecrationPos, 'consecration', { 
                count: 8, 
                scaleMultiplier: 2.0,
                heightOffset: 5 
            });
        }
        
   
    }
    
    // DESYNC SAFE: Determine if unit is undead deterministically
    isUndeadUnit(unitType) {
        if (!unitType) return false;
        
        // Check various undead/evil identifiers
        return (
            unitType.id === 'skeleton' ||
            unitType.id === 'zombie' ||
            unitType.id === 'lich' ||
            unitType.id === 'wraith' ||
            unitType.id === 'demon'
        );
    }
    
    // DESYNC SAFE: Get all units in range
    getUnitsInRange(casterEntity, radius) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return [];
        
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH
        );
        
        return allUnits.filter(unitId => {
            const unitPos = this.game.getComponent(unitId, this.componentTypes.POSITION);
            const health = this.game.getComponent(unitId, this.componentTypes.HEALTH);
            
            if (!unitPos || !health || health.current <= 0) return false;
            
            const distance = Math.sqrt(
                Math.pow(unitPos.x - casterPos.x, 2) + 
                Math.pow(unitPos.z - casterPos.z, 2)
            );
            
            return distance <= radius;
        }).sort((a, b) => String(a).localeCompare(String(b))); // Sort for determinism
    }
    
    // DESYNC SAFE: Clean up consecration
    cleanupConsecration(consecrationId) {
        if (this.game.hasComponent(consecrationId, this.componentTypes.TEMPORARY_EFFECT)) {
            // Visual effect for consecration ending
            const consecrationPos = this.game.getComponent(consecrationId, this.componentTypes.POSITION);
            if (consecrationPos) {
                this.createVisualEffect(consecrationPos, 'consecration', { 
                    count: 12, 
                    scaleMultiplier: 1.5,
                    color: 0xffd700 
                });
            }
            
            this.game.destroyEntity(consecrationId);
            
       
        }
    }
};

// ability: MultiShotAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MultiShotAbility'] = class MultishotAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'multi_shot',
            name: 'Multi Shot',
            description: 'Fire multiple arrows at different targets',
            cooldown: 7.0,
            range: 180,
            manaCost: 25,
            targetType: 'enemies',
            animation: 'attack',
            priority: 6,
            castTime: 1.0,
            ...params
        });
        
        this.maxTargets = 3;
        this.arrowDamage = 35;
        this.shotInterval = 0.2; // Time between each arrow
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    colorRange: { start: 0x8B4513, end: 0xDEB887 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            arrow_launch: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xCD853F,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 2.0
                }
            },
            volley: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xF4A460,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy to shoot at
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Select targets deterministically
        const targets = this.selectMultishotTargets(enemies);
        if (targets.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, 
            `Archer prepares to fire ${targets.length} arrows...`);
        
        // Schedule the multishot volley after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.fireMultishotVolley(casterEntity, targets);
        }, this.castTime, casterEntity);
    }
    
    fireMultishotVolley(casterEntity, targets) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create volley effect
        this.createVisualEffect(casterPos, 'volley');
        
        // Fire arrows at each target with staggered timing
        targets.forEach((targetId, shotIndex) => {
            const shotDelay = shotIndex * this.shotInterval;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.fireSingleArrow(casterEntity, targetId, shotIndex);
            }, shotDelay, casterEntity);
        });
        
        this.logAbilityUsage(casterEntity, 
            `Archer fires volley of ${targets.length} arrows!`);
    }
    
    fireSingleArrow(casterEntity, targetId, shotIndex) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        // Validate target still exists
        if (!casterPos || !targetPos) return;
        
        // Create arrow launch effect
        this.createVisualEffect(casterPos, 'arrow_launch');
        
        // Fire projectile if system is available
        if (this.game.projectileSystem) {
            const projectileData = {
                id: 'arrow',
                title: `Arrow ${shotIndex + 1}`,
                damage: this.arrowDamage,
                speed: 120,
                element: this.element,
                ballistic: true,
                onHit: (hitPos) => {
                    // Impact effect
                    this.createVisualEffect(hitPos, 'arrow_launch', { 
                        count: 3, 
                        scaleMultiplier: 0.8 
                    });
                },
                onTravel: (currentPos) => {
                    // Optional: trail effect during flight
                    if (shotIndex === 0) { // Only show trail on first arrow to avoid spam
                        this.createVisualEffect(currentPos, 'cast', { 
                            count: 1, 
                            scaleMultiplier: 0.5,
                            heightOffset: 0 
                        });
                    }
                }
            };
            
            this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);
        } else {
            // Fallback: direct damage if no projectile system
            this.dealDamageWithEffects(casterEntity, targetId, this.arrowDamage, this.element, {
                isArrow: true,
                isMultishot: true,
                shotIndex: shotIndex
            });
        }
        
    }
    
    // FIXED: Deterministic target selection
    selectMultishotTargets(enemies) {
        if (enemies.length === 0) return [];
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Take up to maxTargets, but prioritize by distance for tactical targeting
        const casterPos = this.game.getComponent(this.getCasterFromContext(), this.componentTypes.POSITION);
        if (!casterPos) {
            // Fallback: just take first N enemies if no caster position
            return sortedEnemies.slice(0, this.maxTargets);
        }
        
        // Calculate distances and sort by distance (closest first), then by ID for tie-breaking
        const enemiesWithDistance = sortedEnemies.map(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            let distance = Infinity;
            
            if (enemyPos) {
                distance = Math.sqrt(
                    Math.pow(enemyPos.x - casterPos.x, 2) + 
                    Math.pow(enemyPos.z - casterPos.z, 2)
                );
            }
            
            return { enemyId, distance };
        });
        
        // Sort by distance first, then by entity ID for deterministic tie-breaking
        enemiesWithDistance.sort((a, b) => {
            if (Math.abs(a.distance - b.distance) < 0.001) { // Nearly equal distances
                return String(a.enemyId).localeCompare(String(b.enemyId));
            }
            return a.distance - b.distance;
        });
        
        // Return up to maxTargets closest enemies
        return enemiesWithDistance
            .slice(0, this.maxTargets)
            .map(item => item.enemyId);
    }
    
    // Helper method to get caster in current context (if needed)
    getCasterFromContext() {
        // This is a fallback - in practice, the caster should be passed to selectMultishotTargets
        // For now, we'll use a simple approach
        return null; // Will trigger the simpler fallback logic
    }
};

// ability: BuildAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BuildAbility'] = class BuildAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, abilityData) {
        super(game, abilityData);
        this.id = 'build';
        this.name = 'Build';
        this.description = 'Construct buildings';
        this.isPassive = true;
        this.autocast = false;
        this.castTime = 0;
        this.cooldown = 0;
        this.priority = 0;
        this.enabled = true;
        this.meta = { preventEnemiesInRangeCheck: true };
        this.buildRange = 50;
    }

    canExecute(entityId) {
        if(!this.enabled){
            return false;
        }
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        let buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
        
        if (!buildingState) {
            return false;
        }

        return this.game.aiSystem.getCurrentAIControllerId(entityId) == ComponentTypes.BUILDING_STATE;
    }
    execute(entityId, targetData) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        
        if (!buildState || !pos || !vel) {
            return null;
        }

        this.updateBuilderState(entityId, buildState, pos, vel);
        return null;
    }

    updateBuilderState(entityId, buildState, pos, vel) {
        buildState.entityId = entityId;
        
        switch (buildState.state) {
            case 'idle':
                break;
            case 'walking_to_construction':
                this.walkToConstruction(buildState, pos, vel);
                break;
            case 'constructing':
                this.constructBuilding(buildState);
                break;
        }
    }

    assignToBuild(peasantEntityId, buildingEntityId, peasantInfo) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const aiState = this.game.getComponent(peasantEntityId, ComponentTypes.AI_STATE);
        const buildingPos = this.game.getComponent(buildingEntityId, ComponentTypes.POSITION);

        if (!buildingPos) return;

        const buildingPlacement = this.game.getComponent(buildingEntityId, ComponentTypes.PLACEMENT);
        const renderComponent = this.game.getComponent(buildingEntityId, ComponentTypes.RENDERABLE);
        renderComponent.spawnType = 'underConstruction';

        this.game.removeComponent(buildingEntityId, ComponentTypes.HEALTH);

        const peasantId = peasantInfo.peasantId;
        const buildTime = peasantInfo.buildTime;

        if (buildingPlacement) {
            buildingPlacement.isUnderConstruction = true;
            buildingPlacement.buildTime = buildTime;
            buildingPlacement.assignedBuilder = peasantId || null;
        }

        this.peasantId = peasantEntityId;
        this.game.addComponent(peasantEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('walking_to_construction', buildingEntityId, buildingPos, this.game.state.round));
        this.game.addComponent(buildingEntityId, ComponentTypes.BUILDING_STATE, Components.BuildingState('planned_for_construction', buildingEntityId, buildingPos, null));

        // Use command queue system to issue build command
        // This will properly interrupt current movement and clear the path
        if (this.game.commandQueueSystem) {
            this.game.gameManager.call('queueCommand', peasantEntityId, {
                type: 'build',
                controllerId: ComponentTypes.BUILDING_STATE,
                targetPosition: buildingPos,
                target: buildingEntityId,
                meta: this.meta,
                priority: this.game.commandQueueSystem.PRIORITY.BUILD,
                interruptible: true
            }, true); // true = interrupt current command
        } else {
            // Fallback to old method if command queue system not available
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(peasantEntityId, ComponentTypes.BUILDING_STATE);
            currentBuildingStateAI.targetPosition = buildingPos;
            currentBuildingStateAI.meta = this.meta;
            this.game.aiSystem.setCurrentAIController(peasantEntityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);
        }

        if (buildingPlacement) {
            buildingPlacement.assignedBuilder = peasantEntityId;
            buildingPlacement.isUnderConstruction = true;
        }
    }

    walkToConstruction(buildState, pos, vel) {
        
        if (!buildState.targetBuildingPosition || !buildState.targetBuildingEntityId) {
            buildState.state = 'idle';
            return;
        }

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildingPosition = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.POSITION);
        const buildingBuildState = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.BUILDING_STATE);
        
        if (!buildingPosition) {
            buildState.targetBuildingEntityId = null;
            buildState.targetBuildingPosition = null;
            buildState.state = 'idle';
            return;
        }

        const dx = buildState.targetBuildingPosition.x - pos.x;
        const dz = buildState.targetBuildingPosition.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < this.buildRange) {
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);
            currentBuildingStateAI.targetPosition = null;
            currentBuildingStateAI.state = 'idle';
            currentBuildingStateAI.meta = this.meta;
            this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);

            pos.x = buildState.targetBuildingPosition.x + this.buildRange;
            pos.z = buildState.targetBuildingPosition.z;
            vel.vx = 0;
            vel.vz = 0;

            // Make the peasant face the building
            const facing = this.game.getComponent(buildState.entityId, ComponentTypes.FACING);
            if (facing) {
                const dx = buildState.targetBuildingPosition.x - pos.x;
                const dz = buildState.targetBuildingPosition.z - pos.z;
                const angleToBuilding = Math.atan2(dz, dx);
                facing.angle = angleToBuilding;
            }

            buildState.state = 'constructing';
            buildState.constructionStartTime = this.game.state.round;
            buildingBuildState.state = 'under_construction';
            buildingBuildState.constructionStartTime = this.game.state.round;
        } else {     
            let currentBuildingStateAI = this.game.aiSystem.getAIControllerData(buildState.entityId, ComponentTypes.BUILDING_STATE);
            if(currentBuildingStateAI.targetPosition != buildState.targetBuildingPosition){
                currentBuildingStateAI.targetPosition = buildState.targetBuildingPosition;  
                currentBuildingStateAI.state = 'chasing';                          
                currentBuildingStateAI.meta = this.meta;
                this.game.aiSystem.setCurrentAIController(buildState.entityId, ComponentTypes.BUILDING_STATE, currentBuildingStateAI);   
            }
        }
    }

    constructBuilding(buildState) {

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);
        const unitType = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.UNIT_TYPE);
        this.game.addComponent(buildState.targetBuildingEntityId, ComponentTypes.HEALTH, Components.Health(unitType.hp));
        

        const elapsed = this.game.state.round - buildState.constructionStartTime;
        const buildTime = buildingPlacement.buildTime || 1;
        if (this.game.animationSystem) {
            const animState = this.game.animationSystem.entityAnimationStates.get(buildState.entityId);
            if(animState){
                const finished = this.game.animationSystem.isAnimationFinished(buildState.entityId, animState.currentClip);
                if(finished || animState.currentClip != 'attack'){
                    this.game.abilitySystem.startAbilityAnimation(buildState.entityId, { castTime: 1 });
                }
            }
        }

        if (elapsed >= buildTime) {            
            this.completeConstruction(buildState);
        }
    }

    completeConstruction(buildState) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const buildingPlacement = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.PLACEMENT);
        const aiState = this.game.getComponent(this.peasantId, ComponentTypes.AI_STATE);
        const renderComponent = this.game.getComponent(buildState.targetBuildingEntityId, ComponentTypes.RENDERABLE);
        renderComponent.spawnType = buildingPlacement.unitType.id;
        this.game.renderSystem?.removeInstance(buildState.targetBuildingEntityId);
        if (!buildingPlacement) {
            buildState.state = 'idle';
            return;
        }
        if(this.game.shopSystem){
            this.game.shopSystem.addBuilding(buildingPlacement.unitType.id, buildingPlacement.squadUnits[0]);
        }

        buildingPlacement.isUnderConstruction = false;
        buildingPlacement.assignedBuilder = null;

        if (this.game.animationSystem) {
            this.game.animationSystem.changeAnimation(buildState.targetBuildingEntityId, 'idle', 1.0, 0);
        }

        buildState.targetBuildingEntityId = null;
        buildState.targetBuildingPosition = null;
        buildState.state = 'idle';

        // Mark command as complete in command queue system
        if (this.game.commandQueueSystem) {
            this.game.gameManager.call('completeCurrentCommand', this.peasantId);
        } else {
            // Fallback to old method
            this.game.aiSystem.removeCurrentAIController(this.peasantId);
        }

        this.game.removeComponent(this.peasantId, ComponentTypes.BUILDING_STATE);
    }
    
    onPlacementPhaseStart(entityId) {
        if(this.canExecute(entityId)){
            this.execute(entityId);
        }
    }
    
    logAbilityUsage(entityId) {
    }
};

// ability: FreezingAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FreezingAuraAbility'] = class FreezingAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'freezing_aura',
            name: 'Freezing Aura',
            description: 'Emanate freezing cold',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            freezing: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));

        
        // Process allies - empower undead
        sortedAllies.forEach(allyId => {
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!unitType || !allyPos) return;
            
            // Check if this is an undead unit
            const distance = Math.sqrt(
                Math.pow(allyPos.x - casterPos.x, 2) + 
                Math.pow(allyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Check if already has empowerment buff
                const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                
                if (!existingBuff || existingBuff.buffType !== 'ice_armor') {
                    const Components = this.game.componentManager.getComponents();
                    this.game.addComponent(allyId, this.componentTypes.BUFF, 
                        Components.Buff('ice_armor', { 
                            armorMultiplier: 1.5
                        }, this.game.state.now + 3.0, false, 1, this.game.state.now));
                    
                    // Visual empowerment effect
                    this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });
                }
            }
            
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'freezing', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 50 
            });
        }
    }
};

// ability: InfernoAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['InfernoAbility'] = class InfernoAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'inferno',
            name: 'Inferno',
            description: 'Creates a blazing inferno that damages all enemies in a large area',
            cooldown: 8.0,
            range: 200,
            manaCost: 80,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 2.0,
            autoTrigger: 'multiple_enemies',
            ...params
        });
        
        this.damage = 35;
        this.infernoRadius = 120;
        this.duration = 4.0;
        this.tickInterval = 0.5;
        this.element = 'fire';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            inferno: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            },
            tick: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff3300,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Find best cluster position deterministically
        const clusterPos = this.findBestClusterPosition(enemies, 2);
        const infernoCenter = clusterPos || this.getDefaultTargetPosition(casterPos, enemies);
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `The battlefield prepares for an unstoppable inferno!`);
        
        // Schedule the inferno to start after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createInferno(casterEntity, infernoCenter);
        }, this.castTime, casterEntity);
    }
    
    createInferno(casterEntity, centerPos) {
        // Create initial inferno effect
        this.createVisualEffect(centerPos, 'inferno');
        
        // Screen effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ff3300', 0.4);
        }
        
        this.logAbilityUsage(casterEntity, `The battlefield erupts in an unstoppable inferno!`);
        
        // Schedule damage ticks deterministically
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickNumber = 0; tickNumber < totalTicks; tickNumber++) {
            const tickDelay = tickNumber * this.tickInterval;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks);
            }, tickDelay, casterEntity);
        }
    }
    
    performInfernoTick(casterEntity, centerPos, tickNumber, totalTicks) {
        // Apply damage to all enemies in radius
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                centerPos,
                this.damage,
                this.element,
                this.infernoRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
            
            // Log damage on first and last ticks
            if (tickNumber === 0 && results.length > 0) {
                this.logAbilityUsage(casterEntity, `Inferno burns ${results.length} enemies!`);
            }
        }
        
        // Visual tick effect (except on last tick to avoid overlap)
        if (tickNumber < totalTicks - 1) {
            this.createVisualEffect(centerPos, 'tick');
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length < minTargets) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential cluster center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within inferno radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.infernoRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Only consider positions that hit minimum targets
            if (targetsInRange >= minTargets) {
                // Calculate score: prioritize more targets, then lower total distance for tie-breaking
                const score = (targetsInRange * 1000) - totalDistance;
                
                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
                if (targetsInRange > maxTargetsHit || 
                    (targetsInRange === maxTargetsHit && score >= bestScore)) {
                    maxTargetsHit = targetsInRange;
                    bestScore = score;
                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
                }
            }
        });
        
        return bestPosition;
    }
    
    // FIXED: Deterministic fallback position when no cluster is found
    getDefaultTargetPosition(casterPos, enemies) {
        if (enemies.length === 0) return casterPos;
        
        // Sort enemies deterministically and pick the first one
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        const firstEnemy = sortedEnemies[0];
        
        const enemyPos = this.game.getComponent(firstEnemy, this.componentTypes.POSITION);
        return enemyPos ? { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z } : casterPos;
    }
};

// ability: MirrorImagesAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MirrorImagesAbility'] = class MirrorImagesAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mirror_images',
            name: 'Mirror Images',
            description: 'Creates 2 weaker illusions of self',
            cooldown: 10.0,
            range: 0, // Self-target
            manaCost: 0,
            targetType: 'self',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            autoTrigger: 'low_health',
            ...params
        });
        
        this.imageCount = 2;
        this.imageDuration = 5.0;
        this.imageHealthRatio = 0.4; // 40% of original health
        this.imageDamageRatio = 0.6; // 60% of original damage
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    colorRange: { start: 0x4169E1, end: 0x87CEEB },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            mirror: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            },
            illusion: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB0C4DE,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Use when low on health or facing multiple enemies
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (casterHealth && casterHealth.current < casterHealth.max * 0.5) {
            return true;
        }
        
        const enemies = this.getEnemiesInRange(casterEntity, 150);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Reality fractures as mirror images appear!`);
        
        // Schedule mirror image creation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createMirrorImages(casterEntity, casterPos);
        }, this.castTime, casterEntity);
    }
    
    createMirrorImages(casterEntity, casterPos) {
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterCollision = this.game.getComponent(casterEntity, this.componentTypes.COLLISION);
        const casterVelocity = this.game.getComponent(casterEntity, this.componentTypes.VELOCITY);
        
        if (!casterTeam || !casterUnitType || !casterCombat || !casterHealth) return;
        
        // Mirror effect at caster
        this.createVisualEffect(casterPos, 'mirror');
        
        const createdImages = [];
        
        // Create images at deterministic positions
        for (let i = 0; i < this.imageCount; i++) {
            const imagePos = this.getDeterministicImagePosition(casterPos, i);
            
            const imageId = this.createMirrorImage(
                casterEntity, imagePos, casterTeam, casterUnitType, 
                casterCombat, casterHealth, casterCollision, casterVelocity
            );
            
            if (imageId !== null) {
                createdImages.push(imageId);
                // Illusion creation effect
                this.createVisualEffect(imagePos, 'illusion');
                
                // Schedule image removal deterministically
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeMirrorImage(imageId);
                }, this.imageDuration, imageId);
            }
        }
        
    }
    
    // FIXED: Deterministic positioning algorithm
    getDeterministicImagePosition(casterPos, imageIndex) {
        // Use predefined positions instead of trigonometry for determinism
        const positions = [
            { offsetX: -35, offsetZ: 25 },   // Left-back
            { offsetX: 35, offsetZ: 25 }     // Right-back
        ];
        
        const offset = positions[imageIndex % positions.length];
        
        return {
            x: casterPos.x + offset.offsetX,
            y: casterPos.y,
            z: casterPos.z + offset.offsetZ
        };
    }
    
    createMirrorImage(originalId, imagePos, team, unitType, combat, health, collision, velocity) {
        // Use deterministic entity creation if available, otherwise use standard method
        const imageId = this.game.createEntity ? this.game.createEntity() : this.generateDeterministicId(originalId);
        
        if (imageId === null || imageId === undefined) return null;
        
        const components = this.game.componentManager.getComponents();
        
        try {
            // Add components in deterministic order (alphabetical by component type)
            this.game.addComponent(imageId, this.componentTypes.AI_STATE, 
                components.AIState('idle'));
                
            this.game.addComponent(imageId, this.componentTypes.ANIMATION, 
                components.Animation());
                
            this.game.addComponent(imageId, this.componentTypes.COLLISION, 
                components.Collision(collision?.radius, collision.height));
                
            this.game.addComponent(imageId, this.componentTypes.COMBAT, 
                components.Combat(
                    Math.floor(combat.damage * this.imageDamageRatio),
                    combat.range,
                    combat.attackSpeed,
                    combat.projectile,
                    0,
                    combat.element || 'physical',
                    Math.floor((combat.armor || 0) * 0.5), // Half armor
                    combat.fireResistance || 0,
                    combat.coldResistance || 0,
                    combat.lightningResistance || 0
                ));
                
            this.game.addComponent(imageId, this.componentTypes.EQUIPMENT, 
                components.Equipment());
                
            this.game.addComponent(imageId, this.componentTypes.FACING, 
                components.Facing(0));
                
            this.game.addComponent(imageId, this.componentTypes.HEALTH, 
                components.Health(Math.floor(health.max * this.imageHealthRatio)));
                
            this.game.addComponent(imageId, this.componentTypes.MIRROR_IMAGE, 
                components.MirrorImage(originalId, true, this.game.state.now || 0));
                
            this.game.addComponent(imageId, this.componentTypes.POSITION, 
                components.Position(imagePos.x, imagePos.y, imagePos.z));
                
            this.game.addComponent(imageId, this.componentTypes.RENDERABLE, 
                components.Renderable("units", unitType.id || unitType.title));
                
            this.game.addComponent(imageId, this.componentTypes.TEAM, 
                components.Team(team.team));
                
            this.game.addComponent(imageId, this.componentTypes.UNIT_TYPE, 
                components.UnitType(
                    unitType.id || unitType.title,
                    `Mirror Image`,
                    0 // No value - they're illusions
                ));
                
            this.game.addComponent(imageId, this.componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, velocity?.maxSpeed || 40));
            
            return imageId;
            
        } catch (error) {
            console.error(`Failed to create mirror image:`, error);
            return null;
        }
    }
    
    // FIXED: Deterministic removal instead of lifetime system
    removeMirrorImage(imageId) {
        if (!this.game.hasEntity || !this.game.hasEntity(imageId)) return;
        
        const imagePos = this.game.getComponent(imageId, this.componentTypes.POSITION);
        
        // Create disappearance effect
        if (imagePos) {
            this.createVisualEffect(imagePos, 'illusion');
        }
        
        // Remove the entity
        if (this.game.removeEntity) {
            this.game.removeEntity(imageId);
        } else if (this.game.destroyEntity) {
            this.game.destroyEntity(imageId);
        }
       
    }
    
    // Fallback method for deterministic ID generation (if needed)
    generateDeterministicId(originalId) {
        // This is a fallback - ideally the game should provide deterministic entity creation
        const timestamp = this.game.state.now || this.game.state.now || 0;
        return `mirror_${originalId}_${Math.floor(timestamp * 1000)}`;
    }
};

// ability: DisruptionBombAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DisruptionBombAbility'] = class DisruptionBombAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'disruption_bomb',
            name: 'Disruption Bomb',
            description: 'Throw a bomb that disables enemy abilities and equipment (effects do not stack)',
            cooldown: 16.0,
            range: 130,
            manaCost: 40,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 1.3,
            ...params
        });
        
        this.explosionRadius = 90;
        this.disruptionDuration = 12.0;
        this.accuracyReduction = 0.4; // 40% accuracy reduction
        this.movementSlowed = 0.6; // Movement slowed to 60%
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            },
            explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0x8A2BE2,
                    colorRange: { start: 0x8A2BE2, end: 0x4B0082 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 2.0
                }
            },
            disruption: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x9932CC,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        // Only use if there are at least 2 enemies to disrupt
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, `Saboteur prepares a disruption bomb!`);
        
        // DESYNC SAFE: Use scheduling system for bomb throw and explosion
        this.game.schedulingSystem.scheduleAction(() => {
            this.throwDisruptionBomb(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    throwDisruptionBomb(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // DESYNC SAFE: Find best cluster position deterministically
        const clusterPos = this.findBestClusterPosition(enemies, 2);
        const targetPos = clusterPos || pos;
        
        // Visual explosion effect
        this.createVisualEffect(targetPos, 'explosion');
        
        // Screen effects for dramatic explosion
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showExplosionEffect(targetPos.x, targetPos.y, targetPos.z);
            this.game.effectsSystem.playScreenShake(0.4, 2);
            this.game.effectsSystem.playScreenFlash('#8A2BE2', 0.3);
        }
        
        // DESYNC SAFE: Apply disruption effects deterministically
        this.applyDisruptionEffects(casterEntity, enemies, targetPos);
    }
    
    // DESYNC SAFE: Apply disruption effects to enemies in range
    applyDisruptionEffects(casterEntity, enemies, bombPos) {
        // Sort enemies for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let disruptedCount = 0;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            // Only affect living enemies
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            // Check if enemy is in explosion radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - bombPos.x, 2) + 
                Math.pow(enemyPos.z - bombPos.z, 2)
            );
            
            if (distance <= this.explosionRadius) {
                // DESYNC SAFE: Check if already disrupted - don't stack disruptions
                const existingBuff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
                
                if (existingBuff && existingBuff.buffType === 'disrupted') {
                    // DESYNC SAFE: Just refresh duration instead of stacking
                    existingBuff.endTime = this.game.state.now + this.disruptionDuration;
                    existingBuff.appliedTime = this.game.state.now;
                } else {
                    // Apply new disruption buff
                    const Components = this.game.componentManager.getComponents();
                    this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                        Components.Buff('disrupted', { 
                            abilitiesDisabled: true,
                            accuracyReduction: this.accuracyReduction,
                            movementSlowed: this.movementSlowed
                        }, this.game.state.now + this.disruptionDuration, false, 1, this.game.state.now));
                    
                    // DESYNC SAFE: Schedule disruption removal
                    this.game.schedulingSystem.scheduleAction(() => {
                        this.removeDisruption(enemyId);
                    }, this.disruptionDuration, enemyId);
                }
                
                // Visual disruption effect on each affected enemy
                this.createVisualEffect(enemyPos, 'disruption');
                
                disruptedCount++;
            }
        });
        
       
    }
    
    // DESYNC SAFE: Find best cluster position deterministically
    findBestClusterPosition(enemies, minCluster = 2) {
        if (enemies.length < minCluster) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPos = null;
        let bestScore = 0;
        
        sortedEnemies.forEach(enemyId => {
            const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!pos) return;
            
            // Count nearby enemies within explosion radius
            let nearbyCount = 0;
            sortedEnemies.forEach(otherId => {
                if (otherId === enemyId) return;
                const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
                if (!otherPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(pos.x - otherPos.x, 2) + 
                    Math.pow(pos.z - otherPos.z, 2)
                );
                
                if (distance <= this.explosionRadius) nearbyCount++;
            });
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (nearbyCount >= minCluster - 1 && nearbyCount >= bestScore) {
                bestScore = nearbyCount;
                bestPos = { x: pos.x, y: pos.y, z: pos.z };
            }
        });
        
        return bestPos;
    }
    
    // DESYNC SAFE: Remove disruption effect
    removeDisruption(enemyId) {
        // Check if enemy still exists and has the disruption buff
        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'disrupted') {
                this.game.removeComponent(enemyId, this.componentTypes.BUFF);
                
                // Visual effect when disruption expires
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (enemyPos) {
                    this.createVisualEffect(enemyPos, 'disruption', { 
                        count: 3, 
                        scaleMultiplier: 0.8,
                        color: 0x87CEEB 
                    });
                }
                
           
            }
        }
    }
};

// ability: DrainLifeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['DrainLifeAbility'] = class DrainLifeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'drain_life',
            name: 'Drain Life',
            description: 'Drains health from an enemy and heals the caster',
            cooldown: 4.5,
            range: 200,
            manaCost: 45,
            targetType: 'auto',
            animation: 'cast',
            priority: 7,
            castTime: 1.2,
            autoTrigger: 'low_health',
            ...params
        });
        
        this.drainAmount = 60;
        this.healRatio = 0.8; // Heal 80% of drained health
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x800080,
                    colorRange: { start: 0x800080, end: 0x4B0082 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            drain: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B008B,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.5
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x9400D3,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Use when injured and enemies are available
        return enemies.length >= 1 && 
               casterHealth && casterHealth.current < casterHealth.max * 0.6;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Target selection
        const target = this.findHighestHealthEnemy(enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate effects (visual, audio, logging)
        this.createVisualEffect(casterPos, 'cast');
        
        // Create drain beam effect immediately
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0x8B008B, linewidth: 4 },
                    animation: { duration: 1000, pulseEffect: true }
                }
            );
        }
        
        this.logAbilityUsage(casterEntity, `Dark energy siphons life force!`);
        
        // DESYNC SAFE: Use scheduling system for delayed effect
        this.game.schedulingSystem.scheduleAction(() => {
            const currentTargetPos = this.game.getComponent(target, this.componentTypes.POSITION);
            if (currentTargetPos) {
                this.performDrain(casterEntity, target, currentTargetPos);
            }
        }, this.castTime, casterEntity);
    }
    
    performDrain(casterEntity, targetId, targetPos) {
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || !casterPos || !targetPos) return;
        
        // Apply damage to target
        const result = this.dealDamageWithEffects(casterEntity, targetId, this.drainAmount, this.element, {
            isDrain: true
        });
        
        if (result && result.damage > 0) {
            // Heal caster based on damage dealt
            const healAmount = Math.floor(result.damage * this.healRatio);
            const actualHeal = Math.min(healAmount, casterHealth.max - casterHealth.current);
            casterHealth.current += actualHeal;
            
            // Drain effect on target
            this.createVisualEffect(targetPos, 'drain');
            
            // Heal effect on caster
            if (actualHeal > 0) {
                this.createVisualEffect(casterPos, 'heal');
                
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.showDamageNumber(
                        casterPos.x, casterPos.y + 15, casterPos.z,
                        actualHeal, 'heal'
                    );
                }
            }
        }
    }
    
    // DESYNC SAFE: Deterministic target selection
    findHighestHealthEnemy(enemies) {
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
};

// ability: ExplosiveTrapAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ExplosiveTrapAbility'] = class ExplosiveTrapAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'explosive_trap',
            name: 'Explosive Trap',
            description: 'Place a hidden trap that explodes when enemies approach (max 2 per Trapper)',
            cooldown: 15.0,
            range: 100,
            manaCost: 35,
            targetType: 'ground',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.maxTrapsPerTrapper = 2;
        this.trapDamage = 80;
        this.explosionRadius = 100;
        this.triggerRadius = 40;
        this.trapPlacementDistance = 60;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B4513,
                    colorRange: { start: 0x8B4513, end: 0xA0522D },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            trap_place: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x696969,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 1.0
                }
            },
            trap_explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    colorRange: { start: 0xFF4500, end: 0xFF8C00 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 2.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // DESYNC SAFE: Check how many traps this trapper already has active
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        // Sort traps for consistent processing
        const sortedTraps = existingTraps.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const myTraps = sortedTraps.filter(trapId => {
            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);
            return trap && trap.caster === casterEntity && !trap.triggered;
        });
        
        return myTraps.length < this.maxTrapsPerTrapper;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Trapper prepares an explosive surprise!");
        
        // DESYNC SAFE: Use scheduling system for trap placement
        this.game.schedulingSystem.scheduleAction(() => {
            this.placeTrap(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    placeTrap(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Calculate trap position deterministically
        const trapPos = this.calculateTrapPosition(casterEntity, pos);
        
        // Create trap entity
        const trapId = this.game.createEntity();
        const Components = this.game.componentManager.getComponents();
        
        // Position component
        this.game.addComponent(trapId, this.componentTypes.POSITION, 
            Components.Position(trapPos.x, trapPos.y, trapPos.z));
        
        // DESYNC SAFE: Trap component with proper game time
        this.game.addComponent(trapId, this.componentTypes.TRAP, 
            Components.Trap(
                this.trapDamage, 
                this.explosionRadius, 
                this.triggerRadius, 
                'physical', 
                casterEntity, 
                false, 
                1
            ));
        
        // Visual indicator (hidden from enemies in actual gameplay)
        this.game.addComponent(trapId, this.componentTypes.RENDERABLE, 
            Components.Renderable("effects", "hidden_trap"));
        
        // DESYNC SAFE: Add lifetime to prevent permanent traps
        this.game.addComponent(trapId, this.componentTypes.LIFETIME, 
            Components.Lifetime(60.0, this.game.state.now)); // 60 second lifetime
        
        // Visual trap placement effect
        this.createVisualEffect(trapPos, 'trap_place');
        
      
        // DESYNC SAFE: Schedule trap cleanup after lifetime
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupTrap(trapId);
        }, 60.0, trapId);
    }
    
    // DESYNC SAFE: Calculate trap position deterministically
    calculateTrapPosition(casterEntity, casterPos) {
        // Get facing direction for consistent placement
        const facing = this.game.getComponent(casterEntity, this.componentTypes.FACING) || { angle: 0 };
        
        // Calculate position ahead of caster
        const trapPos = {
            x: casterPos.x + Math.cos(facing.angle) * this.trapPlacementDistance,
            y: casterPos.y,
            z: casterPos.z + Math.sin(facing.angle) * this.trapPlacementDistance
        };
        
        // DESYNC SAFE: Validate position and adjust if needed
        return this.validateTrapPosition(trapPos, casterPos);
    }
    
    // DESYNC SAFE: Validate and adjust trap position if needed
    validateTrapPosition(proposedPos, fallbackPos) {
        // Basic bounds checking
        if (proposedPos.x < -1000 || proposedPos.x > 1000 || 
            proposedPos.z < -1000 || proposedPos.z > 1000) {
            return fallbackPos; // Use caster position as fallback
        }
        
        // Check for existing traps nearby (prevent stacking)
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        for (const trapId of existingTraps) {
            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
            if (trapPos) {
                const distance = Math.sqrt(
                    Math.pow(trapPos.x - proposedPos.x, 2) + 
                    Math.pow(trapPos.z - proposedPos.z, 2)
                );
                
                if (distance < 30) { // Too close to existing trap
                    // Offset the position slightly
                    return {
                        x: proposedPos.x + 20,
                        y: proposedPos.y,
                        z: proposedPos.z + 20
                    };
                }
            }
        }
        
        return proposedPos; // Position is valid
    }
    
    // DESYNC SAFE: Handle trap trigger (called by game systems when enemy approaches)
    triggerTrap(trapId, triggeringEnemyId) {
        const trapComponent = this.game.getComponent(trapId, this.componentTypes.TRAP);
        const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
        
        if (!trapComponent || !trapPos || trapComponent.triggered) return;
        
        // Mark trap as triggered
        trapComponent.triggered = true;
        trapComponent.triggerCount++;
        
        // Visual explosion effect
        this.createVisualEffect(trapPos, 'trap_explosion');
        
        // Screen effects for dramatic explosion
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showExplosionEffect(trapPos.x, trapPos.y, trapPos.z);
            this.game.effectsSystem.playScreenShake(0.3, 2);
        }
        
        // DESYNC SAFE: Apply explosion damage to all enemies in radius
        this.applyExplosionDamage(trapComponent.caster, trapPos, trapComponent);
        
        // DESYNC SAFE: Schedule trap cleanup after explosion
        this.game.schedulingSystem.scheduleAction(() => {
            this.cleanupTrap(trapId);
        }, 0.5, trapId); // Small delay for explosion effects
    }
    
    // DESYNC SAFE: Apply explosion damage deterministically
    applyExplosionDamage(casterId, explosionPos, trapComponent) {
        // Get all entities that could be damaged
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);
        if (!casterTeam) return;
        
        // Sort entities for consistent processing
        const sortedEntities = allEntities.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let damageTargets = [];
        
        sortedEntities.forEach(entityId => {
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityHealth || !entityTeam || entityHealth.current <= 0) return;
            
            // Don't damage allies
            if (entityTeam.team === casterTeam.team) return;
            
            // Check if in explosion radius
            const distance = Math.sqrt(
                Math.pow(entityPos.x - explosionPos.x, 2) + 
                Math.pow(entityPos.z - explosionPos.z, 2)
            );
            
            if (distance <= trapComponent.radius) {
                damageTargets.push({
                    id: entityId,
                    distance: distance,
                    position: entityPos
                });
            }
        });
        
        // Apply damage to all targets
        damageTargets.forEach(target => {
            // Calculate damage falloff based on distance
            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / trapComponent.radius));
            const finalDamage = Math.floor(trapComponent.damage * damageMultiplier);
            
            this.dealDamageWithEffects(casterId, target.id, finalDamage, trapComponent.element, {
                isTrap: true,
                isExplosion: true
            });
        });
        
     
    }
    
    // DESYNC SAFE: Clean up trap entity
    cleanupTrap(trapId) {
        if (this.game.hasComponent(trapId, this.componentTypes.TRAP)) {
            // Small visual effect for trap disappearing
            const trapPos = this.game.getComponent(trapId, this.componentTypes.POSITION);
            if (trapPos) {
                this.createVisualEffect(trapPos, 'trap_place', { 
                    count: 2, 
                    scaleMultiplier: 0.5 
                });
            }
            
            this.game.destroyEntity(trapId);
        }
    }
    
    // Helper method for other systems to check trap count
    getActiveTrapCount(trapperId) {
        const existingTraps = this.game.getEntitiesWith(
            this.componentTypes.TRAP,
            this.componentTypes.POSITION
        );
        
        return existingTraps.filter(trapId => {
            const trap = this.game.getComponent(trapId, this.componentTypes.TRAP);
            return trap && trap.caster === trapperId && !trap.triggered;
        }).length;
    }
};

// ability: ShadowStrikeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ShadowStrikeAbility'] = class ShadowStrikeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'shadow_strike',
            name: 'Shadow Strike',
            description: 'Teleport behind an enemy and deal critical damage',
            cooldown: 9.0,
            range: 120,
            manaCost: 30,
            targetType: 'enemy',
            animation: 'attack',
            priority: 8,
            castTime: 0.5,
            ...params
        });
        this.backstabDamage = 65;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F2F2F,
                    colorRange: { start: 0x2F2F2F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.0
                }
            },
            teleport: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 3.0
                }
            },
            backstab: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xFF0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Select target deterministically (closest enemy)
        const target = this.findClosestEnemy(casterEntity, enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Rogue strikes from the shadows!");
        
        // DESYNC SAFE: Use scheduling system for teleport and attack
        this.game.schedulingSystem.scheduleAction(() => {
            this.performShadowStrike(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    performShadowStrike(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // DESYNC SAFE: Calculate teleport position deterministically
        const teleportPos = this.calculateTeleportPosition(targetPos);
        
        // Visual effect at original position before teleport
        this.createVisualEffect(casterPos, 'teleport');
        
        // Teleport behind target
        casterPos.x = teleportPos.x;
        casterPos.z = teleportPos.z;
        
        // Visual effect at new position after teleport
        this.createVisualEffect(teleportPos, 'teleport');
        
        // Deal critical backstab damage
        this.dealDamageWithEffects(casterEntity, targetId, this.backstabDamage, 'physical', {
            isCritical: true,
            criticalMultiplier: 2.0,
            isBackstab: true
        });
        
        // Backstab effect
        this.createVisualEffect(targetPos, 'backstab');
        
        // Screen effect for dramatic teleport
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.2, 1.5);
        }
    }
    
    // DESYNC SAFE: Calculate teleport position deterministically
    calculateTeleportPosition(targetPos) {
        // Try positions behind the target in a deterministic order
        const offsets = [
            { x: -25, z: -25 }, // Behind and to the left
            { x: -25, z: 0 },   // Directly behind
            { x: -25, z: 25 },  // Behind and to the right
            { x: 0, z: -25 },   // To the left
            { x: 0, z: 25 },    // To the right
        ];
        
        // Use the first valid position
        for (const offset of offsets) {
            const testPos = {
                x: targetPos.x + offset.x,
                y: targetPos.y,
                z: targetPos.z + offset.z
            };
            
            if (this.isValidTeleportPosition(testPos)) {
                return testPos;
            }
        }
        
        // Fallback position if no valid position found
        return {
            x: targetPos.x - 25,
            y: targetPos.y,
            z: targetPos.z - 25
        };
    }
    
    isValidTeleportPosition(pos) {
        // Basic validation - ensure position is within reasonable bounds
        // This could be enhanced with collision detection if needed
        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;
    }
};

// ability: ShieldWallAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ShieldWallAbility'] = class ShieldWallAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'shield_wall',
            name: 'Shield Wall',
            description: 'Form a defensive stance, reducing damage and taunting enemies',
            cooldown: 12.0,
            range: 0, // Self-buff with taunt radius
            manaCost: 30,
            targetType: 'self',
            animation: 'cast',
            priority: 4,
            castTime: 1.0,
            ...params
        });
        
        this.wallDuration = 10.0;
        this.damageReduction = 0.75; // 75% damage reduction
        this.tauntRadius = 200;
        this.originalArmorMultiplier = 1.0;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x708090,
                    colorRange: { start: 0x708090, end: 0xC0C0C0 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            shield_formation: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4682B4,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            defensive_stance: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 0.6
                }
            },
            taunt_aura: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if already has shield wall to prevent stacking
        const existingWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        if (existingWall && existingWall.isActive) return false;
        
        // Use when enemies are nearby and threatening
        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Soldier prepares to form a shield wall...`);
        
        // Schedule the shield wall formation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.formShieldWall(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    formShieldWall(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterCombat = this.game.getComponent(casterEntity, this.componentTypes.COMBAT);
        
        if (!casterPos) return;
        
        // Create shield formation effect
        this.createVisualEffect(casterPos, 'shield_formation');
        
        // Store original armor for restoration later
        const originalArmor = casterCombat ? casterCombat.armor : 0;
        
        // Apply shield wall component with proper timing
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.wallDuration;
        
        this.game.addComponent(casterEntity, this.componentTypes.SHIELD_WALL, 
            Components.ShieldWall(
                this.damageReduction,
                endTime,
                this.tauntRadius,
                originalArmor
            )
        );
        
        // Schedule defensive stance visual effect
        this.game.schedulingSystem.scheduleAction(() => {
            const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            if (pos) {
                this.createVisualEffect(pos, 'defensive_stance');
            }
        }, 0.5, casterEntity);
        
        // Apply taunt effect to nearby enemies
        this.applyTauntToEnemies(casterEntity);
        
        // Screen effects for dramatic formation
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 1);
        }
        
    
      
        
        // Schedule shield wall expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnShieldWallEnding(casterEntity);
        }, this.wallDuration - 1.5, casterEntity);
        
        // Schedule shield wall removal (failsafe)
        this.game.schedulingSystem.scheduleAction(() => {
            this.removeShieldWall(casterEntity);
        }, this.wallDuration, casterEntity);
    }
    
    applyTauntToEnemies(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity, this.tauntRadius);
        if (enemies.length === 0) return;
        
        // Sort enemies deterministically for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let tauntedCount = 0;
        
        sortedEnemies.forEach((enemyId, index) => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyAI = this.game.getComponent(enemyId, this.componentTypes.AI_STATE);
            
            if (!enemyPos || !enemyAI) return;
            
            // Apply taunt component
            const Components = this.game.componentManager.getComponents();
            const currentTime = this.game.state.now || this.game.state.now || 0;
            const tauntEndTime = currentTime + (this.wallDuration * 0.8); // Taunt lasts 80% of shield wall
            
            this.game.addComponent(enemyId, this.componentTypes.TAUNT, 
                Components.Taunt(
                    casterEntity,     // Taunter
                    tauntEndTime,     // End time
                    this.tauntRadius, // Radius
                    true              // Is taunted
                )
            );
            
            // Force AI to target the shield wall user
  
            enemyAI.target = casterEntity;
            enemyAI.targetPosition = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            enemyAI.path = [];
            enemyAI.meta = {};
        
            // Schedule staggered taunt effects for visual appeal
            this.game.schedulingSystem.scheduleAction(() => {
                const pos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'taunt_aura');
                }
            }, index * 0.1, enemyId);
            
            tauntedCount++;
        });
        
        if (tauntedCount > 0) {
            this.logAbilityUsage(casterEntity, 
                `Shield wall taunts ${tauntedCount} enemies to attack!`);
        }
    }
    
    // FIXED: Shield wall ending warning
    warnShieldWallEnding(casterEntity) {
        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        // Check if shield wall still exists and is active
        if (!shieldWall || !shieldWall.isActive || !casterPos) return;
        
        // Create warning effect
        this.createVisualEffect(casterPos, 'cast', { 
            count: 4, 
            color: 0x708090,
            scaleMultiplier: 0.8 
        });
     
    }
    
    // FIXED: Proper shield wall removal
    removeShieldWall(casterEntity) {
        const shieldWall = this.game.getComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!shieldWall) return;
        
        // Create dissolution effect
        if (casterPos) {
            this.createVisualEffect(casterPos, 'defensive_stance', { 
                count: 6, 
                scaleMultiplier: 0.6 
            });
        }
        
        // Remove shield wall component
        this.game.removeComponent(casterEntity, this.componentTypes.SHIELD_WALL);
        
       
    }
};

// ability: SmiteAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SmiteAbility'] = class SmiteAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'smite',
            name: 'Divine Smite',
            description: 'Calls down divine wrath upon the strongest enemy',
            cooldown: 6.0,
            range: 400,
            manaCost: 65,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 1.8,
            autoTrigger: 'strong_enemy',
            ...params
        });
        
        this.damage = 80;
        this.bonusDamageVsUndead = 2.0; // Double damage vs undead
        this.pillarDelay = 0.5; // Time between pillar and damage
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFFFACD },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            },
            smite: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFF8DC,
                    scaleMultiplier: 3.0,
                    speedMultiplier: 0.8
                }
            },
            pillar: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xF0E68C,
                    scaleMultiplier: 4.0,
                    speedMultiplier: 2.0
                }
            },
            divine_judgment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFFFE0,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Target the strongest enemy (highest health) deterministically
        const target = this.findHighestHealthEnemyDeterministic(enemies);
        if (!target) return null;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine judgment descends from the heavens!`);
        
        // Schedule the divine smite after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performDivineSmite(casterEntity, target, targetPos);
        }, this.castTime, casterEntity);
    }
    
    performDivineSmite(casterEntity, targetId, originalTargetPos) {
        // Get current target position (target may have moved)
        const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const targetPos = currentTargetPos || originalTargetPos; // Fallback to original position
        
        // Create pillar of light effect
        this.createVisualEffect(targetPos, 'pillar');
        
        // Create divine judgment aura effect
        this.createVisualEffect(targetPos, 'divine_judgment');
        
        // Screen flash and shake
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.5);
            this.game.effectsSystem.playScreenShake(0.3, 3);
        }
        
        this.logAbilityUsage(casterEntity, `A pillar of divine light appears!`);
        
        // Schedule the actual damage after pillar effect
        this.game.schedulingSystem.scheduleAction(() => {
            this.applySmiteDamage(casterEntity, targetId, targetPos);
        }, this.pillarDelay, targetId);
    }
    
    applySmiteDamage(casterEntity, targetId, targetPos) {
        // Validate target still exists
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth || targetHealth.current <= 0) {
            this.logAbilityUsage(casterEntity, `Divine judgment finds no target!`);
            return;
        }
        
        // Calculate damage (bonus vs undead)
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        let damage = this.damage;
        let isUndeadTarget = false;
        
        if (targetUnitType && (
            targetUnitType.title.includes('undead') || 
            targetUnitType.title.includes('skeleton') ||
            targetUnitType.title.includes('zombie') ||
            targetUnitType.id.includes('undead')
        )) {
            damage = Math.floor(damage * this.bonusDamageVsUndead);
            isUndeadTarget = true;
        }
        
        // Apply divine damage
        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {
            isSmite: true,
            isCritical: true,
            isAntiUndead: isUndeadTarget,
            criticalMultiplier: 1.5
        });
        
        // Create smite impact effect
        this.createVisualEffect(targetPos, 'smite');
      
    
    }
    
    // FIXED: Deterministic highest health enemy selection
    findHighestHealthEnemyDeterministic(enemies) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        // Process enemies in deterministic order
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (!health) return;
            
            // Use >= for consistent tie-breaking (first in sorted order wins when health is equal)
            if (health.current >= highestHealth) {
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
    
    // Helper method to check if target is undead (for potential future use)
    isUndeadTarget(targetId) {
        const targetUnitType = this.game.getComponent(targetId, this.componentTypes.UNIT_TYPE);
        if (!targetUnitType) return false;
        
        return targetUnitType.title.includes('undead') || 
               targetUnitType.title.includes('skeleton') ||
               targetUnitType.title.includes('zombie') ||
               targetUnitType.id.includes('undead');
    }
    
    // Helper method to get effective damage against target
    getEffectiveDamage(targetId) {
        let damage = this.damage;
        
        if (this.isUndeadTarget(targetId)) {
            damage = Math.floor(damage * this.bonusDamageVsUndead);
        }
        
        return damage;
    }
};

// ability: MindControlAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MindControlAbility'] = class MindControlAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mind_control',
            name: 'Mind Control',
            description: 'Charms enemy to fight for you',
            cooldown: 5.0,
            range: 190,
            manaCost: 0,
            targetType: 'enemy',
            animation: 'cast',
            priority: 8,
            castTime: 3.0,
            ...params
        });

        // How long control lasts once applied
        this.controlDuration = 5.0;

        // DESYNC SAFE: Track pending controls deterministically
        // Map<targetId, { team, contributors: Set<casterId>, progress: number, startTime: number, scheduledActionId: string }>
        this.pendingControls = new Map();

        // DESYNC SAFE: Track active beams for cleanup
        // Map<targetId, { team, beams: Map<casterId, effectData> }>
        this.beamRegistry = new Map();
    }

    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8A2BE2,
                    colorRange: { start: 0x8A2BE2, end: 0xDDA0DD },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            },
            control: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x9932CC,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 2.0
                }
            },
            charm: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xDA70D6,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.5
                }
            }
        };
    }

    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Filter out enemies that are already being controlled or targeted
        const validTargets = enemies.filter(enemyId => {
            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);
            const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
            
            if (!enemyTeam || !casterTeam) return false;
            
            // Don't target enemies that are already controlled by our team
            if (enemyTeam.team === casterTeam.team) return false;
            
            // Don't target enemies that are already being mind controlled
            return !this.pendingControls.has(enemyId);
        });
        
        return validTargets.length > 0;
    }

    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!casterPos || !casterTeam) return;

        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        const validTargets = enemies.filter(enemyId => {
            const enemyTeam = this.game.getComponent(enemyId, this.componentTypes.TEAM);
            return enemyTeam && enemyTeam.team !== casterTeam.team && !this.pendingControls.has(enemyId);
        });

        if (validTargets.length === 0) return;

        // DESYNC SAFE: Select target deterministically (closest enemy)
        const target = this.findClosestEnemy(casterEntity, validTargets);
        if (!target) return;

        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `${this.name} begins to dominate an enemy mind!`);

        // DESYNC SAFE: Use scheduling system for mind control process
        this.game.schedulingSystem.scheduleAction(() => {
            this.startMindControl(casterEntity, target);
        }, this.castTime, casterEntity);
    }

    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;

        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));

        let closest = null;
        let closestDistance = Infinity;

        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;

            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );

            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });

        return closest;
    }

    // DESYNC SAFE: Start mind control process
    startMindControl(casterId, targetId) {
        const casterTeam = this.game.getComponent(casterId, this.componentTypes.TEAM);
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterTeam || !targetTeam || !targetPos) return;

        // Check if target is already being controlled
        if (this.pendingControls.has(targetId)) {
            // Add this caster as a contributor to existing control attempt
            const existing = this.pendingControls.get(targetId);
            existing.contributors.add(casterId);
            this.createBeam(casterId, targetId);
            return;
        }

        // Start new mind control attempt
        const controlData = {
            team: casterTeam.team,
            contributors: new Set([casterId]),
            progress: 0,
            startTime: this.game.state.now,
            originalTeam: targetTeam.team
        };

        this.pendingControls.set(targetId, controlData);

        // Create visual beam effect
        this.createBeam(casterId, targetId);

        // Visual effect on target
        this.createVisualEffect(targetPos, 'control');

        // DESYNC SAFE: Schedule the mind control completion check
        const completionTime = 2.0; // 2 seconds to complete mind control
        const actionId = this.game.schedulingSystem.scheduleAction(() => {
            this.completeMindControl(targetId);
        }, completionTime, casterId);

        controlData.scheduledActionId = actionId;
    }

    // DESYNC SAFE: Complete mind control process
    completeMindControl(targetId) {
        const controlData = this.pendingControls.get(targetId);
        if (!controlData) return;

        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam || !targetPos) {
            this.cancelMindControl(targetId);
            return;
        }

        // Check if any contributors are still alive and in range
        const validContributors = Array.from(controlData.contributors).filter(casterId => {
            const casterHealth = this.game.getComponent(casterId, this.componentTypes.HEALTH);
            const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);
            
            if (!casterHealth || casterHealth.current <= 0 || !casterPos) return false;
            
            const distance = Math.sqrt(
                Math.pow(casterPos.x - targetPos.x, 2) + 
                Math.pow(casterPos.z - targetPos.z, 2)
            );
            
            return distance <= this.range;
        });

        if (validContributors.length === 0) {
            this.cancelMindControl(targetId);
            return;
        }

        // Apply mind control
        this.applyMindControl(targetId, controlData);
    }

    // DESYNC SAFE: Apply mind control effect
    applyMindControl(targetId, controlData) {
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam || !targetPos) return;

        // Change team
        targetTeam.team = controlData.team;

        // Visual charm effect
        this.createVisualEffect(targetPos, 'charm');

       

        // Clean up beams
        this.clearAllBeamsForTarget(targetId);

        // Remove from pending controls
        this.pendingControls.delete(targetId);

        // DESYNC SAFE: Schedule the mind control to expire
        this.game.schedulingSystem.scheduleAction(() => {
            this.expireMindControl(targetId, controlData.originalTeam);
        }, this.controlDuration, null);
    }

    // DESYNC SAFE: Cancel mind control attempt
    cancelMindControl(targetId) {
        const controlData = this.pendingControls.get(targetId);
        if (!controlData) return;

        // Cancel scheduled completion if it exists
        if (controlData.scheduledActionId) {
            this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);
        }

        // Clean up beams
        this.clearAllBeamsForTarget(targetId);

        // Remove from pending controls
        this.pendingControls.delete(targetId);
    }

    // DESYNC SAFE: Expire mind control effect
    expireMindControl(targetId, originalTeam) {
        const targetTeam = this.game.getComponent(targetId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!targetTeam) return; // Target might be dead

        // Restore original team
        targetTeam.team = originalTeam;

        // Visual effect for mind control ending
        if (targetPos) {
            this.createVisualEffect(targetPos, 'control', { count: 2 });
        }

    
    }

    // DESYNC SAFE: Create visual beam effect
    createBeam(casterId, targetId) {
        const casterPos = this.game.getComponent(casterId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos || !this.game.effectsSystem) return;

        // Create beam using the effects system
        const beamEffect = this.game.effectsSystem.createEnergyBeam(
            new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
            new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
            {
                style: { color: 0x8A2BE2, linewidth: 3 },
                animation: { duration: 2000, pulseEffect: true }
            }
        );

        // Track beam for cleanup
        if (!this.beamRegistry.has(targetId)) {
            this.beamRegistry.set(targetId, { beams: new Map() });
        }
        
        this.beamRegistry.get(targetId).beams.set(casterId, beamEffect);
    }

    // DESYNC SAFE: Clear all beams for a target
    clearAllBeamsForTarget(targetId) {
        const entry = this.beamRegistry.get(targetId);
        if (!entry) return;

        // Clean up all beams for this target
        for (const [casterId, beamEffect] of entry.beams.entries()) {
            if (beamEffect && this.game.scene) {
                try {
                    this.game.scene.remove(beamEffect);
                    if (beamEffect.geometry) beamEffect.geometry.dispose();
                    if (beamEffect.material) beamEffect.material.dispose();
                } catch (error) {
                    console.warn('Error cleaning up beam:', error);
                }
            }
        }

        this.beamRegistry.delete(targetId);
    }

    // DESYNC SAFE: Clear specific beam
    clearBeam(casterId, targetId) {
        const entry = this.beamRegistry.get(targetId);
        if (!entry) return;

        const beamEffect = entry.beams.get(casterId);
        if (beamEffect && this.game.scene) {
            try {
                this.game.scene.remove(beamEffect);
                if (beamEffect.geometry) beamEffect.geometry.dispose();
                if (beamEffect.material) beamEffect.material.dispose();
            } catch (error) {
                console.warn('Error cleaning up specific beam:', error);
            }
        }

        entry.beams.delete(casterId);
        
        // If no more beams for this target, remove the entry
        if (entry.beams.size === 0) {
            this.beamRegistry.delete(targetId);
        }
    }

    // DESYNC SAFE: Handle when a caster dies or becomes invalid
    onCasterDeath(casterId) {
        // Remove from all pending controls
        for (const [targetId, controlData] of this.pendingControls.entries()) {
            if (controlData.contributors.has(casterId)) {
                controlData.contributors.delete(casterId);
                
                // Clear the beam for this caster
                this.clearBeam(casterId, targetId);
                
                // If no contributors left, cancel the mind control
                if (controlData.contributors.size === 0) {
                    this.cancelMindControl(targetId);
                }
            }
        }
    }

    // DESYNC SAFE: Handle when a target dies
    onTargetDeath(targetId) {
        // Clean up any pending mind control
        this.cancelMindControl(targetId);
    }

    // DESYNC SAFE: System cleanup
    destroy() {
        // Cancel all pending controls
        for (const [targetId, controlData] of this.pendingControls.entries()) {
            if (controlData.scheduledActionId) {
                this.game.schedulingSystem.cancelAction(controlData.scheduledActionId);
            }
        }
        this.pendingControls.clear();

        // Clean up all beams
        for (const [targetId] of this.beamRegistry.entries()) {
            this.clearAllBeamsForTarget(targetId);
        }
        this.beamRegistry.clear();
    }
};

// ability: WindShieldAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['WindShieldAbility'] = class WindShieldAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'wind_shield',
            name: 'Wind Shield',
            description: 'Creates protective wind barriers that deflect projectiles',
            cooldown: 8.0,
            range: 200,
            manaCost: 60,
            targetType: 'defensive',
            animation: 'cast',
            priority: 4,
            castTime: 1.2,
            autoTrigger: 'projectiles_incoming',
            ...params
        });
        
        this.shieldDuration = 15.0;
        this.deflectionChance = 0.7; // 70% chance to deflect projectiles
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xE0FFFF,
                    colorRange: { start: 0xE0FFFF, end: 0x87CEEB },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 2.5
                }
            },
            shield: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xAFEEEE,
                    scaleMultiplier: 2.5,
                    speedMultiplier: 1.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Use when there are allies to protect and enemies with projectiles nearby
        const enemies = this.getEnemiesInRange(casterEntity, 300);
        return allies.length >= 1 && enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Protective winds swirl around allies!`);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.createWindShields(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    createWindShields(casterEntity) {
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        sortedAllies.forEach(allyId => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            if (!allyPos) return;
            // Shield effect
            this.createVisualEffect(allyPos, 'shield');            
            
            // DESYNC SAFE: Add shield component using scheduling system for duration
            const Components = this.game.componentManager.getComponents();
            this.game.addComponent(allyId, this.componentTypes.BUFF, 
                Components.Buff('wind_shield', { 
                    deflectionChance: this.deflectionChance,
                    projectileReflection: true
                }, this.game.state.now + this.shieldDuration, false, 1, this.game.state.now));
            
            // DESYNC SAFE: Schedule shield removal
            this.game.schedulingSystem.scheduleAction(() => {
                if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
                    const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                    if (buff && buff.buffType === 'wind_shield') {
                        this.game.removeComponent(allyId, this.componentTypes.BUFF);
                        
                        // Visual effect when shield expires
                        const currentPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                        if (currentPos) {
                            this.createVisualEffect(currentPos, 'shield', { 
                                count: 3, 
                                scaleMultiplier: 0.5,
                                color: 0x87CEEB 
                            });
                        }
                    }
                }
            }, this.shieldDuration, allyId);
        });
    }
};

// ability: CorruptingAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CorruptingAuraAbility'] = class CorruptingAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'corrupting_aura',
            name: 'Corrupting Aura',
            description: 'Emanate dark energy that drains enemies and empowers undead (does not stack)',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            corruption: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Oathbreaker spreads corrupting darkness!");
        
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        const allies = this.getAlliesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process enemies - drain their health
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Apply drain damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'divine', {
                    isCorruption: true,
                    tickIndex: tickIndex
                });
                
                // Visual corruption effect
                this.createVisualEffect(enemyPos, 'corruption', { heightOffset: 10 });
            }
        });
        
        // Process allies - empower undead
        sortedAllies.forEach(allyId => {
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!unitType || !allyPos) return;
            
            // Check if this is an undead unit
            if (unitType.id === 'skeleton' || unitType.title.includes('undead') || unitType.title.includes('Skeleton')) {
                const distance = Math.sqrt(
                    Math.pow(allyPos.x - casterPos.x, 2) + 
                    Math.pow(allyPos.z - casterPos.z, 2)
                );
                
                if (distance <= this.range) {
                    // Check if already has empowerment buff
                    const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
                    
                    if (!existingBuff || existingBuff.buffType !== 'dark_empowerment') {
                        const Components = this.game.componentManager.getComponents();
                        this.game.addComponent(allyId, this.componentTypes.BUFF, 
                            Components.Buff('dark_empowerment', { 
                                damageMultiplier: 1.3,
                                attackSpeedMultiplier: 1.2
                            }, this.game.state.now + 3.0, false, 1, this.game.state.now));
                        
                        // Visual empowerment effect
                        this.createVisualEffect(allyPos, 'empowerment', { heightOffset: 5 });
                    }
                }
            }
        });
        
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'corruption', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 15 
            });
        }
    }
};

// ability: EnchantWeaponAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['EnchantWeaponAbility'] = class EnchantWeaponAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'enchant_weapon',
            name: 'Enchant Weapon',
            description: 'Enchant ally weapons with elemental damage (does not stack, refreshes duration)',
            cooldown: 12.0,
            range: 100,
            manaCost: 35,
            targetType: 'allies',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            ...params
        });
        
        this.elementalDamage = 15;
        this.duration = 30.0; // 30 seconds
        this.availableElements = ['fire', 'cold', 'lightning'];
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFFA500 },
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.5
                }
            },
            enchant_fire: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF4500,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            },
            enchant_cold: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00BFFF,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            },
            enchant_lightning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFFF00,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Only use if there are allies to enchant (excluding self)
        return allies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Enchanter begins weaving magical enhancements!`);
        
        // DESYNC SAFE: Use scheduling system for enchantment application
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyWeaponEnchantments(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    applyWeaponEnchantments(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let enchantedCount = 0;
        
        sortedAllies.forEach((allyId, index) => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            
            // Only enchant living allies
            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;
            
            // DESYNC SAFE: Check if already enchanted - don't stack enchantments
            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            
            // DESYNC SAFE: Select element deterministically based on ally index and game time
            const selectedElement = this.selectDeterministicElement(allyId, index);
            
            if (existingBuff && existingBuff.buffType === 'enchant_weapon') {
                // DESYNC SAFE: Refresh duration and update element
                existingBuff.endTime = this.game.state.now + this.duration;
                existingBuff.appliedTime = this.game.state.now;
                existingBuff.modifiers.weaponElement = selectedElement;
            } else {
                // Apply new weapon enchantment
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(allyId, this.componentTypes.BUFF, 
                    Components.Buff('enchant_weapon', { 
                        weaponElement: selectedElement,
                        elementalDamage: this.elementalDamage,
                        glowing: true
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
                
                // DESYNC SAFE: Schedule enchantment removal
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeEnchantment(allyId);
                }, this.duration, allyId);
            }
            
            // Visual enchantment effect based on element
            this.createVisualEffect(allyPos, `enchant_${selectedElement}`);
            
            enchantedCount++;
        });
        
        // Screen effect for successful enchantment
        if (this.game.effectsSystem && enchantedCount > 0) {
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);
        }
        
     
    }
    
    // DESYNC SAFE: Select element deterministically instead of randomly
    selectDeterministicElement(allyId, allyIndex) {
        // Create a deterministic "random" value based on ally ID, game time, and index
        const seed = parseInt(allyId) + Math.floor(this.game.state.now * 100) + allyIndex;
        const pseudoRandom = (seed * 9301 + 49297) % 233280; // Simple PRNG
        const elementIndex = Math.floor((pseudoRandom / 233280) * this.availableElements.length);
        
        return this.availableElements[elementIndex];
    }
    
    // Alternative deterministic selection method (cycle through elements)
    selectCyclicElement(allyIndex) {
        return this.availableElements[allyIndex % this.availableElements.length];
    }
    
    // DESYNC SAFE: Remove enchantment effect
    removeEnchantment(allyId) {
        // Check if ally still exists and has the enchantment buff
        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'enchant_weapon') {
                const element = buff.modifiers.weaponElement || 'fire';
                
                this.game.removeComponent(allyId, this.componentTypes.BUFF);
                
                // Visual effect when enchantment expires
                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                if (allyPos) {
                    this.createVisualEffect(allyPos, `enchant_${element}`, { 
                        count: 3, 
                        scaleMultiplier: 0.6,
                        speedMultiplier: 0.8
                    });
                }
                
              
            }
        }
    }
    
    // Helper method to get enchantment color for UI/effects
    getElementColor(element) {
        switch (element) {
            case 'fire': return 0xFF4500;
            case 'cold': return 0x00BFFF;
            case 'lightning': return 0xFFFF00;
            default: return 0xFFD700;
        }
    }
    
    // Helper method to get element damage type for combat system integration
    getElementDamageType(element) {
        switch (element) {
            case 'fire': return 'fire';
            case 'cold': return 'cold';
            case 'lightning': return 'lightning';
            default: return 'magic';
        }
    }
};

// ability: PhalanxFormationAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PhalanxFormationAbility'] = class PhalanxFormationAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'phalanx_formation',
            name: 'Phalanx Formation',
            description: 'Link with nearby Hoplites - more Hoplites = stronger formation bonus',
            cooldown: 2.0,
            range: 80,
            manaCost: 0,
            targetType: 'allies',
            animation: 'cast',
            priority: 7,
            castTime: 1.2,
            ...params
        });
        
        this.formationDuration = 25.0;
        this.baseArmorMultiplier = 1.15; // 15% base armor bonus
        this.perHopliteBonus = 0.15;     // Additional 15% per hoplite
        this.maxArmorMultiplier = 2.0;   // Cap at 200%
        this.baseCounterChance = 0.2;    // 20% base counter attack chance
        this.perHopliteCounterBonus = 0.05; // +5% per hoplite
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    colorRange: { start: 0x4169E1, end: 0xB0C4DE },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            formation: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            phalanx: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x87CEEB,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if caster already has a phalanx buff to prevent re-casting
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'phalanx') return false;
        
        // Must have at least one nearby hoplite ally (not counting self)
        const nearbyHoplites = this.getNearbyHoplites(casterEntity);
        return nearbyHoplites.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterUnitType = this.game.getComponent(casterEntity, this.componentTypes.UNIT_TYPE);
        
        if (!casterPos || !casterUnitType) return null;
        
        const nearbyHoplites = this.getNearbyHoplites(casterEntity);
        if (nearbyHoplites.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, 
            `Hoplite begins forming phalanx with ${nearbyHoplites.length} allies...`);
        
        // Schedule the formation creation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createPhalanxFormation(casterEntity, nearbyHoplites);
        }, this.castTime, casterEntity);
    }
    
    createPhalanxFormation(casterEntity, nearbyHoplites) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Sort hoplites deterministically for consistent processing
        const sortedHoplites = nearbyHoplites.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const phalanxSize = sortedHoplites.length + 1; // Include caster
        const armorMultiplier = Math.min(
            this.baseArmorMultiplier + (phalanxSize * this.perHopliteBonus), 
            this.maxArmorMultiplier
        );
        const counterAttackChance = this.baseCounterChance + (phalanxSize * this.perHopliteCounterBonus);
        
        // Create formation effect at caster position
        this.createVisualEffect(casterPos, 'formation');
        
        // Apply formation buff to all Hoplites in range (including caster)
        const allHoplites = [casterEntity, ...sortedHoplites];
        let formationSuccess = 0;
        
        // Process hoplites in deterministic order
        allHoplites.forEach((hopliteId, index) => {
            // Validate hoplite still exists and is a hoplite
            const unitType = this.game.getComponent(hopliteId, this.componentTypes.UNIT_TYPE);
            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
            
            if (!unitType || !position || unitType.id !== 'hoplite') return;
            
            // Apply phalanx buff
            const Components = this.game.componentManager.getComponents();
            const currentTime = this.game.state.now || this.game.state.now || 0;
            const endTime = currentTime + this.formationDuration;
            
            this.game.addComponent(hopliteId, this.componentTypes.BUFF, 
                Components.Buff(
                    'phalanx', 
                    { 
                        armorMultiplier: armorMultiplier,
                        counterAttackChance: counterAttackChance,
                        formationSize: phalanxSize,
                        formationLeader: casterEntity,
                        formationRole: (hopliteId === casterEntity) ? 'leader' : 'member'
                    }, 
                    endTime,     // Proper end time
                    false,       // Not stackable
                    1,           // Single stack  
                    currentTime  // Applied time
                )
            );
            
            // Create phalanx effect on each member
            this.createVisualEffect(position, 'phalanx');
            
            // Schedule a delayed formation link effect for visual appeal
            this.game.schedulingSystem.scheduleAction(() => {
                const pos = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'formation', { 
                        count: 3, 
                        scaleMultiplier: 1.0 
                    });
                }
            }, index * 0.2, hopliteId); // Staggered visual effects
            
            formationSuccess++;
        });
        
        // Screen effects for dramatic formation
        if (this.game.effectsSystem && formationSuccess > 0) {
            this.game.effectsSystem.playScreenFlash('#4169E1', 0.4);
        }
    
      
        
        // Schedule formation expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnFormationEnding(allHoplites);
        }, this.formationDuration - 2.0, casterEntity);
    }
    
    // FIXED: Deterministic nearby hoplite detection
    getNearbyHoplites(casterEntity) {
        const allAllies = this.getAlliesInRange(casterEntity);
        
        // Filter and sort hoplites deterministically
        const hoplites = allAllies.filter(allyId => {
            if (allyId === casterEntity) return false; // Exclude self
            
            const unitType = this.game.getComponent(allyId, this.componentTypes.UNIT_TYPE);
            return unitType && unitType.id === 'hoplite';
        });
        
        // Sort deterministically for consistent processing
        return hoplites.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    // FIXED: Formation ending warning
    warnFormationEnding(hopliteIds) {
        let activeFormationMembers = 0;
        
        hopliteIds.forEach(hopliteId => {
            // Check if hoplite still exists and has the phalanx buff
            const buff = this.game.getComponent(hopliteId, this.componentTypes.BUFF);
            const position = this.game.getComponent(hopliteId, this.componentTypes.POSITION);
            
            if (!buff || buff.buffType !== 'phalanx' || !position) return;
            
            // Create warning effect
            this.createVisualEffect(position, 'cast', { 
                count: 3, 
                color: 0x4169E1,
                scaleMultiplier: 0.8 
            });
            
            activeFormationMembers++;
        });
       
    }
};

// ability: BurningAuraAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BurningAuraAbility'] = class BurningAuraAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'burning_aura',
            name: 'Burning Aura',
            description: 'Emanate heat that burns nearby enemies',
            cooldown: 0,
            range: 100,
            manaCost: 0,
            targetType: 'area',
            animation: 'cast',
            priority: 6,
            castTime: 0,
            ...params
        });
        this.drainPerSecond = 8;
        this.duration = 12.0; // 12 seconds instead of 1200 seconds
        this.tickInterval = 1.0; // 1 second between ticks
        this.hasActiveAura = false;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x000000 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            },
            burning: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            empowerment: {
                type: 'fire',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Only allow one active aura per caster
        return !this.hasActiveAura;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!pos) return;
        
        this.createVisualEffect(pos, 'cast');
        
        // Mark aura as active
        this.hasActiveAura = true;
        
        // DESYNC SAFE: Schedule all aura ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeAuraTick(casterEntity, tickIndex, totalTicks);
            }, tickDelay, casterEntity);
        }
        
        // DESYNC SAFE: Schedule aura cleanup
        this.game.schedulingSystem.scheduleAction(() => {
            this.hasActiveAura = false;
        }, this.duration, casterEntity);
    }
    
    // DESYNC SAFE: Execute a single aura tick deterministically
    executeAuraTick(casterEntity, tickIndex, totalTicks) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) {
            // Caster is dead, end the aura early
            this.hasActiveAura = false;
            return;
        }
        
        // DESYNC SAFE: Get enemies and allies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        
        // Sort for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process enemies - burn their health
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.range) {
                // Apply burn damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.drainPerSecond, 'fire', {
                    tickIndex: tickIndex
                });
                
                // Visual corruption effect
                this.createVisualEffect(enemyPos, 'burning', { heightOffset: 10 });
            }
        });
        // Additional visual effects every few ticks
        if (tickIndex % 3 === 0) {
            this.createVisualEffect(casterPos, 'burning', { 
                count: 6, 
                scaleMultiplier: 2.5,
                heightOffset: 15 
            });
        }
    }
};

// ability: TrackingMark
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['TrackingMark'] = class TrackingMarkAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'tracking_mark',
            name: 'Tracking Mark',
            description: 'Mark an enemy for increased damage - multiple Rangers can mark the same target for stacking effect',
            cooldown: 8.0,
            range: 200,
            manaCost: 20,
            targetType: 'enemy',
            animation: 'cast',
            priority: 7,
            castTime: 1.0,
            ...params
        });
        
        this.markDamageIncrease = 0.25; // 25% per mark
        this.maxMarks = 4; // Cap at 4 marks (100% bonus)
        this.markDuration = 15.0;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    colorRange: { start: 0xFF6347, end: 0xFF4500 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            mark_target: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xDC143C,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 2.0
                }
            },
            tracking_beam: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF0000,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 3.0
                }
            },
            mark_stack: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy to mark
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return null;
        
        // Select target deterministically
        const target = this.selectMarkTarget(enemies, casterEntity);
        if (!target) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Ranger takes aim at their prey...`);
        
        // Schedule the mark application after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyTrackingMark(casterEntity, target);
        }, this.castTime, casterEntity);
    }
    
    applyTrackingMark(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        // Validate target still exists
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth || targetHealth.current <= 0 || !targetPos) {
            this.logAbilityUsage(casterEntity, `Target has vanished from sight!`);
            return;
        }
        
        // Create marking beam effect if caster still exists
        if (casterPos) {
            this.createTrackingBeamEffect(casterPos, targetPos);
        }
        
        // Apply or stack the tracking mark
        const markResult = this.applyOrStackMark(casterEntity, targetId);
        
        // Create appropriate visual effect based on result
        if (markResult.isNewMark) {
            this.createVisualEffect(targetPos, 'mark_target');
        } else if (markResult.wasStacked) {
            this.createVisualEffect(targetPos, 'mark_stack');
        } else {
            // Mark refreshed
            this.createVisualEffect(targetPos, 'tracking_beam');
        }
        
        // Enhanced logging
        this.logMarkResult(casterEntity, targetId, markResult);
    }
    
    applyOrStackMark(casterEntity, targetId) {
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.markDuration;
        
        // Check for existing tracking mark
        let existingMark = this.game.getComponent(targetId, this.componentTypes.BUFF);
        
        if (existingMark && existingMark.buffType === 'marked') {
            // Stack the mark up to the maximum
            if (existingMark.stacks < this.maxMarks) {
                existingMark.stacks++;
                existingMark.damageTakenMultiplier = 1 + (this.markDamageIncrease * existingMark.stacks);
                existingMark.endTime = endTime; // Refresh duration
                existingMark.appliedTime = currentTime; // Update applied time
                
                // Track who applied this stack (for potential future features)
                if (!existingMark.appliedBy) {
                    existingMark.appliedBy = [];
                }
                if (!existingMark.appliedBy.includes(casterEntity)) {
                    existingMark.appliedBy.push(casterEntity);
                }
                
                return {
                    isNewMark: false,
                    wasStacked: true,
                    wasRefreshed: false,
                    currentStacks: existingMark.stacks,
                    damageMultiplier: existingMark.damageTakenMultiplier
                };
            } else {
                // Just refresh duration if at max stacks
                existingMark.endTime = endTime;
                existingMark.appliedTime = currentTime;
                
                return {
                    isNewMark: false,
                    wasStacked: false,
                    wasRefreshed: true,
                    currentStacks: existingMark.stacks,
                    damageMultiplier: existingMark.damageTakenMultiplier
                };
            }
        } else {
            // Apply new tracking mark
            this.game.addComponent(targetId, this.componentTypes.BUFF, 
                Components.Buff(
                    'marked', 
                    { 
                        damageTakenMultiplier: 1 + this.markDamageIncrease,
                        revealed: true,
                        markedBy: casterEntity,
                        appliedBy: [casterEntity]
                    }, 
                    endTime,      // End time
                    true,         // Stackable
                    1,            // Initial stack count
                    currentTime   // Applied time
                )
            );
            
            return {
                isNewMark: true,
                wasStacked: false,
                wasRefreshed: false,
                currentStacks: 1,
                damageMultiplier: 1 + this.markDamageIncrease
            };
        }
    }
    
    createTrackingBeamEffect(casterPos, targetPos) {
        // Create a visual connection between ranger and target
        this.createVisualEffect(casterPos, 'tracking_beam');
        this.createVisualEffect(targetPos, 'tracking_beam');
        
        // Create energy beam if effects system supports it
        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(casterPos.x, casterPos.y + 15, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0xFF6347, linewidth: 3 },
                    animation: { duration: 600, flickerCount: 2 }
                }
            );
        }
    }
    
    logMarkResult(casterEntity, targetId, markResult) {
       
        
    }
    
    // FIXED: Deterministic target selection
    selectMarkTarget(enemies, casterEntity) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Priority 1: Unmarked enemies (new marks are more valuable)
        const unmarkedEnemies = sortedEnemies.filter(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            return !buff || buff.buffType !== 'marked';
        });
        
        if (unmarkedEnemies.length > 0) {
            // Among unmarked enemies, prioritize by distance (closest first)
            return this.selectClosestEnemy(unmarkedEnemies, casterEntity);
        }
        
        // Priority 2: Marked enemies that can be stacked further
        const stackableEnemies = sortedEnemies.filter(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            return buff && buff.buffType === 'marked' && buff.stacks < this.maxMarks;
        });
        
        if (stackableEnemies.length > 0) {
            // Among stackable enemies, prioritize by current stacks (higher first for focused fire)
            return this.selectHighestStackedEnemy(stackableEnemies);
        }
        
        // Priority 3: Any marked enemy (for duration refresh)
        return this.selectClosestEnemy(sortedEnemies, casterEntity);
    }
    
    selectClosestEnemy(enemies, casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos || enemies.length === 0) return null;
        
        let closest = null;
        let closestDistance = Infinity;
        
        enemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use <= for consistent tie-breaking (first in sorted order wins)
            if (distance <= closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    selectHighestStackedEnemy(enemies) {
        let highestStacked = null;
        let highestStacks = 0;
        
        enemies.forEach(enemyId => {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (!buff || buff.buffType !== 'marked') return;
            
            // Use >= for consistent tie-breaking (first in sorted order wins)
            if (buff.stacks >= highestStacks) {
                highestStacks = buff.stacks;
                highestStacked = enemyId;
            }
        });
        
        return highestStacked;
    }
};

// ability: IceShardAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['IceShardAbility'] = class IceShardAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'ice_shard',
            name: 'Ice Shard',
            description: 'Fires piercing ice shards that slow enemies',
            cooldown: 2.5,
            range: 280,
            manaCost: 25,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 0.8,
            autoTrigger: 'enemy_in_range',
            ...params
        });
        
        this.damage = 40;
        this.shardCount = 3;
        this.element = 'cold';
        this.slowDuration = 3.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4488ff,
                    colorRange: { start: 0x4488ff, end: 0xaaffff },
                    scaleMultiplier: 1.0,
                    speedMultiplier: 2.0
                }
            },
            shard: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88bbff,
                    scaleMultiplier: 0.6,
                    speedMultiplier: 3.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Crystalline ice shards pierce the air!`);
        
        // Schedule all shards with staggered timing
        for (let i = 0; i < this.shardCount; i++) {
            const shardDelay = this.castTime + (i * 0.2); // 0.2 second stagger between shards
            
            this.game.schedulingSystem.scheduleAction(() => {
                // Re-get enemies at firing time (some may have died)
                const currentEnemies = this.getEnemiesInRange(casterEntity);
                if (currentEnemies.length > 0) {
                    // DESYNC SAFE: Select target deterministically instead of randomly
                    const target = this.selectDeterministicTarget(currentEnemies, i);
                    if (target) {
                        this.fireIceShard(casterEntity, target);
                    }
                }
            }, shardDelay, casterEntity);
        }
    }
    
    // DESYNC SAFE: Deterministic target selection instead of random
    selectDeterministicTarget(enemies, shardIndex) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Use shard index to cycle through targets deterministically
        const targetIndex = shardIndex % sortedEnemies.length;
        return sortedEnemies[targetIndex];
    }
    
    fireIceShard(casterEntity, targetId) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // Visual effect at launch
        this.createVisualEffect(casterPos, 'shard');
        
        // Deal damage with slowing effect
        this.dealDamageWithEffects(casterEntity, targetId, this.damage, this.element, {
            isIceShard: true,
            slowDuration: this.slowDuration
        });
        
        // DESYNC SAFE: Use scheduling system for visual effect delay
        this.game.schedulingSystem.scheduleAction(() => {
            const currentTargetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (currentTargetPos) {
                this.createVisualEffect(currentTargetPos, 'shard', { count: 3 });
            }
        }, 0.3, casterEntity);
    }
};

// ability: MineGoldAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MineGoldAbility'] = class MineGoldAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, abilityData) {
        super(game, abilityData);
        this.id = 'mineGold';
        this.name = 'Mine Gold';
        this.description = 'Automatically mines gold from gold mines';
        this.isPassive = true;
        this.autocast = true;
        this.enabled = true;
        this.castTime = 0;
        this.cooldown = 0;
        this.priority = 0;
        
        this.goldPerTrip = 10;
        this.miningRange = 25;
        this.depositRange = 25;
        this.miningDuration = 2;
        this.depositDuration = 1;
        this.waitingDistance = 30; // Distance to wait from mine when queued
    }

    canExecute(entityId) {
        if(!this.enabled){
            return false;
        }
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        let miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        if (!miningState) {
            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);

            this.game.addComponent(entityId, ComponentTypes.MINING_STATE, {
                state: 'idle',
                targetMineEntityId: null,
                targetMinePosition: null,
                targetTownHall: null,
                waitingPosition: null,
                hasGold: false,
                miningStartTime: 0,
                depositStartTime: 0,
                team: team?.team,
                entityId: entityId
            });
            miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        }

        // Autocast behavior: only activate mining if there's NO current command
        const currentCommand = this.game.gameManager.call('getCurrentCommand', entityId);

        // If there's a current command, don't execute mining
        if (currentCommand) {
            return false;
        }

        // No current command - activate mining (autocast)
        // If we were interrupted (controller was changed), reset mining state to idle
        const currentAIController = this.game.aiSystem.getCurrentAIControllerId(entityId);
        if(currentAIController !== ComponentTypes.MINING_STATE){
            // Mining was interrupted, reset state to idle so it can start fresh
            miningState.state = 'idle';
            miningState.targetMineEntityId = null;
            miningState.targetMinePosition = null;
            miningState.targetTownHall = null;
            miningState.waitingPosition = null;
            miningState.miningStartTime = 0;
            miningState.depositStartTime = 0;
            // Note: Keep hasGold if they were carrying gold when interrupted

            let currentMiningStateAI = this.game.aiSystem.getAIControllerData(entityId, ComponentTypes.MINING_STATE);
            this.game.aiSystem.setCurrentAIController(entityId, ComponentTypes.MINING_STATE, currentMiningStateAI);
        }

        return true;
    }

    execute(entityId, targetData) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
        const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
        const vel = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
        
        if (!miningState || !pos || !vel || !health || health.current <= 0) {
            this.enabled = false;
            return null;
        }
        this.updateMinerState(entityId, miningState, pos, vel);
        return null;
    }

    updateMinerState(entityId, miningState, pos, vel) {
        miningState.entityId = entityId;
        switch (miningState.state) {
            case 'idle':
                this.findMineTarget(miningState);
                break;
            case 'walking_to_mine':
                this.walkToMine(miningState, pos, vel);
                break;
            case 'waiting_at_mine':
                this.waitAtMine(miningState, pos, vel);
                break;
            case 'mining':
                this.mineGold(miningState);
                break;
            case 'walking_to_hall':
                this.walkToTownHall(miningState, pos, vel);
                break;
            case 'depositing':
                this.depositGold(miningState);
                break;
        }
    }

    findMineTarget(miningState) {
        let closestMine = null;
        let closestDistance = Infinity;
        let closestMineEntityId = null;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const pos = this.game.getComponent(miningState.entityId, ComponentTypes.POSITION);
        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);

        if (!pos) return;

        // Get sorted mine entityIds for deterministic iteration
        const sortedMineIds = Array.from(this.game.goldMineSystem.claimedGoldMines.keys()).sort((a, b) =>
            String(a).localeCompare(String(b))
        );

        // Search through all claimed gold mines in deterministic order
        for (const mineEntityId of sortedMineIds) {
            const goldMine = this.game.goldMineSystem.claimedGoldMines.get(mineEntityId);

            // Check if this mine belongs to our team
            if (goldMine.team === miningState.team) {
                // Calculate distance to this mine
                const dx = goldMine.worldPosition.x - pos.x;
                const dz = goldMine.worldPosition.z - pos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);

                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestMine = goldMine;
                    closestMineEntityId = mineEntityId;
                }
            }
        }

        if (!closestMine) {
            return;
        }

        miningState.targetMineEntityId = closestMineEntityId;
        miningState.targetMinePosition = {
            x: closestMine.worldPosition.x,
            y: closestMine.worldPosition.y || 0,
            z: closestMine.worldPosition.z
        };
        miningState.state = 'walking_to_mine';

        if (aiState && aiState.targetPosition != miningState.targetMinePosition) {
            aiState.targetPosition = miningState.targetMinePosition;
            aiState.path = [];
            aiState.meta = {};
        }
    }

    findTownHall(miningState) {
        const CT = this.game.componentManager.getComponentTypes();
        const combatUnits = this.game.getEntitiesWith(CT.POSITION, CT.TEAM, CT.UNIT_TYPE);        
        const aiState = this.game.getComponent(miningState.entityId, CT.AI_STATE);
        const pos = this.game.getComponent(miningState.entityId, CT.POSITION);
        
        if (!pos) return;
        
        let closestTownHall = null;
        let closestDistance = Infinity;
    
        for (let i = 0; i < combatUnits.length; i++) {
            const entityId = combatUnits[i];
            const townHallPos = this.game.getComponent(entityId, CT.POSITION);
            const unitType = this.game.getComponent(entityId, CT.UNIT_TYPE);
            const team = this.game.getComponent(entityId, CT.TEAM);
        
            if (team.team == miningState.team && unitType.id == "townHall") {
                // Calculate distance to this town hall
                const dx = townHallPos.x - pos.x;
                const dz = townHallPos.z - pos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
            
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestTownHall = { x: townHallPos.x, y: townHallPos.y, z: townHallPos.z };
                }
            }
        }
        
        if (closestTownHall) {
            miningState.targetTownHall = closestTownHall;
            if (aiState) {
                aiState.targetPosition = miningState.targetTownHall;
                aiState.path = [];
                aiState.meta = {};
            }
        }
    }

    walkToMine(miningState, pos, vel) {
        if (!miningState.targetMinePosition || !miningState.targetMineEntityId) {
            this.findMineTarget(miningState);
            if (!miningState.targetMinePosition) {
                miningState.state = 'idle';
                return;
            }
        }

        const mine = this.game.goldMineSystem.claimedGoldMines.get(miningState.targetMineEntityId);
        if (!mine || mine.team !== miningState.team) {
            // Mine no longer exists or changed teams - reset to idle
            miningState.targetMineEntityId = null;
            miningState.targetMinePosition = null;
            miningState.waitingPosition = null;
            miningState.state = 'idle';
            return;
        }

        const dx = miningState.targetMinePosition.x - pos.x;
        const dz = miningState.targetMinePosition.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);


        if (dist < this.miningRange) {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            const mineEntityId = miningState.targetMineEntityId;
            const isOccupied = this.game.goldMineSystem.isMineOccupied(mineEntityId);
            const currentOccupant = this.game.goldMineSystem.getCurrentMiner(mineEntityId);

            if (isOccupied && currentOccupant !== miningState.entityId) {
                // Mine is occupied, need to wait
                const queuePosition = this.game.goldMineSystem.getQueuePosition(mineEntityId, miningState.entityId);
                const waitPos = this.getWaitingPosition(miningState.targetMinePosition, queuePosition);
                
                miningState.waitingPosition = waitPos;
                miningState.state = 'waiting_at_mine';

                if (aiState) {
                    aiState.state = 'chasing';
                    aiState.targetPosition = waitPos;
                }
            } else if (!isOccupied) {
                // Mine is free, start mining
                if (aiState) {
                    aiState.state = 'idle';
                    aiState.targetPosition = null;
                }
                pos.x = miningState.targetMinePosition.x;
                pos.z = miningState.targetMinePosition.z;
                vel.vx = 0;
                vel.vz = 0;
                miningState.state = 'mining';
                miningState.miningStartTime = this.game.state.now;
            }
        } else {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState && aiState.targetPosition != miningState.targetMinePosition) {
                aiState.state = 'chasing';
                aiState.targetPosition = miningState.targetMinePosition;        
                aiState.path = [];                        
                aiState.meta = {};
            }
        }
    }

    walkToTownHall(miningState, pos, vel) {
        if (!miningState.targetTownHall) {
            this.findTownHall(miningState);
            if (!miningState.targetTownHall) {
                miningState.state = 'idle';
                return;
            }
        }

        const dx = miningState.targetTownHall.x - pos.x;
        const dz = miningState.targetTownHall.z - pos.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < this.depositRange) {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
            }
            pos.x = miningState.targetTownHall.x - 5;
            pos.z = miningState.targetTownHall.z - 5;
            vel.vx = 0;
            vel.vz = 0;
            miningState.state = 'depositing';
            miningState.depositStartTime = this.game.state.now;
        } else {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);
            
            if (aiState && aiState.targetPosition != miningState.targetTownHall) {
                aiState.state = 'chasing';
                aiState.targetPosition = miningState.targetTownHall;
                aiState.path = [];
                aiState.meta = {};
            }
        }
    }

    waitAtMine(miningState, pos, vel) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const aiState = this.game.getComponent(miningState.entityId, ComponentTypes.AI_STATE);

        // Check if we're next in queue
        const isNextInQueue = this.game.goldMineSystem.isNextInQueue(
            miningState.targetMineEntityId, 
            miningState.entityId
        );
        
        const isMineOccupied = this.game.goldMineSystem.isMineOccupied(miningState.targetMineEntityId);
        
        // If we're next and the mine is free, start mining
        if (isNextInQueue && !isMineOccupied) {
            // The goldMineSystem.processNextInQueue will be called from mineGold when mining completes
            // But we can also transition directly here if we detect we're next
            if (aiState) {
                aiState.state = 'idle';
                aiState.targetPosition = null;
            }
            pos.x = miningState.targetMinePosition.x;
            pos.z = miningState.targetMinePosition.z;
            vel.vx = 0;
            vel.vz = 0;
            
            miningState.state = 'mining';
            miningState.miningStartTime = this.game.state.now;
            miningState.waitingPosition = null;
        } else {
            // Otherwise stay at waiting position
            if (miningState.waitingPosition && aiState && aiState.state !== 'idle') {
                aiState.state = 'idle';
                aiState.targetPosition = null;
                pos.x = miningState.waitingPosition.x;
                pos.z = miningState.waitingPosition.z;
                vel.vx = 0;
                vel.vz = 0;
            }
        }
    }

    getWaitingPosition(minePosition, queuePosition) {
        // Line up miners in a row next to each other
        // Each miner stands 10 units apart
        const spacing = 10;
        const offsetX = queuePosition * spacing;
        
        return {
            x: minePosition.x + this.waitingDistance + offsetX,
            y: minePosition.y,
            z: minePosition.z
        };
    }

    mineGold(miningState) {
        const elapsed = this.game.state.now - miningState.miningStartTime;
        
        if (elapsed >= this.miningDuration) {
            miningState.hasGold = true;
            miningState.goldAmt = 10;

            if(this.game.state.teams){
                let teamState = this.game.state.teams[miningState.team];
                if(teamState && teamState.effects){
                    let teamStateEffects = teamState.effects;
                    if(teamStateEffects['goldPerTrip']){
                        let goldPerTrip = teamStateEffects['goldPerTrip'];
                        if(goldPerTrip && goldPerTrip.value){
                            miningState.goldAmt += goldPerTrip.value;
                        }
                    }
                }
            }
            
            // Change state first, then process queue
            miningState.state = 'walking_to_hall';
            
            // Process next miner in queue now that this mine is free
            if (miningState.targetMineEntityId) {
                this.game.goldMineSystem.processNextInQueue(miningState.targetMineEntityId);
            }
            
            this.findTownHall(miningState);
        }
    }

    depositGold(miningState) {
        const elapsed = this.game.state.now - miningState.depositStartTime;
        
        if (elapsed >= this.depositDuration) {
            this.awardGold(miningState.team, miningState.goldAmt);
            miningState.hasGold = false;
            this.findMineTarget(miningState);
        }
    }

    awardGold(team, goldAmt) {
        if (this.game.isServer) {
            const room = this.game.room;
            for (const [playerId, player] of room.players) {
                if(player.stats.side == team){
                    player.stats.gold += goldAmt;
                    break;
                }
            }
        } else {
            if (team === this.game.state.mySide) {
                this.game.state.playerGold += goldAmt;
            }
        }
    }
    
    logAbilityUsage(entityId) {
        // Passive ability, no logging needed
    }
};

// ability: CurseAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['CurseAbility'] = class CurseAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'curse',
            name: 'Curse',
            description: 'Curses enemies, reducing their damage and making them vulnerable',
            cooldown: 7.0,
            range: 180,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            autoTrigger: 'strong_enemies',
            ...params
        });
        
        this.curseRadius = 100;
        this.damageReduction = 0.5; // Reduce enemy damage by 50%
        this.vulnerabilityIncrease = 1.3; // 30% more damage taken
        this.duration = 20.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    colorRange: { start: 0x2F4F4F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            curse: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x696969,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Dark magic weakens the enemy forces!`);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyCurses(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    applyCurses(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Sort enemies for consistent processing order
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const cursedEnemies = [];
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            if (!enemyPos || !enemyCombat || !enemyHealth || enemyHealth.current <= 0) return;
            
            // Check if enemy is in curse radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.curseRadius) {
                // Apply curse effect visually
                this.createVisualEffect(enemyPos, 'curse');
                
                // DESYNC SAFE: Use buff system instead of directly modifying stats
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(enemyId, this.componentTypes.BUFF, 
                    Components.Buff('curse', { 
                        damageMultiplier: this.damageReduction,
                        damageTakenMultiplier: this.vulnerabilityIncrease,
                        isCursed: true
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
                
                // Create dark aura effect
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createAuraEffect(
                        enemyPos.x, enemyPos.y, enemyPos.z,
                        'magic',
                        this.duration * 1000
                    );
                }
                
                cursedEnemies.push({
                    id: enemyId,
                    originalDamage: enemyCombat.damage,
                    position: enemyPos
                });
                
                // DESYNC SAFE: Schedule curse removal using scheduling system
                this.game.schedulingSystem.scheduleAction(() => {
                    this.removeCurse(enemyId);
                }, this.duration, enemyId);
            }
        });
        
      
    }
    
    // DESYNC SAFE: Remove curse effect
    removeCurse(enemyId) {
        // Check if enemy still exists and has the curse buff
        if (this.game.hasComponent(enemyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(enemyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'curse') {
                this.game.removeComponent(enemyId, this.componentTypes.BUFF);
                
                // Visual effect when curse expires
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (enemyPos) {
                    this.createVisualEffect(enemyPos, 'curse', { 
                        count: 1, 
                        scaleMultiplier: 0.8,
                        color: 0x808080 
                    });
                }
                
            
            }
        }
    }
};

// ability: BlizzardAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BlizzardAbility'] = class BlizzardAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'blizzard',
            name: 'Blizzard',
            description: 'Summons a devastating blizzard that freezes all enemies',
            cooldown: 5.0,
            range: 300,
            manaCost: 0,
            targetType: 'auto',
            animation: 'cast',
            priority: 10,
            castTime: 2.5,
            autoTrigger: 'many_enemies',
            ...params
        });
        
        this.damage = 3;
        this.blizzardRadius = 150;
        this.duration = 3.0;
        this.tickInterval = 0.4;
        this.element = 'cold';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88ccff,
                    colorRange: { start: 0x88ccff, end: 0xffffff },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            blizzard: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xaaddff,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 3;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `An arctic blizzard engulfs the battlefield!`, true);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.createBlizzard(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    createBlizzard(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Screen effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#aaffff', 0.6);
        }
        
        // DESYNC SAFE: Schedule all blizzard ticks using the scheduling system
        const totalTicks = Math.floor(this.duration / this.tickInterval);
        
        for (let tickIndex = 0; tickIndex < totalTicks; tickIndex++) {
            const tickDelay = this.tickInterval * tickIndex;
            
            this.game.schedulingSystem.scheduleAction(() => {
                this.executeBlizzardTick(casterEntity, tickIndex);
            }, tickDelay, casterEntity);
        }
    }
    
    // DESYNC SAFE: Execute a single blizzard tick deterministically
    executeBlizzardTick(casterEntity, tickIndex) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Get all enemies deterministically
        const allEnemies = this.getEnemiesInRange(casterEntity, 1000); // Very large range to cover battlefield
        
        if (allEnemies.length === 0) return;
        
        // Sort enemies deterministically for consistent processing order
        const sortedEnemies = allEnemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            
            // Only affect living enemies
            if (enemyPos && enemyHealth && enemyHealth.current > 0) {
                // Create localized blizzard effect at each enemy
                this.createVisualEffect(enemyPos, 'blizzard', { count: 3 });
                
                // Apply cold damage
                this.dealDamageWithEffects(casterEntity, enemyId, this.damage, this.element, {
                    isBlizzard: true,
                    tickIndex: tickIndex
                });
            }
        });
        
        // Additional visual flair for certain ticks
        if (tickIndex === 0 || tickIndex % 3 === 0) {
            // Create additional atmospheric effects on key ticks
            const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
            if (casterPos) {
                this.createVisualEffect(casterPos, 'blizzard', { 
                    count: 8, 
                    scaleMultiplier: 2.5,
                    heightOffset: 20 
                });
            }
        }
    }
};

// ability: SummonWolfAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['SummonWolfAbility'] = class SummonWolfAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'summon_wolf',
            name: 'Summon Wolf',
            description: 'Call forth a loyal wolf companion (max 1 per Beast Master)',
            cooldown: 0.0,
            range: 0,
            manaCost: 50,
            targetType: 'self',
            animation: 'cast',
            priority: 5,
            castTime: 1.0,
            ...params
        });
        this.hasSummon = false;
        this.summonId = '0_skeleton';
        this.summonedWolfId = null; // Track the specific summoned wolf
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x228b22,
                    colorRange: { start: 0x228b22, end: 0x90ee90 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            },
            summon: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x32cd32,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if this Beast Master already has a summoned wolf that's still alive
        if (this.summonedWolfId) {
            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);
            const wolfDeathState = this.game.getComponent(this.summonedWolfId, this.componentTypes.DEATH_STATE);
            
            // If wolf is dead or dying, reset our tracking
            if (!wolfHealth || wolfHealth.current <= 0 || (wolfDeathState && wolfDeathState.isDying)) {
                this.hasSummon = false;
                this.summonedWolfId = null;
            }
        }
        
        return !this.hasSummon;
    }
    
    execute(casterEntity) {
        const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const team = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        if (!pos || !team) return;
        
        // Immediate cast effect
        this.createVisualEffect(pos, 'cast');
        this.logAbilityUsage(casterEntity, "Beast Master summons a faithful wolf!");
        
        // DESYNC SAFE: Use scheduling system for summoning
        this.game.schedulingSystem.scheduleAction(() => {
            this.performSummon(casterEntity, pos, team);
        }, this.castTime, casterEntity);
    }
    
    performSummon(casterEntity, summonPos, team) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        if (!casterHealth || casterHealth.current <= 0) return;
        
        // DESYNC SAFE: Find deterministic summon position
        const wolfPosition = this.findSummonPosition(summonPos);
        
        // Create wolf companion
        const wolfId = this.createSummonedCreature(wolfPosition, this.summonId, team.team, casterEntity);
        
        if (wolfId) {
            this.hasSummon = true;
            this.summonedWolfId = wolfId;
            
            // Summon effect at wolf position
            this.createVisualEffect(wolfPosition, 'summon');
            
            // Screen effect for dramatic summoning
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenShake(0.15, 1);
            }
        }
    }
    
    // DESYNC SAFE: Find a valid summon position deterministically
    findSummonPosition(basePos) {
        // Try positions in a deterministic pattern around the caster
        const offsets = [
            { x: 30, z: 0 },    // Right
            { x: -30, z: 0 },   // Left
            { x: 0, z: 30 },    // Forward
            { x: 0, z: -30 },   // Back
            { x: 21, z: 21 },   // Diagonal positions
            { x: -21, z: 21 },
            { x: 21, z: -21 },
            { x: -21, z: -21 }
        ];
        
        // Try each position in order until we find a valid one
        for (const offset of offsets) {
            const testPos = {
                x: basePos.x + offset.x,
                y: basePos.y,
                z: basePos.z + offset.z
            };
            
            // Simple position validation (could be enhanced with collision checking)
            if (this.isValidSummonPosition(testPos)) {
                return testPos;
            }
        }
        
        // Fallback to right side of caster if no valid position found
        return {
            x: basePos.x + 30,
            y: basePos.y,
            z: basePos.z
        };
    }
    
    isValidSummonPosition(pos) {
        // Basic validation - ensure position is within reasonable bounds
        // This could be enhanced with collision detection if needed
        return pos.x >= -1000 && pos.x <= 1000 && pos.z >= -1000 && pos.z <= 1000;
    }
    
    createSummonedCreature(pos, unitDefId, team, summoner) {
        try {
            const creatureId = this.game.createEntity();
            const components = this.game.componentManager.getComponents();
            const componentTypes = this.game.componentManager.getComponentTypes();
            
            // Get unit definition for stats (with fallbacks)
            const collections = this.game.getCollections();
            const unitDef = collections?.units?.[unitDefId] || {
                hp: 60,
                damage: 25,
                range: 30,
                attackSpeed: 1.2,
                speed: 40,
                size: 20
            };
            
            // Add all standard unit components
            this.game.addComponent(creatureId, componentTypes.POSITION, 
                components.Position(pos.x, pos.y, pos.z));
            
            this.game.addComponent(creatureId, componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, (unitDef.speed) * 20));
            
            this.game.addComponent(creatureId, componentTypes.RENDERABLE, 
                components.Renderable("units", unitDefId));
            
            this.game.addComponent(creatureId, componentTypes.HEALTH, 
                components.Health(unitDef.hp));
            
            this.game.addComponent(creatureId, componentTypes.COMBAT, 
                components.Combat(unitDef.damage, unitDef.range, unitDef.attackSpeed));
            
            this.game.addComponent(creatureId, componentTypes.COLLISION, 
                components.Collision(unitDef.size, unitDef.height));
            
            this.game.addComponent(creatureId, componentTypes.TEAM, 
                components.Team(team));
            
            this.game.addComponent(creatureId, componentTypes.UNIT_TYPE, 
                components.UnitType(unitDefId, 'Summoned Wolf', 0));
            
            this.game.addComponent(creatureId, componentTypes.AI_STATE, 
                components.AIState('idle'));
            
            this.game.addComponent(creatureId, componentTypes.ANIMATION, 
                components.Animation());
            
            this.game.addComponent(creatureId, componentTypes.FACING, 
                components.Facing(0));
            
            // DESYNC SAFE: Use game time for summoned component
            this.game.addComponent(creatureId, componentTypes.SUMMONED, 
                components.Summoned(summoner, unitDefId, null, this.game.state.now || 0));
            
            return creatureId;
        } catch (error) {
            console.error('Failed to create summoned creature:', error);
            return null;
        }
    }
    
    // Helper method to clean up when the summoner dies
    onSummonerDeath(summonerId) {
        if (this.summonedWolfId && this.game.hasComponent(this.summonedWolfId, this.componentTypes.HEALTH)) {
            // Kill the summoned wolf when summoner dies
            const wolfHealth = this.game.getComponent(this.summonedWolfId, this.componentTypes.HEALTH);
            if (wolfHealth && wolfHealth.current > 0) {
                wolfHealth.current = 0;
                
                // Trigger death system for the wolf
                if (this.game.deathSystem) {
                    this.game.deathSystem.handleEntityDeath(this.summonedWolfId);
                }
            }
        }
        
        this.hasSummon = false;
        this.summonedWolfId = null;
    }
};

// ability: PiercingShotAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['PiercingShotAbility'] = class PiercingShotAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'piercing_shot',
            name: 'Piercing Shot',
            description: 'Fire a bolt that pierces through multiple enemies',
            cooldown: 6.0,
            range: 200,
            manaCost: 25,
            targetType: 'line',
            animation: 'attack',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.piercingDamage = 45;
        this.lineWidth = 20; // Width of the piercing line
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4682B4,
                    colorRange: { start: 0x4682B4, end: 0x87CEEB },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 1.5
                }
            },
            beam_charge: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x6495ED,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            piercing_beam: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xB0C4DE,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 2.5
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0x4169E1,
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Need at least one enemy in range to pierce
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterFacing = this.game.getComponent(casterEntity, this.componentTypes.FACING);
        
        if (!casterPos || !casterFacing) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Crossbow charges a piercing bolt...`);
        
        // Schedule the piercing shot after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.firePiercingShot(casterEntity, casterPos, casterFacing);
        }, this.castTime, casterEntity);
    }
    
    firePiercingShot(casterEntity, casterPos, casterFacing) {
        // Calculate piercing line end position
        const endPos = this.calculateLineEndPosition(casterPos, casterFacing);
        
        // Create beam charging effect
        this.createVisualEffect(casterPos, 'beam_charge');
        
        // Schedule visual beam effect slightly before damage
        this.game.schedulingSystem.scheduleAction(() => {
            this.createPiercingBeamEffect(casterPos, endPos);
        }, 0.2, casterEntity);
        
        // Schedule damage application
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyPiercingDamage(casterEntity, casterPos, endPos);
        }, 0.3, casterEntity);
    }
    
    createPiercingBeamEffect(startPos, endPos) {
        // Create piercing beam visual effect
        this.createVisualEffect(startPos, 'piercing_beam');
        this.createVisualEffect(endPos, 'piercing_beam', { 
            count: 6, 
            scaleMultiplier: 1.5 
        });
        
        // Create energy beam if effects system supports it
        if (this.game.effectsSystem && this.game.effectsSystem.createEnergyBeam) {
            this.game.effectsSystem.createEnergyBeam(
                new THREE.Vector3(startPos.x, startPos.y + 15, startPos.z),
                new THREE.Vector3(endPos.x, endPos.y + 15, endPos.z),
                {
                    style: { color: 0x4682B4, linewidth: 4 },
                    animation: { duration: 800, flickerCount: 2 }
                }
            );
        }
    }
    
    applyPiercingDamage(casterEntity, startPos, endPos) {
        // Get all enemies in range and filter those hit by the line
        const enemies = this.getEnemiesInRange(casterEntity, this.range);
        const hitEnemies = this.getEnemiesInLine(enemies, startPos, endPos);
        
        if (hitEnemies.length === 0) {
            this.logAbilityUsage(casterEntity, `Piercing bolt finds no targets!`);
            return;
        }
        
        // Sort hit enemies by distance along the line for consistent damage application
        const sortedHitEnemies = this.sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos);
        
        // Apply damage to each enemy in order
        sortedHitEnemies.forEach((enemyData, index) => {
            const { enemyId, position } = enemyData;
            
            // Apply piercing damage
            this.dealDamageWithEffects(casterEntity, enemyId, this.piercingDamage, this.element, {
                isPiercing: true,
                piercingIndex: index,
                totalPierced: sortedHitEnemies.length
            });
            
            // Create impact effect at each enemy position
            this.createVisualEffect(position, 'impact');
            
         
        });
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem && sortedHitEnemies.length > 1) {
            this.game.effectsSystem.playScreenShake(0.4, 2);
        }
        
        this.logAbilityUsage(casterEntity, 
            `Crossbow bolt pierces through ${sortedHitEnemies.length} enemies!`);
    }
    
    // FIXED: Deterministic line end position calculation
    calculateLineEndPosition(startPos, facing) {
        return {
            x: startPos.x + Math.cos(facing.angle) * this.range,
            y: startPos.y,
            z: startPos.z + Math.sin(facing.angle) * this.range
        };
    }
    
    // FIXED: Deterministic enemy filtering in line
    getEnemiesInLine(enemies, startPos, endPos) {
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        const hitEnemies = [];
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            if (this.isInLine(startPos, endPos, enemyPos, this.lineWidth)) {
                hitEnemies.push({
                    enemyId: enemyId,
                    position: { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z }
                });
            }
        });
        
        return hitEnemies;
    }
    
    // FIXED: More precise and deterministic line-point distance calculation
    isInLine(start, end, point, width) {
        if (!point) return false;
        
        // Calculate line parameters more precisely
        const lineLength = Math.sqrt(
            Math.pow(end.x - start.x, 2) + Math.pow(end.z - start.z, 2)
        );
        
        if (lineLength < 0.001) return false; // Avoid division by zero
        
        // Calculate perpendicular distance from point to line
        const A = end.z - start.z;
        const B = start.x - end.x;
        const C = end.x * start.z - start.x * end.z;
        
        const distance = Math.abs(A * point.x + B * point.z + C) / Math.sqrt(A * A + B * B);
        
        // Also check if point is within the line segment bounds
        const dotProduct = (point.x - start.x) * (end.x - start.x) + (point.z - start.z) * (end.z - start.z);
        const projectionRatio = dotProduct / (lineLength * lineLength);
        
        // Point must be within line width and within line segment bounds
        return distance <= width && projectionRatio >= 0 && projectionRatio <= 1;
    }
    
    // FIXED: Sort enemies by distance along line for consistent ordering
    sortEnemiesByDistanceAlongLine(hitEnemies, startPos, endPos) {
        return hitEnemies.slice().sort((a, b) => {
            // Calculate distance from start of line for each enemy
            const distanceA = Math.sqrt(
                Math.pow(a.position.x - startPos.x, 2) + 
                Math.pow(a.position.z - startPos.z, 2)
            );
            const distanceB = Math.sqrt(
                Math.pow(b.position.x - startPos.x, 2) + 
                Math.pow(b.position.z - startPos.z, 2)
            );
            
            // Sort by distance from caster, then by entity ID for tie-breaking
            if (Math.abs(distanceA - distanceB) < 0.001) {
                return String(a.enemyId).localeCompare(String(b.enemyId));
            }
            return distanceA - distanceB;
        });
    }
};

// ability: Tornado
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['Tornado'] = class CurseAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'curse',
            name: 'Curse',
            description: 'Curses enemies, reducing their damage and making them vulnerable',
            cooldown: 7.0,
            range: 180,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 5,
            castTime: 1.5,
            autoTrigger: 'strong_enemies',
            ...params
        });
        
        this.curseRadius = 100;
        this.damageReduction = 0.5; // Reduce enemy damage by 50%
        this.vulnerabilityIncrease = 1.3; // 30% more damage taken
        this.duration = 20.0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x2F4F4F,
                    colorRange: { start: 0x2F4F4F, end: 0x000000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.8
                }
            },
            curse: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x696969,
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.applyCurses(casterEntity, enemies);
        }, this.castTime, casterEntity);
    }
    
    applyCurses(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        enemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyCombat = this.game.getComponent(enemyId, this.componentTypes.COMBAT);
            
            if (!enemyPos || !enemyCombat) return;
            
            // Check if enemy is in curse radius
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            if (distance <= this.curseRadius) {
                // Apply curse effect
                this.createVisualEffect(enemyPos, 'curse');
                
                // Reduce enemy damage
                const originalDamage = enemyCombat.damage;
                enemyCombat.damage = Math.floor(enemyCombat.damage * this.damageReduction);
                
                // Create dark aura effect
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createAuraEffect(
                        enemyPos.x, enemyPos.y, enemyPos.z,
                        'magic',
                        this.duration * 1000
                    );
                }
                        
                this.game.schedulingSystem.scheduleAction(() => {
                    if (this.game.getComponent(enemyId, this.componentTypes.COMBAT)) {
                        enemyCombat.damage = originalDamage;
                    }
                }, this.duration, enemyId);

            }
        });
    }
}
;

// ability: LightningBoltAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['LightningBoltAbility'] = class LightningBoltAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'lightning_bolt',
            name: 'Lightning Bolt',
            description: 'Instantly strikes an enemy with pure lightning',
            cooldown: 2.0,
            range: 350,
            manaCost: 30,
            targetType: 'auto',
            animation: 'cast',
            priority: 7,
            castTime: 0.5,
            autoTrigger: 'enemy_in_range',
            ...params
        });
        
        this.damage = 55;
        this.criticalChance = 0.3; // 30% crit chance
        this.element = 'lightning';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 1,
                    color: 0xffff44,
                    colorRange: { start: 0xffff44, end: 0xffffff },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 4.0
                }
            },
            lightning: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0xffffaa,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 5.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // DESYNC SAFE: Find target with highest health deterministically
        const target = this.findHighestHealthEnemy(enemies);
        if (!target) return;
        
        const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Lightning crackles with divine fury!`, true);
        
        this.game.schedulingSystem.scheduleAction(() => {
            this.strikeLightning(casterEntity, target, targetPos);
        }, this.castTime, casterEntity);
    }
    
    strikeLightning(casterEntity, targetId, targetPos) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create lightning bolt visual effect
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createLightningBolt(
                new THREE.Vector3(casterPos.x, casterPos.y + 50, casterPos.z),
                new THREE.Vector3(targetPos.x, targetPos.y + 10, targetPos.z),
                {
                    style: { color: 0xffffaa, linewidth: 6 },
                    animation: { duration: 400, flickerCount: 3 }
                }
            );
        }
        
        // Lightning effect at target
        this.createVisualEffect(targetPos, 'lightning');
        
        // Screen flash
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenFlash('#ffffaa', 0.15);
        }
        
        // DESYNC SAFE: Determine critical hit deterministically instead of random
        const isCritical = this.isDeterministicCritical(casterEntity, targetId);
        const damage = isCritical ? this.damage * 2 : this.damage;
        
        // Apply lightning damage
        this.dealDamageWithEffects(casterEntity, targetId, damage, this.element, {
            isCritical: isCritical,
            isInstant: true
        });
    }
    
    // DESYNC SAFE: Deterministic critical hit calculation
    isDeterministicCritical(casterId, targetId) {
        // Create a deterministic "random" value based on entity IDs and game time
        const seed = parseInt(casterId) + parseInt(targetId) + Math.floor(this.game.state.now * 100);
        const pseudoRandom = (seed * 9301 + 49297) % 233280 / 233280; // Simple PRNG
        
        return pseudoRandom < this.criticalChance;
    }
    
    // DESYNC SAFE: Deterministic highest health enemy finding
    findHighestHealthEnemy(enemies) {
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let strongest = null;
        let highestHealth = 0;
        
        sortedEnemies.forEach(enemyId => {
            const health = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            if (health && health.current >= highestHealth) { // Use >= for consistent tie-breaking
                highestHealth = health.current;
                strongest = enemyId;
            }
        });
        
        return strongest;
    }
};

// ability: RageAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['RageAbility'] = class RageAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'raging_strike',
            name: 'Raging Strike',
            description: 'Unleash primal fury with increased damage and attack speed',
            cooldown: 5.0,
            range: 0, // Self-buff
            manaCost: 20,
            targetType: 'self',
            animation: 'attack',
            priority: 6,
            castTime: 0.8,
            ...params
        });
        
        this.rageDuration = 8.0;
        this.damageMultiplier = 1.5;
        this.attackSpeedMultiplier = 1.3;
        this.element = 'physical';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xff4444, 
                    colorRange: { start: 0xff4444, end: 0xff8800 },
                    scaleMultiplier: 1.3,
                    speedMultiplier: 1.5
                }
            },
            rage: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xff0000, 
                    scaleMultiplier: 1.8,
                    speedMultiplier: 2.0
                }
            },
            fury: {
                type: 'magic',
                options: { 
                    count: 3, 
                    color: 0xcc0000, 
                    scaleMultiplier: 2.2,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        // Check if there are enemies nearby to rage against
        const enemies = this.getEnemiesInRange(casterEntity, 100);
        if (enemies.length === 0) return false;
        
        // Don't stack rage buffs - check if already raged
        const existingBuff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (existingBuff && existingBuff.buffType === 'rage') return false;
        
        return true;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Primal fury begins to build...`);
        
        // Schedule the rage activation after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.activateRage(casterEntity);
        }, this.castTime, casterEntity);
    }
    
    activateRage(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Create dramatic rage effects
        this.createVisualEffect(casterPos, 'rage');
        
        // Schedule a secondary fury effect for visual impact
        this.game.schedulingSystem.scheduleAction(() => {
            if (this.game.hasComponent && this.game.hasComponent(casterEntity, this.componentTypes.POSITION)) {
                const pos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
                if (pos) {
                    this.createVisualEffect(pos, 'fury');
                }
            }
        }, 0.5, casterEntity);
        
        // Apply rage buff with proper timing
        const Components = this.game.componentManager.getComponents();
        const currentTime = this.game.state.now || this.game.state.now || 0;
        const endTime = currentTime + this.rageDuration;
        
        this.game.addComponent(casterEntity, this.componentTypes.BUFF, 
            Components.Buff(
                'rage', 
                { 
                    damageMultiplier: this.damageMultiplier, 
                    attackSpeedMultiplier: this.attackSpeedMultiplier,
                    moveSpeedMultiplier: 1.1 // Slight movement speed bonus
                }, 
                endTime,     // Proper end time
                false,       // Not stackable
                1,           // Single stack
                currentTime  // Applied time
            )
        );
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 2);
            this.game.effectsSystem.playScreenFlash('#ff4444', 0.4);
        }
    
        
        // Schedule buff expiration warning
        this.game.schedulingSystem.scheduleAction(() => {
            this.warnRageEnding(casterEntity);
        }, this.rageDuration - 1.0, casterEntity);
    }
    
    // FIXED: Add rage ending warning for better gameplay feedback
    warnRageEnding(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        // Check if entity still exists and has the buff
        const buff = this.game.getComponent(casterEntity, this.componentTypes.BUFF);
        if (!buff || buff.buffType !== 'rage') return;
        
        if (casterPos) {
            // Create fading effect
            this.createVisualEffect(casterPos, 'cast', { 
                count: 5, 
                color: 0x884444,
                scaleMultiplier: 0.8 
            });
        }
       
    }
};

// ability: BattleCryAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['BattleCryAbility'] = class BattleCryAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'battle_cry',
            name: 'Battle Cry',
            description: 'Rally nearby allies, boosting their damage and morale (does not stack)',
            cooldown: 15.0,
            range: 150,
            manaCost: 40,
            targetType: 'allies',
            animation: 'cast',
            priority: 8,
            castTime: 1.0,
            ...params
        });
        
        this.damageMultiplier = 1.3; // 30% damage boost
        this.duration = 20.0; // 20 seconds
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFFD700,
                    colorRange: { start: 0xFFD700, end: 0xFF4500 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 1.5
                }
            },
            rally: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xFF6347,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        // Only use if there are at least 2 allies to rally (including potentially the caster)
        return allies.length >= 2;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        // DESYNC SAFE: Use scheduling system for the rally effect
        this.game.schedulingSystem.scheduleAction(() => {
            this.performBattleCry(casterEntity);
        }, this.castTime, casterEntity);
        
        // Log immediately when cast starts
        const allies = this.getAlliesInRange(casterEntity);
        this.logAbilityUsage(casterEntity, `Warlord rallies ${allies.length} allies to battle!`, true);
    }
    
    performBattleCry(casterEntity) {
        // Check if caster is still alive
        const casterHealth = this.game.getComponent(casterEntity, this.componentTypes.HEALTH);
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        
        if (!casterHealth || casterHealth.current <= 0 || !casterPos) return;
        
        // DESYNC SAFE: Get and sort allies deterministically
        const allies = this.getAlliesInRange(casterEntity);
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let ralliedCount = 0;
        
        sortedAllies.forEach(allyId => {
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            const allyHealth = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            
            // Only rally living allies
            if (!allyPos || !allyHealth || allyHealth.current <= 0) return;
            
            // DESYNC SAFE: Check if already rallied - don't stack multiple battle cries
            const existingBuff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            
            if (existingBuff && existingBuff.buffType === 'rallied') {
                // DESYNC SAFE: Refresh duration instead of stacking
                existingBuff.endTime = this.game.state.now + this.duration;
                existingBuff.appliedTime = this.game.state.now; // Update applied time
            } else {
                // Apply new rally buff
                const Components = this.game.componentManager.getComponents();
                this.game.addComponent(allyId, this.componentTypes.BUFF, 
                    Components.Buff('rallied', { 
                        damageMultiplier: this.damageMultiplier, 
                        moralBoost: true, 
                        fearImmunity: true 
                    }, this.game.state.now + this.duration, false, 1, this.game.state.now));
            }
            
            // Visual rally effect on each ally
            this.createVisualEffect(allyPos, 'rally');
            
            // DESYNC SAFE: Schedule buff removal
            this.game.schedulingSystem.scheduleAction(() => {
                this.removeRallyBuff(allyId);
            }, this.duration, allyId);
            
            ralliedCount++;
        });
        
        // Screen effect for dramatic rally
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.3, 2);
            this.game.effectsSystem.playScreenFlash('#FFD700', 0.4);
        }
        
        // Additional visual effect at caster position
        this.createVisualEffect(casterPos, 'rally', { 
            count: 12, 
            scaleMultiplier: 3.0,
            heightOffset: 20 
        });
 
    }
    
    // DESYNC SAFE: Remove rally buff
    removeRallyBuff(allyId) {
        // Check if ally still exists and has the rally buff
        if (this.game.hasComponent(allyId, this.componentTypes.BUFF)) {
            const buff = this.game.getComponent(allyId, this.componentTypes.BUFF);
            if (buff && buff.buffType === 'rallied') {
                this.game.removeComponent(allyId, this.componentTypes.BUFF);
                
                // Visual effect when rally expires
                const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
                if (allyPos) {
                    this.createVisualEffect(allyPos, 'rally', { 
                        count: 2, 
                        scaleMultiplier: 0.8,
                        color: 0xCD853F 
                    });
                }
       
            }
        }
    }
};

// ability: MeteorStrikeAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MeteorStrikeAbility'] = class MeteorStrikeAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'meteor_strike',
            name: 'Meteor Strike',
            description: 'Devastating strike on the densest enemy formation',
            cooldown: 5.0,
            range: 300,
            manaCost: 0,
            targetType: 'enemies',
            animation: 'cast',
            priority: 10,
            castTime: 1.0,
            ...params
        });
        
        this.damage = 200;
        this.splashRadius = 120;
        this.delay = 3.0;
        this.element = 'fire';
        this.minTargets = 0;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xffaa00 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            warning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff0000,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            meteor_explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 4.0,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);        
        return enemies.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        const targetPos = this.findBestClusterPosition(enemies, this.minTargets);
        
        if (!targetPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `A massive meteor approaches from the heavens!`);
        
        // Schedule warning indicator after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.createMeteorWarning(targetPos);
        }, this.castTime, casterEntity);
        
        // Schedule meteor impact after cast time + delay
        this.game.schedulingSystem.scheduleAction(() => {
            this.meteorImpact(casterEntity, targetPos);
        }, this.castTime + this.delay, casterEntity);
    }
    
    createMeteorWarning(position) {
        // Create warning effect instead of entity for better desync safety
        this.createVisualEffect(position, 'warning');
        
        // Schedule repeated warning effects during the delay period
        const warningInterval = 0.5;
        const warningCount = Math.floor(this.delay / warningInterval);
        
        for (let i = 1; i < warningCount; i++) {
            this.game.schedulingSystem.scheduleAction(() => {
                this.createVisualEffect(position, 'warning');
            }, i * warningInterval, null);
        }
        
        this.logAbilityUsage(null, `The ground trembles as a meteor approaches!`);
    }
    
    meteorImpact(casterEntity, position) {
        // Create massive explosion effect
        this.createVisualEffect(position, 'meteor_explosion');
        
        // Screen effects for dramatic impact
        if (this.game.effectsSystem) {
            this.game.effectsSystem.playScreenShake(0.8, 4);
            this.game.effectsSystem.playScreenFlash('#ff4400', 0.5);
        }
        
        // Apply splash damage
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                position,
                this.damage,
                this.element,
                this.splashRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
         
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length === 0) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential impact center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within splash radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.splashRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Calculate score: prioritize more targets, then lower total distance for tie-breaking
            const score = (targetsInRange * 1000) - totalDistance;
            
            // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
            if (targetsInRange > maxTargetsHit || 
                (targetsInRange === maxTargetsHit && score >= bestScore)) {
                maxTargetsHit = targetsInRange;
                bestScore = score;
                bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
            }
        });
        
        // If no good cluster found but we have enemies, target the first enemy deterministically
        if (!bestPosition && sortedEnemies.length > 0) {
            const firstEnemyPos = this.game.getComponent(sortedEnemies[0], this.componentTypes.POSITION);
            if (firstEnemyPos) {
                bestPosition = { x: firstEnemyPos.x, y: firstEnemyPos.y, z: firstEnemyPos.z };
            }
        }
        
        return bestPosition;
    }
};

// ability: FireStormAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FireStormAbility'] = class FirestormAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'fireStorm',
            name: 'Fire Storm',
            description: 'Rain fire on the largest enemy cluster',
            cooldown: 12.0,
            range: 200,
            manaCost: 50,
            targetType: 'auto',
            animation: 'cast',
            priority: 8,
            castTime: 2.5,
            autoTrigger: 'enemy_cluster',
            ...params
        });
        
        this.stormRadius = 90;
        this.damage = 70;
        this.element = 'fire';
        this.minTargets = 3;
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    colorRange: { start: 0xff2200, end: 0xffaa00 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            firestorm: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff0000 },
                    scaleMultiplier: 2.5,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);
        return clusterPos !== null;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const enemies = this.getEnemiesInRange(casterEntity);
        const clusterPos = this.findBestClusterPosition(enemies, this.minTargets);
        
        if (!clusterPos) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `The sky darkens as firestorm approaches!`);
        
        // Schedule the firestorm to hit after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performFirestorm(casterEntity, clusterPos);
        }, this.castTime, casterEntity);
    }
    
    performFirestorm(casterEntity, targetPos) {
        // Create firestorm visual effect
        this.createVisualEffect(targetPos, 'firestorm');
        
        // Apply fire damage to all enemies in storm area
        if (this.game.damageSystem) {
            const results = this.game.damageSystem.applySplashDamage(
                casterEntity,
                targetPos,
                this.damage,
                this.element,
                this.stormRadius,
                { allowFriendlyFire: false, isSpell: true }
            );
            
            this.logAbilityUsage(casterEntity, 
                `Firestorm engulfs ${results.length} enemies in flames!`);
        }
    }
    
    // FIXED: Deterministic cluster position finding
    findBestClusterPosition(enemies, minTargets) {
        if (enemies.length < minTargets) return null;
        
        // Sort enemies deterministically first for consistent processing
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let bestPosition = null;
        let maxTargetsHit = 0;
        let bestScore = 0; // For tie-breaking: prefer positions with lower total distance
        
        // Check each enemy position as potential cluster center
        sortedEnemies.forEach(potentialCenter => {
            const centerPos = this.game.getComponent(potentialCenter, this.componentTypes.POSITION);
            if (!centerPos) return;
            
            let targetsInRange = 0;
            let totalDistance = 0;
            
            // Count enemies within storm radius of this position
            sortedEnemies.forEach(enemyId => {
                const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
                if (!enemyPos) return;
                
                const distance = Math.sqrt(
                    Math.pow(enemyPos.x - centerPos.x, 2) + 
                    Math.pow(enemyPos.z - centerPos.z, 2)
                );
                
                if (distance <= this.stormRadius) {
                    targetsInRange++;
                    totalDistance += distance;
                }
            });
            
            // Only consider positions that hit minimum targets
            if (targetsInRange >= minTargets) {
                // Calculate score: prioritize more targets, then lower total distance for tie-breaking
                const score = (targetsInRange * 1000) - totalDistance;
                
                // Use >= for consistent tie-breaking (first in sorted order wins when scores are equal)
                if (targetsInRange > maxTargetsHit || 
                    (targetsInRange === maxTargetsHit && score >= bestScore)) {
                    maxTargetsHit = targetsInRange;
                    bestScore = score;
                    bestPosition = { x: centerPos.x, y: centerPos.y, z: centerPos.z };
                }
            }
        });
        
        return bestPosition;
    }
};

// ability: RaiseDeadAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['RaiseDeadAbility'] = class RaiseDeadAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'raise_dead',
            name: 'Raise Dead',
            description: 'Convert corpses into skeleton warriors',
            cooldown: 1.0,
            range: 150,
            manaCost: 0,
            targetType: 'auto',
            animation: 'cast',
            priority: 1,
            castTime: 1.0,
            autoTrigger: 'corpses_available',
            ...params
        });
        
        this.maxCorpsesToRaise = 4;
        this.raisedUnitType = '0_skeleton';
        this.element = 'dark';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x4B0082,
                    colorRange: { start: 0x4B0082, end: 0x8B008B },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            raise_dead: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x8B008B,
                    colorRange: { start: 0x8B008B, end: 0x32CD32 },
                    scaleMultiplier: 2.0,
                    speedMultiplier: 0.5
                }
            },
            necromancy: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x228B22,
                    scaleMultiplier: 1.8,
                    speedMultiplier: 1.2
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        if (!this.game.deathSystem) return false;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return false;
        
        const validCorpses = this.getValidCorpsesInRange(casterPos);
        return validCorpses.length > 0;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        
        if (!this.game.deathSystem || !casterPos || !casterTeam) return null;
        
        const validCorpses = this.getValidCorpsesInRange(casterPos);
        if (validCorpses.length === 0) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Dark magic stirs the dead...`);
        
        // Schedule the necromancy after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performRaiseDeadRitual(casterEntity, validCorpses, casterTeam.team);
        }, this.castTime, casterEntity);
    }
    
    performRaiseDeadRitual(casterEntity, validCorpses, team) {
        const collections = this.game.getCollections();
        if (!collections?.units?.[this.raisedUnitType]) {
            console.warn(`${this.raisedUnitType} unit type not found`);
            return;
        }
        
        const skeletonDef = collections.units[this.raisedUnitType];
        
        // Sort corpses deterministically for consistent processing order
        const sortedCorpses = this.sortCorpsesDeterministically(validCorpses);
        const corpsesToRaise = sortedCorpses.slice(0, this.maxCorpsesToRaise);
        
        let raisedCount = 0;
        const raisedSkeletons = [];
        
        // Process corpses in deterministic order
        corpsesToRaise.forEach((corpseData, index) => {
            const consumedCorpse = this.game.deathSystem.consumeCorpse(corpseData.entityId);
            if (!consumedCorpse) return;
            
            const skeletonId = this.createSkeletonFromCorpse(
                corpseData.position, 
                skeletonDef, 
                team, 
                index
            );
            
            if (skeletonId !== null) {
                raisedCount++;
                raisedSkeletons.push(skeletonId);
                
                // Create raising effect
                this.createVisualEffect(corpseData.position, 'raise_dead');
                this.logCorpseRaising(consumedCorpse, team);
                
                // Schedule a delayed necromancy effect for dramatic flair
                this.game.schedulingSystem.scheduleAction(() => {
                    this.createVisualEffect(corpseData.position, 'necromancy');
                }, 0.5, skeletonId);
            }
        });
        
        if (raisedCount > 0) {
            this.logAbilityUsage(casterEntity, 
                `Necromancy raises ${raisedCount} skeleton${raisedCount > 1 ? 's' : ''} from the dead!`);
                
            // Screen effect for dramatic impact
            if (this.game.effectsSystem) {
                this.game.effectsSystem.playScreenFlash('#4B0082', 0.4);
            }
        }
    }
    
    // FIXED: Deterministic corpse validation and retrieval
    getValidCorpsesInRange(casterPos) {
        const nearbyCorpses = this.game.deathSystem.getCorpsesInRange(casterPos, this.range);
        
        // Filter out corpses that are already the raised unit type (prevent re-raising skeletons)
        const validCorpses = nearbyCorpses.filter(corpseData => {
            return corpseData.corpse.originalUnitType.id !== this.raisedUnitType;
        });
        
        return validCorpses;
    }
    
    // FIXED: Deterministic corpse sorting
    sortCorpsesDeterministically(corpses) {
        return corpses.slice().sort((a, b) => {
            // Sort by entity ID first for primary determinism
            const idComparison = String(a.entityId).localeCompare(String(b.entityId));
            if (idComparison !== 0) return idComparison;
            
            // Secondary sort by position for additional determinism
            if (a.position.x !== b.position.x) {
                return a.position.x - b.position.x;
            }
            if (a.position.z !== b.position.z) {
                return a.position.z - b.position.z;
            }
            
            return 0;
        });
    }
    
    // FIXED: Deterministic skeleton creation with ordered components
    createSkeletonFromCorpse(corpsePos, skeletonDef, team, creationIndex) {
        const skeletonId = this.game.createEntity ? this.game.createEntity() : null;
        if (skeletonId === null || skeletonId === undefined) return null;
        
        const components = this.game.componentManager.getComponents();
        const componentTypes = this.game.componentManager.getComponentTypes();
        
        // FIXED: Deterministic facing based on creation order, not team
        const initialFacing = (creationIndex % 2 === 0) ? 0 : Math.PI;
        
        try {
            // Add components in deterministic alphabetical order
            this.game.addComponent(skeletonId, componentTypes.AI_STATE, 
                components.AIState('idle'));
                
            this.game.addComponent(skeletonId, componentTypes.ANIMATION, 
                components.Animation());
                
            this.game.addComponent(skeletonId, componentTypes.COLLISION, 
                components.Collision(skeletonDef.size, skeletonDef.height));
                
            this.game.addComponent(skeletonId, componentTypes.COMBAT, 
                components.Combat(
                    skeletonDef.damage || 15, 
                    skeletonDef.range || 25, 
                    skeletonDef.attackSpeed || 1.0,
                    skeletonDef.projectile || null, 
                    0, 
                    skeletonDef.element || 'physical',
                    skeletonDef.armor || 0, 
                    skeletonDef.fireResistance || 0,
                    skeletonDef.coldResistance || 0, 
                    skeletonDef.lightningResistance || 0
                ));
                
            this.game.addComponent(skeletonId, componentTypes.EQUIPMENT, 
                components.Equipment());
                
            this.game.addComponent(skeletonId, componentTypes.FACING, 
                components.Facing(initialFacing));
                
            this.game.addComponent(skeletonId, componentTypes.HEALTH, 
                components.Health(skeletonDef.hp || 50));
                
            this.game.addComponent(skeletonId, componentTypes.POSITION, 
                components.Position(corpsePos.x, corpsePos.y, corpsePos.z));
                
            this.game.addComponent(skeletonId, componentTypes.RENDERABLE, 
                components.Renderable("units", this.raisedUnitType));
                
            this.game.addComponent(skeletonId, componentTypes.TEAM, 
                components.Team(team));
                
            this.game.addComponent(skeletonId, componentTypes.UNIT_TYPE, 
                components.UnitType(
                    this.raisedUnitType, 
                    skeletonDef.title || "Skeleton", 
                    skeletonDef.value || 25
                ));
                
            this.game.addComponent(skeletonId, componentTypes.VELOCITY, 
                components.Velocity(0, 0, 0, (skeletonDef.speed || 1) * 20));
            
            return skeletonId;
            
        } catch (error) {
            console.error(`Failed to create skeleton from corpse:`, error);
            return null;
        }
    }
    
    logCorpseRaising(corpse, team) {
       
    }
};

// ability: MassHealAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['MassHealAbility'] = class MassHealAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'mass_heal',
            name: 'Mass Heal',
            description: 'Heal all injured allies across the battlefield',
            cooldown: 15.0,
            range: 300,
            manaCost: 60,
            targetType: 'auto',
            animation: 'cast',
            priority: 9,
            castTime: 2.0,
            autoTrigger: 'low_team_health',
            ...params
        });
        
        this.healPercent = 0.4; // 40% of max health
        this.minInjuredAllies = 3;
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88ff88,
                    colorRange: { start: 0x88ff88, end: 0xffffaa },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.0
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x88ffaa,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            },
            mass_heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0xaaffaa,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 0.6
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        const injuredAllies = this.getInjuredAllies(allies);
        return injuredAllies.length >= this.minInjuredAllies;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const allies = this.getAlliesInRange(casterEntity);
        const injuredAllies = this.getInjuredAllies(allies);
        
        if (injuredAllies.length < this.minInjuredAllies) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine energy gathers to heal the wounded!`);
        
        // Schedule the mass heal to trigger after cast time
        this.game.schedulingSystem.scheduleAction(() => {
            this.performMassHeal(casterEntity, injuredAllies);
        }, this.castTime, casterEntity);
    }
    
    performMassHeal(casterEntity, targetAllies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        let healedCount = 0;
        let totalHealing = 0;
        
        // Sort allies deterministically for consistent processing order
        const sortedAllies = targetAllies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        // Process each ally deterministically
        sortedAllies.forEach(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            const allyPos = this.game.getComponent(allyId, this.componentTypes.POSITION);
            
            if (!health || !allyPos) return;
            
            // Only heal if ally is still injured
            if (health.current < health.max) {
                const healAmount = Math.floor(health.max * this.healPercent);
                const actualHeal = Math.min(healAmount, health.max - health.current);
                
                if (actualHeal > 0) {
                    // Apply healing
                    health.current += actualHeal;
                    healedCount++;
                    totalHealing += actualHeal;
                    
                    // Create heal effect on each ally
                    this.createVisualEffect(allyPos, 'heal');
                    
                    // Show heal number
                    if (this.game.effectsSystem) {
                        this.game.effectsSystem.showDamageNumber(
                            allyPos.x, allyPos.y + 50, allyPos.z,
                            actualHeal, 'heal'
                        );
                    }
                
                }
            }
        });
        
        // Create major healing effect at caster position
        if (casterPos && healedCount > 0) {
            this.createVisualEffect(casterPos, 'mass_heal');
        }
        
        // Screen effect for dramatic impact
        if (this.game.effectsSystem && healedCount > 0) {
            this.game.effectsSystem.playScreenFlash('#88ff88', 0.3);
        }
        
        // Log final results
        this.logAbilityUsage(casterEntity, 
            `Mass heal restores ${healedCount} allies for ${totalHealing} total health!`);
    }
    
    // FIXED: Deterministic injured ally detection
    getInjuredAllies(allies) {
        // Sort allies deterministically first for consistent processing
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        return sortedAllies.filter(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            // Check if ally is injured (below 80% health threshold)
            return health && health.current < health.max * 0.8;
        });
    }
    
    // Helper method to get all valid heal targets (for future use)
    getAllHealTargets(allies) {
        // Sort allies deterministically first for consistent processing
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        return sortedAllies.filter(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            // Any ally that isn't at full health
            return health && health.current < health.max;
        });
    }
};

// ability: FireBallAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['FireBallAbility'] = class FireballAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'fireBall',
            name: 'Fire Ball',
            description: 'Launch a fiery projectile that explodes on impact',
            cooldown: 5.0,
            range: 150,
            manaCost: 30,
            targetType: 'enemy',
            animation: 'cast',
            priority: 6,
            castTime: 1.5,
            ...params
        });
        
        this.damage = 60;
        this.splashRadius = 80;
        this.element = 'fire';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff8800 },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            },
            projectile: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0xff2200,
                    scaleMultiplier: 0.6,
                    speedMultiplier: 1.5
                }
            },
            explosion: {
                type: 'explosion',
                options: {
                    count: 3,
                    color: 0xff4400,
                    colorRange: { start: 0xff4400, end: 0xff0000 },
                    scaleMultiplier: 1.5,
                    speedMultiplier: 1.2
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0xff0000,
                    scaleMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length > 0;
    }
    
    execute(casterEntity, targetData = null) {
        if (!this.game.projectileSystem) return;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        
        // DESYNC SAFE: Find closest enemy deterministically
        const closestEnemy = this.findClosestEnemy(casterEntity, enemies);
        if (!closestEnemy) return;
        
        this.logAbilityUsage(casterEntity, `Fireball launched at enemy target!`, true);
        
        // DESYNC SAFE: Use scheduling system for projectile firing
        this.game.schedulingSystem.scheduleAction(() => {
            this.fireProjectile(casterEntity, closestEnemy);
        }, this.castTime, casterEntity);
    }
    
    // DESYNC SAFE: Deterministic closest enemy finding
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closestEnemy = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use < for consistent tie-breaking (first in sorted order wins)
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEnemy = enemyId;
            }
        });
        
        return closestEnemy;
    }
    
    fireProjectile(casterEntity, targetId) {
        if (!this.game.projectileSystem) return;
        
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!casterPos || !targetPos) return;
        
        // Create fireball projectile with enhanced effects
        const projectileData = {
            id: 'fireball',
            title: 'Fireball',
            damage: this.damage,
            speed: 80,
            element: this.element,
            ballistic: true,
            splashRadius: this.splashRadius,
            homing: true,
            homingStrength: 0.3,
            onHit: (impactPos) => {
                // Explosion effect
                this.createVisualEffect(impactPos, 'explosion');
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.playScreenShake(0.3, 2);
                }
                
                // DESYNC SAFE: Handle splash damage deterministically
                this.handleSplashDamage(casterEntity, impactPos);
            },
            onTravel: (currentPos) => {
                // Trail effect during flight
                this.createVisualEffect(currentPos, 'projectile', { heightOffset: 0 });
            }
        };
        
        this.game.projectileSystem.fireProjectile(casterEntity, targetId, projectileData);
    }
    
    // DESYNC SAFE: Handle splash damage deterministically
    handleSplashDamage(casterEntity, impactPos) {
        // Get all entities in splash radius
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        
        const casterTeam = this.game.getComponent(casterEntity, this.componentTypes.TEAM);
        if (!casterTeam) return;
        
        const splashTargets = [];
        
        // Find all valid targets in splash radius
        allEntities.forEach(entityId => {
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityTeam || entityTeam.team === casterTeam.team) return;
            
            const distance = Math.sqrt(
                Math.pow(entityPos.x - impactPos.x, 2) + 
                Math.pow(entityPos.z - impactPos.z, 2)
            );
            
            if (distance <= this.splashRadius) {
                splashTargets.push({
                    id: entityId,
                    distance: distance,
                    position: entityPos
                });
            }
        });
        
        // DESYNC SAFE: Sort splash targets deterministically
        splashTargets.sort((a, b) => {
            // Primary sort by distance
            if (Math.abs(a.distance - b.distance) > 0.001) {
                return a.distance - b.distance;
            }
            // Secondary sort by entity ID for deterministic tie-breaking
            return String(a.id).localeCompare(String(b.id));
        });
        
        // Apply splash damage to all targets
        splashTargets.forEach(target => {
            // Calculate damage falloff based on distance
            const damageMultiplier = Math.max(0.3, 1.0 - (target.distance / this.splashRadius));
            const splashDamage = Math.floor(this.damage * damageMultiplier);
            
            // Apply damage
            this.dealDamageWithEffects(casterEntity, target.id, splashDamage, this.element, {
                isSplash: true
            });
            
            // Impact effect on each target
            this.createVisualEffect(target.position, 'impact');
        });
    }
};

// ability: HealAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['HealAbility'] = class HealAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'heal',
            name: 'Heal',
            description: 'Restores health to the most injured ally',
            cooldown: 30,
            range: 200,
            manaCost: 40,
            targetType: 'ally',
            animation: 'cast',
            priority: 8,
            castTime: 1.0,
            autoTrigger: 'injured_ally',
            ...params
        });
        
        this.healAmount = 80;
        this.element = 'divine';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 2,
                    color: 0x88ff88,
                    colorRange: { start: 0x88ff88, end: 0xffffaa },
                    scaleMultiplier: 1.0,
                    speedMultiplier: 1.0
                }
            },
            heal: {
                type: 'heal',
                options: {
                    count: 3,
                    color: 0x88ffaa,
                    scaleMultiplier: 1.2,
                    speedMultiplier: 0.8
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const allies = this.getAlliesInRange(casterEntity);
        return allies.some(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            return health && health.current < health.max; // Ally needs healing
        });
    }
        
    execute(casterEntity, targetData = null) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        const allies = this.getAlliesInRange(casterEntity);
        const target = this.findMostInjuredAlly(allies);
        
        if (!target) return null;
        
        // Show immediate cast effect
        this.createVisualEffect(casterPos, 'cast');
        this.logAbilityUsage(casterEntity, `Divine light mends wounds!`);
        
    
        this.game.schedulingSystem.scheduleAction(() => {
            const targetPos = this.game.getComponent(target, this.componentTypes.POSITION);
            if (targetPos) {
                this.performHeal(casterEntity, target, targetPos);
            }
        }, this.castTime, casterEntity);
    }
    
    performHeal(casterEntity, targetId, targetPos) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        if (!targetHealth) return;
        // Heal effect
        this.createVisualEffect(targetPos, 'heal');
        
        // Apply healing
        const actualHeal = Math.min(this.healAmount, targetHealth.max - targetHealth.current);
        targetHealth.current += actualHeal;
        
        // Show heal number
        if (this.game.effectsSystem) {
            this.game.effectsSystem.showDamageNumber(
                targetPos.x, targetPos.y + 50, targetPos.z,
                actualHeal, 'heal'
            );
        }
        
    
    }
        
    findMostInjuredAlly(allies) {
        // Sort allies deterministically first
        const sortedAllies = allies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let mostInjured = null;
        let lowestHealthRatio = 1.0;
        
        sortedAllies.forEach(allyId => {
            const health = this.game.getComponent(allyId, this.componentTypes.HEALTH);
            if (health && health.max > 0) {
                const healthRatio = health.current / health.max;
                // Use <= for consistent tie-breaking (first in sorted order wins)
                if (healthRatio <= lowestHealthRatio) {
                    lowestHealthRatio = healthRatio;
                    mostInjured = allyId;
                }
            }
        });
        
        return mostInjured;
    }
};

// ability: ChainLightningAbility
window.engine.app.appClasses = window.engine.app.appClasses || {};
window.engine.app.appClasses['ChainLightningAbility'] = class ChainLightningAbility extends engine.app.appClasses['BaseAbility'] {
    constructor(game, params = {}) {
        super(game, {
            id: 'chain_lightning',
            name: 'Chain Lightning',
            description: 'Lightning that jumps between multiple enemies',
            cooldown: 4.0,
            range: 250,
            manaCost: 40,
            targetType: 'enemy',
            animation: 'cast',
            priority: 7,
            castTime: 1,
            ...params
        });
        
        this.initialDamage = 60;
        this.maxJumps = 5;
        this.jumpRange = 70;
        this.damageReduction = 0.8;
        this.element = 'lightning';
    }
    
    defineEffects() {
        return {
            cast: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00aaff,
                    colorRange: { start: 0x00aaff, end: 0x88aaff },
                    scaleMultiplier: 1.2,
                    speedMultiplier: 2.0
                }
            },
            lightning: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x00ccff,
                    scaleMultiplier: 1.5,
                    speedMultiplier: 3.0
                }
            },
            arc: {
                type: 'magic',
                options: {
                    count: 3,
                    color: 0x88aaff,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 2.5
                }
            },
            impact: {
                type: 'damage',
                options: {
                    count: 3,
                    color: 0x00aaff,
                    scaleMultiplier: 1.0
                }
            }
        };
    }
    
    canExecute(casterEntity) {
        const enemies = this.getEnemiesInRange(casterEntity);
        return enemies.length >= 1;
    }
    
    execute(casterEntity) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return;
        
        // DESYNC SAFE: Get and sort enemies deterministically
        const enemies = this.getEnemiesInRange(casterEntity);
        if (enemies.length === 0) return;
        
        // Initial cast effect
        this.createVisualEffect(casterPos, 'cast');
   
        // DESYNC SAFE: Find closest enemy deterministically
        const firstTarget = this.findClosestEnemy(casterEntity, enemies);
        if (!firstTarget) return;
               
        this.startChainLightning(casterEntity, firstTarget, enemies);
    }
    
    // DESYNC SAFE: Start the chain lightning sequence deterministically
    startChainLightning(sourceId, firstTarget, availableTargets) {
        const hitTargets = []; // Track which targets have been hit
        
        // Process the entire chain synchronously to avoid timing issues
        this.processLightningChain(sourceId, firstTarget, availableTargets, hitTargets, this.maxJumps, this.initialDamage, 0);
    }
    
    // DESYNC SAFE: Process the entire lightning chain deterministically
    processLightningChain(sourceId, currentTarget, availableTargets, hitTargets, remainingJumps, damage, jumpIndex) {
        if (remainingJumps <= 0 || !currentTarget || hitTargets.includes(currentTarget)) {
            return;
        }
        
        const targetPos = this.game.getComponent(currentTarget, this.componentTypes.POSITION);
        if (!targetPos) return;
        
        // Add target to hit list
        hitTargets.push(currentTarget);
        
        // Schedule this jump's effects with a small delay for visual appeal
        const jumpDelay = jumpIndex * 0.15; // 150ms between jumps
        
        this.game.schedulingSystem.scheduleAction(() => {
            // Lightning strike effect
            this.createVisualEffect(targetPos, 'lightning');
            
            // Apply damage
            this.dealDamageWithEffects(sourceId, currentTarget, Math.floor(damage), this.element);
            
            // Screen flash for dramatic effect (only on first hit)
            if (this.game.effectsSystem && jumpIndex === 0) {
                this.game.effectsSystem.playScreenFlash('#00aaff', 0.2);
            }
            
            // Create visual arc effect if there was a previous target
            if (jumpIndex > 0) {
                const previousTarget = hitTargets[jumpIndex - 1];
                const previousPos = this.game.getComponent(previousTarget, this.componentTypes.POSITION);
                if (previousPos) {
                    this.createLightningArc(previousPos, targetPos);
                }
            }
        }, jumpDelay, sourceId);
        
        // DESYNC SAFE: Find next target deterministically
        const nextTarget = this.findNextChainTarget(currentTarget, availableTargets, hitTargets);
        
        if (nextTarget && remainingJumps > 1) {
            // Recursively process the next jump
            this.processLightningChain(
                sourceId, 
                nextTarget, 
                availableTargets, 
                hitTargets, 
                remainingJumps - 1, 
                damage * this.damageReduction, 
                jumpIndex + 1
            );
        }
    }
    
    // DESYNC SAFE: Find closest enemy deterministically
    findClosestEnemy(casterEntity, enemies) {
        const casterPos = this.game.getComponent(casterEntity, this.componentTypes.POSITION);
        if (!casterPos) return null;
        
        // Sort enemies deterministically first
        const sortedEnemies = enemies.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedEnemies.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            if (!enemyPos) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - casterPos.x, 2) + 
                Math.pow(enemyPos.z - casterPos.z, 2)
            );
            
            // Use < for consistent tie-breaking (first in sorted order wins)
            if (distance < closestDistance) {
                closestDistance = distance;
                closest = enemyId;
            }
        });
        
        return closest;
    }
    
    // DESYNC SAFE: Find next chain target deterministically
    findNextChainTarget(fromTarget, availableTargets, hitTargets) {
        const fromPos = this.game.getComponent(fromTarget, this.componentTypes.POSITION);
        if (!fromPos) return null;
        
        // Sort targets deterministically first
        const sortedTargets = availableTargets.slice().sort((a, b) => String(a).localeCompare(String(b)));
        
        let closest = null;
        let closestDistance = Infinity;
        
        sortedTargets.forEach(targetId => {
            if (targetId === fromTarget || hitTargets.includes(targetId)) return;
            
            const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
            if (!targetPos) return;
            
            const distance = Math.sqrt(
                Math.pow(targetPos.x - fromPos.x, 2) + 
                Math.pow(targetPos.z - fromPos.z, 2)
            );
            
            // Use < for consistent tie-breaking
            if (distance <= this.jumpRange && distance < closestDistance) {
                closestDistance = distance;
                closest = targetId;
            }
        });
        
        return closest;
    }
    
    createLightningArc(fromPos, toPos) {
        if (!this.game.scene) return;
        
        // Create lightning bolt geometry with deterministic path (no random)
        const points = this.generateDeterministicLightningPath(fromPos, toPos);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        
        // Create lightning material
        const material = new THREE.LineBasicMaterial({
            color: 0x00ddff,
            linewidth: 3,
            transparent: true,
            opacity: 1.0,
            blending: THREE.AdditiveBlending
        });
        
        // Create the lightning line
        const lightningLine = new THREE.Line(geometry, material);
        this.game.scene.add(lightningLine);
        
        // Animate the lightning arc
        this.animateLightningArc(lightningLine, material);
        
        // Add bright points at connection points
        this.createLightningPoints(fromPos, toPos);
    }
    
    // DESYNC SAFE: Generate deterministic lightning path (no random)
    generateDeterministicLightningPath(fromPos, toPos) {
        const points = [];
        const segments = 3; // Number of lightning segments
        
        points.push(new THREE.Vector3(
            fromPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),
            fromPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,
            fromPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)
        ));
        
        // Create jagged lightning path using deterministic values
        for (let i = 1; i < segments; i++) {
            const progress = i / segments;
            
            // Linear interpolation between start and end
            const baseX = fromPos.x + (toPos.x - fromPos.x) * progress;
            const baseY = fromPos.y + (toPos.y - fromPos.y) * progress + 10;
            const baseZ = fromPos.z + (toPos.z - fromPos.z) * progress;
            
            // Add deterministic jagged deviation based on segment index
            const deviation = 15; // Maximum deviation from straight line
            const jaggedX = baseX + (((i * 37) % 100) / 100 - 0.5) * deviation; // Deterministic "random"
            const jaggedY = baseY + (((i * 73) % 100) / 100 - 0.5) * deviation * 0.5;
            const jaggedZ = baseZ + (((i * 91) % 100) / 100 - 0.5) * deviation;
            
            points.push(new THREE.Vector3(
                jaggedX + (this.game.effectsSystem?.effectOffset?.x || 0),
                jaggedY + (this.game.effectsSystem?.effectOffset?.y || 0),
                jaggedZ + (this.game.effectsSystem?.effectOffset?.z || 0)
            ));
        }
        
        points.push(new THREE.Vector3(
            toPos.x + (this.game.effectsSystem?.effectOffset?.x || 0),
            toPos.y + (this.game.effectsSystem?.effectOffset?.y || 0) + 10,
            toPos.z + (this.game.effectsSystem?.effectOffset?.z || 0)
        ));
        
        return points;
    }
    
    animateLightningArc(lightningLine, material) {
        // Use game time for deterministic animation instead of real time
        const startTime = this.game.state.now;
        const animationDuration = 0.48; // 480ms in game time
        const flickerInterval = 0.08; // 80ms in game time
        
        // DESYNC SAFE: Use scheduling system for animation frames
        const animateFrame = (frameIndex) => {
            const currentTime = this.game.state.now;
            const elapsed = currentTime - startTime;
            
            if (elapsed >= animationDuration) {
                // Fade out and remove
                this.fadeLightningArc(lightningLine, material);
                return;
            }
            
            // Deterministic flicker effect based on frame index
            material.opacity = 0.2 + 0.6 * ((frameIndex % 3) / 2); // Cycles between 0.2, 0.5, 0.8
            material.color.setHex((frameIndex % 2) === 0 ? 0x00ddff : 0x88aaff);
            
            // Schedule next frame
            this.game.schedulingSystem.scheduleAction(() => {
                animateFrame(frameIndex + 1);
            }, flickerInterval, null);
        };
        
        animateFrame(0);
    }
    
    fadeLightningArc(lightningLine, material) {
        // Quick cleanup instead of complex fade animation for multiplayer safety
        if (this.game.scene && lightningLine.parent) {
            this.game.scene.remove(lightningLine);
            lightningLine.geometry.dispose();
            lightningLine.material.dispose();
        }
    }
    
    createLightningPoints(fromPos, toPos) {
        // Create bright particle effects at connection points
        if (this.game.effectsSystem) {
            this.game.effectsSystem.createParticleEffect(
                fromPos.x, fromPos.y + 10, fromPos.z, 'magic', {
                    count: 5,
                    color: 0x00ddff,
                    scaleMultiplier: 0.8,
                    speedMultiplier: 2.0,
                    heightOffset: 0
                }
            );
            
            // DESYNC SAFE: Use scheduling system for delayed effect
            this.game.schedulingSystem.scheduleAction(() => {
                if (this.game.effectsSystem) {
                    this.game.effectsSystem.createParticleEffect(
                        toPos.x, toPos.y + 10, toPos.z, 'magic', {
                            count: 5,
                            color: 0x00ddff,
                            scaleMultiplier: 0.8,
                            speedMultiplier: 2.0,
                            heightOffset: 0
                        }
                    );
                }
            }, 0.1, null);
        }
    }
};

// ========== CLASS REGISTRY ACCESSORS ==========

/**
 * Get a compiled class by name and type
 * This replaces the ModuleManager.getCompiledScript method for compiled bundles
 */
window.COMPILED_GAME.getClass = function(className, collectionType) {
    const collection = window.engine.app[collectionType];
    if (!collection) {
        console.error(`Collection ${collectionType} not found in compiled bundle`);
        return null;
    }
    
    const ClassDef = collection[className];
    if (!ClassDef) {
        console.error(`Class ${className} not found in collection ${collectionType}`);
        return null;
    }
    
    return ClassDef;
};

/**
 * Check if a class exists in the compiled bundle
 */
window.COMPILED_GAME.hasClass = function(className, collectionType) {
    const collection = window.engine.app[collectionType];
    return collection && collection[className] !== undefined;
};

// ========== INITIALIZATION ==========

/**
 * Initialize the compiled bundle - patches ModuleManager to prevent duplicate loading
 */
window.COMPILED_GAME.init = function(engine) {
    if (window.COMPILED_GAME.initialized) {
        console.log('Compiled game bundle already initialized');
        return;
    }

    console.log('Initializing compiled game bundle...');

    // Store original methods
    const originalGetCompiledScript = ModuleManager.prototype.getCompiledScript;
    const originalCompileScript = ModuleManager.prototype.compileScript;
    const originalCompileFunction = ModuleManager.prototype.compileFunction;

    // Patch getCompiledScript
    ModuleManager.prototype.getCompiledScript = function(typeName, collectionType) {
        if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
            return window.COMPILED_GAME.getClass(typeName, collectionType);
        }
        return originalGetCompiledScript.call(this, typeName, collectionType);
    };

    // Patch compileScript
    ModuleManager.prototype.compileScript = function(scriptText, typeName) {
        for (const collectionType in window.engine.app) {
            if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
                return window.COMPILED_GAME.getClass(typeName, collectionType);
            }
        }
        return originalCompileScript.call(this, scriptText, typeName);
    };

    // Patch compileFunction
    ModuleManager.prototype.compileFunction = function(scriptText, typeName) {
        if (window.COMPILED_GAME.hasClass(typeName, 'functions')) {
            return window.COMPILED_GAME.getClass(typeName, 'functions');
        }
        return originalCompileFunction.call(this, scriptText, typeName);
    };

    // Patch core.getCollections() to return compiled collections
    if (engine.core && typeof engine.core.getCollections === 'function') {
        const originalGetCollections = engine.core.getCollections.bind(engine.core);
        engine.core.getCollections = function() {
            if (window.COMPILED_GAME?.collections) {
                return window.COMPILED_GAME.collections;
            }
            return originalGetCollections();
        };
    }

    // Make library classes available
    if (engine.moduleManager) {
        engine.moduleManager.libraryClasses = {
            ...engine.moduleManager.libraryClasses,
            ...window.COMPILED_GAME.libraryClasses
        };
        window.GUTS = engine.moduleManager.libraryClasses;
    }

    window.COMPILED_GAME.initialized = true;
    console.log('Compiled game bundle initialized successfully');
};

// Wait for external libraries to load before allowing engine init
window.COMPILED_GAME.ready = new Promise((resolve) => {
    if (window.COMPILED_GAME.externalLibraries && window.COMPILED_GAME.externalLibraries.length > 0) {
        window.addEventListener('compiled-libraries-ready', () => {
            console.log('ðŸŽ® Compiled game ready');
            resolve();
        });
    } else {
        // No external libraries, ready immediately
        resolve();
    }
});