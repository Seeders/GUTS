/**
 * Compiled Game Bundle
 * Project: TurnBasedWarfare
 * Generated: 2025-11-04T23:36:02.144Z
 */

window.engine = {};

// Global bundle namespace
window.COMPILED_GAME = {
    projectName: "TurnBasedWarfare",
    version: "2025-11-04T23:36:02.144Z",
    classRegistry: {},
    libraryClasses: {},
    compiled: true,
    initialized: false
};

// FLAG TO PREVENT DUPLICATE LIBRARY LOADING
window.COMPILED_GAME_LOADED = true;

// ========== LIBRARIES ==========

// Library: BaseECSGame
window.COMPILED_GAME.libraryClasses.BaseECSGame = class BaseECSGame {
    constructor(app) {
        this.app = app;
        this.state = null; // Will be set by subclasses
        this.sceneManager = null; // Will be set by subclasses
        this.moduleManager = app.moduleManager;
        
        this.entityId = 0;
        this.entitiesToAdd = [];
        this.entities = new Map();
        this.components = new Map();
        this.classes = [];
        this.systems = [];
        
        this.nextEntityId = 1;
        this.lastTime = 0;
        this.currentTime = 0;
        this.deltaTime = 0;

        this.isServer = false;        
    }
    init() {
        if(document){
            document.addEventListener('keydown', (e) => {                
                this.triggerEvent('onKeyDown', e.key);
            });
        }
    }
    getEntityId() {
        return this.nextEntityId++;
    }
    getCollections() {
        return this.app.getCollections();
    }

    update(deltaTime) {
  
        if (!this.state.isPaused) {
            this.currentTime = this.currentTime + deltaTime;

            // Only update if a reasonable amount of time has passed
            // const timeSinceLastUpdate = this.currentTime - this.lastTime;

            // // Skip update if more than 1 second has passed (tab was inactive)
            // if (timeSinceLastUpdate > 1000) {
            //     this.lastTime = this.currentTime; // Reset timer without updating
            //     return;
            // }
            this.state.now = this.currentTime;
            this.state.deltaTime = deltaTime;
            this.deltaTime = deltaTime;        

            this.systems.forEach(system => {
                if (system.update) {
                    system.update();
                }
                if(system.render && !this.isServer){
                    system.render();
                }
            });
            
            this.postUpdate();
        }     
    }

    postUpdate() {
       // this.desyncDebugger?.displaySync(false); 
       
        this.lastTime = this.currentTime;
    
        this.entitiesToAdd.forEach((entity) => this.addEntity(entity));        
        this.entitiesToAdd = [];
        
    }

    createEntity(setId) {
        const id = setId || this.getEntityId();
        this.entities.set(id, new Set());
        return id;
    }
    
    destroyEntity(entityId) {
        if (this.entities.has(entityId)) {

            this.systems.forEach(system => {
                if (system.entityDestroyed) {
                    system.entityDestroyed(entityId);                    
                }
            });

            const componentTypes = this.entities.get(entityId);
            componentTypes.forEach(type => {
                this.removeComponent(entityId, type);
            });
            this.entities.delete(entityId);
        }
    }
    
    addComponent(entityId, componentId, componentData) {
        if (!this.entities.has(entityId)) {
            throw new Error(`Entity ${entityId} does not exist`);
        }
        
        if (!this.components.has(componentId)) {
            this.components.set(componentId, new Map());
        }
        
        this.components.get(componentId).set(entityId, componentData);
        this.entities.get(entityId).add(componentId);
    }
    
    removeComponent(entityId, componentType) {
        let component = this.getComponent(entityId, componentType);
        if (this.components.has(componentType)) {
            this.components.get(componentType).delete(entityId);
        }
        if (this.entities.has(entityId)) {
            this.entities.get(entityId).delete(componentType);
        }
        return component;
    }
    
    getComponent(entityId, componentType) {
        if (this.components.has(componentType)) {
            return this.components.get(componentType).get(entityId);
        }
        return null;
    }
    
    hasComponent(entityId, componentType) {
        return this.components.has(componentType) && 
                this.components.get(componentType).has(entityId);
    }
    
    getEntitiesWith(...componentTypes) {
        const result = [];
        for (const [entityId, entityComponents] of this.entities) {
            if (componentTypes.every(type => entityComponents.has(type))) {
                result.push(entityId);
            }
        }
        return result.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    addSystem(system, params) {
        system.game = this;
        this.systems.push(system);
        if (system.init) {
            system.init(params);
        }
    }

    addClass(classId, classRef, params) {
        this.classes[classId] = { classRef: classRef, defaultParams: params };
        this.app.appClasses[classId] = classRef;
    }


    triggerEvent(eventName, data) {
        this.systems.forEach(system => {
            if (system[eventName]) {
                system[eventName](data);
            }
        });
    }

    gameOver() {
        this.state.gameOver = true;
    }

    gameVictory() {
        this.state.victory = true;
    }
    resetCurrentTime() {
        this.state.now = 0;
        this.lastTime = 0;
        this.currentTime = 0;     
    }
}

if(typeof BaseECSGame != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseECSGame = BaseECSGame;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseECSGame;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseECSGame;
        exports.BaseECSGame = BaseECSGame;
    }
};
window.engine.BaseECSGame = window.COMPILED_GAME.libraryClasses.BaseECSGame;

// Library: SceneManager
window.COMPILED_GAME.libraryClasses.SceneManager = class SceneManager {
    constructor(game) {
        this.game = game;
        this.game.state.currentScene = null;
        this.currentSceneData = null;
        this.currentSceneName = null;
    }

    addEntityToScene(entity){        
        if(this.game.state.currentScene){
            return this.game.state.currentScene.addChild(entity);  
        }
        return entity;
    }

    load(sceneName){
        this.currentSceneName = sceneName;
        if(this.game.currentScene) {
            this.game.currentScene.destroy();
        } 
        this.currentSceneData = this.game.getCollections().scenes[this.currentSceneName];

        
        if(this.currentSceneData.type == "ECS") {
            return this.loadECS();
        }
        this.game.state.currentScene = this.game.spawn("scene", {sceneData: this.currentSceneData});

        const sceneEntities = this.currentSceneData.sceneData;
        sceneEntities.forEach(async (sceneEntity) => {
            let params = {
                "objectType": sceneEntity.objectType,
                "spawnType": sceneEntity.spawnType,
            };
            sceneEntity.components.forEach((entityComp) => {
                params = {...params, ...entityComp.parameters, canvas: this.game.canvas };
            });                              
            let e = this.game.spawn(sceneEntity.type, params);
            this.addEntityToScene(e);  
        });
    }

    loadECS() {
        
        const sceneEntities = this.currentSceneData.sceneData;
          sceneEntities.forEach(async (sceneEntity) => {   

            sceneEntity.classes.forEach((sceneClassDef) => {
                const collectionName = sceneClassDef.collection;
                const baseClassId = sceneClassDef.baseClass;
                const classCollection = this.game.getCollections()[collectionName];
                
                if(baseClassId){
                    const collectionClassDef = classCollection[baseClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };
                    const BaseClassDef = this.game.moduleManager.getCompiledScript(baseClassId, collectionName);
                    this.game.addClass(baseClassId, BaseClassDef, params);
                }
                for(const collectionClassId in classCollection) {    
                    if(baseClassId && collectionClassId == baseClassId) continue;                
                    const collectionClassDef = classCollection[collectionClassId];
                    let params = { ...collectionClassDef.parameters, ...sceneClassDef.parameters, canvas: this.game.canvas };
                    const ClassDef = this.game.moduleManager.getCompiledScript(collectionClassId, collectionName);
                    this.game.addClass(collectionClassId, ClassDef, params);
                }
            });         
            
            sceneEntity.managers.forEach((managerDef) => {
                let params = {...managerDef.parameters, canvas: this.game.canvas };
                const ManagerClass = this.game.moduleManager.getCompiledScript(managerDef.type, 'managers');
                const managerInst = new ManagerClass(this.game, this);
                if(managerInst.init){
                    managerInst.init(params);
                }                
            });   

            sceneEntity.systems.forEach((systemDef) => {
                let params = {...systemDef.parameters, canvas: this.game.canvas };
                const SystemClass = this.game.moduleManager.getCompiledScript(systemDef.type, 'systems');
                const systemInst = new SystemClass(this.game, this);
   
                this.game.addSystem(systemInst, params);
                
            });   
            this.game.systems.forEach((system) => {
                system.postAllInit();                
            });                      
        });
    }

};
window.engine.SceneManager = window.COMPILED_GAME.libraryClasses.SceneManager;

// Library: ShapeFactory
window.COMPILED_GAME.libraryClasses.ShapeFactory = class ShapeFactory {
    constructor(palette, textures, libraryClasses, gltfModelScale = 32) {
        this.gltfCache = new Map();
        this.gltfLoader = new THREE_.GLTFLoader();
        this.palette = palette;
        this.textures = textures;
        this.skeleUtils = THREE_.SkeletonUtils;   
        this.urlRoot = "/";
        this.gltfModelScale = gltfModelScale; // Add GLTF scale parameter
    }
    
    setURLRoot(root){
        this.urlRoot = root;
    }
    
    setGLTFScale(scale) {
        this.gltfModelScale = scale;
    }
    
    async createMergedGroupFromJSON(model, frameData, groupName) {
        let mergedGroup = this.getMergedGroup(model, frameData, groupName);
        if( mergedGroup){
            return await this.createGroupFromJSON(groupName, mergedGroup);
        } else {
            return null;
        }
    }
    
    async createGroupFromJSON(groupName, groupData) {
        const group = new THREE.Group();
        group.name = groupName;
        group.userData = { isGroup: true };
        // Use Promise.all with map instead of forEach to properly await all shapes
  
        await Promise.all(groupData.shapes.map(async (shape, index) => {
            if (shape.type === 'gltf') {
                await this.handleGLTFShape(shape, index, group);
            } else {
                await this.handlePrimitiveShape(shape, index, group);
            }
        }));
        
        if(groupData.position){            
            group.position.x = groupData.position.x || 0;
            group.position.y = groupData.position.y || 0;
            group.position.z = groupData.position.z || 0;
        }

        if(groupData.rotation){
            group.rotation.x = groupData.rotation.x || 0;
            group.rotation.y = groupData.rotation.y || 0;
            group.rotation.z = groupData.rotation.z || 0;
        }

        if(groupData.scale){
            group.scale.x = groupData.scale.x || 1;
            group.scale.y = groupData.scale.y || 1;
            group.scale.z = groupData.scale.z || 1;
        } 
        return group;
    }

    async handleGLTFShape(shape, index, group) {
        const applyTransformations = async (model, gltf) => {
            // Extract animations
            const animations = gltf.animations;
            
            // Apply individual shape transformations first
            model.position.set(
                (shape.position ? shape.position.x : shape.x) || 0, 
                (shape.position ? shape.position.y : shape.y) || 0, 
                (shape.position ? shape.position.z : shape.z) || 0
            );
            
            // Apply shape-specific scale first, then multiply by global GLTF scale
            const shapeScaleX = (shape.scale ? shape.scale.x : shape.scaleX) || 1;
            const shapeScaleY = (shape.scale ? shape.scale.y : shape.scaleY) || 1;
            const shapeScaleZ = (shape.scale ? shape.scale.z : shape.scaleZ) || 1;
            
            model.scale.set(
                shapeScaleX * this.gltfModelScale,
                shapeScaleY * this.gltfModelScale,
                shapeScaleZ * this.gltfModelScale
            );
            
            model.rotation.set(
                ((shape.rotation ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,
                ((shape.rotation ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,
                ((shape.rotation ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180
            );

            // Store reference to all bones for equipment attachment
            const modelBones = new Map();
            let skinnedMesh = null;
            let skeleton = null;

            model.traverse(child => {
                if (child.isMesh) {
                    // Override material with skinning enabled
                    let map = child.material.map;
                    child.material = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        metalness: shape.metalness || 0.5,
                        roughness: shape.roughness || 0.5,
                        map: map
                    });                           
                    child.material.alphaTest = 0.1;
                    child.material.needsUpdate = true;
                    child.castShadow = true;
                    child.receiveShadow = true;
                    child.userData = {
                        isShape: true,
                        index: index,
                        isGLTFChild: true
                    };
                    
                    // Check if this is a skinned mesh
                    if (child.isSkinnedMesh) {
                        skinnedMesh = child;
                        skeleton = child.skeleton;
                    }
                }
                
                // Collect all bones for equipment attachment
                if (child.isBone) {
                    modelBones.set(child.name, child);
                    // Mark bone with special userData for identification
                    child.userData.isCharacterBone = true;
                    child.userData.modelIndex = index;
                }
            });

            // Store skeleton and bone information in model userData
            model.userData = {
                isShape: true,
                index: index,
                isGLTFRoot: true,
                castShadow: true,
                animations: animations,
                bones: modelBones,
                skeleton: skeleton,
                skinnedMesh: skinnedMesh
            };
            group.add(model);

            if (animations && animations.length > 0) {
                const mixer = new THREE.AnimationMixer(model);
                const action = mixer.clipAction(animations[0]);
                action.play();

                model.userData.mixer = mixer;
                
                if (skeleton) {
                    model.userData.skeleton = skeleton;
                    // Ensure bones are accessible for equipment attachment
                    skeleton.bones.forEach(bone => {
                        if (!modelBones.has(bone.name)) {
                            modelBones.set(bone.name, bone);
                            bone.userData.isCharacterBone = true;
                            bone.userData.modelIndex = index;
                        }
                    });
                    if (skeleton && animations && animations.length > 0) {
                        const baked = await this.bakeGpuAnimFromModel(model, animations, skeleton, { fps: 30 });
                        model.userData.gpuAnim = baked; // stash VAT + meta on the GLTF root
                    }
                    
                    // Update bones map in userData
                    model.userData.bones = modelBones;
                }
            }         
        };
    
        if (shape.url) {
            const cached = this.gltfCache.get(shape.url);
            if (cached) {
                const clonedScene = this.skeleUtils.clone(cached.scene);
                await applyTransformations(clonedScene, cached);
            } else if (shape.url && location.hostname !== "") {
                await new Promise((resolve, reject) => {
                    this.gltfLoader.load(
                        `${this.urlRoot}${shape.url}`,
                        async (gltf) => {
                            const clonedScene = this.skeleUtils.clone(gltf.scene);
                            this.gltfCache.set(shape.url, gltf);
                            await applyTransformations(clonedScene, gltf);
                            resolve();
                        },
                        undefined,
                        (error) => {
                            console.error(`Failed to load GLTF model at ${shape.url}:`, error);
                            reject(error);
                        }
                    );
                });
            }
        } else {
            return null;
        }
    }

    async handlePrimitiveShape(shape, index, group) {
        let geometry, material;

        let colorToUse = shape.color;
        if(shape.color.paletteColor){
            colorToUse = "#ffffff";
            if(this.palette && this.palette[shape.color.paletteColor]){
                colorToUse = this.palette[shape.color.paletteColor];
            }
        }
        if(shape.texture){
            // If a texture is specified, use it instead of the color
            // If a texture is specified, use it instead of the color
            const textureLoader = new THREE.TextureLoader();
                
            const textureData = this.textures[shape.texture];
            
            if( textureData ) {
                const texture = await new Promise((resolve, reject) => {
                    textureLoader.load(
                        textureData.image,
                        (loadedTexture) => {
                            loadedTexture.wrapS = THREE.RepeatWrapping; // Use ClampToEdge instead of RepeatWrapping
                            loadedTexture.wrapT = THREE.RepeatWrapping; // Use RepeatWrapping for vertical repeat
                            loadedTexture.magFilter = THREE.NearestFilter;
                            loadedTexture.minFilter = THREE.NearestFilter;
                            loadedTexture.generateMipmaps = false;
                            loadedTexture.anisotropy = 1;
                            loadedTexture.needsUpdate = true;

                            const meshWidth = shape.width || 1; // Mesh width in world units
                            const meshHeight = shape.height || 1; // Mesh height in world units
            
                            const textureWidth = loadedTexture.image.width;
                            const textureHeight = loadedTexture.image.height;
                            const pixelsPerUnit = 2;
                            const repeatX = Math.ceil((meshWidth * pixelsPerUnit) / textureWidth);
                            const repeatY = Math.ceil((meshHeight * pixelsPerUnit) / textureHeight);
                            loadedTexture.repeat.set(repeatX, repeatY);
 
                            resolve(loadedTexture);
                        },
                        undefined,
                        (error) => reject(error)
                    );
                });
                material = new THREE.MeshStandardMaterial({ map: texture, color: colorToUse });
            } else {                
                material = new THREE.MeshStandardMaterial({ color: colorToUse });
            }
        } else {            
            // Create material with specified color
            material = new THREE.MeshStandardMaterial({ color: colorToUse });
        }

        switch (shape.type) {
            case 'sphere':
                geometry = new THREE.SphereGeometry(shape.size / 2, 32, 32);
                break;
            case 'cube':
                geometry = new THREE.BoxGeometry(shape.size, shape.size, shape.size);
                break;
            case 'box':
                geometry = new THREE.BoxGeometry(shape.width, shape.height, shape.depth || shape.width);
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(shape.size / 2, shape.size / 2, shape.height, 32);
                break;
            case 'cone':
                geometry = new THREE.ConeGeometry(shape.size / 2, shape.height, 32);
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(shape.size / 2, shape.tubeSize || shape.size / 6, 16, 100);
                break;
            case 'tetrahedron':
                geometry = new THREE.TetrahedronGeometry(shape.size / 2);
                break;
            default:
                return;
        }

        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { isShape: true, castShadow: true, index: index };
        
        // Position and rotation for primitive shapes (no global scale applied)
        mesh.position.set(
            (shape.position && shape.position.x ? shape.position.x : shape.x) || 0, 
            (shape.position && shape.position.y ? shape.position.y : shape.y) || 0, 
            (shape.position && shape.position.z ? shape.position.z : shape.z) || 0
        );
        mesh.rotation.set(
            ((shape.rotation && shape.rotation.x ? shape.rotation.x : shape.rotationX) || 0) * Math.PI / 180,
            ((shape.rotation && shape.rotation.y ? shape.rotation.y : shape.rotationY) || 0) * Math.PI / 180,
            ((shape.rotation && shape.rotation.z ? shape.rotation.z : shape.rotationZ) || 0) * Math.PI / 180
        );
        mesh.scale.set(
            (shape.scale && shape.scale.x ? shape.scale.x : shape.scaleX) || 1,
            (shape.scale && shape.scale.y ? shape.scale.y : shape.scaleY) || 1,
            (shape.scale && shape.scale.z ? shape.scale.z : shape.scaleZ) || 1
        );
        
        group.add(mesh);
    }

    disposeObject(object) {
        object.traverse(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) {
                    child.material.forEach(m => m.dispose());
                } else {
                    child.material.dispose();
                }
            }
        });
    }

    getMergedGroup(model, frameData, groupName) {
        const modelGroup = model[groupName];
        if (!modelGroup) {
            delete frameData?.[groupName];
            return null;
        }
    
        frameData = frameData || {};
        let frameGroup = this.initializeFrameGroup(frameData, modelGroup, groupName);
        
        this.cleanupMatchingTransforms(modelGroup, frameGroup);
        const mergedShapes = this.mergeShapes(modelGroup, frameGroup);
        
        this.cleanupEmptyShapes(frameGroup);
        
        const mergedGroup = {
            ...modelGroup,
            ...frameGroup,
            shapes: mergedShapes
        };
    
        if (modelGroup.shapes.length === 0) {
            frameGroup.shapes = [];
        }
    
        const returnVal = JSON.parse(JSON.stringify(mergedGroup));
        this.cleanupFrameData(frameData, frameGroup, groupName);
        
        return returnVal;
    }
    
    initializeFrameGroup(frameData, modelGroup, groupName) {
        if (!frameData[groupName]) {
            frameData[groupName] = JSON.parse(JSON.stringify(modelGroup));
            const frameGroup = frameData[groupName];
            frameGroup.shapes.forEach((shape, index) => {
                shape.id = index;
            });
            return frameGroup;
        }
        return frameData[groupName];
    }
    
    cleanupMatchingTransforms(modelGroup, frameGroup) {
        const properties = ['position', 'rotation', 'scale'];
        properties.forEach(prop => {
            if (JSON.stringify(modelGroup[prop]) === JSON.stringify(frameGroup[prop])) {
                delete frameGroup[prop];
            }
        });
    }
    
    mergeShapes(modelGroup, frameGroup) {
        return modelGroup.shapes.map((modelShape, i) => {
            if (!frameGroup.shapes) {
                return JSON.parse(JSON.stringify(modelShape));
            }
    
            let frameShape = frameGroup.shapes.find(shape => shape.id === i) || { id: i };
            if (!frameGroup.shapes.includes(frameShape)) {
                frameGroup.shapes.push(frameShape);
            }
    
            const mergedShape = this.mergeShapeProperties(modelShape, frameShape);
            this.cleanupMatchingShapeTransforms(modelShape, frameShape);
            
            return JSON.parse(JSON.stringify(mergedShape));
        });
    }
    
    mergeShapeProperties(modelShape, frameShape) {
        const mergedShape = {};
        
        for (const key in modelShape) {
            if (key === 'id') continue;
            
            if (frameShape && frameShape[key] !== undefined && modelShape[key] === frameShape[key]) {
                delete frameShape[key];
                mergedShape[key] = modelShape[key];
            } else if (!frameShape || frameShape[key] === undefined) {
                mergedShape[key] = modelShape[key];
            } else {
                mergedShape[key] = frameShape[key];
            }
        }
    
        return { ...mergedShape, ...frameShape };
    }
    
    cleanupMatchingShapeTransforms(modelShape, frameShape) {
        const transforms = [
            { prop: 'scale', defaultVal: 1, axes: ['X', 'Y', 'Z'] },
            { prop: 'rotation', defaultVal: 0, axes: ['X', 'Y', 'Z'] }
        ];
    
        transforms.forEach(({ prop, defaultVal, axes }) => {
            axes.forEach(axis => {
                const propName = `${prop}${axis}`;
                if (frameShape[propName] === modelShape[propName] || 
                   (frameShape[propName] === defaultVal && modelShape[propName] === undefined)) {
                    delete frameShape[propName];
                }
            });
        });
    }
    
    cleanupEmptyShapes(frameGroup) {
        if (frameGroup.shapes) {
            frameGroup.shapes = frameGroup.shapes.filter(shape => 
                Object.keys(shape).length > 0
            );
            
            if (frameGroup.shapes.length === 0) {
                delete frameGroup.shapes;
            }
        }
    }
    
    cleanupFrameData(frameData, frameGroup, groupName) {
        if (Object.keys(frameGroup).length === 0) {
            delete frameData[groupName];
        }
    }
        // ---- GPU Animation Bake (VAT) ----
    async bakeGpuAnimFromModel(model, animations, skeleton, opts = {}) {
        // opts: { fps=30, useDualQuat=false }  // keep simple: matrices
        const fps = opts.fps ?? 30;
        if (!skeleton || !animations || animations.length === 0) return null;

        const clips = animations; // THREE.AnimationClip[]
        const bones = skeleton.bones;
        const boneCount = bones.length;

        // Build meta per clip: {name, frames, duration}
        const perClipMeta = clips.map(clip => {
            const frames = Math.max(1, Math.ceil((clip.duration || 0) * fps));
            return { name: clip.name, duration: clip.duration, frames };
        });

        // Layout: one big atlas: rows = sum(frames over clips), columns = boneCount * 4 (mat4)
        const totalFrames = perClipMeta.reduce((a, c) => a + c.frames, 0);
        const cols = boneCount * 4;   // 4 texels per bone (mat4 rows)
        const rows = totalFrames;

        // R32F/RGBA32F: we’ll pack mat4 rows into RGBA floats per texel
        const floatCount = rows * cols * 4; // 4 channels per texel
        const data = new Float32Array(floatCount);

        const mixer = new THREE.AnimationMixer(model);
        const tmpQuat = new THREE.Quaternion();
        const tmpPos = new THREE.Vector3();
        const tmpScl = new THREE.Vector3();
        const boneM = new THREE.Matrix4();
        const bindI = skeleton.boneInverses;

        let rowOffset = 0;
        for (let c = 0; c < clips.length; c++) {
            const clip = clips[c];
            const { frames } = perClipMeta[c];
            const action = mixer.clipAction(clip);
            action.play();

            for (let f = 0; f < frames; f++) {
                const t = (f / Math.max(1, frames - 1)) * (clip.duration || 0);
                mixer.setTime(t);

                // ensure world/bone matrices are fresh
                model.updateMatrixWorld(true);
                bones.forEach((b) => b.updateMatrixWorld(true));

                // For each bone: final palette matrix = world * bindInverse (classic skinning)
                for (let b = 0; b < boneCount; b++) {
                    boneM.copy(bones[b].matrixWorld).multiply(bindI[b]);

                    // write 4 rows (vec4 each) into data
                    // column-major three.js Matrix4 elements
                    const e = boneM.elements; // [n11,n12, ... n44], column-major
                    const baseTexel = ((rowOffset + f) * cols + (b * 4)) * 4;
                    // Row0
                    data[baseTexel + 0] = e[0]; data[baseTexel + 1] = e[4]; data[baseTexel + 2] = e[8];  data[baseTexel + 3] = e[12];
                    // Row1
                    data[baseTexel + 4] = e[1]; data[baseTexel + 5] = e[5]; data[baseTexel + 6] = e[9];  data[baseTexel + 7] = e[13];
                    // Row2
                    data[baseTexel + 8] = e[2]; data[baseTexel + 9] = e[6]; data[baseTexel +10] = e[10]; data[baseTexel +11] = e[14];
                    // Row3
                    data[baseTexel +12] = e[3]; data[baseTexel +13] = e[7]; data[baseTexel +14] = e[11]; data[baseTexel +15] = e[15];
                }
            }

            rowOffset += frames;
            action.stop();
        }

        const tex = new THREE.DataTexture(
            data, cols, rows, THREE.RGBAFormat, THREE.FloatType
        );
        tex.needsUpdate = true;
        tex.flipY = false;

        // clip row ranges
        let acc = 0;
        const clipRows = perClipMeta.map(m => {
            const start = acc;
            const end = acc + m.frames; // exclusive
            acc = end;
            return { name: m.name, start, end, frames: m.frames, duration: m.duration };
        });

        return {
            texture: tex,
            bones: boneCount,
            rows, cols,
            fps,
            clips: clipRows
        };
    }

};
window.engine.ShapeFactory = window.COMPILED_GAME.libraryClasses.ShapeFactory;

// Library: ImageManager
window.COMPILED_GAME.libraryClasses.ImageManager = 
class ImageManager {
    constructor(app, {imageSize, palette, textures}) {
        this.app = app;
        this.images = {};
        this.imageSize = imageSize || 128;
        // Create a single reusable renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
        this.renderer.setSize(this.imageSize, this.imageSize);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        this.renderTarget = new THREE.WebGLRenderTarget(this.imageSize, this.imageSize);
        this.renderTarget.texture.flipY = true;
        
        // Create reusable scene
        this.scene = new THREE.Scene();
        
        // Create reusable cameras for different views
        const cameraDistance = 64;
        const frustumSize = cameraDistance + 16;
        const aspect = 1;

        this.shapeFactory = new GUTS.ShapeFactory(palette, textures);
        if(location.hostname.indexOf('github') >= 0) {
            this.shapeFactory.setURLRoot("/GUTS/");
        }
        // Create 8 cameras for isometric views at 45-degree intervals
        this.cameras = [];
        for (let i = 0; i < 8; i++) {
            this.cameras.push(new THREE.OrthographicCamera(-frustumSize * aspect, frustumSize * aspect, frustumSize, -frustumSize, 0.1, 1000));
        }
        
        // Position cameras in a circle around the y-axis at isometric angle
        // Standard isometric angle is about 35.264 degrees (arctan(1/sqrt(2)))
        const isoAngle = Math.atan(1 / Math.sqrt(2));
        const horizDistance = cameraDistance * Math.cos(isoAngle);
        const vertDistance = cameraDistance * Math.sin(isoAngle);
        
        for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI / 4); // 45-degree increments
            const x = horizDistance * Math.sin(angle);
            const z = horizDistance * Math.cos(angle);
            
            this.cameras[i].position.set(x, vertDistance, z);
            this.cameras[i].lookAt(0, 0, 0);
        }
        
        // Create reusable lights
        this.ambientLight = new THREE.AmbientLight(0xffaaff, .25);
        
        // Create a light group that will rotate with each camera view
        this.lightGroup = new THREE.Group();
        
        // Main directional light
        this.directionalLight = new THREE.DirectionalLight(0xffffaa, .7);
        this.directionalLight.position.set(75, 96, 75);
        this.directionalLight.castShadow = true;
        this.directionalLight.shadow.mapSize.width = 1024;
        this.directionalLight.shadow.mapSize.height = 1024;
        this.directionalLight.shadow.camera.near = 0.5;
        this.directionalLight.shadow.camera.far = 500;
        this.directionalLight.shadow.bias = -0.0005;
        this.directionalLight.shadow.normalBias = 0.02;
        this.directionalLight.shadow.radius = 1;
        this.lightGroup.add(this.directionalLight);
        
        // Fill light
        this.fillLight = new THREE.DirectionalLight(0xffaaff, .5);
        this.fillLight.position.set(-20, 30, -20);
        this.lightGroup.add(this.fillLight);
        
        // Create ground plane
        const groundGeometry = new THREE.PlaneGeometry(200, 200);
        const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        this.ground.rotation.x = -Math.PI / 2;
        this.ground.position.y = 0;
        this.ground.receiveShadow = true;
    }

    clear() {
        images = {};
    }

    dispose() {
        // Proper cleanup when the manager is no longer needed
        if (this.renderer) {
            this.renderer.dispose();
            this.renderer = null;
        }
        if (this.renderTarget) {
            this.renderTarget.dispose();
            this.renderTarget = null;
        }
        if (this.ground && this.ground.geometry) {
            this.ground.geometry.dispose();
            this.ground.material.dispose();
        }
        // Dispose of other reusable resources
        this.cameras = [];
        this.scene = null;
        this.lightGroup = null;
        this.ambientLight = null;
    }

    async loadImages(prefix, config, checkCache = true, cacheResult = true) {

        if (!prefix || !config || typeof config !== 'object') {
            throw new Error('Invalid prefix or config provided to loadImages');
        }
        if( checkCache ) {
            const cachedImages = await this.checkCache(prefix);
            if (cachedImages) {
                this.images = { ...this.images, ...cachedImages };
                return;
            }
        }
        for (const [type, cfg] of Object.entries(config)) {
            if (cfg.render && cfg.render.animations) {
                this.images[`${prefix}_${type}`] = await this.createAnimatedPlaceholder(cfg);
            } else if (cfg.tileMap && cfg.tileMap.terrainTypes) {
                this.images[`${prefix}_${type}`] = await this.createTerrainImages(cfg);
            }
        }
        if(cacheResult) {
            await this.cacheImages(prefix);
        }
    }
    
    async checkCache(prefix) {
        try {
            const response = await fetch(`/cache/${prefix}.json`);
            if (response.ok) {
                const cacheData = await response.json();
                // Convert base64 cached images back to canvases
                return await this.convertBase64ToCanvases(cacheData.images);
            }
            return null;
        } catch (error) {
            return null;
        }
    }

    async convertBase64ToCanvases(cachedImages) {
        const convertedImages = {};
        
        for (const [key, value] of Object.entries(cachedImages)) {
            if (Array.isArray(value)) {
                // Handle terrain tiles
                convertedImages[key] = await Promise.all(value.map(async (terrain) => {
                    const sprites = await Promise.all(terrain.sprites.map(async (base64) => {
                        const canvas = document.createElement('canvas');
                        canvas.width = canvas.height = 24; // Match tileWidth from createTerrainImages
                        const ctx = canvas.getContext('2d');
                        const img = new Image();
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                ctx.drawImage(img, 0, 0);
                                resolve();
                            };
                            img.onerror = reject;
                            img.src = base64;
                        });
                        
                        return canvas;
                    }));
                    
                    return {
                        type: terrain.type,
                        sprites
                    };
                }));
            } else if (typeof value === 'object') {
                // Handle animations
                const animations = {};
                for (const [animType, frames] of Object.entries(value)) {
                    animations[animType] = await Promise.all(frames.map(async (frameSet) => {
                        return Promise.all(frameSet.map(async (base64) => {
                            const canvas = document.createElement('canvas');
                            canvas.width = canvas.height = this.imageSize;
                            const ctx = canvas.getContext('2d');
                            const img = new Image();
                            
                            await new Promise((resolve, reject) => {
                                img.onload = () => {
                                    ctx.drawImage(img, 0, 0);
                                    resolve();
                                };
                                img.onerror = reject;
                                img.src = base64;
                            });
                            
                            return canvas;
                        }));
                    }));
                }
                convertedImages[key] = animations;
            }
        }
        
        return convertedImages;
    }
    async cacheImages(prefix) {
        const base64Images = {};
        
        for (const [key, value] of Object.entries(this.images)) {
            if (key.startsWith(prefix)) {
                if (Array.isArray(value) && value[0]?.type && value[0]?.sprites) {
                    // Handle terrain tiles
                    base64Images[key] = value.map(terrain => ({
                        type: terrain.type,
                        sprites: terrain.sprites.map(canvas => canvas.toDataURL('image/png'))
                    }));
                } else if (typeof value === 'object' && value !== null) {
                    // Handle animations
                    const animationData = {};
                    for (const [animType, frames] of Object.entries(value)) {
                        animationData[animType] = frames.map(frameSet => 
                            frameSet.map(canvas => canvas.toDataURL('image/png'))
                        );
                    }
                    base64Images[key] = animationData;
                }
            }
        }

        try {
            await fetch('/api/cache', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    prefix,
                    images: base64Images
                })
            });
        } catch (error) {
            console.error('Error caching images:', error);
        }
    }
    // In the ImageManager class
    async createTerrainImages(config) {
        let terrainTiles = [];
        const tileWidth = 24;

        // Create a map of terrain type to its image data first
        const terrainMap = {};
        await Promise.all(config.tileMap.terrainTypes.map(async (terrainType, terrainIndex) => {
            const pixelData = terrainType.image;
            if (pixelData && pixelData.length > 0) {
                let sprites = new Array(8);
                
                await Promise.all(pixelData.map(async (imagePixelData, spriteIdx) => {
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = tileWidth;
                    const ctx = canvas.getContext('2d');

                    if (!imagePixelData.startsWith('data:image/')) {
                        imagePixelData = 'data:image/png;base64,' + imagePixelData;
                    }
                    img.src = imagePixelData;

                    await new Promise((resolve, reject) => {
                        img.onload = () => {
                            ctx.drawImage(img, 0, 0);
                            sprites[spriteIdx] = canvas;
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image for ${terrainType.type} at index ${spriteIdx}`);
                            sprites[spriteIdx] = canvas; // Store empty canvas on error
                            resolve(); // Don't reject, just move on
                        };
                    });
                }));

                // Store by index and type for more reliable lookup
                terrainTiles[terrainIndex] = { 
                    type: terrainType.type,
                    sprites: sprites 
                };
            } else {
                // Create a solid color placeholder for types without images
                const sprites = new Array(8).fill().map(() => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = tileWidth;
                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = terrainType.color || '#cccccc';
                    ctx.fillRect(0, 0, tileWidth, tileWidth);
                    return canvas;
                });
                
                terrainTiles[terrainIndex] = {
                    type: terrainType.type,
                    sprites: sprites
                };
            }
        }));

        // Make sure there are no gaps in the array
        return terrainTiles.filter(Boolean);
    }
    async createAnimatedPlaceholder(config) {
        const animations = {};
        
        if(config.shadows === false) {
            this.ground.receiveShadow = false;
        } else {
            this.ground.receiveShadow = true;
        }
        for (const [animType, frames] of Object.entries(config.render.animations)) {
            animations[animType] = [];
            let i = 0;
            for (const frame of frames) {
                const frameImages = await this.captureObjectImagesFromJSON(config.render.model, frame);
                const canvases = frameImages.map(img => {
                    const canvas = document.createElement('canvas');
                    canvas.width = canvas.height = this.imageSize;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    return canvas;
                });                
                animations[animType].push(canvases); // Array of 8 canvases per frame
            }
        }
        return animations; // { "idle": [[canvas0, canvas1, canvas2, canvas3, ...], ...], "walk": [...] }
    }

    getImages(prefix, type) {
        return this.images[`${prefix}_${type}`]; // Returns animation object
    }
    async captureObjectImagesFromJSON(model, frameData) {
        const size = this.imageSize;
        // Clear the scene
        while (this.scene.children.length > 0) {
            const object = this.scene.children[0];
            this.scene.remove(object);
        }
        
        // Add reusable elements to scene
        this.scene.add(this.ground);
        this.scene.add(this.ambientLight);
        this.scene.add(this.lightGroup);
        
        // Create objects from the JSON data
        const objectGroup = await this.createObjectsFromJSON(model, frameData, this.scene);

        
        const images = [];
        
        // For each camera view, rotate the light group to match camera orientation
        for (let i = 0; i < this.cameras.length; i++) {
            const camera = this.cameras[i];
            
            // Reset light group rotation
            this.lightGroup.rotation.set(0, 0, 0);
            
            // Rotate light group to match camera position
            // Calculate angle based on camera index (8 positions at 45-degree intervals)
            // Rotate 45 degrees CLOCKWISE (subtract π/4 instead of adding)
            const angle = (i * Math.PI / 4); 
            this.lightGroup.rotation.y = angle;
            
            // Before rendering with each camera, update shadow camera frustum
            const d = 100;
            this.directionalLight.shadow.camera.left = -d;
            this.directionalLight.shadow.camera.right = d;
            this.directionalLight.shadow.camera.top = d;
            this.directionalLight.shadow.camera.bottom = -d;
            // After rotating lightGroup in the camera loop
            this.directionalLight.shadow.camera.updateProjectionMatrix();
            this.directionalLight.shadow.camera.updateMatrixWorld();
            this.directionalLight.target.position.set(0, 0, 0);
            this.directionalLight.target.updateMatrixWorld();
            // Render and capture the image
            this.renderer.setRenderTarget(this.renderTarget);
            this.renderer.render(this.scene, camera);
            const buffer = new Uint8Array(size * size * 4);
            this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, size, size, buffer);
            
            // Flip the buffer (y-axis)
            const flippedBuffer = new Uint8Array(size * size * 4);
            for (let y = 0; y < size; y++) {
                const srcRowStart = y * size * 4;
                const destRowStart = (size - 1 - y) * size * 4;
                flippedBuffer.set(buffer.subarray(srcRowStart, srcRowStart + size * 4), destRowStart);
            }
            
            const imageData = new ImageData(new Uint8ClampedArray(flippedBuffer), size, size);
            const imageBitmap = await createImageBitmap(imageData);
            images.push(imageBitmap);
        }
        if( this.renderer) this.renderer.setRenderTarget(null);
        
        // Cleanup object geometries and materials
        this.shapeFactory.disposeObject(objectGroup);
        
        // Remove object group from scene
        if( this.scene ) this.scene.remove(objectGroup);
        
        return images;
    }

    /**
     * Creates 3D objects from shape data.
     * @param {Object} frameData - The JSON object containing frame definitions.
     * @returns {THREE.Group} - A group containing all 3D objects.
     */
  
    async createObjectsFromJSON(model, frameData, scene) {
        const rootGroup = new THREE.Group();
        
        for(const groupName in model) {
            const group = await this.shapeFactory.createMergedGroupFromJSON(model, frameData, groupName);
            if(group){
                group.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true; // or set this selectively for objects that should cast shadows
                        child.receiveShadow = true; // for objects that should receive shadows
                    }
                });
                rootGroup.add(group);
            }
        }

        scene.add(rootGroup);
    
        return rootGroup;
    }
   
}
;
window.engine.ImageManager = window.COMPILED_GAME.libraryClasses.ImageManager;

// Library: SpatialGrid
window.COMPILED_GAME.libraryClasses.SpatialGrid =  
    class SpatialGrid {
        constructor(worldSize, cellSize) {
            this.cellSize = cellSize;
            this.cols = worldSize;
            this.rows = worldSize;
            this.grid = new Array(this.cols * this.rows).fill().map(() => []);
            
            // Track which cell each entity is in
            this.entityCells = new Map(); // Map of entity -> cell index
        }
        
        getIndex(x, y) {
            return y * this.cols + x;
        }

        insert(entity) {
            const newIndex = this.getIndex(entity.transform.gridPosition.x, entity.transform.gridPosition.y);
            const oldIndex = this.entityCells.get(entity);
            
            // If entity moved to a new cell
            if (oldIndex !== newIndex) {
                // Remove from old cell if it exists
                if (oldIndex !== undefined) {
                    const oldCell = this.grid[oldIndex];
                    const entityIndex = oldCell.indexOf(entity);
                    if (entityIndex !== -1) {
                        oldCell.splice(entityIndex, 1);
                    }
                }
                
                // Add to new cell
                if (newIndex >= 0 && newIndex < this.grid.length) {
                    this.grid[newIndex].push(entity);
                    this.entityCells.set(entity, newIndex);
                }
            }
        }
        
        remove(entity) {
            const index = this.entityCells.get(entity);
            if (index !== undefined) {
                const cell = this.grid[index];
                const entityIndex = cell.indexOf(entity);
                if (entityIndex !== -1) {
                    cell.splice(entityIndex, 1);
                }
                this.entityCells.delete(entity);
            }
        }
        getNearbyEntities(x, y, radius, type="") {
            const nearby = [];
            // Get cells that could contain entities within radius
            const startX = Math.max(0, Math.floor((x - radius)));
            const endX = Math.min(this.cols - 1, Math.floor((x + radius)));
            const startY = Math.max(0, Math.floor((y - radius)));
            const endY = Math.min(this.rows - 1, Math.floor((y + radius)));
       
            // Collect potential candidates from relevant cells
            for (let row = startY; row <= endY; row++) {
                for (let col = startX; col <= endX; col++) {
                    const index = row * this.cols + col;
                    if (index >= 0 && index < this.grid.length) {
                        for (let entity of this.grid[index]) {
                            const dx = (entity.transform.gridPosition.x) - (x + .5);
                            const dy = (entity.transform.gridPosition.y) - (y + .5);
                            const distSquared = dx * dx + dy * dy;
                            
                            if (distSquared <= radius * radius) {
                                if(type) {
                                    if( entity.type == type ) {
                                        nearby.push(entity);
                                    }
                                } else {
                                    nearby.push(entity);
                                }
                            }                            
                        }
                    }
                }
            }
            
            return nearby;
        }
        clear() {
            this.grid = this.grid.map(() => []);
            this.entityCells.clear();
        }
        
        // Optional: Only clear but maintain all entity positions
        // Useful for when reusing the same grid across updates
        resetKeepingEntities() {
            const allEntities = [];
            this.entityCells.forEach((_, entity) => {
                allEntities.push(entity);
            });
            
            this.clear();
            
            allEntities.forEach(entity => {
                this.insert(entity);
            });
        }
    }
;
window.engine.SpatialGrid = window.COMPILED_GAME.libraryClasses.SpatialGrid;

// Library: CoordinateTranslator
window.COMPILED_GAME.libraryClasses.CoordinateTranslator = class CoordinateTranslator {
    constructor(config, mapSize, isometric = false) {
        this.isometric = isometric;
        this.tileWidth = config.gridSize;
        this.tileHeight = config.gridSize * 0.5;
        this.canvasWidth = config.canvasWidth;
        this.canvasHeight = config.canvasHeight;
        this.mapSize = mapSize;
    }

    // Pixel (top-down) to Grid
    pixelToGrid(pixelX, pixelY) {
        return {
            x: pixelX / this.tileWidth,
            y: pixelY / this.tileWidth
        };
    }

    // Grid to Isometric (with vertical centering)
    gridToIso(gridX, gridY) {
        // If not isometric, return grid coordinates as-is
        if (!this.isometric) {
            return { x: gridX * this.tileWidth, y: gridY * this.tileWidth };
        }

        const isoX = (gridX - gridY) * (this.tileWidth / 2) + this.canvasWidth / 2;
       
        // Calculate the height the grid would occupy
        const totalGridHeight = this.mapSize * this.tileHeight;
       
        // Center vertically by adding an offset
        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;
       
        const isoY = (gridX + gridY) * (this.tileHeight / 2) + verticalOffset;
       
        return { x: isoX, y: isoY };
    }

    // Pixel (top-down) to Isometric
    pixelToIso(pixelX, pixelY) {
        if(!this.isometric){
            return {
                x: pixelX + ( this.canvasWidth - this.mapSize * this.tileWidth) / 2,
                y: pixelY + ( this.canvasHeight - this.mapSize * this.tileWidth) / 2
            }
        }
        const grid = this.pixelToGrid(pixelX, pixelY);
        return this.gridToIso(grid.x, grid.y);
    }

    isoToGrid(isoX, isoY) {
        // If not isometric, convert directly to grid
        if (!this.isometric) {
            return {
                x: isoX / this.tileWidth,
                y: isoY / this.tileWidth
            };
        }

        const adjustedX = isoX - this.canvasWidth / 2;
       
        // Calculate the same vertical offset as in gridToIso
        const totalGridHeight = this.mapSize * this.tileHeight;
        const verticalOffset = (this.canvasHeight - totalGridHeight) / 2;
       
        // Subtract the offset before conversion
        const adjustedY = isoY - verticalOffset;
       
        const gridX = (adjustedX / (this.tileWidth / 2) + adjustedY / (this.tileHeight / 2)) / 2;
        const gridY = (adjustedY / (this.tileHeight / 2) - adjustedX / (this.tileWidth / 2)) / 2;
       
        return { x: gridX, y: gridY };
    }

    isoToPixel(isoX, isoY) {
        const grid = this.isoToGrid(isoX, isoY);
        return {
            x: grid.x * this.tileWidth,
            y: grid.y * this.tileWidth
        };
    }

    // Snap grid coordinates to nearest integer
    snapToGrid(gridX, gridY) {
        return { x: Math.floor(gridX), y: Math.floor(gridY) };
    }
};
window.engine.CoordinateTranslator = window.COMPILED_GAME.libraryClasses.CoordinateTranslator;

// Library: CanvasUtility
window.COMPILED_GAME.libraryClasses.CanvasUtility = class CanvasUtility {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
		this.ctx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency
        
		this.tempCanvas = document.createElement('canvas');
        this.tempCtx = this.tempCanvas.getContext('2d', { willReadFrequently: true });
		this.tempCtx.globalCompositeOperation = 'destination-over';// Set the composite operation to preserve transparency
    }

    setSize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
    }
    paintTexture(imageData) {
        this.setSize(imageData.width, imageData.height);
        this.ctx.putImageData(imageData, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }
	rotateTexture(imageData, angle) {
        // Set the canvas size to accommodate the rotated image
        // Note: If the rotation results in a change in width/height, adjust these values accordingly
        this.setSize(imageData.width, imageData.height);

        // Draw the original imageData to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Apply the rotation
        this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
        this.ctx.rotate(angle);
        this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);

        // Create a temporary canvas to hold the current state
        this.tempCanvas.width = this.canvas.width;
        this.tempCanvas.height = this.canvas.height;
        this.tempCtx.drawImage(this.canvas, 0, 0);

        // Clear the main canvas and draw the rotated image
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(this.tempCanvas, 0, 0);

        // Capture the rotated image data
        let rotatedData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
 

        return rotatedData;
    }
	flipTextureVertical(imageData) {
        this.setSize(imageData.width, imageData.height);

        // Draw the original image data to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Use an off-screen canvas to perform the flip
        this.tempCanvas.width = imageData.width;
        this.tempCanvas.height = imageData.height;
  
        // Apply the flip on the off-screen canvas
        this.tempCtx.translate(0, this.tempCanvas.height);
		this.tempCtx.scale(1, -1);
		this.tempCtx.drawImage(this.canvas, 0, 0);

        // Extract the flipped image data
        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
    }

    flipTextureHorizontal(imageData) {
        this.setSize(imageData.width, imageData.height);

        // Draw the original image data to the canvas
        this.ctx.putImageData(imageData, 0, 0);

        // Use an off-screen canvas to perform the flip
        this.tempCanvas.width = imageData.width;
        this.tempCanvas.height = imageData.height;
        // Apply the flip on the off-screen canvas
		this.tempCtx.translate(this.tempCanvas.width, 0);
		this.tempCtx.scale(-1, 1);
		this.tempCtx.drawImage(this.canvas, 0, 0);

        // Extract the flipped image data
        return this.tempCtx.getImageData(0, 0, this.tempCanvas.width, this.tempCanvas.height);
    }
	drawImage(image) {
        this.setSize(image.width, image.height);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

	rotateImage(image, angle) {
		this.setSize(image.width, image.height);
		// Set up the rotation
		this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
		this.ctx.rotate(angle);
		this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
		this.ctx.fillStyle = 'rgba(0, 0, 0, 0)'; // Fully transparent
		this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
	
		// Draw the image
		this.ctx.drawImage(image, 0, 0);
		return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
	}

    flipImageVertical(image) {
        this.setSize(image.width, image.height);
        this.ctx.translate(0, this.canvas.height);
        this.ctx.scale(1, -1);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

    flipCanvasVertical() {
        this.ctx.translate(0, this.canvas.height);
        this.ctx.scale(1, -1);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }

    flipImageHorizontal(image) {
        this.setSize(image.width, image.height);
        this.ctx.translate(this.canvas.width, 0);
        this.ctx.scale(-1, 1);
        this.ctx.drawImage(image, 0, 0);
        return this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
    }
};
window.engine.CanvasUtility = window.COMPILED_GAME.libraryClasses.CanvasUtility;

// Library: TerrainImageProcessor
window.COMPILED_GAME.libraryClasses.TerrainImageProcessor = class TerrainImageProcessor {
  //Utility function to convert terrain tile spritesheets to and from base64 encoding
    constructor(app, options = {}) {
        this.app = app;
        // Configurable tile dimensions with defaults
        this.tileWidth = options.tileWidth || 24;
        this.tileHeight = options.tileHeight || 24;
        this.tilesX = options.tilesX || 4;
        this.tilesY = options.tilesY || 1; // Will be auto-detected

        // Bind methods to ensure correct context
        this.convertCanvasToBase64Tiles = this.convertCanvasToBase64Tiles.bind(this);
        this.displayStoredBase64Tiles = this.displayStoredBase64Tiles.bind(this);

        // Element references
        this.output = null;
        this.displayImage = null;
    }

    // Initialize the processor with DOM elements
    initialize(outputElement, displayImageElement) {
        this.output = outputElement;
        this.displayImage = displayImageElement;

        // Optional: Add custom event listener
        document.body.addEventListener('editTerrainImage', this.displayStoredBase64Tiles);
    }

    // Detect if the image is 4x1 or 4x2 based on aspect ratio
    detectSpriteSheetLayout(img) {
        const aspectRatio = img.width / img.height;
        
        // For 4x1 layout: width should be 4x tile width, height should be 1x tile height
        // For 4x2 layout: width should be 4x tile width, height should be 2x tile height
        
        // Calculate expected dimensions
        const expectedWidth4x1 = this.tileWidth * 4;
        const expectedHeight4x1 = this.tileHeight * 1;
        const expectedWidth4x2 = this.tileWidth * 4;
        const expectedHeight4x2 = this.tileHeight * 2;
        
        // Check if dimensions match 4x2 layout
        if (img.width === expectedWidth4x2 && img.height === expectedHeight4x2) {
            return { tilesX: 4, tilesY: 2, layout: '4x2' };
        }
        
        // Check if dimensions match 4x1 layout
        if (img.width === expectedWidth4x1 && img.height === expectedHeight4x1) {
            return { tilesX: 4, tilesY: 1, layout: '4x1' };
        }
        
        // Fallback: determine based on aspect ratio
        // 4x1 should have aspect ratio of 4:1
        // 4x2 should have aspect ratio of 2:1
        if (Math.abs(aspectRatio - 4.0) < Math.abs(aspectRatio - 2.0)) {
            return { tilesX: 4, tilesY: 1, layout: '4x1' };
        } else {
            return { tilesX: 4, tilesY: 2, layout: '4x2' };
        }
    }

    processImage(imageUrl) {
        const img = new Image();
        img.onload = () => {
            // Detect the sprite sheet layout
            const layout = this.detectSpriteSheetLayout(img);
            console.log(`Detected sprite sheet layout: ${layout.layout}`);
            
            // Update internal properties
            this.tilesX = layout.tilesX;
            this.tilesY = layout.tilesY;
            
            // Create a temporary canvas to process the image
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;

            const ctx = canvas.getContext('2d');
            
            // Set transparent background
            ctx.globalCompositeOperation = 'source-over';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the uploaded image at original size
            ctx.drawImage(img, 0, 0);

            // Convert to base64 tiles based on detected layout
            const base64Tiles = this.convertCanvasToBase64Tiles(canvas, layout);
            
            // Save base64 tiles to output
            this.output.value = JSON.stringify(base64Tiles);

            // Display the original uploaded image
            this.displayImage.src = imageUrl;
        };
        img.src = imageUrl;
    }

    // Convert canvas to array of base64 tiles with layout detection
    convertCanvasToBase64Tiles(canvas, layout, format = 'png', quality = 1.0) {
        const base64Tiles = [];

        if (layout.layout === '4x2') {
            // Process 4x2 layout: use both provided rows
            
            // First row (top tiles)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

            // Second row (bottom tiles)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = this.tileHeight; // Second row

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

        } else {
            // Process 4x1 layout: use first row and create flipped versions
            
            // First row of tiles (normal)
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                tileCtx.putImageData(imageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }

            // Create vertically flipped versions of the first row
            for (let x = 0; x < 4; x++) {
                const tileCanvas = document.createElement('canvas');
                tileCanvas.width = this.tileWidth;
                tileCanvas.height = this.tileHeight;
                const tileCtx = tileCanvas.getContext('2d');

                const srcX = x * this.tileWidth;
                const srcY = 0;

                const imageData = canvas.getContext('2d').getImageData(
                    srcX, srcY, this.tileWidth, this.tileHeight
                );

                // Create flipped image data
                const flippedImageData = this.verticallyFlipImageData(imageData);

                tileCtx.putImageData(flippedImageData, 0, 0);
                const dataUrl = tileCanvas.toDataURL(`image/${format}`, quality);
                const base64String = dataUrl.split(',')[1];
                base64Tiles.push(base64String);
            }
        }

        return base64Tiles;
    }

    // Helper method to vertically flip ImageData
    verticallyFlipImageData(imageData) {
        const flippedImageData = new ImageData(this.tileWidth, this.tileHeight);
        
        for (let y = 0; y < this.tileHeight; y++) {
            for (let x = 0; x < this.tileWidth; x++) {
                const srcIndex = (y * this.tileWidth + x) * 4;
                const destIndex = ((this.tileHeight - 1 - y) * this.tileWidth + x) * 4;
                
                flippedImageData.data[destIndex] = imageData.data[srcIndex];         // R
                flippedImageData.data[destIndex + 1] = imageData.data[srcIndex + 1]; // G
                flippedImageData.data[destIndex + 2] = imageData.data[srcIndex + 2]; // B
                flippedImageData.data[destIndex + 3] = imageData.data[srcIndex + 3]; // A
            }
        }
        
        return flippedImageData;
    }

    // Display stored base64 tiles
    displayStoredBase64Tiles() {
        // Check if there are stored base64 tiles
        if (!this.output.value) return;

        try {
            // Parse the stored base64 tiles
            const base64Tiles = JSON.parse(this.output.value);

            // Validate the number of tiles
            if (!Array.isArray(base64Tiles) || base64Tiles.length !== 8) {
                console.error('Invalid base64 tiles array - expected 8 tiles, got:', base64Tiles.length);
                return;
            }

            // Create canvas for display - always show as 4x2 for consistency
            const canvas = document.createElement('canvas');
            canvas.width = this.tileWidth * 4;
            canvas.height = this.tileHeight * 2;
            const ctx = canvas.getContext('2d');

            let loadedImages = 0;
            const tileImages = new Array(8).fill(null);

            base64Tiles.forEach((base64String, index) => {
                const tileImg = new Image();
                tileImg.onload = () => {
                    tileImages[index] = tileImg;
                    loadedImages++;

                    // Once all images are loaded, draw them in 4x2 layout
                    if (loadedImages === base64Tiles.length) {
                        // Draw first row of tiles (indices 0-3)
                        for (let x = 0; x < 4; x++) {
                            ctx.drawImage(tileImages[x], x * this.tileWidth, 0);
                        }

                        // Draw second row of tiles (indices 4-7)
                        for (let x = 0; x < 4; x++) {
                            ctx.drawImage(tileImages[x + 4], x * this.tileWidth, this.tileHeight);
                        }

                        // Set the final image
                        this.displayImage.src = canvas.toDataURL('image/png');
                    }
                };

                // Ensure the base64 string has the correct data URL prefix
                let dataUrl = base64String;
                if (!base64String.startsWith('data:image/')) {
                    dataUrl = 'data:image/png;base64,' + base64String;
                }
                tileImg.src = dataUrl;
            });
        } catch (error) {
            console.error('Error parsing stored base64 tiles:', error);
        }
    }

    // Helper method to get layout info for external use
    getLayoutInfo() {
        return {
            tilesX: this.tilesX,
            tilesY: this.tilesY,
            tileWidth: this.tileWidth,
            tileHeight: this.tileHeight
        };
    }

    // Method to manually set layout (useful for testing or specific requirements)
    setLayout(tilesX, tilesY) {
        this.tilesX = tilesX;
        this.tilesY = tilesY;
    }

    // Method to clean up event listeners if needed
    destroy() {
        document.body.removeEventListener('editTerrainImage', this.displayStoredBase64Tiles);
    }
};
window.engine.TerrainImageProcessor = window.COMPILED_GAME.libraryClasses.TerrainImageProcessor;

// Library: TileMap
window.COMPILED_GAME.libraryClasses.TileMap = class TileMap {

  constructor(app, config, { CanvasUtility }) {
   	this.app = app;
    this.config = config;
    this.engineClasses = {
 			"CanvasUtility": CanvasUtility
    } 
  }
	init(canvas, tileSize, layerSpriteSheets, isometric) {
		this.isometric = isometric;
		this.canvas = canvas;
		this.tileSize = tileSize;
		this.numColumns = 0;
		this.layerSpriteSheets = layerSpriteSheets;
		this.tileMap = [];
		this.layerTextures = [];
		this.canvasUtility = new (this.engineClasses.CanvasUtility)();
		
		// Initialize height map canvas
		this.heightMapCanvas = null;
		this.heightMapCtx = null;
		
		this.TileAnalysis = class {
			constructor() {
			  this.heightIndex = 0;
			  this.neighborLowerCount = 0;
			  this.cornerLowerCount = 0;
			  this.topLess = false;
			  this.leftLess = false;
			  this.rightLess = false;
			  this.botLess = false;
			  this.cornerTopLeftLess = false;
			  this.cornerTopRightLess = false;
			  this.cornerBottomLeftLess = false;
			  this.cornerBottomRightLess = false;
			}
		};

		this.TileTransforms = {
			None: 0,
			ClockWise90: 1,
			CounterClockWise90: 2,
			Rotate180: 3,
			FlipHorizontal: 4,
			FlipVertical: 5,
		};
		
		this.TileAtom = {
			Full: 0,
			OneCorner: 1,
			TwoCorner: 2,
			ThreeCorner: 3,
			FullVariation: 4,
			OneCornerBot: 5,
			TwoCornerBot: 6,
			ThreeCornerBot: 7
		};
		
		this.TileMolecule = {
			Full: 0,
			Corner: 1,
			Edge: 2,
			Tunnel: 3,
			TwoSides: 4,
			Penninsula: 5,
			Island: 6,
		};
		
		this.TileCliffMolecules = {
			Full: 0,
			CornerTL: 1,
			CornerTR: 2,
			CornerBL: 3,
			CornerBR: 4,
			EdgeT: 5,
			EdgeL: 6,
			EdgeR: 7,
			EdgeB: 8,
			TunnelH: 9,
			TunnelV: 10,
			TwoSidesTL: 11,
			TwoSidesTR: 12,
			TwoSidesBL: 13,
			TwoSidesBR: 14,    
			PenninsulaT: 15,
			PenninsulaL: 16,
			PenninsulaR: 17,
			PenninsulaB: 18,
			Island: 19,
			FullVariation: 20, // Added for random full tile variation
		};
	}

	initializeHeightMapCanvas() {
		// Create height map canvas with same dimensions as main canvas
		this.heightMapCanvas = document.createElement('canvas');
		this.heightMapCanvas.width = this.canvas.width;
		this.heightMapCanvas.height = this.canvas.height;
		this.heightMapCtx = this.heightMapCanvas.getContext('2d');
		
		// Set properties for better performance when reading pixel data
		this.heightMapCanvas.setAttribute('willReadFrequently', true);
		this.heightMapCtx = this.heightMapCanvas.getContext('2d', { willReadFrequently: true });
		
		// Initialize with black (height 0)
		this.heightMapCtx.fillStyle = 'black';
		this.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);
	}

	updateHeightMapForTile(x, y, heightIndex) {
		if (!this.heightMapCtx) return;
		
		// Convert height index to grayscale value (0-255)
		// Assuming we have up to 256 different height levels
		const heightValue = Math.min(255, Math.max(0, heightIndex * 32)); // Scale as needed
		const heightColor = `rgb(${heightValue}, ${heightValue}, ${heightValue})`;
		
		this.heightMapCtx.fillStyle = heightColor;
		this.heightMapCtx.fillRect(x, y, this.tileSize, this.tileSize);
	}

	getHeightAtPixel(x, y) {
		if (!this.heightMapCtx) return 0;
		
		// Clamp coordinates to canvas bounds
		x = Math.max(0, Math.min(this.heightMapCanvas.width - 1, Math.floor(x)));
		y = Math.max(0, Math.min(this.heightMapCanvas.height - 1, Math.floor(y)));
		
		const imageData = this.heightMapCtx.getImageData(x, y, 1, 1);
		const heightValue = imageData.data[0]; // Red channel (same as green and blue in grayscale)
		
		// Convert back to height index
		return Math.floor(heightValue / 32); // Inverse of the scaling used in updateHeightMapForTile
	}

	getHeightMapImageData() {
		if (!this.heightMapCtx) return null;
		return this.heightMapCtx.getImageData(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);
	}

    draw(map){
		this.tileMap = map;
		this.numColumns = this.tileMap.length;
		
		// Initialize height map canvas if not already done
		if (!this.heightMapCanvas) {
			this.initializeHeightMapCanvas();
		}
		
		// Clear height map canvas
		this.heightMapCtx.fillStyle = 'black';
		this.heightMapCtx.fillRect(0, 0, this.heightMapCanvas.width, this.heightMapCanvas.height);
		
		// Load all textures
		if(this.layerTextures.length == 0 && this.layerSpriteSheets) {
			this.layerSpriteSheets.forEach((layerSprites, index) => {      
				const moleculeData = this.buildBaseMolecules(layerSprites.sprites);
				this.layerTextures[index] = moleculeData;
			});
		}

		let analyzedMap = this.analyzeMap(this.tileMap);
		this.drawMap(analyzedMap);
        if(this.isometric){
          //  this.drawIsometric();
        }
    }

    drawIsometric() {
        let ctx = this.canvas.getContext('2d');
        // Save the original state
        ctx.save();
        
        // Create an off-screen canvas to hold original drawing
        const offscreen = document.createElement('canvas');
        offscreen.width = this.canvas.width;
        offscreen.height = this.canvas.height;
        const offCtx = offscreen.getContext('2d');
        offCtx.drawImage(this.canvas, 0, 0);
        
        // Clear the main canvas
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Move to center for rotation
        ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
        
        // Apply isometric transformation
        const scale = .56;    // Adjust overall size
        const isoAngle = Math.atan(1 / 2); // ≈ 26.565° (classic isometric angle)
        const cosA = Math.cos(isoAngle);   // ≈ 0.8944
        const sinA = Math.sin(isoAngle);   // ≈ 0.4472
        
        ctx.transform(
            cosA * scale,    // scaleX
            sinA * scale,    // skewY
            -cosA * scale,   // skewX
            sinA * scale,    // scaleY
            0,               // translateX
            0                // translateY
        );
        
        // Draw the transformed image centered
        ctx.drawImage(offscreen, -this.canvas.width / 2, -this.canvas.height / 2);
        
        // Restore original state
        ctx.restore();
    }

    drawTexture(texture, x, y) {
		ctx.drawImage(texture, x, y, this.tileSize / 2, this.tileSize / 2); // Assuming each atom is 256x256
    }

    // Function to generate a molecule texture for various molecule ty
	buildBaseMolecules(sprites) {
		// Define texture objects
		const fullTexture = document.createElement("canvas");

		const oneCornerTexture = document.createElement("canvas");
		const twoCornerTexture = document.createElement("canvas");
		const threeCornerTexture = document.createElement("canvas");

		const oneCornerBotTexture = document.createElement("canvas");
		const twoCornerBotTexture = document.createElement("canvas");
		const threeCornerBotTexture = document.createElement("canvas");

		fullTexture.setAttribute('willReadFrequently', true); 

		oneCornerTexture.setAttribute('willReadFrequently', true); 
		twoCornerTexture.setAttribute('willReadFrequently', true); 
		threeCornerTexture.setAttribute('willReadFrequently', true); 

		oneCornerBotTexture.setAttribute('willReadFrequently', true); 
		twoCornerBotTexture.setAttribute('willReadFrequently', true); 
		threeCornerBotTexture.setAttribute('willReadFrequently', true); 

		// Set the texture sizes
		const spriteResolution = this.tileSize / 2;
		const finalTileBaseResolution = spriteResolution * 2;

		fullTexture.width = spriteResolution;
		fullTexture.height = spriteResolution;

		oneCornerTexture.width = spriteResolution;
		oneCornerTexture.height = spriteResolution;

		twoCornerTexture.width = spriteResolution;
		twoCornerTexture.height = spriteResolution;

		threeCornerTexture.width = spriteResolution;
		threeCornerTexture.height = spriteResolution;	

		oneCornerBotTexture.width = spriteResolution;
		oneCornerBotTexture.height = spriteResolution;	

		twoCornerBotTexture.width = spriteResolution;
		twoCornerBotTexture.height = spriteResolution;	

		threeCornerBotTexture.width = spriteResolution;
		threeCornerBotTexture.height = spriteResolution;	
		
		// Get sprite textures
		const fullSprite = sprites[this.TileAtom.Full];
		const fullVariationSprite = sprites[this.TileAtom.FullVariation]; // Sprite 4

		const oneCornerSprite = sprites[this.TileAtom.OneCorner];
		const twoCornerSprite = sprites[this.TileAtom.TwoCorner];
		const threeCornerSprite = sprites[this.TileAtom.ThreeCorner];

		const oneCornerBotSprite = sprites[this.TileAtom.OneCornerBot];
		const twoCornerBotSprite = sprites[this.TileAtom.TwoCornerBot];
		const threeCornerBotSprite = sprites[this.TileAtom.ThreeCornerBot];

		// Create CanvasRenderingContext2D objects for each texture
		const fullCtx = fullTexture.getContext("2d");
		const fullVariationTexture = document.createElement("canvas");
		fullVariationTexture.width = spriteResolution;
		fullVariationTexture.height = spriteResolution;
		fullVariationTexture.setAttribute('willReadFrequently', true);
		const fullVariationCtx = fullVariationTexture.getContext("2d");

		const oneCornerCtx = oneCornerTexture.getContext("2d", { willReadFrequently: true });
		const twoCornerCtx = twoCornerTexture.getContext("2d", { willReadFrequently: true });
		const threeCornerCtx = threeCornerTexture.getContext("2d", { willReadFrequently: true });

		const oneCornerBotCtx = oneCornerBotTexture.getContext("2d", { willReadFrequently: true });
		const twoCornerBotCtx = twoCornerBotTexture.getContext("2d", { willReadFrequently: true });
		const threeCornerBotCtx = threeCornerBotTexture.getContext("2d", { willReadFrequently: true });
		
		// Copy pixels from sprites to texture canvases
		fullCtx.drawImage(fullSprite,0,0);
		fullVariationCtx.drawImage(fullVariationSprite,0,0);

		oneCornerCtx.drawImage(oneCornerSprite,0,0);
		twoCornerCtx.drawImage(twoCornerSprite,0,0);
		threeCornerCtx.drawImage(threeCornerSprite,0,0);

		oneCornerBotCtx.drawImage(oneCornerBotSprite,0,0);
		twoCornerBotCtx.drawImage(twoCornerBotSprite,0,0);
		threeCornerBotCtx.drawImage(threeCornerBotSprite,0,0);

		// Get pixel data from the canvases
		const fullImageData = fullCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const fullVariationImageData = fullVariationCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerTopRightImageData = oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerTopLeftImageData = this.flipTextureHorizontal(oneCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));	

		const oneCornerBotRightImageData = oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const oneCornerBotLeftImageData = this.flipTextureHorizontal(oneCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));	
		
		const twoCornerTopImageData = twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const twoCornerLeftImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), -Math.PI / 2);
		const twoCornerRightImageData = this.rotateTexture(twoCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution), Math.PI / 2);
		const twoCornerBottomImageData = twoCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		
		const threeCornerTopRightImageData = threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const threeCornerTopLeftImageData = this.flipTextureHorizontal(threeCornerCtx.getImageData(0, 0, spriteResolution, spriteResolution));		
		const threeCornerBottomRightImageData = threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution);
		const threeCornerBottomLeftImageData = this.flipTextureHorizontal(threeCornerBotCtx.getImageData(0, 0, spriteResolution, spriteResolution));
				
			
		// Define molecule objects
		const moleculeCanvas = document.createElement("canvas");

		moleculeCanvas.width = finalTileBaseResolution;
		moleculeCanvas.height = finalTileBaseResolution;
		
		const moleculeCtx = moleculeCanvas.getContext('2d', { willReadFrequently: true });

		const cornerCanvas = document.createElement("canvas");

		cornerCanvas.width = finalTileBaseResolution / 2;
		cornerCanvas.height = finalTileBaseResolution / 2;
		
		const cornerCtx = cornerCanvas.getContext('2d', { willReadFrequently: true });

		var imageDataList = [
			//FULL
			this.createMolecule(moleculeCtx, fullImageData, fullImageData, fullImageData, fullImageData),

			//CORNERS
			oneCornerTopLeftImageData, 
			oneCornerTopRightImageData,
			oneCornerBotLeftImageData,
			oneCornerBotRightImageData,
			//EDGES
			this.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, fullImageData, fullImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, twoCornerLeftImageData, fullImageData),
			this.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, fullImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, fullImageData, fullImageData, twoCornerBottomImageData, twoCornerBottomImageData),

			//TUNNELS
			this.createMolecule(moleculeCtx, twoCornerTopImageData, twoCornerTopImageData, twoCornerBottomImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, twoCornerLeftImageData, twoCornerRightImageData),

			//TWO SIDES
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, twoCornerLeftImageData, fullImageData),
			this.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, fullImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, fullImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, fullImageData, twoCornerRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),

			//PENNINSULAS		
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, twoCornerLeftImageData, twoCornerRightImageData),
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, twoCornerTopImageData, threeCornerBottomLeftImageData, twoCornerBottomImageData),
			this.createMolecule(moleculeCtx, twoCornerTopImageData, threeCornerTopRightImageData, twoCornerBottomImageData, threeCornerBottomRightImageData),
			this.createMolecule(moleculeCtx, twoCornerLeftImageData, twoCornerRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),

			//ISLAND
			this.createMolecule(moleculeCtx, threeCornerTopLeftImageData, threeCornerTopRightImageData, threeCornerBottomLeftImageData, threeCornerBottomRightImageData),

			//FULL VARIATION (sprite 4)
			this.createMolecule(moleculeCtx, fullVariationImageData, fullVariationImageData, fullVariationImageData, fullVariationImageData),
		];

		return imageDataList;
	}

	createMolecule(context, TLImageData, TRImageData, BLImageData, BRImageData) {
		let size = context.canvas.width;
		let spriteResolution = size / 2;
		context.fillStyle = 'black';
		context.fillRect(0, 0, size, size);
		context.putImageData(TLImageData, 0, 0);
		context.putImageData(TRImageData, spriteResolution, 0);
		context.putImageData(BLImageData, 0, spriteResolution);
		context.putImageData(BRImageData, spriteResolution, spriteResolution);
		return context.getImageData(0, 0, size, size);
	}

	extractSpritesFromSheet(spriteSheet, columns, rows) {
		let sprites = [];
		let spriteWidth = spriteSheet.width / columns;
		let spriteHeight = spriteSheet.height / rows;
	
		for (let y = 0; y < rows; y++) {
			for (let x = 0; x < columns; x++) {
				let canvas = document.createElement('canvas');
				canvas.width = spriteWidth;
				canvas.height = spriteHeight;
				let context = canvas.getContext('2d');
				context.drawImage(spriteSheet, x * spriteWidth, y * spriteHeight, spriteWidth, spriteHeight, 0, 0, spriteWidth, spriteHeight);
				sprites.push(canvas);
			}
		}
	
		return sprites;
	}
	
	getSpriteRotations(imageDataList) {
		let rotationDict = {};

		let requiredTransforms = {};

		requiredTransforms[this.TileMolecule.Full] = [];
		requiredTransforms[this.TileMolecule.Corner] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Edge] = [this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Tunnel] = [this.TileTransforms.CounterClockWise90];
		requiredTransforms[this.TileMolecule.TwoSides] = [this.TileTransforms.FlipHorizontal, this.TileTransforms.FlipVertical, this.TileTransforms.Rotate180];
		requiredTransforms[this.TileMolecule.Penninsula] = [this.TileTransforms.FlipVertical, this.TileTransforms.ClockWise90, this.TileTransforms.CounterClockWise90];
		requiredTransforms[this.TileMolecule.Island] = [];

		Object.keys(imageDataList).forEach(moleculeType => {
			let rotations = {};
			let colors = imageDataList[moleculeType];
			rotations[this.TileTransforms.None] = colors;

			if (requiredTransforms[moleculeType].includes(this.TileTransforms.ClockWise90)) {
				rotations[this.TileTransforms.ClockWise90] = this.rotateTexture(colors, Math.PI / 2);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.CounterClockWise90)) {
				rotations[this.TileTransforms.CounterClockWise90] = this.rotateTexture(colors, -Math.PI / 2);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.Rotate180)) {
				rotations[this.TileTransforms.Rotate180] = this.rotateTexture(colors, Math.PI);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipHorizontal)) {
				rotations[this.TileTransforms.FlipHorizontal] = this.flipTextureHorizontal(colors);
			}
			if (requiredTransforms[moleculeType].includes(this.TileTransforms.FlipVertical)) {
				rotations[this.TileTransforms.FlipVertical] = this.flipTextureVertical(colors);
			}

			rotationDict[moleculeType] = rotations;
		});

		return rotationDict;
	}

	rotateTexture(imageData, angle) {
		return this.canvasUtility.rotateTexture(imageData, angle);
	}

	flipTextureVertical(imageData) {
		return this.canvasUtility.flipTextureVertical(imageData);
	}

	flipTextureHorizontal(imageData) {
		return this.canvasUtility.flipTextureHorizontal(imageData);
	}

	analyzeTile(x, y) {
		let tileAnalysis = new this.TileAnalysis();
		let row = y;
		let col = x;

		if (row < 0 || row >= this.numColumns || col < 0 || col >= this.numColumns) {
			return tileAnalysis; // Out of bounds
		}

		tileAnalysis.heightIndex = this.tileMap[row][col];

		// Helper function to check if a location is within bounds
		function isWithinBounds(r, c, n) {
			return r >= 0 && r < n && c >= 0 && c < n;
		}

		// Helper function to check and update tile analysis
		var checkAndUpdate = ((r, c, n, direction, propertyLess) => {
			if (isWithinBounds(r, c, n) ) {
				tileAnalysis[direction] = this.tileMap[r][c];
				if( this.tileMap[r][c] < tileAnalysis.heightIndex) {
					tileAnalysis[propertyLess] = true;
					if(['topLess', 'leftLess', 'rightLess', 'botLess'].indexOf(propertyLess) >= 0 ) {
						tileAnalysis.neighborLowerCount++;
					} else if(['cornerTopLeftLess', 'cornerTopRightLess', 'cornerBottomLeftLess', 'cornerBottomRightLess'].indexOf(propertyLess) >= 0) {
						tileAnalysis.cornerLowerCount++;
					}
				}
			}
		});

		checkAndUpdate(row - 1, col, this.numColumns, 'topHeight', 'topLess');
		checkAndUpdate(row, col - 1, this.numColumns, 'leftHeight', 'leftLess');
		checkAndUpdate(row, col + 1, this.numColumns, 'rightHeight', 'rightLess');
		checkAndUpdate(row + 1, col, this.numColumns, 'botHeight', 'botLess');
		checkAndUpdate(row - 1, col - 1, this.numColumns, 'topLeftHeight', 'cornerTopLeftLess');
		checkAndUpdate(row - 1, col + 1, this.numColumns, 'topRightHeight', 'cornerTopRightLess');
		checkAndUpdate(row + 1, col - 1, this.numColumns, 'botLeftHeight', 'cornerBottomLeftLess');
		checkAndUpdate(row + 1, col + 1, this.numColumns, 'botRightHeight', 'cornerBottomRightLess');

		return tileAnalysis;
	}

	// Function to generate a random integer between min and max (inclusive)
	getRandomInt(min, max) {
		return Math.floor(Math.random() * (max - min + 1)) + min;
	}

	// Function to generate a random 10x10 map
	generateRandomMap(rows, columns) {
		let map = [];
		for (let i = 0; i < rows; i++) {
			let row = [];
			for (let j = 0; j < columns; j++) {
				row.push(getRandomInt(0, layers.length - 1)); // Random height between 0 and 10
			}
			map.push(row);
		}
		return map;
	}

	analyzeMap() {
		let analyzedTiles = [];

		for (let i = 0; i < this.numColumns; i++) {
			for (let j = 0; j < this.numColumns; j++) {
				analyzedTiles.push(this.analyzeTile(j, i));
			}
		}

		return analyzedTiles;
	}

	getTransformedTexture(transformationDict, tileAnalysis, molecule){
		switch(tileAnalysis.neighborLowerCount){				
			case 1:
				if(tileAnalysis.leftLess){                    
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				} else if(tileAnalysis.rightLess){
                    return transformationDict[molecule][this.TileTransforms.ClockWise90];
				} else if(tileAnalysis.botLess){		
					return transformationDict[molecule][this.TileTransforms.Rotate180];
				}
				break;
			case 2:
				if(tileAnalysis.topLess && tileAnalysis.leftLess){
					return transformationDict[molecule][this.TileTransforms.FlipHorizontal];
				} else if(tileAnalysis.botLess && tileAnalysis.leftLess){		
					return transformationDict[molecule][this.TileTransforms.Rotate180];
				} else if(tileAnalysis.botLess && tileAnalysis.rightLess){		
					return transformationDict[molecule][this.TileTransforms.FlipVertical];
				} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				}
				break;
			case 3:
				if(!tileAnalysis.topLess){
					return transformationDict[molecule][this.TileTransforms.FlipVertical];
				} else if(!tileAnalysis.leftLess){		
					return transformationDict[molecule][this.TileTransforms.ClockWise90];
				} else if(!tileAnalysis.rightLess){		
					return transformationDict[molecule][this.TileTransforms.CounterClockWise90];
				}
				break;
			case 4:
				break;
			default:
				break;
		}		
        return transformationDict[molecule][this.TileTransforms.None];
	}

	getMoleculeByTileAnalysis(tileAnalysis){
		var molecule = this.TileCliffMolecules.Full;								
		switch(tileAnalysis.neighborLowerCount){
			case 0: 
				// Randomly choose between Full (sprite 0) and FullVariation (sprite 4)
				molecule = Math.random() < 0.5 ? this.TileCliffMolecules.Full : this.TileCliffMolecules.FullVariation;
				break;
			case 1:
				if(tileAnalysis.topLess) {
					molecule = this.TileCliffMolecules.EdgeT;
				} else if(tileAnalysis.leftLess) {
					molecule = this.TileCliffMolecules.EdgeL;
				} else if(tileAnalysis.rightLess) {
					molecule = this.TileCliffMolecules.EdgeR;
				} else if(tileAnalysis.botLess) {
					molecule = this.TileCliffMolecules.EdgeB;
				}
				break;
			case 2:
				if(tileAnalysis.topLess && tileAnalysis.botLess){
					molecule = this.TileCliffMolecules.TunnelH;
				} else if(tileAnalysis.leftLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TunnelV;
				} else if(tileAnalysis.topLess && tileAnalysis.leftLess){
					molecule = this.TileCliffMolecules.TwoSidesTL;
				} else if(tileAnalysis.topLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TwoSidesTR;
				} else if(tileAnalysis.botLess && tileAnalysis.leftLess){
					molecule = this.TileCliffMolecules.TwoSidesBL;
				} else if(tileAnalysis.botLess && tileAnalysis.rightLess){
					molecule = this.TileCliffMolecules.TwoSidesBR;
				} 
				break;
			case 3:
				if( !tileAnalysis.topLess ) {
					molecule = this.TileCliffMolecules.PenninsulaB;
				} else if( !tileAnalysis.leftLess ) {
					molecule = this.TileCliffMolecules.PenninsulaR;
				} else if( !tileAnalysis.rightLess ) {
					molecule = this.TileCliffMolecules.PenninsulaL;
				} else if( !tileAnalysis.botLess ) {
					molecule = this.TileCliffMolecules.PenninsulaT;
				}
				break;								
			case 4:
				molecule = this.TileCliffMolecules.Island;
				break;
		}
		return molecule;
	}

	colorImageData(imageData, tileAnalysis) {
		
		const data = new Uint8ClampedArray(imageData.data);
		var directions = ['topHeight', 'leftHeight', 'rightHeight', 'botHeight', 'topLeftHeight', 'topRightHeight', 'botLeftHeight', 'botRightHeight'];
		let heightCounts = {};
		directions.forEach((direction) => {
			let height = tileAnalysis[direction];
			if (height !== tileAnalysis.heightIndex) {
				if (!heightCounts[height]) {
					heightCounts[height] = 0;
				}
				heightCounts[height]++;
			}
		});
		
		let lowerNeighborHeight = Math.max(0, tileAnalysis.heightIndex - 1);
		let maxCount = 0;
		Object.keys(heightCounts).forEach((height) => {
			if (heightCounts[height] > maxCount && height < tileAnalysis.heightIndex) {
				lowerNeighborHeight = parseInt(height);
				maxCount = heightCounts[height];
			}
		});
		const numPixels = this.tileSize * this.tileSize;
		if(lowerNeighborHeight < 0){
			const blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)
			blackData.fill(0); // Fill with black (0, 0, 0, 255)
			return new ImageData(blackData, this.tileSize, this.tileSize);
		}
		let baseColors = this.layerTextures[tileAnalysis.heightIndex][this.TileMolecule.Full].data;
		let neighborColors = this.layerTextures[lowerNeighborHeight][this.TileMolecule.Full].data;

		// Iterate over each pixel
		for (let i = 0; i < numPixels; i++) {
			const dataIndex = i * 4;
			let pColor = { r: data[dataIndex], g: data[dataIndex + 1], b: data[dataIndex + 2], a: data[dataIndex + 3] };
			let bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };
			let tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };
	
			if (this.layerTextures.length > tileAnalysis.heightIndex) {
				if (baseColors.length > i) {
					bColor = { r: baseColors[dataIndex], g: baseColors[dataIndex + 1], b: baseColors[dataIndex + 2], a: baseColors[dataIndex + 3] };
				}
			}
			if (lowerNeighborHeight >= 0) {
				if (neighborColors.length > i) {
					tColor = { r: neighborColors[dataIndex], g: neighborColors[dataIndex + 1], b: neighborColors[dataIndex + 2], a: neighborColors[dataIndex + 3] };
				}
			}
			let fColor = pColor;
			if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 0 })) fColor = pColor;
			if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) fColor = bColor;

			data.set([fColor.r, fColor.g, fColor.b, fColor.a], dataIndex);
		}
		return new ImageData(data, this.tileSize, this.tileSize);
	}

	isEqualColor(color1, color2) {
		return color1.r === color2.r && color1.g === color2.g && color1.b === color2.b && color1.a === color2.a;
	}

	addCornerGraphics(imageData, tileAnalysis) {
		let cornerSize = this.tileSize / 2;
		let cornerTexture;
		let heightIndex = tileAnalysis.heightIndex;
	
		if (tileAnalysis.cornerLowerCount > 0) {
			if (tileAnalysis.cornerTopLeftLess && (!tileAnalysis.topLess && !tileAnalysis.leftLess)) {				
				cornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerTL];
				imageData = this.colorCornerTextureRoutine(imageData, 0, 0, cornerTexture, tileAnalysis);			
			}
			// Assuming tileAnalysis, textureDict, and other variables are already defined
			if (tileAnalysis.cornerTopRightLess && (!tileAnalysis.topLess && !tileAnalysis.rightLess)) {				
				cornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerTR];
				imageData = this.colorCornerTextureRoutine(imageData, cornerSize, 0, cornerTexture, tileAnalysis);			
			}

			if (tileAnalysis.cornerBottomLeftLess && (!tileAnalysis.botLess && !tileAnalysis.leftLess)) {				
				cornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerBL];
				imageData = this.colorCornerTextureRoutine(imageData, 0, cornerSize, cornerTexture, tileAnalysis);			
			}

			if (tileAnalysis.cornerBottomRightLess && (!tileAnalysis.botLess && !tileAnalysis.rightLess)) {			
				cornerTexture = this.layerTextures[heightIndex][this.TileCliffMolecules.CornerBR];
				imageData = this.colorCornerTextureRoutine(imageData, cornerSize, cornerSize, cornerTexture, tileAnalysis);			
			}
		}
		return imageData;
	}
	
	colorCornerTextureRoutine(outputImageData, x, y, cornerImageData, tileAnalysis) {
		let cornerSize = this.tileSize / 2;	
		let baseHeightIndex = tileAnalysis.heightIndex;
		let baseColors = this.layerTextures[baseHeightIndex][this.TileMolecule.Full];
		const data = new Uint8ClampedArray(outputImageData.data);
		for (let j = 0; j < cornerSize; j++) {
			for (let i = 0; i < cornerSize; i++) {
				// Calculate the correct position in the output image data
				let outputIndex = ((y + j) * this.tileSize + (x + i)) * 4;
	
				let baseColor = this.getColorFromImageData(baseColors, outputIndex);
		
				let sourceOriginX = i;
				let sourceOriginY = j * cornerSize;
				let sourcePixel = (sourceOriginY + sourceOriginX) * 4;
				let pColor = this.getColorFromImageData(cornerImageData, sourcePixel);
				let fColor = pColor;
				if (this.isEqualColor(fColor, { r: 0, g: 0, b: 0, a: 255 })) {
					fColor = baseColor;				
				}
	
				data[outputIndex] = fColor.r;
				data[outputIndex + 1] = fColor.g;
				data[outputIndex + 2] = fColor.b;
				data[outputIndex + 3] = fColor.a;
			}
		}

		return new ImageData(data, this.tileSize, this.tileSize);
	}
	
	getColorFromImageData(imageData, index) {
		return {
			r: imageData.data[index],
			g: imageData.data[index + 1],
			b: imageData.data[index + 2],
			a: imageData.data[index + 3]
		};
	}	
	
	addVariationImage(imageData, tileAnalysis) {
		const img = this.layerSpriteSheets[tileAnalysis.heightIndex];
	
		if (img && Math.random() < .25) {
			this.canvasUtility.setSize(imageData.width, imageData.height);
			
			
			// Paint the existing imageData onto the canvas
			this.canvasUtility.paintTexture(imageData);
	
			// Assuming img is a loaded Image object and you want to draw it at (0,0)
			// Draw the img over the imageData
			this.canvasUtility.ctx.drawImage(img, (imageData.width / 2) - img.width / 2,  (imageData.width / 2) - img.width / 2);
	
			// Get the updated imageData from the canvas
			return this.canvasUtility.ctx.getImageData(0, 0, imageData.width, imageData.height);
		} else {
			// If img is not available, return the original imageData
			return imageData;
		}
	}
	
	drawMap(analyzedMap) {
		const ctx = this.canvas.getContext('2d');
		const layerCanvases = {};
	
		for (let layerIndex = 0; layerIndex < this.layerTextures.length; layerIndex++) {
			const offscreenCanvas = document.createElement('canvas');
			offscreenCanvas.width = this.canvas.width;
			offscreenCanvas.height = this.canvas.height;
			layerCanvases[layerIndex] = offscreenCanvas;
			const offscreenCtx = offscreenCanvas.getContext('2d');
	
			analyzedMap.forEach((tileAnalysis, index) => {
				const x = (index % this.numColumns) * this.tileSize;
				const y = Math.floor(index / this.numColumns) * this.tileSize;
	
				let imageData;
				let _tileAnalysis = {...tileAnalysis };
				if (_tileAnalysis.heightIndex > layerIndex) {
					// Use base image data for higher layers
					_tileAnalysis.heightIndex = layerIndex;
					if(_tileAnalysis.topLess && _tileAnalysis.topHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.topLess = false;
						_tileAnalysis.neighborLowerCount--;
					}
					if(_tileAnalysis.leftLess && _tileAnalysis.leftHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.leftLess = false;
						_tileAnalysis.neighborLowerCount--;
					}
					if(_tileAnalysis.rightLess && _tileAnalysis.rightHeight >= _tileAnalysis.heightIndex){
						_tileAnalysis.rightLess = false;
						_tileAnalysis.neighborLowerCount--;
					}
					if(_tileAnalysis.botLess && _tileAnalysis.botHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.botLess = false;
						_tileAnalysis.neighborLowerCount--;
					}
					if(_tileAnalysis.cornerTopLeftLess && _tileAnalysis.topLeftHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.cornerTopLeftLess = false;
						_tileAnalysis.cornerLowerCount--;
					}
					if(_tileAnalysis.cornerTopRightLess && _tileAnalysis.topRightHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.cornerTopRightLess = false;
						_tileAnalysis.cornerLowerCount--;
					}
					if(_tileAnalysis.cornerBottomLeftLess && _tileAnalysis.botLeftHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.cornerBottomLeftLess = false;
						_tileAnalysis.cornerLowerCount--;
					}
					if(_tileAnalysis.cornerBottomRightLess && _tileAnalysis.botRightHeight >= _tileAnalysis.heightIndex) {
						_tileAnalysis.cornerBottomRightLess = false;
						_tileAnalysis.cornerLowerCount--;
					}
					
				} 
				if (_tileAnalysis.heightIndex < layerIndex) {
					// Use transparent data for tiles below current layer
					let numPixels = this.tileSize * this.tileSize;
					const transparentData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)
					
					for (let i = 0; i < numPixels * 4; i += 4) {
						transparentData[i] = 0;     // Red (not important for transparency)
						transparentData[i + 1] = 0; // Green (not important for transparency)
						transparentData[i + 2] = 0; // Blue (not important for transparency)
						transparentData[i + 3] = 0; // Alpha (0 for full transparency)
					}
					
					imageData = new ImageData(transparentData, this.tileSize, this.tileSize);
					
				 } else {
					imageData = new ImageData(new Uint8ClampedArray(4), 1, 1);
					if( _tileAnalysis.heightIndex >= 0 ) {
						let molecule = this.getMoleculeByTileAnalysis(_tileAnalysis);						
						imageData = this.layerTextures[_tileAnalysis.heightIndex][molecule];
						imageData = this.colorImageData(imageData, _tileAnalysis);
						//imageData = this.addVariationImage(imageData, _tileAnalysis);
						imageData = this.addCornerGraphics(imageData, _tileAnalysis);
					} else {
						let numPixels = this.tileSize * this.tileSize;
						const blackData = new Uint8ClampedArray(numPixels * 4); // 4 values per pixel (RGBA)
						blackData.fill(0); // Fill with black (0, 0, 0, 255)
						imageData = new ImageData(blackData, this.tileSize, this.tileSize);
					}
				}

				// Update height map for this tile
				this.updateHeightMapForTile(x, y, tileAnalysis.heightIndex);
	
				offscreenCtx.putImageData(imageData, x + 2, y + 2);
			});
		}
	
		// Drawing each layer canvas onto the main canvas
		Object.keys(layerCanvases).forEach(layerIndex => {
			ctx.drawImage(layerCanvases[layerIndex], 0, 0);
		});
		
		// Store terrain data for height mapping
		this.terrainData = ctx.getImageData(0, 0, ctx.canvas.width, ctx.canvas.height).data;          
	}
};
window.engine.TileMap = window.COMPILED_GAME.libraryClasses.TileMap;

// Library: Entity
window.COMPILED_GAME.libraryClasses.Entity = class Entity {
    constructor(game, type) {
        this.game = game;
        this.children = [];        
        this.components = [];
        this.renderers = [];
        this.destroyed = false;        
        this.id = -1;
        this.type = type;
        this.collisionRadius = 5;   
        this.entityHeight = 10;        
    }

    init(params) {
        for(let c in this.components) {
            this.components[c].init(params);               
        }     
    }
    getAABB(position = this.transform.position) {
        return {
            min: {
                x: position.x - this.collisionRadius,
                y: position.y,
                z: position.z - this.collisionRadius
            },
            max: {
                x: position.x + this.collisionRadius,
                y: position.y + this.entityHeight,
                z: position.z + this.collisionRadius
            }
        };
    }

    getComponent(name) {
        return this.components[name.toLowerCase()] || this.components[`${name.toLowerCase()}`];
    }
    addRenderer(RendererClassName, params) {
        const RendererClass = this.game.moduleManager.getCompiledScript(RendererClassName, 'renderers');
        const renderer = new RendererClass(this.game, this);
        this.renderers[RendererClass.name.toLowerCase()] = renderer;
        this.components[RendererClass.name.toLowerCase()] = renderer;
        if(params){
            renderer.init(params);
        }
        return renderer;
    }
    addComponent(ComponentClassName, params) {        
        const ComponentClass = this.game.moduleManager.getCompiledScript(ComponentClassName, 'components');
        const component = new ComponentClass(this.game, this);
        this.components[ComponentClass.name.toLowerCase()] = component;
        if(params){
            component.init(params);
        }
        return component;
    }
    getNetworkComponentData(){
        let data = {};
        for(let c in this.components) {
            let cData = this.components[c].getNetworkData(); 
            if(cData){
                data[c] = cData;
            }
        }    
        return data;
    }
    setNetworkComponentData(data, isRemote=false){            
        if(data?.components){
            for(let c in data.components) {
                this.components[c]?.setNetworkData(data.components[c], isRemote); 
            }    
        }
    }
    removeComponent(component) {
        let index = this.components.indexOf(component);
        if( index >= 0 ) {
            this.components.splice(index, 1);
        }
    }
    update() {    
        for(let c in this.components) {
            this.components[c].update(); 
            if(this.destroyed) break;
        }                
    }
    postUpdate() {
        for(let c in this.components) {
            this.components[c].postUpdate();   
            if(this.destroyed) break;
        }     
    }
    draw() {
        for(let r in this.renderers) {
            this.renderers[r].draw();  
        }

    }
    OnCollision(collidedWith){
        for(let c in this.components) {
            this.components[c].OnCollision(collidedWith);                           
        }                
    }
    OnStaticCollision(){
        for(let c in this.components) {
            this.components[c].OnStaticCollision();                           
        }                
    }
    OnGrounded(){
        for(let c in this.components) {
            this.components[c].OnGrounded();                           
        }                
    }
    onPhysicsUpdate(timestamp, physicsStepMs)  {
        for(let c in this.components) {
            this.components[c].onPhysicsUpdate(timestamp, physicsStepMs);                           
        }     
    }
    addChild(entity){
        this.children.push(entity);
        entity.parent = this;
        return entity;
    }
    destroy() {
        this.destroyed = true;
        this.children.forEach((c) => {
            if(!c.destroyed){
                c.destroy();
            }
        });
        for(let c in this.components) {
            this.components[c].destroy();   
        }   
        for(let r in this.renderers) {
            this.renderers[r].destroy();   
        }   
    }
};
window.engine.Entity = window.COMPILED_GAME.libraryClasses.Entity;

// Library: Component
window.COMPILED_GAME.libraryClasses.Component = class Component {
    constructor(game, parent) { 
        this.game = game;
        this.parent = parent;
    }
    init(params) {}
    getComponent(type) {
        return this.parent.getComponent(type);
    }
    update() {}
    postUpdate() {}
    getNetworkData(){ return null }
    setNetworkData(data){ }
    onPhysicsUpdate(timestamp, physicsStepMs){}
    destroy() {}
}
;
window.engine.Component = window.COMPILED_GAME.libraryClasses.Component;

// Library: GameState
window.COMPILED_GAME.libraryClasses.GameState = class GameState {
    constructor(gameConfig = {}) {
        this.collections = gameConfig;
        let state = gameConfig.configs?.state;
     
        // Clear all existing properties
        for (let prop in this) {
            if (Object.prototype.hasOwnProperty.call(this, prop)) {
                delete this[prop];
            }
        }

        // Set only the properties from params
        for (let key in state) {
            if (Object.prototype.hasOwnProperty.call(state, key)) {
                this[key] = state[key];
            }
        }
        // If stats is present, create defaultStats as a copy
  
    }
}

if(typeof GameState != 'undefined'){
    if (typeof window !== 'undefined') {
        window.GameState = GameState;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = GameState;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = GameState;
        exports.GameState = GameState;
    }
};
window.engine.GameState = window.COMPILED_GAME.libraryClasses.GameState;

// Library: ModelManager
window.COMPILED_GAME.libraryClasses.ModelManager = class ModelManager {
    constructor(app, config, { ShapeFactory, palette, textures }) {
        this.app = app;
        this.config = config;
        this.shapeFactory = new ShapeFactory(palette, textures, null, 1);

        if (location.hostname.indexOf('github') >= 0) {
            this.shapeFactory.setURLRoot("/GUTS/");
        }

        // VAT-focused storage
        this.masterModels = new Map();           // objectType_spawnType -> THREE.Group (master models)
        this.animationModels = new Map();        // objectType_spawnType_animName -> THREE.Group
        this.vatBundles = new Map();             // objectType_spawnType -> { geometry, material, vatTexture, meta }
        this.vatBundlePromises = new Map();      // objectType_spawnType -> Promise

        this.assetsLoaded = false;
        this.app.modelManager = this;
    }

    clear() {
        this.masterModels.clear();
        this.animationModels.clear();
        this.vatBundles.clear();
        this.vatBundlePromises.clear();
    }

    dispose() {
        // Dispose VAT bundles
        for (const [key, bundle] of this.vatBundles) {
            if (bundle.geometry) bundle.geometry.dispose();
            if (bundle.material) bundle.material.dispose();
            if (bundle.vatTexture) bundle.vatTexture.dispose();
        }
        this.clear();
    }

    async loadModels(prefix, config) {

        // Load all models first (master + animations)
        for (const [type, cfg] of Object.entries(config)) {
            if (!cfg.render?.model) continue;

            const modelKey = `${prefix}_${type}`;

            // Load master model
            this.masterModels.set(modelKey, await this.createModel(cfg.render.model));

            // Load animation variants
            if (cfg.render.animations) {
                for (const [animName, variants] of Object.entries(cfg.render.animations)) {
                    for (let variantIndex = 0; variantIndex < variants.length; variantIndex++) {
                        const animVariant = variants[variantIndex];
                        const animKey = variantIndex === 0
                            ? `${modelKey}_${animName}`
                            : `${modelKey}_${animName}_${variantIndex}`;

                        // Merge animation model data
                        let mergedModel = JSON.parse(JSON.stringify(cfg.render.model));
                        if (animVariant && Object.keys(animVariant).length > 0) {
                            const mainGroupName = Object.keys(mergedModel)[0];
                            const animGroupName = Object.keys(animVariant)[0];
                            if (animVariant[animGroupName]?.shapes?.[0]?.url) {
                                mergedModel[mainGroupName].shapes[0].url = animVariant[animGroupName].shapes[0].url;
                            }
                        }

                        this.animationModels.set(animKey, await this.createModel(mergedModel));
                    }
                }
            }
        }

        this.assetsLoaded = true;
    }

    async createModel(modelData) {
        const rootGroup = new THREE.Group();
        for (const groupName in modelData) {
            const group = await this.shapeFactory.createMergedGroupFromJSON(
                modelData, {}, groupName, null, null
            );
            if (group) {
                rootGroup.add(group);
            }
        }
        return rootGroup;
    }

    // Main VAT bundle creation - called by RenderSystem
    async requestVATBundle(objectType, spawnType, unitDef) {
        const key = `${objectType}_${spawnType}`;

        // Return existing bundle
        if (this.vatBundles.has(key)) {
            return { ready: true, bundle: this.vatBundles.get(key) };
        }

        // Return in-progress promise
        if (this.vatBundlePromises.has(key)) {
            return { ready: false, promise: this.vatBundlePromises.get(key) };
        }

        // Start building VAT bundle
        const promise = this._buildVATBundle(key, objectType, spawnType, unitDef);
        this.vatBundlePromises.set(key, promise);

        try {
            const bundle = await promise;
            if (bundle) {
                this.vatBundles.set(key, bundle);
                return { ready: true, bundle };
            }
        } catch (error) {
            console.error(`[ModelManager] VAT bundle failed: ${key}`, error);
        } finally {
            this.vatBundlePromises.delete(key);
        }

        return { ready: false, error: 'VAT bundle creation failed' };
    }

    async _buildVATBundle(key, objectType, spawnType, unitDef) {

        // Get master model
        const masterModel = this.masterModels.get(key);
        if (!masterModel) {
            throw new Error(`Master model not found: ${key}`);
        }

        // Find any mesh - prefer skinned mesh but fallback to any mesh
        let targetMesh = null;
        let skeleton = null;
        
        masterModel.traverse(obj => {
            if (obj.isSkinnedMesh && obj.skeleton && !targetMesh) {
                targetMesh = obj;
                skeleton = obj.skeleton;
            } else if (obj.isMesh && !targetMesh) {
                targetMesh = obj;
            }
        });

        if (!targetMesh) {
            throw new Error(`No mesh found in: ${key}`);
        }

        // Collect animation clips (may be empty for static meshes)
        const clips = await this._collectAnimationClips(key, objectType, spawnType, unitDef);
        
        // If no skeleton or no clips, create a static "animation" 
        if (!skeleton || clips.length === 0) {
            return this._buildStaticVATBundle(key, masterModel, targetMesh);
        }

        // Standard VAT bundle with animations
        const vatData = await this._bakeVATTexture(masterModel, skeleton, clips);
        if (!vatData) {
            throw new Error(`VAT baking failed for: ${key}`);
        }

        vatData.clipIndexByName = this._buildClipIndexMap(vatData.clips);
        const material = this._createVATMaterial(targetMesh, vatData, key);
        const geometry = targetMesh.geometry.clone();

        // Copy bone data
        const skinIndexAttr = targetMesh.geometry.getAttribute('skinIndex');
        const skinWeightAttr = targetMesh.geometry.getAttribute('skinWeight');
        if (!skinIndexAttr || !skinWeightAttr) {
            throw new Error('Skinned geometry missing skinIndex/skinWeight attributes.');
        }
        
        geometry.setAttribute('aBoneIndex', skinIndexAttr.clone());
        geometry.setAttribute('aBoneWeight', skinWeightAttr.clone());

        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);

        return {
            geometry,
            material,
            vatTexture: vatData.texture,
            meta: {
                fps: vatData.fps,
                cols: vatData.cols,
                rows: vatData.rows,
                clips: vatData.clips,
                clipIndexByName: vatData.clipIndexByName,
                skeleton: skeleton,
                attachmentTexture: vatData.attachmentTexture,
                attachmentBones: vatData.attachmentBones
            }
        };
    }

    // Add method for static meshes without skeletons:
    _buildStaticVATBundle(key, masterModel, mesh) {
            console.log('build static', key);
        const clips = [{ name: 'idle', startRow: 0, frames: 1 }];
        const clipIndexByName = { 'idle': 0 };
        
        // Now use clips in the material creation
        const identityData = new Float32Array([
            1, 0, 0, 0,  // identity matrix column 0
            0, 1, 0, 0,  // identity matrix column 1  
            0, 0, 1, 0,  // identity matrix column 2
            0, 0, 0, 1   // identity matrix column 3
        ]);

        const identityTexture = new THREE.DataTexture(
            identityData, 4, 1, THREE.RGBAFormat, THREE.FloatType
        );
        identityTexture.needsUpdate = true;
        identityTexture.flipY = false;

        // Then use this instead of null:
        const material = this._createVATMaterial(mesh, {
            texture: identityTexture,  // Instead of null
            clips: clips,
            clipIndexByName: clipIndexByName,
            fps: 30,
            cols: 4,
            rows: 1
        }, key);

        material.userData.batchKey = key;
        material.customProgramCacheKey = () => key;
        material.needsUpdate = true;

        const geometry = mesh.geometry.clone();
        const positionCount = geometry.getAttribute('position').count;
        
        // Create identity bone data (all vertices use bone 0 with weight 1)
        const boneIndices = new Float32Array(positionCount * 4);
        const boneWeights = new Float32Array(positionCount * 4);
        
        for (let i = 0; i < positionCount; i++) {
            boneIndices[i * 4] = 0;     // bone index 0
            boneWeights[i * 4] = 1;     // full weight
            // other indices/weights remain 0
        }
        
        geometry.setAttribute('aBoneIndex', new THREE.BufferAttribute(boneIndices, 4));
        geometry.setAttribute('aBoneWeight', new THREE.BufferAttribute(boneWeights, 4));

        this._ensureFloatAttribute(geometry, 'aClipIndex', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimTime', 1, 0.0);
        this._ensureFloatAttribute(geometry, 'aAnimSpeed', 1, 1.0);
        const baseScale = (masterModel && masterModel.children[0]?.scale) ? masterModel.children[0].scale : new THREE.Vector3(1, 1, 1);
        const basePos = (masterModel && masterModel.children[0]?.position) ? masterModel.children[0].position : new THREE.Vector3(0, 0, 0);

        return {
            geometry,
            material,
            vatTexture: null, // No animation texture needed
            meta: {
                fps: 30,
                cols: 4,   // Identity matrix
                rows: 1,   // Single frame
                clips: clips,
                clipIndexByName: clipIndexByName,
                baseScale: baseScale,
                basePos: basePos
            }
        };
    }
    
    _ensureFloatAttribute(geometry, name, itemSize, fillValue = 0.0) {
        if (!geometry.getAttribute(name)) {
            const pos = geometry.getAttribute('position');
            const count = pos ? pos.count : 0;
            const arr = new Float32Array(count * itemSize);
            if (fillValue !== 0.0) arr.fill(fillValue);
            geometry.setAttribute(name, new THREE.BufferAttribute(arr, itemSize));
        }
    }

    async _collectAnimationClips(key, objectType, spawnType, unitDef) {
        const clips = [];

        // Define standard animation names in order
        const animNames = ['idle', 'walk', 'attack', 'cast', 'death', 'celebrate'];

        for (const animName of animNames) {
            // Skip if not defined in unit config
            if (!unitDef?.render?.animations?.[animName]) continue;

            try {
                // Try to get animation model
                const animKey = `${key}_${animName}`;
                const animModel = this.animationModels.get(animKey);

                if (animModel) {
                    // Extract clip from animation model
                    let clip = null;
                    animModel.traverse(obj => {
                        if (obj.userData?.animations?.[0]) {
                            clip = obj.userData.animations[0];
                        }
                    });

                    if (clip) {
                        clips.push({ name: animName, clip });
                    }
                } else {
                    console.warn(`[ModelManager] Animation model not found: ${animKey}`);
                }
            } catch (error) {
                console.warn(`[ModelManager] Failed to load animation '${animName}' for ${key}:`, error);
            }
        }

        // Ensure we have at least idle
        if (clips.length === 0 || !clips.some(c => c.name === 'idle')) {
            // Create a default idle clip
            const defaultClip = new THREE.AnimationClip('idle', 1.0, []);
            clips.unshift({ name: 'idle', clip: defaultClip });
        }

        return clips;
    }

    async _bakeVATTexture(masterModel, skeleton, clipData, fps = 30) {

        const bones = skeleton.bones;
        const boneCount = bones.length;
        const bindMatrices = skeleton.boneInverses;

        // Calculate texture dimensions
        const cols = boneCount * 4; // 4 columns per bone (matrix rows)
        let totalFrames = 0;

        const clipMeta = clipData.map(({ name, clip }) => {
            const duration = clip.duration || 1.0;
            const frames = Math.max(1, Math.ceil(duration * fps));
            totalFrames += frames;
            return { name, clip, duration, frames };
        });

        const rows = totalFrames;

        // Create texture data
        const textureData = new Float32Array(rows * cols * 4); // RGBA
        const mixer = new THREE.AnimationMixer(masterModel);
        const tempMatrix = new THREE.Matrix4();

        let currentRow = 0;

        // Bake each clip
        for (const clipInfo of clipMeta) {
            const action = mixer.clipAction(clipInfo.clip);
            action.play();


            // Bake frames for this clip
            for (let frame = 0; frame < clipInfo.frames; frame++) {
                // Calculate time for this frame
                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;
                mixer.setTime(t);
                masterModel.updateMatrixWorld(true);

                // Bake bone matrices for this frame
                for (let boneIndex = 0; boneIndex < boneCount; boneIndex++) {
                    // Calculate final bone matrix (world * inverse bind)
                    tempMatrix.copy(bones[boneIndex].matrixWorld);
                    tempMatrix.multiply(bindMatrices[boneIndex]);

                    // Store matrix as 4 columns (transposed for shader)
                    const elements = tempMatrix.elements; // column-major
                    const textureRowIndex = currentRow + frame;
                    const boneColumnStart = boneIndex * 4;

                    for (let col = 0; col < 4; col++) {
                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;
                        // Store column of matrix as RGBA
                        textureData[pixelIndex + 0] = elements[col * 4 + 0]; // x
                        textureData[pixelIndex + 1] = elements[col * 4 + 1]; // y
                        textureData[pixelIndex + 2] = elements[col * 4 + 2]; // z
                        textureData[pixelIndex + 3] = elements[col * 4 + 3]; // w
                    }
                }
            }

            action.stop();
            currentRow += clipInfo.frames;
        }

        // Create texture
        const texture = new THREE.DataTexture(
            textureData,
            cols,
            rows,
            THREE.RGBAFormat,
            THREE.FloatType
        );
        texture.needsUpdate = true;
        texture.flipY = false;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        // Build clip info with row ranges
        let rowOffset = 0;
        const clips = clipMeta.map(info => {
            const clipData = {
                name: info.name,
                startRow: rowOffset,
                endRow: rowOffset + info.frames,
                frames: info.frames,
                duration: info.duration
            };
            rowOffset += info.frames;
            return clipData;
        });

        const attachmentData = await this._bakeBoneAttachmentTexture(
            masterModel, bones, bindMatrices, mixer, clipMeta, fps
        );

        return {
            texture,
            cols,
            rows,
            fps,
            clips,
            boneCount,
            attachmentTexture: attachmentData.texture,
            attachmentBones: attachmentData.bones
        };

  
    }

    _createVATMaterial(baseMesh, vatData, batchKey = 'unknown') {
        // Get base material properties
        const sourceMaterial = Array.isArray(baseMesh.material)
            ? baseMesh.material[0]
            : baseMesh.material;

        // Create VAT material (do NOT enable skinning; we aren't using Three's path)
        const material = new THREE.MeshStandardMaterial({
            map: sourceMaterial?.map || null,
            color: sourceMaterial?.color?.clone() || new THREE.Color(0xffffff),
            metalness: sourceMaterial?.metalness ?? 0.5,
            roughness: sourceMaterial?.roughness ?? 0.5,
            transparent: false
        });

        // Add VAT shader modifications
        material.side = THREE.DoubleSide;           // helps if any frames flip winding
        material.metalness = sourceMaterial?.metalness ?? 0.05; // less metal, easier to see
        material.roughness = sourceMaterial?.roughness ?? 0.9;  // more diffuse light
        // Make VAT lookups crisp (optional but recommended)
        if(vatData.texture){
            vatData.texture.magFilter = THREE.NearestFilter;
            vatData.texture.minFilter = THREE.NearestFilter;
        }
        // Force unique shader compilation per batch
        material.userData.batchKey = batchKey;
        material.customProgramCacheKey = () => batchKey;

        material.onBeforeCompile = (shader) => {
            shader.uniforms.uVATTexture = { value: vatData.texture };
            shader.uniforms.uVATCols    = { value: vatData.cols };
            shader.uniforms.uVATRows    = { value: vatData.rows };
            shader.uniforms.uVATFPS     = { value: vatData.fps };

            // FIXED: Generate unique defines per batch to prevent cross-batch contamination
            const batchPrefix = batchKey.toUpperCase().replace(/[^A-Z0-9]/g, '_');
            const clipDefines = vatData.clips.map((clip, index) => `
                #define ${batchPrefix}_CLIP_${index}_START ${clip.startRow}.0
                #define ${batchPrefix}_CLIP_${index}_FRAMES ${clip.frames}.0
            `).join('\n');


            const clipHelpers = `
                float getClipStartRow(float clipIndex) {
                    ${vatData.clips.map((clip, i) => 
                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_START;`
                    ).join('\n                    ')}
                    return ${batchPrefix}_CLIP_0_START;
                }
                float getClipFrames(float clipIndex) {
                    ${vatData.clips.map((clip, i) => 
                        `if (abs(clipIndex - ${i}.0) < 0.5) return ${batchPrefix}_CLIP_${i}_FRAMES;`
                    ).join('\n                    ')}
                    return ${batchPrefix}_CLIP_0_FRAMES;
                }
                mat4 sampleVATMatrix(float row, float boneIndex) {
                    float boneColStart = boneIndex * 4.0;
                    float v = (row + 0.5) / uVATRows;
                    vec4 c0 = texture2D(uVATTexture, vec2((boneColStart + 0.5) / uVATCols, v));
                    vec4 c1 = texture2D(uVATTexture, vec2((boneColStart + 1.5) / uVATCols, v));
                    vec4 c2 = texture2D(uVATTexture, vec2((boneColStart + 2.5) / uVATCols, v));
                    vec4 c3 = texture2D(uVATTexture, vec2((boneColStart + 3.5) / uVATCols, v));
                    return mat4(c0, c1, c2, c3);  // columns
                }
            `;

            // strip three's skinning prelude (we supply our own attributes)
            shader.vertexShader = shader.vertexShader.replace('#include <skinning_pars_vertex>', '');

            shader.vertexShader = shader.vertexShader.replace(
                'void main() {',
                `
                // Custom VAT attributes
                attribute vec4 aBoneIndex;
                attribute vec4 aBoneWeight;
                attribute float aClipIndex;
                attribute float aAnimTime;
                attribute float aAnimSpeed;

                uniform sampler2D uVATTexture;
                uniform float uVATCols;
                uniform float uVATRows;
                uniform float uVATFPS;

                ${clipDefines}
                ${clipHelpers}

                // Shared temporaries
                float _vat_currentRow;
                mat4 _vat_bm0, _vat_bm1, _vat_bm2, _vat_bm3;

                void main() {
                `
            );

            shader.vertexShader = shader.vertexShader.replace(
            '#include <beginnormal_vertex>',
            `
            // Determine current frame
            float _clipStart  = getClipStartRow(aClipIndex);
            float _clipFrames = getClipFrames(aClipIndex);
            float _frame      = floor(mod(aAnimTime * uVATFPS, _clipFrames));
            _vat_currentRow   = _clipStart + _frame;

            // Normalize bone weights (must be available here)
            float wsum_bn = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;
            vec4 w = (wsum_bn > 0.0) ? (aBoneWeight / wsum_bn) : vec4(1.0, 0.0, 0.0, 0.0);

            // Sample bone matrices for this frame (needed for normals too)
            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);
            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);
            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);
            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);

            // Skin the normal and renormalize
            vec3 n = normal;
            vec3 skinnedN =
                    mat3(_vat_bm0) * n * w.x +
                    mat3(_vat_bm1) * n * w.y +
                    mat3(_vat_bm2) * n * w.z +
                    mat3(_vat_bm3) * n * w.w;

            vec3 objectNormal = normalize(skinnedN);
            `
            );

            // --- begin_vertex: (re)compute weights & use same matrices to skin position
            shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `
            // Recompute (safe if driver reorders chunks)
            float wsum_bv = aBoneWeight.x + aBoneWeight.y + aBoneWeight.z + aBoneWeight.w;
            vec4 w2 = (wsum_bv > 0.0) ? (aBoneWeight / wsum_bv) : vec4(1.0, 0.0, 0.0, 0.0);

            // Ensure matrices are available (cheap duplicates; keeps things robust)
            _vat_bm0 = sampleVATMatrix(_vat_currentRow, aBoneIndex.x);
            _vat_bm1 = sampleVATMatrix(_vat_currentRow, aBoneIndex.y);
            _vat_bm2 = sampleVATMatrix(_vat_currentRow, aBoneIndex.z);
            _vat_bm3 = sampleVATMatrix(_vat_currentRow, aBoneIndex.w);

            // Skin the position
            vec4 _pos = vec4(position, 1.0);
            vec4 _skinnedPos =
                    (_vat_bm0 * _pos) * w2.x +
                    (_vat_bm1 * _pos) * w2.y +
                    (_vat_bm2 * _pos) * w2.z +
                    (_vat_bm3 * _pos) * w2.w;

            vec3 transformed = _skinnedPos.xyz;
            `
            );
        };
        material.needsUpdate = true;
        return material;
    }

    _buildClipIndexMap(clips) {
        const map = {};
        clips.forEach((clip, index) => {
            map[clip.name] = index;
        });
        return map;
    }

    // Legacy compatibility for non-unit objects (buildings, environment objects, etc.)
    getModel(objectType, spawnType) {
        const key = `${objectType}_${spawnType}`;

        // For units, redirect to VAT system
        if (objectType === 'units') {
            console.warn(`[ModelManager] Unit '${spawnType}' should use VAT batching, not getModel()`);
            // Return master model clone for emergency compatibility
            const master = this.masterModels.get(key);
            return master ? master.clone() : null;
        }

        // For environment objects, buildings, etc. - return master model clone
        const masterModel = this.masterModels.get(key);
        if (masterModel) {
            const clone = masterModel.clone();
            // Apply basic material setup
            clone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return clone;
        }

        console.warn(`[ModelManager] No model found for ${objectType}_${spawnType}`);
        return null;
    }

    // Legacy compatibility for animations
    async getAnimation(objectType, spawnType, animName, variantIndex = 0) {
        const key = variantIndex === 0
            ? `${objectType}_${spawnType}_${animName}`
            : `${objectType}_${spawnType}_${animName}_${variantIndex}`;

        const animModel = this.animationModels.get(key);
        if (animModel) {
            const clone = animModel.clone();
            clone.traverse(child => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            return clone;
        }

        console.warn(`[ModelManager] No animation model found for ${key}`);
        return null;
    }

    // Public API
    hasVATBundle(objectType, spawnType) {
        return this.vatBundles.has(`${objectType}_${spawnType}`);
    }

    getVATBundle(objectType, spawnType) {
        return this.vatBundles.get(`${objectType}_${spawnType}`);
    }
    async _bakeBoneAttachmentTexture(masterModel, bones, bindMatrices, mixer, clipMeta, fps) {
        const attachmentBoneNames = [
            'RightHand', 'LeftHand', 'Head', 'Spine2', 'Spine'
        ];
        const bonePrefix = 'mixamorig';
        
        const attachmentBones = [];
        for (const boneName of attachmentBoneNames) {
            let foundIndex = -1;
            for (let i = 0; i < bones.length; i++) {
                const bone = bones[i];
                const cleanName = bone.name.replace(bonePrefix, '');
                if (bone.name === boneName || cleanName === boneName || bone.name.includes(boneName)) {
                    foundIndex = i;
                    break;
                }
            }
            attachmentBones.push({ name: boneName, index: foundIndex });
        }

        const validBones = attachmentBones.filter(b => b.index >= 0);
        const cols = validBones.length * 4;
        const totalFrames = clipMeta.reduce((sum, info) => sum + info.frames, 0);
        const rows = totalFrames;

        const textureData = new Float32Array(rows * cols * 4);
        const tempMatrix = new THREE.Matrix4();
        const worldMatrix = new THREE.Matrix4();

        let currentRow = 0;

        for (const clipInfo of clipMeta) {
            const action = mixer.clipAction(clipInfo.clip);
            action.play();

            for (let frame = 0; frame < clipInfo.frames; frame++) {
                const t = clipInfo.frames > 1 ? (frame / (clipInfo.frames - 1)) * clipInfo.duration : 0;
                mixer.setTime(t);
                masterModel.updateMatrixWorld(true);

                for (let i = 0; i < validBones.length; i++) {
                    const boneIndex = validBones[i].index;
                    const bone = bones[boneIndex];
                    
                    worldMatrix.copy(bone.matrixWorld);
                    tempMatrix.copy(worldMatrix).multiply(bindMatrices[boneIndex]);

                    const elements = tempMatrix.elements;
                    const textureRowIndex = currentRow + frame;
                    const boneColumnStart = i * 4;

                    for (let col = 0; col < 4; col++) {
                        const pixelIndex = (textureRowIndex * cols + boneColumnStart + col) * 4;
                        textureData[pixelIndex + 0] = elements[col * 4 + 0];
                        textureData[pixelIndex + 1] = elements[col * 4 + 1];
                        textureData[pixelIndex + 2] = elements[col * 4 + 2];
                        textureData[pixelIndex + 3] = elements[col * 4 + 3];
                    }
                }
            }

            action.stop();
            currentRow += clipInfo.frames;
        }

        const texture = new THREE.DataTexture(
            textureData,
            cols,
            rows,
            THREE.RGBAFormat,
            THREE.FloatType
        );
        texture.needsUpdate = true;
        texture.flipY = false;
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        console.log(`[ModelManager] Baked attachment texture: ${cols}x${rows} for ${validBones.length} bones`);

        return {
            texture,
            bones: attachmentBones,
            validBones
        };
    }
};
window.engine.ModelManager = window.COMPILED_GAME.libraryClasses.ModelManager;

// Library: ECSGame
window.COMPILED_GAME.libraryClasses.ECSGame = class ECSGame extends window.engine.BaseECSGame {
    constructor(app){
        super(app);   
        this.imageManager = new GUTS.ImageManager(this, 
            { 
                imageSize: this.getCollections().configs.game.imageSize, 
                palette: this.getCollections().configs.game.palette, 
                textures: this.getCollections().textures
            }
        );         
        this.state = new GUTS.GameState(this.getCollections());  
        this.sceneManager = new GUTS.SceneManager(this); 
        this.moduleManager = app.moduleManager;
        this.desyncDebugger = new GUTS.DesyncDebugger(this);
    }

    init() {    
        super.init();   
        this.imageManager.dispose();
    }
};
window.engine.ECSGame = window.COMPILED_GAME.libraryClasses.ECSGame;

// Library: GameModeConfigs
window.COMPILED_GAME.libraryClasses.GameModeConfigs = class GameModeConfigs {
    static getDefaultConfigs() {
        return {
            campaign: {
                name: 'Campaign',
                rounds: 10,
                goldProgression: (round) => 100 + (round * 50),
                enemyScaling: (round) => Math.floor(1 + round * 0.5),
                specialRules: ['story_mode', 'progressive_unlock']
            },
            
            survival: {
                name: 'Survival',
                rounds: Infinity,
                goldProgression: (round) => Math.max(50, 150 - (round * 5)),
                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.2)),
                specialRules: ['limited_gold', 'exponential_enemies']
            },
            
            arena: {
                name: 'Arena',
                rounds: 1,
                goldProgression: () => 200,
                enemyScaling: () => 3,
                specialRules: ['balanced_armies', 'quick_battle']
            },
            
            challenge: {
                name: 'Challenge',
                rounds: 1,
                goldProgression: (challenge) => challenge.startingGold || 100,
                enemyScaling: (challenge) => challenge.enemyCount || 3,
                specialRules: ['preset_enemies', 'special_constraints']
            },
            
            endless: {
                name: 'Endless',
                rounds: Infinity,
                goldProgression: (round) => 100 + (round * 25),
                enemyScaling: (round) => Math.floor(1 + Math.pow(round, 1.5)),
                specialRules: ['infinite_scaling', 'leaderboards']
            },
            
            tournament: {
                name: 'Tournament',
                rounds: 8,
                goldProgression: (round) => 120 + (round * 30),
                enemyScaling: (round) => 2 + Math.floor(round / 2),
                specialRules: ['bracket_progression', 'ai_personalities']
            }
        };
    }

    static applyModeRules(gameInstance, mode, round) {
        const config = this.getDefaultConfigs()[mode];
        if (!config) return;

        // Apply gold progression
        if (gameInstance.state) {
            gameInstance.state.playerGold = config.goldProgression(round);
            console.log('set player gold 1', gameInstance.state.playerGold);
        }

        // Apply special rules
        config.specialRules.forEach(rule => {
            this.applySpecialRule(gameInstance, rule, round);
        });
    }

    static applySpecialRule(gameInstance, rule, round) {
        switch (rule) {
            case 'limited_gold':
                // Reduce gold income over time in survival
                break;
                
            case 'exponential_enemies':
                // Increase enemy difficulty exponentially
                break;
                
            case 'balanced_armies':
                // Ensure fair army compositions
                break;
                
            case 'infinite_scaling':
                // Allow unlimited round progression
                break;
                
            default:
                console.log(`Applying special rule: ${rule}`);
        }
    }
};
window.engine.GameModeConfigs = window.COMPILED_GAME.libraryClasses.GameModeConfigs;

// Library: UIComponents
window.COMPILED_GAME.libraryClasses.UIComponents = class UIComponents {
    static createStatCard(label, value, className = '') {
        const card = document.createElement('div');
        card.className = `enhanced-ui-stat ${className}`;
        card.innerHTML = `
            <div class="stat-label">${label}</div>
            <div class="stat-value">${value}</div>
        `;
        return card;
    }

    static createProgressBar(current, max, label = '') {
        const container = document.createElement('div');
        container.className = 'progress-container';
        
        const percentage = max > 0 ? (current / max) * 100 : 0;
        
        container.innerHTML = `
            <div class="progress-label">${label}</div>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${percentage}%"></div>
            </div>
            <div class="progress-text">${current}/${max}</div>
        `;
        
        return container;
    }

    static createNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.textContent = message;
        
        // Style the notification
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem;
            border-radius: 5px;
            color: white;
            font-family: 'Courier New', monospace;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
            max-width: 300px;
        `;
        
        const colors = {
            info: '#0088ff',
            success: '#00ff00',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        
        notification.style.backgroundColor = colors[type] || colors.info;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            notification.style.animation = 'slideOut 0.3s ease-in';
            setTimeout(() => {
                if (notification.parentNode) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }, duration);
        
        return notification;
    }

    static addProgressBarCSS() {
        const style = document.createElement('style');
        style.textContent = `
            .progress-container {
                margin: 0.5rem 0;
            }
            
            .progress-label {
                font-size: 0.8rem;
                color: #aaa;
                margin-bottom: 0.2rem;
            }
            
            .progress-bar {
                width: 100%;
                height: 1rem;
                background: #333;
                border: 1px solid #555;
                border-radius: 3px;
                overflow: hidden;
            }
            
            .progress-fill {
                height: 100%;
                background: linear-gradient(90deg, #00ff00, #88ff88);
                transition: width 0.3s ease;
            }
            
            .progress-text {
                font-size: 0.7rem;
                color: #ccc;
                margin-top: 0.2rem;
                text-align: center;
            }
            
            @keyframes slideIn {
                from { transform: translateX(100%); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(100%); opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    }
}

// Initialize CSS when the script loads
if (typeof document !== 'undefined') {
    document.addEventListener('DOMContentLoaded', () => {
        window.engine.UIComponents.addProgressBarCSS();
    });
};
window.engine.UIComponents = window.COMPILED_GAME.libraryClasses.UIComponents;

// Library: NotificationSystem
window.COMPILED_GAME.libraryClasses.NotificationSystem = // ================================
// FILE: js/ui/NotificationSystem.js - User Notifications
// ================================

class NotificationSystem {
    static notifications = [];
    static maxNotifications = 5;
    static defaultDuration = 3000;
    static container = null;
    
    static initialize() {
        this.createContainer();
        this.addNotificationCSS();
    }
    
    static createContainer() {
        if (this.container) return;
        
        this.container = document.createElement('div');
        this.container.id = 'notification-container';
        this.container.className = 'notification-container';
        document.body.appendChild(this.container);
    }
    
    static show(message, type = 'info', duration = null, options = {}) {
        this.createContainer();
        
        const notification = this.createNotification(message, type, duration || this.defaultDuration, options);
        this.addNotification(notification);
        
        return notification;
    }
    
    static createNotification(message, type, duration, options) {
        const notification = document.createElement('div');
        const id = 'notification-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        notification.id = id;
        notification.className = `notification notification-${type}`;
        notification.setAttribute('data-type', type);
        
        // Create notification content
        const content = document.createElement('div');
        content.className = 'notification-content';
        
        // Add icon based on type
        const icon = this.getTypeIcon(type);
        const iconElement = document.createElement('span');
        iconElement.className = 'notification-icon';
        iconElement.textContent = icon;
        
        // Add message
        const messageElement = document.createElement('span');
        messageElement.className = 'notification-message';
        messageElement.textContent = message;
        
        // Add close button if closable
        let closeButton = null;
        if (options.closable !== false) {
            closeButton = document.createElement('button');
            closeButton.className = 'notification-close';
            closeButton.innerHTML = '&times;';
            closeButton.type = 'button';
            closeButton.addEventListener('click', () => {
                this.remove(id);
            });
        }
        
        // Add progress bar for timed notifications
        let progressBar = null;
        if (duration > 0) {
            progressBar = document.createElement('div');
            progressBar.className = 'notification-progress';
            progressBar.innerHTML = '<div class="notification-progress-fill"></div>';
        }
        
        // Assemble notification
        content.appendChild(iconElement);
        content.appendChild(messageElement);
        if (closeButton) content.appendChild(closeButton);
        
        notification.appendChild(content);
        if (progressBar) notification.appendChild(progressBar);
        
        // Add click handler for the entire notification if specified
        if (options.onClick) {
            notification.style.cursor = 'pointer';
            notification.addEventListener('click', (e) => {
                if (e.target !== closeButton) {
                    options.onClick();
                    if (options.closeOnClick !== false) {
                        this.remove(id);
                    }
                }
            });
        }
        
        // Store notification data
        notification._notificationData = {
            id,
            type,
            duration,
            createdAt: Date.now(),
            progressBar,
            options
        };
        
        return notification;
    }
    
    static addNotification(notification) {
        // Remove excess notifications
        while (this.notifications.length >= this.maxNotifications) {
            const oldest = this.notifications.shift();
            if (oldest && oldest.parentElement) {
                oldest.parentElement.removeChild(oldest);
            }
        }
        
        // Add to container and tracking array
        this.container.appendChild(notification);
        this.notifications.push(notification);
        
        // Animate in
        setTimeout(() => {
            notification.classList.add('notification-show');
        }, 10);
        
        // Setup auto-removal timer
        const data = notification._notificationData;
        if (data.duration > 0) {
            this.setupAutoRemoval(notification);
        }
        
        // Setup progress bar animation
        if (data.progressBar) {
            this.animateProgressBar(notification);
        }
    }
    
    static setupAutoRemoval(notification) {
        const data = notification._notificationData;
        
        setTimeout(() => {
            this.remove(data.id);
        }, data.duration);
    }
    
    static animateProgressBar(notification) {
        const data = notification._notificationData;
        const progressFill = notification.querySelector('.notification-progress-fill');
        
        if (progressFill) {
            progressFill.style.transition = `width ${data.duration}ms linear`;
            setTimeout(() => {
                progressFill.style.width = '0%';
            }, 10);
        }
    }
    
    static remove(id) {
        const notification = document.getElementById(id);
        if (!notification) return;
        
        // Animate out
        notification.classList.add('notification-hide');
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.parentElement.removeChild(notification);
            }
            
            // Remove from tracking array
            this.notifications = this.notifications.filter(n => n.id !== id);
        }, 300);
    }
    
    static clear(type = null) {
        const notificationsToRemove = type 
            ? this.notifications.filter(n => n._notificationData.type === type)
            : [...this.notifications];
        
        notificationsToRemove.forEach(notification => {
            this.remove(notification._notificationData.id);
        });
    }
    
    static getTypeIcon(type) {
        const icons = {
            info: 'ℹ️',
            success: '✅',
            warning: '⚠️',
            error: '❌',
            achievement: '🏆',
            gold: '💰',
            battle: '⚔️',
            victory: '🎉',
            defeat: '💀'
        };
        
        return icons[type] || icons.info;
    }
    
    // Convenience methods for common notification types
    static success(message, duration = null, options = {}) {
        return this.show(message, 'success', duration, options);
    }
    
    static error(message, duration = 5000, options = {}) {
        return this.show(message, 'error', duration, options);
    }
    
    static warning(message, duration = 4000, options = {}) {
        return this.show(message, 'warning', duration, options);
    }
    
    static info(message, duration = null, options = {}) {
        return this.show(message, 'info', duration, options);
    }
    
    static achievement(message, duration = 5000, options = {}) {
        return this.show(message, 'achievement', duration, options);
    }
    
    static gold(message, duration = 3000, options = {}) {
        return this.show(message, 'gold', duration, options);
    }
    
    static battle(message, duration = 2000, options = {}) {
        return this.show(message, 'battle', duration, options);
    }
    
    static victory(message, duration = 4000, options = {}) {
        return this.show(message, 'victory', duration, options);
    }
    
    static defeat(message, duration = 4000, options = {}) {
        return this.show(message, 'defeat', duration, options);
    }
    
    // Persistent notification (no auto-removal)
    static persistent(message, type = 'info', options = {}) {
        return this.show(message, type, 0, { closable: true, ...options });
    }
    
    static addNotificationCSS() {
        if (document.querySelector('#notification-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
            .notification-container {
                position: fixed;
                top: 20px;
                right: 20px;
                z-index: 1500;
                pointer-events: none;
                max-width: 400px;
            }
            
            .notification {
                background: #1a1a2e;
                border: 2px solid;
                border-radius: 8px;
                margin-bottom: 10px;
                min-height: 60px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                overflow: hidden;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                pointer-events: auto;
                font-family: 'Courier New', monospace;
                position: relative;
            }
            
            .notification-show {
                opacity: 1;
                transform: translateX(0);
            }
            
            .notification-hide {
                opacity: 0;
                transform: translateX(100%);
                margin-bottom: 0;
                min-height: 0;
            }
            
            .notification-content {
                display: flex;
                align-items: center;
                padding: 1rem;
                position: relative;
                z-index: 1;
            }
            
            .notification-icon {
                font-size: 1.2rem;
                margin-right: 0.8rem;
                flex-shrink: 0;
            }
            
            .notification-message {
                flex: 1;
                color: #fff;
                font-size: 0.9rem;
                line-height: 1.4;
            }
            
            .notification-close {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.6);
                font-size: 1.2rem;
                cursor: pointer;
                padding: 0;
                margin-left: 0.5rem;
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                transition: all 0.2s;
                flex-shrink: 0;
            }
            
            .notification-close:hover {
                background: rgba(255, 255, 255, 0.1);
                color: #fff;
            }
            
            .notification-progress {
                position: absolute;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 3px;
                background: rgba(255, 255, 255, 0.1);
            }
            
            .notification-progress-fill {
                width: 100%;
                height: 100%;
                background: currentColor;
                transition: none;
            }
            
            /* Type-specific styles */
            .notification-info {
                border-color: #0088ff;
                background: linear-gradient(135deg, #001133 0%, #002244 100%);
                color: #4dc3ff;
            }
            
            .notification-success {
                border-color: #00ff00;
                background: linear-gradient(135deg, #001100 0%, #003300 100%);
                color: #88ff88;
            }
            
            .notification-warning {
                border-color: #ffaa00;
                background: linear-gradient(135deg, #331100 0%, #442200 100%);
                color: #ffcc66;
            }
            
            .notification-error {
                border-color: #ff4444;
                background: linear-gradient(135deg, #330000 0%, #442222 100%);
                color: #ff8888;
            }
            
            .notification-achievement {
                border-color: #ffd700;
                background: linear-gradient(135deg, #332200 0%, #443300 100%);
                color: #ffee88;
                box-shadow: 0 4px 12px rgba(255, 215, 0, 0.2);
            }
            
            .notification-gold {
                border-color: #ffd700;
                background: linear-gradient(135deg, #2d2200 0%, #443300 100%);
                color: #ffe066;
            }
            
            .notification-battle {
                border-color: #ff6600;
                background: linear-gradient(135deg, #330000 0%, #441100 100%);
                color: #ff9966;
            }
            
            .notification-victory {
                border-color: #00ff88;
                background: linear-gradient(135deg, #001122 0%, #003344 100%);
                color: #66ffaa;
                animation: victoryGlow 2s ease-in-out infinite;
            }
            
            @keyframes victoryGlow {
                0%, 100% { box-shadow: 0 4px 12px rgba(0, 255, 136, 0.2); }
                50% { box-shadow: 0 6px 20px rgba(0, 255, 136, 0.4); }
            }
            
            .notification-defeat {
                border-color: #ff0000;
                background: linear-gradient(135deg, #220000 0%, #330000 100%);
                color: #ff6666;
            }
            
            /* Hover effects for clickable notifications */
            .notification[style*="cursor: pointer"]:hover {
                transform: scale(1.02);
                box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4);
            }
            
            /* Mobile responsiveness */
            @media (max-width: 768px) {
                .notification-container {
                    top: 10px;
                    right: 10px;
                    left: 10px;
                    max-width: none;
                }
                
                .notification {
                    margin-bottom: 8px;
                }
                
                .notification-content {
                    padding: 0.8rem;
                }
                
                .notification-message {
                    font-size: 0.85rem;
                }
            }
            
            /* Animation for notification entrance */
            @keyframes notificationSlide {
                from {
                    opacity: 0;
                    transform: translateX(100%);
                }
                to {
                    opacity: 1;
                    transform: translateX(0);
                }
            }
            
            /* Special effects for achievement notifications */
            .notification-achievement {
                position: relative;
                overflow: visible;
            }
            
            .notification-achievement::before {
                content: '✨';
                position: absolute;
                top: -5px;
                right: -5px;
                font-size: 1.5rem;
                animation: sparkle 1.5s ease-in-out infinite;
            }
            
            @keyframes sparkle {
                0%, 100% { opacity: 0.5; transform: scale(1) rotate(0deg); }
                50% { opacity: 1; transform: scale(1.2) rotate(180deg); }
            }
        `;
        document.head.appendChild(style);
    }
};
window.engine.NotificationSystem = window.COMPILED_GAME.libraryClasses.NotificationSystem;

// Library: GameLoader
window.COMPILED_GAME.libraryClasses.GameLoader = class GameLoader {
    constructor(game) {
        this.game = game;
    }    
    async load(){
        this.collections = this.game.getCollections();        
       // this.collections.configs.game.canvasWidth = window.outerWidth;
       // this.collections.configs.game.canvasHeight = window.outerHeight;
        this.game.palette = this.collections.palettes && this.collections.configs.game.palette ? this.collections.palettes[this.collections.configs.game.palette] : null;
        this.isometric = this.collections.configs.game.isIsometric;
        this.game.state.tileMapData = this.collections.levels[this.game.state.level].tileMap;
        this.game.state.isometric = this.collections.configs.game.isIsometric;
        if (this.game.state.modifierSet && this.collections.modifierSets) {
            this.game.state.stats = this.collections.modifierSets[this.game.state.modifierSet];
            this.game.state.defaultStats = { ...this.game.state.stats };
        }   

        this.setupCanvas(this.collections.configs.game.canvasWidth, this.collections.configs.game.canvasHeight);
        await this.loadAssets();
        this.game.translator = new GUTS.CoordinateTranslator(this.collections.configs.game, this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.isometric);
        
    
        this.game.spatialGrid = new GUTS.SpatialGrid(this.collections.levels[this.game.state.level].tileMap.terrainMap.length, this.collections.configs.game.gridSize);
        const terrainImages = this.game.imageManager.getImages("levels", this.game.state.level);

        // Use ModuleManager's script environment
        this.game.terrainTileMapper = new GUTS.TileMap(this, {}, {CanvasUtility: GUTS.CanvasUtility});

        this.game.terrainTileMapper.init(this.game.terrainCanvasBuffer, this.collections.configs.game.gridSize, terrainImages, this.isometric);

        this.game.sceneManager.load(this.collections.configs.game.initialScene);

        this.game.init();

    }

    setupCanvas(canvasWidth, canvasHeight) {
        
        this.canvas = document.getElementById("gameCanvas");
        if(this.game.getCollections().configs.game.is3D){
            this.finalCtx = this.canvas.getContext("webgl2");
        } else {
            this.finalCtx = this.canvas.getContext("2d");
        }
        this.canvasBuffer = document.createElement("canvas");
        this.ctx = this.canvasBuffer.getContext("2d");
        this.canvasBuffer.setAttribute('width', canvasWidth);
        this.canvasBuffer.setAttribute('height', canvasHeight);
        this.canvas.setAttribute('width', canvasWidth);
        this.canvas.setAttribute('height', canvasHeight);  
        
        this.terrainCanvasBuffer = document.createElement('canvas');
        this.terrainCanvasBuffer.width = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap[0].length;
        this.terrainCanvasBuffer.height = this.collections.configs.game.gridSize * this.collections.levels[this.game.state.level].tileMap.terrainMap.length;

        this.game.canvas = this.canvas;
        this.game.finalCtx = this.finalCtx;
        this.game.canvasBuffer = this.canvasBuffer;
        this.game.ctx = this.ctx;
        this.game.terrainCanvasBuffer = this.terrainCanvasBuffer;
    }
    async loadAssets() {
         // Load all images
        for(let objectType in this.collections) {
            await this.game.imageManager.loadImages(objectType, this.collections[objectType]);
        }  
        this.game.modelManager = new GUTS.ModelManager(this, {}, { ShapeFactory: GUTS.ShapeFactory, palette: this.game.palette, textures: this.game.getCollections().textures});
        
        for(let objectType in this.collections) {
            await this.game.modelManager.loadModels(objectType, this.collections[objectType]);
        }  
 
    }
};
window.engine.GameLoader = window.COMPILED_GAME.libraryClasses.GameLoader;

// Library: GameUtils
window.COMPILED_GAME.libraryClasses.GameUtils = class GameUtils {
    static DEFAULT_UNIT_RADIUS = 25;
    static MIN_MOVEMENT_THRESHOLD = 0.1;
    
    static getUnitRadius(collision) {
        return collision?.radius ? Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius) : this.DEFAULT_UNIT_RADIUS;
    }
    
    static calculateDistance(pos1, pos2, collision1 = null, collision2 = null) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos2.z;
        const centerDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (!collision1 || !collision2) return centerDistance;
        
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        
        return {
            center: centerDistance,
            edge: Math.max(0, centerDistance - radius1 - radius2),
            toTargetEdge: Math.max(0, centerDistance - radius2)
        };
    }
    
    static lerp(a, b, t) {
        return a + (b - a) * t;
    }    
};
window.engine.GameUtils = window.COMPILED_GAME.libraryClasses.GameUtils;

// Library: PlacementPreview
window.COMPILED_GAME.libraryClasses.PlacementPreview = class PlacementPreview {
    constructor(game) {
        this.game = game;
        this.game.placementPreview = this;
        
        this.isActive = false;
        
        this.previewGroup = new THREE.Group();
        this.previewGroup.name = 'PlacementPreview';
        this.previewGroup.visible = false;
        this.game.uiScene.add(this.previewGroup);
        
        this.config = {
            cellOpacity: 0.4,
            borderOpacity: 0.8,
            unitIndicatorRadius: 3,
            unitIndicatorSegments: 8,
            elevationOffset: 20,
            unitElevationOffset: 20,
            cellSizeMultiplier: 0.9,
            maxCells: 50,
            updateThrottle: 16
        };
        
        this.geometryPool = this.createGeometryPool();
        this.materials = this.createMaterials();
        
        this.cellMeshPool = [];
        this.borderMeshPool = [];
        this.unitMeshPool = [];
        this.activeMeshes = [];
        
        this.animationId = null;
        this.lastUpdateTime = 0;
        
        this.initializeObjectPools();
    }
    
    createGeometryPool() {
        const cellSize = this.game.gridSystem.dimensions.cellSize * this.config.cellSizeMultiplier;
        
        return {
            cellPlane: new THREE.PlaneGeometry(cellSize, cellSize),
            unitCircle: new THREE.CircleGeometry(
                this.config.unitIndicatorRadius, 
                this.config.unitIndicatorSegments
            )
        };
    }
    
    createMaterials() {
        return {
            validCell: new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: this.config.cellOpacity,
                side: THREE.DoubleSide
            }),
            invalidCell: new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: this.config.cellOpacity,
                side: THREE.DoubleSide
            }),
            validBorder: new THREE.LineBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: this.config.borderOpacity
            }),
            invalidBorder: new THREE.LineBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: this.config.borderOpacity
            }),
            validUnit: new THREE.MeshBasicMaterial({
                color: 0x00aa00,
                transparent: true,
                opacity: 0.6
            }),
            invalidUnit: new THREE.MeshBasicMaterial({
                color: 0xaa0000,
                transparent: true,
                opacity: 0.6
            })
        };
    }
    
    initializeObjectPools() {
        const maxObjects = this.config.maxCells;
        
        for (let i = 0; i < maxObjects; i++) {
            const cellMesh = new THREE.Mesh(this.geometryPool.cellPlane, this.materials.validCell);
            cellMesh.rotation.x = -Math.PI / 2;
            cellMesh.visible = false;
            this.cellMeshPool.push(cellMesh);
            this.previewGroup.add(cellMesh);
            
            const borderGeometry = new THREE.EdgesGeometry(this.geometryPool.cellPlane);
            const borderMesh = new THREE.LineSegments(borderGeometry, this.materials.validBorder);
            borderMesh.rotation.x = -Math.PI / 2;
            borderMesh.visible = false;
            this.borderMeshPool.push(borderMesh);
            this.previewGroup.add(borderMesh);
            
            const unitMesh = new THREE.Mesh(this.geometryPool.unitCircle, this.materials.validUnit);
            unitMesh.rotation.x = -Math.PI / 2;
            unitMesh.visible = false;
            this.unitMeshPool.push(unitMesh);
            this.previewGroup.add(unitMesh);
        }
    }
    
    showAtWorldPositions(worldPositions, isValid = true) {
        const now = performance.now();
        if (now - this.lastUpdateTime < this.config.updateThrottle) {
            return;
        }
        this.lastUpdateTime = now;
        
        if (!worldPositions || worldPositions.length === 0) {
            this.hide();
            return;
        }
        
        this.isActive = true;
        this.hideAllMeshes();
        
        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;
        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;
        
        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
            if (index >= this.cellMeshPool.length) return;
            
            const cellMesh = this.cellMeshPool[index];
            cellMesh.material = cellMaterial;
            cellMesh.position.set(pos.x, this.config.elevationOffset, pos.z);
            cellMesh.visible = true;
            this.activeMeshes.push(cellMesh);
            
            const borderMesh = this.borderMeshPool[index];
            borderMesh.material = borderMaterial;
            borderMesh.position.set(pos.x, this.config.elevationOffset, pos.z);
            borderMesh.visible = true;
            this.activeMeshes.push(borderMesh);
        });
        
        this.previewGroup.visible = true;
        this.startAnimation();
    }
    
    showAtGridPositions(gridPositions, isValid = true) {
        const worldPositions = gridPositions.map(gridPos => 
            this.game.gridSystem.gridToWorld(gridPos.x, gridPos.z)
        );
        this.showAtWorldPositions(worldPositions, isValid);
    }
    
    showWithUnitMarkers(worldPositions, unitPositions, isValid = true) {
        const now = performance.now();
        if (now - this.lastUpdateTime < this.config.updateThrottle) {
            return;
        }
        this.lastUpdateTime = now;
        
        if (!worldPositions || worldPositions.length === 0) {
            this.hide();
            return;
        }
        
        this.isActive = true;
        this.hideAllMeshes();
        
        const cellMaterial = isValid ? this.materials.validCell : this.materials.invalidCell;
        const borderMaterial = isValid ? this.materials.validBorder : this.materials.invalidBorder;
        const unitMaterial = isValid ? this.materials.validUnit : this.materials.invalidUnit;
        
        worldPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
            if (index >= this.cellMeshPool.length) return;
            
            const cellMesh = this.cellMeshPool[index];
            cellMesh.material = cellMaterial;
            cellMesh.position.set(pos.x, this.config.elevationOffset, pos.z);
            cellMesh.visible = true;
            this.activeMeshes.push(cellMesh);
            
            const borderMesh = this.borderMeshPool[index];
            borderMesh.material = borderMaterial;
            borderMesh.position.set(pos.x, this.config.elevationOffset, pos.z);
            borderMesh.visible = true;
            this.activeMeshes.push(borderMesh);
        });
        
        if (unitPositions && unitPositions.length > 0) {
            unitPositions.slice(0, this.config.maxCells).forEach((pos, index) => {
                if (index >= this.unitMeshPool.length) return;
                
                const unitMesh = this.unitMeshPool[index];
                unitMesh.material = unitMaterial;
                unitMesh.position.set(pos.x, this.config.unitElevationOffset, pos.z);
                unitMesh.visible = true;
                this.activeMeshes.push(unitMesh);
            });
        }
        
        this.previewGroup.visible = true;
        this.startAnimation();
    }
    
    hideAllMeshes() {
        this.activeMeshes.length = 0;
        
        [...this.cellMeshPool, ...this.borderMeshPool, ...this.unitMeshPool].forEach(mesh => {
            mesh.visible = false;
        });
    }
    
    startAnimation() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        const startTime = performance.now();
        const animate = () => {
            if (!this.previewGroup.visible) {
                this.animationId = null;
                return;
            }
            
            const elapsed = (performance.now() - startTime) / 1000;
            const scale = 1 + Math.sin(elapsed * 2) * 0.05;
            
            this.activeMeshes.forEach(mesh => {
                if (mesh.visible) {
                    mesh.scale.setScalar(scale);
                }
            });
            
            this.animationId = requestAnimationFrame(animate);
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    hide() {
        this.previewGroup.visible = false;
        this.hideAllMeshes();
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
    }
    
    clear() {
        this.hide();
        this.isActive = false;
    }
    
    updateConfig(newConfig) {
        Object.assign(this.config, newConfig);
        
        if (newConfig.cellOpacity !== undefined) {
            this.materials.validCell.opacity = newConfig.cellOpacity;
            this.materials.invalidCell.opacity = newConfig.cellOpacity;
        }
        
        if (newConfig.borderOpacity !== undefined) {
            this.materials.validBorder.opacity = newConfig.borderOpacity;
            this.materials.invalidBorder.opacity = newConfig.borderOpacity;
        }
    }
    
    dispose() {
        this.clear();
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        
        if (this.previewGroup.parent) {
            this.previewGroup.parent.remove(this.previewGroup);
        }
        
        Object.values(this.geometryPool).forEach(geometry => {
            if (geometry.dispose) {
                geometry.dispose();
            }
        });
        
        Object.values(this.materials).forEach(material => {
            if (material.dispose) {
                material.dispose();
            }
        });
        
        this.cellMeshPool = [];
        this.borderMeshPool = [];
        this.unitMeshPool = [];
        this.activeMeshes = [];
    }
};
window.engine.PlacementPreview = window.COMPILED_GAME.libraryClasses.PlacementPreview;

// Library: EnemyStrategy
window.COMPILED_GAME.libraryClasses.EnemyStrategy = class EnemyStrategy {
    constructor() {
        this.current = null;
        this.history = [];
        this.playerCounters = new Map();
        
        // Strategy definitions with weights and preferences
        this.strategies = {
            balanced: {
                name: 'Balanced',
                weights: { 
                    hp: 0.3, 
                    damage: 0.4, 
                    range: 0.2, 
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: {},
                description: 'Well-rounded army composition',
                maxUnitsMultiplier: 1.0,
                valueThreshold: null
            },
            counter: {
                name: 'Counter Strategy',
                weights: {},
                unitTypePreferences: {},
                description: 'Counters player\'s last strategy',
                maxUnitsMultiplier: 1.2,
                valueThreshold: null
            },
            starter: {
                name: 'Opening Gambit',
                weights: { 
                    hp: 0.2, 
                    damage: 0.3, 
                    range: 0.3, 
                    speed: 0.2,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: {},
                maxUnitsToPlace: 2,
                description: 'Simple opening with 2 random units',
                maxUnitsMultiplier: 0.5,
                valueThreshold: 0.4
            },
            aggressive: {
                name: 'All-Out Attack',
                weights: {
                    hp: 0.1,
                    damage: 0.6,
                    range: 0.2,
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: { archer: 1.5, mage: 1.3 },
                description: 'Focus on high damage output',
                maxUnitsMultiplier: 1.3,
                valueThreshold: null
            },
            defensive: {
                name: 'Fortress Defense',
                weights: {
                    hp: 0.5,
                    damage: 0.2,
                    range: 0.1,
                    speed: 0.0,
                    armor: 0.2,
                    elemental: 0.0,
                    poison: 0.0
                },
                unitTypePreferences: { tank: 2.0 },
                description: 'Focus on survivability and armor',
                maxUnitsMultiplier: 0.8,
                valueThreshold: null
            },
            elemental: {
                name: 'Elemental Mastery',
                weights: {
                    hp: 0.2,
                    damage: 0.3,
                    range: 0.2,
                    speed: 0.1,
                    armor: 0.0,
                    elemental: 0.2,
                    poison: 0.0
                },
                unitTypePreferences: { mage: 2.5 },
                description: 'Focus on elemental damage',
                maxUnitsMultiplier: 1.1,
                valueThreshold: null
            }
        };
        
        // Unit categorization patterns
        this.unitPatterns = {
            tank: {
                idPatterns: ['_s_'],
                statRequirements: { hp: 200, armor: 5 },
                tags: ['heavy', 'shield', 'guard', 'knight']
            },
            archer: {
                idPatterns: ['_d_'],
                statRequirements: { range: 50 },
                tags: ['bow', 'archer', 'ranger', 'marksman']
            },
            mage: {
                idPatterns: ['_i_'],
                statRequirements: {},
                elementalUnits: true,
                tags: ['mage', 'wizard', 'sorcerer', 'elemental']
            },
            fast: {
                idPatterns: [],
                statRequirements: { speed: 55 },
                tags: ['scout', 'cavalry', 'runner']
            },
            ranged: {
                idPatterns: [],
                statRequirements: { range: 50 },
                tags: ['ranged', 'projectile']
            }
        };
        
        // Strategy selection weights based on game state
        this.selectionWeights = {
            round1: { starter: 1.0 },
            earlyGame: { balanced: 0.4, aggressive: 0.3, counter: 0.3 },
            midGame: { counter: 0.5, balanced: 0.2, aggressive: 0.2, defensive: 0.1 },
            lateGame: { counter: 0.6, elemental: 0.2, aggressive: 0.1, defensive: 0.1 }
        };
    }
    
    /**
     * Select the best strategy for the current game state
     * @param {number} round - Current round number
     * @param {Array} playerPlacements - Player's unit placements
     * @param {Object} gameState - Additional game state information
     * @returns {string} Selected strategy key
     */
    selectStrategy(round, playerPlacements, gameState = {}) {
        // Always use starter strategy for round 1
        if (round === 1) {
            return 'starter';
        }
        
        // Try counter strategy if we have player data
        if (round > 1 && playerPlacements.length > 0) {
            const counterStrategy = this.getCounterStrategy(playerPlacements);
            if (counterStrategy) {
                return 'counter';
            }
        }
        
        // Select based on game phase and weighted probabilities
        const gamePhase = this.determineGamePhase(round, gameState);
        const weights = this.selectionWeights[gamePhase] || this.selectionWeights.midGame;
        
        return this.weightedRandomSelection(weights);
    }
    
    /**
     * Determine current game phase based on round and state
     * @param {number} round - Current round number
     * @param {Object} gameState - Game state information
     * @returns {string} Game phase identifier
     */
    determineGamePhase(round, gameState) {
        if (round <= 2) return 'earlyGame';
        if (round <= 5) return 'midGame';
        return 'lateGame';
    }
    
    /**
     * Select strategy using weighted random selection
     * @param {Object} weights - Strategy weights
     * @returns {string} Selected strategy key
     */
    weightedRandomSelection(weights) {
        const totalWeight = Object.values(weights).reduce((sum, weight) => sum + weight, 0);
        let random = Math.random() * totalWeight;
        
        for (const [strategy, weight] of Object.entries(weights)) {
            random -= weight;
            if (random <= 0) {
                return strategy;
            }
        }
        
        return 'balanced'; // Fallback
    }
    
    /**
     * Generate counter strategy based on player army analysis
     * @param {Array} playerPlacements - Player's unit placements
     * @returns {string|null} Counter strategy or null if no clear counter
     */
    getCounterStrategy(playerPlacements) {
        const playerStats = this.analyzePlayerArmy(playerPlacements);
        
        if (playerPlacements.length === 0) {
            return null;
        }
        
        // Store player analysis for learning
        this.playerCounters.set('lastAnalysis', playerStats);
        
        // Tank-heavy counter: Use mages and elemental damage
        if (playerStats.tankHeavy) {
            this.strategies.counter.unitTypePreferences = { mage: 2.5 };
            this.strategies.counter.weights = { 
                elemental: 0.4, 
                damage: 0.4,
                range: 0.2,
                hp: 0.0,
                speed: 0.0,
                armor: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player tanks with elemental mages';
            return 'counter';
        }
        
        // Archer-heavy counter: Use fast tanks and cavalry
        if (playerStats.archerHeavy) {
            this.strategies.counter.unitTypePreferences = { tank: 2.0, fast: 1.5 };
            this.strategies.counter.weights = { 
                hp: 0.4, 
                armor: 0.3,
                speed: 0.3,
                damage: 0.0,
                range: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player archers with armored units';
            return 'counter';
        }
        
        // Mage-heavy counter: Use fast archers and anti-magic
        if (playerStats.mageHeavy) {
            this.strategies.counter.unitTypePreferences = { archer: 2.0, fast: 1.3 };
            this.strategies.counter.weights = { 
                damage: 0.4, 
                range: 0.3,
                speed: 0.3,
                hp: 0.0,
                armor: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering player mages with fast archers';
            return 'counter';
        }
        
        // Elemental-heavy counter: Use physical damage
        if (playerStats.elementalHeavy) {
            this.strategies.counter.unitTypePreferences = { tank: 1.5, archer: 1.5 };
            this.strategies.counter.weights = {
                hp: 0.3,
                damage: 0.4,
                armor: 0.2,
                speed: 0.1,
                range: 0.0,
                elemental: 0.0,
                poison: 0.0
            };
            this.strategies.counter.description = 'Countering elemental units with physical damage';
            return 'counter';
        }
        
        // Balanced army counter: Focus on superior positioning and damage
        this.strategies.counter.unitTypePreferences = { 
            mage: 1.4, 
            archer: 1.3,
            tank: 1.2
        };
        this.strategies.counter.weights = { 
            damage: 0.4,
            hp: 0.2, 
            range: 0.2, 
            speed: 0.1,
            armor: 0.1,
            elemental: 0.0,
            poison: 0.0
        };
        this.strategies.counter.description = 'Countering balanced army with damage focus';
        return 'counter';
    }
    
    /**
     * Analyze player army composition and characteristics
     * @param {Array} playerPlacements - Player's unit placements
     * @returns {Object} Analysis results
     */
    analyzePlayerArmy(playerPlacements) {
        const totalUnits = playerPlacements.reduce((sum, placement) => {
            return sum + (placement.isSquad ? placement.squadUnits.length : 1);
        }, 0);
        
        if (totalUnits === 0) return {};
        
        let tankCount = 0;
        let mageCount = 0;
        let archerCount = 0;
        let fastCount = 0;
        let elementalCount = 0;
        let totalValue = 0;
        let totalHP = 0;
        let totalDamage = 0;
        
        playerPlacements.forEach(placement => {
            const unit = placement.unitType;
            const squadSize = placement.isSquad ? placement.squadUnits.length : 1;
            
            const category = this.categorizeUnit(unit);
            switch (category) {
                case 'tank': tankCount += squadSize; break;
                case 'archer': archerCount += squadSize; break;
                case 'mage': mageCount += squadSize; break;
                case 'fast': fastCount += squadSize; break;
            }
            
            if (this.isElementalUnit(unit)) {
                elementalCount += squadSize;
            }
            
            totalValue += (unit.value || 0) * squadSize;
            totalHP += (unit.hp || 0) * squadSize;
            totalDamage += (unit.damage || 0) * squadSize;
        });
        
        const analysis = {
            totalUnits,
            tankCount,
            mageCount,
            archerCount,
            fastCount,
            elementalCount,
            totalValue,
            averageValue: totalValue / totalUnits,
            averageHP: totalHP / totalUnits,
            averageDamage: totalDamage / totalUnits,
            
            // Composition flags
            tankHeavy: tankCount / totalUnits > 0.5,
            mageHeavy: mageCount / totalUnits > 0.5,
            archerHeavy: archerCount / totalUnits > 0.5,
            fastHeavy: fastCount / totalUnits > 0.4,
            elementalHeavy: elementalCount / totalUnits > 0.6,
            balanced: Math.max(tankCount, mageCount, archerCount) / totalUnits < 0.6,
            
            // Army characteristics
            highValue: totalValue / totalUnits > 100,
            tanky: totalHP / totalUnits > 150,
            glassCannon: totalDamage / totalHP > 0.5
        };
        
        return analysis;
    }
    
    /**
     * Categorize a unit based on its properties
     * @param {Object} unit - Unit definition
     * @returns {string} Unit category
     */
    categorizeUnit(unit) {
        const id = (unit.id || '').toLowerCase();
        const title = (unit.title || '').toLowerCase();
        
        // Check ID patterns first
        for (const [category, pattern] of Object.entries(this.unitPatterns)) {
            if (pattern.idPatterns.some(p => id.includes(p))) {
                return category;
            }
        }
        
        // Check stat requirements
        if (this.unitPatterns.tank.statRequirements.hp <= (unit.hp || 0) &&
            this.unitPatterns.tank.statRequirements.armor <= (unit.armor || 0)) {
            return 'tank';
        }
        
        if (this.unitPatterns.archer.statRequirements.range <= (unit.range || 0)) {
            return 'archer';
        }
        
        if (this.unitPatterns.fast.statRequirements.speed <= (unit.speed || 0)) {
            return 'fast';
        }
        
        // Check for elemental units (mages)
        if (this.isElementalUnit(unit)) {
            return 'mage';
        }
        
        // Check title/name tags
        for (const [category, pattern] of Object.entries(this.unitPatterns)) {
            if (pattern.tags && pattern.tags.some(tag => title.includes(tag))) {
                return category;
            }
        }
        
        // Default categorization based on primary stats
        if (unit.range > 30) return 'ranged';
        if (unit.speed > 50) return 'fast';
        if (unit.hp > 120) return 'tank';
        
        return 'melee';
    }
    
    /**
     * Check if a unit uses elemental damage
     * @param {Object} unit - Unit definition
     * @returns {boolean} True if unit is elemental
     */
    isElementalUnit(unit) {
        const element = (unit.element || 'physical').toLowerCase();
        return element !== 'physical' && element !== '';
    }
    
    /**
     * Calculate unit efficiency score based on strategy weights
     * @param {Object} unit - Unit definition
     * @param {Object} strategyConfig - Strategy configuration
     * @returns {number} Efficiency score
     */
    calculateUnitScore(unit, strategyConfig) {
        let score = this.calculateEfficiency(unit, strategyConfig.weights);
        
        // Apply unit type preferences
        if (strategyConfig.unitTypePreferences) {
            const unitCategory = this.categorizeUnit(unit);
            const multiplier = strategyConfig.unitTypePreferences[unitCategory] || 1.0;
            score *= multiplier;
        }
        
        // Apply strategy-specific bonuses
        score *= this.getStrategyBonus(unit, strategyConfig);
        
        return score;
    }
    
    /**
     * Calculate base unit efficiency using weighted stats
     * @param {Object} unit - Unit definition
     * @param {Object} weights - Stat weights
     * @returns {number} Base efficiency score
     */
    calculateEfficiency(unit, weights) {
        const hp = unit.hp || 100;
        const damage = unit.damage || 10;
        const range = unit.range || 1;
        const speed = unit.speed || 1;
        const armor = unit.armor || 0;
        const element = (unit.element || 'physical');        
        const poison = element === 'poison' ? 1 : 0;
        const physical = element === 'physical' ? 1 : 0;
        const elemental = (physical + poison === 0) ? 1 : 0;

        let combatValue = (hp * (weights.hp || 0)) + 
                         (damage * (weights.damage || 0)) + 
                         (range * (weights.range || 0)) + 
                         (speed * (weights.speed || 0)) + 
                         (armor * (weights.armor || 0)) + 
                         (elemental * (weights.elemental || 0)) + 
                         (poison * (weights.poison || 0));
        
        return combatValue / (unit.value || 1);
    }
    
    /**
     * Apply strategy-specific bonuses to unit score
     * @param {Object} unit - Unit definition
     * @param {Object} strategyConfig - Strategy configuration
     * @returns {number} Bonus multiplier
     */
    getStrategyBonus(unit, strategyConfig) {
        let bonus = 1.0;
        
        // Elemental strategy bonuses
        if (strategyConfig.name === 'Elemental Mastery' && this.isElementalUnit(unit)) {
            bonus *= 1.3;
        }
        
        // Defensive strategy bonuses
        if (strategyConfig.name === 'Fortress Defense' && (unit.hp || 0) > 150) {
            bonus *= 1.2;
        }
        
        // Aggressive strategy bonuses
        if (strategyConfig.name === 'All-Out Attack' && (unit.damage || 0) > 30) {
            bonus *= 1.2;
        }
        
        return bonus;
    }
    
    /**
     * Get current strategy information
     * @returns {Object} Strategy information
     */
    getCurrentStrategyInfo() {
        const strategy = this.strategies[this.current];
        return {
            current: this.current,
            name: strategy?.name || 'Unknown',
            description: strategy?.description || 'No description',
            weights: strategy?.weights || {},
            preferences: strategy?.unitTypePreferences || {},
            history: this.history.slice(-5)
        };
    }
    
    /**
     * Update strategy history
     * @param {number} round - Round number
     * @param {string} strategy - Strategy used
     * @param {Object} results - Battle results (optional)
     */
    updateHistory(round, strategy, results = {}) {
        this.current = strategy;
        this.history.push({
            round,
            strategy,
            timestamp: Date.now(),
            results
        });
        
        // Keep history manageable
        if (this.history.length > 10) {
            this.history.shift();
        }
    }
    
    /**
     * Reset strategy state
     */
    reset() {
        this.current = null;
        this.history = [];
        this.playerCounters.clear();
    }
    
    /**
     * Get strategy effectiveness analysis
     * @returns {Object} Effectiveness data
     */
    getEffectivenessAnalysis() {
        const strategyResults = new Map();
        
        this.history.forEach(entry => {
            if (!strategyResults.has(entry.strategy)) {
                strategyResults.set(entry.strategy, {
                    uses: 0,
                    wins: 0,
                    effectiveness: 0
                });
            }
            
            const data = strategyResults.get(entry.strategy);
            data.uses++;
            
            if (entry.results?.victory) {
                data.wins++;
            }
            
            data.effectiveness = data.wins / data.uses;
        });
        
        return Object.fromEntries(strategyResults);
    }
};
window.engine.EnemyStrategy = window.COMPILED_GAME.libraryClasses.EnemyStrategy;

// Library: MultiplayerECSGame
window.COMPILED_GAME.libraryClasses.MultiplayerECSGame = class MultiplayerECSGame extends engine.ECSGame {
    constructor(app) {
        super(app);
        this.networkManager = new GUTS.ClientNetworkManager(this);
        this.isMultiplayer = true;
        this.isConnected = false;
        this.isServer = false;
    }

    async init() {
        super.init();
        
        // Check if this is a multiplayer game
        const config = this.getCollections().configs.game;
        if (config.isMultiplayer && !this.app.isServer) {
            console.log('Initializing multiplayer client...');
            
            // Connect to server
            try {
                await this.networkManager.connect(config.networkConfig?.serverUrl);
                this.isConnected = true;
                console.log('Connected to multiplayer server');
                
     
                
                // Show multiplayer UI
                this.showMultiplayerUI();
                
            } catch (error) {
                console.error('Failed to connect to server:', error);
                this.handleConnectionError(error);
            }
        }
    }

    showMultiplayerUI() {
        // Show the join room UI
        const joinUI = document.getElementById('joinUI');
        const multiplayerUI = document.getElementById('multiplayerUI');
        
        if (joinUI) {
            joinUI.style.display = 'block';
        }
        if (multiplayerUI) {
            multiplayerUI.style.display = 'none';
        }
    }

    handleConnectionError(error) {
        // Show error message to user
        const errorUI = document.getElementById('connectionError') || this.createErrorUI();
        errorUI.textContent = `Connection failed: ${error.message}`;
        errorUI.style.display = 'block';
    }

    createErrorUI() {
        const errorDiv = document.createElement('div');
        errorDiv.id = 'connectionError';
        errorDiv.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: red;
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 9999;
        `;
        document.body.appendChild(errorDiv);
        return errorDiv;
    }

};
window.engine.MultiplayerECSGame = window.COMPILED_GAME.libraryClasses.MultiplayerECSGame;

// Library: ClientNetworkManager
window.COMPILED_GAME.libraryClasses.ClientNetworkManager = class ClientNetworkManager {
    constructor(game, options = {}) {
        this.game = game;
        this.game.clientNetworkManager = this;
        this.socket = null;
        this.isConnected = false;
        
        // Configuration
        this.serverUrl = options.serverUrl || this.game.getCollections().configs.multiplayer.serverUrl;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = options.maxReconnectAttempts || 5;
        this.reconnectDelay = options.reconnectDelay || 1000;
        this.callTimeout = options.callTimeout || 10000;
        
        // Event system
        this.listeners = new Map(); // eventName -> Set of callbacks
        this.oneTimeCallbacks = new Map(); // eventName -> Map of callbackId -> callback
        this.callbackCounter = 0;
        
    }

    // =============================================
    // CONNECTION MANAGEMENT
    // =============================================

    async connect(serverUrl = null) {
        if (serverUrl) {
            this.serverUrl = serverUrl;
        }

        try {
            // Uncomment when socket.io is available
            // const { io } = await import('/socket.io/socket.io.js');
            this.socket = io(this.serverUrl, {
                transports: ['websocket', 'polling'],
                autoConnect: true, // Disable auto-connection
                reconnection: false // Disable auto-reconnection during development
            });

            this.setupSocketEventHandlers();
            
            return new Promise((resolve, reject) => {
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.isConnected = true;
                    this.reconnectAttempts = 0;
                    this.emit('connect', { connected: true });
                    resolve();
                });

                this.socket.on('connect_error', (error) => {
                    console.log('disconnected:', error);
                    this.emit('connect_error', error);
                    reject(error);
                });
            });
        } catch (error) {
            console.error('Failed to initialize socket connection:', error);
            throw error;
        }
    }

    setupSocketEventHandlers() {
        // Handle disconnect
        this.socket.on('disconnect', (reason) => {
            console.log('Disconnected from server:', reason);
            this.isConnected = false;
            this.emit('disconnect', { reason });
            this.handleDisconnection();
        });

        // Forward all events to our event system
        if (typeof this.socket.onAny === 'function') {
            this.socket.onAny((eventName, data) => {
                this.emit(eventName, data);
            });
        } else {
            // Fallback for older socket.io versions
            const originalOn = this.socket.on.bind(this.socket);
            
            this.socket.on = (eventName, callback) => {
                const wrappedCallback = (data) => {
                    if (callback) callback(data);
                    this.emit(eventName, data);
                };
                
                return originalOn(eventName, wrappedCallback);
            };
        }

        window.addEventListener('beforeunload', () => {
            this.disconnect();
        });
        
        window.addEventListener('unload', () => {
            this.disconnect();
        });
    }

    handleDisconnection() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            console.log(`Attempting to reconnect... (${this.reconnectAttempts + 1}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.reconnectAttempts++;
                this.connect().catch(() => {
                    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                        this.emit('connection_lost', {
                            attempts: this.reconnectAttempts,
                            maxAttempts: this.maxReconnectAttempts
                        });
                    }
                });
            }, this.reconnectDelay * this.reconnectAttempts);
        } else {
            this.emit('connection_lost', {
                attempts: this.reconnectAttempts,
                maxAttempts: this.maxReconnectAttempts
            });
        }
    }

    disconnect() {
        if (this.socket) {
            this.socket.removeAllListeners(); // Remove all listeners first
            this.socket.disconnect(true); // Force disconnect
            this.socket = null;
        }
        this.isConnected = false;
        this.emit('disconnect', { reason: 'Manual disconnect' });
    }

    // =============================================
    // EVENT SYSTEM
    // =============================================

    /**
     * Listen for an event from the server
     * @param {string} eventName - The event name to listen for
     * @param {function} callback - The callback function
     * @returns {function} - Unsubscribe function
     */
    listen(eventName, callback) {
        if (!this.listeners.has(eventName)) {
            this.listeners.set(eventName, new Set());
        }
        
        this.listeners.get(eventName).add(callback);
        
        // Return unsubscribe function
        return () => {
            const callbacks = this.listeners.get(eventName);
            if (callbacks) {
                callbacks.delete(callback);
                if (callbacks.size === 0) {
                    this.listeners.delete(eventName);
                }
            }
        };
    }

    /**
     * Remove a listener for an event
     * @param {string} eventName - The event name
     * @param {function} callback - The callback to remove
     */
    unlisten(eventName, callback) {
        const callbacks = this.listeners.get(eventName);
        if (callbacks) {
            callbacks.delete(callback);
            if (callbacks.size === 0) {
                this.listeners.delete(eventName);
            }
        }
    }

    /**
     * Emit an event to all listeners
     * @param {string} eventName - The event name
     * @param {any} data - The event data
     */
    emit(eventName, data) {
        // Emit to persistent listeners
        const callbacks = this.listeners.get(eventName);
        if (callbacks) {
            callbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in event listener for ${eventName}:`, error);
                }
            });
        }

        // Emit to one-time callbacks
        const oneTimeCallbacks = this.oneTimeCallbacks.get(eventName);
        if (oneTimeCallbacks) {
            oneTimeCallbacks.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    console.error(`Error in one-time callback for ${eventName}:`, error);
                }
            });
            this.oneTimeCallbacks.delete(eventName);
        }
    }

    /**
     * Call a server method - optionally wait for a response
     * @param {string} sendEvent - The event to send to server
     * @param {any} data - Data to send
     * @param {string} responseEvent - The event to wait for (optional)
     * @param {function} callback - Callback when response is received (optional)
     * @param {number} timeout - Timeout in milliseconds (optional)
     * @returns {number|null} - Callback ID that can be used to cancel, or null for fire-and-forget
     */
    call(sendEvent, data = {}, responseEvent = null, callback = null, timeout = null) {
        if (!this.isConnected) {
            const error = new Error('Not connected to server');
            if (callback) {
                setTimeout(() => callback(null, error), 0);
            }
            return null;
        }

        // If no response event expected, just send (fire and forget)
        if (!responseEvent || !callback) {
            this.socket.emit(sendEvent, data);
            if (callback) {
                setTimeout(() => callback(true), 0);
            }
            return null;
        }

        // Generate unique callback ID
        const callbackId = ++this.callbackCounter;

        // Store the one-time callback
        if (!this.oneTimeCallbacks.has(responseEvent)) {
            this.oneTimeCallbacks.set(responseEvent, new Map());
        }
        
        const responseCallbacks = this.oneTimeCallbacks.get(responseEvent);
        responseCallbacks.set(callbackId, callback);

        // Set up timeout
        const timeoutMs = timeout || this.callTimeout;
        let timeoutId = null;
        if (timeoutMs > 0) {
            timeoutId = setTimeout(() => {
                const callbacks = this.oneTimeCallbacks.get(responseEvent);
                if (callbacks && callbacks.has(callbackId)) {
                    callbacks.delete(callbackId);
                    if (callbacks.size === 0) {
                        this.oneTimeCallbacks.delete(responseEvent);
                    }
                    const timeoutError = new Error(`Timeout waiting for ${responseEvent}`);
                    callback(null, timeoutError);
                }
            }, timeoutMs);
        }

        // Wrap callback to clear timeout
        if (timeoutId) {
            const originalCallback = responseCallbacks.get(callbackId);
            responseCallbacks.set(callbackId, (data) => {
                clearTimeout(timeoutId);
                originalCallback(data);
            });
        }

        // Send the event
        this.socket.emit(sendEvent, data);

        return callbackId;
    }

    /**
     * Cancel a pending call
     * @param {string} responseEvent - The response event
     * @param {number} callbackId - The callback ID
     */
    cancelCall(responseEvent, callbackId) {
        const callbacks = this.oneTimeCallbacks.get(responseEvent);
        if (callbacks && callbacks.has(callbackId)) {
            callbacks.delete(callbackId);
            if (callbacks.size === 0) {
                this.oneTimeCallbacks.delete(responseEvent);
            }
        }
    }

    // =============================================
    // UTILITY METHODS
    // =============================================

    /**
     * Get connection state
     */
    getConnectionState() {
        return {
            isConnected: this.isConnected,
            reconnectAttempts: this.reconnectAttempts,
            maxReconnectAttempts: this.maxReconnectAttempts
        };
    }

    /**
     * Set reconnection options
     */
    setReconnectionOptions(options) {
        if (options.maxReconnectAttempts !== undefined) {
            this.maxReconnectAttempts = options.maxReconnectAttempts;
        }
        if (options.reconnectDelay !== undefined) {
            this.reconnectDelay = options.reconnectDelay;
        }
        if (options.callTimeout !== undefined) {
            this.callTimeout = options.callTimeout;
        }
    }

    // =============================================
    // CLEANUP
    // =============================================

    destroy() {
        // Clean up all listeners
        this.listeners.clear();
        this.oneTimeCallbacks.clear();
        
        // Disconnect socket
        this.disconnect();
    }
};
window.engine.ClientNetworkManager = window.COMPILED_GAME.libraryClasses.ClientNetworkManager;

// Library: BaseSystem
window.COMPILED_GAME.libraryClasses.BaseSystem = class BaseSystem {
    constructor(game) {
        this.game = game;
        this.engine = game.app;
        this.componentTypes = this.game.componentManager.getComponentTypes();
    }
    postAllInit() {

    }
    
    update(){

    }

    render() {

    }

}

if(typeof BaseSystem != 'undefined'){
    if (typeof window !== 'undefined') {
        window.BaseSystem = BaseSystem;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = BaseSystem;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = BaseSystem;
        exports.BaseSystem = BaseSystem;
    }
};
window.engine.BaseSystem = window.COMPILED_GAME.libraryClasses.BaseSystem;

// Library: SeededRandom
window.COMPILED_GAME.libraryClasses.SeededRandom = class SeededRandom {
    constructor(seed) {
        this.seed = seed;
        this.current = seed;
    }
    
    next() {
        this.current = (this.current * 1664525 + 1013904223) % Math.pow(2, 32);
        return this.current / Math.pow(2, 32);
    }
    
    range(min, max) {
        return min + this.next() * (max - min);
    }
    
    int(min, max) {
        return Math.floor(this.range(min, max + 1));
    }
}

if(typeof SeededRandom != 'undefined'){
    if (typeof window !== 'undefined') {
        window.SeededRandom = SeededRandom;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = SeededRandom;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = SeededRandom;
        exports.SeededRandom = SeededRandom;
    }
};
window.engine.SeededRandom = window.COMPILED_GAME.libraryClasses.SeededRandom;

// Library: DesyncDebugger
window.COMPILED_GAME.libraryClasses.DesyncDebugger = class DesyncDebugger {
    constructor(game) {
        this.game = game;
        this.game.desyncDebugger = this;
        this.frameHashes = [];
        this.lastDisplayTime = 0;
        this.logInterval = 0; // Log every 1 sec
        this.detailedLogging = true;
        this.enabled = false;
    }
    displaySync(detailed) {    
        if(this.enabled){
            const entities = this.game.getEntitiesWith(
                this.game.componentManager.getComponentTypes().POSITION,
                this.game.componentManager.getComponentTypes().COMBAT
            );
            // Create deterministic state snapshot
            const stateData = this.createStateSnapshot(entities);
            const hash = this.hash(stateData);
            
            this.frameHashes.push({
                hash: hash,
                entityCount: entities.length,
                stateData: stateData,
                time: this.game.state.now
            });   
            if(this.game.isServer){
                console.log(this.game.state.now, hash);                    
            } else {
                console.log(this.game.state.now, hash, stateData);                    
            }
        }
    }

    createStateSnapshot(entities) {
        const CT = this.game.componentManager.getComponentTypes();
        
        const snapshot = {
            gameTime: parseFloat(this.game.state.now.toFixed(6)), // Round to avoid float precision issues
            entities: []
        };

        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const health = this.game.getComponent(entityId, CT.HEALTH);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);

            const entityData = {
                id: String(entityId),
                pos: `${this.hash(pos ? {
                    x: parseFloat(pos.x.toFixed(3)),
                    y: parseFloat(pos.y.toFixed(3)),
                    z: parseFloat(pos.z.toFixed(3))
                } : null)} ${pos.x}, ${pos.y}, ${pos.z}`,
                vel: `${this.hash(vel ? {
                    vx: parseFloat(vel.vx.toFixed(3)),
                    vy: parseFloat(vel.vy.toFixed(3)),
                    vz: parseFloat(vel.vz.toFixed(3))
                } : null)} ${vel?.vx || 0}, ${vel?.vy || 0}, ${vel?.vz || 0}`,
                healthHash: this.hash(health ? {
                    current: health.current,
                    max: health.max
                } : null),
                combatHash: this.hash(combat ? {
                    lastAttack: parseFloat(combat.lastAttack.toFixed(6)),
                    damage: combat.damage,
                    attackSpeed: combat.attackSpeed
                } : null),
                aiStateHash: this.hash(aiState ? {
                    state: aiState.state,
                    controller: aiState.currentAIController,
                    targetPosition: aiState.targetPosition || 'null',
                    target: aiState.target || 'null'
                } : null),
                aiState: JSON.stringify(aiState)
            };

            snapshot.entities.push(entityData);
        });

        return snapshot;
    }

    hash(data) {
        // Simple hash function for state comparison
        const str = JSON.stringify(data);
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash;
    }

    // Compare with another client's hashes
    compareHashes(otherClientHashes) {
        const mismatches = [];
        
        for (let i = 0; i < Math.min(this.frameHashes.length, otherClientHashes.length); i++) {
            const myFrame = this.frameHashes[i];
            const otherFrame = otherClientHashes[i];
            
            if (myFrame.hash !== otherFrame.hash) {
                mismatches.push({
                    frame: myFrame.frame,
                    myHash: myFrame.hash,
                    otherHash: otherFrame.hash,
                    myTime: myFrame.time,
                    otherTime: otherFrame.time,
                    myEntities: myFrame.entityCount,
                    otherEntities: otherFrame.entityCount
                });
            }
        }
        
        return mismatches;
    }

    enableDetailedLogging() {
        this.detailedLogging = true;
        console.log("Detailed desync logging enabled");
    }

    disableDetailedLogging() {
        this.detailedLogging = false;
        console.log("Detailed desync logging disabled");
    }

    // Get the last N frame hashes for comparison
    getRecentHashes(count = 10) {
        return this.frameHashes.slice(-count);
    }

    // Check for common desync patterns
    analyzeDesyncPatterns() {
        if (this.frameHashes.length < 10) return;

        const recent = this.frameHashes.slice(-10);
        const patterns = {
            stableHashes: new Set(recent.map(f => f.hash)).size === 1,
            increasingEntityCount: recent[recent.length - 1].entityCount > recent[0].entityCount,
            decreasingEntityCount: recent[recent.length - 1].entityCount < recent[0].entityCount,
            timeIncreasingMonotonically: recent.every((frame, i) => i === 0 || frame.time > recent[i-1].time)
        };

        console.log("Desync Analysis:", patterns);
        return patterns;
    }
}

if(typeof DesyncDebugger != 'undefined'){

    if (typeof window !== 'undefined') {
        window.DesyncDebugger = DesyncDebugger;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = DesyncDebugger;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = DesyncDebugger;
        exports.DesyncDebugger = DesyncDebugger;
    }
};
window.engine.DesyncDebugger = window.COMPILED_GAME.libraryClasses.DesyncDebugger;

// Library: FantasyUIEnhancements
window.COMPILED_GAME.libraryClasses.FantasyUIEnhancements = class FantasyUIEnhancements {
    constructor(game) {
        this.game = game;
        this.initializeEnhancements();
    }

    initializeEnhancements() {
        this.setupButtonAnimations();
        this.setupModeCardSelection();
        this.setupNotificationSystem();
        this.setupBattleLogAnimations();
        this.addParticleEffects();
    }

    /**
     * Enhanced button interactions with ripple effects
     */
    setupButtonAnimations() {
        document.addEventListener('DOMContentLoaded', () => {
            const buttons = document.querySelectorAll('.btn, .ready-btn, .level-up-button, .undo-button');
            buttons.forEach(button => {
                // Hover effects
                button.addEventListener('mouseenter', () => {
                    if (!button.disabled) {
                        button.style.transform = 'translateY(-2px) scale(1.02)';
                    }
                });
                
                button.addEventListener('mouseleave', () => {
                    if (!button.disabled) {
                        button.style.transform = 'translateY(0) scale(1)';
                    }
                });

                // Ripple effect on click
                button.addEventListener('click', (e) => {
                    this.createRippleEffect(e.target, e);
                });
            });
        });
    }

    /**
     * Creates ripple effect on button click
     */
    createRippleEffect(button, event) {
        const ripple = document.createElement('span');
        ripple.style.cssText = `
            position: absolute;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.6);
            transform: scale(0);
            animation: ripple 0.6s linear;
            pointer-events: none;
            z-index: 1;
        `;
        
        const rect = button.getBoundingClientRect();
        const size = Math.max(rect.width, rect.height);
        ripple.style.width = ripple.style.height = size + 'px';
        ripple.style.left = (event.clientX - rect.left - size / 2) + 'px';
        ripple.style.top = (event.clientY - rect.top - size / 2) + 'px';
        
        button.style.position = 'relative';
        button.style.overflow = 'hidden';
        button.appendChild(ripple);
        
        setTimeout(() => {
            if (ripple.parentNode) {
                ripple.remove();
            }
        }, 600);
    }

    /**
     * Enhanced mode card selection with animations
     */
    setupModeCardSelection() {
        document.addEventListener('click', (e) => {
            const modeCard = e.target.closest('.mode-card');
            if (modeCard) {
                // Remove selected class from all cards
                const allCards = document.querySelectorAll('.mode-card');
                allCards.forEach(card => {
                    card.classList.remove('selected');
                    card.style.animation = 'cardDeselect 0.3s ease-out';
                });
                
                // Add selected class to clicked card
                modeCard.classList.add('selected');
                modeCard.style.animation = 'cardSelect 0.4s ease-out';
                
                // Create selection sound effect (visual feedback)
                this.createSelectionEffect(modeCard);
            }
        });
    }

    /**
     * Creates visual selection effect for mode cards
     */
    createSelectionEffect(card) {
        const effect = document.createElement('div');
        effect.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: selectionPulse 0.8s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        card.style.position = 'relative';
        card.appendChild(effect);
        
        setTimeout(() => {
            if (effect.parentNode) {
                effect.remove();
            }
        }, 800);
    }

    /**
     * Enhanced notification system
     */
    setupNotificationSystem() {
        this.notificationContainer = document.createElement('div');
        this.notificationContainer.id = 'notificationContainer';
        this.notificationContainer.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        `;
        document.body.appendChild(this.notificationContainer);
    }

    /**
     * Show enhanced notification with fantasy styling
     */
    showNotification(message, type = 'info', duration = 5000) {
        const notification = document.createElement('div');
        notification.className = `fantasy-notification ${type}`;
        notification.style.cssText = `
            background: linear-gradient(145deg, rgba(26, 13, 26, 0.95), rgba(13, 10, 26, 0.95));
            border: 2px solid var(--primary-gold);
            border-radius: 8px;
            padding: 1rem 1.5rem;
            color: var(--parchment);
            font-family: var(--font-title);
            min-width: 250px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
            animation: notificationSlideIn 0.3s ease-out;
            backdrop-filter: blur(10px);
        `;

        // Set border color based on type
        switch (type) {
            case 'success':
                notification.style.borderColor = 'var(--forest-green)';
                message = `✅ ${message}`;
                break;
            case 'error':
                notification.style.borderColor = 'var(--blood-red)';
                message = `❌ ${message}`;
                break;
            case 'warning':
                notification.style.borderColor = 'var(--accent-amber)';
                message = `⚠️ ${message}`;
                break;
            default:
                message = `ℹ️ ${message}`;
        }

        notification.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <span>${message}</span>
                <button onclick="this.parentElement.parentElement.remove()" 
                        style="background: none; border: none; color: var(--stone-gray); cursor: pointer; font-size: 1.2rem; margin-left: 1rem;">×</button>
            </div>
        `;

        this.notificationContainer.appendChild(notification);

        // Auto-hide after duration
        setTimeout(() => {
            if (notification.parentNode) {
                notification.style.animation = 'notificationSlideOut 0.3s ease-in';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }, duration);

        return notification;
    }

    /**
     * Enhanced battle log with smooth animations
     */
    setupBattleLogAnimations() {
        this.battleLogQueue = [];
        this.isProcessingLog = false;
    }

    /**
     * Add battle log entry with animation
     */
    addBattleLogEntry(message, type = 'default') {
        this.battleLogQueue.push({ message, type });
        if (!this.isProcessingLog) {
            this.processBattleLogQueue();
        }
    }

    /**
     * Process battle log queue with animations
     */
    processBattleLogQueue() {
        if (this.battleLogQueue.length === 0) {
            this.isProcessingLog = false;
            return;
        }

        this.isProcessingLog = true;
        const { message, type } = this.battleLogQueue.shift();
        
        const battleLog = document.getElementById('battleLog');
        if (!battleLog) {
            this.processBattleLogQueue();
            return;
        }

        const entry = document.createElement('div');
        entry.classList.add('log-entry');
        if (type !== 'default') {
            entry.classList.add(`log-${type}`);
        }
        
        entry.textContent = message;
        entry.style.cssText = `
            opacity: 0;
            transform: translateX(-20px);
            transition: all 0.4s ease;
        `;

        battleLog.appendChild(entry);

        // Animate in
        setTimeout(() => {
            entry.style.opacity = '1';
            entry.style.transform = 'translateX(0)';
        }, 10);

        // Auto-scroll to bottom
        battleLog.scrollTop = battleLog.scrollHeight;

        // Remove old entries if too many
        const entries = battleLog.querySelectorAll('.log-entry');
        if (entries.length > 50) {
            const oldEntry = entries[0];
            oldEntry.style.opacity = '0';
            oldEntry.style.transform = 'translateX(-20px)';
            setTimeout(() => {
                if (oldEntry.parentNode) {
                    oldEntry.remove();
                }
            }, 400);
        }

        // Process next entry after delay
        setTimeout(() => {
            this.processBattleLogQueue();
        }, 200);
    }

    /**
     * Add floating particle effects
     */
    addParticleEffects() {
        // Add particles to main menu
        const mainMenu = document.getElementById('mainMenu');
        if (mainMenu && !mainMenu.querySelector('.particle-container')) {
            this.createParticleSystem(mainMenu);
        }

        // Add subtle particles to game screen
        const gameScreen = document.getElementById('gameScreen');
        if (gameScreen && !gameScreen.querySelector('.particle-container')) {
            this.createParticleSystem(gameScreen, 'subtle');
        }
    }

    /**
     * Create particle system for backgrounds
     */
    createParticleSystem(container, intensity = 'normal') {
        const particleContainer = document.createElement('div');
        particleContainer.className = 'particle-container';
        particleContainer.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        `;

        const particleCount = intensity === 'subtle' ? 15 : 30;
        const particleSize = intensity === 'subtle' ? 2 : 3;
        const particleOpacity = intensity === 'subtle' ? 0.3 : 0.6;

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.style.cssText = `
                position: absolute;
                width: ${particleSize}px;
                height: ${particleSize}px;
                background: radial-gradient(circle, rgba(212, 175, 55, ${particleOpacity}), transparent);
                border-radius: 50%;
                animation: particleFloat ${15 + Math.random() * 20}s linear infinite;
                animation-delay: ${Math.random() * 10}s;
                left: ${Math.random() * 100}%;
                top: ${Math.random() * 100}%;
            `;
            particleContainer.appendChild(particle);
        }

        container.style.position = 'relative';
        container.appendChild(particleContainer);
    }

    /**
     * Enhanced screen transitions
     */
    switchScreen(fromScreenId, toScreenId) {
        const fromScreen = document.getElementById(fromScreenId);
        const toScreen = document.getElementById(toScreenId);

        if (fromScreen) {
            fromScreen.style.animation = 'screenFadeOut 0.4s ease-in forwards';
            setTimeout(() => {
                fromScreen.classList.remove('active');
                fromScreen.style.animation = '';
            }, 400);
        }

        setTimeout(() => {
            if (toScreen) {
                toScreen.classList.add('active');
                toScreen.style.animation = 'screenFadeIn 0.6s ease-out';
                
                // Add particles if it's main menu
                if (toScreenId === 'mainMenu') {
                    this.addParticleEffects();
                }
            }
        }, fromScreen ? 200 : 0);
    }

    /**
     * Create enhanced unit card with animations
     */
    createEnhancedUnitCard(unitData) {
        const card = document.createElement('div');
        card.className = 'unit-card';
        card.dataset.unitId = unitData.id;
        card.style.animation = 'cardSlideIn 0.3s ease-out';

        // Add shimmer effect for rare/special units
        if (unitData.rarity && unitData.rarity !== 'common') {
            card.classList.add('rare-unit');
            this.addShimmerEffect(card, unitData.rarity);
        }

        card.innerHTML = `
            <div class="unit-name">${unitData.name || unitData.title}</div>
            <div class="unit-cost">💰 ${unitData.value || unitData.cost}g</div>
            <div class="unit-stats">⚔️ ${unitData.damage} | 🛡️ ${unitData.hp}</div>
        `;

        // Add tooltip
        if (unitData.description) {
            card.title = unitData.description;
        }

        // Add selection animation
        card.addEventListener('click', () => {
            this.animateUnitSelection(card);
        });

        return card;
    }

    /**
     * Add shimmer effect for rare units
     */
    addShimmerEffect(card, rarity) {
        const shimmer = document.createElement('div');
        shimmer.style.cssText = `
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.4), transparent);
            animation: shimmer 3s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
        `;
        
        card.style.position = 'relative';
        card.style.overflow = 'hidden';
        card.appendChild(shimmer);
    }

    /**
     * Animate unit card selection
     */
    animateUnitSelection(card) {
        // Remove selection from other cards
        document.querySelectorAll('.unit-card.selected').forEach(c => {
            c.classList.remove('selected');
        });

        // Add selection to this card
        card.classList.add('selected');
        
        // Create selection burst effect
        const burst = document.createElement('div');
        burst.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 10px;
            height: 10px;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.8), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: selectionBurst 0.6s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        card.appendChild(burst);
        setTimeout(() => burst.remove(), 600);
    }

    /**
     * Enhanced experience panel creation
     */
    createEnhancedExperiencePanel(squadData) {
        const panel = document.createElement('div');
        panel.className = 'experience-panel';
        panel.style.animation = 'experienceGlow 2s ease-in-out infinite alternate';

        panel.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <span style="color: var(--stone-gray); font-size: 14px; font-weight: bold;">
                    ${squadData.displayName} (Lvl ${squadData.level})
                </span>
                <span style="color: var(--accent-amber); font-size: 12px;">
                    → ${squadData.nextLevelName}
                </span>
            </div>
            <div class="experience-bar">
                <div class="experience-fill" style="width: 100%;"></div>
            </div>
            <div style="display: flex; justify-content: space-between; font-size: 11px; color: var(--stone-gray); margin-bottom: 8px;">
                <span>Ready to level up!</span>
                <span>${squadData.levelUpCost}g cost</span>
            </div>
        `;

        const levelUpButton = document.createElement('button');
        levelUpButton.className = 'level-up-button';
        levelUpButton.textContent = `Level Up (-${squadData.levelUpCost}g)`;
        levelUpButton.addEventListener('click', () => {
            this.animateLevelUp(panel);
        });

        panel.appendChild(levelUpButton);
        return panel;
    }

    /**
     * Animate level up effect
     */
    animateLevelUp(panel) {
        // Create level up burst effect
        const burst = document.createElement('div');
        burst.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: radial-gradient(circle, rgba(255, 215, 0, 0.9), rgba(255, 140, 0, 0.5), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%) scale(0);
            animation: levelUpBurst 1s ease-out;
            pointer-events: none;
            z-index: 10;
        `;
        
        panel.style.position = 'relative';
        panel.appendChild(burst);
        
        setTimeout(() => burst.remove(), 1000);
        
        // Show success notification
        this.showNotification('🌟 Squad leveled up successfully!', 'success');
    }

    /**
     * Copy room ID with enhanced feedback
     */
    copyRoomId() {
        const roomId = document.getElementById('lobbyRoomId').textContent;
        if (navigator.clipboard) {
            navigator.clipboard.writeText(roomId).then(() => {
                this.showNotification(`🏰 Room ID "${roomId}" copied to clipboard!`, 'success');
                
                // Visual feedback on the room ID element
                const roomIdEl = document.getElementById('lobbyRoomId');
                roomIdEl.style.animation = 'copyPulse 0.6s ease-out';
                setTimeout(() => {
                    roomIdEl.style.animation = '';
                }, 600);
            });
        } else {
            this.showNotification('📋 Copy feature not available in this browser', 'warning');
        }
    }
}

if(typeof FantasyUIEnhancements != 'undefined'){
        
    // Export for use in your game systems
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = FantasyUIEnhancements;
    } else if (typeof window !== 'undefined') {
        window.FantasyUIEnhancements = FantasyUIEnhancements;
    }
};
window.engine.FantasyUIEnhancements = window.COMPILED_GAME.libraryClasses.FantasyUIEnhancements;

// Library: MinHeap
window.COMPILED_GAME.libraryClasses.MinHeap = class MinHeap {
    constructor() {
        this.heap = [];
    }
    
    push(item) {
        this.heap.push(item);
        this.bubbleUp(this.heap.length - 1);
    }
    
    pop() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown(0);
        return min;
    }
    
    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].f >= this.heap[parentIndex].f) break;
            
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }
    
    bubbleDown(index) {
        while (true) {
            const leftChild = 2 * index + 1;
            const rightChild = 2 * index + 2;
            let smallest = index;
            
            if (leftChild < this.heap.length && this.heap[leftChild].f < this.heap[smallest].f) {
                smallest = leftChild;
            }
            
            if (rightChild < this.heap.length && this.heap[rightChild].f < this.heap[smallest].f) {
                smallest = rightChild;
            }
            
            if (smallest === index) break;
            
            [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
}

if(typeof MinHeap != 'undefined'){
        
    if (typeof window !== 'undefined') {
        window.MinHeap = MinHeap;
    }

    // Make available as ES module export (new for server)  
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = MinHeap;
    }

    // Make available as ES6 export (also new for server)
    if (typeof exports !== 'undefined') {
        exports.default = MinHeap;
        exports.MinHeap = MinHeap;
    }
};
window.engine.MinHeap = window.COMPILED_GAME.libraryClasses.MinHeap;

// Library: PerformanceProfiler
window.COMPILED_GAME.libraryClasses.PerformanceProfiler = class PerformanceProfiler {
    constructor(game, sampleSize = 60) {
        this.game = game;
        this.game.profiler = this;
        this.sampleSize = sampleSize;
        this.timings = new Map();
        this.frameTimes = [];
        this.enabled = true;
        this.startTime = performance.now();
    }

    startMeasure(label) {
        if (!this.enabled) return;
        if (!this.timings.has(label)) {
            this.timings.set(label, {
                samples: [],
                totalTime: 0,
                calls: 0,
                avgTime: 0,
                maxTime: 0,
                minTime: Infinity
            });
        }
        return performance.now();
    }

    endMeasure(label, startTime) {
        if (!this.enabled) return;
        const duration = performance.now() - startTime;
        const stats = this.timings.get(label);
        
        if (stats) {
            stats.samples.push(duration);
            if (stats.samples.length > this.sampleSize) {
                stats.samples.shift();
            }
            
            stats.totalTime += duration;
            stats.calls++;
            stats.maxTime = Math.max(stats.maxTime, duration);
            stats.minTime = Math.min(stats.minTime, duration);
            stats.avgTime = stats.samples.reduce((a, b) => a + b, 0) / stats.samples.length;
        }
    }

    measure(label, fn) {
        const start = this.startMeasure(label);
        try {
            return fn();
        } finally {
            this.endMeasure(label, start);
        }
    }

    async measureAsync(label, fn) {
        const start = this.startMeasure(label);
        try {
            return await fn();
        } finally {
            this.endMeasure(label, start);
        }
    }

    getReport(sortBy = 'avgTime') {
        const report = [];
        for (const [label, stats] of this.timings) {
            report.push({
                label,
                avgTime: stats.avgTime,
                maxTime: stats.maxTime,
                minTime: stats.minTime,
                totalTime: stats.totalTime,
                calls: stats.calls,
                percentOfFrame: 0
            });
        }

        const totalTime = report.reduce((sum, stat) => sum + stat.avgTime, 0);
        report.forEach(stat => {
            stat.percentOfFrame = totalTime > 0 ? (stat.avgTime / totalTime * 100) : 0;
        });

        report.sort((a, b) => b[sortBy] - a[sortBy]);
        return report;
    }

    printReport() {
        const report = this.getReport();
        console.log('\n=== Performance Report ===');
        console.log('Label'.padEnd(30), 'Avg(ms)', 'Max(ms)', 'Min(ms)', '% Frame', 'Calls');
        console.log('-'.repeat(80));
        
        report.forEach(stat => {
            console.log(
                stat.label.padEnd(30),
                stat.avgTime.toFixed(3).padStart(7),
                stat.maxTime.toFixed(3).padStart(7),
                stat.minTime.toFixed(3).padStart(7),
                stat.percentOfFrame.toFixed(1).padStart(6) + '%',
                stat.calls.toString().padStart(6)
            );
        });
        
        const totalAvg = report.reduce((sum, stat) => sum + stat.avgTime, 0);
        console.log('-'.repeat(80));
        console.log('Total'.padEnd(30), totalAvg.toFixed(3).padStart(7));
        console.log('\n');
    }

    reset() {
        this.timings.clear();
        this.frameTimes = [];
    }

    toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
    }

    
    setupCommands() {
        window.debug = {
            profileSystem: (systemName) => {
                const system = this.game.systems.find(s => 
                    s.constructor.name.toLowerCase().includes(systemName.toLowerCase())
                );
                if (system) {
                    console.log(`Profiling ${system.constructor.name}...`);
                    this.game.profiler.reset();
                    setTimeout(() => {
                        this.game.profiler.printReport();
                    }, 3000);
                } else {
                    console.log(`System "${systemName}" not found`);
                }
            },
            
            listSystems: () => {
                console.log('Active Systems:');
                this.game.systems.forEach((system, i) => {
                    console.log(`${i + 1}. ${system.constructor.name}`);
                });
            },
            
            compareRuns: (duration = 5000) => {
                console.log('Starting comparison run...');
                this.game.profiler.reset();
                
                setTimeout(() => {
                    const baseline = this.game.getPerformanceReport();
                    console.log('Baseline recorded. Make changes and wait...');
                    
                    setTimeout(() => {
                        const current = this.game.getPerformanceReport();
                        console.log('\n=== Performance Comparison ===');
                        console.log('System'.padEnd(30), 'Before', 'After', 'Diff');
                        console.log('-'.repeat(70));
                        
                        baseline.forEach(before => {
                            const after = current.find(s => s.label === before.label);
                            if (after) {
                                const diff = after.avgTime - before.avgTime;
                                const diffStr = (diff > 0 ? '+' : '') + diff.toFixed(3);
                                const color = diff > 0 ? '\x1b[31m' : '\x1b[32m';
                                console.log(
                                    before.label.padEnd(30),
                                    before.avgTime.toFixed(3).padStart(7),
                                    after.avgTime.toFixed(3).padStart(7),
                                    `${color}${diffStr}\x1b[0m`.padStart(10)
                                );
                            }
                        });
                    }, duration);
                }, duration);
            }
        };
        
        console.log('Debug commands loaded. Available: debug.profileSystem(), debug.listSystems(), debug.compareRuns()');
    }
}
if(typeof PerformanceProfiler != 'undefined'){
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = PerformanceProfiler;
    }
};
window.engine.PerformanceProfiler = window.COMPILED_GAME.libraryClasses.PerformanceProfiler;

// Library: threejs (external module)
// Loaded from: /node_modules/three/build/three.module.js
window["THREE"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.THREE = null; // Placeholder

// Library: three_SkeletonUtils (external module)
// Loaded from: /global/libraries/js/three_SkeletonUtils.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["SkeletonUtils"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.SkeletonUtils = null; // Placeholder

// Library: three_OrbitControls (external module)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["OrbitControls"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.OrbitControls = null; // Placeholder

// Library: GLTFLoader (external module)
// Loaded from: /global/libraries/js/GLTFLoader.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["GLTFLoader"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.GLTFLoader = null; // Placeholder

// Library: three_EffectComposer (external module)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["EffectComposer"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.EffectComposer = null; // Placeholder

// Library: three_RenderPixelatedPass (external module)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["RenderPixelatedPass"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.RenderPixelatedPass = null; // Placeholder

// Library: three_OutputPass (external module)
// Loaded from: https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js
if (!window["THREE_"]) {
    window["THREE_"] = {};
}
window["THREE_"]["OutputPass"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.OutputPass = null; // Placeholder

// Library: socket.io.min.js (external module)
// Loaded from: https://cdn.socket.io/4.7.2/socket.io.min.js
window["socket.io.min.js"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.socket_io_min_js = null; // Placeholder

// Library: Rapier (external module)
// Loaded from: https://cdn.skypack.dev/@dimforge/rapier3d-compat
window["RAPIER"] = null; // Will be loaded at runtime
window.COMPILED_GAME.libraryClasses.RAPIER = null; // Placeholder

// ========== IMPORT MAP ==========
window.COMPILED_GAME.importMap = {
  "three": "/node_modules/three/build/three.module.js",
  "RAPIER": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
  "SkeletonUtils": "/global/libraries/js/three_SkeletonUtils.js",
  "OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
  "GLTFLoader": "/global/libraries/js/GLTFLoader.js",
  "EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
  "RenderPixelatedPass": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
  "OutputPass": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js"
};
// Create and inject import map
(function() {
    if (!document.querySelector('script[type="importmap"]')) {
        const importMapScript = document.createElement('script');
        importMapScript.setAttribute('type', 'importmap');
        importMapScript.textContent = JSON.stringify({ 
            imports: window.COMPILED_GAME.importMap 
        }, null, 2);
        document.head.prepend(importMapScript);
        console.log('📍 Import map created');
    }
})();

// ========== EXTERNAL LIBRARY LOADER ==========
window.COMPILED_GAME.externalLibraries = [
  {
    "name": "threejs",
    "url": "/node_modules/three/build/three.module.js",
    "isModule": true,
    "requireName": "THREE"
  },
  {
    "name": "three_SkeletonUtils",
    "url": "/global/libraries/js/three_SkeletonUtils.js",
    "isModule": true,
    "requireName": "SkeletonUtils",
    "windowContext": "THREE_"
  },
  {
    "name": "three_OrbitControls",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/controls/OrbitControls.js",
    "isModule": true,
    "requireName": "OrbitControls",
    "windowContext": "THREE_"
  },
  {
    "name": "GLTFLoader",
    "url": "/global/libraries/js/GLTFLoader.js",
    "isModule": true,
    "requireName": "GLTFLoader",
    "windowContext": "THREE_"
  },
  {
    "name": "three_EffectComposer",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/EffectComposer.js",
    "isModule": true,
    "requireName": "EffectComposer",
    "windowContext": "THREE_"
  },
  {
    "name": "three_RenderPixelatedPass",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/RenderPixelatedPass.js",
    "isModule": true,
    "requireName": "RenderPixelatedPass",
    "windowContext": "THREE_"
  },
  {
    "name": "three_OutputPass",
    "url": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/postprocessing/OutputPass.js",
    "isModule": true,
    "requireName": "OutputPass",
    "windowContext": "THREE_"
  },
  {
    "name": "socket.io.min.js",
    "url": "https://cdn.socket.io/4.7.2/socket.io.min.js",
    "isModule": true,
    "requireName": "socket.io.min.js"
  },
  {
    "name": "Rapier",
    "url": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
    "isModule": true,
    "requireName": "RAPIER"
  }
];
// Load external libraries at bundle initialization
(async function() {
    const loadPromises = [];
    
    for (const lib of window.COMPILED_GAME.externalLibraries) {
        if (lib.isModule) {
            // Import as ES module
            const loadPromise = import(lib.url).then((module) => {
                const libName = lib.requireName || lib.name;
                const loadedModule = module[libName] || module.default || module;
                
                const libraryKey = libName.replace(/-/g, "__").replace(/\./g, "_");
                
                if (lib.windowContext) {
                    if (!window[lib.windowContext]) {
                        window[lib.windowContext] = {};
                    }
                    window[lib.windowContext][libName] = loadedModule;
                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;
                } else {
                    window[libName] = loadedModule;
                    window.COMPILED_GAME.libraryClasses[libraryKey] = loadedModule;
                }
                
                console.log(`📦 Loaded external module: ${lib.name}`);
            }).catch(error => {
                console.error(`Failed to load external module ${lib.name}:`, error);
            });
            
            loadPromises.push(loadPromise);
        }
    }
    
    // Wait for all external modules to load
    await Promise.all(loadPromises);
    console.log('✅ All external libraries loaded');
    
    // Dispatch event when libraries are ready
    window.dispatchEvent(new CustomEvent('compiled-libraries-ready'));
})();

// ========== GAME CLASSES ==========

// ========== FUNCTIONS ==========

// Function: calculateDamage
window.COMPILED_GAME.classRegistry.functions = window.COMPILED_GAME.classRegistry.functions || {};
window.COMPILED_GAME.classRegistry.functions['calculateDamage'] = function calculateDamage(attack, target) {
    // Set default values if not provided
    
    attack.speed = attack.speed || 5;     
    attack.piercing = attack.piercing || 0,
    attack.splashRadius = attack.splashRadius || 0;
    attack.critChance = attack.critChance || .05;
    attack.critMultiplier = attack.critMultiplier || 2;
    attack.penetration = {
      "fire": attack.firePenetration || 0,
      "electric": attack.electricPenetration || 0,
      "cold": attack.coldPenetration || 0,
      "physical": attack.physicalPenetration || 0,
      "toxic": attack.toxicPenetration || 0,
    }
    target.resistances = {
      "fire": target.fireResistance || 0,
      "electric": target.electricResistance || 0,
      "cold": target.coldResistance || 0,
      "physical": target.physicalResistance || 0,
      "toxic": target.toxicResistance || 0,
    }
    
    // Initialize result object
    const result = {
      damageBlocked: 0,
      damageAbsorbed: 0,
      damageDealt: 0,
      energyShieldRemaining: target.energyShield || 0,
      wasEvaded: false,
      wasCritical: Math.random() <= attack.critChance,
      hitDetails: {}
    };
    
    // Check for evasion
    if (target.evasion && target.evasion > 0) {
      const evasionRoll = Math.random() * 100;
      if (evasionRoll < target.evasion) {
        result.wasEvaded = true;
        result.hitDetails.evasion = "Attack evaded";
        return result;
      }
    }
    
    // Calculate initial damage
    let damage = attack.baseDamage;
    
    // Apply critical hit
    if (result.wasCritical) {
      damage *= attack.critMultiplier;
      result.hitDetails.critical = `Critical hit (${attack.critMultiplier}x damage)`;
    }
    
    // Apply resistances based on damage type
  
    if(attack.damageType != "physical") {
      const resistance = target.resistances[attack.damageType] || 0;
      const penetration = attack.penetration[attack.damageType] || 0;
      const finalResist = resistance - penetration;
      let resistanceMultiplier = 1 - (finalResist / 100);
      damage *= resistanceMultiplier;
  
      
      if (finalResist !== 0) {
        if (finalResist > 0) {
          result.hitDetails.resistance = `${attack.damageType} resisted (${finalResist}%)`;
        } else {
          result.hitDetails.resistance = `${attack.damageType} vulnerability (${-finalResist}%)`;
        }
      }  
    }
    
    // Apply armor (only affects physical damage)
    if (attack.damageType === "physical" && target.armor > 0) {
      let effectiveArmor = target.armor;
      if (attack.penetration.physical > 0 ) {
        // Piercing ignores 75% of armor
        effectiveArmor = target.armor * (1 - attack.penetration.physical);
      }
      // Armor formula: damage reduction percentage = armor / (armor + 100)
      const armorReduction = effectiveArmor / (effectiveArmor + 100);
      const blockedDamage = damage * armorReduction;
      
      damage -= blockedDamage;
      result.damageBlocked = blockedDamage;
      result.hitDetails.armor = `Armor blocked ${blockedDamage.toFixed(1)} damage`;
    }
    
    // Round damage to 1 decimal place for cleaner numbers
    damage = Math.round(damage * 10) / 10;
    
    // Apply shield absorption
    if (target.energyShield > 0) {
      if (damage <= target.energyShield) {
        // Shield absorbs all damage
        result.damageAbsorbed = damage;
        result.energyShieldRemaining = target.energyShield - damage;
        result.hitDetails.energyShield = `Shield absorbed all damage, ${result.energyShieldRemaining.toFixed(1)} shield remaining`;
        damage = 0;
      } else {
        // Shield is depleted, remaining damage goes through
        result.damageAbsorbed = target.energyShield;
        result.damageDealt = damage - target.energyShield;
        result.energyShieldRemaining = 0;
        result.hitDetails.energyShield = `Shield depleted, ${result.damageDealt.toFixed(1)} damage dealt to health`;
        damage -= target.energyShield;
      }
    } else {
      // No shield, all damage goes to health
      result.damageDealt = damage;
    }
    
    // Make sure we don't return negative damage
    result.damageDealt = Math.max(0, result.damageDealt);
    
    return result;
  }
;

// Function: calculateStats
window.COMPILED_GAME.classRegistry.functions = window.COMPILED_GAME.classRegistry.functions || {};
window.COMPILED_GAME.classRegistry.functions['calculateStats'] = function calculateStats(stats, calcArray) {

    if( calcArray && calcArray.length > 0 ) {
        let additiveStats = {};
        let multiplicitiveStats = {};
        for(let key in stats) {
            additiveStats[key] = [];
            multiplicitiveStats[key] = [];
        }
        for(let effect of calcArray) {
            effect.apply(stats, additiveStats, multiplicitiveStats);
        }
        let addedEffects = {};
        for(let key in additiveStats){
            for(let val of additiveStats[key]){ 
                if(addedEffects[key]){
                    addedEffects[key] += val - 1;
                } else {
                    addedEffects[key] = val - 1;
                }
            }
        }

        for(let key in addedEffects) {
            if( stats[key] ) {
                stats[key] *= ( 1 + addedEffects[key] );
            }
        }

        let multipliedUpgrades = {};        
        for(let key in multiplicitiveStats){
            for(let val of multiplicitiveStats[key]){ 
                if(stats[key]){
                    stats[key] *= val;
                }
            }
        }
    }
};

// ========== SYSTEMS ==========

// System: TerrainSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['TerrainSystem'] = class TerrainSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.terrainSystem = this;
        
        this.initialized = false;
        
        // Core terrain data
        this.level = null;
        this.world = null;
        this.tileMap = null;
        this.heightMapData = null;
        
        // Settings from collections
        this.heightMapSettings = null;
        
        // Terrain dimensions
        this.terrainSize = 0;
        this.extensionSize = 0;
        this.extendedSize = 0;
        this.heightStep = 0;
        
        // Height map canvas for processing (lightweight)
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
    }

    init() {
        if (this.initialized) return;

        // Load world data
        this.loadWorldData();
        
        // Initialize height map processing
        this.initializeHeightMapProcessing();
        
        this.initialized = true;
    }

    loadWorldData() {
        const collections = this.game.getCollections();
        if (!collections) {
            console.error('TerrainSystem: No collections found');
            return;
        }

        const currentLevel = this.game.state?.level || 'level1';
        this.level = collections.levels?.[currentLevel];
        
        if (!this.level) {
            console.error(`TerrainSystem: Level '${currentLevel}' not found`);
            return;
        }

        this.world = collections.worlds?.[this.level.world];
        if (!this.world) {
            console.error(`TerrainSystem: World '${this.level.world}' not found`);
            return;
        }

        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];
        this.heightStep = this.heightMapSettings?.heightStep || 10;
        this.tileMap = this.level.tileMap;

        // Calculate world dimensions
        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;
        this.extensionSize = this.world.extensionSize || 0;
        this.extendedSize = this.terrainSize + 2 * this.extensionSize;
    }

    initializeHeightMapProcessing() {
        if (!this.heightMapSettings?.enabled) {
            console.log('TerrainSystem: Height map disabled, using flat terrain');
            return;
        }

        // Check if we're running in a browser environment
        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
        
        if (isBrowser) {
            // Create a small canvas for height map processing
            this.heightMapCanvas = document.createElement('canvas');
            this.heightMapCanvas.width = this.terrainSize;
            this.heightMapCanvas.height = this.terrainSize;
            this.heightMapCtx = this.heightMapCanvas.getContext('2d');
            this.processHeightMapFromCanvas();
        } else {
            // For server-side, we'll work directly with the terrain data
            console.log('TerrainSystem: Running in server mode, using data-only height processing');
            this.processHeightMapFromData();
        }
    }

    processHeightMapFromData() {
        if (!this.tileMap?.terrainMap) {
            console.warn('TerrainSystem: No terrain map data available');
            return;
        }

        // Initialize height map data array
        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);
        
        // Set extension area to extension terrain height
        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
        const extensionHeight = extensionTerrainType * this.heightStep;

        // Initialize all points with extension height
        for (let z = 0; z < this.extendedSize; z++) {
            for (let x = 0; x < this.extendedSize; x++) {
                this.heightMapData[z * this.extendedSize + x] = extensionHeight;
            }
        }

        // Process the actual terrain area directly from terrain map
        const terrainMap = this.tileMap.terrainMap;
        const gridSize = this.game.getCollections().configs.game.gridSize;
        
        for (let z = 0; z < terrainMap.length; z++) {
            for (let x = 0; x < terrainMap[z].length; x++) {
                const terrainType = terrainMap[z][x];
                const height = terrainType * this.heightStep;
                
                // Map terrain coordinates to extended coordinates
                const extX = x * gridSize + this.extensionSize;
                const extZ = z * gridSize + this.extensionSize;
                
                // Apply height to a region around this tile
                const halfGrid = Math.floor(gridSize / 2);
                for (let dz = -halfGrid; dz <= halfGrid; dz++) {
                    for (let dx = -halfGrid; dx <= halfGrid; dx++) {
                        const finalX = extX + dx;
                        const finalZ = extZ + dz;
                        
                        if (finalX >= 0 && finalX < this.extendedSize && 
                            finalZ >= 0 && finalZ < this.extendedSize) {
                            
                            const heightIndex = finalZ * this.extendedSize + finalX;
                            this.heightMapData[heightIndex] = height;
                        }
                    }
                }
            }
        }

        console.log(`TerrainSystem: Processed height map from data - ${this.extendedSize}x${this.extendedSize}`);
    }

    processHeightMapFromCanvas() {
        // This method would be used if running client-side with canvas support
        // For now, fall back to data processing
        this.processHeightMapFromData();
    }

    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeightAtPosition(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates
        // The ground is centered at origin, so we need to offset by half the extended size
        const heightMapX = Math.floor(worldX + this.extendedSize / 2);
        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);
        
        // Ensure coordinates are within bounds
        if (heightMapX < 0 || heightMapX >= this.extendedSize || 
            heightMapZ < 0 || heightMapZ >= this.extendedSize) {
            // Outside terrain bounds, use extension terrain height
            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
            return extensionTerrainType * this.heightStep;
        }
        
        // Get height from height map
        const heightIndex = heightMapZ * this.extendedSize + heightMapX;
        return this.heightMapData[heightIndex] || 0;
    }

    /**
     * Get terrain height with bilinear interpolation for smoother transitions
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Smoothly interpolated terrain height
     */
    getTerrainHeightAtPositionSmooth(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates (with decimal precision)
        const heightMapX = worldX + this.extendedSize / 2;
        const heightMapZ = worldZ + this.extendedSize / 2;
        
        // Get the four surrounding grid points
        const x0 = Math.floor(heightMapX);
        const x1 = x0 + 1;
        const z0 = Math.floor(heightMapZ);
        const z1 = z0 + 1;
        
        // Get fractional parts for interpolation
        const fx = heightMapX - x0;
        const fz = heightMapZ - z0;
        
        // Helper function to get height at specific grid point
        const getHeightAt = (x, z) => {
            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {
                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
                return extensionTerrainType * this.heightStep;
            }
            const heightIndex = z * this.extendedSize + x;
            return this.heightMapData[heightIndex] || 0;
        };
        
        // Get heights at the four corners
        const h00 = getHeightAt(x0, z0);
        const h10 = getHeightAt(x1, z0);
        const h01 = getHeightAt(x0, z1);
        const h11 = getHeightAt(x1, z1);
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }

    /**
     * Get terrain type at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate  
     * @returns {number|null} Terrain type index, or null if outside bounds
     */
    getTerrainTypeAtPosition(worldX, worldZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const gridSize = this.game.getCollections().configs.game.gridSize;
        const terrainMap = this.tileMap.terrainMap;
        
        // Convert world coordinates to terrain grid coordinates
        const terrainX = Math.floor((worldX + this.terrainSize / 2) / gridSize);
        const terrainZ = Math.floor((worldZ + this.terrainSize / 2) / gridSize);
        
        // Check bounds
        if (terrainX < 0 || terrainX >= terrainMap[0]?.length || 
            terrainZ < 0 || terrainZ >= terrainMap.length) {
            // Outside terrain bounds, return extension terrain type
            return this.tileMap.extensionTerrainType || 0;
        }
        
        return terrainMap[terrainZ][terrainX];
    }

    getTerrainTypeAtGridPosition(gridX, gridZ) {
        if (!this.tileMap?.terrainMap) {
            return null;
        }

        const terrainMap = this.tileMap.terrainMap;
        
        if(terrainMap.length <= gridZ) {
            return null;
        }
        if(terrainMap[gridZ].length <= gridX) {
            return null;
        }
        
        return terrainMap[gridZ][gridX];
    }
    /**
     * Check if a position is within terrain bounds
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within terrain bounds
     */
    isWithinTerrainBounds(worldX, worldZ) {
        const halfTerrain = this.terrainSize / 2;
        return worldX >= -halfTerrain && worldX <= halfTerrain &&
               worldZ >= -halfTerrain && worldZ <= halfTerrain;
    }

    /**
     * Check if a position is within extended terrain bounds (including extension)
     * @param {number} worldX - World X coordinate  
     * @param {number} worldZ - World Z coordinate
     * @returns {boolean} True if within extended terrain bounds
     */
    isWithinExtendedBounds(worldX, worldZ) {
        const halfExtended = this.extendedSize / 2;
        return worldX >= -halfExtended && worldX <= halfExtended &&
               worldZ >= -halfExtended && worldZ <= halfExtended;
    }

    /**
     * Get terrain information at position including height, type, and bounds checking
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {Object} Terrain info object
     */
    getTerrainInfoAtPosition(worldX, worldZ) {
        return {
            height: this.getTerrainHeightAtPosition(worldX, worldZ),
            heightSmooth: this.getTerrainHeightAtPositionSmooth(worldX, worldZ),
            terrainType: this.getTerrainTypeAtPosition(worldX, worldZ),
            withinBounds: this.isWithinTerrainBounds(worldX, worldZ),
            withinExtendedBounds: this.isWithinExtendedBounds(worldX, worldZ)
        };
    }

    /**
     * Enforce terrain boundaries for movement
     * @param {Object} pos - Position object with x, z properties
     * @param {number} unitRadius - Unit radius for boundary checking
     */
    enforceBoundaries(pos, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }

    /**
     * Get safe spawn position within terrain bounds
     * @param {number} preferredX - Preferred X coordinate
     * @param {number} preferredZ - Preferred Z coordinate
     * @param {number} unitRadius - Unit radius for boundary checking
     * @returns {Object} Safe position with x, y, z coordinates
     */
    getSafeSpawnPosition(preferredX, preferredZ, unitRadius = 25) {
        const halfTerrain = this.terrainSize / 2;
        
        // Clamp to safe bounds
        const safeX = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredX));
        const safeZ = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, preferredZ));
        
        // Get terrain height at safe position
        const height = this.getTerrainHeightAtPosition(safeX, safeZ);
        
        return {
            x: safeX,
            y: height,
            z: safeZ
        };
    }

    update() {
        // TerrainSystem is mostly static, minimal update needed
        if (!this.initialized) {
            this.init();
        }
    }

    destroy() {
        // Clean up resources
        this.heightMapData = null;
        this.heightMapCanvas = null;
        this.heightMapCtx = null;
        
        this.initialized = false;
    }
};

// System: WorldSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['WorldSystem'] = class WorldSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.worldSystem = this;
        
        this.initialized = false;
        
        // Core Three.js components
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null;
        
        // Terrain and world objects
        this.ground = null;
        this.groundTexture = null;
        this.groundCanvas = null;
        this.groundCtx = null;
        this.grass = null;
        this.liquidMeshes = [];
        
        // Extension planes
        this.extensionPlanes = [];
        
        // Terrain canvas for tile mapping
        this.terrainCanvas = null;
        this.terrainCtx = null;
        
        // Lighting
        this.ambientLight = null;
        this.directionalLight = null;
        this.hemisphereLight = null;
        
        // Uniforms for shaders
        this.uniforms = {};
        
        // World data
        this.level = null;
        this.world = null;
        this.tileMap = null;
        this.heightMapData = null;
        // Settings from collections
        this.lightingSettings = null;
        this.shadowSettings = null;
        this.fogSettings = null;
        this.heightMapSettings = null;
        this.cameraSettings = null;
        
        // Timing
        this.clock = new THREE.Clock();
        this.timer = 0;
        this.terrainRendered = false;

        // Controls
        this.controls = null;

        // Window resize handler
        this.onWindowResizeHandler = this.onWindowResize.bind(this);
    }

    init() {
        if (this.initialized) return;

        // Initialize Three.js core components
        this.initializeThreeJS();
        
        // Load world data
        this.loadWorldData();
        
        // Initialize terrain canvas
        this.initializeTerrainCanvas();
        
        // Set up world rendering
        this.setupWorld();
        
        this.initialized = true;
    }

    initializeThreeJS() {
        const gameCanvas = document.getElementById('gameCanvas');
        if (!gameCanvas) {
            console.error('WorldRenderSystem: gameCanvas not found!');
            return;
        }

        this.scene = new THREE.Scene();
        this.uiScene = new THREE.Scene();
        const currentLevel = this.game.state?.level || 'level1';
        this.level = this.game.getCollections().levels?.[currentLevel];
        this.world = this.game.getCollections().worlds[this.level.world];
        this.cameraData = this.game.getCollections().cameras[this.world.camera]; 
        const width = window.innerWidth;
        const height = window.innerHeight; 
        console.log('cameraDATA', this.cameraData);
      // Camera setup
        if(this.cameraData.fov){
            this.camera = new THREE.PerspectiveCamera(
                this.cameraData.fov,
                width / height,
                this.cameraData.near,
                this.cameraData.far
            );
        } else if(this.cameraData.zoom){
            this.camera = new THREE.OrthographicCamera(
                width / - 2, 
                width / 2, 
                height / 2, 
                height / - 2, 
                this.cameraData.near,
                this.cameraData.far
            );
            this.camera.zoom = this.cameraData.zoom;
            this.camera.updateProjectionMatrix();
        }

        this.renderer = new THREE.WebGLRenderer({ 
            canvas: gameCanvas,
            antialias: false,
            alpha: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        window.addEventListener('resize', this.onWindowResizeHandler);
        
        this.game.camera = this.camera;
        this.game.scene = this.scene;
        this.game.uiScene = this.uiScene;
        this.game.renderer = this.renderer;
    }

    initializeTerrainCanvas() {
        this.terrainCanvas = document.createElement('canvas');
        this.terrainCanvas.width = 700;
        this.terrainCanvas.height = 500;
        this.terrainCtx = this.terrainCanvas.getContext('2d');
    }

    loadWorldData() {
        const collections = this.game.getCollections();
        if (!collections) {
            console.error('WorldRenderSystem: No collections found');
            return;
        }

        const currentLevel = this.game.state?.level || 'level1';
        this.level = collections.levels?.[currentLevel];
        
        if (!this.level) {
            console.error(`WorldRenderSystem: Level '${currentLevel}' not found`);
            return;
        }

        this.world = collections.worlds?.[this.level.world];
        if (!this.world) {
            console.error(`WorldRenderSystem: World '${this.level.world}' not found`);
            return;
        }

        this.lightingSettings = collections.lightings?.[this.world.lighting];
        this.shadowSettings = collections.shadows?.[this.world.shadow];
        this.fogSettings = collections.fogs?.[this.world.fog];
        this.heightMapSettings = collections.heightMaps?.[this.world.heightMap];
        this.cameraSettings = collections.cameras?.[this.world.camera];
        this.heightStep = this.heightMapSettings.heightStep;
        this.tileMap = this.level.tileMap;

        // Calculate world dimensions
        this.terrainSize = this.tileMap.size * collections.configs.game.gridSize;
        this.extensionSize = this.world.extensionSize || 0;
        this.extendedSize = this.terrainSize + 2 * this.extensionSize;
        this.heightMapResolution = this.extendedSize / (this.heightMapSettings?.resolutionDivisor || 1);
        
        this.renderer.shadowMap.enabled = this.shadowSettings?.enabled;
    }

    setupWorld() {
        if (this.world?.backgroundColor) {
            this.scene.background = new THREE.Color(this.world.backgroundColor);
        }

        this.setupFog();
        this.setupLighting();
        this.setupCamera();
        this.setupGround();
        
        // Add extension planes after ground is set up
        this.createExtensionPlanes();
        
        // Always render terrain during setup to ensure ground appears
        if (this.tileMap?.terrainMap) {
            this.renderTerrain();
        } else {
            console.warn('WorldRenderSystem: No terrain map available during setup');
        }
    }

    setupFog() {
        if (this.fogSettings?.enabled) {
            this.scene.fog = new THREE.FogExp2(
                this.fogSettings.color, 
                this.fogSettings.density
            );
        }
    }

    setupLighting() {
        if (!this.lightingSettings) {
            this.lightingSettings = {
                ambientColor: '#404040',
                ambientIntensity: 0.6,
                directionalColor: '#ffffff',
                directionalIntensity: 1.0,
                skyColor: '#87CEEB',
                groundColor: '#ffffff',
                hemisphereIntensity: 0.4
            };
        }

        this.ambientLight = new THREE.AmbientLight(
            this.lightingSettings.ambientColor,
            this.lightingSettings.ambientIntensity
        );
        this.scene.add(this.ambientLight);

        this.directionalLight = new THREE.DirectionalLight(
            this.lightingSettings.directionalColor,
            this.lightingSettings.directionalIntensity
        );
        if(this.lightingSettings.direction){
            this.lightingSettings.direction = JSON.parse(this.lightingSettings.direction);
            this.directionalLight.position.set(
                -this.lightingSettings.direction.x * this.extendedSize,  
                -this.lightingSettings.direction.y * this.extendedSize, 
                -this.lightingSettings.direction.z * this.extendedSize
            );
        }
        console.log(this.directionalLight.position, this.lightingSettings.direction);
        this.directionalLight.castShadow = this.shadowSettings?.enabled || false;

        if (this.shadowSettings?.enabled) {
            this.directionalLight.shadow.mapSize.width = this.shadowSettings.mapSize;
            this.directionalLight.shadow.mapSize.height = this.shadowSettings.mapSize;
            this.directionalLight.shadow.camera.near = 0.5;
            this.directionalLight.shadow.camera.far = 20000;
            this.directionalLight.shadow.bias = this.shadowSettings.bias;
            this.directionalLight.shadow.normalBias = this.shadowSettings.normalBias;
            this.directionalLight.shadow.radius = this.shadowSettings.radius;

            const d = this.extendedSize * 0.75;
            this.directionalLight.shadow.camera.left = -d;
            this.directionalLight.shadow.camera.right = d;
            this.directionalLight.shadow.camera.top = d;
            this.directionalLight.shadow.camera.bottom = -d;

            this.directionalLight.target.position.set(
                0, 
                0, 
                0
            );
            this.directionalLight.target.updateMatrixWorld();
            this.directionalLight.shadow.camera.updateProjectionMatrix();
        }

        this.scene.add(this.directionalLight);
        this.scene.add(this.directionalLight.target);

        this.hemisphereLight = new THREE.HemisphereLight(
            this.lightingSettings.skyColor,
            this.lightingSettings.groundColor,
            this.lightingSettings.hemisphereIntensity
        );
        this.scene.add(this.hemisphereLight);

    }

    postAllInit(){
        
        this.setupPostProcessing();
    }
        setupPostProcessing() {
            const gameConfig = this.game.getCollections()?.configs?.game;
            if (!gameConfig) return;
            
            const pixelSize = gameConfig.pixelSize || 1;
            this.game.postProcessingSystem.registerPass('render', {
                enabled: true,
                create: () => {
                    return {
                        enabled: true,
                        needsSwap: true,
                        clear: true,
                        renderToScreen: false,
                        
                        render: (renderer, writeBuffer, readBuffer, deltaTime, maskActive) => {
                            renderer.setRenderTarget(writeBuffer);
                            renderer.clear(true, true, true); // Clear color, depth, and stencil
                            renderer.render(this.scene, this.camera);
                        },
                        
                        setSize: (width, height) => {
                            // No-op
                        }
                    };
                }
            });
            // Register pixel pass
            this.game.postProcessingSystem.registerPass('pixel', {
                enabled: pixelSize !== 1,
                create: () => {
                    const pixelPass = new THREE_.RenderPixelatedPass(pixelSize, this.scene, this.camera);
                    pixelPass.enabled = pixelSize !== 1;
                    pixelPass.normalEdgeStrength = 0;
                    return pixelPass;
                }
            });
            
            // Register output pass (always last)
            this.game.postProcessingSystem.registerPass('output', {
                enabled: true,
                create: () => {
                    return new THREE_.OutputPass();
                }
            });
            
            console.log('[WorldSystem] Registered post-processing passes');
        }
    

    setupCamera() {
        if (!this.cameraSettings) {
            this.cameraSettings = {
                position: '{"x":0,"y":200,"z":300}',
                lookAt: '{"x":0,"y":0,"z":0}',
                fov: 60,
                near: 1,
                far: 30000
            };
        }

        const cameraPos = JSON.parse(this.cameraSettings.position);
       // this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);

        const lookAt = JSON.parse(this.cameraSettings.lookAt);
       // this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);

        if (this.cameraSettings.fov && this.camera.isPerspectiveCamera) {
            this.camera.fov = this.cameraSettings.fov;
            this.camera.near = this.cameraSettings.near || 0.1;
            this.camera.far = this.cameraSettings.far || 30000;
            this.camera.updateProjectionMatrix();
        }

       // this.setupOrbitControls(lookAt);

     
    }

    setupOrbitControls(lookAt) {
        if (typeof THREE_.OrbitControls === 'undefined') {
            console.warn('WorldRenderSystem: THREE.OrbitControls not found.');
            return;
        }

        this.controls = new THREE_.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.mouseButtons = {
            LEFT: null,                           // Disable left click
            MIDDLE: THREE.MOUSE.ROTATE,          // Middle mouse for rotation
            RIGHT: THREE.MOUSE.PAN               // Right mouse for panning (optional)
        };
        this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);
        this.controls.maxPolarAngle = Math.PI / 2.05;
        this.controls.minPolarAngle = 0.1;
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.screenSpacePanning = false;
        this.controls.minDistance = 50;
        this.controls.maxDistance = 1000;
        
        this.controls.update();
        
    }

    setupGround() {
        if (!this.tileMap) {
            console.warn('WorldRenderSystem: No tile map found');
            return;
        }

        this.groundCanvas = document.createElement('canvas');
        this.groundCanvas.width = this.extendedSize;
        this.groundCanvas.height = this.extendedSize;
        this.groundCtx = this.groundCanvas.getContext('2d');

        // Fill with extension terrain color
        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
        const terrainTypes = this.tileMap.terrainTypes || [];
        let bgColor = terrainTypes[extensionTerrainType]?.color;
        
        if (bgColor?.paletteColor && this.game.palette) {
            bgColor = this.game.palette[bgColor.paletteColor];
        }
        
        const finalBgColor = bgColor || '#333333';
        
        this.groundCtx.fillStyle = finalBgColor;
        this.groundCtx.fillRect(0, 0, this.extendedSize, this.extendedSize);

        this.groundTexture = new THREE.CanvasTexture(this.groundCanvas);
        this.groundTexture.wrapS = THREE.ClampToEdgeWrapping;
        this.groundTexture.wrapT = THREE.ClampToEdgeWrapping;
        this.groundTexture.minFilter = THREE.NearestFilter;
        this.groundTexture.magFilter = THREE.NearestFilter;

        const segments = this.heightMapResolution || 1;
        const groundGeometry = new THREE.PlaneGeometry(
            this.extendedSize,
            this.extendedSize,
            segments,
            segments
        );

        this.groundVertices = groundGeometry.attributes.position;
        const groundMaterial = new THREE.MeshStandardMaterial({
            map: this.groundTexture,
            side: THREE.DoubleSide,
            metalness: 0.0,
            roughness: 1
        });

        this.ground = new THREE.Mesh(groundGeometry, groundMaterial);
        this.ground.rotation.x = -Math.PI / 2;
        // Center the ground at origin instead of offset
        this.ground.position.set(0, 0, 0);
        this.ground.receiveShadow = true;
        this.ground.castShadow = true;

        this.scene.add(this.ground);

        this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);
    }

    createExtensionPlanes() {
        if (!this.tileMap) return;
        
        
        // Get the extension terrain color
        const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
        const terrainTypes = this.tileMap.terrainTypes || [];
        let bgColor = terrainTypes[extensionTerrainType]?.color;
        
        if (bgColor?.paletteColor && this.game.palette) {
            bgColor = this.game.palette[bgColor.paletteColor];
        }
        
        const extensionColor = bgColor || '#333333';
        
        // Extension settings
        const extensionDistance = 19000; // How far the planes extend
        const detailedGroundSize = this.extendedSize; // Size of your existing detailed ground
        const halfDetailedSize = detailedGroundSize / 2;
               
        const extensionCanvas = document.createElement('canvas');
        extensionCanvas.width = 1;
        extensionCanvas.height = 1;
        const extensionCtx = extensionCanvas.getContext('2d');
        
        extensionCtx.fillStyle = extensionColor;
        extensionCtx.fillRect(0, 0, 1, 1);

        const extensionTexture = new THREE.CanvasTexture(extensionCanvas);
        extensionTexture.wrapS = THREE.ClampToEdgeWrapping;
        extensionTexture.wrapT = THREE.ClampToEdgeWrapping;
        extensionTexture.minFilter = THREE.NearestFilter;
        extensionTexture.magFilter = THREE.NearestFilter;
        // Create simple material for extension planes
        const extensionMaterial = new THREE.MeshStandardMaterial({
            map: extensionTexture,
            side: THREE.DoubleSide,
            metalness: 0.0,
            roughness: 0.8,
            fog: false
        });
        
        // Store extension planes for cleanup
        this.extensionPlanes = [];
    
        const extensionHeight = extensionTerrainType * this.heightStep;

        // 1. North plane (positive Z)
        const northGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);
        const northPlane = new THREE.Mesh(northGeometry, extensionMaterial.clone());
        northPlane.rotation.x = -Math.PI / 2;
        northPlane.position.set(0, extensionHeight, halfDetailedSize + extensionDistance / 2);
        northPlane.receiveShadow = true;
        this.scene.add(northPlane);
        this.extensionPlanes.push(northPlane);
        
        // 2. South plane (negative Z)
        const southGeometry = new THREE.PlaneGeometry(detailedGroundSize + 2 * extensionDistance, extensionDistance);
        const southPlane = new THREE.Mesh(southGeometry, extensionMaterial.clone());
        southPlane.rotation.x = -Math.PI / 2;
        southPlane.position.set(0, extensionHeight, -halfDetailedSize - extensionDistance / 2);
        southPlane.receiveShadow = true;
        this.scene.add(southPlane);
        this.extensionPlanes.push(southPlane);
        
        // 3. East plane (positive X)
        const eastGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);
        const eastPlane = new THREE.Mesh(eastGeometry, extensionMaterial.clone());
        eastPlane.rotation.x = -Math.PI / 2;
        eastPlane.position.set(halfDetailedSize + extensionDistance / 2, extensionHeight, 0);
        eastPlane.receiveShadow = true;
        this.scene.add(eastPlane);
        this.extensionPlanes.push(eastPlane);
        
        // 4. West plane (negative X)  
        const westGeometry = new THREE.PlaneGeometry(extensionDistance, detailedGroundSize);
        const westPlane = new THREE.Mesh(westGeometry, extensionMaterial.clone());
        westPlane.rotation.x = -Math.PI / 2;
        westPlane.position.set(-halfDetailedSize - extensionDistance / 2, extensionHeight, 0);
        westPlane.receiveShadow = true;
        this.scene.add(westPlane);
        this.extensionPlanes.push(westPlane);
        
    }

    renderTerrain() {
        if (!this.tileMap?.terrainMap) {
            console.warn('WorldRenderSystem: No terrain map data found');
            return;
        }

        
        // Clear terrain canvas
        this.terrainCtx.clearRect(0, 0, this.terrainCanvas.width, this.terrainCanvas.height);
        
        // Draw terrain tiles
        this.drawTerrainTiles(this.tileMap.terrainMap);
        
        // Update ground texture with terrain data
        this.updateGroundTexture();
        
        this.terrainRendered = true;
        
    }

    drawTerrainTiles(terrainMap) {       
        this.game.terrainTileMapper.draw(terrainMap);
    }

    updateGroundTexture() {
        if (!this.terrainCanvas) {
            console.warn('WorldRenderSystem: No terrain canvas available for ground texture update');
            return;
        }

        // Draw terrain data onto ground canvas
        this.groundCtx.drawImage(
            this.game.terrainTileMapper.canvas, 
            this.extensionSize, 
            this.extensionSize
        );
        this.groundTexture.needsUpdate = true;
        
        if (this.heightMapSettings?.enabled) {
            this.updateHeightMap();
        }
        
        // Generate liquid surfaces
        if (this.tileMap?.terrainTypes) {
            this.generateLiquidSurfaceMesh(0); // Water
            this.generateLiquidSurfaceMesh(1); // Lava/other liquid
        }

        // Add grass
       // this.addGrassToTerrain();

        // Render environment objects
        this.renderEnvironmentObjects();
    }

    renderEnvironmentObjects() {
        if (!this.scene || !this.tileMap.environmentObjects || this.tileMap.environmentObjects.length === 0) {
            return;
        }

        // Group environment objects by type
        const objectsByType = {};
        this.tileMap.environmentObjects.forEach(obj => {
            if (!objectsByType[obj.type]) {
                objectsByType[obj.type] = [];
            }
            objectsByType[obj.type].push(obj);
        });

        // Process each type separately
        Object.entries(objectsByType).forEach(([type, objects]) => {
            const referenceModel = this.game.modelManager?.getModel("worldObjects", type);
            if (!referenceModel) {
                console.warn(`WorldRenderSystem: Model not found for type: ${type}`);
                return;
            }

            const meshData = [];
            referenceModel.updateMatrixWorld(true);

            referenceModel.traverse(node => {
                if (node.isMesh) {
                    const parent = node.parent;
                    const parentWorldMatrix = parent.matrixWorld.clone();
                    const localMatrix = node.matrix.clone();

                    const relativeMatrix = new THREE.Matrix4();
                    relativeMatrix.copy(parentWorldMatrix);
                    relativeMatrix.multiply(localMatrix);
                    meshData.push({
                        mesh: node,
                        relativeMatrix: relativeMatrix
                    });
                }
            });
            
            if (meshData.length === 0) return;

            const instancedMeshes = meshData.map(({ mesh, relativeMatrix }) => {
                const instancedMesh = new THREE.InstancedMesh(
                    mesh.geometry,
                    mesh.material,
                    objects.length
                );
                instancedMesh.userData.relativeMatrix = relativeMatrix;
                instancedMesh.userData.objectType = type;
                instancedMesh.castShadow = true;   
                instancedMesh.receiveShadow = true;
                if(instancedMesh.material.map){
                    instancedMesh.material.map.wrapS = THREE.MirroredRepeatWrapping;
                    instancedMesh.material.side = THREE.DoubleSide; // Set side to double for better visibility                                
                    instancedMesh.material.alphaTest = 0.1;
                }
                instancedMesh.material.transparent = true;
                instancedMesh.material.needsUpdate = true; // Force material update
           
                return instancedMesh;
            });

            const matrix = new THREE.Matrix4();
            const dummy = new THREE.Object3D();

            objects.forEach((obj, index) => {
                                const worldX = (obj.x + this.extensionSize) - this.extendedSize / 2;
                const worldZ = (obj.y + this.extensionSize) - this.extendedSize / 2;

                let height = 0;
                if (this.heightMapSettings?.enabled) {
                    height = this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);
                }

                // Original positioning but with proper centering
                // The terrain canvas is drawn at position (extensionSize, extensionSize) on the ground canvas
                // So we need to account for that offset

                dummy.position.set(worldX, height, worldZ);
                dummy.rotation.y = Math.random() * Math.PI * 2;
                const scale = (0.8 + Math.random() * 0.4) * ( type == 'rock' ? 1 : 50);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
        
                instancedMeshes.forEach(instancedMesh => {
                    matrix.copy(dummy.matrix);
                    matrix.multiply(instancedMesh.userData.relativeMatrix);
                    instancedMesh.setMatrixAt(index, matrix);
                });
            });

            instancedMeshes.forEach(instancedMesh => {
                instancedMesh.instanceMatrix.needsUpdate = true;
                this.scene.add(instancedMesh);
            });
        });

    }

    onWindowResize() {
        if (!this.camera || !this.renderer) return;
        
        const width = window.innerWidth;
        const height = window.innerHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        
        if (this.composer) {
            this.composer.setSize(width, height);
        }
    }

    update() {
        if (!this.initialized) return;

        this.timer += this.game.state.deltaTime;

        if (this.controls) {
            this.controls.update();
        }

        for (const key in this.uniforms) {
            if (this.uniforms[key].time) {
                this.uniforms[key].time.value = this.timer;
            }
        }

        // Ensure terrain is rendered at least once
        if (!this.terrainRendered && this.tileMap?.terrainMap) {
            this.renderTerrain();
        }

        this.render();
    }

    render() {
        if (!this.scene || !this.camera || !this.renderer) {
            console.warn('WorldRenderSystem: Missing components for rendering');
            return;
        }

        if (this.game.postProcessingSystem?.composer) {
            this.game.postProcessingSystem.render();
        } else {
            this.renderer.render(this.scene, this.camera);
        }
    }

    updateHeightMap() {
        if (!this.heightMapSettings.enabled || !this.game.terrainTileMapper.heightMapCanvas) {
            console.warn('Height map not available from TileMapper');
            return;
        }

        try {
            const heightMapCanvas = this.game.terrainTileMapper.heightMapCanvas;
            const heightMapCtx = heightMapCanvas.getContext('2d', { willReadFrequently: true });
            
            // Get the height map image data directly from TileMapper
            const heightMapImageData = heightMapCtx.getImageData(0, 0, heightMapCanvas.width, heightMapCanvas.height);
            const heightData = heightMapImageData.data;

            this.heightMapData = new Float32Array(this.extendedSize * this.extendedSize);

            // Set extension area to extension terrain height
            const extensionTerrainType = this.tileMap.extensionTerrainType || 0;
            const extensionHeight = extensionTerrainType * this.heightStep;

            // Initialize all points with extension height
            for (let z = 0; z < this.extendedSize; z++) {
                for (let x = 0; x < this.extendedSize; x++) {
                    this.heightMapData[z * this.extendedSize + x] = extensionHeight;
                }
            }

            // Process the actual terrain area using height map data
            const scaleX = heightMapCanvas.width / this.terrainSize;
            const scaleZ = heightMapCanvas.height / this.terrainSize;

            for (let z = 0; z < this.terrainSize; z++) {
                for (let x = 0; x < this.terrainSize; x++) {
                    // Sample from height map
                    const heightMapX = Math.floor(x * scaleX);
                    const heightMapZ = Math.floor(z * scaleZ);
                    
                    const pixelIndex = (heightMapZ * heightMapCanvas.width + heightMapX) * 4;
                    const heightValue = heightData[pixelIndex]; // Red channel (grayscale)
                    
                    // Convert grayscale value back to height index
                    const heightIndex = Math.floor(heightValue / 32); // Inverse of scaling in TileMapper
                    let height = heightIndex * this.heightStep;

                    // Check neighboring pixels for cliff smoothing if needed
                    let neighborCheckDist = this.heightMapSettings.resolutionDivisor || 1;
                    const neighbors = [
                        { x: x - neighborCheckDist, z: z },   // left
                        { x: x + neighborCheckDist, z: z },   // right
                        { x: x, z: z - neighborCheckDist },   // top
                        { x: x, z: z + neighborCheckDist },   // bottom
                        { x: x - neighborCheckDist, z: z - neighborCheckDist }, // top-left
                        { x: x + neighborCheckDist, z: z - neighborCheckDist }, // top-right
                        { x: x - neighborCheckDist, z: z + neighborCheckDist }, // bottom-left
                        { x: x + neighborCheckDist, z: z + neighborCheckDist }  // bottom-right
                    ];

                    let lowestNeighborHeight = height;
                    for (const neighbor of neighbors) {
                        if (neighbor.x >= 0 && neighbor.x < this.terrainSize && 
                            neighbor.z >= 0 && neighbor.z < this.terrainSize) {
                            
                            const neighborHMapX = Math.floor(neighbor.x * scaleX);
                            const neighborHMapZ = Math.floor(neighbor.z * scaleZ);
                            const neighborIndex = (neighborHMapZ * heightMapCanvas.width + neighborHMapX) * 4;
                            const neighborHeightValue = heightData[neighborIndex];
                            const neighborHeightIndex = Math.floor(neighborHeightValue / 32);
                            const neighborHeight = neighborHeightIndex * this.heightStep;
                            
                            if (neighborHeight < lowestNeighborHeight) {
                                lowestNeighborHeight = neighborHeight;
                            }
                        }
                    }
                    
                    // Use the lowest neighbor height for cliff smoothing
                    height = lowestNeighborHeight;
                    // Set height in extended coordinate system
                    const extX = x + this.extensionSize;
                    const extZ = z + this.extensionSize;
                    this.heightMapData[extZ * this.extendedSize + extX] = height;
                }
            }

            this.applyHeightMapToGeometry();

        } catch (e) {
            console.warn('Failed to update height map from TileMapper:', e);
        }
    }
    findClosestTerrainType(r, g, b, terrainTypeColors) {
        let minDistance = Infinity;
        let bestTypeIndex = null;
        const toleranceSquared = 36;

        for (const [colorKey, typeIndex] of Object.entries(terrainTypeColors)) {
            const [cr, cg, cb] = colorKey.split(',').map(Number);
            const distance = ((r - cr) ** 2 + (g - cg) ** 2 + (b - cb) ** 2);
            
            if (distance < minDistance && distance < toleranceSquared) {
                minDistance = distance;
                bestTypeIndex = typeIndex;
            }
        }

        return bestTypeIndex;
    }

    createTerrainTypeColorMap() {
        const colorMap = {};
        const terrainTypes = this.tileMap.terrainTypes || [];

        for (let i = 0; i < terrainTypes.length; i++) {
            const terrainType = terrainTypes[i];
            let color = terrainType.color || {};

            if (color.paletteColor && this.game.palette) {
                const hexColor = this.game.palette[color.paletteColor];
                if (hexColor) {
                    const r = parseInt(hexColor.slice(1, 3), 16);
                    const g = parseInt(hexColor.slice(3, 5), 16);
                    const b = parseInt(hexColor.slice(5, 7), 16);
                    colorMap[`${r},${g},${b}`] = i;
                }
            } else {
                const hexColor = color;
                if (hexColor) {
                    const r = parseInt(hexColor.slice(1, 3), 16);
                    const g = parseInt(hexColor.slice(3, 5), 16);
                    const b = parseInt(hexColor.slice(5, 7), 16);
                    colorMap[`${r},${g},${b}`] = i;
                }
            }
        }

        return colorMap;
    }

    applyHeightMapToGeometry() {
        if (!this.ground || !this.groundVertices) return;

        const positions = this.groundVertices.array;
        const geometry = this.ground.geometry;
        const segments = this.heightMapResolution;
        const verticesPerRow = segments + 1;

        for (let z = 0; z < verticesPerRow; z++) {
            for (let x = 0; x < verticesPerRow; x++) {
                const vertexIndex = (z * verticesPerRow + x);
                const idx = vertexIndex * 3;

                const nx = x / segments;
                const nz = z / segments;

                const terrainX = Math.floor(nx * (this.extendedSize - 1));
                const terrainZ = Math.floor(nz * (this.extendedSize - 1));

                const heightIndex = terrainZ * this.extendedSize + terrainX;
                const height = this.heightMapData[heightIndex] || 0;

                positions[idx + 2] = height;
            }
        }

        this.groundVertices.needsUpdate = true;
        geometry.computeVertexNormals();
    }

    generateLiquidSurfaceMesh(terrainType) {
        const terrainMap = this.tileMap.terrainMap;
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const rows = terrainMap.length;
        const cols = terrainMap[0].length;
        
        // Arrays to store vertices, indices, and UVs for the BufferGeometry
        const vertices = [];
        const indices = [];
        const uvs = [];
        
        // Amount to extend the perimeter (e.g., 10% of gridSize)
        const extensionAmount = gridSize * 0.25; // Adjust as needed        

        // Calculate centering offset to match ground positioning
        const terrainWorldWidth = cols * gridSize;
        const terrainWorldHeight = rows * gridSize;
        const centerOffsetX = -terrainWorldWidth / 2;
        const centerOffsetZ = -terrainWorldHeight / 2;

        // Helper function to check if a tile is a water tile
        const isWaterTile = (x, z) => {
            if (x < 0 || x >= cols || z < 0 || z >= rows) return false;
            return terrainMap[z][x] === terrainType;
        };
        
        // Step 1: Generate a grid of vertices, but only for positions needed by water tiles
        const usedPositions = new Set();
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    usedPositions.add(`${x},${z}`);     // Bottom-left
                    usedPositions.add(`${x + 1},${z}`); // Bottom-right
                    usedPositions.add(`${x + 1},${z + 1}`); // Bottom-right in your view (+z is south)
                    usedPositions.add(`${x},${z + 1}`); // Top-left
                }
            }
        }
        
        // Step 2: Create vertices for all used positions and store their original positions
        const positionToVertexIndex = new Map();
        const originalPositions = []; // Store original (x, z) for each vertex
        let vertexIndex = 0;
        for (const pos of usedPositions) {
            const [x, z] = pos.split(',').map(Number);
            positionToVertexIndex.set(pos, vertexIndex++);
            
            // Apply centering offset to match ground positioning
            const worldX = x * gridSize + centerOffsetX;
            const worldZ = z * gridSize + centerOffsetZ;
            
            vertices.push(worldX, 0.1, worldZ);
            originalPositions.push([x, z]); // Store original grid position
            uvs.push(x, z); // UVs based on grid position
        }
        
        // Step 3: Generate indices for water tiles, connecting them into a single mesh
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    const bl = positionToVertexIndex.get(`${x},${z}`);
                    const br = positionToVertexIndex.get(`${x + 1},${z}`);
                    const tr = positionToVertexIndex.get(`${x + 1},${z + 1}`); // Bottom-right in your view
                    const tl = positionToVertexIndex.get(`${x},${z + 1}`);

                    indices.push(bl, br, tl);
                    indices.push(br, tr, tl);
                }
            }
        }
        
        // Step 4: Identify perimeter vertices and their extension directions
        const perimeterExtensions = new Map(); // Map vertexIndex to { extendLeft, extendRight, extendUp, extendDown }
        for (let z = 0; z < rows; z++) {
            for (let x = 0; x < cols; x++) {
                if (terrainMap[z][x] === terrainType) {
                    const isLeftEdge = !isWaterTile(x - 1, z);
                    const isRightEdge = !isWaterTile(x + 1, z);
                    const isBottomEdge = !isWaterTile(x, z - 1); // North
                    const isTopEdge = !isWaterTile(x, z + 1);    // South

                    // Bottom-left vertex (x, z)
                    if (isLeftEdge || isBottomEdge) {
                        const vIdx = positionToVertexIndex.get(`${x},${z}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isLeftEdge) ext.extendLeft = true;
                        if (isBottomEdge) ext.extendUp = true; // North
                    }

                    // Bottom-right vertex (x + 1, z)
                    if (isRightEdge || isBottomEdge) {
                        const vIdx = positionToVertexIndex.get(`${x + 1},${z}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isRightEdge) ext.extendRight = true;
                        if (isBottomEdge) ext.extendUp = true; // North
                    }

                    // Top-right vertex (x + 1, z + 1) - Bottom-right in your view
                    if (isRightEdge || isTopEdge) {
                        const vIdx = positionToVertexIndex.get(`${x + 1},${z + 1}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isRightEdge) ext.extendRight = true;
                        if (isTopEdge) ext.extendDown = true; // South
                    }

                    // Top-left vertex (x, z + 1)
                    if (isLeftEdge || isTopEdge) {
                        const vIdx = positionToVertexIndex.get(`${x},${z + 1}`);
                        if (!perimeterExtensions.has(vIdx)) perimeterExtensions.set(vIdx, { extendLeft: false, extendRight: false, extendUp: false, extendDown: false });
                        const ext = perimeterExtensions.get(vIdx);
                        if (isLeftEdge) ext.extendLeft = true;
                        if (isTopEdge) ext.extendDown = true; // South
                    }
                }
            }
        }
        
        // Step 5: Apply perimeter extensions
        perimeterExtensions.forEach((ext, vertexIndex) => {
            const idx = vertexIndex * 3;
            const [origX, origZ] = originalPositions[vertexIndex];     

            if (ext.extendLeft) vertices[idx] -= extensionAmount; // Extend left
            if (ext.extendRight) vertices[idx] += extensionAmount; // Extend right
            if (ext.extendUp) vertices[idx + 2] -= extensionAmount; // Extend north (decrease z)
            if (ext.extendDown) vertices[idx + 2] += extensionAmount; // Extend south (increase z)

       
        });
        
        // Step 6: Create the BufferGeometry
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geometry.setIndex(indices);
        geometry.computeVertexNormals(); // For lighting
        
        // Parse the hex color to RGB
        const parseHexColor = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return { r, g, b };
        };
        
        const waterShader = this.game.getCollections().shaders[this.level.waterShader];
        
        // Use the hex color in a ShaderMaterial
        this.uniforms[terrainType] = JSON.parse(waterShader.uniforms);
        let vectorizeProps = JSON.parse(waterShader.vectors);
        vectorizeProps.forEach((prop => {
            if (this.uniforms[terrainType][prop]) {
                if( prop.toLowerCase().endsWith("color")){
                    const colorToUse = this.tileMap.terrainTypes[terrainType].color;
                    const { r, g, b } = parseHexColor(colorToUse);
                    this.uniforms[terrainType][prop].value = new THREE.Vector3(r, g, b);
                } else {
                    let arr = this.uniforms[terrainType][prop].value;
                    this.uniforms[terrainType][prop].value = new THREE.Vector3(arr[0], arr[1], arr[2]);
                }
            }
        }));
        
        this.uniforms[terrainType].fogColor = { value: new THREE.Color(this.fogSettings.color) };
        this.uniforms[terrainType].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;
        
        // Reference the uniforms
        const uniforms = this.uniforms[terrainType];
        
        // Create the shader material
        const material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: waterShader.vertexScript,
            fragmentShader: waterShader.fragmentScript,
            side: THREE.DoubleSide,
            transparent: true
        });

        // Replace the MeshBasicMaterial with this ShaderMaterial in the mesh creation
        const waterMesh = new THREE.Mesh(geometry, material);        
        waterMesh.position.y = (terrainType + 1) * this.heightMapSettings.heightStep;
        
        // No additional position offset needed since vertices are already centered
        waterMesh.position.x = 0;
        waterMesh.position.z = 0;
        
        this.scene.add(waterMesh);
        this.liquidMeshes.push(waterMesh);

    }

    addGrassToTerrain() {
        const bladeWidth = 12;
        const bladeHeight = 18;
        const grassGeometry = this.createCurvedBladeGeometry(bladeWidth, bladeHeight);
        grassGeometry.translate(0, bladeHeight / 2, 0);
        const grassCount = 50000;

        const gridSize = this.game.getCollections().configs.game.gridSize;
        const phases = new Float32Array(grassCount);
        for (let i = 0; i < grassCount; i++) {
            phases[i] = Math.random() * Math.PI * 2;
        }
        grassGeometry.setAttribute('instancePhase', new THREE.InstancedBufferAttribute(phases, 1));

        const grassTexture = this.createGrassTexture();
        const grassShader = this.game.getCollections().shaders[this.level.grassShader];
        this.uniforms['grass'] = JSON.parse(grassShader.uniforms);
        
        this.uniforms['grass'].windDirection = { value: new THREE.Vector2(this.uniforms['grass'].windDirection.value[0], this.uniforms['grass'].windDirection.value[1]).normalize()};
        this.uniforms['grass'].map = { value: grassTexture };
        this.uniforms['grass'].fogColor = { value: new THREE.Color(this.fogSettings.color) };
        this.uniforms['grass'].fogDensity = this.fogSettings.enabled ? { value: this.fogSettings.density } : 0;
        const lightDirection = new THREE.Vector3();
        lightDirection.subVectors(this.directionalLight.position, this.directionalLight.target.position);
        lightDirection.normalize();

        this.uniforms['grass'].skyColor =  { value: new THREE.Color(this.lightingSettings.skyColor) }; // HemisphereLight sky color
        this.uniforms['grass'].groundColor = { value: new THREE.Color(this.lightingSettings.groundColor) }; // HemisphereLight ground color
        this.uniforms['grass'].hemisphereIntensity = { value: this.lightingSettings.hemisphereIntensity };

        const uniforms = this.uniforms['grass'];
        this.grassMaterial = new THREE.ShaderMaterial({
            vertexShader: grassShader.vertexScript,
            fragmentShader: grassShader.fragmentScript,
            uniforms: uniforms,
            transparent: true
        });

        this.grassShader = this.grassMaterial;
        
        grassGeometry.computeVertexNormals(); 
        const grass = new THREE.InstancedMesh(grassGeometry, this.grassMaterial, grassCount);
        grass.castShadow = true;
        grass.receiveShadow = false;

        const dummy = new THREE.Object3D();
        const grassArea = this.extendedSize;  
        const ctx = this.groundCanvas.getContext('2d');
        const terrainData = ctx.getImageData(0, 0, this.groundCanvas.width, this.groundCanvas.height).data;

        // Create a density map for grass placement
        const densityMap = new Float32Array(this.extendedSize * this.extendedSize);
        for (let z = 0; z < this.extendedSize; z++) {
            for (let x = 0; x < this.extendedSize; x++) {
                // Check current pixel for green dominance
                const pixelIndex = (z * this.groundCanvas.width + x) * 4;
                const isGreenDominant = (pixel) => {
                    const r = terrainData[pixel];
                    const g = terrainData[pixel + 1];
                    const b = terrainData[pixel + 2];
                    return g > r && g > b;
                };

                // Only set density if current pixel and all neighbors are green
                if (isGreenDominant(pixelIndex)) {
                    // Check 8 neighboring pixels
                    let checkDist = Math.ceil(gridSize / 10);
                    const neighbors = [
                        [-checkDist, -checkDist], [0, -checkDist], [checkDist, -checkDist],
                        [-checkDist,  0],                           [checkDist,  0],
                        [-checkDist,  checkDist], [0,  checkDist], [checkDist,  checkDist]
                    ];

                    let allNeighborsGreen = true;
                    for (const [dx, dz] of neighbors) {
                        const nx = x + dx;
                        const nz = z + dz;
                        
                        // Skip if neighbor is outside bounds
                        if (nx < 0 || nx >= this.extendedSize || nz < 0 || nz >= this.extendedSize) {
                            allNeighborsGreen = false;
                            break;
                        }

                        const neighborIndex = (nz * this.groundCanvas.width + nx) * 4;
                        if (!isGreenDominant(neighborIndex)) {
                            allNeighborsGreen = false;
                            break;
                        }
                    }

                    densityMap[z * this.extendedSize + x] = allNeighborsGreen ? 1 : 0;
                } else {
                    densityMap[z * this.extendedSize + x] = 0;
                }
            }
        }

        // Place grass based on density
        let placed = 0;
        for (let i = 0; i < grassCount * 2 && placed < grassCount; i++) {
            const x = Math.floor(Math.random() * grassArea);
            const z = Math.floor(Math.random() * grassArea);
            if (densityMap[z * this.extendedSize + x] > 0) {
                const rotationY = Math.random() * Math.PI * 2;
                const scale = 0.7 + Math.random() * 0.5;
                let height = this.heightMapSettings.enabled
                    ? this.heightMapData[Math.min(z, this.extendedSize - 1) * this.extendedSize + Math.min(x, this.extendedSize - 1)] || 0
                    : 0;
                dummy.position.set(x - grassArea / 2 , height - bladeHeight, z - grassArea / 2);
                dummy.rotation.set(0, rotationY, 0);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();
                grass.setMatrixAt(placed++, dummy.matrix);
            }
        }

        grass.instanceMatrix.needsUpdate = true;
        this.scene.add(grass);
        this.grass = grass;
    }
    
    createCurvedBladeGeometry(width = 0.1, height = 1) {
        const shape = new THREE.Shape();
        shape.moveTo(0, 0);
        shape.quadraticCurveTo(width * 0.5, height * 0.5, 0, height);
    
        const shapeGeom = new THREE.ShapeGeometry(shape, 12);
        const positions = shapeGeom.attributes.position.array;
        const uvs = shapeGeom.attributes.uv.array;
        const vertexCount = positions.length / 3;
    
        const newUVs = new Float32Array(uvs.length);
        const newNormals = new Float32Array(positions.length);
    
        for (let i = 0; i < vertexCount; i++) {
            const posIndex = i * 3;
            const uvIndex = i * 2;
            const x = positions[posIndex];
            const y = positions[posIndex + 1];
            const normalizedY = y / height;
    
            newUVs[uvIndex] = uvs[uvIndex];
            newUVs[uvIndex + 1] = normalizedY;
    
            // Compute normal: approximate outward direction along curve
            const t = y / height; // Parameter along curve
            const curveX = width * 0.5 * (1 - t); // Quadratic curve approximation
            const tangent = new THREE.Vector2(curveX - x, y - (y - height * 0.5)).normalize();
            const normal = new THREE.Vector2(-tangent.y, tangent.x); // Perpendicular to tangent
            newNormals[posIndex] = normal.x;
            newNormals[posIndex + 1] = 0;
            newNormals[posIndex + 2] = normal.y;
        }
    
        shapeGeom.setAttribute('uv', new THREE.BufferAttribute(newUVs, 2));
        shapeGeom.setAttribute('normal', new THREE.BufferAttribute(newNormals, 3));
        return shapeGeom;
    }

    createGrassTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 4;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');

        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0.0, this.game.palette["greenMColor"]);
        gradient.addColorStop(0.8, this.game.palette["greenMColor"]);
        gradient.addColorStop(1.0, this.game.palette["redLColor"]);

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;
        texture.magFilter = THREE.NearestFilter;
        texture.minFilter = THREE.NearestFilter;
        return texture;
    }

    // Utility methods for external systems
    setControlsEnabled(enabled) {
        if (this.controls) {
            this.controls.enabled = enabled;
        }
    }

    resetCamera() {
        if (!this.cameraSettings) return;

        const cameraPos = JSON.parse(this.cameraSettings.position);
        const lookAt = JSON.parse(this.cameraSettings.lookAt);

        if (this.controls) {
            this.controls.reset();
            this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
            this.controls.target.set(lookAt.x, lookAt.y, lookAt.z);
            this.controls.update();
        } else {
         //   this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
        //    this.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);
        }

    }

    // Terrain update methods for dynamic changes
    updateTerrain() {
        this.terrainRendered = false;
        this._cachedColorMap = null;
        this.renderTerrain();
    }

    destroy() {

        // Clean up extension planes
        if (this.extensionPlanes) {
            this.extensionPlanes.forEach(plane => {
                this.scene.remove(plane);
                plane.geometry?.dispose();
                plane.material?.dispose();
            });
            this.extensionPlanes = [];
        }

        // Clean up ground
        if (this.ground) {
            this.scene.remove(this.ground);
            this.ground.geometry?.dispose();
            this.ground.material?.dispose();
        }

        // Clean up grass
        if (this.grass) {
            this.scene.remove(this.grass);
            this.grass.geometry?.dispose();
            this.grass.material?.dispose();
        }

        // Clean up liquid meshes
        this.liquidMeshes.forEach(mesh => {
            this.scene.remove(mesh);
            mesh.geometry?.dispose();
            mesh.material?.dispose();
        });
        this.liquidMeshes = [];

        // Clean up textures
        this.groundTexture?.dispose();

        // Clean up lights
        if (this.ambientLight) this.scene.remove(this.ambientLight);
        if (this.directionalLight) {
            this.scene.remove(this.directionalLight);
            this.scene.remove(this.directionalLight.target);
        }
        if (this.hemisphereLight) this.scene.remove(this.hemisphereLight);

        // Clean up Three.js core
        if (this.renderer) {
            this.renderer.dispose();
        }

        // Clean up composer
        if (this.composer) {
            this.composer.dispose();
        }

        // Clean up orbit controls
        if (this.controls) {
            this.controls.dispose();
            this.controls = null;
        }

        // Remove event listeners
        window.removeEventListener('resize', this.onWindowResizeHandler);

        // Clear references
        this.groundCanvas = null;
        this.terrainCanvas = null;
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.composer = null;

        this.initialized = false;
    }

    // Add this method to the WorldSystem class

    getTerrainHeightAtPosition(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates
        // The ground is centered at origin, so we need to offset by half the extended size
        const heightMapX = Math.floor(worldX + this.extendedSize / 2);
        const heightMapZ = Math.floor(worldZ + this.extendedSize / 2);
        
        // Ensure coordinates are within bounds
        if (heightMapX < 0 || heightMapX >= this.extendedSize || heightMapZ < 0 || heightMapZ >= this.extendedSize) {
            // Outside terrain bounds, use extension terrain height
            const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
            return extensionTerrainType * this.heightStep;
        }
        
        // Get height from height map
        const heightIndex = heightMapZ * this.extendedSize + heightMapX;
        return this.heightMapData[heightIndex] || 0;
    }

    // Optional: Add bilinear interpolation for smoother height transitions
    getTerrainHeightAtPositionSmooth(worldX, worldZ) {
        // Check if height map is available and enabled
        if (!this.heightMapData || !this.heightMapSettings?.enabled) {
            return 0; // Fallback to flat ground
        }
        
        // Convert world coordinates to height map coordinates (with decimal precision)
        const heightMapX = worldX + this.extendedSize / 2;
        const heightMapZ = worldZ + this.extendedSize / 2;
        
        // Get the four surrounding grid points
        const x0 = Math.floor(heightMapX);
        const x1 = x0 + 1;
        const z0 = Math.floor(heightMapZ);
        const z1 = z0 + 1;
        
        // Get fractional parts for interpolation
        const fx = heightMapX - x0;
        const fz = heightMapZ - z0;
        
        // Helper function to get height at specific grid point
        const getHeightAt = (x, z) => {
            if (x < 0 || x >= this.extendedSize || z < 0 || z >= this.extendedSize) {
                const extensionTerrainType = this.tileMap?.extensionTerrainType || 0;
                return extensionTerrainType * this.heightStep;
            }
            const heightIndex = z * this.extendedSize + x;
            return this.heightMapData[heightIndex] || 0;
        };
        
        // Get heights at the four corners
        const h00 = getHeightAt(x0, z0);
        const h10 = getHeightAt(x1, z0);
        const h01 = getHeightAt(x0, z1);
        const h11 = getHeightAt(x1, z1);
        
        // Bilinear interpolation
        const h0 = h00 * (1 - fx) + h10 * fx;
        const h1 = h01 * (1 - fx) + h11 * fx;
        return h0 * (1 - fz) + h1 * fz;
    }
};

// System: PostProcessingSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['PostProcessingSystem'] = class PostProcessingSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.postProcessingSystem = this;
        
        this.composer = null;
        this.passes = new Map();
        this.passOrder = ['render', 'pixel', 'fog', 'output'];
    }

    init(params = {}) {
        this.params = params;
    }

    postAllInit() {
        
        if (!this.game.renderer || !this.game.scene || !this.game.camera) {
            console.error('[PostProcessingSystem] Missing renderer, scene, or camera in postAllInit');
            return;
        }
        
        
        this.composer = new THREE_.EffectComposer(this.game.renderer);
        
        // Create depth textures for both render targets
        const depthTexture1 = new THREE.DepthTexture();
        depthTexture1.format = THREE.DepthFormat;
        depthTexture1.type   = THREE.UnsignedIntType; // 24/32-bit depth

        const depthTexture2 = new THREE.DepthTexture();
        depthTexture2.format = THREE.DepthFormat;
        depthTexture2.type   = THREE.UnsignedIntType;

        this.composer.renderTarget1.depthTexture = depthTexture1;
        this.composer.renderTarget1.depthBuffer  = true;
        this.composer.renderTarget2.depthTexture = depthTexture2;
        this.composer.renderTarget2.depthBuffer  = true;

        // Make sure sizes are synced after attaching:
        const size = this.game.renderer.getSize(new THREE.Vector2());
        this.composer.setSize(size.x, size.y);
        
        if (this.passes.size > 0) {
            this.rebuildComposer();
        }
        
    }

    registerPass(name, passConfig) {
        
        if (this.passes.has(name)) {
            console.warn(`[PostProcessingSystem] Pass ${name} already exists, replacing`);
        }
        
        this.passes.set(name, passConfig);
        
        if (this.composer) {
            this.rebuildComposer();
        } 
    }

    removePass(name) {
        
        if (this.passes.has(name)) {
            const passConfig = this.passes.get(name);
            if (passConfig.dispose) {
                passConfig.dispose();
            }
            this.passes.delete(name);
            
            if (this.composer) {
                this.rebuildComposer();
            }
        }
    }

    rebuildComposer() {
        if (!this.composer) {
            console.warn('[PostProcessingSystem] Composer not initialized yet');
            return;
        }
        
        
        this.composer.passes = [];
        
        for (const passName of this.passOrder) {
            const passConfig = this.passes.get(passName);
            
            if (!passConfig) continue;
            
            if (passConfig.enabled === false) {
                continue;
            }
            
            if (typeof passConfig.create === 'function') {
                const pass = passConfig.create();
                this.composer.addPass(pass);
            } else if (passConfig.pass) {
                this.composer.addPass(passConfig.pass);
            }
        }
        
    }

    render() {
        if (this.composer) {
            // Render main scene with all post-processing (including fog)
            this.composer.render();
            
            if (this.game.uiScene) {
                this.game.renderer.autoClear = false;  // Don't clear the screen    
                this.game.renderer.clearDepth();             
                this.game.renderer.render(this.game.uiScene, this.game.camera);
                this.game.renderer.autoClear = true;   // Reset for next frame
            }
        }
    }

    setSize(width, height) {
        if (this.composer) {
            this.composer.setSize(width, height);
        }
    }

    dispose() {
        if (this.composer) {
            this.composer.passes.forEach(pass => {
                if (pass.dispose) pass.dispose();
            });
        }
        this.passes.clear();
    }
};

// System: RenderSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['RenderSystem'] = class RenderSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.renderSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        this.vatBatches = new Map();
        this.entityToInstance = new Map();
        this.batchCreationPromises = new Map();
        
        this.modelScale = 32;
        this.DEFAULT_CAPACITY = 128;
        this.MIN_MOVEMENT_THRESHOLD = 0.1;

        this.DEBUG = true;
        this.DEBUG_LEVEL = 1;
        this._frame = 0;
        this._stats = {
            entitiesProcessed: 0,
            instancesCreated: 0,
            instancesRemoved: 0,
            batchesActive: 0
        };

        this._bindDebugHelpers();
        this.hiddenEntities = new Set();
    }

    _bindDebugHelpers() {
        if (typeof window !== "undefined") {
            window.VATRenderDebug = {
                dumpBatches: () => this.dumpBatches(),
                dumpInstances: () => this.dumpInstances(),
                setDebugLevel: (level) => this.DEBUG_LEVEL = level,
                getStats: () => this._stats
            };
        }
    }

    update() {
        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;

        this._frame++;
        this.updateEntities();
        this.updateAnimations();
        this.finalizeUpdates();
    }

    updateEntities() {
        const CT = this.componentTypes;
        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);
        this._stats.entitiesProcessed = entities.length;

        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
            const velocity = this.game.getComponent(entityId, CT.VELOCITY);
            const facing = this.game.getComponent(entityId, CT.FACING);
            const team = this.game.getComponent(entityId, CT.TEAM);

            if (!pos || !renderable) return;

            if (this.isEnemy(team) && !this.isVisibleForPlayer(pos)) {
                if (this.entityToInstance.has(entityId)) {
                    this.hideEntityInstance(entityId);
                }
                return;
            } else {
                if (this.hiddenEntities.has(entityId)) {
                    this.showEntityInstance(entityId);
                }
            }

            if (typeof renderable.spawnType !== 'string') {
                console.error(`[RenderSystem] Unit entity ${entityId} has invalid spawnType:`, {
                    objectType: renderable.objectType,
                    spawnType: renderable.spawnType,
                    spawnTypeType: typeof renderable.spawnType
                });
                return;
            }

            let instance = this.entityToInstance.get(entityId);
            if (!instance) {
                this.createInstance(entityId, renderable.objectType, renderable.spawnType);
                instance = this.entityToInstance.get(entityId);
            }

            if (instance && !this.hiddenEntities.has(entityId)) {
                this.updateInstanceTransform(instance, pos, velocity, facing);
            }
        });

        this.cleanupRemovedEntities(new Set(entities));
    }

    async createInstance(entityId, objectType, spawnType) {
        if (typeof spawnType !== 'string') {
            console.error(`[RenderSystem] CRITICAL: spawnType should be string but got ${typeof spawnType}:`, spawnType);
            return null;
        }

        const batchKey = `${objectType}_${spawnType}`;
        
        let batch = this.vatBatches.get(batchKey);
        if (!batch) {
            if (this.batchCreationPromises.has(batchKey)) {
                try {
                    batch = await this.batchCreationPromises.get(batchKey);
                } catch (error) {
                    return null;
                }
            } else {
                const creationPromise = this.createVATBatch(batchKey, objectType, spawnType);
                this.batchCreationPromises.set(batchKey, creationPromise);
                
                try {
                    batch = await creationPromise;
                    if (!batch) {
                        console.error(`[RenderSystem] Failed to create batch for ${batchKey}`);
                        return null;
                    }
                } finally {
                    this.batchCreationPromises.delete(batchKey);
                }
            }
        }

        if (!batch || !batch.capacity) {
            console.error(`[RenderSystem] Batch has no capacity property:`, batch);
            return null;
        }

        let instanceIndex = -1;
        for (let i = 0; i < batch.capacity; i++) {
            if (!batch.entityMap.has(i)) {               
                instanceIndex = i;
                break;
            }
        }

        if (instanceIndex === -1) {
            console.warn(`[RenderSystem] Batch ${batchKey} is full (${batch.capacity} instances)`);
            return null;
        }

        batch.entityMap.set(instanceIndex, entityId);
        batch.count = Math.max(batch.count, instanceIndex + 1);
        batch.mesh.count = batch.count;

        if (batch.attributes && batch.attributes.clipIndex) {
            batch.attributes.clipIndex.setX(instanceIndex, 0);
            batch.attributes.animTime.setX(instanceIndex, 0);
            batch.attributes.animSpeed.setX(instanceIndex, 1);
            
            batch.attributes.clipIndex.array[instanceIndex] = 0;
            batch.attributes.animTime.array[instanceIndex] = 0;
            batch.attributes.animSpeed.array[instanceIndex] = 1;
            
            batch.dirty.animation = true; 
        }

        const instance = { batchKey, instanceIndex };
        this.entityToInstance.set(entityId, instance);
        this._stats.instancesCreated++;
    
        return instance;
    }

    async createVATBatch(batchKey, objectType, spawnType) {
        const collections = this.game.getCollections?.();
        let objectDef = null;
        
        if (collections[objectType]) {
            objectDef = collections[objectType][spawnType];
            if (!objectDef && typeof spawnType === 'number') {
                const objectKeys = Object.keys(collections[objectType]);
                if (spawnType < objectKeys.length) {
                    const unitKey = objectKeys[spawnType];
                    objectDef = collections[objectType][unitKey];
                }
            }
            if (!objectDef) {
                objectDef = collections[objectType][String(spawnType)];
            }
        }
        
        if (!objectDef) {
            console.error(`[RenderSystem] No object definition found for ${objectType} - ${spawnType}`);
            return null;
        }

        let bundleResult;
        try {
            bundleResult = await this.game.modelManager.requestVATBundle(objectType, spawnType, objectDef);
        } catch (error) {
            console.error(`[RenderSystem] VAT bundle request failed for ${batchKey}:`, error);
            return null;
        }
        
        if (!bundleResult.ready) {
            console.warn(`[RenderSystem] VAT bundle not ready for ${batchKey}`);
            return null;
        }

        const bundle = bundleResult.bundle;
        if (!bundle) {
            console.error(`[RenderSystem] No bundle in result for ${batchKey}`, bundleResult);
            return null;
        }
        
        if (!bundle.geometry || !bundle.material) {
            console.error(`[RenderSystem] Invalid VAT bundle for ${batchKey} - missing geometry or material:`, {
                hasGeometry: !!bundle.geometry,
                hasMaterial: !!bundle.material,
                bundle
            });
            return null;
        }

        if (bundle.meta) {
            if (bundle.meta.clips && bundle.meta.clipIndexByName) {
                bundle.meta.clips.forEach((clip, arrayIndex) => {
                    const mappedIndex = bundle.meta.clipIndexByName[clip.name];
                    const match = mappedIndex === arrayIndex;
                    if (!match) {
                        console.error(`[RenderSystem] METADATA CORRUPTION: Clip "${clip.name}" index mismatch!`);
                    }
                });
            }
        } else {
            console.error(`[RenderSystem] CRITICAL: No meta object in VAT bundle for ${batchKey}`);
        }

        const geometry = bundle.geometry.clone();
        const material = bundle.material;
        const capacity = this.DEFAULT_CAPACITY;

        material.uuid = THREE.MathUtils.generateUUID();
        material.needsUpdate = true;

        material.userData = {
            batchKey: batchKey,
            createdAt: Date.now(),
            vatTexture: bundle.meta.vatTextureId || 'unknown'
        };

        this.setupVATAttributes(geometry, capacity);

        const mesh = new THREE.InstancedMesh(geometry, material, capacity);
        mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        mesh.count = 0;
        mesh.castShadow = true;
        mesh.receiveShadow = true;

        mesh.frustumCulled = false;
        
        const boundingBox = new THREE.Box3();
        const size = this.modelScale * 2;
        boundingBox.setFromCenterAndSize(new THREE.Vector3(0, 0, 0), new THREE.Vector3(size, size, size));
        geometry.boundingBox = boundingBox;
        geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(0, 0, 0), size * 0.5);

        if (!material.side || material.side === THREE.FrontSide) {
            material.side = THREE.DoubleSide;
        }

        this.game.scene.add(mesh);

        const batch = {
            mesh,
            geometry,
            material,
            capacity,
            count: 0,
            entityMap: new Map(),
            attributes: {
                clipIndex: geometry.getAttribute('aClipIndex'),
                animTime: geometry.getAttribute('aAnimTime'),
                animSpeed: geometry.getAttribute('aAnimSpeed')
            },
            dirty: {
                matrices: false,
                animation: false
            },
            meta: bundle.meta,
            bundleSource: `${objectType}/${spawnType}`
        };

        for (let i = 0; i < capacity; i++) {
            batch.attributes.clipIndex.setX(i, 0);
            batch.attributes.animTime.setX(i, 0);
            batch.attributes.animSpeed.setX(i, 1);
        }
        batch.dirty.animation = true;

        this.vatBatches.set(batchKey, batch);
        this._stats.batchesActive = this.vatBatches.size;
  
        return batch;
    }

    setupVATAttributes(geometry, capacity) {
        const clipIndexArray = new Float32Array(capacity).fill(0);
        const animTimeArray = new Float32Array(capacity).fill(0);
        const animSpeedArray = new Float32Array(capacity).fill(1);

        const clipIndexAttr = new THREE.InstancedBufferAttribute(clipIndexArray, 1);
        const animTimeAttr = new THREE.InstancedBufferAttribute(animTimeArray, 1);
        const animSpeedAttr = new THREE.InstancedBufferAttribute(animSpeedArray, 1);
        
        clipIndexAttr.setUsage(THREE.DynamicDrawUsage);
        animTimeAttr.setUsage(THREE.DynamicDrawUsage);
        animSpeedAttr.setUsage(THREE.DynamicDrawUsage);
        
        geometry.setAttribute('aClipIndex', clipIndexAttr);
        geometry.setAttribute('aAnimTime', animTimeAttr);
        geometry.setAttribute('aAnimSpeed', animSpeedAttr);
    }

    updateInstanceTransform(instance, pos, velocity, facing) {
        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const matrix = new THREE.Matrix4();
        const baseScale = (batch.meta && batch.meta.baseScale) ? batch.meta.baseScale : new THREE.Vector3(1, 1, 1);
        const basePosition = (batch.meta && batch.meta.basePos) ? batch.meta.basePos : new THREE.Vector3(0, 0, 0);

        const position = new THREE.Vector3(
            pos.x + basePosition.x,
            pos.y + basePosition.y,
            pos.z + basePosition.z
        );
        
        const quaternion = new THREE.Quaternion();
        const facingAngle = this.calculateFacingAngle(velocity, facing);
        if (facingAngle !== null) {
            const isProjectile = !facing || facing.angle === undefined;
			if(isProjectile) {
                const direction = new THREE.Vector3(velocity.vx, velocity.vy, velocity.vz).normalize();
                const defaultForward = new THREE.Vector3(0, 1, 0);
                quaternion.setFromUnitVectors(defaultForward, direction);
            } else {
				quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -facingAngle + Math.PI / 2);
			}
        }

        const scale = new THREE.Vector3(
            this.modelScale * baseScale.x,
            this.modelScale * baseScale.y,
            this.modelScale * baseScale.z
        );

        matrix.compose(position, quaternion, scale);
        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);
        batch.dirty.matrices = true;
    }

    calculateFacingAngle(velocity, facing) {
        if (velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD)) {
            return Math.atan2(velocity.vz, velocity.vx);
        }
        
        if (facing && facing.angle !== undefined) {
            return facing.angle;
        }

        return null;
    }

    updateAnimations() {
        const dt = this.game.state?.deltaTime;
        if (!dt) return;

        for (const [batchKey, batch] of this.vatBatches) {
            if (batchKey.startsWith('buildings_')) continue;
            const clipIndexAttr = batch.attributes.clipIndex;
            const animTimeAttr = batch.attributes.animTime;
            const animSpeedAttr = batch.attributes.animSpeed;
            
            let hasAnimationUpdates = false;

            for (const [instanceIndex, entityId] of batch.entityMap) {
                const currentTime = animTimeAttr.array[instanceIndex];
                const speed = animSpeedAttr.array[instanceIndex];
                const clipIndex = clipIndexAttr.array[instanceIndex];

                if (speed > 0) {
                    const clip = batch.meta.clips[clipIndex];
                    const duration = clip?.duration || 1.0;
                    
                    const newTime = (currentTime + dt * speed) % duration;
                    animTimeAttr.array[instanceIndex] = newTime;
                    hasAnimationUpdates = true;
                }
            }

            if (hasAnimationUpdates) {
                animTimeAttr.needsUpdate = true;
                batch.dirty.animation = true;
            }
        }
    }

    finalizeUpdates() {
        for (const batch of this.vatBatches.values()) {
            if (batch.dirty.matrices) {
                batch.mesh.instanceMatrix.needsUpdate = true;
                batch.dirty.matrices = false;
            }
            
            if (batch.dirty.animation) {
                batch.attributes.clipIndex.needsUpdate = true;
                batch.attributes.animSpeed.needsUpdate = true;
                batch.dirty.animation = false;
            }
        }
    }

    setInstanceClip(entityId, clipName, resetTime = true) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) {
            console.warn(`[RenderSystem] No instance found for entity ${entityId}`);
            return false;
        }

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) {
            console.warn(`[RenderSystem] No batch found for key ${instance.batchKey}`);
            return false;
        }

        const clipIndex = batch.meta.clipIndexByName[clipName];
        if (clipIndex === undefined) {
            console.warn(`[RenderSystem] Clip '${clipName}' not found in batch ${instance.batchKey}.`);
            console.warn(`Available:`, Object.keys(batch.meta.clipIndexByName));
            console.warn(`  - Batch meta clips array:`, batch.meta.clips?.map(c => c.name || 'unnamed'));
            console.warn(`  - Bundle source:`, batch.bundleSource || 'unknown');
            return false;
        }

        const currentEntity = batch.entityMap.get(instance.instanceIndex);
        
        if (currentEntity !== entityId) {
            console.error(`[RenderSystem] SLOT CORRUPTION! Slot ${instance.instanceIndex} maps to ${currentEntity} but trying to write for ${entityId}`);
            
            let correctSlot = -1;
            for (const [slot, mappedEntityId] of batch.entityMap.entries()) {
                if (mappedEntityId === entityId) {
                    correctSlot = slot;
                    break;
                }
            }
            if (correctSlot !== -1) {
                console.warn(`[RenderSystem] RECOVERY: Found correct slot ${correctSlot} for entity ${entityId}`);
                instance.instanceIndex = correctSlot;
                this.entityToInstance.set(entityId, instance);
            } else {
                console.error(`[RenderSystem] CORRUPTION: Entity ${entityId} not found in any slot!`);
                return false;
            }
        }

        batch.attributes.clipIndex.setX(instance.instanceIndex, clipIndex);
        batch.attributes.clipIndex.array[instance.instanceIndex] = clipIndex;
        
        if (resetTime) {
            batch.attributes.animTime.setX(instance.instanceIndex, 0);
            batch.attributes.animTime.array[instance.instanceIndex] = 0;
        }
        batch.dirty.animation = true;

        const verifyClipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];
  
        if (verifyClipIndex !== clipIndex) {
            console.error(`[RenderSystem] WRITE FAILED! Expected ${clipIndex} but got ${verifyClipIndex}`);
        }

        return true;
    }

    setInstanceSpeed(entityId, speed) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return false;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return false;

        batch.attributes.animSpeed.setX(instance.instanceIndex, speed);
        batch.dirty.animation = true;
    
        return true;
    }

    getInstanceAnimationState(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return null;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return null;

        try {
            const clipIndex = batch.attributes.clipIndex.array[instance.instanceIndex];
            const animTime = batch.attributes.animTime.array[instance.instanceIndex];
            const animSpeed = batch.attributes.animSpeed.array[instance.instanceIndex];

            if (clipIndex === undefined || clipIndex === null) return null;

            const clipName = Object.keys(batch.meta.clipIndexByName).find(
                name => batch.meta.clipIndexByName[name] === clipIndex
            );

            return {
                clipName,
                clipIndex,
                animTime,
                animSpeed,
                clipDuration: batch.meta.clips[clipIndex]?.duration || 1.0
            };
        } catch (error) {
            return null;
        }
    }

    cleanupRemovedEntities(currentEntities) {
        const toRemove = [];
        
        for (const [entityId, instance] of this.entityToInstance) {
            if (!currentEntities.has(entityId)) {
                toRemove.push(entityId);
            }
        }

        toRemove.forEach(entityId => {
            this.removeInstance(entityId);
        });
    }

    removeInstance(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return;

        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const mappedEntity = batch.entityMap.get(instance.instanceIndex);
        if (mappedEntity !== entityId) {
            console.error(`[RenderSystem] CORRUPTION DETECTED! Instance ${instance.instanceIndex} maps to ${mappedEntity} but trying to remove ${entityId}`);
        }

        batch.entityMap.delete(instance.instanceIndex);
        this.entityToInstance.delete(entityId);

        const matrix = new THREE.Matrix4();
        matrix.scale(new THREE.Vector3(0, 0, 0));
        batch.mesh.setMatrixAt(instance.instanceIndex, matrix);
        batch.dirty.matrices = true;

        batch.attributes.clipIndex.setX(instance.instanceIndex, 0);
        batch.attributes.animTime.setX(instance.instanceIndex, 0);
        batch.attributes.animSpeed.setX(instance.instanceIndex, 0);
        
        batch.attributes.clipIndex.array[instance.instanceIndex] = 0;
        batch.attributes.animTime.array[instance.instanceIndex] = 0;
        batch.attributes.animSpeed.array[instance.instanceIndex] = 0;
        
        batch.dirty.animation = true;

        this._stats.instancesRemoved++;
    }

    isInstanced(entityId) {
        return this.entityToInstance.has(entityId);
    }

    getBatchInfo(objectType, spawnType) {
        const batchKey = `${objectType}_${spawnType}`;
        const batch = this.vatBatches.get(batchKey);
        if (!batch) return null;

        return {
            batchKey,
            capacity: batch.capacity,
            count: batch.count,
            activeInstances: batch.entityMap.size,
            availableClips: Object.keys(batch.meta.clipIndexByName)
        };
    }

    dumpBatches() {
        const batches = [];
        for (const [key, batch] of this.vatBatches) {
            batches.push({
                key,
                capacity: batch.capacity,
                count: batch.count,
                activeInstances: batch.entityMap.size,
                clips: Object.keys(batch.meta.clipIndexByName),
                entityMappings: Array.from(batch.entityMap.entries())
            });
        }
        return batches;
    }

    dumpInstances() {
        const instances = [];
        for (const [entityId, instance] of this.entityToInstance) {
            const state = this.getInstanceAnimationState(entityId);
            instances.push({
                entityId,
                batchKey: instance.batchKey,
                instanceIndex: instance.instanceIndex,
                animationState: state
            });
        }
        return instances;
    }

    entityDestroyed(entityId) {
        this.removeInstance(entityId);
    }

    isEnemy(teamComp) {
        const myTeam = this.game?.state?.mySide;
        if (!teamComp || myTeam == null) return false;
        return teamComp.team !== myTeam;
    }

    isVisibleForPlayer(pos) {
        const fow = this.game?.fogOfWarSystem;
        if (!fow || !pos) return true;
        return fow.isVisibleAt(pos.x, pos.z);
    }

    hideEntityInstance(entityId) {
        const instance = this.entityToInstance.get(entityId);
        if (!instance) return;
        const batch = this.vatBatches.get(instance.batchKey);
        if (!batch) return;

        const m = new THREE.Matrix4();
        m.scale(new THREE.Vector3(0, 0, 0));
        batch.mesh.setMatrixAt(instance.instanceIndex, m);
        batch.dirty.matrices = true;

        this.hiddenEntities.add(entityId);
    }

    showEntityInstance(entityId) {
        this.hiddenEntities.delete(entityId);
    }

    destroy() {
        for (const batch of this.vatBatches.values()) {
            if (batch.mesh) {
                this.game.scene.remove(batch.mesh);
                batch.mesh.geometry?.dispose();
                batch.mesh.material?.dispose();
            }
        }
        
        this.vatBatches.clear();
        this.entityToInstance.clear();
        this.batchCreationPromises.clear();
    }
};

// System: MovementSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['MovementSystem'] = class MovementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.movementSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.MIN_MOVEMENT_THRESHOLD = 0.1;
        
        this.AI_SPEED_MULTIPLIER = 0.1;
        this.DEFAULT_AI_SPEED = 50;
        this.POSITION_UPDATE_MULTIPLIER = 1;
        this.DEFAULT_TERRAIN_SIZE = 768 * 2;
        
        this.GRAVITY = 200;
        this.GROUND_LEVEL = 0;
        this.GROUND_IMPACT_THRESHOLD = 5;
        this.TERRAIN_FOLLOW_SPEED = 8;
        
        this.SEPARATION_FORCE = 80;
        this.SEPARATION_RADIUS_MULTIPLIER = 0.1;
        this.MAX_SEPARATION_CHECKS = 8;
        this.AVOIDANCE_SMOOTHING = 0.15;
        
        this.PATHFINDING_LOOKAHEAD = 100;
        this.OBSTACLE_AVOIDANCE_FORCE = 70;
        this.AVOIDANCE_ANGLE = Math.PI / 3;
        this.STUCK_THRESHOLD = 5;
        this.STUCK_TIME_LIMIT = 2000;
        this.REPATH_DISTANCE = 50;
        
        this.PATH_WAYPOINT_DISTANCE = 50;
        this.PATH_REACHED_DISTANCE = 24;
        this.PATH_REREQUEST_INTERVAL = 0.5;
        
        this.SPATIAL_GRID_SIZE = 80;
        this.MAX_PATHFINDING_CHECKS = 6;
        this.PATHFINDING_CHECK_POINTS = 3;
        this.PATHFINDING_UPDATE_INTERVAL = 3;
        this.NEAR_UNIT_RADIUS = 150;
        
        this.VELOCITY_SMOOTHING = 0.9;
        this.DIRECTION_SMOOTHING = 0.9;
        this.FORCE_DAMPING = 0.85;
        this.MIN_DIRECTION_CHANGE = 0.1;
        this.OSCILLATION_DETECTION_FRAMES = 5;
        this.OSCILLATION_THRESHOLD = Math.PI / 6;
        
        this.unitStates = new Map();
        this.spatialGrid = new Map();
        this.frameCounter = 0;
        this.pathfindingQueue = [];
        this.pathfindingQueueIndex = 0;
        
        this.movementHistory = new Map();
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        this.frameCounter++;
        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION, this.componentTypes.VELOCITY);
        
        this.buildSpatialGrid(entities);
        
        const unitData = new Map();
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            
            if (!projectile) {
                const unitRadius = this.getUnitRadius(collision);

                const isAnchored = vel.anchored ||
                    (!!aiState &&
                    (aiState.state === 'attacking' || aiState.state === 'waiting') &&
                    aiState.aiBehavior &&
                    !!aiState.target);

                unitData.set(entityId, {
                    pos, vel, unitType, collision, aiState, projectile,
                    unitRadius,
                    isAnchored,
                    desiredVelocity: { vx: 0, vy: 0, vz: 0 },
                    separationForce: { x: 0, y: 0, z: 0 },
                    avoidanceForce: { x: 0, y: 0, z: 0 }
                });
                
                this.updateUnitState(entityId, pos, vel);
                this.updateMovementHistory(entityId, vel);
            }
        });
        
        const sortedEntityIds = Array.from(unitData.keys());

        sortedEntityIds.forEach((entityId) => {
            this.calculateDesiredVelocity(entityId, unitData.get(entityId));
        });
        
        sortedEntityIds.forEach((entityId) => {
            this.calculateSeparationForceOptimized(entityId, unitData.get(entityId));
        });
        
        this.updatePathfindingStaggered(unitData);
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(entityId, this.componentTypes.VELOCITY);
            const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            
            const isAffectedByGravity = vel.affectedByGravity;
            
            if (!projectile && unitData.has(entityId)) {
                let entityData = unitData.get(entityId);
                if(vel.vx != 0 || vel.vz != 0 || entityData.desiredVelocity.vx != 0 || entityData.desiredVelocity.vz != 0){
                    this.applyUnitMovementWithSmoothing(entityId, unitData.get(entityId));
                }
            }
            
            if (isAffectedByGravity) {
                vel.vy -= this.GRAVITY * this.game.state.deltaTime;
            }
            
            pos.x += vel.vx * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.y += vel.vy * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
            pos.z += vel.vz * this.game.state.deltaTime * this.POSITION_UPDATE_MULTIPLIER;
      
            if(!projectile){
                this.handleGroundInteraction(pos, vel);
                this.enforceBoundaries(pos, collision);
                    
                const placement = this.game.getComponent(entityId, this.componentTypes.PLACEMENT);
                if (placement && placement.placementId && this.game.gridSystem) {
                    this.game.gridSystem.updateUnitPosition(placement.placementId, pos.x, pos.z);
                }
            }
        });
    }
    
    updateMovementHistory(entityId, vel) {
        if (!this.movementHistory.has(entityId)) {
            this.movementHistory.set(entityId, {
                velocityHistory: [],
                smoothedDirection: { x: 0, z: 0 },
                dampedForces: { separation: { x: 0, z: 0 }, avoidance: { x: 0, z: 0 } }
            });
        }
        
        const history = this.movementHistory.get(entityId);
        
        history.velocityHistory.push({ 
            vx: vel.vx, 
            vz: vel.vz, 
            frame: this.frameCounter 
        });
        
        if (history.velocityHistory.length > this.OSCILLATION_DETECTION_FRAMES) {
            history.velocityHistory.shift();
        }
    }
    
    isUnitOscillating(entityId) {
        const history = this.movementHistory.get(entityId);
        if (!history || history.velocityHistory.length < this.OSCILLATION_DETECTION_FRAMES) {
            return false;
        }
        
        let directionChanges = 0;
        let lastDirection = null;
        
        for (const vel of history.velocityHistory) {
            const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
            if (speed < 0.1) continue;
            
            const direction = Math.atan2(vel.vz, vel.vx);
            if (lastDirection !== null) {
                let angleDiff = Math.abs(direction - lastDirection);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                
                if (angleDiff > this.OSCILLATION_THRESHOLD) {
                    directionChanges++;
                }
            }
            lastDirection = direction;
        }
        
        return directionChanges >= 2;
    }
    
    buildSpatialGrid(entities) {
        this.spatialGrid.clear();
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            
            if (!projectile && pos) {
                const gridX = Math.floor(Math.round(pos.x * 1000) / 1000 / this.SPATIAL_GRID_SIZE);
                const gridZ = Math.floor(Math.round(pos.z * 1000) / 1000 / this.SPATIAL_GRID_SIZE);
                const gridKey = `${gridX},${gridZ}`;
                
                if (!this.spatialGrid.has(gridKey)) {
                    this.spatialGrid.set(gridKey, []);
                }
                this.spatialGrid.get(gridKey).push(entityId);
            }
        });
        
        for (const [gridKey, entityList] of this.spatialGrid.entries()) {
            entityList.sort((a, b) => String(a).localeCompare(String(b)));
        }
    }
    
    getNearbyUnits(pos, radius) {
        const nearbyUnits = [];
        const gridRadius = Math.ceil(Math.round(radius * 1000) / 1000 / this.SPATIAL_GRID_SIZE);
        const centerGridX = Math.floor(Math.round(pos.x * 1000) / 1000 / this.SPATIAL_GRID_SIZE);
        const centerGridZ = Math.floor(Math.round(pos.z * 1000) / 1000 / this.SPATIAL_GRID_SIZE);
        
        const gridCells = [];
        for (let gridX = centerGridX - gridRadius; gridX <= centerGridX + gridRadius; gridX++) {
            for (let gridZ = centerGridZ - gridRadius; gridZ <= centerGridZ + gridRadius; gridZ++) {
                gridCells.push(`${gridX},${gridZ}`);
            }
        }
        
        gridCells.sort();
        
        for (const gridKey of gridCells) {
            const cellUnits = this.spatialGrid.get(gridKey);
            if (cellUnits) {
                nearbyUnits.push(...cellUnits);
            }
        }
        
        return nearbyUnits.sort((a, b) => String(a).localeCompare(String(b)));
    }
    
    updatePathfindingStaggered(unitData) {
        if (this.pathfindingQueue.length === 0) {
            const sortedEntityIds = Array.from(unitData.keys()).sort((a, b) => String(a).localeCompare(String(b)));
            sortedEntityIds.forEach(entityId => {
                const data = unitData.get(entityId);
                if (data.aiState?.state === 'chasing') {
                    this.pathfindingQueue.push(entityId);
                }
            });
        }
        
        const unitsPerFrame = Math.max(1, Math.ceil(this.pathfindingQueue.length / this.PATHFINDING_UPDATE_INTERVAL));
        
        for (let i = 0; i < unitsPerFrame && this.pathfindingQueueIndex < this.pathfindingQueue.length; i++) {
            const entityId = this.pathfindingQueue[this.pathfindingQueueIndex];
            if (unitData.has(entityId)) {
                this.calculatePathfindingAvoidanceOptimized(entityId, unitData.get(entityId), unitData);
            }
            this.pathfindingQueueIndex++;
        }
        
        if (this.pathfindingQueueIndex >= this.pathfindingQueue.length) {
            this.pathfindingQueueIndex = 0;
            this.pathfindingQueue = [];
        }
    }
    
    updateUnitState(entityId, pos, vel) {
        const currentTime = this.game.state.now;
        
        if (!this.unitStates.has(entityId)) {
            this.unitStates.set(entityId, {
                lastPosition: { x: pos.x, z: pos.z },
                lastMovementTime: currentTime,
                stuckTime: 0,
                lastPathTime: 0,
                avoidanceDirection: 0
            });
            return;
        }
        
        const state = this.unitStates.get(entityId);
        const speed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        const distanceMoved = Math.sqrt(
            Math.pow(pos.x - state.lastPosition.x, 2) + 
            Math.pow(pos.z - state.lastPosition.z, 2)
        );
        
        if (speed < this.STUCK_THRESHOLD && distanceMoved < 1) {
            state.stuckTime += this.game.state.deltaTime;
        } else {
            state.stuckTime = 0;
            state.lastPosition.x = pos.x;
            state.lastPosition.z = pos.z;
        }
        
        if (distanceMoved > this.REPATH_DISTANCE) {
            state.avoidanceDirection = 0;
            state.lastPathTime = currentTime;
        }
    }
    
    calculateSeparationForceOptimized(entityId, data) {
        const { pos, unitRadius, isAnchored } = data;

        if (isAnchored) {
            data.separationForce.x = 0;
            data.separationForce.y = 0;
            data.separationForce.z = 0;
            return;
        }
        
        const separationRadius = unitRadius * this.SEPARATION_RADIUS_MULTIPLIER;
        const nearbyUnits = this.getNearbyUnits(pos, separationRadius);
        
        let separationForceX = 0;
        let separationForceZ = 0;
        let neighborCount = 0;
        let checksPerformed = 0;
        
        for (const otherEntityId of nearbyUnits) {
            if (entityId === otherEntityId) continue;
            if (checksPerformed >= this.MAX_SEPARATION_CHECKS) break;
            
            checksPerformed++;
            
            const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
            const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
            
            if (!otherPos) continue;
            
            const otherRadius = this.getUnitRadius(otherCollision);
            
            const dx = pos.x - otherPos.x;
            const dz = pos.z - otherPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            const minDistance = unitRadius + otherRadius;
            const influenceDistance = Math.max(minDistance, separationRadius);
            
            if (distance < influenceDistance && distance > 0.1) {
                const force = this.SEPARATION_FORCE * (influenceDistance - distance) / influenceDistance;
                
                const dirX = dx / distance;
                const dirZ = dz / distance;
                
                separationForceX += dirX * force;
                separationForceZ += dirZ * force;
                neighborCount++;
            }
        }
        
        if (neighborCount > 0) {
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedSeparation = history.dampedForces.separation;
                dampedSeparation.x *= this.FORCE_DAMPING;
                dampedSeparation.z *= this.FORCE_DAMPING;
                
                separationForceX = (separationForceX / neighborCount) * 0.7 + dampedSeparation.x * 0.3;
                separationForceZ = (separationForceZ / neighborCount) * 0.7 + dampedSeparation.z * 0.3;
                
                dampedSeparation.x = separationForceX;
                dampedSeparation.z = separationForceZ;
            } else {
                separationForceX /= neighborCount;
                separationForceZ /= neighborCount;
            }
        }
        
        data.separationForce.x = separationForceX;
        data.separationForce.z = separationForceZ;
    }
    
    calculatePathfindingAvoidanceOptimized(entityId, data, allUnitData) {
        const { pos, vel, aiState, unitRadius, isAnchored } = data;

        if (isAnchored || !aiState || aiState.state !== 'chasing') {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        let targetPos = aiState.targetPosition;
        const targetEntityId = aiState.target;

        if(targetEntityId){
            targetPos = this.game.getComponent(targetEntityId, this.componentTypes.POSITION);
        }
        
        if (!targetPos) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        const desiredDirection = {
            x: targetPos.x - pos.x,
            z: targetPos.z - pos.z
        };
        
        const desiredDistance = Math.sqrt(desiredDirection.x * desiredDirection.x + desiredDirection.z * desiredDirection.z);
        
        if (desiredDistance < 0.1) {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
            return;
        }
        
        desiredDirection.x /= desiredDistance;
        desiredDirection.z /= desiredDistance;
        
        const obstacleInfo = this.findObstaclesInPathOptimized(pos, desiredDirection, unitRadius, entityId, targetEntityId);
        
        if (obstacleInfo.hasObstacle) {
            const unitState = this.unitStates.get(entityId);
            const avoidanceForce = this.calculateAvoidanceVector(
                pos, desiredDirection, obstacleInfo, unitState, unitRadius
            );
            
            const history = this.movementHistory.get(entityId);
            if (history) {
                const dampedAvoidance = history.dampedForces.avoidance;
                dampedAvoidance.x *= this.FORCE_DAMPING;
                dampedAvoidance.z *= this.FORCE_DAMPING;
                
                const blendedX = avoidanceForce.x * 0.6 + dampedAvoidance.x * 0.4;
                const blendedZ = avoidanceForce.z * 0.6 + dampedAvoidance.z * 0.4;
                
                dampedAvoidance.x = blendedX;
                dampedAvoidance.z = blendedZ;
                
                data.avoidanceForce.x = blendedX;
                data.avoidanceForce.z = blendedZ;
            } else {
                data.avoidanceForce.x = avoidanceForce.x;
                data.avoidanceForce.z = avoidanceForce.z;
            }
        } else {
            data.avoidanceForce.x = 0;
            data.avoidanceForce.z = 0;
        }
    }
    
    findObstaclesInPathOptimized(pos, direction, unitRadius, entityId, targetEntityId = null) {
        const lookaheadDistance = this.PATHFINDING_LOOKAHEAD;
        const checkRadius = unitRadius * 1.5;
        
        const nearbyUnits = this.getNearbyUnits(pos, lookaheadDistance + checkRadius);
        
        let closestObstacle = null;
        let closestDistance = Infinity;
        let checksPerformed = 0;
        
        for (let i = 1; i <= this.PATHFINDING_CHECK_POINTS; i++) {
            const checkDistance = (lookaheadDistance / this.PATHFINDING_CHECK_POINTS) * i;
            const checkPos = {
                x: pos.x + direction.x * checkDistance,
                z: pos.z + direction.z * checkDistance
            };
            
            for (const otherEntityId of nearbyUnits) {
                if (entityId === otherEntityId) continue;
                if (targetEntityId && otherEntityId === targetEntityId) continue;
                if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
                
                checksPerformed++;
                
                const otherPos = this.game.getComponent(otherEntityId, this.componentTypes.POSITION);
                const otherCollision = this.game.getComponent(otherEntityId, this.componentTypes.COLLISION);
                
                if (!otherPos) continue;
                
                const otherRadius = this.getUnitRadius(otherCollision);
                
                const dx = checkPos.x - otherPos.x;
                const dz = checkPos.z - otherPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                const minDistance = checkRadius + otherRadius;
                
                if (distance < minDistance && distance < closestDistance) {
                    closestDistance = distance;
                    closestObstacle = {
                        pos: otherPos,
                        radius: otherRadius,
                        distance: distance,
                        entityId: otherEntityId
                    };
                }
            }
            
            if (checksPerformed >= this.MAX_PATHFINDING_CHECKS) break;
        }
        
        return {
            hasObstacle: closestObstacle !== null,
            obstacle: closestObstacle
        };
    }
    
    calculateAvoidanceVector(pos, desiredDirection, obstacleInfo, unitState, unitRadius) {
        if (!obstacleInfo.hasObstacle) {
            return { x: 0, z: 0 };
        }
        
        const obstacle = obstacleInfo.obstacle;
        const toObstacle = {
            x: obstacle.pos.x - pos.x,
            z: obstacle.pos.z - pos.z
        };
        
        const obstacleDistance = Math.sqrt(toObstacle.x * toObstacle.x + toObstacle.z * toObstacle.z);
        
        if (obstacleDistance < 0.1) {
            return { x: 0, z: 0 };
        }
        
        toObstacle.x /= obstacleDistance;
        toObstacle.z /= obstacleDistance;
        
        let avoidanceDirection = unitState?.avoidanceDirection || 0;
        
        if (avoidanceDirection === 0) {
            const perpLeft = { x: -toObstacle.z, z: toObstacle.x };
            const perpRight = { x: toObstacle.z, z: -toObstacle.x };
            
            const leftAlignment = perpLeft.x * desiredDirection.x + perpLeft.z * desiredDirection.z;
            const rightAlignment = perpRight.x * desiredDirection.x + perpRight.z * desiredDirection.z;
            
            avoidanceDirection = leftAlignment > rightAlignment ? 1 : -1;
            
            if (unitState) {
                unitState.avoidanceDirection = avoidanceDirection;
            }
        }
        
        const avoidanceVector = {
            x: -toObstacle.z * avoidanceDirection,
            z: toObstacle.x * avoidanceDirection
        };
        
        const minDistance = unitRadius + obstacle.radius + 10;
        const avoidanceStrength = Math.max(0, (minDistance - obstacleDistance) / minDistance);
        const force = this.OBSTACLE_AVOIDANCE_FORCE * avoidanceStrength;
        
        return {
            x: avoidanceVector.x * force,
            z: avoidanceVector.z * force
        };
    }
    
    calculateDesiredVelocity(entityId, data) {
        const { pos, vel, aiState, isAnchored } = data;

        if (isAnchored || !aiState) {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'waiting' || aiState.state === 'idle') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
            return;
        }
        
        if (aiState.state === 'chasing' && aiState.aiBehavior && (aiState.targetPosition || aiState.target)) {
            this.requestPathIfNeeded(entityId, data);
            
            if (aiState.path && aiState.path.length > 0) {
                this.followPath(entityId, data);
            } else {
                data.desiredVelocity.vx = 0;
                data.desiredVelocity.vy = 0;
                data.desiredVelocity.vz = 0;
            }
        } else if (aiState.state === 'attacking') {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        } else {
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vy = 0;
            data.desiredVelocity.vz = 0;
        }
    }
    
    requestPathIfNeeded(entityId, data) {
        const { pos, aiState } = data;
        const now = this.game.state.now;
        if(!aiState.aiBehavior){
            aiState.aiBehavior = {};
        }
        if (!aiState.aiBehavior.lastPathRequest || (now - aiState.aiBehavior.lastPathRequest) > this.PATH_REREQUEST_INTERVAL) {
            aiState.aiBehavior.lastPathRequest = now;
            
            let targetPos = aiState.targetPosition;
            if (aiState.target) {
                targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
            }
            
            if ((!aiState.path || aiState.path.length == 0) && targetPos) {
                aiState.path = this.game.pathfindingSystem.requestPath(
                    entityId,
                    pos.x,
                    pos.z,
                    targetPos.x,
                    targetPos.z,
                    1
                );
            } 
        }
    }
    
    followPath(entityId, data) {
        const { pos, vel, aiState } = data;
        
        if (aiState.pathIndex === undefined) {
            aiState.pathIndex = 0;
        }
        
        if (aiState.pathIndex >= aiState.path.length) {
            aiState.path = null;
            aiState.pathIndex = 0;
            data.desiredVelocity.vx = 0;
            data.desiredVelocity.vz = 0;
            data.desiredVelocity.vy = 0;
            return;
        }
        
        const waypoint = aiState.path[aiState.pathIndex];
        const dx = waypoint.x - pos.x;
        const dz = waypoint.z - pos.z;
        const distToWaypoint = Math.sqrt(dx * dx + dz * dz);
        
        if (distToWaypoint < this.PATH_REACHED_DISTANCE) {
            aiState.pathIndex++;
            
            if (aiState.pathIndex >= aiState.path.length) {
                aiState.path = null;
                aiState.pathIndex = 0;
            }
            return;
        }
        
        const moveSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED);
        data.desiredVelocity.vx = (dx / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vz = (dz / distToWaypoint) * moveSpeed;
        data.desiredVelocity.vy = 0;
    }
    
    applyUnitMovementWithSmoothing(entityId, data) {
        const { vel, desiredVelocity, separationForce, avoidanceForce, isAnchored } = data;

        if (isAnchored) {
            vel.vx = 0;
            vel.vz = 0;
            vel.vy = desiredVelocity.vy || vel.vy || 0;
            return;
        }
        
        const history = this.movementHistory.get(entityId);
        const isOscillating = this.isUnitOscillating(entityId);
        
        let targetVx = desiredVelocity.vx + separationForce.x + avoidanceForce.x;
        let targetVz = desiredVelocity.vz + separationForce.z + avoidanceForce.z;
        
        if (isOscillating) {
            targetVx = desiredVelocity.vx + (separationForce.x + avoidanceForce.x) * 0.3;
            targetVz = desiredVelocity.vz + (separationForce.z + avoidanceForce.z) * 0.3;
        }
        
        const velocitySmoothing = isOscillating ? this.VELOCITY_SMOOTHING * 0.5 : this.VELOCITY_SMOOTHING;
        const directionSmoothing = isOscillating ? this.DIRECTION_SMOOTHING * 0.3 : this.DIRECTION_SMOOTHING;
        
        const newVx = this.lerp(vel.vx, targetVx, velocitySmoothing);
        const newVz = this.lerp(vel.vz, targetVz, velocitySmoothing);
        
        if (history && history.smoothedDirection) {
            const targetDirection = Math.atan2(targetVz, targetVx);
            
            let currentDirection;
            const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
            
            if (currentSpeed < this.MIN_MOVEMENT_THRESHOLD) {
                const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                currentDirection = facing ? facing.angle : 0;
            } else {
                currentDirection = Math.atan2(vel.vz, vel.vx);
            }
            
            let directionDiff = targetDirection - currentDirection;
            if (directionDiff > Math.PI) directionDiff -= 2 * Math.PI;
            if (directionDiff < -Math.PI) directionDiff += 2 * Math.PI;
            
            if (Math.abs(directionDiff) > this.MIN_DIRECTION_CHANGE) {
                const smoothedDirection = currentDirection + directionDiff * directionSmoothing;
                const speed = Math.sqrt(newVx * newVx + newVz * newVz);
                
                if (speed > 0.1) {
                    vel.vx = Math.cos(smoothedDirection) * speed;
                    vel.vz = Math.sin(smoothedDirection) * speed;
                    
                    const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
                    if (facing) {
                        facing.angle = smoothedDirection;
                    }
                } else {
                    vel.vx = newVx;
                    vel.vz = newVz;
                }
            } else {
                vel.vx = newVx;
                vel.vz = newVz;
            }
        } else {
            vel.vx = newVx;
            vel.vz = newVz;
        }
        
        vel.vy = desiredVelocity.vy;
        
        const speedSqrd = vel.vx * vel.vx + vel.vz * vel.vz;
        if (speedSqrd < this.MIN_MOVEMENT_THRESHOLD * this.MIN_MOVEMENT_THRESHOLD) {
            vel.vx = 0;
            vel.vz = 0;
        }
        
        const maxSpeed = Math.max((vel.maxSpeed || this.DEFAULT_AI_SPEED) * this.AI_SPEED_MULTIPLIER, this.DEFAULT_AI_SPEED) * 1.4;
        const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vz * vel.vz);
        if (currentSpeed > maxSpeed) {
            const speedRatio = maxSpeed / currentSpeed;
            vel.vx *= speedRatio;
            vel.vz *= speedRatio;
        }
    }
    
    lerp(a, b, t) {
        return a + (b - a) * t;
    }
    
    shouldApplyGravity(entityId, projectile, unitType) {
        if (projectile) {
            return true;
        }
        
        if (unitType) {
            const collections = this.game.getCollections && this.game.getCollections();
            if (collections && collections.units) {
                const unitDef = collections.units[unitType.id];
                if (unitDef && unitDef.flying) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    handleGroundInteraction(pos, vel) {
        const terrainHeight = this.getTerrainHeightAtPosition(pos.x, pos.z);
        
        if (terrainHeight !== null) {
            const targetHeight = terrainHeight;   
            pos.y = targetHeight;
            
            if (pos.y <= targetHeight + 0.1) {
                vel.vy = Math.max(0, vel.vy);
            }
        } else {
            if (pos.y < this.GROUND_LEVEL) {
                pos.y = this.GROUND_LEVEL;
                vel.vy = Math.max(0, vel.vy);
            }
        }
    }
    
    getTerrainHeightAtPosition(worldX, worldZ) {
        if (this.game.terrainSystem && this.game.terrainSystem.getTerrainHeightAtPosition) {
            return this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);
        }
        return this.GROUND_LEVEL;
    }
    
    enforceBoundaries(pos, collision) {
        const collections = this.game.getCollections();
        const currentLevel = this.game.state.level;
        const level = collections.levels[currentLevel];        
        const tileMap = level.tileMap;

        const terrainSize = tileMap.size * collections.configs.game.gridSize;
        const halfTerrain = terrainSize / 2;
        const unitRadius = this.getUnitRadius(collision);
        

        pos.x = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.x));
        pos.z = Math.max(-halfTerrain + unitRadius, Math.min(halfTerrain - unitRadius, pos.z));
    }
    
    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }
    
    entityDestroyed(entityId) {
        if (this.spatialGrid) {
            this.spatialGrid.delete(entityId);
        }
        
        if (this.unitStates) {
            this.unitStates.delete(entityId);
        }
        
        if (this.movementTracking) {
            this.movementTracking.delete(entityId);
        }
        
        if (this.movementHistory) {
            this.movementHistory.delete(entityId);
        }
    }

    ping() {
        console.log('pong');
    }
};

// System: CombatAISystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['CombatAISystem'] = class CombatAISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.combatAISystems = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.DEFAULT_UNIT_RADIUS = 25;
        this.ATTACK_RANGE_BUFFER = 10;
        this.ALLY_SPACING_DISTANCE = 10;
        this.ENEMY_SPACING_DISTANCE = 5;
        this.AVOIDANCE_RADIUS_MULTIPLIER = 1;
        this.STRONG_AVOIDANCE_FORCE = 50;
        this.GENTLE_AVOIDANCE_FORCE = 10;

        this.TARGET_SWITCH_COOLDOWN = 0.3;
        this.MOVEMENT_DECISION_INTERVAL = 0.05;

        this.MIN_ATTACK_ANIMATION_TIME = 0.4;
        this.STATE_CHANGE_COOLDOWN = 0.1;

        this.DAMAGE_TIMING_RATIO = 0.5;
        
        this.TARGET_POSITION_THRESHOLD = this.game.getCollections().configs.game.gridSize * 0.5;
        // Debug logging
        this.DEBUG_ENEMY_DETECTION = true; // Set to false to disable debug

    }
            
    update() {
        const CT = this.componentTypes;
        if (this.game.state.phase !== 'battle'){
            const combatUnits = this.game.getEntitiesWith(
               CT.AI_STATE
            );
            for (let i = 0; i < combatUnits.length; i++) {
                const entityId = combatUnits[i];
                const aiState = this.game.getComponent(entityId, CT.AI_STATE);
                if (aiState.state !== 'idle') {
                    this.changeAIState(aiState, 'idle');
                }
                aiState.target = null;
            }
            return;
        }

        const combatUnits = this.game.getEntitiesWith(
            CT.POSITION, CT.COMBAT, CT.TEAM, CT.AI_STATE
        );
        for (let i = 0; i < combatUnits.length; i++) {
            const entityId = combatUnits[i];
            const pos = this.game.getComponent(entityId, CT.POSITION);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const team = this.game.getComponent(entityId, CT.TEAM);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);
            const vel = this.game.getComponent(entityId, CT.VELOCITY);
            const collision = this.game.getComponent(entityId, CT.COLLISION);

            if (!pos || !vel || !combat || !team || !aiState){
                 continue;
            }
            if (!aiState.aiBehavior) {
                aiState.aiBehavior = {
                    lastDecisionTime: 0,
                    targetLockTime: 0,
                    lastStateChange: 0,
                    lastAttackStart: 0
                };
            }
            const aiBehavior = aiState.aiBehavior;

            // DEBUG: Log combat range and position

            const enemiesInRange = this.getAllEnemiesInRange(entityId, team, combat) || [];
            
            // DEBUG: Log enemies found
            if (aiState.target) {
                const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
                if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                    aiState.target = null;
                }
            }
            if(aiState.targetPosition){
                const distance = Math.sqrt(
                    Math.pow( aiState.targetPosition.x - pos.x, 2) + 
                    Math.pow( aiState.targetPosition.z - pos.z, 2)
                );
                aiState.targetDistance = distance;
            } else {
                aiState.targetDistance = 0;
            }
            if (enemiesInRange.length === 0) {
                if(aiState.targetPosition){
                    if(aiState.targetDistance > this.TARGET_POSITION_THRESHOLD && !vel.anchored){
                        if(aiState.state !== 'chasing'){
                            this.changeAIState(aiState, 'chasing');
                        }
                    } else {
                        if (aiState.state !== 'idle') {
                            this.changeAIState(aiState, 'idle');
                        }
                    }
                }   
            }

            if (aiBehavior.nextMoveTime == null) aiBehavior.nextMoveTime = 0;
            const shouldMakeDecision = true;//(this.game.state.now >= aiBehavior.nextMoveTime);
            
            if (shouldMakeDecision && aiState.state !== 'waiting') {
                aiBehavior.nextMoveTime = this.game.state.now + this.MOVEMENT_DECISION_INTERVAL;
                this.makeAIDecision(entityId, pos, combat, team, aiState, enemiesInRange, collision);
                aiBehavior.lastDecisionTime = this.game.state.now;
            }

            this.handleCombat(entityId, pos, combat, aiState, collision);
        }
    }

    getAllEnemiesInRange(entityId, team, combat) {
        const allUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const visionRange = combat.visionRange;
        
        return allUnits.filter(otherId => {
            if (otherId === entityId) return false;
            
            const otherTeam = this.game.getComponent(otherId, this.componentTypes.TEAM);
            const otherHealth = this.game.getComponent(otherId, this.componentTypes.HEALTH);
            const otherDeathState = this.game.getComponent(otherId, this.componentTypes.DEATH_STATE);
            const otherPos = this.game.getComponent(otherId, this.componentTypes.POSITION);
            
            if (!otherTeam || otherTeam.team === team.team) return false;
            if (!otherHealth || otherHealth.current <= 0) return false;
            if (otherDeathState && otherDeathState.isDying) return false;
            if (!otherPos) return false;
            
            return this.isInVisionRange(entityId, otherId, visionRange);                   
        });
    }


    changeAIState(aiState, newState) {
      
        const aiBehavior = aiState.aiBehavior;
        if (this.game.state.now - aiBehavior.lastStateChange < this.STATE_CHANGE_COOLDOWN) return false;
        if (aiState.state === 'attacking') {
            const attackDuration = this.game.state.now - aiBehavior.lastAttackStart;
            if (attackDuration < this.MIN_ATTACK_ANIMATION_TIME) return false;
        }
        if (aiState.state !== newState) {
            aiState.state = newState;
            aiBehavior.lastStateChange = this.game.state.now;
            if (newState === 'attacking') aiBehavior.lastAttackStart = this.game.state.now;
            return true;
        }
        return false;
    }

    makeAIDecision(entityId, pos, combat, team, aiState, enemiesInRange, collision) {
        const aiBehavior = aiState.aiBehavior;
        
        // CHANGED: Always try to find the best target from ALL enemies
        let targetEnemy = this.findBestTarget(entityId, pos, combat.range, enemiesInRange, aiState);
        
        if (!targetEnemy) {
            aiState.target = null;
            //console.log('set current target null 4');
            return;
        }
        
        const targetHealth = this.game.getComponent(targetEnemy, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetEnemy, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            console.log('set current target null 5');
            return;
        }
        
        const enemyPos = this.game.getComponent(targetEnemy, this.componentTypes.POSITION);
        if (!enemyPos) return;
        
        // Set the target
        aiState.target = targetEnemy;
        //aiState.targetPosition = { x: enemyPos.x, y: enemyPos.y, z: enemyPos.z };
        if (this.isInAttackRange(entityId, targetEnemy, combat)) {
            // Check if this is a spell caster and if abilities are available
   
            this.changeAIState(aiState, 'attacking');
        } else {
            if(aiState.state !== 'chasing'){
                this.changeAIState(aiState, 'chasing');
            }
        }
    }

    findBestTarget(entityId, pos, range, enemiesInRange, aiState) {
        const aiBehavior = aiState.aiBehavior;
        let bestTarget = null;
        let bestScore = -Infinity;
        
        // If unit is currently attacking, stick with current target unless switching would be much better
        if (aiState.target && enemiesInRange.includes(aiState.target)) {
            const currentTargetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
            const currentTargetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
            const currentTargetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);

            const isCurrentTargetValid = currentTargetHealth && 
                                       currentTargetHealth.current > 0 && 
                                       (!currentTargetDeathState || !currentTargetDeathState.isDying) &&
                                       currentTargetPos;
            
            if (isCurrentTargetValid) {
                // Calculate current target score
                const currentDistance = Math.sqrt(
                    Math.pow(currentTargetPos.x - pos.x, 2) + 
                    Math.pow(currentTargetPos.z - pos.z, 2)
                );
                const currentHealthRatio = currentTargetHealth.current / (currentTargetHealth.max || currentTargetHealth.current);
                const currentScore = this.calculateTargetScore(currentDistance, currentHealthRatio, true);
                
                // Only switch if we find a significantly better target
                bestScore = currentScore * 1.2; // 20% bonus for current target (sticky targeting)
                bestTarget = aiState.target;
            }
        }
        
        // Evaluate all enemies to find the best target
        enemiesInRange.forEach(enemyId => {
            const enemyPos = this.game.getComponent(enemyId, this.componentTypes.POSITION);
            const enemyHealth = this.game.getComponent(enemyId, this.componentTypes.HEALTH);
            const enemyDeathState = this.game.getComponent(enemyId, this.componentTypes.DEATH_STATE);
            
            if (!enemyPos || !enemyHealth || enemyHealth.current <= 0) return;
            if (enemyDeathState && enemyDeathState.isDying) return;
            
            const distance = Math.sqrt(
                Math.pow(enemyPos.x - pos.x, 2) + 
                Math.pow(enemyPos.z - pos.z, 2)
            );

            const healthRatio = enemyHealth.current / (enemyHealth.max || enemyHealth.current);
            const isCurrentTarget = (enemyId === aiState.target);
            
            const score = this.calculateTargetScore(distance, healthRatio, isCurrentTarget);
            
            if (score > bestScore) {
                bestScore = score;
                bestTarget = enemyId;
            }
            
        });
        
        if (bestTarget !== aiState.target) {
            aiBehavior.targetLockTime = this.game.state.now;
        }
        
        return bestTarget;
    }

    calculateTargetScore(distance, healthRatio, isCurrentTarget) {
        let score = 0;
        
        // Distance factor - closer is better, but not overwhelmingly so
        // Use logarithmic scaling so very far enemies are still viable
        const maxDistance = 20000; // Assume max battlefield size
        const distanceFactor = Math.max(0, (maxDistance - distance) / maxDistance);
        score += distanceFactor * 100;    

        
        // Current target bonus for stability
        if (isCurrentTarget) {
            score += 50000;
        }
        
        
        return score;
    }

    handleCombat(entityId, pos, combat, aiState, collision) {
        const aiBehavior = aiState.aiBehavior;
        if (!aiState.target || aiState.state !== 'attacking'){
           // console.log('no target or not attacking', aiState);
            return;
        }
        
        const targetPos = this.game.getComponent(aiState.target, this.componentTypes.POSITION);
        const targetHealth = this.game.getComponent(aiState.target, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(aiState.target, this.componentTypes.DEATH_STATE);
        
        if (!targetPos || !targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
            aiState.target = null;
            console.log('set current target null 6');
            return;
        }
        
        if (!this.isInAttackRange(entityId, aiState.target, combat, 5)) {
            this.changeAIState(aiState, 'chasing');
            console.log('not in attack range');
            return;
        }
        
        // Handle melee units with damage > 0
        if (combat.damage > 0) {
            const effectiveAttackSpeed = this.getEffectiveAttackSpeed(entityId, combat.attackSpeed);
            if ((this.game.state.now - combat.lastAttack) >= 1 / effectiveAttackSpeed) {
                this.initiateAttack(entityId, aiState.target, combat);
                combat.lastAttack = this.game.state.now;
                aiBehavior.lastAttackStart = this.game.state.now;
            }
        }           
    }
    
    initiateAttack(attackerId, targetId, combat) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);
        if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) return;
        
        if (this.game.animationSystem) {
            const animationSpeed = this.calculateAnimationSpeed(attackerId, combat.attackSpeed);
            const minAnimationTime = 1 / combat.attackSpeed * 0.8; // 80% of attack interval
            this.game.animationSystem.triggerSinglePlayAnimation(attackerId, 'attack', animationSpeed, minAnimationTime);
        }
        
        if (combat.projectile && this.game.projectileSystem) {
            this.scheduleProjectileLaunch(attackerId, targetId, combat);
        } else {
            this.scheduleMeleeDamage(attackerId, targetId, combat);
        }
    }

    calculateAnimationSpeed(attackerId, animationSpeed) {
        const attackInterval = 1 / animationSpeed;
        
        // Default fallback duration
        let baseAnimationDuration = 0.8;
        
        if (this.game.animationSystem) {
            // NEW: Get duration from VAT bundle instead of mixer actions
            const CT = this.componentTypes;
            const renderable = this.game.getComponent(attackerId, CT.RENDERABLE);
            
            if (renderable) {
                const batchInfo = this.game.renderSystem?.getBatchInfo(
                    renderable.objectType, 
                    renderable.spawnType
                );
                
                if (batchInfo) {
                    const bundle = this.game.modelManager?.getVATBundle(
                        renderable.objectType, 
                        renderable.spawnType
                    );
                    
                    if (bundle?.meta?.clips) {
                        // Find attack clip duration
                        const attackClip = bundle.meta.clips.find(clip => 
                            clip.name === 'attack' || clip.name === 'combat' || clip.name === 'fight'
                        );
                        if (attackClip) {
                            baseAnimationDuration = attackClip.duration;
                        }
                    }
                }
            }
            
            // OLD SYSTEM COMPATIBILITY (remove this once VAT is working):
            // Keep this as fallback in case you need it temporarily
            if (this.game.animationSystem.entityAnimations) {
                const animationActions = this.game.animationSystem.entityAnimations.get(attackerId);
                if (animationActions && animationActions.attack) {
                    const attackAction = animationActions.attack;
                    if (attackAction.getClip) {
                        baseAnimationDuration = attackAction.getClip().duration;
                    }
                }
            }
        }
        
        // Calculate speed to fit animation into attack interval
        const targetAnimationDuration = Math.max(attackInterval * 0.9, 0.2);
        let resultSpeed = baseAnimationDuration / targetAnimationDuration;
        
        return resultSpeed;
    }

    scheduleMeleeDamage(attackerId, targetId, combat) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot schedule melee damage');
            return;
        }

        const attackInterval = 1 / combat.attackSpeed;
        const damageDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
    
        const element = this.getDamageElement(attackerId, combat);
        
        this.game.damageSystem.scheduleDamage(
            attackerId, 
            targetId, 
            combat.damage, 
            element, 
            damageDelay,
            {
                isMelee: true,
                weaponRange: combat.range + this.ATTACK_RANGE_BUFFER + 1
            }
        );
    }

    scheduleProjectileLaunch(attackerId, targetId, combat) {
        const attackInterval = 1 / combat.attackSpeed;
        const launchDelay = attackInterval * this.DAMAGE_TIMING_RATIO;
        
        // Clean generic scheduling
        this.game.schedulingSystem.scheduleAction(() => {
            this.fireProjectileAttack(attackerId, targetId, combat.projectile);
        }, launchDelay, attackerId);
    }

    fireProjectileAttack(attackerId, targetId, projectileTypeId) {
        if (!this.game.projectileSystem) return;
        const projectileData = this.game.getCollections().projectiles[projectileTypeId];
        if (!projectileData) return;
        this.game.projectileSystem.fireProjectile(attackerId, targetId, {
            id: projectileTypeId,
            ...projectileData
        });
    }

    getDamageElement(entityId, combat) {
        if (combat.element) {
            return combat.element;
        }
        
        const weaponElement = this.getWeaponElement(entityId);
        if (weaponElement) {
            return weaponElement;
        }
        
        return this.game.damageSystem?.ELEMENT_TYPES?.PHYSICAL || 'physical';
    }

    getWeaponElement(entityId) {
        if (!this.game.equipmentSystem) return null;
        
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (!equipment) return null;
        
        const mainHandItem = equipment.slots.mainHand;
        if (mainHandItem) {
            const itemData = this.game.equipmentSystem.getItemData(mainHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }
        
        const offHandItem = equipment.slots.offHand;
        if (offHandItem) {
            const itemData = this.game.equipmentSystem.getItemData(offHandItem);
            if (itemData && itemData.stats && itemData.stats.element) {
                return itemData.stats.element;
            }
        }
        
        return null;
    }

    calculateDistances(pos1, pos2, collision1, collision2) {
        const dx = pos2.x - pos1.x;
        const dz = pos2.z - pos1.z;
        const centerToCenterDistance = Math.sqrt(dx * dx + dz * dz);
        const radius1 = this.getUnitRadius(collision1);
        const radius2 = this.getUnitRadius(collision2);
        const edgeToEdgeDistance = Math.max(0, centerToCenterDistance - radius1 - radius2);
        const distanceToTargetEdge = Math.max(0, centerToCenterDistance - radius2);
        return {
            centerToCenter: centerToCenterDistance,
            edgeToEdge: edgeToEdgeDistance,
            attackerCenterToTargetEdge: distanceToTargetEdge,
            attackerRadius: radius1,
            targetRadius: radius2
        };
    }

    isInAttackRange(attackerId, targetId, combat, extraBuffer = 0) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;

        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        const effectiveRange = combat.range + this.ATTACK_RANGE_BUFFER + extraBuffer;
        return distances.attackerCenterToTargetEdge <= effectiveRange;
    }

    isInVisionRange(viewerId, targetId, visionRange) {
        const viewerPos = this.game.getComponent(viewerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const viewerCollision = this.game.getComponent(viewerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!viewerPos || !targetPos) return false;

        const distances = this.calculateDistances(viewerPos, targetPos, viewerCollision, targetCollision);
        return distances.attackerCenterToTargetEdge <= visionRange;
    }

    isWithinEdgeToEdgeRange(attackerId, targetId, maxRange) {
        const attackerPos = this.game.getComponent(attackerId, this.componentTypes.POSITION);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        const attackerCollision = this.game.getComponent(attackerId, this.componentTypes.COLLISION);
        const targetCollision = this.game.getComponent(targetId, this.componentTypes.COLLISION);
        if (!attackerPos || !targetPos) return false;
        const distances = this.calculateDistances(attackerPos, targetPos, attackerCollision, targetCollision);
        return distances.edgeToEdge <= maxRange;
    }

    getUnitRadius(collision) {
        if (collision && collision.radius) {
            return Math.max(this.DEFAULT_UNIT_RADIUS, collision.radius);
        }
        return this.DEFAULT_UNIT_RADIUS;
    }

    startDeathProcess(entityId) {

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        const existingDeathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
        if (existingDeathState && existingDeathState.isDying) return;
        
        if (this.game.damageSystem) {
            this.game.damageSystem.clearAllStatusEffects(entityId);
        }
        
        this.game.addComponent(entityId, ComponentTypes.DEATH_STATE, Components.DeathState(true, this.game.state.now, 2.0));
        if (this.game.hasComponent(entityId, ComponentTypes.AI_STATE)) {
            this.game.removeComponent(entityId, ComponentTypes.AI_STATE);
        }
        const velocity = this.game.getComponent(entityId, ComponentTypes.VELOCITY);
        if (velocity) { velocity.x = 0; velocity.y = 0; velocity.z = 0; }
        
        if (this.game.hasComponent(entityId, ComponentTypes.COMBAT)) {
            this.game.removeComponent(entityId, ComponentTypes.COMBAT);
        }
        
        if (this.game.animationSystem && this.game.animationSystem.playDeathAnimation) {
            this.game.animationSystem.playDeathAnimation(entityId);
        }
        if(this.game.abilitySystem){
            this.game.abilitySystem.removeEntityAbilities(entityId);
        }
    }
    
    applyDamage(sourceId, targetId, damage, element, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply damage');
            return { damage: 0, prevented: true, reason: 'no_damage_system' };
        }
                
        return this.game.damageSystem.applyDamage(sourceId, targetId, damage, element, options);
    }

    applySplashDamage(sourceId, centerPos, damage, element, radius, options = {}) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot apply splash damage');
            return [];
        }
        
        return this.game.damageSystem.applySplashDamage(sourceId, centerPos, damage, element, radius, options);
    }

    curePoison(targetId, stacksToRemove = null) {
        if (!this.game.damageSystem) {
            console.warn('DamageSystem not found, cannot cure poison');
            return false;
        }
        
        return this.game.damageSystem.curePoison(targetId, stacksToRemove);
    }

    getPoisonStacks(entityId) {
        if (!this.game.damageSystem) {
            return 0;
        }
        
        return this.game.damageSystem.getPoisonStacks(entityId);
    }

    getEffectiveAttackSpeed(entityId, baseAttackSpeed) {
        // Get attack speed modifiers from buffs
        if (!this.game.damageSystem || !this.game.damageSystem.getAttackerModifiers) {
            return baseAttackSpeed;
        }
        
        const attackerMods = this.game.damageSystem.getAttackerModifiers(entityId);
        return baseAttackSpeed * (attackerMods.attackSpeedMultiplier || 1.0);
    }

    getStatusEffects(entityId) {
        if (!this.game.damageSystem) {
            return { poison: [] };
        }
        
        return this.game.damageSystem.getStatusEffects(entityId);
    }

    setRetaliatoryTarget(entityId, attackerId) {
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (!aiState) return;
        
        if (aiState.target) return;
        
        const attackerHealth = this.game.getComponent(attackerId, this.componentTypes.HEALTH);
        const attackerDeathState = this.game.getComponent(attackerId, this.componentTypes.DEATH_STATE);
        if (!attackerHealth || attackerHealth.current <= 0) return;
        if (attackerDeathState && attackerDeathState.isDying) return;
        
        const attackerTeam = this.game.getComponent(attackerId, this.componentTypes.TEAM);
        const defenderTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        if (attackerTeam && defenderTeam && attackerTeam.team === defenderTeam.team) return;
        
        aiState.target = attackerId;
    }

    debugStatusEffects() {
        if (!this.game.damageSystem) {
            return;
        }
        
        this.game.damageSystem.debugStatusEffects();
    }
};

// System: ProjectileSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ProjectileSystem'] = class ProjectileSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.projectileSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Configuration
        this.HIT_DETECTION_RADIUS = 24;
        this.TRAIL_UPDATE_INTERVAL = 0.05;
        
        // Ballistic configuration
        this.DEFAULT_LAUNCH_ANGLE = Math.PI / 4; // 45 degrees
        this.MIN_LAUNCH_ANGLE = Math.PI / 6; // 30 degrees
        this.MAX_LAUNCH_ANGLE = Math.PI / 3; // 60 degrees
        this.BALLISTIC_HEIGHT_MULTIPLIER = 0.3; // How high the arc goes relative to distance
        this.PROJECTILE_LIFETIME = 200;
        
        // Ground impact detection
        this.GROUND_IMPACT_THRESHOLD = 0; // Distance from ground to trigger impact
        
        // Trail tracking for visual effects
        this.projectileTrails = new Map();
        
        // Get gravity from movement system
        this.GRAVITY = this.game.movementSystem?.GRAVITY;
    }
    
    // Deterministic rounding helper
    roundForDeterminism(value, precision = 6) {
        return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision);
    }
    
    fireProjectile(sourceId, targetId, projectileData = {}) {
        const sourcePos = this.game.getComponent(sourceId, this.componentTypes.POSITION);
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        const targetPos = this.game.getComponent(targetId, this.componentTypes.POSITION);
        
        if (!sourcePos || !sourceCombat || !targetPos) return null;
        
        // Create projectile entity
        const projectileId = this.game.createEntity();
        const components = this.game.componentManager.getComponents();
        
        // Determine projectile element (from weapon, combat component, or projectile data)
        const projectileElement = this.determineProjectileElement(sourceId, projectileData);
        
        // Pass source ID to trajectory calculation for ballistic projectiles
        const projectileDataWithSource = { ...projectileData, sourceId: sourceId };
        
        // Calculate trajectory based on projectile type
        const trajectory = this.calculateTrajectory(sourcePos, targetPos, projectileDataWithSource);
        
        // Determine spawn height - ballistic projectiles start above ground to avoid immediate impact
        const spawnHeight = Math.max(sourcePos.y + 20, 20);           
        
        // Add components with full 3D support
        this.game.addComponent(projectileId, this.componentTypes.POSITION, 
            components.Position(sourcePos.x, spawnHeight, sourcePos.z));
        
        this.game.addComponent(projectileId, this.componentTypes.VELOCITY, 
            components.Velocity(trajectory.vx, trajectory.vy, trajectory.vz, projectileData.speed, projectileData.ballistic || false));
        
         // Enhanced projectile component with element
        this.game.addComponent(projectileId, this.componentTypes.PROJECTILE, {
            damage: sourceCombat.damage,
            speed: projectileData.speed,
            range: sourceCombat.range * 1.5,
            target: targetId,
            source: sourceId,
            startTime: this.game.state.now,
            startX: sourcePos.x,
            startY: spawnHeight,
            startZ: sourcePos.z,
            isBallistic: projectileData.ballistic || false,
            targetX: targetPos.x,
            targetY: targetPos.y + 20,
            targetZ: targetPos.z,
            launchAngle: trajectory.launchAngle,
            timeToTarget: trajectory.timeToTarget,
            weaponRange: trajectory.weaponRange || sourceCombat.range,
            element: projectileElement
        });

        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        // Add UNIT_TYPE component for projectiles
        this.game.addComponent(projectileId, this.componentTypes.UNIT_TYPE, 
            components.UnitType(projectileData.id, projectileData.title, 0));
        
        // Add TEAM component (same team as source)
        if (sourceTeam) {
            this.game.addComponent(projectileId, this.componentTypes.TEAM, 
                components.Team(sourceTeam.team));
        }

        // Visual component        
        this.game.addComponent(projectileId, this.componentTypes.RENDERABLE, 
            components.Renderable("projectiles", projectileData.id));
        
        // Use LifetimeSystem instead of direct component
        if (this.game.lifetimeSystem) {
            this.game.lifetimeSystem.addLifetime(projectileId, this.PROJECTILE_LIFETIME, {
                fadeOutDuration: 1.0, // Fade out in last second
                onDestroy: (entityId) => {
                    // Custom cleanup for projectiles
                    this.cleanupProjectileData(entityId);
                }
            });
        } else {
            // Fallback to old method if LifetimeSystem not available
            this.game.addComponent(projectileId, this.componentTypes.LIFETIME, 
                components.Lifetime(this.PROJECTILE_LIFETIME, this.game.state.now));
        }
        
        // Homing component if specified
        if (projectileData.homing && projectileData.homingStrength > 0) {
            const homingStrength = projectileData.ballistic ? 
                projectileData.homingStrength * 0.3 : projectileData.homingStrength;
            this.game.addComponent(projectileId, this.componentTypes.HOMING_TARGET, 
                components.HomingTarget(targetId, homingStrength, { x: targetPos.x, y: targetPos.y, z: targetPos.z }));
        }
        
        return projectileId;
    }
    
    cleanupProjectileData(projectileId) {
        // Clean up trail data
        this.projectileTrails.delete(projectileId);
    }

    /**
     * Determine the element of a projectile based on various sources
     */
    determineProjectileElement(sourceId, projectileData) {
        // Priority order: projectile data > weapon element > combat element > default physical
        
        // 1. Check projectile data for explicit element
        if (projectileData.element) {
            return projectileData.element;
        }
        
        // 2. Check combat component element
        const sourceCombat = this.game.getComponent(sourceId, this.componentTypes.COMBAT);
        if (sourceCombat && sourceCombat.element) {
            return sourceCombat.element;
        }
        
        // 3. Default to physical
        return this.game.damageSystem?.ELEMENT_TYPES?.PHYSICAL || 'physical';
    }

    calculateTrajectory(sourcePos, targetPos, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        const projectileSpeed = projectileData.speed;
        
        // For ballistic projectiles, calculate arc trajectory based on weapon range
        if (projectileData.ballistic) {
            return this.calculateBallisticTrajectory(sourcePos, targetPos, projectileSpeed, projectileData);
        } else {
            // Direct trajectory for non-ballistic projectiles
            const totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (totalDistance === 0) {
                return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
            }
            
            const initialVx = (dx / totalDistance) * projectileSpeed;
            const initialVy = (dy / totalDistance) * projectileSpeed;
            const initialVz = (dz / totalDistance) * projectileSpeed;
            
            return {
                vx: this.roundForDeterminism(initialVx),
                vy: this.roundForDeterminism(initialVy),
                vz: this.roundForDeterminism(initialVz),
                launchAngle: this.roundForDeterminism(Math.atan2(Math.sqrt(dx * dx + dz * dz), dy)),
                timeToTarget: this.roundForDeterminism(totalDistance / projectileSpeed)
            };
        }
    }
    
    calculateBallisticTrajectory(sourcePos, targetPos, speed, projectileData) {
        const dx = targetPos.x - sourcePos.x;
        const dy = targetPos.y - sourcePos.y; // Height difference
        const dz = targetPos.z - sourcePos.z; // Forward/backward distance
        
        const horizontalDistance = Math.sqrt(dx * dx + dz * dz);
        
        if (horizontalDistance === 0) {
            return { vx: 0, vy: 0, vz: 0, launchAngle: 0, timeToTarget: 0 };
        }
        
        // Get the firing unit's combat range to determine proper ballistic trajectory
        const sourceId = projectileData.sourceId;
        const sourceCombat = sourceId ? this.game.getComponent(sourceId, this.componentTypes.COMBAT) : null;
        const weaponRange = sourceCombat ? sourceCombat.range : horizontalDistance;
        
        // Use 45-degree angle for optimal range (gives maximum distance for given initial velocity)
        const launchAngle = Math.PI / 4; // 45 degrees
        const g = this.GRAVITY;
        
        // Calculate the initial velocity needed to reach the weapon's maximum range at 45 degrees
        const optimalInitialVelocity = Math.sqrt(weaponRange * g);
        
        // Calculate what range this velocity would achieve at our target distance
        const actualRange = Math.min(horizontalDistance, weaponRange);
        
        // If target is within range, calculate trajectory to hit it exactly
        let initialVelocity;
        let actualLaunchAngle = launchAngle;
        
        if (horizontalDistance <= weaponRange) {
            // Target is within range - calculate exact trajectory
            const maxRangeAtOptimalVelocity = (optimalInitialVelocity * optimalInitialVelocity) / g;
            
            if (horizontalDistance <= maxRangeAtOptimalVelocity) {
                // We can reach this distance with our optimal velocity
                initialVelocity = optimalInitialVelocity;
                // Calculate the required angle: sin(2θ) = (range * g) / v₀²
                const sin2Theta = (horizontalDistance * g) / (initialVelocity * initialVelocity);
                
                // We want the lower trajectory angle (there are two solutions)
                const angle2Theta = Math.asin(Math.min(1, sin2Theta));
                actualLaunchAngle = angle2Theta / 2;
                
                // Prefer angles between 15° and 75° for realistic artillery
                if (actualLaunchAngle < Math.PI / 12) { // Less than 15°
                    actualLaunchAngle = Math.PI / 12;
                } else if (actualLaunchAngle > 5 * Math.PI / 12) { // More than 75°
                    actualLaunchAngle = 5 * Math.PI / 12;
                }
            } else {
                // Use 45° and calculate required velocity for this specific distance
                actualLaunchAngle = Math.PI / 4;
                initialVelocity = Math.sqrt(horizontalDistance * g);
            }
        } else {
            // Target is beyond weapon range - fire at maximum range in target direction
            initialVelocity = optimalInitialVelocity;
            actualLaunchAngle = Math.PI / 4; // 45° for maximum range
        }
        
        // Calculate time of flight
        const timeToTarget = (2 * initialVelocity * Math.sin(actualLaunchAngle)) / g;
        
        // Calculate horizontal direction unit vector
        const horizontalDirectionX = dx / horizontalDistance;
        const horizontalDirectionZ = dz / horizontalDistance;
        
        // Calculate initial velocity components
        const horizontalVelocity = initialVelocity * Math.cos(actualLaunchAngle);
        const vx = horizontalDirectionX * horizontalVelocity;
        const vz = horizontalDirectionZ * horizontalVelocity;
        const vy = initialVelocity * Math.sin(actualLaunchAngle); // Initial upward velocity
        
        // Adjust for height difference if target is at different elevation
        if (Math.abs(dy) > 5) { // Only adjust for significant height differences
            const heightAdjustment = dy / timeToTarget;
            const adjustedVy = vy + heightAdjustment;
            
            return {
                vx: this.roundForDeterminism(vx),
                vy: this.roundForDeterminism(adjustedVy),
                vz: this.roundForDeterminism(vz),
                launchAngle: this.roundForDeterminism(actualLaunchAngle),
                timeToTarget: this.roundForDeterminism(timeToTarget),
                weaponRange: this.roundForDeterminism(weaponRange),
                calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
            };
        }
        
        return {
            vx: this.roundForDeterminism(vx),
            vy: this.roundForDeterminism(vy),
            vz: this.roundForDeterminism(vz),
            launchAngle: this.roundForDeterminism(actualLaunchAngle),
            timeToTarget: this.roundForDeterminism(timeToTarget),
            weaponRange: this.roundForDeterminism(weaponRange),
            calculatedRange: this.roundForDeterminism((initialVelocity * initialVelocity * Math.sin(2 * actualLaunchAngle)) / g)
        };
    }
    
    update() {
        if (this.game.state.phase !== 'battle') return;
        
        const projectiles = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.VELOCITY, 
            this.componentTypes.PROJECTILE
        );        
        projectiles.forEach(projectileId => {
            const pos = this.game.getComponent(projectileId, this.componentTypes.POSITION);
            const vel = this.game.getComponent(projectileId, this.componentTypes.VELOCITY);
            const projectile = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE);
            const homing = this.game.getComponent(projectileId, this.componentTypes.HOMING_TARGET);
                        
            // Update homing behavior
            if (homing && homing.targetId && projectile.isBallistic) {
                this.updateBallisticHoming(projectileId, pos, vel, projectile, homing);
            } else if (homing && homing.targetId) {
                this.updateHomingProjectile(projectileId, pos, vel, projectile, homing);
            }
            
            // Handle different collision types based on projectile type
            if (projectile.isBallistic) {
                // Ballistic projectiles ONLY check for ground impact
                this.handleProjectileGroundImpact(projectileId, pos, projectile);
            } else {
                // Non-ballistic projectiles check for direct unit hits
                this.checkProjectileCollisions(projectileId, pos, projectile);
            }
            
            // Update visual trail
            this.updateProjectileTrail(projectileId, pos);
        });
    }
    
    updateBallisticHoming(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // For ballistic projectiles, we adjust the trajectory mid-flight
            // Calculate time elapsed since launch
            const timeElapsed = this.game.state.now - projectile.startTime;
            const remainingTime = Math.max(0.1, projectile.timeToTarget - timeElapsed);
            
            // Calculate where we need to be to hit the moving target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            
            // Adjust horizontal velocity to reach new target position
            const requiredHorizontalVelX = dx / remainingTime;
            const requiredHorizontalVelZ = dz / remainingTime;
            
            // Apply homing adjustment with strength factor
            const homingStrength = homing.homingStrength * this.game.state.deltaTime * 2; // Reduced for ballistic
            vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + requiredHorizontalVelX * homingStrength);
            vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + requiredHorizontalVelZ * homingStrength);
            
            // For vertical homing, we need to be more careful to maintain ballistic arc
            // Only adjust if we're in the descending phase
            if (vel.vy < 0) { // Falling down
                const requiredVerticalVel = (dy + 0.5 * this.GRAVITY * remainingTime * remainingTime) / remainingTime;
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength * 0.5) + requiredVerticalVel * (homingStrength * 0.5));
            }
        } else if (homing.lastKnownPosition) {
            // Target is gone, continue toward last known position
            const dx = homing.lastKnownPosition.x - pos.x;
            const dy = homing.lastKnownPosition.y - pos.y;
            const dz = homing.lastKnownPosition.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance < 20) {
                // Close enough to last known position, destroy projectile
                this.destroyProjectile(projectileId);
                return;
            }
        }
    }
    
    updateHomingProjectile(projectileId, pos, vel, projectile, homing) {
        // Get current target position
        const targetPos = this.game.getComponent(homing.targetId, this.componentTypes.POSITION);
        
        if (targetPos) {
            // Update last known position
            homing.lastKnownPosition = { x: targetPos.x, y: targetPos.y, z: targetPos.z };
            
            // Calculate direction to target
            const dx = targetPos.x - pos.x;
            const dy = targetPos.y - pos.y;
            const dz = targetPos.z - pos.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            if (distance > 0) {
                // Calculate desired velocity direction
                const desiredVx = (dx / distance) * projectile.speed;
                const desiredVy = (dy / distance) * projectile.speed;
                const desiredVz = (dz / distance) * projectile.speed;
                
                // Blend current velocity with desired velocity based on homing strength
                const homingStrength = homing.homingStrength * this.game.state.deltaTime * 5; // Adjust responsiveness
                vel.vx = this.roundForDeterminism(vel.vx * (1 - homingStrength) + desiredVx * homingStrength);
                vel.vy = this.roundForDeterminism(vel.vy * (1 - homingStrength) + desiredVy * homingStrength);
                vel.vz = this.roundForDeterminism(vel.vz * (1 - homingStrength) + desiredVz * homingStrength);
                
                // Maintain speed
                const currentSpeed = Math.sqrt(vel.vx * vel.vx + vel.vy * vel.vy + vel.vz * vel.vz);
                if (currentSpeed > 0) {
                    const speedRatio = projectile.speed / currentSpeed;
                    vel.vx = this.roundForDeterminism(vel.vx * speedRatio);
                    vel.vy = this.roundForDeterminism(vel.vy * speedRatio);
                    vel.vz = this.roundForDeterminism(vel.vz * speedRatio);
                }
            }
        } else {
            homing.targetId = null;
        }
    }
    
    checkProjectileCollisions(projectileId, pos, projectile) {
        // Only for NON-ballistic projectiles
        if (projectile.isBallistic) return; // Skip collision check for ballistic
        
        // Get all potential targets
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        );
        
        const sourceTeam = this.game.getComponent(projectile.source, this.componentTypes.TEAM);
        if (!sourceTeam) return;
        
        let hitDetected = false;

        for (const entityId of allEntities) {
            if (hitDetected) break; // Stop after first hit to ensure consistency
            if (entityId === projectile.source) continue; // Don't hit the source
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            const entityHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            
            if (!entityPos || !entityTeam || !entityHealth) continue;
            if (entityTeam.team === sourceTeam.team) continue; // Don't hit allies
            
            // Calculate 3D distance with consistent precision
            const dx = Math.round((entityPos.x - pos.x) * 1000) / 1000;
            const dy = Math.round((entityPos.y - pos.y) * 1000) / 1000;
            const dz = Math.round((entityPos.z - pos.z) * 1000) / 1000;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
            
            // Get entity radius for collision detection
            const entityUnitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const entityRadius = this.getUnitRadius(entityUnitType);

            // Check collision for direct hit
            if (distance <= entityRadius + this.HIT_DETECTION_RADIUS) {
                // Direct hit detected!
                this.handleProjectileHit(projectileId, entityId, entityPos, projectile);
                hitDetected = true;
                break;
            }
        }
    }
    
    handleProjectileGroundImpact(entityId, pos, projectile) {
        // Only for ballistic projectiles
        if (!projectile.isBallistic) return;
        
        // Get actual terrain height for projectile impact
        const terrainHeight = this.game.worldSystem.getTerrainHeightAtPosition(pos.x, pos.z);
        const actualGroundLevel = terrainHeight !== null ? terrainHeight : this.game.movementSystem?.GROUND_LEVEL || 0;
        
        // Check if projectile hit the ground
        if (pos.y <= actualGroundLevel + this.GROUND_IMPACT_THRESHOLD) {
            // Ballistic projectiles explode on ground impact
            this.triggerBallisticExplosion(entityId, pos, projectile, actualGroundLevel);
            return;
        }
    }

    handleProjectileHit(projectileId, targetId, targetPos, projectile) {
        if (this.game.damageSystem) {
            const damage = projectile.damage;
            const element = projectile.element || this.game.damageSystem.ELEMENT_TYPES.PHYSICAL;
            
            this.game.damageSystem.applyDamage(projectile.source, targetId, damage, element, {
                isProjectile: true,
                projectileId: projectileId
            });
            
            this.createHitEffect(projectileId, targetId, targetPos, element, false);
        }
        
        
        this.destroyProjectile(projectileId);
    }

    triggerBallisticExplosion(entityId, pos, projectile, groundLevel) {
        this.createGroundExplosion(entityId, pos, projectile, groundLevel);
        
        if (this.game.damageSystem) {
            const splashRadius = 80;
            const splashDamage = Math.floor(projectile.damage);
            const element = projectile.element || this.game.damageSystem.ELEMENT_TYPES.PHYSICAL;
            
            const results = this.game.damageSystem.applySplashDamage(
                projectile.source,
                pos,
                splashDamage,
                element,
                splashRadius,
                {
                    isBallistic: true,
                    projectileId: entityId,
                    allowFriendlyFire: false
                }
            );
            
            if (this.game.combatAISystems && projectile.source && results) {
                for (const result of results) {
                    if (result.targetId && result.actualDamage > 0) {
                        this.game.combatAISystems.setRetaliatoryTarget(result.targetId, projectile.source);
                    }
                }
            }
        }
        
        this.destroyProjectile(entityId);
    }
    
    createHitEffect(projectileId, targetId, targetPos, element, isBallistic = false) {
        if(this.game.effectsSystem){
            this.game.effectsSystem.createParticleEffect(targetPos.x, targetPos.y, targetPos.z, 'magic', {
                color: this.getElementalEffectColor(element),
                count: 3
            });
        }
    
    }

    createGroundExplosion(projectileId, pos, projectile, groundLevel) {

    }

    // Get visual effect color based on element
    getElementalEffectColor(element) {
        if (!this.game.damageSystem) return '#ff2200'; // blood-red
        
        switch (element) {
            case this.game.damageSystem.ELEMENT_TYPES.FIRE:
                return '#ffaa00'; // Default orange
            case this.game.damageSystem.ELEMENT_TYPES.COLD:
                return '#44aaff'; // Light blue
            case this.game.damageSystem.ELEMENT_TYPES.LIGHTNING:
                return '#ffff44'; // Bright yellow
            case this.game.damageSystem.ELEMENT_TYPES.POISON:
                return '#44ff44'; // Green
            case this.game.damageSystem.ELEMENT_TYPES.DIVINE:
                return '#ffddaa'; // Golden
            case this.game.damageSystem.ELEMENT_TYPES.PHYSICAL:
            default:
                return '#ff2200'; // Default orange
        }
    }

    // Get explosion effect type based on element
    getElementalExplosionEffect(element) {
        if (!this.game.damageSystem) return 'explosion';
        
        switch (element) {
            case this.game.damageSystem.ELEMENT_TYPES.FIRE:
                return 'fire_explosion';
            case this.game.damageSystem.ELEMENT_TYPES.COLD:
                return 'ice_explosion';
            case this.game.damageSystem.ELEMENT_TYPES.LIGHTNING:
                return 'lightning_explosion';
            case this.game.damageSystem.ELEMENT_TYPES.POISON:
                return 'poison_explosion';
            case this.game.damageSystem.ELEMENT_TYPES.DIVINE:
                return 'divine_explosion';
            case this.game.damageSystem.ELEMENT_TYPES.PHYSICAL:
            default:
                return 'explosion';
        }
    }
    
    updateProjectileTrail(projectileId, pos) {
        const projectileVisual = this.game.getComponent(projectileId, this.componentTypes.PROJECTILE_VISUAL);
        if (!projectileVisual || projectileVisual.trailLength <= 0) return;
        
        if (!this.projectileTrails.has(projectileId)) {
            this.projectileTrails.set(projectileId, []);
        }
        
        const trail = this.projectileTrails.get(projectileId);
        
        // Add current position to trail (full 3D)
        trail.push({ x: pos.x, y: pos.y, z: pos.z, time: (this.game.state.now || 0) });
        
        // Remove old trail points
        while (trail.length > projectileVisual.trailLength) {
            trail.shift();
        }
    }
        
    destroyProjectile(projectileId) {
        // Use LifetimeSystem for destruction if available
        if (this.game.lifetimeSystem) {
            this.game.lifetimeSystem.destroyEntityImmediately(projectileId, true);
        } else {
            // Fallback cleanup
            this.cleanupProjectileData(projectileId);
            this.game.destroyEntity(projectileId);
        }
    }
    
    getUnitRadius(unitType) {
        const DEFAULT_UNIT_RADIUS = 15;
        
        if (unitType && unitType.size) {
            return Math.max(DEFAULT_UNIT_RADIUS, unitType.size);
        }
        
        const collections = this.game.getCollections && this.game.getCollections();
        if (collections && collections.units && unitType) {
            const unitDef = collections.units[unitType.id];
            if (unitDef && unitDef.size) {
                return Math.max(DEFAULT_UNIT_RADIUS, unitDef.size);
            }
        }
        
        return DEFAULT_UNIT_RADIUS;
    }
    
    getProjectileTrail(projectileId) {
        return this.projectileTrails.get(projectileId) || [];
    }
    entityDestroyed(entityId) {
        // Clean up projectile trails
        if (this.projectileTrails) {
            this.projectileTrails.delete(entityId);
        }
        
        // Clean up any projectile tracking
        if (this.activeProjectiles) {
            this.activeProjectiles.delete(entityId);
        }
    }
};

// System: AnimationSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['AnimationSystem'] = class AnimationSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.animationSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        // Animation state tracking (VAT-only, no mixers)
        this.entityAnimationStates = new Map(); // entityId -> { currentClip, lastStateChange, flags, etc. }
        
        // Animation configuration
        this.MIN_MOVEMENT_THRESHOLD = 0.1;
        this.MIN_ATTACK_ANIMATION_TIME = 0.4;
        this.STATE_CHANGE_COOLDOWN = 0.1;

        // Single-play animations (play once then stop/transition)
        this.SINGLE_PLAY_ANIMATIONS = new Set([
            'attack', 'cast', 'death'
        ]);

    }

    update() {
        if (!this.game.scene || !this.game.camera || !this.game.renderer) return;
        this.updateEntityAnimations();
    }

    updateEntityAnimations() {
        const CT = this.componentTypes;
        const entities = this.game.getEntitiesWith(CT.POSITION, CT.RENDERABLE);

        entities.forEach(entityId => {
            // Only process instanced entities
            if (!this.game.renderSystem?.isInstanced(entityId)) return;

            const velocity = this.game.getComponent(entityId, CT.VELOCITY);
            const health = this.game.getComponent(entityId, CT.HEALTH);
            const combat = this.game.getComponent(entityId, CT.COMBAT);
            const aiState = this.game.getComponent(entityId, CT.AI_STATE);

            // Ensure entity has animation state
            if (!this.entityAnimationStates.has(entityId)) {
                this.initializeEntityAnimationState(entityId);
            }

            // Update animation logic
            this.updateEntityAnimationLogic(entityId, velocity, health, combat, aiState);
        });

        // Clean up removed entities
        this.cleanupRemovedEntities(new Set(entities));
    }

    initializeEntityAnimationState(entityId) {
        const state = {
            currentClip: 'idle',
            lastStateChange: this.game.state?.now || 0,
            animationTime: 0,
            minAnimationTime: 0,
            pendingClip: null,
            pendingSpeed: null,
            pendingMinTime: null,
            isTriggered: false,
            isDying: false,
            isCorpse: false,
            isCelebrating: false,
            // NEW: Track fallback usage to prevent thrashing
            lastRequestedClip: null,    // What was originally requested
            lastResolvedClip: null,     // What actually got set
            fallbackCooldown: 0         // Time remaining before allowing re-request of failed clip
        };

        this.entityAnimationStates.set(entityId, state);

        // Set initial animation
        this.game.renderSystem?.setInstanceClip(entityId, 'idle', true);
        this.game.renderSystem?.setInstanceSpeed(entityId, 1);

    }

    updateEntityAnimationLogic(entityId, velocity, health, combat, aiState) {
    
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        const currentTime = this.game.state?.now || 0;
        const deltaTime = this.game.state?.deltaTime || 1/60;
        animState.animationTime += deltaTime;

        // NEW: Handle animation completion for locked states
        if (animState.isDying || animState.isCorpse || animState.isCelebrating) {
            // Handle celebration completion ONLY
            if (animState.isCelebrating && this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
                const isFinished = this.isAnimationFinished(entityId, animState.currentClip);
                
                if (isFinished) {
                    this.stopCelebration(entityId);
                    return;
                }
            }
            
            return; // Still locked, don't process normal animation logic
        }
        // Handle pending triggered animations (from external calls)
        if (animState.isTriggered && animState.pendingClip) {
            this.applyTriggeredAnimation(entityId, animState);
            return;
        }

        // Determine desired animation based on game state
        const desired = this.determineDesiredAnimation(entityId, velocity, health, combat, aiState);
    
        // Check if we should change animation
        const shouldChange = this.shouldChangeAnimation(entityId, animState, desired, currentTime);
        

        if (shouldChange) {
            this.changeAnimation(entityId, desired.clip, desired.speed, desired.minTime);
        } else {
            // Update animation speed if needed (for continuous animations)
            this.updateAnimationSpeed(entityId, desired.speed);
        }
    }

    determineDesiredAnimation(entityId, velocity, health, combat, aiState) {
        let clip = 'idle';
        let speed = 1.0;
        let minTime = 0;

        if(this.game.state.phase == 'battle'){
            // Check movement first
            const isMoving = velocity && (Math.abs(velocity.vx) > this.MIN_MOVEMENT_THRESHOLD || Math.abs(velocity.vz) > this.MIN_MOVEMENT_THRESHOLD);
            
            if (isMoving) {
                clip = 'walk';
                speed = this.calculateWalkSpeed(velocity);
            }

            // AI state overrides
            if (aiState) {
                switch (aiState.state) {
                    case 'attacking':
                    case 'combat':
                        // During combat, prefer walking if moving, otherwise idle
                        if (!isMoving) {
                            clip = 'idle';
                            speed = 1.0;
                        }
                        break;
                        
                    case 'chasing':
                    case 'moving':
                        clip = 'walk';
                        speed = this.calculateWalkSpeed(velocity);
                        break;
                        
                    case 'waiting':
                        clip = isMoving ? 'walk' : 'idle';
                        if (isMoving) speed = this.calculateWalkSpeed(velocity);
                        break;
                }
            }
        }

        return { clip, speed, minTime };
    }

    shouldChangeAnimation(entityId, animState, desired, currentTime) {
        // 1) If we are in a single-play clip, don't allow state changes until it's finished
        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            const finished = this.isAnimationFinished(entityId, animState.currentClip);

            // Respect explicit minAnimationTime as an additional guard
            const minTimeSatisfied = (animState.minAnimationTime <= 0) || (animState.animationTime >= animState.minAnimationTime);

            // Block changes until BOTH: (a) clip finished OR (b) min time satisfied (use whichever is stricter for your game)
            // If you want strictly "finished", change to: if (!finished) return false;
            if (!finished && !minTimeSatisfied) {
                return false;
            }
            // Once finished (or min time hit), we can flow through to normal logic below.
        }

        // 2) Cooldown: prevent thrashing even for continuous animations
        const timeSinceLastChange = currentTime - animState.lastStateChange;
        if(timeSinceLastChange < 0){
            return true;

        }
        if (timeSinceLastChange < this.STATE_CHANGE_COOLDOWN) {
            return false;
        }

        // 3) If the desired clip differs, allow change (this now runs AFTER the single-play guard)
        if (animState.currentClip !== desired.clip) {
            return true;
        }

        // 4) For single-play, if somehow the clip finished (edge case) allow refresh
        if (this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            if (this.isAnimationFinished(entityId, animState.currentClip)) {
                return true;
            }
        }

        // 5) Respect minAnimationTime for non-single-play too
        if (animState.minAnimationTime > 0 && animState.animationTime < animState.minAnimationTime) {
            return false;
        }

        return false;
    }

    changeAnimation(entityId, clipName, speed = 1.0, minTime = 0) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return false;

        // Try to resolve clip name to available clip
        const resolvedClip = this.resolveClipName(entityId, clipName);
        
        // Apply animation change
        const success = this.game.renderSystem?.setInstanceClip(entityId, resolvedClip, true);
        if (success) {
            this.game.renderSystem?.setInstanceSpeed(entityId, speed);
            
            // Update state
            animState.currentClip = resolvedClip;
            animState.lastStateChange = this.game.state?.now || 0;
            animState.animationTime = 0;
            animState.minAnimationTime = minTime;
            
            return true;
        } else {
            console.warn(`[AnimationSystem] ❌ Failed to change animation for entity ${entityId}: ${clipName} -> ${resolvedClip}`);
        }

        return false;
    }

    updateAnimationSpeed(entityId, targetSpeed) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        // Only update speed for continuous animations
        if (!this.SINGLE_PLAY_ANIMATIONS.has(animState.currentClip)) {
            this.game.renderSystem?.setInstanceSpeed(entityId, targetSpeed);
        }
    }

    applyTriggeredAnimation(entityId, animState) {
        const clip = animState.pendingClip;
        const speed = animState.pendingSpeed || 1.0;
        const minTime = animState.pendingMinTime || 0;

        // Clear pending state
        animState.pendingClip = null;
        animState.pendingSpeed = null;
        animState.pendingMinTime = null;
        animState.isTriggered = false;

        // Apply the animation
        this.changeAnimation(entityId, clip, speed, minTime);
    }

    // Public API methods
    
    triggerSinglePlayAnimation(entityId, clipName, speed = 1.0, minTime = 0) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) {
            console.warn(`[AnimationSystem] No animation state for entity ${entityId}`);
            return false;
        }

        
        // Queue the animation
        animState.pendingClip = clipName;
        animState.pendingSpeed = speed;
        animState.pendingMinTime = minTime;
        animState.isTriggered = true;

        return true;
    }

    playDeathAnimation(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) {
            console.warn(`[AnimationSystem] ❌ No animation state found for entity ${entityId} during death`);
            return;
        }

        // Set death state
        animState.isDying = true;
        animState.isCorpse = false;
        animState.isCelebrating = false;
        
        // Clear any pending animations
        animState.isTriggered = false;
        animState.pendingClip = null;
        animState.pendingSpeed = null;
        animState.pendingMinTime = null;
        
        // Reset fallback tracking for death animation
        animState.lastRequestedClip = null;
        animState.lastResolvedClip = null;
        animState.fallbackCooldown = 0;
        
        // Apply death animation immediately
        this.changeAnimation(entityId, 'death', 1.0, 0);
        
    }

    setCorpseAnimation(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        // Update animation state flags
        animState.isDying = false;
        animState.isCorpse = true;
        
        // Stop the animation completely - set speed to 0 and freeze at current frame
        this.game.renderSystem?.setInstanceSpeed(entityId, 0);
        
    
    }

    startCelebration(entityId, teamType = null) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        animState.isCelebrating = true;
        
        // Try celebration animations, fallback to idle
        const celebrationClips = ['celebrate'];
        let clipToUse = 'idle';
        
        for (const clip of celebrationClips) {
            if (this.hasClip(entityId, clip)) {
                clipToUse = clip;
                break;
            }
        }

        this.changeAnimation(entityId, clipToUse, 1.0, 0);
    }

    stopCelebration(entityId) {
        const animState = this.entityAnimationStates.get(entityId);
        if (!animState) return;

        animState.isCelebrating = false;
        this.changeAnimation(entityId, 'idle', 1.0, 0);
    }

    entityJump(entityId, speed = 1.0) {
        if (this.hasClip(entityId, 'leap')) {
            this.triggerSinglePlayAnimation(entityId, 'leap', speed, 0.5);
        }
    }

    entityThrow(entityId, speed = 1.0) {
        if (this.hasClip(entityId, 'throw')) {
            this.triggerSinglePlayAnimation(entityId, 'throw', speed, 0.3);
        }
    }

    stopAllAnimations(entityId) {
        this.game.renderSystem?.setInstanceSpeed(entityId, 0);
    }

    // Utility methods

    calculateWalkSpeed(velocity) {
        if (!velocity) return 1.0;
        const speed = Math.sqrt((velocity.vx || 0) ** 2 + (velocity.vz || 0) ** 2);
        return Math.min(2.0, Math.max(0.5, speed / 30)); // Adjust divisor based on your units
    }

    isAnimationFinished(entityId, clipName) {
        if (!this.SINGLE_PLAY_ANIMATIONS.has(clipName)) {
            return false; // Continuous animations never finish
        }

        const animationState = this.game.renderSystem?.getInstanceAnimationState(entityId);
        if (!animationState) {
            return true;
        }

        // Check if we've played through most of the clip
        const progress = animationState.animTime / animationState.clipDuration;
        const isFinished = progress >= 0.9; // Consider finished at 90%
        
        return isFinished;
    }

    hasClip(entityId, clipName) {
        const CT = this.componentTypes;
        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
        if (!renderable) return false;

        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);
        return batchInfo?.availableClips?.includes(clipName) || false;
    }

    resolveClipName(entityId, desiredClip) {
        const CT = this.componentTypes;
        const renderable = this.game.getComponent(entityId, CT.RENDERABLE);
        if (!renderable) return 'idle';

        const batchInfo = this.game.renderSystem?.getBatchInfo(renderable.objectType, renderable.spawnType);
        if (!batchInfo) return 'idle';

        const availableClips = batchInfo.availableClips;

        // Return if exact match exists
        if (availableClips.includes(desiredClip)) {
            return desiredClip;
        }

        // Try fallbacks
        const fallbacks = {
            'attack': ['combat', 'fight', 'swing', 'strike', 'idle'],
            'shoot': ['bow', 'cast', 'throw', 'attack', 'idle'],
            'bow': ['shoot', 'cast', 'throw', 'attack', 'idle'],
            'cast': ['shoot', 'throw', 'attack', 'idle'],
            'walk': ['run', 'move', 'step', 'idle'],
            'hurt': ['damage', 'hit', 'pain', 'idle'],
            'death': ['die', 'idle'],
            'celebrate': ['victory', 'cheer', 'dance', 'happy', 'win', 'idle']
        };

        const fallbackList = fallbacks[desiredClip] || ['idle'];
        for (const fallback of fallbackList) {
            if (availableClips.includes(fallback)) {
                return fallback;
            }
        }

        // Final fallback
        return availableClips[0] || 'idle';
    }

    // Cleanup methods

    cleanupRemovedEntities(currentEntities) {
        const toRemove = [];
        
        for (const entityId of this.entityAnimationStates.keys()) {
            if (!currentEntities.has(entityId)) {
                toRemove.push(entityId);
            }
        }

        toRemove.forEach(entityId => {
            this.removeEntityAnimations(entityId);
        });
    }

    entityDestroyed(entityId){
        this.removeEntityAnimations(entityId);
    }
    removeEntityAnimations(entityId) {
        this.entityAnimationStates.delete(entityId);        
    }

    destroy() {
        this.entityAnimationStates.clear();
    }

};

// System: ArmyDisplaySystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ArmyDisplaySystem'] = class ArmyDisplaySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);  
        this.game.armyDisplaySystem = this;
        this.updateInterval = null;
        this.lastUpdateData = null;
    }
    
    initialize() {
        this.addArmyDisplayCSS();
        this.setupUpdateLoop();
    }
    
    setupUpdateLoop() {
        // Update army display every 500ms to avoid performance issues
        this.updateInterval = setInterval(() => {
            this.update();
        }, 500);
    }
    
    update() {
        const playerArmy = document.getElementById('playerArmy');
        const enemyArmy = document.getElementById('enemyArmy');
        
        if (!playerArmy || !enemyArmy) return;
        
        const armyData = this.getArmyData();
        
        // Only update if data has changed to avoid unnecessary DOM manipulation
        if (this.hasDataChanged(armyData)) {
            this.displayArmy(playerArmy, armyData.playerUnits, 'player');
            this.displayArmy(enemyArmy, armyData.enemyUnits, 'enemy');
            this.lastUpdateData = armyData;
        }
        
        this.updateArmyStats(armyData);
    }
    
    hasDataChanged(newData) {
        if (!this.lastUpdateData) return true;
        
        return (
            JSON.stringify(newData.playerUnits) !== JSON.stringify(this.lastUpdateData.playerUnits) ||
            JSON.stringify(newData.enemyUnits) !== JSON.stringify(this.lastUpdateData.enemyUnits)
        );
    }
    
    getArmyData() {
        try {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const allUnits = this.game.getEntitiesWith(
                ComponentTypes.TEAM, 
                ComponentTypes.UNIT_TYPE, 
                ComponentTypes.HEALTH
            ) || [];
            
            const playerUnits = [];
            const enemyUnits = [];
            
            allUnits.forEach(entityId => {
                const team = this.game.getComponent(entityId, ComponentTypes.TEAM);
                const unitType = this.game.getComponent(entityId, ComponentTypes.UNIT_TYPE);
                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                const combat = this.game.getComponent(entityId, ComponentTypes.COMBAT);
                
                const unitInfo = {
                    id: entityId,
                    type: unitType?.type || 'Unknown',
                    name: unitType?.name || unitType?.type || 'Unit',
                    health: health?.current || 0,
                    maxHealth: health?.max || 1,
                    position: position ? { x: position.x, z: position.z } : null,
                    damage: combat?.damage || 0,
                    status: this.getUnitStatus(entityId)
                };
                
                if (team?.team === 'player') {
                    playerUnits.push(unitInfo);
                } else if (team?.team === 'enemy') {
                    enemyUnits.push(unitInfo);
                }
            });
            
            // Sort by health percentage (wounded units first, then by position)
            const sortUnits = (units) => {
                return units.sort((a, b) => {
                    const healthPercentA = a.health / a.maxHealth;
                    const healthPercentB = b.health / b.maxHealth;
                    
                    // Wounded units first
                    if (healthPercentA < 1 && healthPercentB >= 1) return -1;
                    if (healthPercentB < 1 && healthPercentA >= 1) return 1;
                    
                    // Then sort by position (front to back)
                    if (a.position && b.position) {
                        return a.position.x - b.position.x;
                    }
                    
                    return 0;
                });
            };
            
            return {
                playerUnits: sortUnits(playerUnits),
                enemyUnits: sortUnits(enemyUnits)
            };
        } catch (error) {
            console.warn('Error getting army data:', error);
            return { playerUnits: [], enemyUnits: [] };
        }
    }
    
    getUnitStatus(entityId) {
        try {
            const ComponentTypes = this.game.componentManager.getComponentTypes();
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
            
            if (health?.current <= 0) return 'dead';
            if (aiState?.state === 'attacking') return 'attacking';
            if (aiState?.state === 'moving') return 'moving';
            if (aiState?.state === 'idle') return 'idle';
            
            return 'unknown';
        } catch (error) {
            return 'unknown';
        }
    }
    
    displayArmy(container, units, armyType) {
        // Clear container
        container.innerHTML = '';
        
        if (units.length === 0) {
            this.displayEmptyArmy(container, armyType);
            return;
        }
        
        // Create army header
        this.createArmyHeader(container, units, armyType);
        
        // Display units
        units.forEach((unit, index) => {
            const unitElement = this.createUnitElement(unit, index, armyType);
            container.appendChild(unitElement);
        });
    }
    
    displayEmptyArmy(container, armyType) {
        const emptyDiv = document.createElement('div');
        emptyDiv.className = 'army-empty';
        emptyDiv.innerHTML = `
            <div class="empty-icon">${armyType === 'player' ? '🛡️' : '⚔️'}</div>
            <div class="empty-text">
                ${armyType === 'player' ? 'No units deployed' : 'Enemy preparing...'}
            </div>
        `;
        container.appendChild(emptyDiv);
    }
    
    createArmyHeader(container, units, armyType) {
        const header = document.createElement('div');
        header.className = `army-header army-header-${armyType}`;
        
        const totalHealth = units.reduce((sum, unit) => sum + unit.health, 0);
        const maxHealth = units.reduce((sum, unit) => sum + unit.maxHealth, 0);
        const healthPercent = maxHealth > 0 ? Math.round((totalHealth / maxHealth) * 100) : 0;
        
        const aliveCount = units.filter(unit => unit.health > 0).length;
        
        header.innerHTML = `
            <div class="army-summary">
                <span class="unit-count">${aliveCount}/${units.length} Units</span>
                <span class="health-percent ${this.getHealthPercentClass(healthPercent)}">${healthPercent}% HP</span>
            </div>
            <div class="army-health-bar">
                <div class="health-bar-fill" style="width: ${healthPercent}%"></div>
            </div>
        `;
        
        container.appendChild(header);
    }
    
    createUnitElement(unit, index, armyType) {
        const unitDiv = document.createElement('div');
        unitDiv.className = `army-unit army-unit-${armyType}`;
        unitDiv.dataset.unitId = unit.id;
        
        const healthPercent = unit.health / unit.maxHealth;
        const healthClass = this.getHealthClass(healthPercent);
        const statusIcon = this.getStatusIcon(unit.status);
        
        unitDiv.innerHTML = `
            <div class="unit-info">
                <div class="unit-name-row">
                    <span class="unit-name">${unit.name}</span>
                    <span class="unit-status">${statusIcon}</span>
                </div>
                <div class="unit-health-row">
                    <span class="unit-health ${healthClass}">${unit.health}/${unit.maxHealth}</span>
                    <span class="unit-damage">⚔️${unit.damage}</span>
                </div>
                <div class="unit-health-bar">
                    <div class="health-bar-fill ${healthClass}" 
                         style="width: ${Math.max(0, healthPercent * 100)}%"></div>
                </div>
            </div>
        `;
        
        // Add click handler for unit selection/info
        unitDiv.addEventListener('click', () => {
            this.showUnitDetails(unit, armyType);
        });
        
        // Add hover effects
        unitDiv.addEventListener('mouseenter', () => {
            this.highlightUnit(unit.id);
        });
        
        unitDiv.addEventListener('mouseleave', () => {
            this.unhighlightUnit(unit.id);
        });
        
        return unitDiv;
    }
    
    getHealthClass(healthPercent) {
        if (healthPercent <= 0) return 'health-dead';
        if (healthPercent <= 0.25) return 'health-critical';
        if (healthPercent <= 0.5) return 'health-wounded';
        if (healthPercent <= 0.75) return 'health-damaged';
        return 'health-full';
    }
    
    getHealthPercentClass(percent) {
        if (percent <= 25) return 'health-critical';
        if (percent <= 50) return 'health-wounded';
        if (percent <= 75) return 'health-damaged';
        return 'health-full';
    }
    
    getStatusIcon(status) {
        const icons = {
            attacking: '⚔️',
            moving: '🏃',
            idle: '🛡️',
            dead: '💀',
            unknown: '❓'
        };
        return icons[status] || icons.unknown;
    }
    
    showUnitDetails(unit, armyType) {
        const details = `
            <h3>${unit.name} Details</h3>
            <div class="unit-details">
                <div class="detail-row">
                    <span>Health:</span>
                    <span class="${this.getHealthClass(unit.health / unit.maxHealth)}">
                        ${unit.health}/${unit.maxHealth}
                    </span>
                </div>
                <div class="detail-row">
                    <span>Damage:</span>
                    <span>${unit.damage}</span>
                </div>
                <div class="detail-row">
                    <span>Status:</span>
                    <span>${this.getStatusIcon(unit.status)} ${unit.status}</span>
                </div>
                ${unit.position ? `
                <div class="detail-row">
                    <span>Position:</span>
                    <span>(${unit.position.x.toFixed(1)}, ${unit.position.z.toFixed(1)})</span>
                </div>
                ` : ''}
            </div>
        `;
        
        // Use the input handler to show modal
        if (this.game.uiSystem.input) {
            this.game.uiSystem.input.showModal(`${armyType === 'player' ? '🛡️' : '⚔️'} Unit Info`, details);
        }
    }
    
    highlightUnit(unitId) {
        // Visual highlight on the battlefield (could integrate with effects system)
        if (this.game.effectsSystem) {
            // Get unit position and show highlight effect
            try {
                const ComponentTypes = this.game.componentManager.getComponentTypes();
                const position = this.game.getComponent(unitId, ComponentTypes.POSITION);
                if (position) {
                    // Convert world position to screen position and show highlight
                    // This is a placeholder - actual implementation would depend on rendering system
                    console.log(`Highlighting unit ${unitId} at position (${position.x}, ${position.z})`);
                }
            } catch (error) {
                console.warn('Could not highlight unit:', error);
            }
        }
    }
    
    unhighlightUnit(unitId) {
        // Remove highlight
        console.log(`Unhighlighting unit ${unitId}`);
    }
    
    updateArmyStats(armyData) {
        this.updateArmyStrength(armyData);
        this.updateArmyComposition(armyData);
    }
    
    updateArmyStrength(armyData) {
        // Update army strength indicators
        const playerStrength = this.calculateArmyStrength(armyData.playerUnits);
        const enemyStrength = this.calculateArmyStrength(armyData.enemyUnits);
        
        // Update strength displays if they exist
        const playerStrengthEl = document.getElementById('playerArmyStrength');
        const enemyStrengthEl = document.getElementById('enemyArmyStrength');
        
        if (playerStrengthEl) {
            playerStrengthEl.textContent = playerStrength;
            playerStrengthEl.className = this.getStrengthClass(playerStrength);
        }
        
        if (enemyStrengthEl) {
            enemyStrengthEl.textContent = enemyStrength;
            enemyStrengthEl.className = this.getStrengthClass(enemyStrength);
        }
    }
    
    calculateArmyStrength(units) {
        return units.reduce((total, unit) => {
            const healthFactor = unit.health / unit.maxHealth;
            return total + (unit.damage * healthFactor);
        }, 0);
    }
    
    getStrengthClass(strength) {
        if (strength >= 100) return 'strength-very-high';
        if (strength >= 75) return 'strength-high';
        if (strength >= 50) return 'strength-medium';
        if (strength >= 25) return 'strength-low';
        return 'strength-very-low';
    }
    
    updateArmyComposition(armyData) {
        // Update army composition displays
        const playerComposition = this.analyzeComposition(armyData.playerUnits);
        const enemyComposition = this.analyzeComposition(armyData.enemyUnits);
        
        // Could update composition indicators here
        console.log('Player composition:', playerComposition);
        console.log('Enemy composition:', enemyComposition);
    }
    
    analyzeComposition(units) {
        const composition = {};
        units.forEach(unit => {
            composition[unit.type] = (composition[unit.type] || 0) + 1;
        });
        return composition;
    }
    
    addArmyDisplayCSS() {
        if (document.querySelector('#army-display-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'army-display-styles';
        style.textContent = `
            .army-empty {
                text-align: center; padding: 2rem; color: #666;
            }
            
            .empty-icon {
                font-size: 2rem; margin-bottom: 0.5rem; opacity: 0.5;
            }
            
            .empty-text {
                font-size: 0.9rem; opacity: 0.7;
            }
            
            .army-header {
                background: rgba(255, 255, 255, 0.05);
                padding: 0.8rem; margin-bottom: 0.5rem;
                border-radius: 5px; border-left: 3px solid;
            }
            
            .army-header-player { border-left-color: #00ff00; }
            .army-header-enemy { border-left-color: #ff4444; }
            
            .army-summary {
                display: flex; justify-content: space-between;
                align-items: center; margin-bottom: 0.5rem;
            }
            
            .unit-count {
                font-weight: bold; color: #ccc;
            }
            
            .health-percent {
                font-weight: bold; font-size: 0.9rem;
            }
            
            .army-health-bar {
                height: 4px; background: #333; border-radius: 2px; overflow: hidden;
            }
            
            .health-bar-fill {
                height: 100%; transition: width 0.3s ease;
            }
            
            .army-unit {
                background: rgba(255, 255, 255, 0.03);
                border: 1px solid transparent;
                border-radius: 4px; padding: 0.6rem;
                margin: 0.3rem 0; cursor: pointer;
                transition: all 0.2s ease;
            }
            
            .army-unit:hover {
                background: rgba(255, 255, 255, 0.08);
                border-color: rgba(255, 255, 255, 0.2);
                transform: translateX(2px);
            }
            
            .army-unit-player:hover { border-left-color: #00ff00; }
            .army-unit-enemy:hover { border-left-color: #ff4444; }
            
            .unit-info {
                font-size: 0.85rem;
            }
            
            .unit-name-row, .unit-health-row {
                display: flex; justify-content: space-between;
                align-items: center; margin-bottom: 0.3rem;
            }
            
            .unit-name {
                font-weight: bold; color: #ccc;
            }
            
            .unit-status {
                opacity: 0.8;
            }
            
            .unit-health {
                font-weight: bold;
            }
            
            .unit-damage {
                font-size: 0.8rem; opacity: 0.8;
            }
            
            .unit-health-bar {
                height: 3px; background: #333;
                border-radius: 2px; overflow: hidden;
            }
            
            /* Health color classes */
            .health-full, .health-full .health-bar-fill { color: #00ff00; background-color: #00ff00; }
            .health-damaged, .health-damaged .health-bar-fill { color: #88ff88; background-color: #88ff88; }
            .health-wounded, .health-wounded .health-bar-fill { color: #ffff00; background-color: #ffff00; }
            .health-critical, .health-critical .health-bar-fill { color: #ff8800; background-color: #ff8800; }
            .health-dead, .health-dead .health-bar-fill { color: #ff0000; background-color: #ff0000; opacity: 0.5; }
            
            /* Strength classes */
            .strength-very-high { color: #00ff88; }
            .strength-high { color: #88ff88; }
            .strength-medium { color: #ffff88; }
            .strength-low { color: #ff8888; }
            .strength-very-low { color: #ff4444; }
            
            /* Unit details modal content */
            .unit-details {
                font-family: monospace;
            }
            
            .detail-row {
                display: flex; justify-content: space-between;
                padding: 0.5rem 0; border-bottom: 1px solid #333;
            }
            
            .detail-row:last-child {
                border-bottom: none;
            }
        `;
        document.head.appendChild(style);
    }
    
    cleanup() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
        }
    }
}
;

// System: EffectsSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['EffectsSystem'] = class EffectsSystem extends engine.BaseSystem {
    constructor(game) {
        super(game); 
        this.game.effectsSystem = this;
        
        // Screen effect tracking
        this.screenEffects = [];
        this.shakeActive = false;
        this.flashActive = false;
        
        // UI notifications
        this.notifications = [];
        
        // Single array for all active effects with unified update loop
        this.activeEffects = [];
        
        // Object pools for reuse
        this.geometryPool = new Map(); // type -> geometry[]
        this.materialPool = new Map(); // key -> material[]
        this.effectPool = []; // Reusable effect objects        
        this.activeAuras = new Map();
        // Batching system
        this.batchedEffects = new Map(); // type -> effects[]
        
        this.effectOffset = { x: 0, y: 75, z: 0 };
        this.shakeData = null;
        this.flashData = null;
        // Performance tracking
        this.stats = {
            activeEffects: 0,
            pooledObjects: 0
        };
    }
    
    initialize() {
        this.addEffectsCSS();
        console.log('EffectsSystem initialized');
    }
    
    // Batch process all effects using game time
    updateAllEffects() {
        if (!this.game.state) return;
        
        const currentTime = this.game.state.now;
        if (!currentTime) return;
        
        const toRemove = [];
        
        for (let i = this.activeEffects.length - 1; i >= 0; i--) {
            const effect = this.activeEffects[i];
            const elapsed = currentTime - effect.startTime;
            const progress = elapsed / effect.duration;
            
            if (progress >= 1) {
                toRemove.push(i);
                continue;
            }
            
            this.updateEffect(effect, elapsed, progress);
        }
        
        // Remove completed effects and return to pool
        toRemove.forEach(index => {
            const effect = this.activeEffects[index];
            this.recycleEffect(effect);
            this.activeEffects.splice(index, 1);
        });
        
        this.stats.activeEffects = this.activeEffects.length;
    }
    
    updateEffect(effect, elapsed, progress) {
        const { material, animation } = effect;
        
        // Batch similar updates together
        switch (effect?.animationType) {
            case 'flicker':
                this.updateFlickerEffect(effect, elapsed, animation);
                break;
            case 'pulse':
                this.updatePulseEffect(effect, elapsed, animation);
                break;
            case 'fade':
                this.updateFadeEffect(effect, progress, animation);
                break;
        }
    }
    
    updateFlickerEffect(effect, elapsed, animation) {
        if (animation?.flickerCount > 0 && effect?.flickerCount < animation?.flickerCount) {
            if (elapsed % animation.flickerSpeed < animation.flickerSpeed / 2) {
                if (animation.opacityFlicker) {
                    effect.material.opacity = Math.random() * 0.6 + 0.4;
                }
                if (animation.colorFlicker) {
                    const colors = [0x00ddff, 0x88aaff, 0xaaffff];
                    effect.material.color.setHex(colors[Math.floor(Math.random() * colors.length)]);
                }
                effect.flickerCount++;
            }
        }
    }
    
    updatePulseEffect(effect, elapsed, animation) {
        if (animation?.pulseEffect) {
            const pulseIntensity = Math.sin(elapsed * 0.01) * 0.3 + 0.7;
            effect.material.opacity = pulseIntensity;
        }
    }
    
    updateFadeEffect(effect, progress, animation) {
        if (animation?.fadeOut && progress > 0.7) {
            const fadeProgress = (progress - 0.7) / 0.3;
            effect.material.opacity = effect.originalOpacity * (1 - fadeProgress);
        }
    }
    
    // Object pooling system
    getPooledGeometry(type, points) {
        const poolKey = `${type}_${points.length}`;
        let pool = this.geometryPool.get(poolKey);
        
        if (!pool) {
            pool = [];
            this.geometryPool.set(poolKey, pool);
        }
        
        if (pool.length > 0) {
            const geometry = pool.pop();
            geometry.setFromPoints(points);
            geometry.computeBoundingSphere();
            return geometry;
        }
        
        return new THREE.BufferGeometry().setFromPoints(points);
    }
    
    getPooledMaterial(config) {
        const poolKey = `${config.color}_${config.linewidth}_${config.blending}`;
        let pool = this.materialPool.get(poolKey);
        
        if (!pool) {
            pool = [];
            this.materialPool.set(poolKey, pool);
        }
        
        if (pool.length > 0) {
            const material = pool.pop();
            material.opacity = config.opacity || 1.0;
            material.color.setHex(config.color || 0xffffff);
            return material;
        }
        
        return new THREE.LineBasicMaterial({
            color: config.color || 0xffffff,
            linewidth: config.linewidth || 2,
            transparent: true,
            opacity: config.opacity || 1.0,
            blending: config.blending || THREE.AdditiveBlending
        });
    }
    
    getPooledEffect() {
        if (this.effectPool.length > 0) {
            return this.effectPool.pop();
        }
        
        return {
            line: null,
            geometry: null,
            material: null,
            startTime: 0,
            duration: 0,
            flickerCount: 0,
            originalOpacity: 1,
            animationType: null
        };
    }
    
    recycleEffect(effect) {
        if (!effect) return;
        
        try {
            // Remove from scene
            if (this.game?.scene && effect.line) {
                this.game.scene.remove(effect.line);
            }
            
            // Return to pools
            if (effect.geometry) {
                const poolKey = `${effect.type}_${effect.geometry.attributes.position.count}`;
                let pool = this.geometryPool.get(poolKey);
                if (!pool) {
                    pool = [];
                    this.geometryPool.set(poolKey, pool);
                }
                if (pool.length < 10) { // Limit pool size
                    pool.push(effect.geometry);
                }
            }
            
            if (effect.material) {
                const poolKey = `${effect.material.color.getHex()}_${effect.material.linewidth}_${effect.material.blending}`;
                let pool = this.materialPool.get(poolKey);
                if (!pool) {
                    pool = [];
                    this.materialPool.set(poolKey, pool);
                }
                if (pool.length < 10) { // Limit pool size
                    pool.push(effect.material);
                }
            }
            
            // Reset effect object and return to pool
            effect.line = null;
            effect.geometry = null;
            effect.material = null;
            effect.startTime = 0;
            effect.duration = 0;
            effect.flickerCount = 0;
            effect.originalOpacity = 1;
            effect.animationType = null;
            
            if (this.effectPool.length < 50) { // Limit pool size
                this.effectPool.push(effect);
            }
            
        } catch (e) {
            console.warn('recycleEffect error:', e);
        }
    }
    
    // Main line effect creation (same interface, better performance)
    createLineEffect(config) {
        if (!this.game.scene) return null;
        
        const {
            startPos,
            endPos,
            type = 'lightning',
            style = {},
            animation = {}
        } = config;
        
        const lineConfig = this.getLineEffectConfig(type);
        const mergedStyle = { ...lineConfig.style, ...style };
        const mergedAnimation = { ...lineConfig.animation, ...animation };
        
        // Generate path based on type
        const points = this.generateLinePath(startPos, endPos, type, mergedStyle);
        
        // Use pooled objects
        const geometry = this.getPooledGeometry(type, points);
        const material = this.getPooledMaterial(mergedStyle);
        const effect = this.getPooledEffect();
        
        // Create line object
        const lineEffect = new THREE.Line(geometry, material);
        this.game.scene.add(lineEffect);
        
        // Setup effect tracking
        effect.line = lineEffect;
        effect.geometry = geometry;
        effect.material = material;
        effect.startTime = this.game.state.now;
        effect.duration = mergedAnimation.duration || 1000;
        effect.originalOpacity = material.opacity;
        effect.type = type;
        
        // Determine animation type for efficient batching
        if (mergedAnimation.flickerCount > 0) {
            effect.animationType = 'flicker';
        } else if (mergedAnimation.pulseEffect) {
            effect.animationType = 'pulse';
        } else if (mergedAnimation.fadeOut) {
            effect.animationType = 'fade';
        }
        
        this.activeEffects.push(effect);
        
        return effect;
    }
    
    // Batch creation for multiple effects
    createBatchedEffects(effects) {
        const results = [];
        
        for (const config of effects) {
            const effect = this.createLineEffect(config);
            if (effect) {
                results.push(effect);
            }
        }
        
        return results;
    }
    
    // Keep existing interface methods unchanged
    createLightningBolt(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'lightning',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createEnergyBeam(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'beam',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createMagicArc(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'arc',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    createChainLink(startPos, endPos, options = {}) {
        return this.createLineEffect({
            startPos,
            endPos,
            type: 'chain',
            style: options.style || {},
            animation: options.animation || {}
        });
    }
    
    // Line effect configuration (unchanged)
    getLineEffectConfig(type) {
        const configs = {
            lightning: {
                style: {
                    color: 0x88aaff,
                    linewidth: 3,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    segments: 8,
                    deviation: 15,
                    jaggedIntensity: 1.2
                },
                animation: {
                    duration: 0.3,
                    flickerCount: 3,
                    flickerSpeed: 50,
                    opacityFlicker: true,
                    colorFlicker: true,
                    fadeOut: true
                }
            },
            beam: {
                style: {
                    color: 0xff4444,
                    linewidth: 4,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending,
                    segments: 3,
                    deviation: 2,
                    jaggedIntensity: 0.1
                },
                animation: {
                    duration: 0.5,
                    pulseEffect: true,
                    fadeOut: true
                }
            },
            arc: {
                style: {
                    color: 0x44ff44,
                    linewidth: 2,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending,
                    segments: 12,
                    deviation: 25,
                    jaggedIntensity: 0.3,
                    arcHeight: 30
                },
                animation: {
                    duration: 0.8,
                    fadeOut: true
                }
            },
            chain: {
                style: {
                    color: 0xffaa00,
                    linewidth: 3,
                    opacity: 0.9,
                    blending: THREE.AdditiveBlending,
                    segments: 6,
                    deviation: 8,
                    jaggedIntensity: 0.8
                },
                animation: {
                    duration: 0.6,
                    flickerCount: 2,
                    flickerSpeed: 80,
                    fadeOut: true
                }
            }
        };
        
        return configs[type] || configs.lightning;
    }
    
    // Path generation (unchanged but more efficient)
    generateLinePath(start, end, type, style) {
        const points = [start.clone()];
        const segments = style.segments || 5;
        const deviation = style.deviation || 10;
        const jaggedIntensity = style.jaggedIntensity || 1;
        
        // Different path generation based on type
        if (type === 'arc') {
            return this.generateArcPath(start, end, style.arcHeight || 20, segments);
        }
        
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const basePos = start.clone().lerp(end, t);
            
            // Add jagged deviation
            if (deviation > 0 && jaggedIntensity > 0) {
                const actualDeviation = deviation * jaggedIntensity;
                basePos.x += (Math.random() - 0.5) * actualDeviation;
                basePos.y += (Math.random() - 0.5) * actualDeviation * 0.5;
                basePos.z += (Math.random() - 0.5) * actualDeviation;
            }
            
            points.push(basePos);
        }
        
        points.push(end.clone());
        return points;
    }
    
    generateArcPath(start, end, height, segments) {
        const points = [];
        const midPoint = start.clone().lerp(end, 0.5);
        midPoint.y += height;
        
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = this.quadraticBezier(start, midPoint, end, t);
            points.push(point);
        }
        
        return points;
    }
    
    quadraticBezier(p0, p1, p2, t) {
        const point = new THREE.Vector3();
        point.x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;
        point.y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;
        point.z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z + t * t * p2.z;
        return point;
    }
    
    // Clear effects efficiently
    clearAllEffects() {
        // Recycle all active effects
        for (const effect of this.activeEffects) {
            this.recycleEffect(effect);
        }
        this.activeEffects = [];
    }
    
    // Force cleanup with pool clearing
    forceCleanup() {
        this.clearAllEffects();
        
        // Clear pools
        for (const [key, pool] of this.geometryPool) {
            pool.forEach(geo => geo.dispose());
            pool.length = 0;
        }
        
        for (const [key, pool] of this.materialPool) {
            pool.forEach(mat => mat.dispose());
            pool.length = 0;
        }
        
        this.effectPool.length = 0;
        this.stats.pooledObjects = 0;
    }
    
    // Performance monitoring
    getPerformanceStats() {
        const poolSize = Array.from(this.geometryPool.values()).reduce((sum, pool) => sum + pool.length, 0) +
                        Array.from(this.materialPool.values()).reduce((sum, pool) => sum + pool.length, 0) +
                        this.effectPool.length;
        
        this.stats.pooledObjects = poolSize;
        
        return {
            ...this.stats,
            memoryUsage: {
                geometryPools: this.geometryPool.size,
                materialPools: this.materialPool.size,
                effectPool: this.effectPool.length
            }
        };
    }
    
    // Keep all existing particle and screen effect methods unchanged
    getEffectConfig(effectType) {
        const configs = {
            victory: {
                count: 5,
                shape: 'star',
                color: 0x00ff00,
                colorRange: { start: 0x00ff00, end: 0xffff00 },
                lifetime: 1.5,
                velocity: { speed: 8, spread: 0.5, pattern: 'burst' },
                scale: 2,
                scaleVariation: 0.3,
                physics: { gravity: -0.5, drag: 0.99 },
                rotation: { enabled: true, speed: 5 },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            },
            defeat: {
                count: 8,
                shape: 'spark',
                color: 0xff0000,
                colorRange: { start: 0xff0000, end: 0x440000 },
                lifetime: 2,
                velocity: { speed: 6, spread: 0.8, pattern: 'burst' },
                scale: 1.5,
                scaleVariation: 0.4,
                physics: { gravity: 0.3, drag: 0.95 },
                rotation: { enabled: true, speed: 3 },
                visual: { fadeOut: true, scaleOverTime: false, blending: 'normal' }
            },
            levelup: {
                count: 12,
                shape: 'glow',
                color: 0xffaa00,
                colorRange: { start: 0xffaa00, end: 0xffffff },
                lifetime: 2.5,
                velocity: { speed: 4, spread: 0.3, pattern: 'fountain' },
                scale: 3,
                scaleVariation: 0.2,
                physics: { gravity: -0.2, drag: 0.98 },
                rotation: { enabled: false },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            }
        };
        
        return configs[effectType] || configs.victory;
    }
    
    // Screen effects (unchanged)
    playScreenShake(duration = 0.3, intensity = 2) {
        if (this.shakeActive) return;
        
        const gameContainer = document.getElementById('gameContainer');
        if (!gameContainer) return;
        
        this.shakeActive = true;
        this.shakeData = {
            startTime: this.game.state.now,
            duration: duration, 
            intensity: intensity,
            originalTransform: gameContainer.style.transform
        };
    }

    playScreenFlash(color = '#ffffff', duration = 0.3) {
        // if (this.flashActive) return;
        // return;
        // this.flashActive = true;
        // const flash = document.createElement('div');
        // flash.className = 'screen-flash';
        // flash.style.cssText = `
        //     position: fixed;
        //     top: 0;
        //     left: 0;
        //     width: 100%;
        //     height: 100%;
        //     background-color: ${color};
        //     pointer-events: none;
        //     z-index: 999;
        //     opacity: 0.6;
        // `;
        
        // document.body.appendChild(flash);
        
        // // Store flash data for game loop processing
        // this.flashData = {
        //     element: flash,
        //     startTime: this.game.state.now,
        //     duration: duration,
        //     startOpacity: 0.6
        // };
    }

    
    // UI effects (unchanged)
    showFloatingText(text, position, type = 'damage', duration = 1500) {
        const floatingText = document.createElement('div');
        floatingText.className = `floating-text ${type}`;
        floatingText.textContent = text;
        floatingText.style.cssText = `
            position: absolute;
            left: ${position.x}px;
            top: ${position.y}px;
            color: ${this.getTextColor(type)};
            font-weight: bold;
            font-size: 16px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1000;
            animation: floatingText ${duration}ms ease-out forwards;
        `;
        
        document.body.appendChild(floatingText);
        
        setTimeout(() => {
            if (document.body.contains(floatingText)) {
                document.body.removeChild(floatingText);
            }
        }, duration);
    }
    
    getTextColor(type) {
        const colors = {
            damage: '#ff4444',
            healing: '#44ff44', 
            levelup: '#ffaa00',
            gold: '#ffdd00',
            experience: '#88aaff'
        };
        return colors[type] || '#ffffff';
    }
    
    showGameNotification(title, message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `game-notification notification-${type}`;
        notification.innerHTML = `
            <div style="font-weight: bold; margin-bottom: 5px;">${title}</div>
            <div>${message}</div>
        `;
        
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid ${this.getNotificationColor(type)};
            max-width: 300px;
            z-index: 1001;
            animation: notificationSlideIn 0.3s ease-out;
        `;
        
        document.body.appendChild(notification);
        this.notifications.push(notification);
        
        setTimeout(() => {
            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                    const index = this.notifications.indexOf(notification);
                    if (index > -1) {
                        this.notifications.splice(index, 1);
                    }
                }
            }, 300);
        }, duration);
    }
    
    getNotificationColor(type) {
        const colors = {
            info: '#4444ff',
            success: '#44ff44',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        return colors[type] || '#4444ff';
    }
    
    // Particle effects - delegate to particle system
    createParticleEffect(x, y, z, type, options = {}) {
        // Use existing particle system if available
        if (this.game.particleSystem) {
            // Convert to the config format that ParticleSystem.createParticles expects
            const config = {
                position: new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z),
                count: options.count || 3,
                shape: options.shape || 'circle',
                color: options.color || 0xffffff,
                colorRange: options.colorRange || null,
                lifetime: options.lifetime || 1.5,
                velocity: options.velocity || { speed: 5, spread: 1, pattern: 'burst' },
                scale: (options.scaleMultiplier || 1) * 1.0,
                scaleVariation: options.scaleVariation || 0.5,
                physics: options.physics || { gravity: 0.5, drag: 0.98 },
                rotation: options.rotation || { enabled: false, speed: 0 },
                visual: options.visual || { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            };
            
            this.game.particleSystem.createParticles(config);
        }
    }
    
    showDamageNumber(x, y, z, damage, type = 'damage') {
        this.showFloatingText(damage.toString(), { x, y }, type);
    }
    
    showVictoryEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'victory', options);
        this.playScreenFlash('#44ff44', 0.3);
        this.showGameNotification('Victory!', 'You won!', 'success', 2000);
    }
    
    showDefeatEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'defeat', options);
        this.playScreenFlash('#ff4444', 0.5);
        this.showGameNotification('Defeat!', 'You lost!', 'error', 2000);
    }
    
    showExplosionEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'explosion', options);
        this.playScreenShake(0.2, 3);
    }
    
    showHealEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'heal', options);
    }
    
    showMagicEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'magic', options);
    }
    
    showDamageEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'damage', options);
    }
    
    showLevelUpEffect(x, y, z, options = {}) {
        this.createParticleEffect(x, y, z, 'levelup', options);
        this.playScreenShake(0.4, 1);
        this.showGameNotification('Level Up!', 'Character advanced!', 'success', 3000);
    }
    
    // Missing method that abilities are calling
    createAuraEffect(x, y, z, type, duration) {
        if (!this.game.particleSystem) return;
        const auraId = `aura_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const startTime = this.game.state.now;
        const position = new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z);
        
        // Create aura configuration
        const config = this.getEffectConfig(type);
        const auraData = {
            id: auraId,
            position: position.clone(),
            type: type,
            startTime: startTime,
            duration: duration,
            lastParticleTime: startTime,
            particleInterval: 1, // 1 second between particle bursts
            isActive: true,
            config: {
                count: 4,
                shape: 'circle',
                color: config.color || 0xffffff,
                colorRange: config.colorRange || null,
                lifetime: 2.0,
                velocity: { speed: 2, spread: 0.8, pattern: 'burst' },
                scale: (config.scale || 1) * 0.8,
                scaleVariation: 0.3,
                physics: { gravity: -0.1, drag: 0.98 },
                rotation: { enabled: true, speed: 1 },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            }
        };
        
        // Add to active auras tracking
        if (!this.activeAuras) {
            this.activeAuras = new Map();
        }
        this.activeAuras.set(auraId, auraData);
        
        return auraId;
    }
    
    // Missing methods that were in the original EffectsSystem
    showNotification(message, type = 'info', duration = 3000) {
        const notification = document.createElement('div');
        notification.className = `game-notification notification-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            color: white;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            z-index: 1000;
            animation: notificationSlideIn 0.5s ease-out;
            max-width: 300px;
            word-wrap: break-word;
        `;
        
        switch (type) {
            case 'victory':
                notification.style.background = 'linear-gradient(145deg, #001100, #003300)';
                notification.style.border = '2px solid #00ff00';
                notification.style.color = '#00ff00';
                notification.style.textShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                break;
            case 'defeat':
                notification.style.background = 'linear-gradient(145deg, #110000, #330000)';
                notification.style.border = '2px solid #ff0000';
                notification.style.color = '#ff4444';
                notification.style.textShadow = '0 0 10px rgba(255, 68, 68, 0.5)';
                break;
            case 'levelup':
                notification.style.background = 'linear-gradient(145deg, #111100, #333300)';
                notification.style.border = '2px solid #ffd700';
                notification.style.color = '#ffd700';
                notification.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                break;
            default:
                notification.style.background = 'linear-gradient(145deg, #001122, #003344)';
                notification.style.border = '2px solid #00aaff';
                notification.style.color = '#00aaff';
                notification.style.textShadow = '0 0 10px rgba(0, 170, 255, 0.5)';
        }
        
        document.body.appendChild(notification);
        this.notifications.push(notification);
        this.repositionNotifications();
        
        setTimeout(() => {
            this.removeNotification(notification);
        }, duration);
    }
    
    removeNotification(notification) {
        if (document.body.contains(notification)) {
            notification.style.animation = 'notificationSlideOut 0.3s ease-out forwards';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
                const index = this.notifications.indexOf(notification);
                if (index > -1) {
                    this.notifications.splice(index, 1);
                }
                this.repositionNotifications();
            }, 300);
        }
    }
    
    repositionNotifications() {
        this.notifications.forEach((notification, index) => {
            notification.style.top = `${20 + index * 80}px`;
        });
    }
    
    showDamageNumber(x, y, z, damage, type = 'damage') {
        // Use floating text for damage numbers
        this.showFloatingText(damage.toString(), { x, y: y + 50 }, type);
        
        // Also create particle effect for visual emphasis
        if (this.game.particleSystem) {
            const config = {
                position: new THREE.Vector3(x + this.effectOffset.x, y + this.effectOffset.y, z + this.effectOffset.z),
                count: 3,
                shape: 'circle',
                color: this.getDamageColor(type),
                lifetime: 1.0,
                velocity: { speed: 15, spread: 0.3, pattern: 'burst' },
                scale: 0.8,
                scaleVariation: 0.2,
                physics: { gravity: -0.5, drag: 0.95 },
                rotation: { enabled: false },
                visual: { fadeOut: true, scaleOverTime: true, blending: 'additive' }
            };
            
            this.game.particleSystem.createParticles(config);
        }
    }
    
    getDamageColor(type) {
        switch (type) {
            case 'heal': return 0x00ff88;
            case 'critical': return 0xff0044;
            case 'poison': return 0x8a2be2;
            case 'fire': return 0xff4400;
            case 'cold': return 0x00bfff;
            case 'lightning': return 0xffff00;
            case 'divine': return 0xffd700;
            default: return 0xff4444;
        }
    }
    
    // Clear all effects method that was referenced
    clearAllEffects() {
        // Clear all active line effects
        for (const effect of this.activeEffects) {
            this.recycleEffect(effect);
        }
        this.activeEffects = [];
        
        // Clear all active auras
        if (this.activeAuras) {
            this.activeAuras.clear();
        }
        
        // Clear particle effects
        if (this.game.particleSystem) {
            this.game.particleSystem.clearAllParticles();
        }
        
        // Clear notifications
        this.notifications.forEach(notification => {
            this.removeNotification(notification);
        });
        
        this.shakeActive = false;
        this.flashActive = false;
    }
    
    addEffectsCSS() {
        const style = document.createElement('style');
        style.id = 'effects-styles';
        style.textContent = `
            .screen-flash {
                transition: opacity 0.3s ease-out;
            }
            
            @keyframes battleStartTransition {
                0% { transform: translateX(-100%); }
                100% { transform: translateX(100%); }
            }
            
            @keyframes flashFade {
                0% { opacity: 0.6; }
                100% { opacity: 0; }
            }
            
            @keyframes notificationSlideIn {
                from { 
                    transform: translateX(100%);
                    opacity: 0; 
                }
                to { 
                    transform: translateX(0);
                    opacity: 1; 
                }
            }
            
            @keyframes notificationSlideOut {
                from { 
                    transform: translateX(0);
                    opacity: 1; 
                }
                to { 
                    transform: translateX(100%);
                    opacity: 0; 
                }
            }
            
            @keyframes floatingText {
                0% { 
                    transform: translate(-50%, -50%) scale(0.8);
                    opacity: 0;
                }
                20% { 
                    transform: translate(-50%, -50%) scale(1.2);
                    opacity: 1;
                }
                100% { 
                    transform: translate(-50%, -150%) scale(1);
                    opacity: 0;
                }
            }
            
            .game-notification {
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(5px);
            }
        `;
        document.head.appendChild(style);
    }
    
    // Main update method called by game loop
    update() {
        this.updateAllEffects();
        this.updateAuras(); 
        this.updateScreenEffects();
    }
    updateAuras() {
        if (!this.activeAuras || !this.game.state) return;
        
        const currentTime = this.game.state.now;
        const aurasToRemove = [];
        
        for (const [auraId, auraData] of this.activeAuras) {
            const elapsed = currentTime - auraData.startTime;
            
            // Check if aura has expired
            if (elapsed >= auraData.duration) {
                aurasToRemove.push(auraId);
                continue;
            }
            
            // Check if it's time to create new particles
            const timeSinceLastParticle = currentTime - auraData.lastParticleTime;
            if (timeSinceLastParticle >= auraData.particleInterval) {
                this.createAuraParticles(auraData);
                auraData.lastParticleTime = currentTime;
            }
        }
        
        // Remove expired auras
        aurasToRemove.forEach(auraId => {
            this.activeAuras.delete(auraId);
        });
    }
    
    updateScreenEffects() {
        // Handle screen shake
        if (this.shakeActive && this.shakeData) {
            const gameContainer = document.getElementById('gameContainer');
            if (!gameContainer) {
                this.shakeActive = false;
                return;
            }
            
            const elapsed = this.game.state.now - this.shakeData.startTime;
            const progress = elapsed / this.shakeData.duration;
            
            if (progress >= 1) {
                gameContainer.style.transform = this.shakeData.originalTransform;
                this.shakeActive = false;
                this.shakeData = null;
            } else {
                const diminishingIntensity = this.shakeData.intensity * (1 - progress);
                const shakeX = (Math.random() - 0.5) * diminishingIntensity;
                const shakeY = (Math.random() - 0.5) * diminishingIntensity;
                gameContainer.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
            }
        }
        
        // Handle screen flash
        if (this.flashActive && this.flashData) {
            const elapsed = this.game.state.now - this.flashData.startTime;
            const progress = elapsed / this.flashData.duration;
            
            if (progress >= 1) {
                // Flash finished
                if (document.body.contains(this.flashData.element)) {
                    document.body.removeChild(this.flashData.element);
                }
                this.flashActive = false;
                this.flashData = null;
            } else {
                // Fade out the flash
                const opacity = this.flashData.startOpacity * (1 - progress);
                this.flashData.element.style.opacity = opacity;
            }
        }
    }
    createAuraParticles(auraData) {
        if (!this.game.particleSystem) return;
        
        const particleConfig = {
            position: auraData.position,
            ...auraData.config
        };
        
        this.game.particleSystem.createParticles(particleConfig);
    }
    destroy() {
        this.forceCleanup();
        
        const styleElement = document.querySelector('#effects-styles');
        if (styleElement) {
            styleElement.remove();
        }
        
        console.log('EffectsSystem destroyed');
    }
    entityDestroyed(entityId) {
        // Clean up any auras associated with this entity
        if (this.activeAuras) {
            const aurasToRemove = [];
            for (const [auraId, auraData] of this.activeAuras) {
                if (auraData.sourceEntityId === entityId || auraData.targetEntityId === entityId) {
                    aurasToRemove.push(auraId);
                }
            }
            aurasToRemove.forEach(auraId => this.activeAuras.delete(auraId));
        }
        
        // Clean up any particle effects tracking
        if (this.entityEffects) {
            this.entityEffects.delete(entityId);
        }
    }
};

// System: GridSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['GridSystem'] = class GridSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.gridSystem = this;
        
        this.state = new Map();

        // NEW: track which half each team owns
        this.teamSides = { player: 'left', enemy: 'right' };
        this.leftBounds = null;
        this.rightBounds = null;
    }
    
    init() {

        const collections = this.game.getCollections();
        
        const cellSize = collections.configs.game.gridSize; 
        const currentLevel = collections.configs.state.level;
        const terrainSize = collections.levels[currentLevel]?.tileMap?.size * cellSize;
        
        this.cellSize = cellSize;
        this.showGrid = true;
        this.snapToGrid = true;
        this.highlightValidCells = true;
        
        this.dimensions = {
            width: Math.floor(terrainSize / cellSize),
            height: Math.floor(terrainSize / cellSize),
            cellSize: cellSize,
            startX: -terrainSize / 2,
            startZ: -terrainSize / 2
        };
        console.log("dimensions", this.dimensions);
        
        this.gridVisualization = null;

        // Compute half-splits once
        const half = Math.floor(this.dimensions.width / 2);
        this.leftBounds = {
            minX: 0,
            maxX: half - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };
        this.rightBounds = {
            minX: half,
            maxX: this.dimensions.width - 1,
            minZ: 0,
            maxZ: this.dimensions.height - 1
        };

        // Default: player=left, enemy=right (can be swapped later)
        this.playerBounds = this.leftBounds;
        this.enemyBounds  = this.rightBounds;
        
        // Pre-calculate world bounds for faster collision detection
        this.worldBounds = {
            minX: this.dimensions.startX,
            maxX: this.dimensions.startX + (this.dimensions.width * cellSize),
            minZ: this.dimensions.startZ,
            maxZ: this.dimensions.startZ + (this.dimensions.height * cellSize)
        };
    }

    // NEW: set which half each team owns (call this when you learn sides from the server)
    setTeamSides(sides) {
        if (sides?.player === 'left' || sides?.player === 'right') {
            this.teamSides.player = sides.player;
        }
        if (sides?.enemy === 'left' || sides?.enemy === 'right') {
            this.teamSides.enemy = sides.enemy;
        }

        // Point player/enemy bounds at the correct half
        this.playerBounds = (this.teamSides.player === 'left') ? this.leftBounds : this.rightBounds;
        this.enemyBounds  = (this.teamSides.enemy  === 'left') ? this.leftBounds : this.rightBounds;

    }
    
    createVisualization(scene) {
        if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
        }
        
        const group = new THREE.Group();
        const { width, height, cellSize, startX, startZ } = this.dimensions;
        
        // Use BufferGeometry for better performance
        const linePositions = [];
        
        // Vertical lines
        for (let x = 0; x <= width; x++) {
            const worldX = startX + (x * cellSize);
            linePositions.push(
                worldX, 1, startZ,
                worldX, 1, startZ + (height * cellSize)
            );
        }
        
        // Horizontal lines
        for (let z = 0; z <= height; z++) {
            const worldZ = startZ + (z * cellSize);
            linePositions.push(
                startX, 1, worldZ,
                startX + (width * cellSize), 1, worldZ
            );
        }
        
        const lineGeometry = new THREE.BufferGeometry();
        lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
        
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x444444, 
            transparent: true, 
            opacity: 0.3 
        });
        
        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        group.add(lines);
        
        // Center divider line
        const dividerPositions = [
            startX + (width * cellSize / 2), 2, startZ,
            startX + (width * cellSize / 2), 2, startZ + (height * cellSize)
        ];
        
        const dividerGeometry = new THREE.BufferGeometry();
        dividerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(dividerPositions, 3));
        
        const dividerMaterial = new THREE.LineBasicMaterial({ 
            color: 0xff0000, 
            transparent: true, 
            opacity: 0.5 
        });
        
        const dividerLine = new THREE.LineSegments(dividerGeometry, dividerMaterial);
        group.add(dividerLine);
        
        this.gridVisualization = group;
        scene.add(this.gridVisualization);
    }
    
    worldToGrid(worldX, worldZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: Math.floor((worldX - startX) / cellSize),
            z: Math.floor((worldZ - startZ) / cellSize)
        };
    }
    
    gridToWorld(gridX, gridZ) {
        const { cellSize, startX, startZ } = this.dimensions;
        return {
            x: startX + (gridX * cellSize) + (cellSize / 2),
            z: startZ + (gridZ * cellSize) + (cellSize / 2)
        };
    }
    
    // OPTIMIZED: Early bounds checking
    isValidPosition(gridPos) {
        return gridPos.x >= 0 && gridPos.x < this.dimensions.width &&
               gridPos.z >= 0 && gridPos.z < this.dimensions.height;
    }

    isValidPlacement(cells, team) {
        if (!cells || cells.length === 0) return false;
                
        // IMPORTANT: use dynamic bounds based on current side assignment
        const bounds = (team === 'right') ? this.rightBounds : this.leftBounds;
        
        for (const cell of cells) {
            if (cell.x < bounds.minX || cell.x > bounds.maxX ||
                cell.z < bounds.minZ || cell.z > bounds.maxZ) {
                return false;
            }
        }
        
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            const cellState = this.state.get(key);
            if (cellState && cellState.occupied) {
                return false;
            }
        }

        
        return true;
    }
    updateUnitPosition(placementId, worldX, worldZ) {
        this.freeCells(placementId);
        const gridPos = this.worldToGrid(worldX, worldZ);        
        this.occupyCells([gridPos], placementId);
    }
    occupyCells(cells, placementId) {        
        const updates = cells.map(cell => ({
            key: `${cell.x},${cell.z}`,
            value: {
                occupied: true,
                placementId: placementId
            }
        }));
        updates.forEach(({ key, value }) => {
            this.state.set(key, value);
        });
        
    }

    freeCells(placementId) {
        const keysToDelete = [];
        
        for (const [key, value] of this.state.entries()) {
            if (value.placementId === placementId) {
                keysToDelete.push(key);
            }
        }
        
        keysToDelete.forEach(key => {
            this.state.delete(key);
        });
        
    }
       
    entityDestroyed(entityId) {
        const CT = this.game.componentManager.getComponentTypes();
        const placement = this.game.getComponent(entityId, CT.PLACEMENT);
        if(placement){
            this.freeCells(placement.placementId);
        }
    }
    clear() {
        this.state.clear();
    }
    
    toggleVisibility(scene) {
        this.showGrid = !this.showGrid;
        
        if (this.showGrid) {
            this.createVisualization(scene);
        } else if (this.gridVisualization) {
            scene.remove(this.gridVisualization);
            this.gridVisualization = null;
        }
    }
    
    getBounds(team) {
        // Keep API compatibility; these references are updated by setTeamSides()
        return team === 'right' ? this.rightBounds : this.leftBounds;
    }
    
    getCellState(gridX, gridZ) {
        const key = `${gridX},${gridZ}`;
        return this.state.get(key);
    }
    
    getOccupiedCells() {
        return Array.from(this.state.entries()).map(([key, value]) => {
            const [x, z] = key.split(',').map(Number);
            return { x, z, ...value };
        });
    }
    
    getGridInfo() {
        return {
            dimensions: this.dimensions,
            leftBounds: this.leftBounds,
            rightBounds: this.rightBounds,
            teamSides: { ...this.teamSides },
            occupiedCells: this.getOccupiedCells(),
            totalCells: this.dimensions.width * this.dimensions.height,
            occupiedCount: this.state.size
        };
    }
    
    // OPTIMIZED: Batch cell queries for better performance
    areCellsOccupied(cells) {
        for (const cell of cells) {
            const key = `${cell.x},${cell.z}`;
            if (this.state.has(key)) {
                return true;
            }
        }
        return false;
    }
    
    // OPTIMIZED: Fast world bounds check
    isInWorldBounds(worldX, worldZ) {
        return worldX >= this.worldBounds.minX && worldX <= this.worldBounds.maxX &&
               worldZ >= this.worldBounds.minZ && worldZ <= this.worldBounds.maxZ;
    }
};

// System: MultiplayerPlacementSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['MultiplayerPlacementSystem'] = class MultiplayerPlacementSystem extends engine.BaseSystem {
    constructor(game, sceneManager) {
        super(game);
        this.sceneManager = sceneManager;
        this.game.placementSystem = this;
        
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();
        this.canvas = this.game.canvas;
        
        this.playerPlacements = [];
        this.opponentPlacements = [];        
        this.undoStack = [];
        this.maxUndoSteps = 10;
        
        this.game.state.targetPositions = new Map();
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;
        
        this.lastMouseMoveTime = 0;
        this.lastValidationTime = 0;
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        this.lastUpdateTime = 0;
        this.config = {
            maxSquadsPerRound: 2,
            enablePreview: true,
            enableUndo: true,
            validationThrottle: .32
        };
        this.elements = {};
    }

    init(params) {
        this.params = params || {};
        this.initializeSubsystems();
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.initializeControls();
        this.elements.readyButton.addEventListener('click', () => {
            this.togglePlacementReady();
        });
        
        this.elements.undoButton.addEventListener('click', () => {
            this.undoLastPlacement();

            this.elements.undoButton.style.transform = 'scale(0.95)';
            setTimeout(() => {
                this.elements.undoButton.style.transform = 'scale(1)';
            }, 150);
            
            this.game.uiSystem.showNotification('↶ Last deployment undone', 'info', 2000);
         
        });
        
        this.elements.undoButton.addEventListener('mouseenter', () => {
            if (!this.elements.undoButton.disabled) {
                this.elements.undoButton.style.background = 'linear-gradient(135deg, #616161, #757575)';
                this.elements.undoButton.style.transform = 'translateY(-2px)';
                this.elements.undoButton.style.boxShadow = '0 4px 12px rgba(117, 117, 117, 0.3)';
            }
        });
        
        this.elements.undoButton.addEventListener('mouseleave', () => {
            if (!this.elements.undoButton.disabled) {
                this.elements.undoButton.style.background = 'linear-gradient(135deg, var(--stone-gray), #616161)';
                this.elements.undoButton.style.transform = 'translateY(0)';
                this.elements.undoButton.style.boxShadow = 'none';
            }
        });
    }

    initializeSubsystems() {
        const terrainSize = this.game.worldSystem?.terrainSize || 768;
        
        this.gridSystem = this.game.gridSystem;
        this.gridSystem.init({terrainSize});
        this.squadManager = this.game.squadManager;
        this.unitCreator = this.game.unitCreationManager;
         
        if (this.config.enablePreview) {
            this.placementPreview = new GUTS.PlacementPreview(this.game);
        }
        
        this.groundMeshCache = this.findGroundMesh();
    }

    onGameStarted() {
        this.getStartingState();
        this.onPlacementPhaseStart();
    }

    getStartingState() {
         this.game.networkManager.getStartingState((success, response) => {
            if(success){
                const buildingTypes = this.game.getCollections().buildings;
                const unitTypes = this.game.getCollections().buildings;
                response.startingUnits.forEach((unitData) => {
                    const unitId = unitData.type;
                    const unitPos = unitData.position;
                    const collection = this.game.getCollections()[unitData.collection];
                    if(collection){
                        const unitDef = collection[unitId];
                        const placementData = { id: unitId, collection: unitData.collection, ...unitDef };       
                        const placement = this.createPlacementData(unitPos, placementData, this.game.state.mySide);
                        placement.isStartingState = true;
                        this.game.networkManager.submitPlacement(placement, (success, response) => {
                            if(success){
                                this.placeSquad(placement);
                                if(placement.unitType.collection == "buildings"){
                                    this.game.shopSystem.addBuilding(placement.unitType.id, placement.squadUnits[0]);
                                }
                            }
                        });            
                    }          
                });
                const pos = response.camera.position;
                const look = response.camera.lookAt;
                this.game.camera.position.set(pos.x, pos.y, pos.z);
                this.game.camera.lookAt(look.x, look.y, look.z);
            }
        });   
    }

    getPlacementsForSide(side){
        if(side == this.game.state.mySide){
            return this.playerPlacements;
        } else {
            return this.opponentPlacements;
        }
    }

    onPlacementPhaseStart() { 
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;
           
        if (this.game.shopSystem) {
            this.game.shopSystem.reset();
        }  
        if (this.game.damageSystem) {
            this.game.damageSystem.clearAll();
        }
        if(this.game.effectsSystem){
            this.game.effectsSystem.clearAllEffects();
        }
        
        this.enablePlacementUI();
        this.elements.readyButton.textContent = 'Ready for Battle';
    }
    
    respawnEnemyUnits() {
        this.respawnSquads(this.opponentPlacements, this.game.state.mySide == 'left' ? 'right' : 'left');
    }
          
    getTotalUnitCount(placements) {
        return placements.reduce((sum, placement) => {
            return sum + (placement.isSquad ? placement.squadUnits.length : 1);
        }, 0);
    }     
    
    createRespawnEffect(position, team) {
        if (!this.game.effectsSystem) return;
        
        const effectType = team === 'player' ? 'magic' : 'heal';
        this.game.effectsSystem.createParticleEffect(
            position.x,
            position.y,
            position.z,
            effectType,
            { count: 3, speedMultiplier: 0.6 }
        );
    }
        
    enablePlacementUI() {
        this.elements.readyButton.disabled = false;   
        this.elements.undoButton.disabled = false;      
    }
        
    disablePlacementUI() {
        this.elements.readyButton.disabled = true; 
        this.elements.undoButton.disabled = true;        
    }

    updatePlacementUI() {
        if (this.elements.undoButton) {
            this.elements.undoButton.disabled = this.undoStack.length === 0;
            this.elements.undoButton.style.opacity = this.undoStack.length === 0 ? '0.5' : '1';
        }
    }

    togglePlacementReady(callback) {
        if (this.elements.readyButton) {
            this.elements.readyButton.disabled = true;
            this.elements.readyButton.textContent = 'Updating...';
        }
        this.game.networkManager.toggleReadyForBattle((success, response) => {
            if(success){
                this.hasSubmittedPlacements = true;
                this.elements.readyButton.textContent = 'Waiting for Opponent...';
            } else {
                if (this.elements.readyButton) {
                    this.elements.readyButton.disabled = false;
                    this.elements.readyButton.textContent = 'Ready for Battle';
                }
            }
        });
    }

    handleReadyForBattleUpdate(data) {
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.playerId === myPlayerId) {
            this.isPlayerReady = data.ready;
            this.updatePlacementUI();
        } 
        
        if (data.allReady) {
            let opponentPlacements = null;
            data.gameState.players.forEach((player) => {
                if(player.id != myPlayerId){
                    opponentPlacements = player.placements;
                }
            });
            this.applyOpponentPlacements(opponentPlacements);
            this.applyTargetPositions();
            this.game.state.phase = 'battle';
            this.game.triggerEvent("onBattleStart");
            this.game.resetCurrentTime();
            this.resetAI();
            this.game.desyncDebugger.enabled = true;
            this.game.desyncDebugger.displaySync(true);
            if (this.elements.readyButton) {
                this.elements.readyButton.disabled = true;
                this.elements.readyButton.textContent = 'Battling!';
            }
        } else {
            const opponentReady = data.gameState?.players?.find(p => p.id !== myPlayerId)?.ready;
            if (opponentReady) {
                this.game.uiSystem?.showNotification('Opponent is ready for battle!', 'info');
            }
        }
    }

    resetAI() {
        const componentTypes = this.game.componentManager.getComponentTypes();            
        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      
        AIEntities.forEach((entityId) => {
            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);
            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
            combat.lastAttack = 0;
            aiState.aiBehavior = {};
        });
    }

    applyTargetPositions(){
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const allPlacements = [...this.playerPlacements, ...this.opponentPlacements];
        allPlacements.forEach((placement) => {
            placement.squadUnits.forEach(entityId => {
                const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
                const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                if (aiState && position) {
                    let targetPosition = aiState.targetPosition;
                    let tempPosition = this.game.unitOrderSystem.temporaryOpponentMoveOrders.get(placement.placementId);
                    if(tempPosition){
                        targetPosition = tempPosition;
                        this.game.unitOrderSystem.temporaryOpponentMoveOrders.delete(placement.placementId);                    
                    }

                    if(targetPosition){
                            console.log('found targetPosition', entityId, targetPosition, aiState);
                        if(!aiState.currentAIController || aiState.currentAIController == "OrderSystemMove"){
                            const dx = position.x - targetPosition.x;
                            const dz = position.z - targetPosition.z;
                            const distSq = dx * dx + dz * dz;
                            const threshold = this.game.getCollections().configs.game.gridSize * 0.5;
                            if (distSq <= threshold * threshold) {
                                aiState.currentAIController = null;
                                aiState.targetPosition = null;
                                placement.targetPosition = null;
                            } else {
                                aiState.targetPosition = { ...targetPosition };      
                                aiState.currentAIController = "OrderSystemMove";
                            }
                        }
                    } else {
                        console.log('did not find target position', aiState);
                    }
                }
            });
        });
    }

    update() {
        if (this.game.state.phase !== 'placement') {
            this.lastRaycastTime = 0;
            this.lastValidationTime = 0;
            this.lastUpdateTime = 0;            
            this.disablePlacementUI();
            return;
        }
        
        if (this.game.state.now - this.lastValidationTime > this.config.validationThrottle) {
            this.updateCursorState();
            this.updatePlacementUI();
            this.lastValidationTime = this.game.state.now;
        }
    }

    applyOpponentPlacements(opponentData) {
        opponentData.forEach(placement => {
            if(this.game.placementSystem.opponentPlacements.find(p => p.placementId === placement.placementId)) {
                return;
            }
            this.placeSquad(placement);         
        });

        if (this.game.state) {
            this.game.state.enemyPlacementComplete = true;
        }
    }

    createEnemyFromOpponentPlacement(opponentPlacement) {
        if(this.game.squadExperienceSystem){
            this.game.squadExperienceSystem.setSquadInfo(opponentPlacement.placementId, opponentPlacement.experience);
        }

        if (this.game.squadManager && this.game.unitCreationManager) {
            const unitPositions = this.game.squadManager.calculateUnitPositions(
                opponentPlacement.gridPosition,
                opponentPlacement.unitType
            );

            let squadUnits = [];
            unitPositions.forEach((pos, index) => {
                const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
                const unitY = terrainHeight !== null ? terrainHeight : 0;

                let entityId = this.game.unitCreationManager.create(
                    pos.x,
                    unitY,
                    pos.z,
                    opponentPlacement.targetPosition,
                    opponentPlacement,
                    this.game.state.mySide == 'right' ? 'left' : 'right'
                );
                if (opponentPlacement.unitType.id === 'goldMine') {
                    const gridWidth = opponentPlacement.unitType.placementGridWidth || 2;
                    const gridHeight = opponentPlacement.unitType.placementGridHeight || 2;
                    
                    const opponentSide = this.game.state.mySide === 'right' ? 'left' : 'right';
                    
                    this.game.goldMineSystem.buildGoldMine(
                        entityId,
                        opponentSide,
                        opponentPlacement.gridPosition,
                        gridWidth,
                        gridHeight
                    );
                }
                squadUnits.push(entityId);
            });
            opponentPlacement.squadUnits = squadUnits;
        }

        if (this.game.gridSystem?.occupyCells && opponentPlacement.cells?.length) {
            this.game.gridSystem.occupyCells(opponentPlacement.cells, opponentPlacement.placementId);
        }

        this.opponentPlacements.push(opponentPlacement);
    }

    handleUnitSelectionChange() {
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.cachedWorldPos = null;
        this.lastMouseX = null;
        this.lastMouseY = null;
        this.lastRaycastTime = null;
        this.lastRaycastMouseX = null;
        this.lastRaycastMouseY = null;
        this.approximateWorldScale = null;
        this.previousWorldPos = null;
        this.previousMouseX = null;
        this.previousMouseY = null;
        
        if (this.squadValidationCache) {
            this.squadValidationCache.clear();
        }
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }
        
        document.body.style.cursor = 'default';
    }

    onActivateBuildingPlacement(){
        this.handleUnitSelectionChange();
    }

    handleCanvasClick(event) {
        const state = this.game.state;
        
        if (this.settingTargetPosition) {
            return;
        }
        
        if (state.phase !== 'placement') {
            return;
        }
        if(!state.selectedUnitType) {
            return;
        }
        
        if (this.isPlayerReady) {
            return;
        }
        
        if (!this.canPlayerPlaceSquad()) {
            return;
        }
        
        if (state.playerGold < state.selectedUnitType.value) {
            return;
        }
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        const worldPosition = this.getWorldPositionFromMouse(event, mouseX, mouseY);
        let gridPos = this.game.gridSystem.worldToGrid(worldPosition.x, worldPosition.z);
        
        let isValidPlacement = this.isValidGridPlacement(worldPosition);
       
        if (!isValidPlacement) {
            return;
        }
    
        if (this.game.squadManager) {
            const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
        
            if (!validation.valid) {
                return;
            }
        }
        
        const placement = this.createPlacementData(gridPos, state.selectedUnitType, this.game.state.mySide);

        this.game.networkManager.submitPlacement(placement, (success, response) => {
            if(success){
                this.placeSquad(placement);
            }
        });        
    }

    canPlayerPlaceSquad() {
        return true;
    }

    placeSquad(placement) {
        const unitPositions = this.game.squadManager.calculateUnitPositions(placement.gridPosition, placement.unitType);
        const undoInfo = this.createUndoInfo(placement);
        
        const squadUnits = this.createSquadUnits(placement, unitPositions, placement.team, undoInfo);
        placement.squadUnits = squadUnits;
        placement.isSquad = squadUnits.length > 1;
        this.updateGameStateForPlacement(placement, undoInfo);
        
        this.game.gridSystem.occupyCells(placement.cells, placement.placementId);
        
        if (this.game.squadExperienceSystem) {
            this.game.squadExperienceSystem.initializeSquad(placement.placementId, placement.unitType, squadUnits, placement.team);
        }
        
        if (this.game.effectsSystem && squadUnits.length <= 8) {
            this.createPlacementEffects(unitPositions.slice(0, 8), placement.team);
        }
        
        this.cachedValidation = null;
        this.cachedGridPos = null;
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }

        this.game.state.selectedUnitType = null;
        this.handleUnitSelectionChange();
        
        return placement;
    }

    createSquadUnits(placement, unitPositions, team, undoInfo) {
        const createdUnits = [];
        
        const maxUnits = Math.min(unitPositions.length, 16);
        const positions = unitPositions.slice(0, maxUnits);
        
        positions.forEach(pos => {
            const terrainHeight = this.game.terrainSystem?.getTerrainHeightAtPosition(pos.x, pos.z) || 0;
            const unitY = terrainHeight !== null ? terrainHeight : 0;
        
            const entityId = this.game.unitCreationManager.create(pos.x, unitY, pos.z, pos, placement, team);
            createdUnits.push(entityId);
            undoInfo.unitIds.push(entityId);
            
            if(placement.unitType.id == 'goldMine'){
                const gridWidth = placement.unitType.placementGridWidth || 2;
                const gridHeight = placement.unitType.placementGridHeight || 2;
                this.game.goldMineSystem.buildGoldMine(entityId, team, placement.gridPosition, gridWidth, gridHeight);
            }
            if (placement.peasantInfo && placement.collection === 'buildings') {           
                const peasantInfo = placement.peasantInfo;
                const peasantId = peasantInfo.peasantId;
                const peasantAbilities = this.game.abilitySystem.entityAbilities.get(peasantId);
                if (peasantAbilities) {
                    const buildAbility = peasantAbilities.find(a => a.id === 'build');
                    if (buildAbility) {
                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);
                    }
                }
                
                this.game.state.peasantBuildingPlacement = null;
            }
        });
        
        return createdUnits;
    }

    createUndoInfo(placement) {
        return {
            type: 'squad_placement',
            placementId: placement.placementId,
            collection: placement.collection,
            unitType: { ...placement.unitType },
            cost: placement.unitType.value || 0,
            gridPosition: { ...placement.gridPosition },
            cells: [...placement.cells],
            unitIds: [],
            team: this.game.state.mySide,
            timestamp: this.game.state.now
        };
    }

    createPlacementData(gridPos, unitType, team) {
        const squadData = this.game.squadManager.getSquadData(unitType);
        const cells = this.game.squadManager.getSquadCells(gridPos, squadData);
        
        const placementId = `squad_${team}_${gridPos.x}_${gridPos.z}_${this.game.state.round}`;
        return {
            placementId: placementId,
            gridPosition: gridPos,
            cells: cells,
            collection: unitType.collection,
            unitType: { ...unitType },
            squadUnits: [],
            team: team,
            targetPosition: this.game.state.targetPositions.get(placementId),
            roundPlaced: this.game.state.round,
            timestamp: this.game.state.now,
            peasantInfo: this.game.state.peasantBuildingPlacement
        };
    }

    updateGameStateForPlacement(placement, undoInfo) {                
        if (this.isMyTeam(placement.team)) {
            this.addToUndoStack(undoInfo);
            if(!placement.isStartingState){
                this.game.state.playerGold -= (placement.unitType.value || 0);
            }
            this.playerPlacements.push(placement);
        } else {
            this.opponentPlacements.push(placement);
        }
    }

    setPlacementExperience(placements) {
        if (placements && this.game.squadExperienceSystem) {
            placements.forEach(placement => {
                if (placement.experience && placement.placementId) {
                    const experienceData = placement.experience;                
                    let squadData = this.game.squadExperienceSystem.getSquadInfo(placement.placementId);
                    
                    if (squadData) {
                        squadData.level = experienceData.level;
                        squadData.experience = experienceData.experience;
                        squadData.experienceToNextLevel = experienceData.experienceToNextLevel;
                        squadData.canLevelUp = experienceData.canLevelUp;                    
                    }
                }
            });            
        }
    }

    isMyTeam(team){
        return team == this.game.state.mySide;
    }

    createPlacementEffects(unitPositions, team) {
        if (!this.game.effectsSystem) return;
        
        const effectType = this.isMyTeam(team) ? 'magic' : 'defeat';
        const maxEffects = Math.min(unitPositions.length, 6);
        
        for (let i = 0; i < maxEffects; i++) {
            const pos = unitPositions[i];
            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
            const unitY = terrainHeight !== null ? terrainHeight : 0;
            
            this.game.effectsSystem.createParticleEffect(
                pos.x,
                unitY,
                pos.z,
                effectType,
                { count: 3, speedMultiplier: 0.8 }
            );
        }
    }

    undoLastPlacement() {
        if (!this.config.enableUndo) return;
        
        const state = this.game.state;
        
        if (state.phase !== 'placement') {
            return;
        }
        
        if (this.isPlayerReady) {
            return;
        }
        
        if (this.undoStack.length === 0) {
            return;
        }
        
        const undoInfo = this.undoStack.pop();
        
        try {
            undoInfo.unitIds.forEach(entityId => {
                if (this.game.destroyEntity) {
                    this.game.destroyEntity(entityId);
                }
            });
            
            state.playerGold += undoInfo.cost;
            
            const placementIndex = this.playerPlacements.findIndex(p => p.placementId === undoInfo.placementId);
            if (placementIndex !== -1) {
                this.playerPlacements.splice(placementIndex, 1);
            }
            
            if (this.game.squadExperienceSystem) {
                this.game.squadExperienceSystem.removeSquad(undoInfo.placementId);
            }
            
            this.game.gridSystem.freeCells(undoInfo.placementId);
            this.createUndoEffects(undoInfo);
            
            this.cachedValidation = null;
            this.cachedGridPos = null;
            
        } catch (error) {
            console.error('Undo failed:', error);
        }
    }

    createUndoEffects(undoInfo) {
        if (!this.game.effectsSystem) return;
        
        const maxEffects = Math.min(undoInfo.cells.length, 4);
        
        for (let i = 0; i < maxEffects; i++) {
            const cell = undoInfo.cells[i];
            const worldPos = this.game.gridSystem.gridToWorld(cell.x, cell.z);
            this.game.effectsSystem.createParticleEffect(
                worldPos.x,
                0,
                worldPos.z,
                'magic',
                { count: 3, speedMultiplier: 0.7 }
            );
        }
    }

    getPlacementById(placementId) {
        const playerPlacement = this.playerPlacements.find(placement => placement.placementId === placementId);
        if (playerPlacement) {
            return playerPlacement;
        }
        
        const opponentPlacement = this.opponentPlacements.find(placement => placement.placementId === placementId);
        if (opponentPlacement) {
            return opponentPlacement;
        }
        
        return null;
    }

    collectPlayerPlacements() {
        return this.playerPlacements;
    }

    initializeControls() {
        this.elements.readyButton = document.getElementById('placementReadyBtn');
        this.elements.undoButton = document.getElementById('undoBtn');

        if (this.config.enableUndo) {
            document.addEventListener('keydown', (event) => {
                if ((event.ctrlKey || event.metaKey) && event.key === 'z') {
                    event.preventDefault();
                    this.undoLastPlacement();
                }
            });
        }
        
        if (this.config.enablePreview && this.placementPreview) {
            let animationFrameId = null;
            let pendingMouseEvent = null;
            
            const throttledMouseMove = (event) => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                pendingMouseEvent = event;
                
                animationFrameId = requestAnimationFrame(() => {
                    if (this.game.state.now - this.lastUpdateTime < .08) {
                        return;
                    }
                    
                    this.lastUpdateTime = this.game.state.now;
                    if (this.game.state.phase === 'placement' && 
                        this.game.state.selectedUnitType && 
                        !this.isPlayerReady &&
                        pendingMouseEvent) {
                        
                        this.updatePlacementPreview(pendingMouseEvent);
                    }
                    
                    animationFrameId = null;
                    pendingMouseEvent = null;
                });
            };
            
            this.canvas.addEventListener('mousemove', throttledMouseMove);
            
            this.canvas.addEventListener('mouseleave', () => {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                
                this.placementPreview.clear();
                this.cachedValidation = null;
                this.cachedGridPos = null;
                document.body.style.cursor = 'default';
            });
        }
    }

    updatePlacementPreview(event) {
        if (!this.placementPreview) return;
        
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        this.lastMouseX = mouseX;
        this.lastMouseY = mouseY;
        
        const timeSinceLastRaycast = this.game.state.now - (this.lastRaycastTime || 0);
        const shouldRaycast = timeSinceLastRaycast > 0.15;
        
        let worldPosition;
        if (!shouldRaycast) {
            return;
        } else {
            worldPosition = this.getWorldPositionFromMouse(event, mouseX, mouseY);
            
            if (worldPosition) {
                this.cachedWorldPos = worldPosition;
                this.lastRaycastTime = this.game.state.now;
                this.lastRaycastMouseX = mouseX;
                this.lastRaycastMouseY = mouseY;
            }
        }
        
        if (!worldPosition) {
            this.placementPreview.clear();
            document.body.style.cursor = 'not-allowed';
            return;
        }
        
        const gridPos = this.game.gridSystem.worldToGrid(worldPosition.x, worldPosition.z);
        const state = this.game.state;
        
        let cells = [];
        let isValid = this.isValidGridPlacement(worldPosition);
        let unitPositions = null;

        if (state.selectedUnitType.collection === 'buildings') {
            cells = this.calculateBuildingCells(gridPos, state.selectedUnitType);            
        } else {
            const squadData = this.game.squadManager.getSquadData(state.selectedUnitType);
            cells = this.game.squadManager.getSquadCells(gridPos, squadData);
            if (this.game.squadManager.getSquadSize(squadData) > 1) {
                unitPositions = this.game.squadManager.calculateUnitPositions(gridPos, state.selectedUnitType);
            }
        }

        const worldPositions = cells.map(cell => 
            this.game.gridSystem.gridToWorld(cell.x, cell.z)
        );

        if (unitPositions && unitPositions.length > 0) {
            this.placementPreview.showWithUnitMarkers(worldPositions, unitPositions, isValid);
        } else {
            this.placementPreview.showAtWorldPositions(worldPositions, isValid);
        }

        document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';
    }

    getWorldPositionFromMouse(event, mouseX, mouseY) {
        if (!this.game.scene || !this.game.camera) return null;
        
        if (!this.mouse) {
            this.mouse = new THREE.Vector2();
        }
        
        if (mouseX !== undefined && mouseY !== undefined) {
            this.mouse.set(mouseX, mouseY);
        } else {
            const rect = this.canvas.getBoundingClientRect();
            this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        
        if (!this.raycaster) {
            this.raycaster = new THREE.Raycaster();
        }
        this.raycaster.setFromCamera(this.mouse, this.game.camera);
        
        const ray = this.raycaster.ray;
        
        if (Math.abs(ray.direction.y) < 0.0001) {
            return null;
        }
        
        const distance = (0 - ray.origin.y) / ray.direction.y;
        
        if (distance < 0) {
            return null;
        }
        
        const intersectionPoint = ray.origin.clone().add(
            ray.direction.clone().multiplyScalar(distance)
        );
        
        return intersectionPoint;
    }

    findGroundMesh() {
        if (this.game.worldSystem?.ground) {
            return this.game.worldSystem.ground;
        }
        
        for (let child of this.game.scene.children) {
            if (child.isMesh && child.geometry?.type === 'PlaneGeometry') {
                return child;
            }
        }
        return null;
    }

    getGroundMesh() {
        return this.findGroundMesh();
    }

    isValidGridPlacement(worldPos, unitDef) {
        const selectedUnitType = unitDef || this.game.state.selectedUnitType;
        
        let gridPos = this.game.gridSystem.worldToGrid(worldPos.x, worldPos.z);
        let cells = [];
        let isValid = false;
        let gridValid = false;

        if (selectedUnitType.collection === 'buildings') {
            cells = this.calculateBuildingCells(gridPos, selectedUnitType);
            
            if (selectedUnitType.id === 'goldMine') {
                const gridWidth = selectedUnitType.placementGridWidth || 2;
                const gridHeight = selectedUnitType.placementGridHeight || 2;
                const validation = this.game.goldMineSystem.isValidGoldMinePlacement(gridPos, gridWidth, gridHeight);
                isValid = validation.valid;
            } else {
                gridValid = this.game.gridSystem.isValidPlacement(cells, this.game.state.mySide);
                
                let terrainValid = true;
                cells.forEach((cell) => {
                    const terrainTypeId = this.game.terrainSystem.getTerrainTypeAtGridPosition(cell.x, cell.z);
                    if(!terrainTypeId) {
                        terrainValid = false;
                        return;
                    }
                    const terrainType = this.game.worldSystem.tileMap.terrainTypes[terrainTypeId];
                    
                    terrainValid = terrainValid && terrainType.buildable;
                });
                

                isValid = gridValid && terrainValid;
            }
        } else {
            const squadData = this.game.squadManager.getSquadData(selectedUnitType);
            cells = this.game.squadManager.getSquadCells(gridPos, squadData);
            gridValid = this.game.gridSystem.isValidPlacement(cells, this.game.state.mySide);
            isValid = gridValid;
        }
        return isValid;
    }

    addToUndoStack(undoInfo) {
        if (!this.config.enableUndo) return;
        
        this.undoStack.push(undoInfo);
        
        if (this.undoStack.length > this.maxUndoSteps) {
            this.undoStack.shift();
        }
    }

    clearUndoStack() {
        this.undoStack = [];
    }

    getUndoStatus() {
        return {
            canUndo: this.undoStack.length > 0 && this.config.enableUndo && !this.isPlayerReady,
            undoCount: this.undoStack.length,
            maxUndoSteps: this.maxUndoSteps,
            lastAction: this.undoStack.length > 0 ? this.undoStack[this.undoStack.length - 1] : null
        };
    }

    setTeamSides(sides) {
        this.teamSides = {
            player: sides?.player || 'left',
            enemy: sides?.enemy || 'right'
        };
    }

    calculateBuildingCells(gridPos, building) {
        const cells = [];
        const gridWidth = building.placementGridWidth || 1;
        const gridHeight = building.placementGridHeight || 1;
        const startX = gridPos.x - Math.floor(gridWidth / 2);
        const startZ = gridPos.z - Math.floor(gridHeight / 2);

        for (let z = 0; z < gridHeight; z++) {
            for (let x = 0; x < gridWidth; x++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    updateCursorState(isValid) {
        if (this.isPlayerReady) {
            document.body.style.cursor = 'not-allowed';
        } else if (this.game.state.selectedUnitType) {
            document.body.style.cursor = isValid ? 'crosshair' : 'not-allowed';
        } else {
            document.body.style.cursor = 'default';
        }
    }

    onBattleEnd() {        
        this.removeDeadSquadsAfterRound();
    }
        
    removeDeadSquadsAfterRound() {
        if (!this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        this.playerPlacements = this.filterDeadSquads(this.playerPlacements, ComponentTypes);
        this.opponentPlacements = this.filterDeadSquads(this.opponentPlacements, ComponentTypes);
    }

    filterDeadSquads(placements, ComponentTypes) {
        return placements.filter(placement => {
            if (!placement.squadUnits || placement.squadUnits.length === 0) {
                this.cleanupDeadSquad(placement);
                return false;
            }

            const aliveUnits = placement.squadUnits.filter(entityId => {
                const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
                if(buildingState) return true;
                return health && health.current > 0 && (!deathState || !deathState.isDying);
            });

            if (aliveUnits.length === 0) {
                this.cleanupDeadSquad(placement);
                return false;
            }

            placement.squadUnits = aliveUnits;
            return true;
        });
    }

    cleanupDeadSquad(placement) {
        if (this.game.gridSystem && placement.placementId) {
            this.game.gridSystem.freeCells(placement.placementId);
        }

        if (this.game.squadExperienceSystem && placement.placementId) {
            this.game.squadExperienceSystem.removeSquad(placement.placementId);
        }
    }

    updateGridPositionsAfterRound() {
        if (!this.game.gridSystem || !this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        this.game.gridSystem.clear();

        [this.playerPlacements, this.opponentPlacements].forEach(placements => {
            placements.forEach(placement => {
                if (!placement.squadUnits || placement.squadUnits.length === 0) return;

                const aliveUnits = placement.squadUnits.filter(entityId => {
                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                    return health && health.current > 0 && (!deathState || !deathState.isDying);
                });

                if (aliveUnits.length === 0) return;

                const positions = aliveUnits.map(entityId => {
                    const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
                    return pos ? { x: pos.x, z: pos.z } : null;
                }).filter(p => p !== null);

                if (positions.length === 0) return;

                const avgX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
                const avgZ = positions.reduce((sum, p) => sum + p.z, 0) / positions.length;
                const newGridPos = this.game.gridSystem.worldToGrid(avgX, avgZ);

                if (this.game.gridSystem.isValidPosition(newGridPos)) {
                    placement.gridPosition = newGridPos;
                    placement.squadUnits = aliveUnits;

                    const squadData = this.game.squadManager?.getSquadData(placement.unitType);
                    if (squadData) {
                        const cells = this.game.squadManager.getSquadCells(newGridPos, squadData);
                        placement.cells = cells;
                        this.game.gridSystem.occupyCells(cells, placement.placementId);
                    }
                }
            });
        });
    }

    resetAllPlacements() {
        if (this.game.squadExperienceSystem) {
            this.game.squadExperienceSystem.reset();
        }
        
        this.playerPlacements = [];
        this.opponentPlacements = [];
        this.isPlayerReady = false;
        this.hasSubmittedPlacements = false;
        this.clearUndoStack();
        this.game.gridSystem.clear();
        
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        this.groundMeshCache = this.findGroundMesh();
        
        if (this.placementPreview) {
            this.placementPreview.clear();
        }
    }

    dispose() {
        this.cachedValidation = null;
        this.cachedGridPos = null;
        this.groundMeshCache = null;
        
        if (this.placementPreview) {
            this.placementPreview.dispose();
        }
                
        this.resetAllPlacements();
    }

    getUnitAtWorldPosition(worldPos) {
        const clickRadius = 30;
        let closestEntityId = null;
        let closestDistance = clickRadius;
        
        const entities = this.game.getEntitiesWith(
            this.game.componentManager.getComponentTypes().POSITION,
            this.game.componentManager.getComponentTypes().TEAM
        );
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            const team = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().TEAM);
            
            const dx = pos.x - worldPos.x;
            const dz = pos.z - worldPos.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestEntityId = entityId;
            }
        });
        
        return closestEntityId;
    }
};

// System: ShopSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ShopSystem'] = class ShopSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.shopSystem = this;
        
        this.ownedBuildings = new Map();
        this.buildingUpgrades = new Map();
        this.buildingProductionProgress = new Map();
        this.game.state.selectedEntity = {
            "collection": null,
            "entityId": null
        };
        this.townHallLevel = 0;
        
        this.lastExperienceUpdate = 0;
        this.uiEnhancements = new GUTS.FantasyUIEnhancements(game);
    }

    createShop() {
        this.renderActionPanel();
        this.createExperiencePanel();
    }

    renderActionPanel() {
        const container = document.getElementById('actionPanel');
        if (!container) return;
        container.innerHTML = '';

        if (this.game.state.selectedEntity.collection == 'buildings') {
            this.renderBuildingActions(container);
        } 
    }

    clearSelectedEntity() {    
        this.game.state.selectedEntity.entityId = null;
        this.game.state.selectedEntity.collection = null;
    }

    renderBuildingActions(placement) {
        const building = placement.unitType;
        const container = document.getElementById('actionPanel');  
        if (!container) return;
        container.innerHTML = '';
        if (!building) {
            this.clearSelectedEntity();
            return;
        }

        // const header = document.createElement('div');
        // header.className = 'action-panel-header';
        // header.innerHTML = `
        //     <button class="deselect-btn" id="deselectBtn">←</button>
        //     <span>${building.icon || '🏛️'} ${building.title}</span>
        // `;
        // container.appendChild(header);

        // document.getElementById('deselectBtn').addEventListener('click', () => {
        //     this.clearSelectedEntity();
        //     this.createShop();
        // });

       
        const buildingId = this.game.state.selectedEntity.entityId;
        if(this.buildingProductionProgress.has(buildingId)){
            const hasUnits = building.units && building.units.length > 0;
            const hasUpgrades = building.upgrades && building.upgrades.length > 0;
            if (hasUnits) {
                const unitsSection = this.createUnitsSection(building);
                container.appendChild(unitsSection);
            }

            if (hasUpgrades) {
                const upgradesSection = this.createUpgradesSection(building);
                container.appendChild(upgradesSection);
            }

            if (!hasUnits && !hasUpgrades) {
                const empty = document.createElement('div');
                empty.className = 'action-empty';
                empty.textContent = 'No actions available';
                container.appendChild(empty);
            }
        } else {
            const empty = document.createElement('div');
            empty.className = 'action-empty';
            empty.textContent = 'Under Construction';
            container.appendChild(empty);
        }
        
        container.removeAttribute('style');
    }

    createUnitsSection(building) {
        const section = document.createElement('div');
        section.className = 'action-section';

        // const header = document.createElement('div');
        // header.className = 'action-section-header';
        // header.textContent = 'RECRUIT';
        // section.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'action-grid';
        const UnitTypes = this.game.getCollections().units;
        
        const buildingId = this.game.state.selectedEntity.entityId;
        const productionProgress = this.buildingProductionProgress.get(buildingId);
        const remainingCapacity = 1 - productionProgress;
        
        building.units.forEach(unitId => {
            const unit = UnitTypes[unitId];
            const buildTime = unit.buildTime || 1;
            const canAfford = this.game.state.playerGold >= unit.value;
            const hasCapacity = buildTime <= remainingCapacity + 0.001;
            
            let locked = !canAfford || !hasCapacity;
            let lockReason = null;
            if (!canAfford) {
                lockReason = "Can't afford";
            } else if (!hasCapacity) {
                lockReason = `Need ${buildTime.toFixed(1)} rounds`;
            }
            
            const btn = this.createActionButton({
                iconId: unit.icon,
                title: unit.title,
                cost: unit.value,
                buildTime: buildTime,
                locked: locked,
                lockReason: lockReason,
                onClick: () => this.purchaseUnit(unitId, unit)
            });
            grid.appendChild(btn);
        });

        section.appendChild(grid);
        return section;
    }

    createUpgradesSection(building) {
        const section = document.createElement('div');
        section.className = 'action-section';

        const header = document.createElement('div');
        header.className = 'action-section-header';
        header.textContent = 'UPGRADES';
        section.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'action-grid';

        const buildingId = this.game.state.selectedEntity.entityId;
        const purchasedUpgrades = this.buildingUpgrades.get(buildingId) || new Set();

        building.upgrades.forEach(upgradeId => {
            const upgrade = this.game.getCollections().upgrades[upgradeId];
            if (!upgrade) return;

            const isOwned = purchasedUpgrades.has(upgradeId);
            const locked = isOwned || this.game.state.playerGold < upgrade.value;

            const btn = this.createActionButton({
                icon: upgrade.icon || '⭐',
                title: upgrade.title,
                cost: upgrade.value,
                locked: locked,
                lockReason: isOwned ? 'Owned' : (locked ? "Can't afford" : null),
                owned: isOwned,
                onClick: () => !isOwned && this.purchaseUpgrade(upgradeId, upgrade, buildingId)
            });
            grid.appendChild(btn);
        });

        section.appendChild(grid);
        return section;
    }

    createActionButton(options) {
        const {
            iconId,
            title,
            cost,
            buildTime,
            locked = false,
            lockReason = null,
            onClick
        } = options;

        const btn = document.createElement('button');
        btn.className = 'action-btn';
        if (locked) btn.classList.add('locked');

        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(iconId){
            const icon = this.game.getCollections().icons[iconId];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  '⚔️';
            }
        } else {
            iconEl.textContent =  '⚔️';
        }

        
        btn.appendChild(iconEl);
        let costTxt = `💰 ${cost}`;
        if (lockReason) {
            costTxt = lockReason;
        } 
        btn.title = `${title} ${costTxt}`;
        

        if (!locked) {
            btn.addEventListener('click', onClick);
        }

        return btn;
    }

    isBuildingLocked(buildingId, building) {
        return this.game.state.playerGold < building.value ||
               (building.requires && !this.hasRequirements(building.requires));
    }

    getLockReason(buildingId, building) {
        if (this.game.state.playerGold < building.value) return "Can't afford";
        if (building.requires && !this.hasRequirements(building.requires)) {
            return 'Missing requirements';
        }
        return null;
    }

    hasRequirements(requirements) {
        if (requirements.townHallLevel) {
            if (this.townHallLevel < requirements.townHallLevel) return false;
        }
        if (requirements.buildings) {
            for (const reqBuilding of requirements.buildings) {
                if (!this.ownedBuildings.has(reqBuilding)) return false;
            }
        }
        return true;
    }

    addBuilding(buildingId, entityId){
        if(!this.ownedBuildings.has(buildingId)){
            this.ownedBuildings.set(buildingId, [entityId]);
        } else {
            this.ownedBuildings.get(buildingId).push(entityId)            
        }

        this.buildingProductionProgress.set(entityId, 0);
        this.buildingUpgrades.set(buildingId, new Set());
        this.createShop();
        
    }

    purchaseUnit(unitId, unit) {
        const buildingId = this.game.state.selectedEntity.entityId;
        const placementId = this.getBuildingPlacementId(buildingId);
        
        if (!placementId) {
            console.log('no building selected');
            this.showNotification('No building selected!', 'error');
            return;
        }

        const buildTime = unit.buildTime || 1;
        const productionProgress = this.buildingProductionProgress.get(buildingId);
        const remainingCapacity = 1 - productionProgress;
        
        if (buildTime > remainingCapacity + 0.001) {
            this.showNotification(`Not enough production capacity! Need ${buildTime.toFixed(1)} rounds`, 'error');
            return;
        }

        unit.id = unitId;
        unit.collection = 'units';
        const placementPos = this.findBuildingPlacementPosition(placementId, unit);
        if (!placementPos) {
            console.log('no valid placement');
            this.showNotification('No valid placement near building!', 'error');
            return;
        }
        const placement = this.game.placementSystem.createPlacementData(placementPos, unit, this.game.state.mySide);
        
        this.game.networkManager.submitPlacement(placement, (success, response) => {
            if(success){
                const newProgress = productionProgress + buildTime;
                this.buildingProductionProgress.set(buildingId, newProgress);
                this.game.placementSystem.placeSquad(placement);                
                this.createShop();
            }
        });       
    }

    findBuildingPlacementPosition(placementId, unitDef) {
        const buildingGridPos = this.getBuildingGridPosition(placementId);
        const placement = this.game.placementSystem.getPlacementById(placementId);
        if (!buildingGridPos) return null;

        const gridSystem = this.game.gridSystem;
        const placementSystem = this.game.placementSystem;
        if (!gridSystem || !placementSystem) return null;

        const buildingCells = placement.cells || [];
        const buildingCellSet = new Set(buildingCells.map(cell => `${cell.x},${cell.z}`));

        const searchRadius = 12;
        const spiralOffsets = this.generateSpiralOffsets(searchRadius);

        for (const offset of spiralOffsets) {
            const testPos = {
                x: buildingGridPos.x + offset.x,
                z: buildingGridPos.z + offset.z
            };
            
            const testCellKey = `${testPos.x},${testPos.z}`;
            if (buildingCellSet.has(testCellKey)) {
                continue;
            }
            
            const unitSquadData = this.game.squadManager.getSquadData(unitDef);
            const unitCells = this.game.squadManager.getSquadCells(testPos, unitSquadData);
            
            const overlapsBuilding = unitCells.some(cell => 
                buildingCellSet.has(`${cell.x},${cell.z}`)
            );
            
            if (overlapsBuilding) {
                continue;
            }

            const worldPos = gridSystem.gridToWorld(testPos.x, testPos.z);
            if (placementSystem.isValidGridPlacement(worldPos, unitDef)) {
                return testPos;
            }
        }

        return null;
    }

    generateSpiralOffsets(maxRadius) {
        const offsets = [];
        let x = 0, z = 0;
        let dx = 0, dz = -1;
        
        for (let i = 0; i < (maxRadius * 2) * (maxRadius * 2); i++) {
            if ((-maxRadius < x && x <= maxRadius) && (-maxRadius < z && z <= maxRadius)) {
                offsets.push({ x, z });
            }
            
            if (x === z || (x < 0 && x === -z) || (x > 0 && x === 1 - z)) {
                const temp = dx;
                dx = -dz;
                dz = temp;
            }
            
            x += dx;
            z += dz;
        }
        
        return offsets;
    }

    getBuildingPlacementId(buildingId) {
        const state = this.game.state;
        const mySide = state.mySide;
        const placements = this.game.placementSystem.getPlacementsForSide(mySide);
        if (!placements) return null;

        for (const [placementIndex, placement] of Object.entries(placements)) {
            for(const squadUnit of placement.squadUnits){
                if (squadUnit === buildingId) {
                    return placement.placementId;
                }
            }
        }
        return null;
    }

    getBuildingGridPosition(placementId) {
        const placement = this.game.placementSystem.getPlacementById(placementId);
        console.log('got placement', placement);
        return placement.gridPosition;
    }

    purchaseUpgrade(upgradeId, upgrade) {
        this.game.networkManager.purchaseUpgrade({ 
            upgradeId, 
            buildingId: this.game.state.selectedEntity.entityId 
        }, (success, response) => {
            if (success) {
                if (!this.buildingUpgrades.has(this.game.state.selectedEntity.entityId)) {
                    this.buildingUpgrades.set(this.game.state.selectedEntity.entityId, new Set());
                }
                this.buildingUpgrades.get(this.game.state.selectedEntity.entityId).add(upgradeId);
                this.game.state.playerGold -= upgrade.value;
                this.applyUpgradeEffects(this.game.state.mySide, upgrade);
                this.showNotification(`${upgrade.title} purchased!`, 'success');
            }
        });
    }

    applyUpgradeEffects(team, upgrade) {
        if (upgrade.effects) {
            upgrade.effects.forEach(effectId => {
                const effect = this.game.getCollections().effects[effectId];
                if (effect) {
                    effect.id = effectId;
                    this.applyEffect(team, effect);
                }
            });
        }
    }

    applyEffect(team, effectData) {
        if(!this.game.state.teams){
            this.game.state.teams = {};
        }
        if(!this.game.state.teams[team]) {
            this.game.state.teams[team] = {};
        } 
        if(!this.game.state.teams[team].effects) {
            this.game.state.teams[team].effects = {};
        }
        this.game.state.teams[team].effects[effectData.id] = effectData;
    }

    onPlacementPhaseStart() {
        this.ownedBuildings.keys().forEach(buildingType => {
            this.ownedBuildings.get(buildingType).forEach((buildingEntityId) => {
                this.buildingProductionProgress.set(buildingEntityId, 0);
            });
        });
        this.createShop();
    }

    createExperiencePanel() {
        if (!this.game.squadExperienceSystem) return;
        
        const container = document.getElementById('unitPromotions');
        if (!container) return;
        
        container.innerHTML = '';

        const squadsReadyToLevelUp = this.game.squadExperienceSystem.getSquadsReadyToLevelUp();
        
        if (squadsReadyToLevelUp.length === 0) return;

        squadsReadyToLevelUp.forEach(squad => {
            const panel = this.createExperienceCard(squad);
            if (panel) {
                container.appendChild(panel);
            }
        });
    }

    createExperienceCard(squad) {
        const currentUnitType = this.getCurrentUnitType(squad.placementId, squad.team);
        if (!currentUnitType) return null;

        const hasSpecializations = currentUnitType.specUnits && currentUnitType.specUnits.length > 0;
        const isSpecializationLevel = (squad.level) == 2;
        const canSpecialize = isSpecializationLevel && hasSpecializations;
        
        const card = document.createElement('div');
        card.className = 'experience-panel';

        if (canSpecialize) {
            const shimmer = document.createElement('div');
            shimmer.classList.add("shimmer");
            card.appendChild(shimmer);
        }

        const currentLevelText = ` (Lvl ${squad.level})`;
        const nextLevelText = canSpecialize ? '⭐ Ascend!' : ` Level ${squad.level + 1}`;

        const header = document.createElement('div');
        header.className = 'experience-header';

        const unitIcon = document.createElement('div');
        unitIcon.className = 'experience-unit-icon';
        unitIcon.textContent = currentUnitType.icon || '⚔️';
        header.appendChild(unitIcon);

        const info = document.createElement('div');
        info.className = 'experience-info';

        const title = document.createElement('div');
        title.className = 'experience-title';
        title.textContent = this.getSquadDisplayName(squad.placementId);
        info.appendChild(title);

        const subtitle = document.createElement('div');
        subtitle.className = 'experience-subtitle';
        subtitle.textContent = `${currentUnitType.title}${currentLevelText}`;
        info.appendChild(subtitle);

        header.appendChild(info);
        card.appendChild(header);

        const progress = document.createElement('div');
        progress.className = 'experience-progress';

        const progressBar = document.createElement('div');
        progressBar.className = 'experience-progress-bar';

        const progressFill = document.createElement('div');
        progressFill.className = 'experience-progress-fill';
        progressFill.style.width = '100%';
        progressBar.appendChild(progressFill);

        progress.appendChild(progressBar);

        const xpText = document.createElement('div');
        xpText.className = 'experience-xp-text';
        xpText.textContent = 'Ready to advance!';
        progress.appendChild(xpText);

        card.appendChild(progress);

        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'experience-buttons';

        if (canSpecialize) {
            const specBtn = document.createElement('button');
            specBtn.className = 'btn btn-primary experience-btn';
            specBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;
            specBtn.onclick = () => {
                if (this.game.squadExperienceSystem) {
                    this.game.squadExperienceSystem.showSpecializationSelection(
                        squad.placementId, 
                        squad, 
                        squad.levelUpCost
                    );
                }
            };
            buttonContainer.appendChild(specBtn);
        } else {
            const levelUpBtn = document.createElement('button');
            levelUpBtn.className = 'btn btn-primary experience-btn';
            levelUpBtn.innerHTML = `${nextLevelText} (${squad.levelUpCost}g)`;
            levelUpBtn.onclick = () => {
                if (this.game.squadExperienceSystem) {
                    this.game.squadExperienceSystem.levelUpSquad(squad.placementId, squad.team);
                }
            };
            buttonContainer.appendChild(levelUpBtn);
        }

        card.appendChild(buttonContainer);
        return card;
    }

    getCurrentUnitType(placementId, team) {
        const state = this.game.state;
        const placement = state.placements?.[team]?.[placementId];
        if (!placement) return null;
        
        const UnitTypes = this.game.getCollections().units;
        return placement.unitType ? UnitTypes[placement.unitType] : null;
    }

    getSquadDisplayName(placementId) {
        const match = placementId.match(/^([a-z]+)_(\d+)$/);
        if (match) {
            const side = match[1];
            const index = parseInt(match[2], 10);
            const sideLabel = side === 'left' ? 'Left' : side === 'right' ? 'Right' : side === 'center' ? 'Center' : 'Unknown';
            return `${sideLabel} Squad ${index + 1}`;
        }
        return placementId;
    }

    showNotification(message, type) {
        if (this.uiEnhancements) {
            this.uiEnhancements.showNotification(message, type);
        } 
    }

    update() {
        const state = this.game.state;
        const inPlacementPhase = state.phase === 'placement';
        
        if (inPlacementPhase && this.game.squadExperienceSystem) {
            if (this.game.state.now - this.lastExperienceUpdate > 2) {
                const squadsReadyToLevelUp = this.game.squadExperienceSystem.getSquadsReadyToLevelUp();
                const hasReadySquads = squadsReadyToLevelUp.length > 0;
                const hasExperiencePanel = document.querySelector('.experience-panel') !== null;
                
                if (hasReadySquads !== hasExperiencePanel) {
                    this.createExperiencePanel();
                }
                
                this.lastExperienceUpdate = this.game.state.now;
            }
        }
    }

    reset() {
        this.clearSelectedEntity();
    }

  
};

// System: TeamHealthSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['TeamHealthSystem'] = class TeamHealthSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.teamHealthSystem = this;
        
        
        // Team health configuration
        this.MAX_TEAM_HEALTH = 2500;
        this.teamHealth = {
            left: this.MAX_TEAM_HEALTH,
            right: this.MAX_TEAM_HEALTH
        };
        
        // Track if we've already processed this round's result
        this.roundProcessed = false;
        
        if(!this.game.isServer){
            console.log('this.game', this.game);
            this.initializeUI();
        }
    }
    
    initializeUI() {
        // Delay creation to ensure DOM is ready
        setTimeout(() => {
            this.updateHealthDisplay();
        }, 100);
    }
    
    updateHealthDisplay() {
        const playerFill = document.getElementById('playerHealthFill');
        const playerText = document.getElementById('playerHealthText');
        const opponentFill = document.getElementById('opponentHealthFill');
        const opponentText = document.getElementById('opponentHealthText');
        
        let myHealth = this.teamHealth[this.game.state.mySide] || this.MAX_TEAM_HEALTH;
        let opponentHealth = this.teamHealth[this.game.state.mySide == 'left' ? 'right' : 'left'] || this.MAX_TEAM_HEALTH;
        if (playerFill && playerText) {
            const playerPercent = (myHealth / this.MAX_TEAM_HEALTH) * 100;
            playerFill.style.width = `${playerPercent}%`;
            playerText.textContent = `${myHealth}/${this.MAX_TEAM_HEALTH}`;
        }
        
        if (opponentFill && opponentText) {
            const opponentPercent = (opponentHealth / this.MAX_TEAM_HEALTH) * 100;
            opponentFill.style.width = `${opponentPercent}%`;
            opponentText.textContent = `${opponentHealth}/${this.MAX_TEAM_HEALTH}`;
        }
    }
    
    onBattleStart() {
        this.roundProcessed = false;
     
    }
    
    // Apply damage when PhaseSystem tells us a round ended
    applyRoundDamage(winningTeam, survivingUnits) {
        
        // Calculate damage based on surviving squads' base values
        const damageResult = this.calculateSquadBasedDamage(survivingUnits);
        const losingTeam = winningTeam === 'left' ? 'right' : 'left';
        
        // Apply damage to losing team
        this.dealDamageToTeam(losingTeam, damageResult.totalDamage);
        
        // Return result object
        return {
            result: winningTeam === this.game.state.mySide ? 'victory' : 'defeat',
            winningTeam: winningTeam,
            losingTeam: losingTeam,
            damage: damageResult.totalDamage,
            survivingSquads: damageResult.survivingSquads,
            gameOver: this.teamHealth[losingTeam] <= 0,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    // Apply no damage for draws
    applyRoundDraw() {
        if (this.roundProcessed) return null;
        this.roundProcessed = true;

        
        // Return draw result
        return {
            result: 'draw',
            winningTeam: null,
            losingTeam: null,
            damage: 0,
            gameOver: false,
            remainingHealth: {
                left: this.teamHealth.left,
                right: this.teamHealth.right
            }
        };
    }
    
    /**
     * Calculate damage based on squads, not individual units
     * If ANY units from a squad survive, the entire squad's base value counts as damage
     * @param {Array} survivingUnits - Array of surviving unit entity IDs
     * @returns {Object} Damage calculation results
     */
    calculateSquadBasedDamage(survivingUnits) {
        const squadMap = new Map(); // squadId -> {unitType, survivors, totalUnits}
        let totalDamage = 0;
        let survivingSquadCount = 0;
        const squadDetails = [];
        if(!survivingUnits){ 
            return {
                totalDamage: 0,
                survivingSquads: 0,
                squadDetails: []
            };
        }
        // Group surviving units by their squad placement ID
        survivingUnits.forEach(unitId => {
            // Find which squad this unit belongs to
            const squadInfo = this.findSquadForUnit(unitId);
            if (squadInfo) {
                const { placementId, unitType } = squadInfo;
                
                if (!squadMap.has(placementId)) {
                    squadMap.set(placementId, {
                        unitType: unitType,
                        survivors: 0,
                        totalUnits: this.getOriginalSquadSize(placementId),
                        placementId: placementId
                    });
                }
                
                squadMap.get(placementId).survivors++;
            }
        });
        
        // Calculate damage for each squad that has survivors
        squadMap.forEach((squadData, placementId) => {
            if (squadData.survivors > 0) {
                // Entire squad's base value counts as damage
                const squadBaseDamage = squadData.unitType.value || 50;
                totalDamage += squadBaseDamage;
                survivingSquadCount++;
                
                squadDetails.push({
                    name: squadData.unitType.title || squadData.unitType.id || 'Unknown Squad',
                    damage: squadBaseDamage,
                    survivingUnits: squadData.survivors,
                    totalUnits: squadData.totalUnits,
                    placementId: placementId
                });
                
            }
        });
        
        return {
            totalDamage: totalDamage,
            survivingSquads: survivingSquadCount,
            squadDetails: squadDetails
        };
    }
    
    /**
     * Find which squad a unit belongs to
     * @param {number} unitId - Unit entity ID
     * @returns {Object|null} Squad info or null
     */
    findSquadForUnit(unitId) {
        // Check with experience system first (most reliable)
        if (this.game.squadExperienceSystem) {
            const squadData = this.game.squadExperienceSystem.findSquadByUnitId(unitId);
            if (squadData) {
                const unitType = this.getCurrentUnitTypeForSquad(squadData.placementId);
                return {
                    placementId: squadData.placementId,
                    unitType: unitType || { value: squadData.squadValue, title: 'Unknown', id: 'unknown' }
                };
            }
        }
        
        // Fallback: search placement system
        if (this.game.placementSystem) {
            const allPlacements = [
                ...this.game.placementSystem.playerPlacements,
                ...this.game.placementSystem.opponentPlacements
            ];
            
            for (const placement of allPlacements) {
                if (placement.squadUnits) {
                    const unitMatch = placement.squadUnits.find(entityId => entityId === unitId);
                    if (unitMatch) {
                        return {
                            placementId: placement.placementId,
                            unitType: placement.unitType
                        };
                    }
                } 
            }
        }
        
        // Last resort: use unit type component directly
        const unitTypeComponent = this.game.getComponent(unitId, this.componentTypes.UNIT_TYPE);
        if (unitTypeComponent) {
            return {
                placementId: `unknown_${unitId}`,
                unitType: {
                    value: unitTypeComponent.value || 50,
                    title: unitTypeComponent.type || 'Unknown Unit',
                    id: unitTypeComponent.id || 'unknown'
                }
            };
        }
        
        return null;
    }
    
    /**
     * Get the current unit type for a squad (handles specializations)
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Current unit type
     */
    getCurrentUnitTypeForSquad(placementId) {
        if (this.game.squadExperienceSystem && this.game.squadExperienceSystem.getCurrentUnitType) {
            return this.game.squadExperienceSystem.getCurrentUnitType(placementId);
        }
        
        // Fallback to placement system
        if (this.game.placementSystem) {
            const placement = this.game.placementSystem.playerPlacements.find(p => p.placementId === placementId) ||
                             this.game.placementSystem.opponentPlacements.find(p => p.placementId === placementId);
            return placement ? placement.unitType : null;
        }
        
        return null;
    }
    
    /**
     * Get the original size of a squad when it was placed
     * @param {string} placementId - Squad placement ID
     * @returns {number} Original squad size
     */
    getOriginalSquadSize(placementId) {
        // Check experience system first
        if (this.game.squadExperienceSystem) {
            const squadData = this.game.squadExperienceSystem.squadExperience.get(placementId);
            if (squadData) {
                return squadData.totalUnitsInSquad || squadData.squadSize;
            }
        }
        
        // Fallback to placement system
        if (this.game.placementSystem) {
            const placement = this.game.placementSystem.playerPlacements.find(p => p.placementId === placementId) ||
                             this.game.placementSystem.opponentPlacements.find(p => p.placementId === placementId);
            if (placement) {
                return placement.squadUnits ? placement.squadUnits.length : 1;
            }
        }
        
        return 1; // Default fallback
    }
    
    dealDamageToTeam(team, damage) {
        this.teamHealth[team] = Math.max(0, this.teamHealth[team] - damage);
        if(!this.game.isServer){
            this.updateHealthDisplay();
            this.showDamageEffect(team, damage);
        }
    }
    
    showDamageEffect(team, damage) {
        // Create floating damage text
        const damageText = document.createElement('div');
        damageText.className = `damage-popup ${team}-damage`;
        damageText.textContent = `-${damage}`;
        
        // Position based on team
        const healthBar = document.querySelector(`.${team}-health`);
        if (healthBar) {
            const rect = healthBar.getBoundingClientRect();
            damageText.style.position = 'fixed';
            damageText.style.left = `${rect.left + rect.width / 2}px`;
            damageText.style.top = `${rect.top}px`;
            damageText.style.zIndex = '1000';
            
            document.body.appendChild(damageText);
            
            // Animate and remove
            setTimeout(() => {
                if (damageText.parentNode) {
                    damageText.parentNode.removeChild(damageText);
                }
            }, 2000);
        }
    }
    
    resetTeamHealth() {
        this.teamHealth.left = this.MAX_TEAM_HEALTH;
        this.teamHealth.right = this.MAX_TEAM_HEALTH;
        this.roundProcessed = false;
        this.updateHealthDisplay();
    }
    
    getTeamHealth(team) {
        return this.teamHealth[team] || 0;
    }
    
    getHealthPercentage(team) {
        return (this.teamHealth[team] / this.MAX_TEAM_HEALTH) * 100;
    }
    
    // Get health status for UI
    getHealthStatus() {
        return {
            left: {
                current: this.teamHealth.left,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('left')
            },
            right: {
                current: this.teamHealth.right,
                max: this.MAX_TEAM_HEALTH,
                percentage: this.getHealthPercentage('right')
            }
        };
    }

    getLeftHealth() {
        return this.teamHealth.left || 0;
    }

    // Method for multiplayer compatibility - returns current right health  
    getRightHealth() {
        return this.teamHealth.right || 0;
    }

    // Method to set left health (for multiplayer server updates)
    setLeftHealth(health) {
        this.teamHealth.left = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Method to set right health (for multiplayer server updates)
    setRightHealth(health) {
        this.teamHealth.right = Math.max(0, Math.min(health, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Multiplayer-specific method to sync both team healths from server
    syncHealthFromServer(leftHealth, rightHealth) {
        this.teamHealth.left = Math.max(0, Math.min(leftHealth, this.MAX_TEAM_HEALTH));
        this.teamHealth.right = Math.max(0, Math.min(rightHealth, this.MAX_TEAM_HEALTH));
        this.updateHealthDisplay();
    }

    // Check if either team is eliminated (for multiplayer game end conditions)
    isGameOver() {
        return this.teamHealth.left <= 0 || this.teamHealth.right <= 0;
    }

    // Get the winning team (for multiplayer results)
    getWinningTeam() {
        if (this.teamHealth.left <= 0) return 'right';
        if (this.teamHealth.right <= 0) return 'left';
        return null; // No winner yet
    }
};

// System: HealthBarSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['HealthBarSystem'] = class HealthBarSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.healthBarSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Health bar configuration
        this.HEALTH_BAR_WIDTH = 32;
        this.HEALTH_BAR_HEIGHT = 4;
        this.HEALTH_BAR_OFFSET_Y = 50; // Units above unit
        this.BACKGROUND_DEPTH = 2; // Slight offset to prevent z-fighting
        
        // Track health bar meshes
        this.healthBars = new Map(); // entityId -> { background, fill, group, lastHealth }
        
        // Initialize only after world system is ready
        this.initialized = false;
    }
    
    initialize() {
        if (this.initialized || !this.game.scene) return;
        
        this.initialized = true;
        console.log('Simple Quad HealthBarSystem initialized');
    }
    
    update() {
        // Wait for scene to be available from WorldSystem
        if (!this.game.scene || !this.game.camera) {
            return;
        }
        
        // Initialize if not done yet
        if (!this.initialized) {
            this.initialize();
        }
        
        // Get all entities with health and position
        const healthEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.HEALTH,
            this.componentTypes.UNIT_TYPE
        );
        
        // Update existing health bars and create new ones
        healthEntities.forEach(entityId => {
            const pos    = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const health = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const team   = this.game.getComponent(entityId, this.componentTypes.TEAM);
            if (!pos || !health) return;

            // === Fog-of-war visibility filter (enemies only) ===
            const isEnemy = this.isEnemy(team);
            const isVisible = !isEnemy || this.isVisibleAt(pos);

            // If enemy not visible: hide existing bar (if any) and skip work
            if (!isVisible) {
                const hb = this.healthBars.get(entityId);
                if (hb) hb.group.visible = false;
                return;
            }
            // Coming back into vision: unhide if we already have one
            const existing = this.healthBars.get(entityId);
            if (existing) existing.group.visible = true;
            // === end FOW filter ===

            // Create health bar if it doesn't exist
            if (!existing) {
                this.createHealthBarMesh(entityId, team);
            }

            // Update health bar
            this.updateHealthBarMesh(entityId, pos, health, team);
        });
        
        // Clean up health bars for destroyed entities
        this.cleanupRemovedHealthBars(healthEntities);
    }
    
    createHealthBarMesh(entityId, team) {
        // Create group to hold both background and fill
        const group = new THREE.Group();
        
        // Create background quad (dark background)
        const backgroundGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);
        const backgroundMaterial = new THREE.MeshBasicMaterial({
            color: 0x222222
        });
        const background = new THREE.Mesh(backgroundGeometry, backgroundMaterial);
        background.position.z = -this.BACKGROUND_DEPTH; // Slightly behind
        
        // Create health fill quad
        const fillGeometry = new THREE.PlaneGeometry(this.HEALTH_BAR_WIDTH, this.HEALTH_BAR_HEIGHT);
        const fillMaterial = new THREE.MeshBasicMaterial({
            color: this.getHealthColor(team)
        });
        const fill = new THREE.Mesh(fillGeometry, fillMaterial);
        
        // Add both to group
        group.add(background);
        group.add(fill);
        
        // Add to scene
        this.game.scene.add(group);
        
        // Store references
        this.healthBars.set(entityId, {
            background: background,
            fill: fill,
            group: group,
            fillGeometry: fillGeometry,
            fillMaterial: fillMaterial,
            lastHealth: -1, // Force initial update
            lastHealthPercent: -1,
            lastMaxHealth: -1, // Track max health changes for notch updates
            notches: [] // Array to hold notch meshes
        });
        
        // Set high render order to ensure health bars render on top of everything
        background.renderOrder = 9999;
        fill.renderOrder = 10000;
    }
    
    updateHealthBarMesh(entityId, pos, health, team) {
        const healthBarData = this.healthBars.get(entityId);
        if (!healthBarData) return;
        
        const { background, fill, group, fillGeometry, fillMaterial } = healthBarData;
        

        // Position group above unit
        const unitType  = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const collections = this.game.getCollections?.();
        const unitData = (unitType && collections && collections[unitType.collection])
            ? collections[unitType.collection][unitType.id]
            : null;

        const baseY   = pos.y || 0;
        const heightY = (unitData && unitData.height != null)
            ? unitData.height
            : this.HEALTH_BAR_OFFSET_Y;

        group.position.set(pos.x, baseY + heightY, pos.z);

        
        // Make health bar always face camera (billboard effect)
        const cameraPosition = this.game.camera.position;
        group.lookAt(cameraPosition.x, cameraPosition.y, cameraPosition.z);
        
        // Calculate health percentage
        const currentHealthPercent = Math.max(0, Math.min(100, (health.current / health.max) * 100));
        
        // Only update if health changed
        if (healthBarData.lastHealthPercent !== currentHealthPercent) {
            // Update fill width by scaling
            const healthRatio = currentHealthPercent / 100;
            fill.scale.x = healthRatio;
            
            // Adjust position to keep fill left-aligned
            fill.position.x = -(this.HEALTH_BAR_WIDTH * (1 - healthRatio)) / 2;
            
            // Update color based on health percentage
            fillMaterial.color.setHex(this.getHealthColorByPercent(currentHealthPercent, team));
            
            healthBarData.lastHealthPercent = currentHealthPercent;
        }
        
        // Hide health bar if unit is at full health (optional)
        if (this.shouldHideFullHealthBars() && health.current >= health.max) {
            group.visible = false;
        } else {
            group.visible = true;
        }
        
        // Update notches based on max health
        this.updateHealthBarNotches(entityId, health.max);
    }
    
    getHealthColor(team) {
        const teamColors = {
            'player': 0x00ff00,  // Green for player
            'enemy': 0x00ff00,   // Green for enemy (all start green)
            'neutral': 0x00ff00  // Green for neutral
        };
        return teamColors[team?.team] || teamColors.neutral;
    }
    
    getHealthColorByPercent(percent, team) {
        // All units start with green, then transition based on health
        if (percent > 75) {
            return 0x00ff00; // Green
        } else if (percent > 50) {
            return 0x88ff00; // Yellow-green
        } else if (percent > 25) {
            return 0xffff00; // Yellow
        } else if (percent > 10) {
            return 0xff8800; // Orange
        } else {
            return 0xff0000; // Red for critical health
        }
    }
    
    updateHealthBarNotches(entityId, maxHealth) {
        const healthBarData = this.healthBars.get(entityId);
        if (!healthBarData) return;
        
        // Only update notches if max health changed
        if (healthBarData.lastMaxHealth === maxHealth) return;
        
        // Remove existing notches
        healthBarData.notches.forEach(notch => {
            healthBarData.group.remove(notch);
            notch.geometry.dispose();
            notch.material.dispose();
        });
        healthBarData.notches = [];
        
        // Calculate how many 100 HP marks we need
        const numNotches = Math.floor(maxHealth / 100);

        if (numNotches >= 1) { // Create notches for any unit with 100+ HP
            const notchWidth = 1; // Make notches wider so they're more visible
            const notchHeight = this.HEALTH_BAR_HEIGHT; // Make them shorter
            
            for (let i = 1; i <= numNotches; i++) { // i represents the HP value (100, 200, 300, etc.)
                const hpValue = i * 100; // 100, 200, 300, etc.
                
                // Calculate position as percentage of max health
                const positionPercent = hpValue / maxHealth; // 100/140 = 0.714 for your archer
                
                // Convert to X offset (-50% to +50% of bar width)
                const xOffset = (positionPercent - 0.5) * this.HEALTH_BAR_WIDTH;
                
                
                // Create notch geometry
                const notchGeometry = new THREE.PlaneGeometry(notchWidth, notchHeight);
                const notchMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000, // White notch lines for better visibility
                    transparent: false
                });
                
                const notch = new THREE.Mesh(notchGeometry, notchMaterial);
                notch.position.set(xOffset, -this.HEALTH_BAR_HEIGHT * 0.5 + notchHeight * 0.5, 0.2); // Further in front
                notch.renderOrder = 10001; // Above fill
                
                healthBarData.group.add(notch);
                healthBarData.notches.push(notch);
                
            }
        }
        
        healthBarData.lastMaxHealth = maxHealth;
    }
    
    shouldHideFullHealthBars() {
        // You can make this configurable
        return false; // Set to true to hide health bars when units are at full health
    }
    
    cleanupRemovedHealthBars(currentEntities) {
        const currentEntitySet = new Set(currentEntities);
        
        for (const [entityId] of this.healthBars.entries()) {
            if (!currentEntitySet.has(entityId)) {
                this.removeHealthBarMesh(entityId);
            }
        }
    }
    
    removeHealthBarMesh(entityId) {
        const healthBarData = this.healthBars.get(entityId);
        if (healthBarData) {
            // Remove group from scene
            if (this.game.scene) {
                this.game.scene.remove(healthBarData.group);
            }
            
            // Dispose of main geometries and materials
            healthBarData.background.geometry.dispose();
            healthBarData.background.material.dispose();
            healthBarData.fill.geometry.dispose();
            healthBarData.fill.material.dispose();
            
            // Dispose of notches
            healthBarData.notches.forEach(notch => {
                notch.geometry.dispose();
                notch.material.dispose();
            });
            
            // Remove from map
            this.healthBars.delete(entityId);
        }
    }
    
    // Utility methods for configuration
    setHealthBarScale(scale = 1.0) {
        this.healthBars.forEach(healthBarData => {
            const newWidth = this.HEALTH_BAR_WIDTH * scale;
            const newHeight = this.HEALTH_BAR_HEIGHT * scale;
            
            // Update background geometry
            healthBarData.background.geometry.dispose();
            healthBarData.background.geometry = new THREE.PlaneGeometry(newWidth, newHeight);
            
            // Update fill geometry 
            healthBarData.fillGeometry.dispose();
            healthBarData.fillGeometry = new THREE.PlaneGeometry(newWidth, newHeight);
            healthBarData.fill.geometry = healthBarData.fillGeometry;
            
            // Force position update
            healthBarData.lastHealthPercent = -1;
        });
    }
    isEnemy(teamComp) {
        const myTeam = this.game?.state?.mySide;
        if (myTeam == null || !teamComp) return false;
        return teamComp.team !== myTeam;
    }

    isVisibleAt(pos) {
        const fow = this.game?.fogOfWarSystem;
        if (!fow || !pos) return true; // if no FOW, default to visible
        return fow.isVisibleAt(pos.x, pos.z);
    }

    toggleHealthBars(visible = true) {
        this.healthBars.forEach(healthBarData => {
            healthBarData.group.visible = visible;
        });
    }
    
    setHealthBarOffset(offsetY) {
        this.HEALTH_BAR_OFFSET_Y = offsetY;
        // Positions will be updated on next frame
    }
    
    // Update all health bar colors (useful for team color changes)
    updateAllHealthBarColors() {
        this.healthBars.forEach((healthBarData, entityId) => {
            // Force color update
            healthBarData.lastHealthPercent = -1;
        });
    }
    
    // Set render order to ensure health bars appear on top
    setRenderOrder(order = 1000) {
        this.healthBars.forEach(healthBarData => {
            healthBarData.background.renderOrder = order;
            healthBarData.fill.renderOrder = order + 1;
        });
    }
    
    destroy() {
        // Clean up all health bar meshes
        for (const [entityId] of this.healthBars.entries()) {
            this.removeHealthBarMesh(entityId);
        }
        
        this.healthBars.clear();
        this.initialized = false;
        
        console.log('Simple Quad HealthBarSystem destroyed');
    }
};

// System: UnitRadiusSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['UnitRadiusSystem'] = class UnitRadiusSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.unitRadiusSystem = this;        
        this.componentTypes = this.game.componentManager.getComponentTypes();
        this.debugCircles = new Map(); // entityId -> { sizeCircle, attackCircle }
        this.enabled = false; // Toggle this to show/hide circles
        
        // Visual configuration
        this.SIZE_CIRCLE_COLOR = 0x00ff00;      // Green for unit size
        this.ATTACK_CIRCLE_COLOR = 0xff0000;    // Red for attack range
        this.CIRCLE_OPACITY = 0.3;
        this.CIRCLE_LINE_WIDTH = 2;
    }
    
    update() {
        if (!this.enabled ) return;
        if(this.game.state.phase !== 'battle') {
            this.hideAllCircles();
            return;
        }
        
        const entities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.UNIT_TYPE
        );
        
        entities.forEach(entityId => {
            this.updateEntityCircles(entityId);
        });
        
        // Clean up circles for destroyed entities
        this.cleanupDestroyedEntities(entities);
    }
    
    updateEntityCircles(entityId) {
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const collision = this.game.getComponent(entityId, this.componentTypes.COLLISION);
        const combat = this.game.getComponent(entityId, this.componentTypes.COMBAT);
        
        if (!pos || !collision) return;
        
        // Get or create debug circles for this entity
        let circles = this.debugCircles.get(entityId);
        if (!circles) {
            circles = this.createDebugCircles(entityId);
            this.debugCircles.set(entityId, circles);
        }
        
        if (!circles.sizeCircle || !circles.attackCircle) {
            return;
        }
        
        // Update positions
        circles.sizeCircle.position.set(pos.x, pos.y + 50, pos.z); // y=1 to avoid z-fighting
        circles.attackCircle.position.set(pos.x, pos.y + 60, pos.z); // y=2 to be above size circle
        
        // Update sizes
        const unitRadius = this.getUnitRadius(collision);
        const attackRange = this.getAttackRange(combat, collision);
        
        //console.log(`Entity ${entityId}: unitRadius=${unitRadius}, attackRange=${attackRange}, pos=(${pos.x}, ${pos.y})`);
        
        // Scale the circles - base circle is 50 units radius, so scale accordingly
        circles.sizeCircle.scale.setScalar(unitRadius / 50);
        circles.attackCircle.scale.setScalar(attackRange / 50);
        
        // Always show size circle
        circles.sizeCircle.visible = true;
        
        // Show/hide attack circle based on entity state
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (aiState && (aiState.state === 'attacking' || aiState.state === 'chasing')) {
            circles.attackCircle.visible = true;
            if (aiState.state === 'attacking') {
                circles.attackCircle.material.color.setHex(0xff0000); // Bright red when attacking
            } else {
                circles.attackCircle.material.color.setHex(0xffaa00); // Orange when chasing
            }
        } else {
            circles.attackCircle.visible = true; // Show it anyway for debugging
            circles.attackCircle.material.color.setHex(0x0000ff); // Blue when idle
        }
    }
    
    createDebugCircles(entityId) {
        if (!this.game.worldSystem || !this.game.worldSystem.scene) {
            console.error('No scene found! worldSystem:', this.game.worldSystem);
            return { sizeCircle: null, attackCircle: null };
        }
        
        // Create size circle (unit radius)
        const sizeGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring
        const sizeMaterial = new THREE.MeshBasicMaterial({
            color: this.SIZE_CIRCLE_COLOR,
            transparent: true,
            opacity: this.CIRCLE_OPACITY,
            side: THREE.DoubleSide
        });
        const sizeCircle = new THREE.Mesh(sizeGeometry, sizeMaterial);
        sizeCircle.rotation.x = -Math.PI / 2; // Lay flat on ground
        
        // Create attack range circle
        const attackGeometry = new THREE.RingGeometry(48, 50, 32); // Thin ring
        const attackMaterial = new THREE.MeshBasicMaterial({
            color: this.ATTACK_CIRCLE_COLOR,
            transparent: true,
            opacity: this.CIRCLE_OPACITY,
            side: THREE.DoubleSide
        });
        const attackCircle = new THREE.Mesh(attackGeometry, attackMaterial);
        attackCircle.rotation.x = -Math.PI / 2; // Lay flat on ground
        
        // Add to scene
        this.game.worldSystem.scene.add(sizeCircle);
        this.game.worldSystem.scene.add(attackCircle);
        
        return { sizeCircle, attackCircle };
    }
    
    getUnitRadius(collision) {
        // Use the same logic as your MovementSystem
        if (collision && collision.radius) {
            return collision.radius; 
        }
        
        return 0.1;
    }
    
    getAttackRange(combat, collision) {
        if (!combat) return 0;
        
        const unitRadius = this.getUnitRadius(collision);
        const attackRange = Math.max(combat.range, unitRadius);
        
        return attackRange;
    }
    
    cleanupDestroyedEntities(activeEntities) {
        const activeIds = new Set(activeEntities);
        
        for (const [entityId, circles] of this.debugCircles) {
            if (!activeIds.has(entityId)) {
                // Remove from scene
                if (circles.sizeCircle && this.game.worldSystem.scene) {
                    this.game.worldSystem.scene.remove(circles.sizeCircle);
                    circles.sizeCircle.geometry.dispose();
                    circles.sizeCircle.material.dispose();
                }
                if (circles.attackCircle && this.game.worldSystem.scene) {
                    this.game.worldSystem.scene.remove(circles.attackCircle);
                    circles.attackCircle.geometry.dispose();
                    circles.attackCircle.material.dispose();
                }
                
                // Remove from map
                this.debugCircles.delete(entityId);
            }
        }
    }
    
    hideAllCircles() {
        for (const [entityId, circles] of this.debugCircles) {
            if (circles.sizeCircle) circles.sizeCircle.visible = false;
            if (circles.attackCircle) circles.attackCircle.visible = false;
        }
    }
    
    showAllCircles() {
        for (const [entityId, circles] of this.debugCircles) {
            if (circles.sizeCircle) circles.sizeCircle.visible = true;
            if (circles.attackCircle) circles.attackCircle.visible = true;
        }
    }
    
    toggle() {
        this.enabled = !this.enabled;
        if (this.enabled) {
            this.showAllCircles();
        } else {
            this.hideAllCircles();
        }
        console.log(`Unit debug circles ${this.enabled ? 'enabled' : 'disabled'}`);
    }
    
    cleanup() {
        this.hideAllCircles();
        this.cleanupDestroyedEntities([]);
    }
};

// System: EquipmentSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['EquipmentSystem'] = class EquipmentSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.equipmentSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.entityEquipment = new Map();
        this.equipmentCache = new Map();
        this.equipmentBatches = new Map();
        this.equipmentInstances = new Map();
        
        this.scaleFactor = 32;
        this.DEFAULT_CAPACITY = 128;
        this.bonePrefix = 'mixamorig';
        
        this.boneNameMappings = {
            default: {
                mainHand: ['RightHand', 'Hand_R', 'hand_R', 'R_Hand'],
                offHand: ['LeftHand', 'Hand_L', 'hand_L', 'L_Hand'],
                head: ['Head', 'head', 'Head_M'],
                chest: ['Spine2', 'spine2', 'Chest', 'chest'],
                back: ['Spine', 'spine', 'Back', 'back']
            }
        };
        
        this.slotDefaultOffsets = {
            mainHand: { x: 0, y: 0, z: 0 },
            offHand: { x: 0, y: 0, z: 0 },
            head: { x: 0, y: 0.15, z: 0 },
            chest: { x: 0, y: 0, z: 0 },
            back: { x: 0, y: 0, z: -0.2 }
        };
        
        console.log('[Equipment] System initialized with bone attachment texture');
    }
    
    update() {
        const entities = this.game.getEntitiesWith(
            this.componentTypes.EQUIPMENT,
            this.componentTypes.POSITION
        );
        
        entities.forEach(entityId => {
            this.updateEntityEquipment(entityId);
        });
        
        this.cleanupRemovedEntities(entities);
    }
    
    updateEntityEquipment(entityId) {
        const equipmentData = this.equipmentInstances.get(entityId);
        if (!equipmentData) return;
        
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const facing = this.game.getComponent(entityId, this.componentTypes.FACING);
        
        if (!pos) return;
        
        const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);
        if (!unitInstance) return;
        
        const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);
        if (!unitBatch) return;
        
        for (const [slotType, equipInstance] of equipmentData.entries()) {
            this.updateEquipmentTransformWithBone(
                equipInstance, 
                pos, 
                facing, 
                unitBatch,
                unitInstance
            );
        }
    }
    
    sampleAttachmentMatrix(attachmentTexture, cols, rows, rowIndex, attachmentBoneIndex) {
        if (!attachmentTexture?.image?.data) return null;
        
        const textureData = attachmentTexture.image.data;
        const boneColStart = attachmentBoneIndex * 4;
        
        const matrix = new THREE.Matrix4();
        const elements = matrix.elements;
        
        for (let col = 0; col < 4; col++) {
            const pixelX = Math.floor(boneColStart + col);
            const pixelY = Math.floor(rowIndex);
            
            if (pixelX >= cols || pixelY >= rows || pixelY < 0) {
                return null;
            }
            
            const pixelIndex = (pixelY * cols + pixelX) * 4;
            
            elements[col * 4 + 0] = textureData[pixelIndex + 0];
            elements[col * 4 + 1] = textureData[pixelIndex + 1];
            elements[col * 4 + 2] = textureData[pixelIndex + 2];
            elements[col * 4 + 3] = textureData[pixelIndex + 3];
        }
        
        return matrix;
    }
        
    updateEquipmentTransformWithBone(equipInstance, pos, facing, unitBatch, unitInstance) {
        const batch = this.equipmentBatches.get(equipInstance.batchKey);
        if (!batch || equipInstance.instanceIndex === null) return;
        
        if (!unitBatch?.meta?.attachmentTexture) return;
        
        const clipIndex = unitBatch.attributes.clipIndex.array[unitInstance.instanceIndex];
        const animTime = unitBatch.attributes.animTime.array[unitInstance.instanceIndex];
        
        if (clipIndex === undefined || animTime === undefined) return;
        
        const clipInfo = unitBatch.meta.clips[clipIndex];
        if (!clipInfo) return;
        
        const fps = unitBatch.meta.fps || 30;
        const frame = Math.floor((animTime * fps) % clipInfo.frames);
        const rowIndex = clipInfo.startRow + frame;
        
        const attachmentBoneIndex = equipInstance.attachmentBoneIndex;
        if (attachmentBoneIndex === undefined || attachmentBoneIndex < 0) return;
        
        const skinningMatrix = this.sampleAttachmentMatrix(
            unitBatch.meta.attachmentTexture,
            unitBatch.meta.attachmentTexture.image.width,
            unitBatch.meta.attachmentTexture.image.height,
            rowIndex,
            attachmentBoneIndex
        );
        
        if (!skinningMatrix) return;
        
        const skeleton = unitBatch.meta.skeleton;
        const originalBoneIndex = unitBatch.meta.attachmentBones[attachmentBoneIndex].index;
        const bindInverse = skeleton.boneInverses[originalBoneIndex];

        const bindPose = new THREE.Matrix4().copy(bindInverse).invert();
        const boneWorldLocal = new THREE.Matrix4().multiplyMatrices(skinningMatrix, bindPose);
        
        const bonePos = new THREE.Vector3();
        const boneQuat = new THREE.Quaternion();
        const boneScale = new THREE.Vector3();
        boneWorldLocal.decompose(bonePos, boneQuat, boneScale);
        
        const baseScale = unitBatch.meta.baseScale || new THREE.Vector3(1, 1, 1);
        const basePosition = unitBatch.meta.basePos || new THREE.Vector3(0, 0, 0);
        
        bonePos.multiply(baseScale);
        bonePos.multiplyScalar(this.scaleFactor);
        
        const slotDefaults = this.slotDefaultOffsets[equipInstance.slotType] || { x: 0, y: 0, z: 0 };
        const offsetVec = new THREE.Vector3(
            slotDefaults.x,
            slotDefaults.y,
            slotDefaults.z
        );
        
        if (equipInstance.attachmentData?.offset) {
            offsetVec.x += (equipInstance.attachmentData.offset.x * 0.5);
            offsetVec.y += (equipInstance.attachmentData.offset.y * 0.5);
            offsetVec.z += (equipInstance.attachmentData.offset.z * 0.5);
        }
        const boneRotation = boneQuat.clone();
        if (equipInstance.attachmentData?.rotation) {
            const offsetRot = new THREE.Quaternion();
            offsetRot.setFromEuler(new THREE.Euler(
                (equipInstance.attachmentData.rotation.x) * Math.PI / 180,
                (equipInstance.attachmentData.rotation.y) * Math.PI / 180,
                (equipInstance.attachmentData.rotation.z) * Math.PI / 180,
                'XYZ'
            ));
            boneRotation.multiply(offsetRot);
        }
        
        offsetVec.applyQuaternion(boneRotation);
        bonePos.add(offsetVec);
        
        const rotationY = facing ? (-facing.angle + Math.PI / 2) : (Math.PI / 2);
        const worldRotation = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
        
        bonePos.applyQuaternion(worldRotation);
        
        const worldPos = new THREE.Vector3(
            pos.x + basePosition.x * this.scaleFactor,
            (pos.y || 0) + basePosition.y * this.scaleFactor,
            pos.z + basePosition.z * this.scaleFactor
        );
        bonePos.add(worldPos);
        
        const finalRotation = new THREE.Quaternion().multiplyQuaternions(worldRotation, boneRotation);
        
        const finalScale = new THREE.Vector3(this.scaleFactor * 0.25, this.scaleFactor * 0.25, this.scaleFactor * 0.25);
        
        const matrix = new THREE.Matrix4();
        matrix.compose(bonePos, finalRotation, finalScale);
        
        batch.mesh.setMatrixAt(equipInstance.instanceIndex, matrix);
        batch.mesh.instanceMatrix.needsUpdate = true;
    }
    
    findAttachmentBoneIndex(attachmentBones, boneName) {
        if (!attachmentBones) return -1;
        
        for (let i = 0; i < attachmentBones.length; i++) {
            const bone = attachmentBones[i];
            if (bone.name === boneName || 
                bone.name.replace(this.bonePrefix, '') === boneName ||
                bone.name.includes(boneName)) {
                console.log(`[Equipment] Found attachment bone "${boneName}" at index ${i} (original: ${bone.index})`);
                return i;
            }
        }
        
        console.warn(`[Equipment] Attachment bone not found: ${boneName}`);
        return -1;
    }
   
    async equipItem(entityId, slotData, itemData) {
        return false;
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        const slotType = slotData.slot;
        if (!equipment) return false;
        
        if (equipment.slots[slotType]) {
            await this.unequipItem(entityId, slotType);
        }
        
        const spawnType = slotData.item;
        const equipmentModel = await this.loadEquipmentModel(spawnType);
        if (!equipmentModel) return false;
        
        const batchKey = `equipment_${spawnType}`;
        let batch = this.equipmentBatches.get(batchKey);
        
        if (!batch) {
            batch = this.createEquipmentBatch(batchKey, equipmentModel);
            if (!batch) return false;
        }
        
        const unitInstance = this.game.renderSystem?.entityToInstance?.get(entityId);
        if (!unitInstance) return false;
        
        const unitBatch = this.game.renderSystem?.vatBatches?.get(unitInstance.batchKey);
        if (!unitBatch?.meta?.attachmentBones) {
            console.error('[Equipment] Unit has no attachment bone data');
            return false;
        }
        
        const boneNames = this.boneNameMappings.default[slotType];
        let attachmentBoneIndex = -1;
        
        for (const boneName of boneNames) {
            attachmentBoneIndex = this.findAttachmentBoneIndex(unitBatch.meta.attachmentBones, boneName);
            if (attachmentBoneIndex >= 0) break;
        }
        
        if (attachmentBoneIndex < 0) {
            console.error(`[Equipment] No valid attachment bone found for slot ${slotType}`);
            return false;
        }
        
        const instanceIndex = this.allocateEquipmentInstance(batch);
        if (instanceIndex === null) return false;
        
        const equipInstance = {
            batchKey,
            instanceIndex,
            slotType,
            attachmentBoneIndex,
            attachmentData: slotData.attachmentData
        };
        
        if (!this.equipmentInstances.has(entityId)) {
            this.equipmentInstances.set(entityId, new Map());
        }
        this.equipmentInstances.get(entityId).set(slotType, equipInstance);
        
        if (!this.entityEquipment.has(entityId)) {
            this.entityEquipment.set(entityId, new Map());
        }
        
        this.entityEquipment.get(entityId).set(slotType, {
            itemData,
            spawnType,
            instanceIndex,
            batchKey
        });
        
        equipment.slots[slotType] = {
            itemData,
            equippedItem: itemData
        };
        
        console.log(`[Equipment] Equipped ${spawnType} to entity ${entityId} slot ${slotType} attachment bone ${attachmentBoneIndex}`);
        return true;
    }
    
    createEquipmentBatch(batchKey, equipmentModel) {
        let geometry = null;
        let material = null;
            
        equipmentModel.updateMatrixWorld(true);

        equipmentModel.traverse(child => {
            if (child.isMesh && !geometry) {
                geometry = child.geometry.clone();
                child.updateMatrixWorld(true);
                geometry.applyMatrix4(child.matrixWorld);
                material = child.material.clone();
            }
        });
        
        if (!geometry || !material) return null;
        
        material.metalness = material.metalness || 0;
        material.roughness = material.roughness || 1;
        
        const instancedMesh = new THREE.InstancedMesh(geometry, material, this.DEFAULT_CAPACITY);
        instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        instancedMesh.castShadow = true;
        instancedMesh.receiveShadow = true;
        instancedMesh.frustumCulled = false;
        
        const hiddenMatrix = new THREE.Matrix4();
        hiddenMatrix.makeTranslation(0, -10000, 0);
        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        
        for (let i = 0; i < this.DEFAULT_CAPACITY; i++) {
            instancedMesh.setMatrixAt(i, hiddenMatrix);
        }
        instancedMesh.instanceMatrix.needsUpdate = true;
        
        if (this.game.scene) {
            this.game.scene.add(instancedMesh);
        }
        
        const batch = {
            mesh: instancedMesh,
            capacity: this.DEFAULT_CAPACITY,
            count: 0,
            availableIndices: Array.from({ length: this.DEFAULT_CAPACITY }, (_, i) => i),
            usedIndices: new Set()
        };
        
        this.equipmentBatches.set(batchKey, batch);
        return batch;
    }
    
    allocateEquipmentInstance(batch) {
        if (batch.availableIndices.length === 0) return null;
        const instanceIndex = batch.availableIndices.shift();
        batch.usedIndices.add(instanceIndex);
        batch.count++;
        return instanceIndex;
    }
    
    releaseEquipmentInstance(batch, instanceIndex) {
        if (!batch.usedIndices.has(instanceIndex)) return;
        
        const hiddenMatrix = new THREE.Matrix4();
        hiddenMatrix.makeTranslation(0, -10000, 0);
        hiddenMatrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        batch.mesh.setMatrixAt(instanceIndex, hiddenMatrix);
        batch.mesh.instanceMatrix.needsUpdate = true;
        
        batch.usedIndices.delete(instanceIndex);
        batch.availableIndices.push(instanceIndex);
        batch.count--;
    }
    
    async unequipItem(entityId, slotType) {
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (!equipment || !equipment.slots[slotType]) return true;
        
        const equipInstance = this.equipmentInstances.get(entityId)?.get(slotType);
        
        if (equipInstance) {
            const batch = this.equipmentBatches.get(equipInstance.batchKey);
            if (batch) {
                this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);
            }
            this.equipmentInstances.get(entityId)?.delete(slotType);
        }
        
        const entityEquip = this.entityEquipment.get(entityId);
        if (entityEquip) {
            entityEquip.delete(slotType);
        }
        
        equipment.slots[slotType] = null;
        return true;
    }
    
    async loadEquipmentModel(spawnType) {
        const cacheKey = `items_${spawnType}`;
        
        if (this.equipmentCache.has(cacheKey)) {
            return this.equipmentCache.get(cacheKey).clone();
        }
        
        try {
            const model = this.game.modelManager.getModel("items", spawnType);
            
            if (model) {
                model.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        if (child.material) {
                            child.material.metalness = child.material.metalness || 0;
                            child.material.roughness = child.material.roughness || 1;
                        }
                    }
                });
                
                this.equipmentCache.set(cacheKey, model);
                return model.clone();
            }
        } catch (error) {
            console.error(`Error loading equipment model ${cacheKey}:`, error);
        }
        
        return null;
    }
    
    cleanupRemovedEntities(activeEntities) {
        const activeSet = new Set(activeEntities);
        
        for (const [entityId, equipmentMap] of this.equipmentInstances.entries()) {
            if (!activeSet.has(entityId)) {
                for (const [slotType, equipInstance] of equipmentMap.entries()) {
                    const batch = this.equipmentBatches.get(equipInstance.batchKey);
                    if (batch) {
                        this.releaseEquipmentInstance(batch, equipInstance.instanceIndex);
                    }
                }
                this.equipmentInstances.delete(entityId);
                this.entityEquipment.delete(entityId);
            }
        }
    }
    
    destroy() {
        for (const [batchKey, batch] of this.equipmentBatches.entries()) {
            if (batch.mesh) {
                if (this.game.scene) {
                    this.game.scene.remove(batch.mesh);
                }
                batch.mesh.geometry.dispose();
                if (Array.isArray(batch.mesh.material)) {
                    batch.mesh.material.forEach(mat => mat.dispose());
                } else {
                    batch.mesh.material.dispose();
                }
            }
        }
        
        for (const [key, model] of this.equipmentCache.entries()) {
            model.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        }
        
        this.equipmentBatches.clear();
        this.equipmentInstances.clear();
        this.entityEquipment.clear();
        this.equipmentCache.clear();
    }
};

// System: DeathSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['DeathSystem'] = class DeathSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.deathSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
    }
    
    update() {
        // Get all entities with death state
        const dyingEntities = this.game.getEntitiesWith(this.componentTypes.DEATH_STATE);
        dyingEntities.forEach(entityId => {
            const deathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        
            if (deathState.isDying) {
                const timeSinceDeath = this.game.state.now - deathState.deathStartTime;
                
                // Remove health (corpses can't be damaged)
                if (this.game.hasComponent(entityId, this.componentTypes.HEALTH)) {
                    this.game.removeComponent(entityId, this.componentTypes.HEALTH);
                }
                
                // Remove velocity (corpses don't move)
                if (this.game.hasComponent(entityId, this.componentTypes.VELOCITY)) {
                    this.game.removeComponent(entityId, this.componentTypes.VELOCITY);
                }
                
                // NEW: Check if animation system says death animation is complete
                const animationCompleted = this.isDeathAnimationCompleted(entityId);
                
                // Convert to corpse when EITHER timer expires OR animation completes (whichever comes first)
                const timerExpired = timeSinceDeath >= deathState.deathAnimationDuration;
                
                if (animationCompleted || timerExpired) {
                    console.log(entityId, "DIED");
                    if(unitType && unitType.collection == "buildings"){
                        this.destroyBuilding(entityId, unitType);
                    } else {
                        this.convertToCorpse(entityId);
                    }
                }
            }
        });
    }



    destroyBuilding(entityId, unitType) {
        console.log(`=== Destroy Building DEBUG ===`);     
        console.log(`Data received:`, entityId, unitType);        

        if (unitType.id === 'goldMine') {
            const result = this.game.goldMineSystem.destroyGoldMine(entityId);
            if (!result.success) {
                return result;
            }
        } 
        this.game.destroyEntity(entityId);  
        return { success: true };
    }
    
    // NEW: Check if death animation is completed via AnimationSystem
    isDeathAnimationCompleted(entityId) {
        if (!this.game.animationSystem) return false;
        
        const animState = this.game.animationSystem.entityAnimationStates?.get(entityId);
        if (!animState) return false;
        
        // Only check if entity is currently dying and playing death animation
        if (!animState.isDying) return false;
        if (animState.currentClip !== 'death' && animState.currentClip !== 'die') return false;
        
        // Check if the animation system considers the death animation finished
        return this.game.animationSystem.isAnimationFinished(entityId, animState.currentClip);
    }
    
    convertToCorpse(entityId) {
        const Components = this.game.componentManager.getComponents();
        
        // Get current components before conversion
        const position = this.game.getComponent(entityId, this.componentTypes.POSITION);
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const renderable = this.game.getComponent(entityId, this.componentTypes.RENDERABLE);
        
        if (!position || !unitType || !team) return;
        
        // CRITICAL: Notify AnimationSystem FIRST to set corpse state
        if (this.game.animationSystem && this.game.animationSystem.setCorpseAnimation) {
            this.game.animationSystem.setCorpseAnimation(entityId);
        }
        
        // Remove death state
        this.game.removeComponent(entityId, this.componentTypes.DEATH_STATE);        
        
        // Add corpse component
        this.game.addComponent(entityId, this.componentTypes.CORPSE, Components.Corpse(
            { ...unitType }, 
            (this.game.state.now || 0), 
            team.team
        ));
        
    }
    
    // Rest of your existing methods remain the same...
    getCorpsesInRange(position, range, teamFilter = null) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        const nearbyCorpses = [];
        
        corpses.forEach(corpseId => {
            const corpsePos = this.game.getComponent(corpseId, this.componentTypes.POSITION);
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            
            if (!corpsePos || !corpse) return;
            
            // Check team filter if specified
            if (teamFilter && corpse.teamAtDeath !== teamFilter) return;
            
            // Check distance
            const dx = corpsePos.x - position.x;
            const dz = corpsePos.z - position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);
            
            if (distance <= range) {
                nearbyCorpses.push({
                    entityId: corpseId,
                    position: corpsePos,
                    corpse: corpse,
                    distance: distance
                });
            }
        });
        
        return nearbyCorpses;
    }
    
    consumeCorpse(corpseId) {
        // Remove corpse from battlefield (for abilities that consume corpses)
        const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
        if (!corpse) return null;
        
        // Return corpse data for the ability to use
        const corpseData = { ...corpse };
        
        // Destroy the corpse entity
        this.game.destroyEntity(corpseId);
        
        return corpseData;
    }
    
    getAllCorpses() {
        return this.game.getEntitiesWith(this.componentTypes.CORPSE);
    }
    
    getCorpsesByTeam(team) {
        const corpses = this.game.getEntitiesWith(this.componentTypes.CORPSE);
        return corpses.filter(corpseId => {
            const corpse = this.game.getComponent(corpseId, this.componentTypes.CORPSE);
            return corpse && corpse.teamAtDeath === team;
        });
    }
};

// System: DamageSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['DamageSystem'] = class DamageSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.damageSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Element types
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };

        // Poison DoT configuration
        this.POISON_CONFIG = {
            DEFAULT_DURATION: 5.0,  // seconds
            DEFAULT_TICKS: 5,       // number of damage instances
            STACK_LIMIT: 50,         // maximum poison stacks
            STACK_REFRESH: true     // new poison refreshes duration
        };

        // Status effect tracking
        this.activeStatusEffects = new Map(); // entityId -> { poison: [...], other effects }
        
        // Damage event queue for delayed damage (melee attacks, etc.)
        this.pendingDamageEvents = new Map();
        
        // Configuration
        this.RESISTANCE_CAP = 0.9; // Maximum resistance (90%)
        this.MIN_DAMAGE = 1; // Minimum damage that can be dealt
    }

    // =============================================
    // CORE DAMAGE APPLICATION METHODS
    // =============================================

    /**
     * Main damage application method - handles all damage types and resistances
     * @param {number} sourceId - Entity dealing damage
     * @param {number} targetId - Entity receiving damage  
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element type
     * @param {Object} options - Additional options (splash, crit, etc.)
     */
    applyDamage(sourceId, targetId, baseDamage, element = this.ELEMENT_TYPES.PHYSICAL, options = {}) {
        const targetHealth = this.game.getComponent(targetId, this.componentTypes.HEALTH);
        const targetDeathState = this.game.getComponent(targetId, this.componentTypes.DEATH_STATE);

        if (!targetHealth || (targetDeathState && targetDeathState.isDying)) {
            return { damage: 0, prevented: true, reason: 'target_invalid' };
        }
        
        const defenderMods = this.getDefenderModifiers(targetId);
        // Get target's defenses
        const defenses = this.getEntityDefenses(targetId, defenderMods);
        const attackerMods = this.getAttackerModifiers(sourceId);
        let buffedDamage = baseDamage * attackerMods.damageMultiplier;

        

        if (options.isCritical) {
            buffedDamage *= options.criticalMultiplier || 2.0;
        }
        // Handle poison as special case (DoT)
        if (element === this.ELEMENT_TYPES.POISON) {
            return this.applyPoisonDoT(sourceId, targetId, buffedDamage, options);
        }
        // Calculate final damage after resistances/armor
        const damageResult = this.calculateFinalDamage(sourceId, targetId, buffedDamage, element, defenses, defenderMods, options);

        // Apply immediate damage
        targetHealth.current -= damageResult.finalDamage;

        // Visual feedback
        this.applyVisualFeedback(targetId, damageResult, element);

        // Check for death
        if (targetHealth.current <= 0) {
            this.handleEntityDeath(targetId);
        }
 
        this.game.combatAISystems.setRetaliatoryTarget(targetId, sourceId);
           
        return {
            damage: damageResult.finalDamage,
            originalDamage: baseDamage,
            buffedDamage: buffedDamage,
            mitigated: damageResult.mitigated,
            element: element,
            fatal: targetHealth.current <= 0
        };
    }
    getAttackerModifiers(attackerId) {
        const buff = this.game.getComponent(attackerId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            damageMultiplier: 1.0,
            attackSpeedMultiplier: 1.0 
        };
        
        return {
            damageMultiplier: buff.modifiers?.damageMultiplier || 1.0,
            attackSpeedMultiplier: buff.modifiers?.attackSpeedMultiplier || 1.0
        };
    }
    getDefenderModifiers(defenderId) {
        const buff = this.game.getComponent(defenderId, this.componentTypes.BUFF);
        if (!buff || !buff.isActive) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        const currentTime = this.game.state.now || 0;
        if (buff.endTime && currentTime > buff.endTime) return { 
            armorMultiplier: 1.0, 
            damageTakenMultiplier: 1.0, 
            damageReduction: 0 
        };
        
        return {
            armorMultiplier: buff.modifiers?.armorMultiplier || buff.armorMultiplier || 1.0,
            damageTakenMultiplier: buff.modifiers?.damageTakenMultiplier || buff.damageTakenMultiplier || 1.0,
            damageReduction: buff.modifiers?.damageReduction || buff.damageReduction || 0,
            additionalLightningResistance: buff.modifiers?.additionalLightningResistance || buff.additionalLightningResistance || 0,
            additionalFireResistance: buff.modifiers?.additionalFireResistance || buff.additionalFireResistance || 0,
            additionalColdResistance: buff.modifiers?.additionalColdResistance || buff.additionalColdResistance || 0,
            additionalElementalResistance: buff.modifiers?.additionalElementalResistance || buff.additionalElementalResistance || 0
        };
    }
    /**
     * Apply splash/area damage around a point
     * @param {number} sourceId - Source of the damage
     * @param {Object} centerPos - Center position {x, y, z}
     * @param {number} baseDamage - Base damage amount
     * @param {string} element - Damage element
     * @param {number} radius - Splash radius
     * @param {Object} options - Additional options
     */
    applySplashDamage(sourceId, centerPos, baseDamage, element, radius, options = {}) {
        const results = [];
        const sourceTeam = this.game.getComponent(sourceId, this.componentTypes.TEAM);
        
        if (!sourceTeam) return results;

        // Find all entities within splash radius
        const allEntities = this.game.getEntitiesWith(
            this.componentTypes.POSITION, 
            this.componentTypes.HEALTH,
            this.componentTypes.TEAM
        );
        allEntities.forEach(entityId => {
            if (entityId === sourceId && !options.allowSelfDamage) return; // Don't damage source by default
            
            const entityPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const entityTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
            
            if (!entityPos || !entityTeam) return;
            if (entityTeam.team === sourceTeam.team && !options.allowFriendlyFire) return;

            // Calculate 3D distance from explosion center
            const distance = this.calculateDistance3D(centerPos, entityPos);
            
            if (distance <= radius) {
                // Calculate damage based on distance (closer = more damage)
                const damageMultiplier = Math.max(0.2, 1 - (distance / radius));
                const adjustedDamage = Math.floor(baseDamage * damageMultiplier);
           
                // Apply damage (experience will be awarded inside applyDamage)
                const result = this.applyDamage(sourceId, entityId, adjustedDamage, element, {
                    ...options,
                    isSplash: true,
                    splashDistance: distance,
                    splashMultiplier: damageMultiplier
                });
                
                if (result.damage > 0) {
                    results.push({
                        entityId,
                        ...result,
                        distance
                    });
                }
            }
        });

        return results;
    }

    // =============================================
    // DAMAGE CALCULATION METHODS
    // =============================================

    /**
     * Calculate final damage after all resistances and modifiers
     */
    calculateFinalDamage(sourceId, targetId, baseDamage, element, defenses, defenderMods, options = {}) {
        let finalDamage = baseDamage;
        let mitigated = 0;

        // Apply element-specific damage reduction
        switch (element) {
            case this.ELEMENT_TYPES.PHYSICAL:
                const armor = defenses.armor || 0;
                mitigated = Math.min(armor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - armor);
                break;

            case this.ELEMENT_TYPES.FIRE:
                const fireResist = this.capResistance(defenses.fireResistance || 0);
                mitigated = Math.floor(finalDamage * fireResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - fireResist)));
                break;

            case this.ELEMENT_TYPES.COLD:
                const coldResist = this.capResistance(defenses.coldResistance || 0);
                mitigated = Math.floor(finalDamage * coldResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - coldResist)));
                break;

            case this.ELEMENT_TYPES.LIGHTNING:
                const lightningResist = this.capResistance(defenses.lightningResistance || 0);
                mitigated = Math.floor(finalDamage * lightningResist);
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage * (1 - lightningResist)));
                break;

            case this.ELEMENT_TYPES.DIVINE:
                // Divine damage cannot be reduced
                mitigated = 0;
                finalDamage = Math.max(this.MIN_DAMAGE, Math.floor(finalDamage));
                break;

            default:
                console.warn(`Unknown damage element: ${element}, treating as physical`);
                const defaultArmor = defenses.armor || 0;
                mitigated = Math.min(defaultArmor, finalDamage - this.MIN_DAMAGE);
                finalDamage = Math.max(this.MIN_DAMAGE, finalDamage - defaultArmor);
                break;
        }
        // Apply damage taken multiplier (from marks, etc.)
        finalDamage *= defenderMods.damageTakenMultiplier;
        
        // Apply flat damage reduction (from intimidation, shield wall, etc.)
        if (defenderMods.damageReduction > 0) {
            const reductionAmount = Math.floor(finalDamage * defenderMods.damageReduction);
            finalDamage -= reductionAmount;
            mitigated += reductionAmount;
        }
        return {
            finalDamage,
            mitigated,
            originalDamage: baseDamage
        };
    }

    /**
     * Get entity's defensive stats from all sources
     */
    getEntityDefenses(entityId, defenderMods) {
        const defenses = {
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0
        };

        // Get base defenses from combat component
        const combatComponent = this.game.getComponent(entityId, this.componentTypes.COMBAT);
        if (combatComponent) {
            defenses.armor = combatComponent.armor || 0;
            defenses.fireResistance = combatComponent.fireResistance || 0;
            defenses.coldResistance = combatComponent.coldResistance || 0;
            defenses.lightningResistance = combatComponent.lightningResistance || 0;
        }

        // Add equipment bonuses if equipment system exists
        const equipment = this.game.getComponent(entityId, this.componentTypes.EQUIPMENT);
        if (equipment && this.game.equipmentSystem && this.game.equipmentSystem.calculateTotalStats) {
            const equipmentStats = this.game.equipmentSystem.calculateTotalStats(entityId);
            if (equipmentStats) {
                defenses.armor += equipmentStats.armor || 0;
                defenses.fireResistance += equipmentStats.fireResistance || 0;
                defenses.coldResistance += equipmentStats.coldResistance || 0;
                defenses.lightningResistance += equipmentStats.lightningResistance || 0;
            }
        }

        // Add temporary resistance bonuses from status effects
        defenses.armor *= defenderMods.armorMultiplier; // Apply armor multiplier from buffs
        defenses.fireResistance = defenses.fireResistance + defenderMods.additionalFireResistance + defenderMods.additionalElementalResistance;
        defenses.coldResistance = defenses.coldResistance + defenderMods.additionalColdResistance + defenderMods.additionalElementalResistance;
        defenses.lightningResistance = defenses.lightningResistance + defenderMods.additionalLightningResistance + defenderMods.additionalElementalResistance;

        return defenses;
    }

    // =============================================
    // POISON SYSTEM METHODS
    // =============================================

    /**
     * Apply poison damage over time - poison cannot be resisted, only cured
     */
    applyPoisonDoT(sourceId, targetId, totalDamage, options = {}) {
        const duration = options.duration || this.POISON_CONFIG.DEFAULT_DURATION;
        const ticks = options.ticks || this.POISON_CONFIG.DEFAULT_TICKS;
        
        // Poison cannot be resisted - it always applies at full strength
        const perTickDamage = Math.max(1, Math.ceil(totalDamage / ticks));

        // Initialize status effects for target if needed
        if (!this.activeStatusEffects.has(targetId)) {
            this.activeStatusEffects.set(targetId, { poison: [] });
        }

        const statusEffects = this.activeStatusEffects.get(targetId);
        
        // Check current poison stacks
        if (statusEffects.poison.length >= this.POISON_CONFIG.STACK_LIMIT) {
            if (this.POISON_CONFIG.STACK_REFRESH) {
                // Remove oldest poison stack and add new one
                statusEffects.poison.shift();
            } else {
                // Cannot add more poison
                return { damage: 0, prevented: true, reason: 'stack_limit' };
            }
        }
        const poisonEffect = {
            sourceId,
            remainingTicks: ticks,
            damagePerTick: perTickDamage,
            tickInterval: duration / ticks,
            nextTickTime: this.game.state.now + (duration / ticks),
            startTime: this.game.state.now,
            totalDamage: perTickDamage * ticks
        };

        statusEffects.poison.push(poisonEffect);

      
        return {
            damage: poisonEffect.totalDamage,
            isPoison: true,
            stacks: statusEffects.poison.length,
            tickDamage: perTickDamage,
            duration: duration
        };
    }

    /**
     * Process ongoing poison damage
     */
    processStatusEffects() {     

        
        for (const [entityId, statusEffects] of this.activeStatusEffects.entries()) {
            const targetHealth = this.game.getComponent(entityId, this.componentTypes.HEALTH);
            const targetDeathState = this.game.getComponent(entityId, this.componentTypes.DEATH_STATE);
            
            if (!targetHealth || targetHealth.current <= 0 || (targetDeathState && targetDeathState.isDying)) {
                // Entity is dead or dying, remove all status effects
                this.activeStatusEffects.delete(entityId);
                continue;
            }
            // Process poison effects
            statusEffects.poison = statusEffects.poison.filter(poisonEffect => {
                if (this.game.state.now >= poisonEffect.nextTickTime) {
                    // Apply poison damage
                    targetHealth.current -= poisonEffect.damagePerTick;
                    
                    // Visual feedback for poison
                    this.applyVisualFeedback(entityId, { finalDamage: poisonEffect.damagePerTick }, this.ELEMENT_TYPES.POISON);

                    // Check for death from poison
                    if (targetHealth.current <= 0) {
                        this.handleEntityDeath(entityId);
                        return false; // Remove this poison effect
                    }

                    // Update for next tick
                    poisonEffect.remainingTicks--;
                    poisonEffect.nextTickTime = this.game.state.now + poisonEffect.tickInterval;

                    // Keep poison if ticks remain
                    return poisonEffect.remainingTicks > 0;
                }
                return true; // Keep poison effect
            });

            // Remove entity from status effects if no effects remain
            if (statusEffects.poison.length === 0) {
                this.activeStatusEffects.delete(entityId);
            }
        }
    }

    /**
     * Cure poison effects
     */
    curePoison(targetId, stacksToRemove = null) {
        const statusEffects = this.activeStatusEffects.get(targetId);
        if (!statusEffects || statusEffects.poison.length === 0) return false;

        const removeCount = stacksToRemove || statusEffects.poison.length;
        const removedStacks = statusEffects.poison.splice(0, removeCount);

        if (statusEffects.poison.length === 0) {
            this.activeStatusEffects.delete(targetId);
        }

        return true;
    }

    // =============================================
    // DELAYED DAMAGE SYSTEM
    // =============================================

    /**
     * Schedule damage to be applied later (for melee attacks, timed effects, etc.)
     */
    scheduleDamage(sourceId, targetId, damage, element, delay, options = {}) {
        const triggerTime = this.game.state.now + delay;
        const eventId = `${sourceId}_${targetId}_${this.game.state.now}_${Math.random()}`;
        
        this.pendingDamageEvents.set(eventId, {
            sourceId,
            targetId,
            damage,
            element: element || this.ELEMENT_TYPES.PHYSICAL,
            triggerTime,
            options,
            eventId
        });
        
        return eventId;
    }

    /**
     * Process pending damage events
     */
    processPendingDamage() {        

        const eventsToRemove = [];
        
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {

            if (this.game.state.now >= event.triggerTime) {
                // Check if target is still valid
                const targetHealth = this.game.getComponent(event.targetId, this.componentTypes.HEALTH);
                const targetDeathState = this.game.getComponent(event.targetId, this.componentTypes.DEATH_STATE);
                
                if (targetHealth && targetHealth.current > 0 && (!targetDeathState || !targetDeathState.isDying)) {
                    // Apply the delayed damage
                     this.applyDamage(event.sourceId, event.targetId, event.damage, event.element, {
                        ...event.options,
                        isDelayed: true
                    });
                }
                
                eventsToRemove.push(eventId);
            }
        }
        
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
    }


    calculateDistance3D(pos1, pos2) {
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const dz = pos2.z - pos1.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    capResistance(resistance) {
        return Math.min(this.RESISTANCE_CAP, Math.max(-1.0, resistance));
    }

    getPoisonStacks(entityId) {
        const statusEffects = this.activeStatusEffects.get(entityId);
        return statusEffects ? statusEffects.poison.length : 0;
    }


    applyVisualFeedback(targetId, damageResult, element) {
        const targetAnimation = this.game.getComponent(targetId, this.componentTypes.ANIMATION);
        if (targetAnimation) {
            // Different flash intensities based on element
            switch (element) {
                case this.ELEMENT_TYPES.FIRE:
                    targetAnimation.flash = 0.6;
                    break;
                case this.ELEMENT_TYPES.COLD:
                    targetAnimation.flash = 0.5;
                    break;
                case this.ELEMENT_TYPES.LIGHTNING:
                    targetAnimation.flash = 0.8;
                    break;
                case this.ELEMENT_TYPES.POISON:
                    targetAnimation.flash = 0.3; // Subtle for DoT
                    break;
                case this.ELEMENT_TYPES.DIVINE:
                    targetAnimation.flash = 0.7;
                    break;
                default:
                    targetAnimation.flash = 0.5;
                    break;
            }
        }
    }


    handleEntityDeath(entityId) {
        
        // Notify other systems about death
        if (this.game.combatAISystems) {
            this.game.combatAISystems.startDeathProcess(entityId);
        }
        if (this.game.phaseSystem) {
            this.game.phaseSystem.checkForRoundEnd();
        }
    }

    entityDestroyed(entityId) {
        // Clear pending damage events for this entity
        const eventsToRemove = [];
        for (const [eventId, event] of this.pendingDamageEvents.entries()) {
            if (event.sourceId === entityId || event.targetId === entityId) {
                eventsToRemove.push(eventId);
            }
        }
        eventsToRemove.forEach(id => this.pendingDamageEvents.delete(id));
        
        // Clear status effects
        this.activeStatusEffects.delete(entityId);
    }

    update() {
        this.processStatusEffects();
        this.processPendingDamage();
    }

    clearAllStatusEffects(entityId) {
        this.activeStatusEffects.delete(entityId);
    }

    clearAll() {        
        this.activeStatusEffects.clear();  
        this.pendingDamageEvents.clear();
    }

    getStatusEffects(entityId) {
        return this.activeStatusEffects.get(entityId) || { poison: [] };
    }

};

// System: AbilitySystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['AbilitySystem'] = class AbilitySystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.abilitySystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        this.abilityActionCounter = 0;
        this.entityAbilities = new Map();
        this.abilityCooldowns = new Map();
        this.abilityQueue = new Map();
        this.abilityActions = new Map();
    }    
    
    addAbilitiesToUnit(entityId, abilityIds) {
        if (!Array.isArray(abilityIds)) {
            abilityIds = [abilityIds];
        }
        const unitAbilities = [];
        
        abilityIds.forEach(abilityId => {
            const AbilityClass = this.game.app.appClasses[abilityId];
            if (AbilityClass) {
                const abilityInstance = new AbilityClass(this.game, this.game.getCollections().abilities[abilityId]);
                unitAbilities.push(abilityInstance);
            } else {
                console.warn(`Ability '${abilityId}' not found`);
            }
        });
        
        if (unitAbilities.length > 0) {
            this.entityAbilities.set(entityId, unitAbilities);
        }
    }

    update() {
        if (this.game.state.phase !== 'battle') return;

        this.processAbilityQueue();
        this.processAbilityActions();
        this.updateAIAbilityUsage();
    }
    processAbilityQueue() {        
        for (const [entityId, queuedAbility] of this.abilityQueue.entries()) {
            if (this.game.state.now >= queuedAbility.executeTime) {
                const abilities = this.entityAbilities.get(entityId);
                if (abilities) {
                    const ability = abilities.find(a => a.id === queuedAbility.abilityId);
                    if (ability) {
                        // Execute ability and get potential callback
                        const abilityAction = ability.execute(entityId, queuedAbility.targetData);
                        
                        // If ability returns a callback, schedule it deterministically
                        if (typeof abilityAction === 'function') {
                            // Add to a delayed effects queue
                            this.scheduleAbilityAction(abilityAction, ability.castTime);
                        }
                    }
                }
                this.abilityQueue.delete(entityId);
            }
        }
    }
    scheduleAbilityAction(action, castTime) {        
        const executeTime = this.game.state.now + castTime;
        const effectId = `${this.game.state.now}_${this.abilityActionCounter++}`;
    
        this.abilityActions.set(effectId, {
            callback: action,
            executeTime: executeTime
        });
    }
    processAbilityActions() {
        if (!this.abilityActions) return;
        
        for (const [effectId, abilityAction] of this.abilityActions.entries()) {
            if (this.game.state.now >= abilityAction.executeTime) {
                abilityAction.callback();
                this.abilityActions.delete(effectId);
            }
        }
    }
    updateAIAbilityUsage() {
        const sortedEntityIds = Array.from(this.entityAbilities.keys()).sort((a, b) => 
            String(a).localeCompare(String(b))
        );
        
        sortedEntityIds.forEach(entityId => {
            const abilities = this.entityAbilities.get(entityId);
            this.considerAbilityUsage(entityId, abilities);
        });
    }
    
    considerAbilityUsage(entityId, abilities) {
        if (this.abilityQueue.has(entityId)) {
            return; // Entity is already casting an ability, wait for it to finish
        }
        
        const availableAbilities = abilities
            .filter(ability => this.isAbilityOffCooldown(entityId, ability.id))
            .filter(ability => ability.canExecute(entityId))
            .sort((a, b) => b.priority - a.priority);
        
        // Check if unit is waiting and now has abilities available
        const aiState = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
        if (aiState && aiState.state === 'waiting' && availableAbilities.length > 0) {
            // Transition back to attacking state since we have abilities ready
            if (this.game.combatAISystems) {
                this.game.combatAISystems.changeAIState(aiState, 'attacking');
                
                // Re-enable movement decisions by resetting decision time
                if (aiState.aiBehavior) {
                    aiState.aiBehavior.lastDecisionTime = 0;
                }
            }
        }
        
        if (availableAbilities.length > 0) {
            this.useAbility(entityId, availableAbilities[0].id);
        }
    }
    
    useAbility(entityId, abilityId, targetData = null) {
        const abilities = this.entityAbilities.get(entityId);
        if (!abilities) return false;
        
        const ability = abilities.find(a => a.id === abilityId);
        if (!ability) return false;
        

        
        if (!this.isAbilityOffCooldown(entityId, abilityId)) {
            return false;
        }
        
        if (!ability.canExecute(entityId, targetData)) {
            return false;
        }
        
        if (this.game.animationSystem && !ability.isPassive) {
            this.startAbilityAnimation(entityId, ability);
        }
        this.abilityQueue.set(entityId, {
            abilityId: abilityId,
            targetData: targetData,
            executeTime: this.game.state.now + ability.castTime
        });
        
        this.setCooldown(entityId, abilityId, ability.cooldown);
        ability.logAbilityUsage(entityId);
        
        return true;
    }
    
    startAbilityAnimation(entityId, ability) {
        if (!this.game.animationSystem?.triggerSinglePlayAnimation) return;
        
        const animationsToTry = ['attack', 'idle'];
        
        for (const anim of animationsToTry) {
    
            // For abilities, use normal speed unless it's an attack-based ability
            let animationSpeed = 1.0;
            let minAnimationTime = 1.5;                
                    
            if (ability && this.game.combatAISystems) {
                animationSpeed = this.game.combatAISystems.calculateAnimationSpeed(entityId, ability.castTime);
                minAnimationTime = 1 / ability.castTime;
            }
            
            this.game.animationSystem.triggerSinglePlayAnimation(entityId, anim, animationSpeed, minAnimationTime);
            break;
            
        }
    }
    
    setCooldown(entityId, abilityId, cooldownDuration) {
        const key = `${entityId}_${abilityId}`;
        this.abilityCooldowns.set(key, this.game.state.now + cooldownDuration);
    }
    
    isAbilityOffCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd || this.game.state.now >= cooldownEnd;
    }
    
    getRemainingCooldown(entityId, abilityId) {
        const key = `${entityId}_${abilityId}`;
        const cooldownEnd = this.abilityCooldowns.get(key);
        return !cooldownEnd ? 0 : Math.max(0, cooldownEnd - this.game.state.now);
    }
    
    getEntityAbilities(entityId) {
        return this.entityAbilities.get(entityId) || [];
    }
    
    getAbilityCooldowns(entityId) {
        const abilities = this.getEntityAbilities(entityId);

        return abilities.map(ability => ({
            id: ability.id,
            name: ability.name,
            remainingCooldown: this.getRemainingCooldown(entityId, ability.id),
            totalCooldown: ability.cooldown
        }));
    }
    
    createAbility(abilityId) {
        const AbilityClass = this.game.app.appClasses[abilityId];
        return AbilityClass ? new AbilityClass() : null;
    }
    
    getAvailableAbilityIds() {
        return Object.keys(this.game.getCollections().abilities);
    }
        
    removeEntityAbilities(entityId) {
        this.entityAbilities.delete(entityId);
        this.abilityQueue.delete(entityId);
        
        // Clean up cooldowns
        const keysToRemove = [];
        for (const key of this.abilityCooldowns.keys()) {
            if (key.startsWith(`${entityId}_`)) {
                keysToRemove.push(key);
            }
        }
        keysToRemove.forEach(key => this.abilityCooldowns.delete(key));
        
    }
    onPlacementPhaseStart() {
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onPlacementPhaseStart === 'function') {
                    ability.onPlacementPhaseStart(entityId);
                }
            });
        }            
    }     
    onBattleEnd() {
        
        // Call onBattleEnd on all ability instances
        for (const [entityId, abilities] of this.entityAbilities.entries()) {
            abilities.forEach(ability => {
                if (typeof ability.onBattleEnd === 'function') {
                    ability.onBattleEnd(entityId);
                }
            });
        }
        
        // Clear all ability queues and cooldowns
        this.abilityQueue.clear();
        this.abilityActions.clear();
        this.abilityCooldowns.clear();
        this.abilityActionCounter = 0;
        
    }

    destroy() {
        this.entityAbilities.clear();
        this.abilityCooldowns.clear();
        this.abilityQueue.clear();
        this.abilityActions.clear();
    }
    entityDestroyed(entityId) {
        this.removeEntityAbilities(entityId);
    }
};

// System: ParticleSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ParticleSystem'] = class ParticleSystem extends engine.BaseSystem {
  constructor(game) {
    super(game);
    this.game.particleSystem = this;

    this.CAPACITY = 2000;
    this.initialized = false;
    this.activeCount = 0;
    this.freeList = [];

    this.positions = new Array(this.CAPACITY);
    this.velocities = new Array(this.CAPACITY);
    this.gravityArr = new Float32Array(this.CAPACITY);
    this.dragArr = new Float32Array(this.CAPACITY);

    this.aColorStart = new Float32Array(this.CAPACITY * 3);
    this.aColorEnd   = new Float32Array(this.CAPACITY * 3);
    this.aLifetime   = new Float32Array(this.CAPACITY);
    this.aStartTime  = new Float32Array(this.CAPACITY);
    this.aInitScale  = new Float32Array(this.CAPACITY);
    this.aFlags      = new Float32Array(this.CAPACITY * 2);

    this._tmpMat = new THREE.Matrix4();
    this._cursor = 0;

    this.UPDATE_STRIDE = 2;
  }

  initialize() {
    if (this.initialized || !this.game.scene) return;

    const geometry = new THREE.PlaneGeometry(0.25, 0.25);

    const vertexShader = `
      attribute vec3 aColorStart;
      attribute vec3 aColorEnd;
      attribute float aLifetime;
      attribute float aStartTime;
      attribute float aInitScale;
      attribute vec2 aFlags; // x: fadeOut, y: scaleOverTime
      varying vec3 vColor;
      varying float vAlpha;
      varying vec2 vUv;
      uniform float uTime;

      vec3 camRight() { return vec3(modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0]); }
      vec3 camUp()    { return vec3(modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1]); }

      void main() {
        vUv = uv;
        float age = max(uTime - aStartTime, 0.0);
        float lifeT = clamp(1.0 - age / max(aLifetime, 0.0001), 0.0, 1.0);

        vColor = mix(aColorEnd, aColorStart, lifeT);
        vAlpha = aFlags.x > 0.5 ? lifeT : 1.0;

        float s = aInitScale;
        if (aFlags.y > 0.5) {
          if (lifeT > 0.8)       s *= (1.0 - lifeT) * 5.0;
          else if (lifeT > 0.2)  s *= 1.0;
          else                   s *= lifeT * 5.0;
        }

        vec3 right = camRight();
        vec3 up    = camUp();

        vec3 instT = vec3(instanceMatrix[3][0], instanceMatrix[3][1], instanceMatrix[3][2]);
        vec3 worldPos = instT + right * (position.x * s) + up * (position.y * s);

        gl_Position = projectionMatrix * viewMatrix * vec4(worldPos, 1.0);
      }
    `;

    const fragmentShader = `
      precision mediump float;
      varying vec3 vColor;
      varying float vAlpha;
      varying vec2 vUv;

      void main() {
        vec2 c = vUv - vec2(0.5);
        float r = length(c) * 2.0;
        float mask = smoothstep(1.0, 0.6, r);
        float a = vAlpha * mask;

        if (a <= 0.001) discard;

        // CHANGED: simple straight output (no tone mapping), alpha not premultiplied here
        gl_FragColor = vec4(vColor, a); // CHANGED
      }
    `;

    this.material = new THREE.ShaderMaterial({
      vertexShader,
      fragmentShader,
      transparent: true,
      depthWrite: false,
      blending: THREE.NormalBlending,          // CHANGED: sane default; per-effect override allowed
      uniforms: { uTime: { value: 0 } },
      toneMapped: false                        // CHANGED: ensure shader output isn't remapped
    });

    this.mesh = new THREE.InstancedMesh(geometry, this.material, this.CAPACITY);
    this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

    const addAttr = (arr, itemSize, name) => {
      const a = new THREE.InstancedBufferAttribute(arr, itemSize);
      this.mesh.geometry.setAttribute(name, a);
      return a;
    };
    this.attrColorStart = addAttr(this.aColorStart, 3, 'aColorStart');
    this.attrColorEnd   = addAttr(this.aColorEnd,   3, 'aColorEnd');
    this.attrLifetime   = addAttr(this.aLifetime,   1, 'aLifetime');
    this.attrStartTime  = addAttr(this.aStartTime,  1, 'aStartTime');
    this.attrInitScale  = addAttr(this.aInitScale,  1, 'aInitScale');
    this.attrFlags      = addAttr(this.aFlags,      2, 'aFlags');

    for (let i = 0; i < this.CAPACITY; i++) {
      this._writeTranslation(i, 1e9, 1e9, 1e9);
      this.positions[i]  = new THREE.Vector3(1e9, 1e9, 1e9);
      this.velocities[i] = new THREE.Vector3(0, 0, 0);
      this.gravityArr[i] = 0.0;
      this.dragArr[i]    = 1.0;
      this.freeList.push(i);
    }

    this.mesh.frustumCulled = false;
    this.game.scene.add(this.mesh);

    this.initialized = true;
  }

  _writeTranslation(index, x, y, z) {
    const m = this._tmpMat;
    m.identity();
    m.setPosition(x, y, z);
    this.mesh.setMatrixAt(index, m);
  }

  /**
   * createParticles(config)
   * Config preserved:
   *   position, count, lifetime,
   *   visual.{color|colorRange{start,end}|scale|fadeOut|scaleOverTime|blending|scaleMultiplier},
   *   velocityRange, gravity, drag, speedMultiplier, heightOffset, shape? (ignored)
   */
  createParticles(config) {
    if (!this.initialized) {
      this.initialize();
      if (!this.initialized) return;
    }

    const {
      position = new THREE.Vector3(0, 0, 0),
      count = 10,
      lifetime = 1.25,
      visual = {},
      velocityRange = { x: [-30, 30], y: [50, 120], z: [-30, 30] },
      gravity = -100.0,
      drag = 0.98,
      speedMultiplier: speedMulTop = 1.0,
      heightOffset = 0
    } = config;

    // ---------- COLOR RESOLUTION (broad compatibility) ----------
    // CHANGED: find start/end colors across multiple common fields
    const { startColorResolved, endColorResolved } = this._resolveColorPair(config, visual); // CHANGED

    // ---------- SCALE / SPEED ----------
    const scaleMul = (visual.scaleMultiplier != null ? visual.scaleMultiplier : 1.0);
    const initScale = ((visual.scale != null) ? visual.scale : 16.0) * scaleMul;

    const speedMulVisual = (visual.speedMultiplier != null ? visual.speedMultiplier : 1.0);
    const speedMul = speedMulTop * speedMulVisual;

    const fadeOut = (visual.fadeOut === undefined) ? true : !!visual.fadeOut;
    const scaleOverTime = (visual.scaleOverTime === undefined) ? true : !!visual.scaleOverTime;

    // Per-effect blending (global switch for the single material)
    if (visual.blending) {
      const b = String(visual.blending).toLowerCase();
      const target =
        b === 'additive' ? THREE.AdditiveBlending :
        b === 'multiply' ? THREE.MultiplyBlending :
                           THREE.NormalBlending;
      if (this.material.blending !== target) {
        this.material.blending = target;
        this.material.needsUpdate = true;
      }
    }

    const rv = (min, max) => min + Math.random() * (max - min);
    const now = this._now();

    let spawned = 0;
    const want = Math.max(1, Math.floor(count));
    while (spawned < want && this.freeList.length > 0) {
      const i = this.freeList.pop();

      const px = position.x;
      const py = position.y + heightOffset;
      const pz = position.z;

      this.positions[i].set(px, py, pz);
      this._writeTranslation(i, px, py, pz);

      const vx = rv(velocityRange.x[0], velocityRange.x[1]) * speedMul;
      const vy = rv(velocityRange.y[0], velocityRange.y[1]) * speedMul;
      const vz = rv(velocityRange.z[0], velocityRange.z[1]) * speedMul;
      this.velocities[i].set(vx, vy, vz);
      this.gravityArr[i] = gravity;
      this.dragArr[i]    = drag;

      // CHANGED: write resolved colors
      const si = i * 3;
      this.aColorStart[si    ] = startColorResolved.r;
      this.aColorStart[si + 1] = startColorResolved.g;
      this.aColorStart[si + 2] = startColorResolved.b;

      this.aColorEnd[si    ] = endColorResolved.r;
      this.aColorEnd[si + 1] = endColorResolved.g;
      this.aColorEnd[si + 2] = endColorResolved.b;

      this.aLifetime[i]  = lifetime;
      this.aStartTime[i] = now;
      this.aInitScale[i] = initScale;
      this.aFlags[i * 2    ] = fadeOut ? 1.0 : 0.0;
      this.aFlags[i * 2 + 1] = scaleOverTime ? 1.0 : 0.0;

      spawned++;
      this.activeCount++;
    }

    this.attrColorStart.needsUpdate = true;
    this.attrColorEnd.needsUpdate   = true;
    this.attrLifetime.needsUpdate   = true;
    this.attrStartTime.needsUpdate  = true;
    this.attrInitScale.needsUpdate  = true;
    this.attrFlags.needsUpdate      = true;
    this.mesh.instanceMatrix.needsUpdate = true;
  }

  clearAllParticles() {
    if (!this.initialized) return;
    for (let i = 0; i < this.CAPACITY; i++) {
      this.aLifetime[i] = 0.0;
      this._writeTranslation(i, 1e9, 1e9, 1e9);
      this.positions[i].set(1e9, 1e9, 1e9);
      this.velocities[i].set(0, 0, 0);
      this.gravityArr[i] = 0.0;
      this.dragArr[i] = 1.0;
      if (!this.freeList.includes(i)) this.freeList.push(i);
    }
    this.activeCount = 0;
    this.attrLifetime.needsUpdate = true;
    this.mesh.instanceMatrix.needsUpdate = true;
  }

  update() {
    if (!this.initialized) return;

    const dt = this.game?.state?.deltaTime || 0.016;
    const now = this._now();
    this.material.uniforms.uTime.value = now;

    if (this.activeCount === 0) return;

    const total = this.CAPACITY;
    let processed = 0;
    const target = Math.max(1, Math.floor(this.activeCount / this.UPDATE_STRIDE));

    for (let loop = 0; loop < total && processed < target; loop++) {
      const i = this._cursor;
      this._cursor = (this._cursor + 1) % total;

      const life = this.aLifetime[i];
      if (life <= 0.0) continue;

      if ((now - this.aStartTime[i]) >= life) {
        this.aLifetime[i] = 0.0;
        this.attrLifetime.needsUpdate = true;

        this._writeTranslation(i, 1e9, 1e9, 1e9);
        this.mesh.instanceMatrix.needsUpdate = true;

        this.positions[i].set(1e9, 1e9, 1e9);
        this.velocities[i].set(0, 0, 0);
        this.gravityArr[i] = 0.0;
        this.dragArr[i] = 1.0;

        this.freeList.push(i);
        this.activeCount--;
        processed++;
        continue;
      }

      const vel = this.velocities[i];
      vel.y += this.gravityArr[i] * dt;
      vel.x *= this.dragArr[i];
      vel.y *= this.dragArr[i];
      vel.z *= this.dragArr[i];

      const pos = this.positions[i];
      pos.x += vel.x * dt;
      pos.y += vel.y * dt;
      pos.z += vel.z * dt;

      this._writeTranslation(i, pos.x, pos.y, pos.z);
      processed++;
    }

    this.mesh.instanceMatrix.needsUpdate = true;
  }

  destroy() {
    if (!this.initialized) return;
    this.game.scene.remove(this.mesh);
    this.mesh.geometry.dispose();
    this.material.dispose();
    this.initialized = false;
  }

  // ===== helpers =====

  // CHANGED: resolve *pair* of colors from many possible config shapes
  _resolveColorPair(config, visual) {
    // Try pairs first (most explicit)
    const pairCandidates = [
      visual?.colorRange,
      config?.colorRange,
      (visual && (visual.startColor || visual.endColor)) ? { start: visual.startColor, end: visual.endColor } : null,
      (config && (config.startColor || config.endColor)) ? { start: config.startColor, end: config.endColor } : null
    ].filter(Boolean);

    for (const pair of pairCandidates) {
      if (pair?.start != null && pair?.end != null) {
        return {
          startColorResolved: this._resolveColor(pair.start),
          endColorResolved:   this._resolveColor(pair.end)
        };
      }
    }

    // Single color fallbacks (use same for start/end)
    const singleCandidates = [
      visual?.color,
      config?.color
    ].filter((v) => v != null);

    if (singleCandidates.length) {
      const c = this._resolveColor(singleCandidates[0]);
      return { startColorResolved: c, endColorResolved: c };
    }

    // Default white
    const white = { r: 1, g: 1, b: 1 };
    return { startColorResolved: white, endColorResolved: white };
  }

  // Normalize many color forms to {r,g,b} floats (0..1)
  _resolveColor(input) {
    if (input instanceof THREE.Color) {
      return { r: input.r, g: input.g, b: input.b };
    }
    if (typeof input === 'number' || typeof input === 'string') {
      const c = new THREE.Color(input);
      return { r: c.r, g: c.g, b: c.b };
    }
    if (Array.isArray(input) && input.length >= 3) {
      let [r, g, b] = input;
      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }
      return { r, g, b };
    }
    if (input && typeof input === 'object' && 'r' in input && 'g' in input && 'b' in input) {
      let { r, g, b } = input;
      if (r > 1 || g > 1 || b > 1) { r /= 255; g /= 255; b /= 255; }
      return { r, g, b };
    }
    return { r: 1, g: 1, b: 1 };
  }

  _now() {
    if (this.game?.state?.simTime != null) return this.game.state.simTime;
    return performance.now() / 1000;
  }
};

// System: SquadExperienceSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['SquadExperienceSystem'] = class SquadExperienceSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.squadExperienceSystem = this;
        
        // Squad experience tracking
        this.squadExperience = new Map(); // placementId -> experience data
        this.savedSquadExperience = new Map(); // placementId -> saved experience data
        
        // Experience configuration
        this.config = {
            experiencePerLevel: 15,     // Base experience needed per level
            maxLevel: 10,                // Maximum squad level
            levelUpCostRatio: 0.5,       // Cost to level up = squad value * ratio
            experienceMultiplier: 1.0,   // Global experience gain multiplier
            baselineXPPerSecond: 1,   // tune: ~1–3% of a cheap unit’s value per 10s
            baselineXPCombatOnly: true  // only tick during combat phase
        };
        
        // Level bonuses (applied to all units in squad)
        this.levelBonuses = {
            1: { hp: 1.0, damage: 1.0, name: "Rookie" },            
            2: { hp: 1.15, damage: 1.15, name: "Veteran" },
            3: { hp: 1.3, damage: 1.3, name: "Ascended" },
            4: { hp: 1.4, damage: 1.4, name: "Elite" },
            5: { hp: 1.5, damage: 1.5, name: "Champion" },
            6: { hp: 1.6, damage: 1.6, name: "Legendary" },
            7: { hp: 1.7, damage: 1.7, name: "Mythic" },
            8: { hp: 1.8, damage: 1.8, name: "Divine" },
            9: { hp: 1.9, damage: 1.9, name: "Transcendent" },
            10: { hp: 2.0, damage: 2.0, name: "Godlike" }
        };
        
        // UI update throttling
        this.lastUIUpdate = 0;
        this.UI_UPDATE_INTERVAL = 500; // Update UI every 500ms
        
    }
    
    /**
     * Initialize experience tracking for a new squad
     * @param {string} placementId - Unique placement identifier
     * @param {Object} unitType - Unit type definition (not squadData)
     * @param {Array} unitIds - Array of entity IDs in the squad
     * @param {string} team - Team identifier
     */
    initializeSquad(placementId, unitType, unitIds, team) {
        // Check if we already have experience data for this placement ID
        const existingData = this.squadExperience.get(placementId);
        if (existingData) {
       
            // Update unit IDs and size for respawned squad
            existingData.unitIds = [...unitIds];
            existingData.squadSize = unitIds.length;
            
            // Apply level bonuses to new units
            this.applyLevelBonuses(placementId);
            return existingData;
        }
        
        // Create new squad data
        const squadValue = this.calculateSquadValue(unitType);
        
        const experienceData = {
            placementId: placementId,
            level: 1,
            experience: 0,
            experienceToNextLevel: this.calculateExperienceNeeded(0),
            squadValue: squadValue,
            unitIds: [...unitIds],
            team: team,
            squadSize: unitIds.length,
            canLevelUp: false,
            totalUnitsInSquad: unitIds.length, // Just use actual unit count
            lastExperienceGain: 0,
            creationTime: this.game.state.now
        };
        
        this.squadExperience.set(placementId, experienceData);
        
        // Try to restore saved experience for player squads
  
        this.restoreSquadExperience(placementId, experienceData);
        
        // Apply initial bonuses if any
        this.applyLevelBonuses(placementId);
         return experienceData;
    }
    /**
     * Add experience to a squad
     * @param {string} placementId - Squad placement ID
     * @param {number} experience - Experience to add
     */
    addExperience(placementId, experience) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return;
        
        // Don't gain experience if already at max level or ready to level up
        if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) {
            return;
        }
        
        squadData.experience += experience;
        squadData.lastExperienceGain = this.game.state.now;
        
        // Check if squad can level up
        if (squadData.experience >= squadData.experienceToNextLevel) {
            squadData.canLevelUp = true;
            // Stop gaining experience until manually leveled up
            squadData.experience = squadData.experienceToNextLevel;
                
        }
        
        // Update UI periodically
        if (this.game.state.now - this.lastUIUpdate > this.UI_UPDATE_INTERVAL) {
            this.updateSquadUI();
            this.lastUIUpdate = this.game.state.now;
        }
    }
    getLevelUpCost(placementId){
        
        const squadData = this.squadExperience.get(placementId);
        if(squadData){
            const levelUpCost = this.getLevelUpCostBySquadValue(squadData.squadValue)

            return levelUpCost;
        } else {
            return -1;
        }
    }
    getLevelUpCostBySquadValue(squadValue){
        return Math.floor(squadValue * this.config.levelUpCostRatio);
    }
    canAffordLevelUp(placementId, playerGold){
                
        const levelUpCost = this.getLevelUpCost(placementId);

         if (levelUpCost < 0 || playerGold < levelUpCost) {    
            return false;
         }
         return true;
    }
    /**
     * Level up a squad (only during placement phase)
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Optional specialization unit ID (for level 3+)
     * @returns {boolean} Success status
     */
    async levelUpSquad(placementId, specializationId = null, playerId = null, callback) {
        if (this.game.state.phase !== 'placement') {
            console.log("incorrect phase to level up");
            callback(false);
        }
        
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || !squadData.canLevelUp) {
            console.log("squad cant level up", placementId, squadData, this.squadExperience);
            callback(false);
        };        
                        
        // Check for specialization selection UI (unchanged)
        const isSpecializationLevel = squadData.level >= 2;
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        const hasSpecializations = currentUnitType && currentUnitType.specUnits && currentUnitType.specUnits.length > 0;
        if (!this.game.isServer && isSpecializationLevel && hasSpecializations && !specializationId) {
            this.showSpecializationSelection(placementId, squadData, callback);
            console.log('showing spec selection');
            return;
        }
        
        
        try {
            if (!this.game.isServer) {
                // Handle specialization case
                if (specializationId && isSpecializationLevel && hasSpecializations) {
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId, specializationId }, 'SQUAD_LEVELED');
       
                    if (!success) {
                        console.log('no success making network call apply_spec or level_squad');
                        callback(false);
                    } 
                    this.applySpecialization(placementId, specializationId, playerId);
                } else {
                    // Handle regular level up
                    const success = await this.makeNetworkCall('LEVEL_SQUAD', 
                        { placementId }, 'SQUAD_LEVELED');
                    
                    if (!success) {
                        console.log('no success making network call level_squad');
                        callback(false);
                    }
                }
            } 
                
            // Deduct cost optimistically
            callback(this.finishLevelingSquad(squadData, placementId, specializationId));
            
        } catch (error) {
            // Refund gold on any error
            console.log('failed to level squad', error);
            callback(false);
        }
    }

    // Helper method to promisify network calls
    makeNetworkCall(action, data, expectedResponse) {
        return new Promise((resolve, reject) => {
            this.game.clientNetworkManager.call(action, data, expectedResponse, (responseData, error) => {
                if(responseData && responseData.success) {
                    resolve(responseData);
                } else {
                    reject(error);
                }
            });
        });
    }

    finishLevelingSquad(squadData, placementId, specializationId) {
        console.log('finishLevelingSquad');
        // Level up
        squadData.level++;
        squadData.experience = 0;
        squadData.experienceToNextLevel = this.calculateExperienceNeeded(squadData.level);
        squadData.canLevelUp = false;
        
        // Apply level bonuses to all units in squad
        this.applyLevelBonuses(placementId);
        
        const levelUpCost = this.getLevelUpCost(placementId);  
        this.game.state.playerGold -= levelUpCost;
            
        console.log('leveling squad for cost', placementId, levelUpCost);
        // Visual effects
        if (this.game.effectsSystem) {
            squadData.unitIds.forEach(entityId => {
                const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
                if (pos) {
                    const effectType = specializationId ? 'magic' : 'heal';
                    this.game.effectsSystem.createParticleEffect(
                        pos.x, pos.y + 20, pos.z,
                        effectType,
                        { count: 3, speedMultiplier: specializationId ? 1.5 : 1.2 }
                    );
                }
            });
        }
        return true;
    }
    
    /**
     * Apply specialization transformation to a squad
     * @param {string} placementId - Squad placement ID
     * @param {string} specializationId - Specialization unit type ID
     * @returns {boolean} Success status
     */
    applySpecialization(placementId, specializationId, playerId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return false;
        
        // Get the specialization unit type
        const collections = this.game.getCollections();
        if (!collections || !collections.units || !collections.units[specializationId]) {
            console.error(`Specialization unit type ${specializationId} not found`);
            return false;
        }
        
        const specializationUnitType = collections.units[specializationId];
        
        // Find the placement in PlacementSystem to update the unit type
        if (!this.game.placementSystem) {
            console.error('PlacementSystem not found');
            return false;
        }
        
        const placement = this.game.placementSystem.getPlacementById(placementId);
        if (!placement) {
            console.error(`Placement ${placementId} not found`);
            return false;
        }
        
        // Update the placement's unit type
        const oldUnitType = placement.unitType;
        placement.unitType = { id: specializationId, ...specializationUnitType };
        
        // Recreate all units in the squad with the new unit type
        const componentTypes = this.game.componentManager.getComponentTypes();
        const newUnitIds = [];
        
        console.log('applying specialization to ', squadData, squadData.unitIds);
        console.log('placement', placement);
        // Store positions of old units
        const positions = [];
        squadData.unitIds.forEach(entityId => {
            const pos = this.game.getComponent(entityId, componentTypes.POSITION);
            if (pos) {
                positions.push({ x: pos.x, y: pos.y, z: pos.z });
            }
            // Destroy old unit
            if (this.game.destroyEntity) {
                this.game.destroyEntity(entityId);
            }
        });
        
        // Create new specialized units at the same positions
        positions.forEach(pos => {
            const terrainHeight = this.game.unitCreationManager.getTerrainHeight(pos.x, pos.z);
            const unitY = terrainHeight !== null ? terrainHeight : pos.y;
            
            const entityId = this.game.unitCreationManager.create(
                pos.x, unitY, pos.z, 
                placement.targetPosition,
                placement, 
                squadData.team
            );
            console.log('created new unit', placement.unitType, entityId);
            newUnitIds.push(entityId);
        });
        
        // Update squad data with new unit IDs
        squadData.unitIds = newUnitIds;
        
        // Update squad value based on new unit type
        squadData.squadValue = this.calculateSquadValue(placement.unitType);
            // Refresh shop
        if (this.game.shopSystem) {
            this.game.shopSystem.createShop();
        }
        return true;
    }
    
    /**
     * Show specialization selection UI
     * @param {string} placementId - Squad placement ID
     * @param {Object} squadData - Squad experience data
     */
    showSpecializationSelection(placementId, squadData, callback) {
        const currentUnitType = this.getCurrentUnitType(placementId, squadData.team);
        if (!currentUnitType || !currentUnitType.specUnits) return;
        
        const collections = this.game.getCollections();
        if (!collections || !collections.units) return;
        
        // Create specialization selection modal
        const modal = document.createElement('div');
        modal.className = 'specialization-modal';
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.8); z-index: 10000;
            display: flex; justify-content: center; align-items: center;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: linear-gradient(145deg, #1a1a2e, #16213e);
            border: 2px solid #ffaa00; border-radius: 10px;
            padding: 20px; max-width: 600px; width: 90%;
            color: #fff; text-align: center;
        `;
        
        const squadName = this.getSquadDisplayName(placementId);
        content.innerHTML = `
            <h3 style="color: #ffaa00; margin-bottom: 15px;">⭐ SPECIALIZATION AVAILABLE! ⭐</h3>
            <p style="margin-bottom: 20px;">Choose a specialization for your ${squadName}:</p>
            <div id="specialization-options" style="margin-bottom: 20px;"></div>
            <button id="cancel-specialization" style="
                background: #666; color: #fff; border: none; padding: 8px 16px;
                border-radius: 4px; cursor: pointer; margin-right: 10px;
            ">Cancel</button>
        `;
        
        modal.appendChild(content);
        
        // Add specialization options
        const optionsContainer = content.querySelector('#specialization-options');
        currentUnitType.specUnits.forEach(specId => {
            const specUnit = collections.units[specId];
            if (specUnit) {
                const optionButton = document.createElement('button');
                optionButton.style.cssText = `
                    display: block; width: 100%; margin: 8px 0; padding: 12px;
                    background: linear-gradient(135deg, #006600, #008800);
                    color: white; border: 1px solid #00aa00; border-radius: 4px;
                    cursor: pointer; transition: all 0.2s ease;
                `;
                
                const squadValue = this.calculateSquadValue(specUnit);
                const levelUpCost = this.getLevelUpCostBySquadValue(squadValue);
                optionButton.innerHTML = `
                    <strong>${specUnit.title || specId}</strong><br>
                    <small style="opacity: 0.8;">${specUnit.hp || 100} HP, ${specUnit.damage || 10} DMG - Cost: ${levelUpCost}g</small>
                `;
                
                optionButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    this.levelUpSquad(placementId, specId, null, callback);
                });
                
                optionButton.addEventListener('mouseenter', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #008800, #00aa00)';
                    optionButton.style.transform = 'translateY(-2px)';
                });
                
                optionButton.addEventListener('mouseleave', () => {
                    optionButton.style.background = 'linear-gradient(135deg, #006600, #008800)';
                    optionButton.style.transform = 'translateY(0)';
                });
                
                optionsContainer.appendChild(optionButton);
            }
        });
        
        // Cancel button
        content.querySelector('#cancel-specialization').addEventListener('click', () => {
            document.body.removeChild(modal);
        });
        
        // Close on escape
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                document.body.removeChild(modal);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
    }
    
    /**
     * Get the current unit type for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {Object|null} Unit type or null if not found
     */
    getCurrentUnitType(placementId, side) {
        if (!this.game.placementSystem) return null;
        const placements = this.game.placementSystem.getPlacementsForSide(side);
        if(placements){
            const placement = placements.find(p => p.placementId === placementId);
            return placement ? placement.unitType : null;
        }
        return null;
    }
    
    /**
     * Apply level bonuses to all units in a squad
     * @param {string} placementId - Squad placement ID
     */
    applyLevelBonuses(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData || squadData.level <= 1) {
            return;
        }
        
        const bonuses = this.levelBonuses[squadData.level];
        if (!bonuses) {
            return;
        }
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        squadData.unitIds.forEach(entityId => {
            const unitType = this.game.getComponent(entityId, componentTypes.UNIT_TYPE);
            if (unitType) {
                const baseUnitData = this.game.getCollections().units[unitType.id];
            
                // Apply health bonus
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                if (health && bonuses.hp > 1) {
                    const newMaxHealth = Math.floor(baseUnitData.hp * bonuses.hp);
                    const healthIncrease = newMaxHealth - health.max;
                    health.max = newMaxHealth;
                    health.current += healthIncrease; // Also increase current health
                }
                
                // Apply damage bonus
                const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
                if (combat && bonuses.damage > 1) {
                    combat.damage = Math.floor(baseUnitData.damage * bonuses.damage);
                }
                
                // Visual indicator (flash effect)
                const animation = this.game.getComponent(entityId, componentTypes.ANIMATION);
                if (animation) {
                    animation.flash = 0.8;
                }
            }
        });
    }
    
    /**
     * Calculate total health of all units in a squad
     * @param {string} placementId - Squad placement ID
     * @returns {number} Total health
     */
    calculateSquadTotalHealth(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (!squadData) return 100; // Default fallback
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        let totalHealth = 0;
        
        squadData.unitIds.forEach(entityId => {
            const health = this.game.getComponent(entityId, componentTypes.HEALTH);
            if (health) {
                totalHealth += health.max;
            }
        });
        
        return Math.max(1, totalHealth); // Avoid division by zero
    }
    
    /**
     * Calculate squad value based on unit type
     * @param {Object} unitType - Unit type definition
     * @returns {number} Squad value (just the unit's base cost)
     */
    calculateSquadValue(unitType) {
        return unitType.value || 0;
    }
    
    /**
     * Calculate experience needed for next level
     * @param {number} currentLevel - Current level
     * @returns {number} Experience needed
     */
    calculateExperienceNeeded(currentLevel) {
        // Exponential scaling: level 1 = 100, level 2 = 150, level 3 = 225, etc.
        return Math.floor(this.config.experiencePerLevel * Math.pow(1.5, currentLevel));
    }
    
    /**
     * Find squad data by unit entity ID
     * @param {number} entityId - Unit entity ID
     * @returns {Object|null} Squad experience data
     */
    findSquadByUnitId(entityId) {
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.unitIds.includes(entityId)) {
                return squadData;
            }
        }
        return null;
    }
    
    /**
     * Get display name for a squad
     * @param {string} placementId - Squad placement ID
     * @returns {string} Display name
     */
    getSquadDisplayName(placementId) {
        // Try to get the name from placement system
        if (this.game.placementSystem) {
            const playerPlacements = this.game.placementSystem.getPlacementsForSide(this.game.state.mySide);
            const placement = playerPlacements.find(p => p.placementId === placementId);
            if (placement && placement.unitType) {
                return placement.unitType.title || placement.unitType.id || 'Squad';
            }
            
            const enemyPlacements = this.game.placementSystem.enemyPlacements;
            const enemyPlacement = enemyPlacements.find(p => p.placementId === placementId);
            if (enemyPlacement && enemyPlacement.unitType) {
                return enemyPlacement.unitType.title || enemyPlacement.unitType.id || 'Enemy Squad';
            }
        }
        
        return `Squad ${placementId.slice(-4)}`;
    }
    
    /**
     * Get level bonus name
     * @param {number} level - Squad level
     * @returns {string} Bonus name
     */
    getLevelBonusName(level) {
        return this.levelBonuses[level]?.name || '';
    }
    
    /**
     * Update squad experience UI
     */
    updateSquadUI() {
        // This method could update a dedicated squad experience panel
        // For now, we'll just ensure the shop system can access this data
        if (this.game.shopSystem && this.game.shopSystem.updateSquadExperience) {
            this.game.shopSystem.updateSquadExperience();
        }
    }
    
    /**
     * Get all player squads that can level up
     * @returns {Array} Array of squad data that can level up
     */
    getSquadsReadyToLevelUp() {
        const readySquads = [];
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            if (squadData.canLevelUp && squadData.team == this.game.state.mySide) {
                readySquads.push({
                    ...squadData,
                    displayName: this.getSquadDisplayName(placementId),
                    levelUpCost: Math.floor(squadData.squadValue * this.config.levelUpCostRatio),
                    nextLevelName: this.getLevelBonusName(squadData.level + 1)
                });
            }
        }
        
        return readySquads;
    }
    
    /**
     * Get squad experience info for display
     * @param {string} placementId - Squad placement ID
     * @returns {Object} Experience info
     */
    getSquadInfo(placementId) {
        return this.squadExperience.get(placementId);        
    }

    setSquadInfo(placementId, placementExperience){
        if(placementExperience){
            this.squadExperience.set(placementId, placementExperience);
            console.log('applying opponent level bonuses', placementId);
            this.applyLevelBonuses(placementId);
        }
    }

    getExperienceFromPlacements(placements){
        let experience = {};
        placements.forEach((placement) => {
            experience[placement.placementId] = this.getSquadInfo(placement.placementId)
        });
        return experience;
    }
    
    /**
     * Clean up squad data when units are destroyed
     * MODIFIED: Only remove on explicit request, not automatic cleanup
     * @param {string} placementId - Squad placement ID
     */
    removeSquad(placementId) {
        const squadData = this.squadExperience.get(placementId);
        if (squadData) {
           this.squadExperience.delete(placementId);
        }
    }
    
    /**
     * Update method called each frame
     */
    update() {

        this.tickBaselineXP();
    }
    tickBaselineXP() {
        // Optional: restrict to combat only
        if (this.config.baselineXPCombatOnly && this.game?.state?.phase !== 'battle') return;

        for (const [placementId, squadData] of this.squadExperience.entries()) {
            // Respect caps: no gain if at max or waiting for manual level-up
            if (squadData.level >= this.config.maxLevel || squadData.canLevelUp) continue;

            const unitsAliveInSquad = this.unitsAliveInSquad(squadData);
            if (unitsAliveInSquad > 0) {
                const squadLivingRatio = unitsAliveInSquad / squadData.totalUnitsInSquad;                
                const xp = squadLivingRatio * this.config.baselineXPPerSecond * this.game.state.deltaTime * this.config.experienceMultiplier;
                if (xp > 0) this.addExperience(placementId, xp);
            }
        }
    }
    unitsAliveInSquad(squadData) {
        if (!squadData || !squadData.unitIds?.length) return 0;
        const componentTypes = this.game.componentManager.getComponentTypes();
        let count = 0;
        for (const id of squadData.unitIds) {
            const h = this.game.getComponent(id, componentTypes.HEALTH);
            if (h && h.current > 0) count++;
        }
        return count;
    }
    /**
     * Clean up experience data for squads with dead/missing units
     * MODIFIED: Never remove experience data, just update unit lists
     */
    onPlacementPhaseStart() {
        
        this.saveSquadExperience();
        
        const componentTypes = this.game.componentManager.getComponentTypes();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {
            const validUnits = squadData.unitIds.filter(entityId => {
                const health = this.game.getComponent(entityId, componentTypes.HEALTH);
                return health && health.current > 0;
            });
            
            if (validUnits.length < squadData.unitIds.length) {             
                squadData.unitIds = validUnits;
                squadData.squadSize = validUnits.length;
            }
        }
    }
    
    /**
     * Reset all experience data (for new game)
     */
    reset() {
        this.squadExperience.clear();
        this.savedSquadExperience.clear();
    }

    /**
     * Save player squad experience before round cleanup
     */
    saveSquadExperience() {
        this.savedSquadExperience = new Map();
        
        for (const [placementId, squadData] of this.squadExperience.entries()) {

            // Save the experience data
            this.savedSquadExperience.set(placementId, {
                level: squadData.level,
                experience: squadData.experience,
                experienceToNextLevel: squadData.experienceToNextLevel,
                canLevelUp: squadData.canLevelUp,
                squadValue: squadData.squadValue,
                totalUnitsInSquad: squadData.totalUnitsInSquad
            });
            
        }
    }

    /**
     * Restore saved player experience to a respawned squad
     */
    restoreSquadExperience(placementId, squadData) {
        const saved = this.savedSquadExperience.get(placementId);
        if (saved) {
            squadData.level = saved.level;
            squadData.experience = saved.experience;
            squadData.experienceToNextLevel = saved.experienceToNextLevel;
            squadData.canLevelUp = saved.canLevelUp;
            
          
            // Apply level bonuses if squad has levels
            if (squadData.level > 0) {
                this.applyLevelBonuses(placementId);
            }
            
            return true;
        }
        return false;
    }
    /**
     * Get debug information
     * @returns {Object} Debug info
     */
    getDebugInfo() {
        const squads = Array.from(this.squadExperience.values());
        return {
            totalSquads: squads.length,
            leftSquads: squads.filter(s => s.team === 'left').length,
            rightSquads: squads.filter(s => s.team === 'right').length,
            squadsReadyToLevelUp: squads.filter(s => s.canLevelUp).length,
            averageLevel: squads.length > 0 ? squads.reduce((sum, s) => sum + s.level, 0) / squads.length : 0,
            maxLevel: Math.max(0, ...squads.map(s => s.level))
        };
    }
};

// System: LifetimeSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['LifetimeSystem'] = class LifetimeSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.lifetimeSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Configuration
        this.CHECK_INTERVAL = 0.1; // Check lifetimes every 100ms for performance
        this.lastCheck = 0;
        
        // Track entities with custom destruction callbacks
        this.destructionCallbacks = new Map(); // entityId -> callback function
        
        // Track entities that should fade out before destruction
        this.fadeOutEntities = new Map(); // entityId -> fade data
        
        // Statistics
        this.stats = {
            entitiesDestroyed: 0,
            entitiesExpired: 0,
            entitiesFaded: 0
        };
    }
    
    update() {        
        // Only check periodically for performance
        if (this.game.state.now - this.lastCheck < this.CHECK_INTERVAL) return;
        this.lastCheck = this.game.state.now;
        
        // Get all entities with lifetime components
        const lifetimeEntities = this.game.getEntitiesWith(this.componentTypes.LIFETIME);
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (!lifetime) return;
            
            const age = (this.game.state.now - lifetime.startTime);
            
            // Check if entity has expired
            if (age >= lifetime.duration) {
                this.handleExpiredEntity(entityId, lifetime);
            } 
        });
    }
    
    // =============================================
    // ENTITY EXPIRATION HANDLING
    // =============================================
    
    handleExpiredEntity(entityId, lifetime) {
        // Call custom destruction callback if registered
        const callback = this.destructionCallbacks.get(entityId);
        if (callback) {
            try {
                callback(entityId, lifetime);
            } catch (error) {
                console.warn(`Lifetime destruction callback error for entity ${entityId}:`, error);
            }
            this.destructionCallbacks.delete(entityId);
        }
        
        // Special handling for different entity types
        this.handleSpecialEntityTypes(entityId, lifetime);
        
        // Create destruction effects if specified
        this.createDestructionEffects(entityId, lifetime);
        
        // Log destruction if enabled
        this.logEntityDestruction(entityId, lifetime);
        
        // Remove from fade tracking
        this.fadeOutEntities.delete(entityId);
        
        // Destroy the entity
        this.game.destroyEntity(entityId);
        
        // Update statistics
        this.stats.entitiesDestroyed++;
        this.stats.entitiesExpired++;
    }
    
    handleSpecialEntityTypes(entityId, lifetime) {
        // Handle projectiles
        if (this.game.hasComponent(entityId, this.componentTypes.PROJECTILE)) {
            // Clean up projectile-specific data
            if (this.game.projectileSystem && this.game.projectileSystem.projectileTrails) {
                this.game.projectileSystem.projectileTrails.delete(entityId);
            }
        }
        
        // Handle summons
        if (this.game.hasComponent(entityId, this.componentTypes.SUMMONED)) {
            this.handleSummonExpiration(entityId);
        }
        
        // Handle mirror images
        if (this.game.hasComponent(entityId, this.componentTypes.MIRROR_IMAGE)) {
            this.handleMirrorImageExpiration(entityId);
        }
        
        // Handle traps
        if (this.game.hasComponent(entityId, this.componentTypes.TRAP)) {
            this.handleTrapExpiration(entityId);
        }
        
        // Handle temporary effects
        if (this.game.hasComponent(entityId, this.componentTypes.TEMPORARY_EFFECT)) {
            this.handleTemporaryEffectExpiration(entityId);
        }
        
        // Handle mind controlled entities
        if (this.game.hasComponent(entityId, this.componentTypes.MIND_CONTROLLED)) {
            this.handleMindControlExpiration(entityId);
        }
        
        // Handle thorns effect
        if (this.game.thornsEntities && this.game.thornsEntities.has(entityId)) {
            this.game.thornsEntities.delete(entityId);
        }
    }
    
    handleSummonExpiration(entityId) {
        const summonPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (summonPos && this.game.effectsSystem) {
            // Create disappearing effect
            this.game.effectsSystem.createParticleEffect(
                summonPos.x, summonPos.y, summonPos.z, 
                'magic', 
                { count: 3, color: 0x9370DB, scaleMultiplier: 1.5 }
            );
        }
   
    }
    
    handleMirrorImageExpiration(entityId) {
        const imagePos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (imagePos && this.game.effectsSystem) {
            // Create shimmering dissolution effect
            this.game.effectsSystem.createParticleEffect(
                imagePos.x, imagePos.y, imagePos.z, 
                'magic', 
                { count: 3, color: 0x6495ED, scaleMultiplier: 1.2 }
            );
        }
    }
    
    handleTrapExpiration(entityId) {
        const trapPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (trapPos && this.game.effectsSystem) {
            // Create fizzling effect for expired trap
            this.game.effectsSystem.createParticleEffect(
                trapPos.x, trapPos.y, trapPos.z, 
                'magic', 
                { count: 3, color: 0x696969, scaleMultiplier: 0.8 }
            );
        }
        
       
    }
    
    handleTemporaryEffectExpiration(entityId) {
        // For visual effect entities, just let them fade naturally
        const effectPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (effectPos && this.game.effectsSystem) {
            this.game.effectsSystem.createParticleEffect(
                effectPos.x, effectPos.y, effectPos.z, 
                'magic', 
                { count: 3, color: 0xFFFFFF, scaleMultiplier: 0.5 }
            );
        }
    }
    
    handleMindControlExpiration(entityId) {
        const mindControl = this.game.getComponent(entityId, this.componentTypes.MIND_CONTROLLED);
        const targetTeam = this.game.getComponent(entityId, this.componentTypes.TEAM);
        const targetPos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        
        if (mindControl && targetTeam) {
            // Restore original team
            targetTeam.team = mindControl.originalTeam;
            
            // Clear AI target
            const targetAI = this.game.getComponent(entityId, this.componentTypes.AI_STATE);
            if (targetAI && targetAI.aiBehavior) {
                targetAI.target = null;
                targetAI.targetPosition = null;
            }
            
            // Visual effect
            if (targetPos && this.game.effectsSystem) {
                this.game.effectsSystem.createParticleEffect(
                    targetPos.x, targetPos.y, targetPos.z, 
                    'magic', 
                    { count: 3, color: 0xDA70D6, scaleMultiplier: 1.0 }
                );
            }
            
            // Remove mind control component
            this.game.removeComponent(entityId, this.componentTypes.MIND_CONTROLLED);
            
          
        }
    }

    
    // =============================================
    // DESTRUCTION EFFECTS
    // =============================================
    
    createDestructionEffects(entityId, lifetime) {
        if (!lifetime.destructionEffect) return;
        
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (!pos || !this.game.effectsSystem) return;
        
        const effectConfig = lifetime.destructionEffect;
        
        // Create particle effect
        this.game.effectsSystem.createParticleEffect(
            pos.x, pos.y, pos.z,
            effectConfig.type || 'magic',
            {
                count: effectConfig.count || 3,
                color: effectConfig.color || 0xFFFFFF,
                scaleMultiplier: effectConfig.scaleMultiplier || 1.0,
                speedMultiplier: effectConfig.speedMultiplier || 1.0
            }
        );
        
        // Screen effects if specified
        if (effectConfig.screenShake) {
            this.game.effectsSystem.playScreenShake(
                effectConfig.screenShake.duration || 0.2,
                effectConfig.screenShake.intensity || 1
            );
        }
        
        if (effectConfig.screenFlash) {
            this.game.effectsSystem.playScreenFlash(
                effectConfig.screenFlash.color || '#FFFFFF',
                effectConfig.screenFlash.duration || 0.2
            );
        }
    }
    
    // =============================================
    // PUBLIC API METHODS
    // =============================================
    
    /**
     * Add a lifetime component to an entity
     * @param {number} entityId - Entity to add lifetime to
     * @param {number} duration - Duration in seconds
     * @param {Object} options - Additional options
     */
    addLifetime(entityId, duration, options = {}) {
        
        const lifetimeData = {
            duration: duration,
            startTime: this.game.state.now,
            fadeOutDuration: options.fadeOutDuration || 0,
            destructionEffect: options.destructionEffect || null,
            onDestroy: options.onDestroy || null
        };
        
        this.game.addComponent(entityId, this.componentTypes.LIFETIME, lifetimeData);
        
        // Register destruction callback if provided
        if (options.onDestroy && typeof options.onDestroy === 'function') {
            this.destructionCallbacks.set(entityId, options.onDestroy);
        }
        
        return entityId;
    }
    
    /**
     * Extend the lifetime of an entity
     * @param {number} entityId - Entity to extend
     * @param {number} additionalDuration - Additional time in seconds
     */
    extendLifetime(entityId, additionalDuration) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration += additionalDuration;
            return true;
        }
        return false;
    }
    
    /**
     * Reduce the lifetime of an entity
     * @param {number} entityId - Entity to reduce
     * @param {number} reductionAmount - Time to reduce in seconds
     */
    reduceLifetime(entityId, reductionAmount) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            lifetime.duration = Math.max(0, lifetime.duration - reductionAmount);
            return true;
        }
        return false;
    }
    
    /**
     * Get remaining lifetime of an entity
     * @param {number} entityId - Entity to check
     * @returns {number} Remaining time in seconds, or -1 if no lifetime component
     */
    getRemainingLifetime(entityId) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            const age = (this.game.state.now - lifetime.startTime);
            return Math.max(0, (lifetime.duration) - age);
        }
        return -1;
    }
    
    /**
     * Check if an entity will expire soon
     * @param {number} entityId - Entity to check
     * @param {number} threshold - Time threshold in seconds
     * @returns {boolean} True if entity will expire within threshold
     */
    willExpireSoon(entityId, threshold = 5.0) {
        const remaining = this.getRemainingLifetime(entityId);
        return remaining >= 0 && remaining <= threshold;
    }
    
    /**
     * Remove lifetime component from an entity (makes it permanent)
     * @param {number} entityId - Entity to make permanent
     */
    makeEntityPermanent(entityId) {
        if (this.game.hasComponent(entityId, this.componentTypes.LIFETIME)) {
            this.game.removeComponent(entityId, this.componentTypes.LIFETIME);
            this.destructionCallbacks.delete(entityId);
            this.fadeOutEntities.delete(entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Force immediate destruction of an entity with lifetime
     * @param {number} entityId - Entity to destroy
     * @param {boolean} triggerEffects - Whether to trigger destruction effects
     */
    destroyEntityImmediately(entityId, triggerEffects = true) {
        const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
        if (lifetime) {
            if (triggerEffects) {
                this.handleExpiredEntity(entityId, lifetime);
            } else {
                this.destructionCallbacks.delete(entityId);
                this.fadeOutEntities.delete(entityId);
                this.game.destroyEntity(entityId);
                this.stats.entitiesDestroyed++;
            }
            return true;
        }
        return false;
    }
    
    /**
     * Register a custom destruction callback for an entity
     * @param {number} entityId - Entity to register callback for
     * @param {Function} callback - Function to call on destruction
     */
    registerDestructionCallback(entityId, callback) {
        if (typeof callback === 'function') {
            this.destructionCallbacks.set(entityId, callback);
        }
    }
    
    /**
     * Get all entities with lifetime components
     * @returns {Array} Array of entity IDs
     */
    getAllLifetimeEntities() {
        return this.game.getEntitiesWith(this.componentTypes.LIFETIME);
    }
    
    /**
     * Get entities that will expire within a time threshold
     * @param {number} threshold - Time threshold in seconds
     * @returns {Array} Array of entity IDs
     */
    getExpiringEntities(threshold = 5.0) {
        const expiringEntities = [];
        
        const lifetimeEntities = this.getAllLifetimeEntities();
        
        lifetimeEntities.forEach(entityId => {
            const lifetime = this.game.getComponent(entityId, this.componentTypes.LIFETIME);
            if (lifetime) {
                const age = (this.game.state.now - lifetime.startTime);
                const remaining = lifetime.duration - age;
                
                if (remaining <= threshold && remaining > 0) {
                    expiringEntities.push(entityId);
                }
            }
        });
        
        return expiringEntities;
    }
    
    // =============================================
    // LOGGING AND STATISTICS
    // =============================================
    
    logEntityDestruction(entityId, lifetime) {
       
    }
    
    getStatistics() {
        return { ...this.stats };
    }
    
    resetStatistics() {
        this.stats.entitiesDestroyed = 0;
        this.stats.entitiesExpired = 0;
        this.stats.entitiesFaded = 0;
    }
    
    // =============================================
    // SYSTEM MANAGEMENT
    // =============================================
    
    destroy() {
        // Clean up all tracking maps
        this.destructionCallbacks.clear();
        this.fadeOutEntities.clear();
        this.resetStatistics();
    }
};

// System: MultiplayerUISystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['MultiplayerUISystem'] = class MultiplayerUISystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.uiSystem = this;
        
        // State tracking
        this.currentScreen = null;
        this.gameState = null;
        this.config = {
            maxSquadsPerRound: 2,
            numBackgrounds: 5
        };
    }

    // GUTS Manager Interface
    init(params) {
        this.params = params || {};
        this.initializeUI();
        this.setupEventListeners();
    }

    initializeUI() {
        let randomBG = Math.floor(Math.random() * (this.config.numBackgrounds + 1));
        document.body.classList.add(`bg${randomBG}`);
        // Add multiplayer UI elements to existing interface
        const multiplayerHTML = `
            <div id="multiplayerHUD" style="display: none; position: absolute; top: 10px; right: 330px; z-index: 1000;">
                <div class="opponent-info">
                    <h4>Opponent</h4>
                    <div class="opponent-stats">
                        <div>Name: <span id="opponentName">-</span></div>
                        <div>Health: <span id="opponentHealth">100</span></div>
                        <div>Gold: <span id="opponentGold">-</span></div>
                    </div>
                </div>
            </div>
            
            <div id="multiplayerNotifications" style="position: fixed; top: 50px; left: 50%; transform: translateX(-50%); z-index: 2000;">
                <!-- Notifications appear here -->
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', multiplayerHTML);
    }

    handleMultiplayerModeSelection(mode) {
        // Create setup dialog for multiplayer
        const setupDialog = document.createElement('div');
        setupDialog.className = 'multiplayer-setup-dialog modal';

        const interfaceConfig = this.game.getCollections().interfaces[mode.interfaceId]
        setupDialog.innerHTML = interfaceConfig?.html || `Interface ${mode.interfaceId} not found`;

        document.body.appendChild(setupDialog);
        this.setupMultiplayerDialogEvents(setupDialog, mode);
    }

    setupMultiplayerDialogEvents(dialog, mode) {
        const playerNameInput = dialog.querySelector('#playerName');
        const quickMatchBtn = dialog.querySelector('#quickMatchBtn');
        const createRoomBtn = dialog.querySelector('#createRoomBtn');
        const joinRoomBtn = dialog.querySelector('#joinRoomBtn');
        const roomIdInput = dialog.querySelector('#roomIdInput');
        const cancelBtn = dialog.querySelector('#cancelMultiplayerBtn');

        const getPlayerName = () => playerNameInput.value.trim() || 'Player';

        if (quickMatchBtn) {
            quickMatchBtn.addEventListener('click', () => {
                this.game.networkManager.startQuickMatch(getPlayerName());
                dialog.remove();
            });
        }

        if (createRoomBtn) {
            createRoomBtn.addEventListener('click', () => {
                this.game.networkManager.createRoom(getPlayerName(), mode.maxPlayers);
                dialog.remove();
            });
        }

        if (joinRoomBtn) {
            joinRoomBtn.addEventListener('click', () => {
                const roomId = roomIdInput.value.trim().toUpperCase();
                if (roomId) {
                    this.game.networkManager.joinRoom(roomId, getPlayerName());
                    dialog.remove();
                } else {
                    this.showNotification('Please enter a Room ID', 'error');
                }
            });
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => {
                dialog.remove();
            });
        }

        playerNameInput.focus();
        playerNameInput.select();
    }

    toggleReady() {
        // Disable button while updating
        const btn = document.getElementById('player1ReadyBtn');
        if (btn) {
            btn.disabled = true;
            btn.textContent = 'Updating...';
        }
        
        this.game.networkManager.toggleReady(() => {
            
        });
    }
    leaveRoom() {
        this.game.networkManager.leaveRoom();
        this.exitToMainMenu();
    }


    setupEventListeners() {
        // Set up lobby event handlers (these elements created by showLobby)
        document.addEventListener('click', (e) => {
            if (e.target.id === 'player1ReadyBtn') {
                this.toggleReady();
            }
            if (e.target.id === 'leaveLobbyBtn') {
                this.leaveRoom();
            }
        });

    }

    showLobby(gameState, roomId) {
        this.currentScreen = 'lobby';
        this.roomId = roomId;
          
        // Show lobby screen
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        document.getElementById('multiplayerLobby').classList.add('active');

        this.updateLobby(gameState);
    }

    updateLobby(gameState) {
        if (!gameState) return;

        const myPlayerId = this.game.clientNetworkManager.playerId;
        
        // Update room ID
        const lobbyRoomId = document.getElementById('lobbyRoomId');
        if (lobbyRoomId) {
            lobbyRoomId.textContent = this.roomId || '------';
        }
        
        // Update player count
        const playerCount = document.getElementById('playerCount');
        if (playerCount) {
            playerCount.textContent = gameState.players?.length || 0;
        }

        // Update player cards
        if (gameState.players) {
            const myPlayer = gameState.players.find(p => p.id === myPlayerId);
            const opponent = gameState.players.find(p => p.id !== myPlayerId);

            // Update my player card (Player 1)
            if (myPlayer) {
                const player1Name = document.getElementById('player1Name');
                const player1Status = document.getElementById('player1Status');
                const player1ReadyBtn = document.getElementById('player1ReadyBtn');
                const player1Info = document.getElementById('player1Info');

                if (player1Name) {
                    player1Name.textContent = `${myPlayer.name} (You)${myPlayer.isHost ? ' - Host' : ''}`;
                }
                if (player1Status) {
                    player1Status.textContent = myPlayer.ready ? '🟢 Ready for Battle!' : '🟡 Preparing...';
                    player1Status.className = `player-status ${myPlayer.ready ? 'ready' : 'waiting'}`;
                }
                if (player1ReadyBtn) {
                    player1ReadyBtn.disabled = false;
                    player1ReadyBtn.textContent = myPlayer.ready ? '⏳ CANCEL READY' : '🛡️ READY FOR BATTLE';
                    player1ReadyBtn.className = myPlayer.ready ? 'ready-btn ready-state' : 'ready-btn';
                }
                if (player1Info) {
                    player1Info.className = `player-card ${myPlayer.ready ? 'ready' : 'waiting'}`;
                }
            }

            // Update opponent card (Player 2)
            if (opponent) {
                const player2Name = document.getElementById('player2Name');
                const player2Status = document.getElementById('player2Status');
                const player2Info = document.getElementById('player2Info');

                if (player2Info) {
                    player2Info.style.display = 'block';
                    player2Info.className = `player-card ${opponent.ready ? 'ready' : 'waiting'}`;
                }
                if (player2Name) {
                    player2Name.textContent = `${opponent.name}${opponent.isHost ? ' - Host' : ''}`;
                }
                if (player2Status) {
                    player2Status.textContent = opponent.ready ? '🟢 Ready for Battle!' : '🟡 Preparing...';
                    player2Status.className = `player-status ${opponent.ready ? 'ready' : 'waiting'}`;
                }
            } else {
                // Hide opponent card if no second player
                const player2Info = document.getElementById('player2Info');
                if (player2Info) {
                    player2Info.style.display = 'none';
                }
            }

            // Update start game button (only for host)
            const startBtn = document.getElementById('startGameBtn');
            if (startBtn && myPlayer?.isHost) {
                const allReady = gameState.players.every(p => p.ready);
                const canStart = gameState.players.length === 2 && allReady;
                
                startBtn.style.display = gameState.players.length === 2 ? 'block' : 'none';
                startBtn.disabled = !canStart;
                startBtn.textContent = allReady ? '⚡ COMMENCE WAR' : 'Waiting for Ready';
            }

            // Update lobby status message
            const statusMsg = document.getElementById('lobbyStatusMessage');
            if (statusMsg) {
                if (gameState.players.length === 1) {
                    statusMsg.textContent = 'Waiting for worthy opponents...';
                } else if (gameState.players.length === 2) {
                    const allReady = gameState.players.every(p => p.ready);
                    statusMsg.textContent = allReady ? 
                        'All warriors ready! Prepare for battle!' : 
                        'Opponent found! Awaiting ready status...';
                }
            }
        }
    }

    onGameStarted(data) {

        this.currentScreen = 'game';
        
        // Hide lobby, show game
        document.getElementById('multiplayerLobby')?.classList.remove('active');
        document.getElementById('gameScreen')?.classList.add('active');
        
        // Start the game
        this.game.gameManager.startSelectedMode();
        
    }

    showNotification(message, type = 'info', duration = 4000) {
        const notification = document.createElement('div');
        notification.textContent = message;
        
        const colors = {
            info: '#00aaff',
            success: '#00ff00',
            warning: '#ffaa00',
            error: '#ff4444'
        };
        
        const color = colors[type] || colors.info;
        notification.style.cssText = `
            background: rgba(0, 0, 0, 0.9); border: 2px solid ${color};
            color: ${color}; padding: 12px 16px; border-radius: 6px;
            margin-bottom: 8px; font-weight: bold; pointer-events: auto; cursor: pointer;
        `;
        
        notification.onclick = () => notification.remove();
        
        const container = document.getElementById('multiplayerNotifications') || document.body;
        container.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentElement) {
                notification.remove();
            }
        }, duration);
    }
    
    start() {
        this.game.shopSystem.createShop();
        this.game.particleSystem.initialize(); 
        this.game.effectsSystem.initialize();          
    }

    exitToMainMenu() {
        this.currentScreen = null;
        this.roomId = null;
        this.isHost = false;
        this.gameState = null;

        if (this.game.screenManager?.showMainMenu) {
            this.game.screenManager.showMainMenu();
        } else {
            window.location.reload();
        }
    }

 
    dispose() {
        this.networkUnsubscribers.forEach(unsubscribe => {
            if (typeof unsubscribe === 'function') {
                unsubscribe();
            }
        });
        this.networkUnsubscribers = [];
        
    }
    onPlacementPhaseStart() {
        const state = this.game.state;
        state.phase = 'placement';
        state.phaseTimeLeft = null; // No timer in multiplayer
        state.playerReady = false;
        state.enemyPlacementComplete = false; // Actually opponent placement
        state.roundEnding = false;          
    }
    
    onBattleEnd() {

            
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entitiesToDestroy = new Set();
        
        [
            ComponentTypes.CORPSE
        ].forEach(componentType => {
            const entities = this.game.getEntitiesWith(componentType);
            entities.forEach(id => entitiesToDestroy.add(id));
        });
        
        entitiesToDestroy.forEach(entityId => {
            try {
                this.game.destroyEntity(entityId); 
            } catch (error) {
                console.warn(`Error destroying entity ${entityId}:`, error);
            }
        });
        
 
        if (this.game.projectileSystem?.clearAllProjectiles) {
            this.game.projectileSystem.clearAllProjectiles();
        }
        
    }
       
    startVictoryCelebration(victoriousUnits) {
        if (!this.game.animationSystem) return;
        
        // Determine which team won
        const firstUnit = victoriousUnits[0];
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const team = this.game.getComponent(firstUnit, ComponentTypes.TEAM);
        const teamType = team?.team || 'player';
        
        victoriousUnits.forEach(entityId => {
            this.game.animationSystem.startCelebration(entityId, teamType);
        });
    }

    update() {
        this.updatePhaseUI();
        this.updateGoldDisplay();
        this.updateRoundDisplay();
        this.updateSideDisplay();
    }

    handleRoundResult(roundResult) {
        const state = this.game.state;
        state.phase = 'ended'; 
    }

    updatePhaseUI() {
        const state = this.game.state;
        
        // Update round number
 
         
        // Update phase status
        const phaseStatusEl = document.getElementById('phaseStatus');
        if (phaseStatusEl) {
            if (state.phase === 'placement') {
                if (state.playerReady) {
                    phaseStatusEl.textContent = 'Army deployed! Waiting for opponent...';
                } else {
                    phaseStatusEl.textContent = 'Deploy your units and get ready!';
                }
            } else if (state.phase === 'battle') {
                phaseStatusEl.textContent = 'Battle in progress! Watch your units fight!';
            }
        }
    }
    
    updateGoldDisplay() {
        const goldDisplay = document.getElementById('playerGold');
        if (goldDisplay) {
            goldDisplay.textContent = this.game.state.playerGold || 0;
        }
    }
    
    updateRoundDisplay() {
        const roundNumberEl = document.getElementById('currentRound');
        if (roundNumberEl) {
            roundNumberEl.textContent = this.game.state.round || 1;
        }
    }
    updateSideDisplay() {
        const sideDisplay = document.getElementById('playerSide');
        if (sideDisplay) {
            sideDisplay.textContent = this.game.state.mySide || 0;
        }
    }
   
};

// System: SchedulingSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['SchedulingSystem'] = class SchedulingSystem extends engine.BaseSystem {
   constructor(game) {
        super(game);
        this.game.schedulingSystem = this;
        
        // Scheduled actions storage
        this.scheduledActions = new Map();
        this.actionIdCounter = 0;
        
        // Entity tracking for cleanup
        this.entityActions = new Map(); // entityId -> Set of actionIds
    }
    
    update() {
        this.processScheduledActions();
    }
    
    /**
     * Schedule an action to execute after a delay
     * @param {Function} callback - Function to execute
     * @param {number} delaySeconds - Delay in seconds (game time)
     * @param {string|null} entityId - Optional entity ID for tracking/cleanup
     * @returns {string} actionId - Unique identifier for this action
     */
    scheduleAction(callback, delaySeconds, entityId = null) {
        const executeTime = this.game.state.now + delaySeconds;
        const actionId = `action_${this.actionIdCounter++}_${executeTime.toFixed(6)}`;
        
        this.scheduledActions.set(actionId, {
            callback: callback,
            executeTime: executeTime,
            entityId: entityId
        });
        
        // Track entity associations for cleanup
        if (entityId) {
            if (!this.entityActions.has(entityId)) {
                this.entityActions.set(entityId, new Set());
            }
            this.entityActions.get(entityId).add(actionId);
        }
        
        return actionId;
    }
    
    /**
     * Process all scheduled actions that are ready to execute
     */
    processScheduledActions() {
        const actionsToExecute = [];
        
        // Find all actions ready to execute
        for (const [actionId, action] of this.scheduledActions.entries()) {
            if (this.game.state.now >= action.executeTime) {
                actionsToExecute.push({ id: actionId, action: action });
            }
        }
        
        // Sort actions for deterministic execution order
        actionsToExecute.sort((a, b) => {
            // Primary sort: by execution time
            if (Math.abs(a.action.executeTime - b.action.executeTime) > 0.000001) {
                return a.action.executeTime - b.action.executeTime;
            }
            // Secondary sort: by action ID for deterministic tie-breaking
            return a.id.localeCompare(b.id);
        });
        
        // Execute actions in deterministic order
        actionsToExecute.forEach(({ id, action }) => {
            try {
                action.callback();
            } catch (error) {
                console.error(`Error executing scheduled action ${id}:`, error);
            }
            
            // Clean up
            this.removeAction(id, action.entityId);
        });
    }
    
    /**
     * Cancel a scheduled action
     * @param {string} actionId - Action to cancel
     * @returns {boolean} - True if action was found and cancelled
     */
    cancelAction(actionId) {
        const action = this.scheduledActions.get(actionId);
        if (action) {
            this.removeAction(actionId, action.entityId);
            return true;
        }
        return false;
    }
    
    /**
     * Cancel all actions associated with an entity
     * @param {string} entityId - Entity whose actions should be cancelled
     * @returns {number} - Number of actions cancelled
     */
    entityDestroyed(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        if (!entityActionIds) return 0;
        
        let cancelledCount = 0;
        for (const actionId of entityActionIds) {
            if (this.scheduledActions.has(actionId)) {
                this.scheduledActions.delete(actionId);
                cancelledCount++;
            }
        }
        
        this.entityActions.delete(entityId);
        return cancelledCount;
    }
    
    /**
     * Internal method to remove action and clean up tracking
     * @param {string} actionId 
     * @param {string|null} entityId 
     */
    removeAction(actionId, entityId) {
        this.scheduledActions.delete(actionId);
        
        if (entityId && this.entityActions.has(entityId)) {
            this.entityActions.get(entityId).delete(actionId);
            
            // Clean up empty entity tracking
            if (this.entityActions.get(entityId).size === 0) {
                this.entityActions.delete(entityId);
            }
        }
    }
    
    /**
     * Get info about scheduled actions (for debugging)
     * @returns {Object} - Statistics about scheduled actions
     */
    getSchedulingStats() {
        return {
            totalActions: this.scheduledActions.size,
            entitiesWithActions: this.entityActions.size,
            nextActionTime: this.getNextActionTime()
        };
    }
    
    /**
     * Get the time of the next scheduled action
     * @returns {number|null} - Time of next action, or null if none scheduled
     */
    getNextActionTime() {
        let nextTime = null;
        for (const action of this.scheduledActions.values()) {
            if (nextTime === null || action.executeTime < nextTime) {
                nextTime = action.executeTime;
            }
        }
        return nextTime;
    }
    
    /**
     * Check if an entity has scheduled actions
     * @param {string} entityId 
     * @returns {boolean}
     */
    hasEntityActions(entityId) {
        const entityActionIds = this.entityActions.get(entityId);
        return entityActionIds && entityActionIds.size > 0;
    }
    
    /**
     * Clear all scheduled actions (useful for game reset)
     */
    clearAllActions() {
        this.scheduledActions.clear();
        this.entityActions.clear();
    }
    
    /**
     * Convenience method: Schedule a delayed function call
     * @param {Object} obj - Object to call method on
     * @param {string} methodName - Method name to call
     * @param {Array} args - Arguments to pass
     * @param {number} delaySeconds - Delay in seconds
     * @param {string|null} entityId - Optional entity ID
     * @returns {string} actionId
     */
    scheduleMethodCall(obj, methodName, args = [], delaySeconds, entityId = null) {
        return this.scheduleAction(() => {
            if (obj && typeof obj[methodName] === 'function') {
                obj[methodName](...args);
            }
        }, delaySeconds, entityId);
    }
}
;

// System: GoldMineSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['GoldMineSystem'] = class GoldMineSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.goldMineSystem = this;
        this.goldVeinLocations = [];
        this.claimedGoldMines = new Map();
        
        console.log('[GoldMineSystem] Initialized', this.game.isServer ? '(SERVER)' : '(CLIENT)');
    }

    init(params) {
        this.params = params || {};
        this.findGoldVeinLocations();
        console.log('[GoldMineSystem] Init complete. Found', this.goldVeinLocations.length, 'gold veins');
    }

    findGoldVeinLocations() {
        const tileMap = this.game.terrainSystem?.tileMap;
        if (!tileMap?.environmentObjects) {
            console.warn('[GoldMineSystem] No environment objects found');
            return;
        }

        const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        const extendedSize = this.game.terrainSystem?.extendedSize || 0;

        this.goldVeinLocations = tileMap.environmentObjects
            .filter(obj => obj.type === 'goldVein')
            .map(obj => {
                const worldX = (obj.x + extensionSize) - extendedSize / 2;
                const worldZ = (obj.y + extensionSize) - extendedSize / 2;
                
                const gridPos = this.game.gridSystem.worldToGrid(worldX, worldZ);
                
                const gridWidth = obj.placementGridWidth || 2;
                const gridHeight = obj.placementGridHeight || 2;
                
                const cells = this.calculateGoldVeinCells(gridPos, gridWidth, gridHeight);

                return {
                    x: obj.x,
                    y: obj.y,
                    worldX: worldX,
                    worldZ: worldZ,
                    gridPos: gridPos,
                    gridWidth: gridWidth,
                    gridHeight: gridHeight,
                    cells: cells,
                    claimed: false,
                    claimedBy: null,
                    instanceIndex: null,
                    originalIndex: tileMap.environmentObjects.indexOf(obj)
                };
            });

        console.log('[GoldMineSystem] Found gold veins:', this.goldVeinLocations);

        if (!this.game.isServer) {
            this.mapGoldVeinInstances();
        }
    }

    calculateGoldVeinCells(gridPos, gridWidth, gridHeight) {
        const cells = [];
        const startX = gridPos.x - Math.round(gridWidth / 2);
        const startZ = gridPos.z - Math.round(gridHeight / 2);

        for (let z = 0; z < gridHeight; z++) {
            for (let x = 0; x < gridWidth; x++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }

        return cells;
    }

    isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight) {
        const buildingCells = this.calculateGoldVeinCells(gridPos, buildingGridWidth, buildingGridHeight);
        
        for (const vein of this.goldVeinLocations) {
            if (vein.claimed) continue;
            
            if (this.cellsMatch(buildingCells, vein.cells)) {
                return { valid: true, vein: vein };
            }
        }

        return { valid: false };
    }

    cellsMatch(cells1, cells2) {
        if (cells1.length !== cells2.length) return false;

        const cellSet = new Set(cells2.map(c => `${c.x},${c.z}`));
        
        for (const cell of cells1) {
            if (!cellSet.has(`${cell.x},${cell.z}`)) {
                return false;
            }
        }

        return true;
    }

    mapGoldVeinInstances() {
        if (!this.game.worldSystem?.scene) {
            console.warn('[GoldMineSystem] No scene available for mapping instances');
            return;
        }

        const goldVeinInstancedMeshes = [];
        this.game.worldSystem.scene.traverse(child => {
            if (child instanceof THREE.InstancedMesh && child.userData.objectType === 'goldVein') {
                goldVeinInstancedMeshes.push(child);
            }
        });

        let globalIndex = 0;
        for (const vein of this.goldVeinLocations) {
            vein.instanceIndex = globalIndex;
            vein.instancedMeshes = goldVeinInstancedMeshes;
            globalIndex++;
        }
    }

    buildGoldMine(entityId, team, gridPos, buildingGridWidth, buildingGridHeight) {
        
        const validation = this.isValidGoldMinePlacement(gridPos, buildingGridWidth, buildingGridHeight);
        if (!validation.valid) {
            console.warn('[GoldMineSystem] Invalid placement - no matching unclaimed vein');
            return { success: false, error: 'Must be placed on a gold vein' };
        }

        const vein = validation.vein;
        
        vein.claimed = true;
        vein.claimedBy = team;

        let mineModel = null;
        if (!this.game.isServer) {
            mineModel = this.replaceVeinWithMine(vein);
        }

        this.claimedGoldMines.set(entityId, {
            entityId: entityId,
            position: { x: vein.x, z: vein.y },
            worldPosition: { x: vein.worldX, z: vein.worldZ },
            gridPos: vein.gridPos,
            cells: vein.cells,
            veinIndex: vein.originalIndex,
            veinData: vein,
            team: team,
            model: mineModel
        });

        return { success: true };
    }

    destroyGoldMine(entityId) {
        const goldMine = this.claimedGoldMines.get(entityId);
        if (!goldMine) {
            return { success: false, error: 'No gold mine to destroy' };
        }

        // Clear any miners targeting this mine
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && miningState.targetMineEntityId === entityId) {
                miningState.targetMineEntityId = null;
                miningState.targetMinePosition = null;
                miningState.waitingPosition = null;
                miningState.state = 'idle';
            }
        }

        if (!this.game.isServer) {
            console.log('[GoldMineSystem] CLIENT: Restoring vein');
            this.restoreVein(goldMine.veinData);
        } else {
            console.log('[GoldMineSystem] SERVER: Releasing mine claim');
            goldMine.veinData.claimed = false;
            goldMine.veinData.claimedBy = null;
        }
        
        this.claimedGoldMines.delete(entityId);

        console.log('[GoldMineSystem] Gold mine destroyed. Remaining mines:', this.claimedGoldMines.size);
        return { success: true };
    }

    // Check if a mine is currently occupied by looking at component states
    isMineOccupied(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return true;
            }
        }
        
        return false;
    }

    // Get the current miner at a mine by checking component states
    getCurrentMiner(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'mining') {
                return minerEntityId;
            }
        }
        
        return null;
    }

    // Get all miners in queue (waiting_at_mine state) for a specific mine
    getMinersInQueue(mineEntityId) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miners = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        const queuedMiners = [];
        
        for (const minerEntityId of miners) {
            const miningState = this.game.getComponent(minerEntityId, ComponentTypes.MINING_STATE);
            if (miningState && 
                miningState.targetMineEntityId === mineEntityId && 
                miningState.state === 'waiting_at_mine') {
                queuedMiners.push(minerEntityId);
            }
        }
        
        return queuedMiners;
    }

    // Get queue position for a specific miner
    getQueuePosition(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.indexOf(minerEntityId);
    }

    // Check if a miner is next in queue
    isNextInQueue(mineEntityId, minerEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        return queue.length > 0 && queue[0] === minerEntityId;
    }

    // Process next miner in queue when mine becomes available
    processNextInQueue(mineEntityId) {
        const queue = this.getMinersInQueue(mineEntityId);
        
        if (queue.length === 0) {
            return;
        }
        
        const nextMinerId = queue[0];
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const miningState = this.game.getComponent(nextMinerId, ComponentTypes.MINING_STATE);
        
        if (miningState && miningState.state === 'waiting_at_mine') {
            const aiState = this.game.getComponent(nextMinerId, ComponentTypes.AI_STATE);
            const pos = this.game.getComponent(nextMinerId, ComponentTypes.POSITION);
            const vel = this.game.getComponent(nextMinerId, ComponentTypes.VELOCITY);
            
            if (pos && vel && miningState.targetMinePosition) {
                miningState.waitingPosition = null;
                
                pos.x = miningState.targetMinePosition.x;
                pos.z = miningState.targetMinePosition.z;
                vel.vx = 0;
                vel.vz = 0;
                
                miningState.state = 'mining';
                miningState.miningStartTime = this.game.state.now;
                
                if (aiState) {
                    aiState.state = 'idle';
                    aiState.targetPosition = null;
                }
            }
        }
    }

    replaceVeinWithMine(vein) {
        return;
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         const position = new THREE.Vector3(0, -10000, 0);
        //         matrix.makeTranslation(position.x, position.y, position.z);
        //         matrix.scale(new THREE.Vector3(0.001, 0.001, 0.001));
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });
        // } 
    }

    restoreVein(vein) {
        // if (vein.instancedMeshes && vein.instanceIndex !== null) {
        //     const extensionSize = this.game.terrainSystem?.extensionSize || 0;
        //     const extendedSize = this.game.terrainSystem?.extendedSize || 0;
        //     const heightMapSettings = this.game.worldSystem?.heightMapSettings;
            
        //     let height = 0;
        //     if (heightMapSettings?.enabled) {
        //         height = heightMapSettings.heightStep * this.game.terrainSystem.tileMap.extensionTerrainType;
        //     }

        //     const worldX = (vein.x + extensionSize) - extendedSize / 2;
        //     const worldZ = (vein.y + extensionSize) - extendedSize / 2;

        //     const dummy = new THREE.Object3D();
        //     dummy.position.set(worldX, height, worldZ);
        //     dummy.rotation.y = Math.random() * Math.PI * 2;
        //     dummy.scale.set(50, 50, 50);
        //     dummy.updateMatrix();

        //     vein.instancedMeshes.forEach(mesh => {
        //         const matrix = new THREE.Matrix4();
        //         matrix.copy(dummy.matrix);
        //         if (mesh.userData.relativeMatrix) {
        //             matrix.multiply(mesh.userData.relativeMatrix);
        //         }
        //         mesh.setMatrixAt(vein.instanceIndex, matrix);
        //         mesh.instanceMatrix.needsUpdate = true;
        //     });            
        // }

        vein.claimed = false;
        vein.claimedBy = null;
    }

    
    onBattleEnd() {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entities = this.game.getEntitiesWith(ComponentTypes.MINING_STATE);
        
        entities.forEach(entityId => {
            const miningState = this.game.getComponent(entityId, ComponentTypes.MINING_STATE);
            if (miningState) {
                miningState.miningStartTime = 0;
                miningState.depositStartTime = 0;
            }
        });
    }

    reset() {
        
        if (!this.game.isServer) {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                this.restoreVein(goldMine.veinData, goldMine.model);
            }
        } else {
            for (const [entityId, goldMine] of this.claimedGoldMines) {
                goldMine.veinData.claimed = false;
                goldMine.veinData.claimedBy = null;
            }
        }
        
        this.claimedGoldMines.clear();
        
    }
};

// System: PathfindingSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['PathfindingSystem'] = class PathfindingSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.pathfindingSystem = this;
        
        this.navMesh = null;
        this.navGridSize = 32;
        this.navGridWidth = 0;
        this.navGridHeight = 0;
        
        this.terrainTypes = null;
        this.walkabilityCache = new Map();
        
        this.pathCache = new Map();
        this.MAX_CACHE_SIZE = 1000;
        this.CACHE_EXPIRY_TIME = 5000;
        
        this.pathRequests = [];
        this.MAX_PATHS_PER_FRAME = 10;
        
        this.initialized = false;
    }

    init() {
        if (this.initialized) return;
        
        const collections = this.game.getCollections();
        if (!collections) {
            console.warn('PathfindingSystem: Collections not available');
            return;
        }
        
        const level = collections.levels?.[this.game.state.level];
        if (!level || !level.tileMap) {
            console.warn('PathfindingSystem: Level or tileMap not available');
            return;
        }
        
        if (!this.game.terrainSystem || !this.game.terrainSystem.initialized) {
            console.warn('PathfindingSystem: Waiting for terrain system...');
            return;
        }
        
        this.terrainTypes = level.tileMap.terrainTypes;
        if (!this.terrainTypes) {
            console.warn('PathfindingSystem: No terrain types found in level');
            return;
        }
        
        this.buildWalkabilityCache();
        this.bakeNavMesh();
        this.initialized = true;
        console.log('PathfindingSystem: Initialized with', this.terrainTypes.length, 'terrain types');
    }

    buildWalkabilityCache() {
        this.walkabilityCache.clear();
        
        for (let i = 0; i < this.terrainTypes.length; i++) {
            const terrainType = this.terrainTypes[i];
            const walkableNeighbors = terrainType.walkableNeighbors || [];
            
            for (let j = 0; j < this.terrainTypes.length; j++) {
                const targetType = this.terrainTypes[j].type;
                const canWalk = walkableNeighbors.includes(targetType);
                
                const key = `${i}-${j}`;
                this.walkabilityCache.set(key, canWalk);
            }
        }
    }

    canWalkBetweenTerrains(fromTerrainIndex, toTerrainIndex) {
        const key = `${fromTerrainIndex}-${toTerrainIndex}`;
        return this.walkabilityCache.get(key) === true;
    }

    bakeNavMesh() {
        const terrainSize = this.game.terrainSystem.terrainSize;
        
        this.navGridWidth = Math.ceil(terrainSize / this.navGridSize);
        this.navGridHeight = Math.ceil(terrainSize / this.navGridSize);
        
        this.navMesh = new Uint8Array(this.navGridWidth * this.navGridHeight);
        
        const halfTerrain = terrainSize / 2;
        
        for (let z = 0; z < this.navGridHeight; z++) {
            for (let x = 0; x < this.navGridWidth; x++) {
                const worldX = (x * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                const worldZ = (z * this.navGridSize) - halfTerrain + this.navGridSize / 2;
                
                const terrainType = this.game.terrainSystem.getTerrainTypeAtPosition(worldX, worldZ);
                
                const idx = z * this.navGridWidth + x;
                this.navMesh[idx] = terrainType !== null ? terrainType : 0;
            }
        }
        
        console.log(`PathfindingSystem: Baked nav mesh ${this.navGridWidth}x${this.navGridHeight}`);
    }

    worldToNavGrid(worldX, worldZ) {
        const halfTerrain = this.game.terrainSystem.terrainSize / 2;
        const gridX = Math.floor((worldX + halfTerrain) / this.navGridSize);
        const gridZ = Math.floor((worldZ + halfTerrain) / this.navGridSize);
        return { x: gridX, z: gridZ };
    }

    navGridToWorld(gridX, gridZ) {
        const halfTerrain = this.game.terrainSystem.terrainSize / 2;
        const worldX = (gridX * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        const worldZ = (gridZ * this.navGridSize) - halfTerrain + this.navGridSize / 2;
        return { x: worldX, z: worldZ };
    }

    getTerrainAtNavGrid(gridX, gridZ) {
        if (gridX < 0 || gridX >= this.navGridWidth || gridZ < 0 || gridZ >= this.navGridHeight) {
            return null;
        }
        return this.navMesh[gridZ * this.navGridWidth + gridX];
    }

    requestPath(entityId, startX, startZ, endX, endZ, priority = 0) {
        const cacheKey = `${Math.floor(startX/50)},${Math.floor(startZ/50)}-${Math.floor(endX/50)},${Math.floor(endZ/50)}`;
        
        const cached = this.pathCache.get(cacheKey);
        if (cached && (this.game.state.now - cached.timestamp) < this.CACHE_EXPIRY_TIME) {
            return cached.path;
        }
        
        this.pathRequests.push({
            entityId,
            startX,
            startZ,
            endX,
            endZ,
            priority,
            cacheKey,
            timestamp: this.game.state.now
        });
        
        return null;
    }

    findPath(startX, startZ, endX, endZ, cacheKey = null) {
        const startGrid = this.worldToNavGrid(startX, startZ);
        const endGrid = this.worldToNavGrid(endX, endZ);
        
        if (startGrid.x === endGrid.x && startGrid.z === endGrid.z) {
            return [{ x: endX, z: endZ }];
        }
        
        const openSet = new GUTS.MinHeap();
        const closedSet = new Set();
        const cameFrom = new Map();
        const gScore = new Map();
        const fScore = new Map();
        
        const startKey = `${startGrid.x},${startGrid.z}`;
        const endKey = `${endGrid.x},${endGrid.z}`;
        
        gScore.set(startKey, 0);
        fScore.set(startKey, this.heuristic(startGrid, endGrid));
        openSet.push({ key: startKey, x: startGrid.x, z: startGrid.z, f: fScore.get(startKey) });
        
        const directions = [
            {dx: 1, dz: 0}, {dx: -1, dz: 0}, {dx: 0, dz: 1}, {dx: 0, dz: -1},
            {dx: 1, dz: 1}, {dx: -1, dz: 1}, {dx: 1, dz: -1}, {dx: -1, dz: -1}
        ];
        
        let iterations = 0;
        const maxIterations = this.navGridWidth * this.navGridHeight;
        
        while (!openSet.isEmpty() && iterations < maxIterations) {
            iterations++;
            
            const current = openSet.pop();
            const currentKey = current.key;
            
            if (currentKey === endKey) {
                const path = this.reconstructPath(cameFrom, currentKey, endX, endZ);
                
                if (cacheKey) {
                    this.addToCache(cacheKey, path);
                }
                
                return path;
            }
            
            closedSet.add(currentKey);
            
            const currentTerrain = this.getTerrainAtNavGrid(current.x, current.z);
            
            for (const dir of directions) {
                const neighborX = current.x + dir.dx;
                const neighborZ = current.z + dir.dz;
                const neighborKey = `${neighborX},${neighborZ}`;
                
                if (closedSet.has(neighborKey)) continue;
                
                const neighborTerrain = this.getTerrainAtNavGrid(neighborX, neighborZ);
                if (neighborTerrain === null) continue;
                
                if (!this.canWalkBetweenTerrains(currentTerrain, neighborTerrain)) {
                    continue;
                }
                
                const isDiagonal = dir.dx !== 0 && dir.dz !== 0;
                const moveCost = isDiagonal ? 1.414 : 1;
                const tentativeGScore = gScore.get(currentKey) + moveCost;
                
                if (!gScore.has(neighborKey) || tentativeGScore < gScore.get(neighborKey)) {
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentativeGScore);
                    
                    const h = this.heuristic({x: neighborX, z: neighborZ}, endGrid);
                    const f = tentativeGScore + h;
                    fScore.set(neighborKey, f);
                    
                    openSet.push({ key: neighborKey, x: neighborX, z: neighborZ, f });
                }
            }
        }
        
        return null;
    }

    reconstructPath(cameFrom, currentKey, endX, endZ) {
        const path = [];
        const gridPath = [];
        
        let current = currentKey;
        while (current) {
            const [x, z] = current.split(',').map(Number);
            gridPath.unshift({ x, z });
            current = cameFrom.get(current);
        }
        
        for (const gridPoint of gridPath) {
            const worldPos = this.navGridToWorld(gridPoint.x, gridPoint.z);
            path.push(worldPos);
        }
        
        if (path.length > 0) {
            path[path.length - 1] = { x: endX, z: endZ };
        }
        
        return this.smoothPath(path);
    }

    smoothPath(path) {
        if (path.length <= 2) return path;
        
        const smoothed = [path[0]];
        let currentIdx = 0;
        
        while (currentIdx < path.length - 1) {
            let farthestVisible = currentIdx + 1;
            
            for (let i = path.length - 1; i > currentIdx + 1; i--) {
                if (this.hasLineOfSight(path[currentIdx], path[i])) {
                    farthestVisible = i;
                    break;
                }
            }
            
            smoothed.push(path[farthestVisible]);
            currentIdx = farthestVisible;
        }
        
        return smoothed;
    }

    hasLineOfSight(from, to) {
        const fromGrid = this.worldToNavGrid(from.x, from.z);
        const toGrid = this.worldToNavGrid(to.x, to.z);
        
        const dx = Math.abs(toGrid.x - fromGrid.x);
        const dz = Math.abs(toGrid.z - fromGrid.z);
        const sx = fromGrid.x < toGrid.x ? 1 : -1;
        const sz = fromGrid.z < toGrid.z ? 1 : -1;
        let err = dx - dz;
        
        let x = fromGrid.x;
        let z = fromGrid.z;
        let lastTerrain = this.getTerrainAtNavGrid(x, z);
        
        while (true) {
            if (x === toGrid.x && z === toGrid.z) return true;
            
            const currentTerrain = this.getTerrainAtNavGrid(x, z);
            if (currentTerrain === null) return false;
            
            if (!this.canWalkBetweenTerrains(lastTerrain, currentTerrain)) {
                return false;
            }
            
            lastTerrain = currentTerrain;
            
            const e2 = 2 * err;
            if (e2 > -dz) {
                err -= dz;
                x += sx;
            }
            if (e2 < dx) {
                err += dx;
                z += sz;
            }
        }
    }

    heuristic(a, b) {
        const dx = Math.abs(a.x - b.x);
        const dz = Math.abs(a.z - b.z);
        return Math.sqrt(dx * dx + dz * dz);
    }

    addToCache(key, path) {
        if (this.pathCache.size >= this.MAX_CACHE_SIZE) {
            const oldestKey = null;
            let oldestTime = Infinity;
            
            for (const [k, v] of this.pathCache.entries()) {
                if (v.timestamp < oldestTime) {
                    oldestTime = v.timestamp;
                    oldestKey = k;
                }
            }
            
            if (oldestKey) {
                this.pathCache.delete(oldestKey);
            }
        }
        
        this.pathCache.set(key, {
            path: path,
            timestamp: this.game.state.now
        });
    }

    clearPathCache() {
        this.pathCache.clear();
    }

    update() {
        if (!this.initialized) {
            this.init();
            return;
        }
        
        const now = this.game.state.now;
        const keysToDelete = [];
        
        for (const [key, data] of this.pathCache.entries()) {
            if (now - data.timestamp > this.CACHE_EXPIRY_TIME) {
                keysToDelete.push(key);
            }
        }
        
        keysToDelete.sort();
        for (const key of keysToDelete) {
            this.pathCache.delete(key);
        }
        
        if (this.pathRequests.length === 0) return;
        
        this.pathRequests.sort((a, b) => {
            if (b.priority !== a.priority) return b.priority - a.priority;
            return String(a.entityId).localeCompare(String(b.entityId));
        });
        
        const pathsToProcess = Math.min(this.MAX_PATHS_PER_FRAME, this.pathRequests.length);
        
        for (let i = 0; i < pathsToProcess; i++) {
            const request = this.pathRequests.shift();
            
            const path = this.findPath(
                request.startX,
                request.startZ,
                request.endX,
                request.endZ,
                request.cacheKey
            );
            
            if (path && this.game.componentManager) {
                const componentTypes = this.game.componentManager.getComponentTypes();
                const aiState = this.game.getComponent(request.entityId, componentTypes.AI_STATE);
                
                if (aiState) {
                    aiState.path = path;
                    aiState.pathIndex = 0;
                }
            }
        }
    }

    ping() {
        console.log('pong');
    }
}

;

// System: FogOfWarSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['FogOfWarSystem'] = class FogOfWarSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.fogOfWarSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();

        this.VISION_RADIUS = 500;
        this.WORLD_SIZE = this.game.worldSystem.extendedSize;
        this.FOG_TEXTURE_SIZE = 64; // Increased for smoother edges

        this.fogRenderTarget = null;
        this.explorationRenderTarget = null;
        this.explorationRenderTargetPingPong = null;
        this.fogScene = null;
        this.fogCamera = null;
        this.fogPass = null;

        // No more CPU buffers needed!
        
        // Reusable circle pool
        this.circlePool = [];
        this.circleGeometry = null;
        this.circleMaterial = null;
        
        // Accumulation shader for exploration
        this.accumulationMaterial = null;
        this.accumulationQuad = null;
        this.accumulationScene = null;
        this.accumulationCamera = null;
        
        this.pixelBuffer = new Uint8Array(4);
        
        this.cachedVisibilityBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE * 4);
        this.cachedExplorationBuffer = new Uint8Array(this.FOG_TEXTURE_SIZE * this.FOG_TEXTURE_SIZE * 4);
        this.visibilityCacheValid = false;
        this.explorationCacheValid = false;
        this.isVisibleAtCount = 0;
        this.isExploredAtCount = 0;
    }


    init(params = {}) {
        this.params = params;
        
        this.fogRenderTarget = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );
        
        // Render target for persistent exploration
        this.explorationRenderTarget = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );
        
        this.explorationRenderTargetPingPong = new THREE.WebGLRenderTarget(
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );
        
        const halfSize = this.WORLD_SIZE / 2;
        this.fogCamera = new THREE.OrthographicCamera(
            -halfSize, halfSize,
            halfSize, -halfSize,
            0.1, 1000
        );
        this.fogCamera.position.set(0, 500, 0);
        this.fogCamera.lookAt(0, 0, 0);
        this.fogScene = new THREE.Scene();
        this.fogScene.background = new THREE.Color(0x000000);
        
        this.circleTexture = this.createGradientCircleTexture();
        
        // Create shared geometry and material
        this.circleGeometry = new THREE.CircleGeometry(1, 32);
        this.circleMaterial = new THREE.MeshBasicMaterial({
            map: this.circleTexture,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        
        // Create accumulation shader (max blending for exploration)
        this.accumulationMaterial = new THREE.ShaderMaterial({
            uniforms: {
                currentExploration: { value: null },
                newVisibility: { value: null }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D currentExploration;
                uniform sampler2D newVisibility;
                varying vec2 vUv;
                
                void main() {
                    float explored = texture2D(currentExploration, vUv).r;
                    float visible = texture2D(newVisibility, vUv).r;
                    float newExploration = max(explored, visible);
                    gl_FragColor = vec4(newExploration, newExploration, newExploration, 1.0);
                }
            `
        });
        
        // Create accumulation scene (reused every frame)
        this.accumulationQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            this.accumulationMaterial
        );
        this.accumulationScene = new THREE.Scene();
        this.accumulationScene.add(this.accumulationQuad);
        this.accumulationCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        console.log('[FogOfWarSystem] GPU-accelerated RTS-style fog initialized');
    }

    postAllInit() {
        if (this.game.postProcessingSystem) {
            this.createFogPass();
            this.game.postProcessingSystem.registerPass('fog', {
                enabled: true,
                pass: this.fogPass
            });
        }
    }

    update() {
     
        
        this.isVisibleAtCount = 0;
        this.isExploredAtCount = 0;
    }

    createFogPass() {
        this.fogPass = {
            enabled: true,
            needsSwap: true,
            clear: false,
                                    
            uniforms: {
                tDiffuse: { value: null },
                tDepth: { value: null },
                fogTexture: { value: this.fogRenderTarget.texture },
                explorationTexture: { value: this.explorationRenderTarget.texture },
                worldSize: { value: this.WORLD_SIZE },
                cameraNear: { value: 1 },
                cameraFar: { value: 100 },
                cameraWorldMatrix: { value: new THREE.Matrix4() },
                cameraProjectionMatrixInv: { value: new THREE.Matrix4() }
            },
            
            material: null,
            fsQuad: null,
            fsQuadScene: null,
            fsQuadCamera: null
        };

        this.fogPass.material = new THREE.ShaderMaterial({
            uniforms: this.fogPass.uniforms,
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform sampler2D tDepth;
                uniform sampler2D fogTexture;
                uniform sampler2D explorationTexture;
                uniform float worldSize;
                uniform float cameraNear;
                uniform float cameraFar;
                uniform mat4 cameraWorldMatrix;
                uniform mat4 cameraProjectionMatrixInv;

                varying vec2 vUv;
                
                float readDepth(vec2 coord) {
                    return texture2D(tDepth, coord).x;
                }
                
                float perspectiveDepthToViewZ(float depth, float near, float far) {
                    return (near * far) / ((far - near) * depth - far);
                }
                
                vec3 getWorldPosition(vec2 uv, float depth) {
                    // NDC coordinates
                    float x = uv.x * 2.0 - 1.0;
                    float y = uv.y * 2.0 - 1.0;
                    float z = depth * 2.0 - 1.0;
                    
                    vec4 clipPos = vec4(x, y, z, 1.0);
                    
                    // To view space
                    vec4 viewPos = cameraProjectionMatrixInv * clipPos;
                    viewPos /= viewPos.w;
                    
                    // To world space
                    vec4 worldPos = cameraWorldMatrix * viewPos;
                    
                    return worldPos.xyz;
                }

                void main() {
                    vec4 sceneColor = texture2D(tDiffuse, vUv);
                    float unexploredIntensity = 0.025;
                    float exploredIntensity = 0.2;
                    // Read depth and reconstruct world position
                    float depth = readDepth(vUv);
                    vec3 worldPos = getWorldPosition(vUv, depth);
                    
                    // Convert world XZ to fog UV
                    float halfSize = worldSize * 0.5;
                    vec2 fogUV = vec2(
                        (worldPos.x + halfSize) / worldSize,
                        (-worldPos.z + halfSize) / worldSize
                    );
                    
                    vec3 grayscale = vec3(dot(sceneColor.rgb, vec3(0.299, 0.587, 0.114)));
                    // Check bounds - out of bounds is unexplored
                    float inset = 1e-4;
                    if (fogUV.x < inset || fogUV.x > 1.0 - inset ||
                        fogUV.y < inset || fogUV.y > 1.0 - inset) {
                        // Completely black (unexplored)
                        gl_FragColor = vec4(grayscale * unexploredIntensity, 1.0);
                        return;
                    }
                    
                    // Sample gradient fog texture (smooth visibility with gradients)
                    vec4 fogSample = texture2D(fogTexture, fogUV);
                    float visibleGradient = fogSample.r; // Smooth gradient from circles
                    
                    // Sample exploration texture (now also has gradients)
                    vec4 explorationSample = texture2D(explorationTexture, fogUV);
                    float explorationGradient = explorationSample.g;
                    
                    // Calculate explored color (darkened/desaturated)
                    vec3 exploredColor = sceneColor.rgb * exploredIntensity;
                    
                    // Blend between explored and fully visible based on visibility gradient
                    vec3 visibleColor = mix(exploredColor, sceneColor.rgb, visibleGradient);
                    
                    // Finally, blend from black (unexplored) to visible/explored based on exploration gradient
                    vec3 finalColor = mix(grayscale * unexploredIntensity, visibleColor, explorationGradient);
                    
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `

        });
        
        const geometry = new THREE.PlaneGeometry(2, 2);
        const mesh = new THREE.Mesh(geometry, this.fogPass.material);
        const scene = new THREE.Scene();
        scene.add(mesh);
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        // Set these BEFORE creating the render function
        this.fogPass.fsQuadScene = scene;
        this.fogPass.fsQuadCamera = camera;
        
        const fogPassObj = this.fogPass;
        const fogSystemRef = this;
        
        // Create fsQuad object
        this.fogPass.fsQuad = {
            render: (renderer) => {
                renderer.render(fogPassObj.fsQuadScene, fogPassObj.fsQuadCamera);
            }
        };
        
        // NOW create the pass render function (after fsQuad exists)
        this.fogPass.render = function(renderer, writeBuffer, readBuffer) {
            // CRITICAL: Update camera matrices RIGHT NOW to match the depth buffer
            // that was just rendered, preventing lag/swimming effect
            if (fogSystemRef.game.camera) {
                fogPassObj.uniforms.cameraWorldMatrix.value.copy(fogSystemRef.game.camera.matrixWorld);
                fogPassObj.uniforms.cameraProjectionMatrixInv.value.copy(fogSystemRef.game.camera.projectionMatrixInverse);
                fogPassObj.uniforms.cameraNear.value = fogSystemRef.game.camera.near;
                fogPassObj.uniforms.cameraFar.value = fogSystemRef.game.camera.far;
            }
            
            fogSystemRef.renderFogTexture();
            
            fogPassObj.uniforms.tDiffuse.value = readBuffer.texture;
            fogPassObj.uniforms.tDepth.value = readBuffer.depthTexture;
            
            if (fogPassObj.needsSwap) {
                renderer.setRenderTarget(writeBuffer);
            } else {
                renderer.setRenderTarget(null);
            }
            
            fogPassObj.fsQuad.render(renderer);
        };
                
        this.fogPass.setSize = function(width, height) {
            // No-op
        };
    }

    renderFogTexture() {
        const myTeam = this.game.state.mySide;
        if (!myTeam) return;

        const myUnits = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM,
            this.componentTypes.HEALTH
        ).filter(id => {
            const team = this.game.getComponent(id, this.componentTypes.TEAM);
            return team?.team === myTeam;
        });

        // Hide all circles first
        this.circlePool.forEach(circle => circle.visible = false);

        // Position visible circles for each unit
        myUnits.forEach((entityId, index) => {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            if (!pos) return;

            // Reuse or create circle
            let circle;
            if (index < this.circlePool.length) {
                circle = this.circlePool[index];
                circle.visible = true;
            } else {
                circle = new THREE.Mesh(this.circleGeometry, this.circleMaterial);
                circle.rotation.x = -Math.PI / 2;
                this.circlePool.push(circle);
                this.fogScene.add(circle);
            }
            let visionRadius = unitType.visionRange || this.VISION_RADIUS;
            circle.scale.set(visionRadius, visionRadius, visionRadius);
            circle.position.set(pos.x, 0, pos.z);
        });

        // Render current visibility to fogRenderTarget (GPU, fast!)
        this.game.renderer.setRenderTarget(this.fogRenderTarget);
        this.game.renderer.render(this.fogScene, this.fogCamera);
        
        // Accumulate into exploration using GPU shader
        // This does: exploration = max(exploration, visibility)
        this.accumulationMaterial.uniforms.currentExploration.value = this.explorationRenderTarget.texture;
        this.accumulationMaterial.uniforms.newVisibility.value = this.fogRenderTarget.texture;
        
        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);
        
        // Render fullscreen quad with accumulation shader (scene already created in init)
        this.game.renderer.render(this.accumulationScene, this.accumulationCamera);
        
        // Swap render targets (no allocation/deallocation!)
        const temp = this.explorationRenderTarget;
        this.explorationRenderTarget = this.explorationRenderTargetPingPong;
        this.explorationRenderTargetPingPong = temp;
        
        // Update uniform reference
        this.fogPass.uniforms.explorationTexture.value = this.explorationRenderTarget.texture;
        
        this.game.renderer.setRenderTarget(null);
        
        this.visibilityCacheValid = false;
        this.explorationCacheValid = false;
    }

    createGradientCircleTexture() {
        const size = 128;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        
        const centerX = size / 2;
        const centerY = size / 2;
        const radius = size / 2;
        
        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(0.7, 'rgba(255, 255, 255, 1.0)');
        gradient.addColorStop(1.0, 'rgba(255, 255, 255, 0.0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, size, size);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    setVisionRadius(radius) {
        this.VISION_RADIUS = radius;
        console.log(`[FogOfWarSystem] Vision radius set to ${radius}`);
    }

    updateVisibilityCache() {
        if (this.visibilityCacheValid) return;
        

        this.game.renderer.readRenderTargetPixels(
            this.fogRenderTarget,
            0, 0,
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            this.cachedVisibilityBuffer
        );
        
        this.visibilityCacheValid = true;
    }

    updateExplorationCache() {
        if (this.explorationCacheValid) return;
        
        this.game.renderer.readRenderTargetPixels(
            this.explorationRenderTarget,
            0, 0,
            this.FOG_TEXTURE_SIZE,
            this.FOG_TEXTURE_SIZE,
            this.cachedExplorationBuffer
        );
        
        this.explorationCacheValid = true;
    }

    isVisibleAt(x, z) {
        this.isVisibleAtCount += 1;
 
        const uv = this.worldToUV(x, z);
        if (!uv) return false;
        
        this.updateVisibilityCache();
        
        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);
        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);
        const index = (py * this.FOG_TEXTURE_SIZE + px) * 4;
        
        return this.cachedVisibilityBuffer[index] > 0;
    }

    isExploredAt(x, z) {
        this.isExploredAtCount += 1;

        const uv = this.worldToUV(x, z);
        if (!uv) return false;
        
        this.updateExplorationCache();
        
        const px = Math.floor(uv.x * this.FOG_TEXTURE_SIZE);
        const py = Math.floor(uv.y * this.FOG_TEXTURE_SIZE);
        const index = (py * this.FOG_TEXTURE_SIZE + px) * 4;
        
        return this.cachedExplorationBuffer[index] > 0;
    }

    worldToUV(x, z) {
        const half = this.WORLD_SIZE * 0.5;
        let u = (x + half) / this.WORLD_SIZE;
        let v = (-z + half) / this.WORLD_SIZE;

        // Return null if out of bounds
        if (u < 0 || u > 1 || v < 0 || v > 1) {
            return null;
        }

        return { x: u, y: v };
    }

    resetExploration() {
        // Clear exploration render target to black
        this.game.renderer.setRenderTarget(this.explorationRenderTarget);
        this.game.renderer.clear();
        this.game.renderer.setRenderTarget(this.explorationRenderTargetPingPong);
        this.game.renderer.clear();
        this.game.renderer.setRenderTarget(null);
        this.explorationCacheValid = false;
        console.log('[FogOfWarSystem] Exploration reset');
    }

    dispose() {
        if (this.fogRenderTarget) {
            this.fogRenderTarget.dispose();
        }
        if (this.explorationRenderTarget) {
            this.explorationRenderTarget.dispose();
        }
        if (this.explorationRenderTargetPingPong) {
            this.explorationRenderTargetPingPong.dispose();
        }
        if (this.game.postProcessingSystem) {
            this.game.postProcessingSystem.removePass('fog');
        }
        if (this.circleGeometry) {
            this.circleGeometry.dispose();
        }
        if (this.circleMaterial) {
            this.circleMaterial.dispose();
        }
        if (this.circleTexture) {
            this.circleTexture.dispose();
        }
        if (this.accumulationMaterial) {
            this.accumulationMaterial.dispose();
        }
        if (this.accumulationQuad) {
            this.accumulationQuad.geometry.dispose();
        }
        this.circlePool = [];
    }
};

// System: SelectedUnitSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['SelectedUnitSystem'] = class SelectedUnitSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.selectedUnitSystem = this;
        this.canvas = this.game.canvas;
        
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        // Selection circle configuration
        this.CIRCLE_RADIUS = 25;
        this.CIRCLE_SEGMENTS = 32;
        this.CIRCLE_THICKNESS = 2;
        this.CIRCLE_COLOR = 0x00ff00; // Green selection color
        this.CIRCLE_OFFSET_Y = 1;   // Slightly above ground to prevent z-fighting
        
        // Track selection circles
        this.selectionCircles = new Map(); // entityId -> { circle, group, lastPosition }
        
        // Currently highlighted units
        this.highlightedUnits = new Set();
        
        // Box selection state
        this.boxSelection = {
            active: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            element: null
        };
        
        // Selection mode tracking
        this.selectedUnitIds = new Set(); // Track multiple selected squads
        
        this.currentSelectedIndex = 0;
        // Initialize flag
        this.initialized = false;
    }
    
    initialize() {
        if (this.initialized || !this.game.scene) return;
        
        this.initialized = true;
        this.createBoxSelectionElement();
        this.setupBoxSelectionListeners();
        
        const unitPortrait = document.getElementById('unitPortrait');   
        unitPortrait.addEventListener('click', () => {
            if(this.game.cameraControlSystem) {
                if(this.game.state.selectedEntity.entityId){
                    const pos = this.game.getComponent(this.game.state.selectedEntity.entityId, this.game.componentManager.getComponentTypes().POSITION);
                    if(pos){
                        this.game.cameraControlSystem.lookAt(pos.x, pos.z);
                    }
                }
            }
        });
    }
    
    createBoxSelectionElement() {
        // Create the visual selection box element
        const boxElement = document.createElement('div');
        boxElement.id = 'unitSelectionBox';
        boxElement.style.cssText = `
            position: absolute;
            border: 2px solid rgba(0, 255, 0, 0.8);
            background: rgba(0, 255, 0, 0.1);
            pointer-events: none;
            display: none;
            z-index: 10000;
        `;
        document.body.appendChild(boxElement);
        this.boxSelection.element = boxElement;
    }
    
    setupBoxSelectionListeners() {
        // Mouse down - start box selection
        this.canvas.addEventListener('mousedown', (event) => {
            // Only left click, and not clicking on UI elements
            if (event.button !== 0) return;
            
            const rect = this.canvas.getBoundingClientRect();
            this.boxSelection.startX = event.clientX;
            this.boxSelection.startY = event.clientY;
            this.boxSelection.currentX = event.clientX;
            this.boxSelection.currentY = event.clientY;
            this.boxSelection.active = true;
            
            // Don't show box immediately - wait for drag
        });
        
        // Mouse move - update box selection
        this.canvas.addEventListener('mousemove', (event) => {
            if (!this.boxSelection.active) return;
            
            this.boxSelection.currentX = event.clientX;
            this.boxSelection.currentY = event.clientY;
            
            // Calculate distance dragged
            const dx = this.boxSelection.currentX - this.boxSelection.startX;
            const dy = this.boxSelection.currentY - this.boxSelection.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Only show box if dragged more than 5 pixels (prevents accidental box on click)
            if (distance > 5) {
                this.updateBoxSelectionVisual();
            }
        });
        
        // Mouse up - complete box selection
        this.canvas.addEventListener('mouseup', (event) => {
            if (!this.boxSelection.active) return;
            
            const dx = this.boxSelection.currentX - this.boxSelection.startX;
            const dy = this.boxSelection.currentY - this.boxSelection.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // If dragged significantly, do box selection
            if (distance > 5) {
                requestAnimationFrame(() => {
                    this.completeBoxSelection(event);
                });
            } else {
                // Single click selection
                
                requestAnimationFrame(() => {
                    this.checkUnitSelectionClick(event);
                });
            }
            
            // Reset box selection state
            this.boxSelection.active = false;
            this.boxSelection.element.style.display = 'none';
        });
        
        // Cancel box selection on context menu or escape
        this.canvas.addEventListener('contextmenu', (event) => {
            if (this.boxSelection.active) {
                event.preventDefault();
                this.cancelBoxSelection();
            }
        });
        
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape' && this.boxSelection.active) {
                this.cancelBoxSelection();
            }
        });
    }
    
    updateBoxSelectionVisual() {
        const box = this.boxSelection;
        const element = box.element;
        
        // Calculate box dimensions
        const left = Math.min(box.startX, box.currentX);
        const top = Math.min(box.startY, box.currentY);
        const width = Math.abs(box.currentX - box.startX);
        const height = Math.abs(box.currentY - box.startY);
        
        // Update element
        element.style.left = left + 'px';
        element.style.top = top + 'px';
        element.style.width = width + 'px';
        element.style.height = height + 'px';
        element.style.display = 'block';
    }
        
    completeBoxSelection(event) {
        const box = this.boxSelection;
        
        // Get box boundaries in screen space (client coordinates)
        const left = Math.min(box.startX, box.currentX);
        const right = Math.max(box.startX, box.currentX);
        const top = Math.min(box.startY, box.currentY);
        const bottom = Math.max(box.startY, box.currentY);
        
        // Find all units within the selection box
        const selectedUnits = this.getUnitsInScreenBox(left, top, right, bottom);
        
        // Check if shift is held for additive selection
        const isAdditive = event.shiftKey;
        
        if (!isAdditive) {
            this.selectedUnitIds.clear();
        }
        selectedUnits.forEach((unitId) => {
            this.selectedUnitIds.add(unitId);
        });
        this.currentSelectedIndex = 0;
        const currentUnit = selectedUnits[this.currentSelectedIndex];
        if(currentUnit){
            const placement = this.game.getComponent(currentUnit, this.componentTypes.PLACEMENT);
            const unitType = this.game.getComponent(currentUnit, this.componentTypes.UNIT_TYPE );
            if(placement){
                const placementId = placement.placementId;
                if(unitType.collection == 'units'){                    
                    this.game.unitOrderSystem.showSquadActionPanel(placementId);                    
                } else {
                    const placement = this.game.placementSystem.getPlacementById(placementId);
                    this.game.shopSystem.renderBuildingActions(placement);
                }
            }
        }
        // Update the UI and highlights for all selected squads
        if (this.selectedUnitIds.size > 0) {
            this.updateMultipleSquadSelection();
        } else {            
            this.deselectAll();
        }
        
    }


    getUnitsInScreenBox(left, top, right, bottom) {
        const selectedUnits = [];
        const selectedBuildings = [];
        const rect = this.canvas.getBoundingClientRect();
        
        // Get all entities with position component
        const entities = this.game.getEntitiesWith(this.componentTypes.POSITION);
        
        entities.forEach(entityId => {
            // Only select units on player's team
            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
            if (!team) return;
            
            // Try multiple ways to check team
            const unitTeam = team.team || team.side || team.teamId;
            const myTeam = this.game.state.mySide || this.game.state.playerSide || this.game.state.team;
            
            if (unitTeam !== myTeam) {
                return;
            }
            
            // Get position component
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            if (!pos || !unitType) return;
            
            // Convert world position to screen position
            const screenPos = this.worldToScreen(pos.x, pos.y, pos.z);
            if (!screenPos) return;
            
            // Convert normalized screen coords (0-1) to client coordinates
            const screenX = screenPos.x * rect.width + rect.left;
            const screenY = screenPos.y * rect.height + rect.top;
            
            // Check if within selection box (in client coordinates)
            if (screenX >= left && screenX <= right && 
                screenY >= top && screenY <= bottom) {
                if(unitType.collection == 'units'){
                    selectedUnits.push(entityId);
                } else {
                    selectedBuildings.push(entityId);
                }
            }
        });
        
        return selectedUnits.length > 0 ? selectedUnits : selectedBuildings;
    }
    worldToScreen(x, y, z) {
        if (!this.game.camera || !this.game.canvas) return null;
        
        try {
            // Create a 3D vector
            const vector = new THREE.Vector3(x, y, z);
            
            // Project to screen space
            vector.project(this.game.camera);
            
            // Check if behind camera
            if (vector.z > 1) return null;
            
            // Convert to screen coordinates (0 to 1 range)
            // (0,0) is top-left, (1,1) is bottom-right
            return {
                x: (vector.x + 1) / 2,
                y: (-vector.y + 1) / 2
            };
        } catch (error) {
            console.warn('[SelectedUnitSystem] worldToScreen error:', error);
            return null;
        }
    }
    findSquadForUnit(entityId) {           
        const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
        return team?.placementId || null;
    }
    updateMultipleSquadSelection() {        
        this.currentSelectedIndex = 0;
        const unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];
    
        this.setSelectedEntity(unitId);         
        this.highlightUnits(Array.from(this.selectedUnitIds)); 
        
        this.game.unitOrderSystem.stopTargeting();
        if(this.selectedUnitIds.size > 0){
            let unitId = Array.from(this.selectedUnitIds)[this.currentSelectedIndex];
            const unitType = this.game.getComponent(unitId, this.game.componentManager.getComponentTypes().UNIT_TYPE);
            if(unitType.collection == "units") {
                this.game.unitOrderSystem.startTargeting();     
            }
        }
    }
    
    
    cancelBoxSelection() {
        this.boxSelection.active = false;
        this.boxSelection.element.style.display = 'none';
    }

    checkUnitSelectionClick(event) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        const worldPos = this.game.placementSystem.getWorldPositionFromMouse(event, mouseX, mouseY);
    
        if (!worldPos) return;
    
        const placementId = this.getPlacementAtWorldPosition(worldPos);
    
        if (placementId) {
            const placement = this.game.placementSystem.getPlacementById(placementId);
            if (placement && placement.team === this.game.state.mySide) {
                let entityId = placement.squadUnits[0];
                // Check if shift is held for additive selection
                if (event.shiftKey) {
                    if (this.selectedUnitIds.has(entityId)) {
                        // Deselect if already selected
                        this.selectedUnitIds.delete(entityId);
                    } else {
                        // Add to selection
                        this.selectedUnitIds.add(entityId);
                    }
                    this.updateMultipleSquadSelection();
                } else {
                    // Single selection (clear others)
                    this.deselectAll();
                    this.selectedUnitIds.add(entityId);
                    this.selectUnit(entityId, placementId);
                }
            }
        } else {
            // Clicked on empty space - deselect all
            if (!event.shiftKey) {
                this.deselectAll();
            }
        }
    }
    
    deselectAll() {
        this.clearAllHighlights();
        this.selectedUnitIds.clear();                
        this.game.state.selectedEntity.entityId = null;
        this.game.state.selectedEntity.collection = null;

        const actionPanel = document.getElementById('actionPanel');     
        if(actionPanel) {
            actionPanel.innerHTML = "";
        }

        const selectedUnits = document.getElementById('selectedUnits');        
        if(selectedUnits) {
            selectedUnits.innerHTML = "";
        }

        const unitPortrait = document.getElementById('unitPortrait');        
        if(unitPortrait){
            unitPortrait.innerHTML = "";
        }
        
        this.game.triggerEvent('onDeSelectAll');
    }

    getPlacementAtWorldPosition(worldPos) {
        const clickRadius = 30;
        let closestPlacementId = null;
        let closestDistance = clickRadius;
        
        const entities = this.game.getEntitiesWith(
            this.game.componentManager.getComponentTypes().POSITION,
            this.game.componentManager.getComponentTypes().PLACEMENT
        );
        
        entities.forEach(entityId => {
            const pos = this.game.getComponent(entityId, this.game.componentManager.getComponentTypes().POSITION);
            const placement = this.game.getComponent(entityId, this.componentTypes.PLACEMENT);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            const dx = pos.x - worldPos.x;
            const dz = pos.z - worldPos.z;
            let distance = Math.sqrt(dx * dx + dz * dz);
            
            if(unitType.size) {
                distance -= unitType.size;
            }
                

            if (distance < closestDistance) {
                closestDistance = distance;
                closestPlacementId = placement.placementId;
            }
        });
        
        return closestPlacementId;
    }

    selectUnit(entityId, placementId) {
        if (!entityId) return;
        
        const squadData = this.game.squadExperienceSystem?.getSquadInfo(placementId);
        
        if (squadData) {
            const placement = this.game.placementSystem.getPlacementById(placementId);
            squadData.unitIds = placement.squadUnits;
            this.setSelectedEntity(entityId);
            this.highlightUnits(placement.squadUnits);  
            if(placement.collection == 'units'){           
                this.game.unitOrderSystem.startTargeting();     
            } else {                
                this.game.unitOrderSystem.stopTargeting()
            }
        }
    }

    setSelectedEntity(entityId){         
        const CT = this.game.componentManager.getComponentTypes();
        const placement = this.game.getComponent(entityId, CT.PLACEMENT);
        const placementId = placement.placementId;
        this.game.state.selectedEntity.entityId = entityId;
        this.game.state.selectedEntity.collection = placement.collection;
        if(placement.collection == "units"){
            this.game.unitOrderSystem.showSquadActionPanel(placementId);         
        } else {
            this.game.shopSystem.renderBuildingActions(placement);
        }
    }

    update() {
        // Wait for scene to be available
        if (!this.game.scene || !this.game.camera) {
            return;
        }
        
        // Initialize if not done yet
        if (!this.initialized) {
            this.initialize();
        }
        
        
        // Update all active selection circles
        this.updateSelectionCircles();
        
        // Clean up circles for units that no longer exist or are deselected
        this.cleanupRemovedCircles();
    }
    
    highlightUnits(unitIds) {
        if (!unitIds || !Array.isArray(unitIds)) {
            this.clearAllHighlights();
            return;
        }
        
        // Convert to Set for easy comparison
        const newHighlightSet = new Set(unitIds);
        
        // Remove circles for units no longer selected
        for (const entityId of this.highlightedUnits) {
            if (!newHighlightSet.has(entityId)) {
                this.removeSelectionCircle(entityId);
            }
        }
        
        // Add circles for newly selected units
        for (const entityId of unitIds) {
            if (!this.highlightedUnits.has(entityId)) {
                this.createSelectionCircle(entityId);
            }
        }
        
        if(document){
            const container = document.getElementById('unitPortrait');
            container.innerHTML = ``;
            const portrait = this.createPortrait(unitIds[this.currentSelectedIndex]);
            if(portrait){
                container.append(portrait);
            }
            const selectedUnitsContainer = document.getElementById('selectedUnits');
            selectedUnitsContainer.innerHTML = ``;
            
            unitIds.forEach((unitId, index) => {
                const selectedPortrait = this.createPortrait(unitId);
                if(selectedPortrait){
                    const selectedUnitIconContainer = document.createElement('div');
                    if(index == this.currentSelectedIndex){                        
                        selectedUnitIconContainer.classList.add('selected');
                    }
                    selectedUnitIconContainer.append(selectedPortrait);
                    selectedUnitsContainer.append(selectedUnitIconContainer);
                    selectedUnitIconContainer.addEventListener('click', () => {
                        this.deselectAll();
                        this.selectedUnitIds.add(unitId);
                        const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);
                        this.selectUnit(unitId, placement.placementId);
                    });
                }            
            });            
        }
        // Update tracked set
        this.highlightedUnits = newHighlightSet;
        
    }

    createPortrait(entityId){
        if(document) {
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            const icon = this.game.getCollections().icons[unitType.icon];

            if(icon){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                return img;
            }
        }
        return null;
    }
    
    clearAllHighlights() {
        // Remove all selection circles
        for (const entityId of this.highlightedUnits) {
            this.removeSelectionCircle(entityId);
        }
        
        this.currentSelectedIndex = 0;
        this.highlightedUnits.clear();
    }
    
    createSelectionCircle(entityId) {
        // Don't create if already exists
        if (this.selectionCircles.has(entityId)) return;
        
        // Get entity position to determine size
        const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
        if (!pos) return;
        
        // Determine radius based on unit type
        const radius = this.getUnitRadius(entityId);
        
        // Create ring geometry (donut shape)
        const geometry = new THREE.RingGeometry(
            radius - this.CIRCLE_THICKNESS / 2,
            radius + this.CIRCLE_THICKNESS / 2,
            this.CIRCLE_SEGMENTS
        );
        
        // Create material
        const material = new THREE.MeshBasicMaterial({
            color: this.CIRCLE_COLOR,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        
        // Create mesh
        const circle = new THREE.Mesh(geometry, material);
        circle.rotation.x = -Math.PI / 2; // Lay flat on ground
        circle.renderOrder = 9998; // Render before health bars
        
        // Create group to hold circle
        const group = new THREE.Group();
        group.add(circle);
        
        // Add to UI scene
        this.game.scene.add(group);
        
        // Store reference
        this.selectionCircles.set(entityId, {
            circle: circle,
            group: group,
            geometry: geometry,
            material: material,
            radius: radius,
            lastPosition: { x: pos.x, y: pos.y, z: pos.z },
            baseOpacity: 0.8
        });
        
        console.log(`[SelectedUnitSystem] Created selection circle for entity ${entityId}`);
    }
    
    updateSelectionCircles() {
        for (const [entityId, circleData] of this.selectionCircles) {
            // Check if entity still exists
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) {
                this.removeSelectionCircle(entityId);
                continue;
            }
            
            // Update position
            circleData.group.position.set(pos.x, pos.y + this.CIRCLE_OFFSET_Y, pos.z);
        }
    }
    
    getUnitRadius(entityId) {
        // Try to get unit type to determine appropriate radius
        const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
        
        if (unitType) {
            const collections = this.game.getCollections?.();
            const unitData = (collections && collections[unitType.collection])
                ? collections[unitType.collection][unitType.id]
                : null;
            
            if (unitData && unitData.size) {
                return unitData.size + 2; // Slightly larger than unit
            }
        }
        
        // Default radius if no unit data
        return this.CIRCLE_RADIUS;
    }
    
    cleanupRemovedCircles() {
        for (const [entityId] of this.selectionCircles) {
            // Check if entity still exists
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            if (!pos) {
                this.removeSelectionCircle(entityId);
            }
            
            // Check if entity is still highlighted
            if (!this.highlightedUnits.has(entityId)) {
                this.removeSelectionCircle(entityId);
            }
        }
    }
    
    removeSelectionCircle(entityId) {
        const circleData = this.selectionCircles.get(entityId);
        if (!circleData) return;
        
        // Remove from scene
        if (this.game.scene) {
            this.game.scene.remove(circleData.group);
        }
        
        // Dispose of resources
        circleData.geometry.dispose();
        circleData.material.dispose();
        
        // Remove from map
        this.selectionCircles.delete(entityId);
        
        console.log(`[SelectedUnitSystem] Removed selection circle for entity ${entityId}`);
    }
    
    // Configuration methods
    setSelectionColor(color) {
        this.CIRCLE_COLOR = color;
        
        // Update existing circles
        for (const [_, circleData] of this.selectionCircles) {
            circleData.material.color.setHex(color);
        }
    }
    
    
    setCircleThickness(thickness) {
        this.CIRCLE_THICKNESS = thickness;
        
        // Would need to recreate all circles to apply
        // For now, just update the config for future circles
    }
    
    toggleAnimation(enabled) {
        if (!enabled) {
            // Reset all circles to default state
            for (const [_, circleData] of this.selectionCircles) {
                circleData.circle.scale.set(1, 1, 1);
                circleData.circle.rotation.z = 0;
                circleData.material.opacity = circleData.baseOpacity;
            }
        }
    }
    
    // Utility to check if a unit is currently highlighted
    isHighlighted(entityId) {
        return this.highlightedUnits.has(entityId);
    }
    
    // Get all currently highlighted unit IDs
    getHighlightedUnits() {
        return Array.from(this.highlightedUnits);
    }
    
    // Get all currently selected squad IDs
    getSelectedSquads() {
        let placementIds = new Set();
        const CT = this.game.componentManager.getComponentTypes();
        Array.from(this.selectedUnitIds).forEach((unitId) => {
            const placement = this.game.getComponent(unitId, this.componentTypes.PLACEMENT);
            placementIds.add(placement.placementId);
        });
        return [...placementIds];
    }
    getSelectedUnits() {
        return Array.from(this.selectedUnitIds);
    }

    
    onBattleStart() {
        this.deselectAll();
    }
    onKeyDown(key) {
        if (key === 'Escape') {
            this.deselectAll();
        }
    }
    
    destroy() {
        // Clean up box selection element
        if (this.boxSelection.element && this.boxSelection.element.parentElement) {
            this.boxSelection.element.parentElement.removeChild(this.boxSelection.element);
        }
        
        // Clean up all selection circles
        for (const [entityId] of this.selectionCircles) {
            this.removeSelectionCircle(entityId);
        }
        
        this.selectionCircles.clear();
        this.highlightedUnits.clear();
        this.selectedUnitIds.clear();
        this.initialized = false;
        
        console.log('[SelectedUnitSystem] Destroyed');
    }
};

// System: UnitOrderSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['UnitOrderSystem'] = class UnitOrderSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game = game;
        this.game.unitOrderSystem = this;

        this.componentTypes = this.game.componentManager.getComponentTypes();

        this.isTargeting = false;
        this.pendingCallbacks = 0;

        this._onCanvasClick = this._onCanvasClick.bind(this);
        this._onCanvasMouseMove = this._onCanvasMouseMove.bind(this);

        this.cursorWhenTargeting = 'crosshair';
        this.pingEffect = { count: 12, color: 0x00ff00 };
        this.temporaryOpponentMoveOrders = new Map();
        this.targetingPreview = new GUTS.PlacementPreview(this.game);
        this.targetingPreview.updateConfig({
            cellOpacity: 0.3,
            borderOpacity: 0.6
        });
    }

    init() {}

    showSquadActionPanel(placementId) {
        const actionPanel = document.getElementById('actionPanel');
        if (!actionPanel) return;

        
        const placement = this.game.placementSystem.getPlacementById(placementId);
        
        actionPanel.innerHTML = "";
        
        const componentTypes = this.game.componentManager.getComponentTypes();
  
        
        const firstUnit = placement.squadUnits[0];
        const unitType = firstUnit ? this.game.getComponent(firstUnit, componentTypes.UNIT_TYPE) : null;
        
        let squadPanel = document.createElement('div');
        squadPanel.id = 'squadActionPanel';
        
        actionPanel.appendChild(squadPanel);
        
        this.displayActionSet(null, squadPanel, firstUnit, unitType);
    }

    displayActionSet(actionSetId, panel, selectedUnitId, unitType) {
        panel.innerHTML = ``;
        const actionSection = document.createElement('div');
        actionSection.className = 'action-section';

        const grid = document.createElement('div');
        grid.className = 'action-grid';
        
        let actions = [];

        if(!unitType.actionSet){
            if(unitType.collection == 'units'){
                unitType.actionSet = 'defaultUnitActions';
            } 
        } 

        if(actionSetId || unitType.actionSet){
            if(!actionSetId) {
                actionSetId = unitType.actionSet;
            }
            let currentActionSet = this.game.getCollections().actionSets[actionSetId];
            if(currentActionSet.actions){
                actions = currentActionSet.actions;
                const actionsCollection = this.game.getCollections().actions;
                actions.forEach((actionId) => {
                    let action = actionsCollection[actionId];
                    const btn = this.createActionButton(action, panel, selectedUnitId, unitType);
                    grid.appendChild(btn);
                });
            } else if(currentActionSet.buildings){
                const buildings = this.game.getCollections().buildings;
                currentActionSet.buildings.forEach(buildingId => {
                    if (buildingId === 'underConstruction') return;
                    
                    const building = buildings[buildingId];            
                    if (!building.buildTime) building.buildTime = 1;
                    
                    building.id = buildingId;
                    const canAfford = this.game.state.playerGold >= (building.value || 0);
                    const isLocked = this.game.shopSystem?.isBuildingLocked(buildingId, building);
                    const lockReason = this.game.shopSystem?.getLockReason(buildingId, building);
                    
                    const btn = this.createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId);
                    grid.appendChild(btn);
                });
            }
        }
        actionSection.appendChild(grid);
    
        panel.appendChild(actionSection);
    }

    createActionButton(action, panel, selectedUnitId, unitType) {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.title = `${action.title}`;

        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(action.icon){
            const icon = this.game.getCollections().icons[action.icon];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  '🏛️';
            }
        } else {
            iconEl.textContent =  '🏛️';
        }
        btn.append(iconEl);

        if(action.order){
            btn.addEventListener('click', () => {
                this[action.order]();
            });
        } else if(action.actionSet){
            btn.addEventListener('click', () => {
                this.displayActionSet(action.actionSet, panel, selectedUnitId, unitType);
            });
        }
        return btn;
    }

    createBuildingButton(building, canAfford, isLocked, lockReason, selectedUnitId) {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        btn.title = `${building.title} 💰${building.value}`;
        const locked = isLocked || !canAfford;
        if (locked) {
            btn.style.opacity = '0.5';
            btn.style.cursor = 'not-allowed';
            btn.title = `${building.title} ${lockReason}`;
        }
        
        const iconEl = document.createElement('div');
        iconEl.className = 'action-btn-icon';
        if(building.icon){
            const icon = this.game.getCollections().icons[building.icon];
            if(icon && icon.filePath){
                const img = document.createElement('img');
                img.src = `./${icon.filePath}`;
                iconEl.append(img);
            } else {
                iconEl.textContent =  '🏛️';
            }
        } else {
            iconEl.textContent =  '🏛️';
        }
        btn.append(iconEl);

        if (!locked) {
            btn.addEventListener('click', () => {
                this.activateBuildingPlacement(building, selectedUnitId);
            });
            
            btn.addEventListener('mouseenter', () => {
                btn.style.border = '2px solid var(--primary-gold)';
                btn.style.transform = 'translateY(-2px)';
            });
            
            btn.addEventListener('mouseleave', () => {
                btn.style.border = '2px solid rgba(255, 170, 0, 0.3)';
                btn.style.transform = 'translateY(0)';
            });
        }

        return btn;
    }

    activateBuildingPlacement(building, selectedUnitId) {
        this.game.state.selectedUnitType = { 
            id: building.id, 
            collection: 'buildings', 
            ...building 
        };
        
        this.game.state.peasantBuildingPlacement = {
            peasantId: selectedUnitId,
            buildTime: building.buildTime
        };
        
        this.stopTargeting();
        
        this.game.triggerEvent('onActivateBuildingPlacement', this.game.state.selectedUnitType);
    }

    startTargeting() {
        this.stopTargeting();
        if(this.game.state.phase != 'placement') return;
        this.isTargeting = true;
        this.pendingCallbacks = 0;

        const canvas = this.game.canvas;
        if (canvas) {
            canvas.addEventListener('contextmenu', this._onCanvasClick, { once: true });
            canvas.addEventListener('mousemove', this._onCanvasMouseMove);
        }

        document.body.style.cursor = this.cursorWhenTargeting;

        this.game.uiSystem?.showNotification('🎯 Click the ground to set a target for selected units', 'info', 1200);
    }

    stopTargeting() {
        if (!this.isTargeting) return;
        this.isTargeting = false;

        const canvas = this.game.canvas;
        if (canvas) {
            canvas.removeEventListener('contextmenu', this._onCanvasClick, { once: true });
            canvas.removeEventListener('mousemove', this._onCanvasMouseMove);
        }
        document.body.style.cursor = 'default';
        
        this.targetingPreview.clear();
    }

    holdPosition() {
        this.stopTargeting();
        
        let placementIds = this.game.selectedUnitSystem.getSelectedSquads() || [];
        
        if (!placementIds || placementIds.length === 0) {
            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);
            return;
        }
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        placementIds.forEach((placementId) => {
            const placement = this.game.placementSystem.getPlacementById(placementId);
            placement.squadUnits.forEach((unitId) => {
                const position = this.game.getComponent(unitId, ComponentTypes.POSITION);
                const aiState = this.game.getComponent(unitId, ComponentTypes.AI_STATE);
                if (this.game.effectsSystem && position) {
                    this.game.effectsSystem.createParticleEffect(position.x, 0, position.z, 'magic', { ...this.pingEffect });
                }
                if(aiState){
                    aiState.targetPosition = position; 
                    aiState.currentAIController = "OrderSystemHold";
                }
            });
        });
        
    }

    onKeyDown(key) {
        if (key === 'Escape' && this.isTargeting) {
            this.game.uiSystem?.showNotification('❌ Targeting canceled', 'warning', 800);
            this.stopTargeting();
        }
    }

    _onCanvasMouseMove(event) {
        if (!this.isTargeting) return;

        const canvas = this.game.canvas;
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        const worldPos = this.game.placementSystem?.getWorldPositionFromMouse?.(event, mouseX, mouseY);
        if (!worldPos) {
            this.targetingPreview.clear();
            return;
        }

        const placementIds = this.game.selectedUnitSystem?.getSelectedSquads() || [];
        if (placementIds.length === 0) {
            this.targetingPreview.clear();
            return;
        }

        const targetPosition = { x: worldPos.x, z: worldPos.z };
        const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);

        this.targetingPreview.showAtWorldPositions(targetPositions, true);
    }

    _onCanvasClick(event) {
        if (!this.isTargeting) return;

        const canvas = this.game.canvas;
        if (!canvas) {
            this.stopTargeting();
            return;
        }

        const rect = canvas.getBoundingClientRect();
        const mouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const mouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        const worldPos = this.game.placementSystem?.getWorldPositionFromMouse?.(event, mouseX, mouseY);
        if (!worldPos) {
            this.game.uiSystem?.showNotification('Could not find ground under cursor.', 'error', 1000);
            this.stopTargeting();
            return;
        }

        let placementIds = this.game.selectedUnitSystem.getSelectedSquads() || [];
        
        if (!placementIds || placementIds.length === 0) {
            this.game.uiSystem?.showNotification('No units selected.', 'warning', 800);
            this.stopTargeting();
            return;
        }

        const targetPosition = { x: worldPos.x, y: 0, z: worldPos.z };

        if (this.game.effectsSystem) {
            this.game.effectsSystem.createParticleEffect(worldPos.x, 0, worldPos.z, 'magic', { ...this.pingEffect });
        }

        this.issueMoveOrders(placementIds, targetPosition);
    }

    issueMoveOrders(placementIds, targetPosition) {
        if(this.game.state.phase != "placement") {
            return;
        };
        const targetPositions = this.getFormationTargetPositions(targetPosition, placementIds);
        this.game.networkManager.setSquadTargets(
            { placementIds, targetPositions },
            (success) => {
                if (success) { 
                    const ComponentTypes = this.game.componentManager.getComponentTypes();        
                    for(let i = 0; i < placementIds.length; i++){
                        let placementId = placementIds[i];
                        const targetPosition = targetPositions[i];
                        const placement = this.game.placementSystem.getPlacementById(placementId);
                        placement.squadUnits.forEach((unitId) => {
                            const aiState = this.game.getComponent(unitId, ComponentTypes.AI_STATE);
                            if (this.game.effectsSystem && targetPosition) {
                                this.game.effectsSystem.createParticleEffect(targetPosition.x, 0, targetPosition.z, 'magic', { ...this.pingEffect });
                            }
                            if(aiState && targetPosition){
                                aiState.targetPosition = targetPosition;
                                aiState.currentAIController = "OrderSystemMove";
                            }
                        });
                                
                    }      
                    this.stopTargeting();                
                }                
            }
        );
    }

    getFormationTargetPositions(targetPosition, placementIds){
        let targetPositions = [];
        const gridSize = this.game.getCollections().configs.game.gridSize;
        const unitPadding = 1;

        for(let i = 0; i < placementIds.length; i++){
            targetPositions.push({
                x: targetPosition.x,
                z: i % 2 == 0 ? targetPosition.z + i * gridSize * unitPadding : targetPosition.z - i * gridSize * unitPadding
            });
        }
        return targetPositions;
    }

    applySquadTargetPosition(placementId, targetPosition) {   
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const placement = this.game.placementSystem.getPlacementById(placementId);
        if(!placement){
            this.temporaryOpponentMoveOrders.set(placementId, targetPosition);
            return;
        }
        placement.targetPosition = targetPosition;
        placement.squadUnits.forEach((unitId) => {
            const aiState = this.game.getComponent(unitId, ComponentTypes.AI_STATE);
            if(aiState && targetPosition){
                aiState.targetPosition = targetPosition;
                aiState.currentAIController = "OrderSystemMove";
            }
        });            
    }

    applySquadsTargetPositions(placementIds, targetPositions) {     
        for(let i = 0; i < placementIds.length; i++){  
            let placementId = placementIds[i];
            let targetPosition = targetPositions[i];
            this.applySquadTargetPosition(placementId, targetPosition);
        }
    }
    onBattleStart() {
        this.stopTargeting();
    }
    onDeSelectAll() {        
        this.targetingPreview.clear();
    }

    destroy() {
        this.stopTargeting();
        if (this.targetingPreview) {
            this.targetingPreview.dispose();
        }
    }
};

// System: MiniMapSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['MiniMapSystem'] = class MiniMapSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.game.miniMapSystem = this;
        this.componentTypes = this.game.componentManager.getComponentTypes();
        
        this.MINIMAP_SIZE = 200;
        this.MINIMAP_PADDING = 10;
        
        this.container = null;
        this.canvas = null;
        this.ctx = null;
        
        this.minimapCamera = null;
        this.minimapScene = null;
        this.minimapRenderTarget = null;
        
        this.unitIconGeometry = null;
        this.buildingIconGeometry = null;
        this.goldVeinIconGeometry = null;
        this.friendlyIconMaterial = null;
        this.friendlyInstancedMesh = null;
        this.enemyIconMaterial = null;
        this.enemyInstancedMesh = null;
        this.friendlyBuildingMaterial = null;
        this.friendlyBuildingMesh = null;
        this.enemyBuildingMaterial = null;
        this.enemyBuildingMesh = null;
        this.goldVeinMaterial = null;
        this.goldVeinMesh = null;
        this.tempMatrix = null;
        
        this.isDragging = false;
        this.minimapWorldSize = 0;
        this.initialized = false;
        this.MINIMAP_ROTATION = -45;
    }

    onGameStarted() {
        // Get the container and its actual width
        this.container = document.getElementById('miniMapContainer');
        const rect = this.container.getBoundingClientRect();
       // this.MINIMAP_SIZE = rect.width; // use actual displayed size

        // Use that size for both the canvas and render target
        this.minimapWorldSize = this.game.worldSystem.extendedSize;
        
        this.createMinimapCamera();
        this.addTerrainBackground(); 
        this.createIconMaterials();
        this.createMinimapUI();
        this.setupEventListeners();
        this.initialized = true;
    }


    createMinimapCamera() {
        const halfSize = this.minimapWorldSize / 2;
        
        this.minimapCamera = new THREE.OrthographicCamera(
            -halfSize, halfSize,
            halfSize, -halfSize,
            0.1, 1000
        );
        this.minimapCamera.position.set(0, 500, 0);
        this.minimapCamera.lookAt(0, 0, 0);
        
        this.minimapScene = new THREE.Scene();
        
        this.minimapRenderTarget = new THREE.WebGLRenderTarget(
            this.MINIMAP_SIZE,
            this.MINIMAP_SIZE,
            {
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat
            }
        );
        
        this.addFogBackground();
    }

    addFogBackground() {
        const fogQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),
            new THREE.ShaderMaterial({
                uniforms: {
                    explorationTexture: { value: null },
                    visibilityTexture: { value: null }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D explorationTexture;
                    uniform sampler2D visibilityTexture;
                    varying vec2 vUv;
                    
                    void main() {
                        float explored = texture2D(explorationTexture, vUv).r;
                        float visible = texture2D(visibilityTexture, vUv).r;
                        
                        vec3 color;
                        float alpha;
                        if (visible > 0.0) {
                            // Fully visible - make it transparent so terrain shows through
                            color = vec3(0.0);
                            alpha = 0.0;
                        } else if (explored > 0.0) {
                            // Explored but not visible - dark overlay
                            color = vec3(0.0);
                            alpha = 0.6;
                        } else {
                            // Unexplored - black
                            color = vec3(0.0);
                            alpha = 1.0;
                        }
                        
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                depthTest: false
            })
        );
        fogQuad.rotation.x = -Math.PI / 2;
        fogQuad.position.y = -1;
        fogQuad.renderOrder = 100;
        
        this.minimapScene.add(fogQuad);
        this.fogQuad = fogQuad;
    }

    createIconMaterials() {
        const gridSize = this.game.getCollections().configs.game.gridSize;
        // Unit icons - slightly bigger
        this.unitIconGeometry = new THREE.CircleGeometry(gridSize, 4);
        
        // Building icons - much bigger
        this.buildingIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);
        
        // Gold vein icons - medium size
        this.goldVeinIconGeometry = new THREE.CircleGeometry(gridSize*2, 4);
        
        const MAX_UNITS = 1000;
        const MAX_BUILDINGS = 200;
        
        // Friendly units
        this.friendlyIconMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.friendlyInstancedMesh = new THREE.InstancedMesh(
            this.unitIconGeometry,
            this.friendlyIconMaterial,
            MAX_UNITS
        );
        this.friendlyInstancedMesh.renderOrder = 100;
        this.friendlyInstancedMesh.count = 0;
        this.minimapScene.add(this.friendlyInstancedMesh);
        
        // Enemy units
        this.enemyIconMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.enemyInstancedMesh = new THREE.InstancedMesh(
            this.unitIconGeometry,
            this.enemyIconMaterial,
            MAX_UNITS
        );
        this.enemyInstancedMesh.renderOrder = 100;
        this.enemyInstancedMesh.count = 0;
        this.minimapScene.add(this.enemyInstancedMesh);
        
        // Friendly buildings
        this.friendlyBuildingMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.friendlyBuildingMesh = new THREE.InstancedMesh(
            this.buildingIconGeometry,
            this.friendlyBuildingMaterial,
            MAX_BUILDINGS
        );
        this.friendlyBuildingMesh.renderOrder = 100;
        this.friendlyBuildingMesh.count = 0;
        this.minimapScene.add(this.friendlyBuildingMesh);
        
        // Enemy buildings
        this.enemyBuildingMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.enemyBuildingMesh = new THREE.InstancedMesh(
            this.buildingIconGeometry,
            this.enemyBuildingMaterial,
            MAX_BUILDINGS
        );
        this.enemyBuildingMesh.renderOrder = 100;
        this.enemyBuildingMesh.count = 0;
        this.minimapScene.add(this.enemyBuildingMesh);
        
        // Gold veins (yellow)
        this.goldVeinMaterial = new THREE.MeshBasicMaterial({
            color: 0xFFD700,
            side: THREE.DoubleSide,
            depthWrite: false,
            depthTest: false
        });
        
        this.goldVeinMesh = new THREE.InstancedMesh(
            this.goldVeinIconGeometry,
            this.goldVeinMaterial,
            100
        );
        this.goldVeinMesh.renderOrder = 50;
        this.goldVeinMesh.count = 0;
        this.minimapScene.add(this.goldVeinMesh);
        
        this.tempMatrix = new THREE.Matrix4();
        this.rotationMatrix = new THREE.Matrix4();
        this.rotationMatrix.makeRotationX(-Math.PI / 2);
    }

    createMinimapUI() {
        this.canvas = document.createElement('canvas');
        this.canvas.width = this.MINIMAP_SIZE;
        this.canvas.height = this.MINIMAP_SIZE;
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.display = 'block';
        this.ctx = this.canvas.getContext('2d');

        if (this.container) {
            this.container.appendChild(this.canvas);
        }

        // Update render target to match
        if (this.minimapRenderTarget) {
            this.minimapRenderTarget.setSize(this.MINIMAP_SIZE, this.MINIMAP_SIZE);
        }
    }


    setupEventListeners() {
        this.container.addEventListener('mousedown', (e) => {
            this.isDragging = true;
            this.handleMinimapClick(e);
        });
        
        this.container.addEventListener('mousemove', (e) => {
            if (this.isDragging) {
                this.handleMinimapClick(e);
            }
        });
        
        this.container.addEventListener('mouseup', () => {
            this.isDragging = false;
        });
        
        this.container.addEventListener('mouseleave', () => {
            this.isDragging = false;
        });
    }

    handleMinimapClick(event) {
        const rect = this.canvas.getBoundingClientRect();
         const camera = this.game.camera;
     
        // Get click position relative to canvas center (in pixels)
        const clickX = event.clientX - rect.left - rect.width / 2;
        const clickY = event.clientY - rect.top - rect.height / 2;
        
        // Apply inverse rotation to compensate for CSS rotation
        const angle = -this.MINIMAP_ROTATION * Math.PI / 180;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        
        const rotatedX = clickX * cos - clickY * sin;
        const rotatedY = clickX * sin + clickY * cos;
        
        // Convert back to normalized coordinates (0..1)
        const nx = (rotatedX + rect.width / 2) / rect.width;
        const ny = (rotatedY + rect.height / 2) / rect.height;
        
        let worldSize = this.game.worldSystem.terrainSize * 2;
        // Map to world coordinates
        const half = worldSize * 0.5;
        const worldX = nx * worldSize - half;
        const worldZ = ny * worldSize - half;
        if(this.game.cameraControlSystem){
            this.game.cameraControlSystem.lookAt(worldX, worldZ);
        }
    }

    update() {
        if(!this.initialized) return;
        this.updateFogTextures();
        this.updateUnitIcons();
        this.updateGoldVeinIcons();
        this.renderMinimap();
    }

    updateFogTextures() {
        if (!this.game.fogOfWarSystem || !this.fogQuad) return;
        
        this.fogQuad.material.uniforms.explorationTexture.value = 
            this.game.fogOfWarSystem.explorationRenderTarget.texture;
        this.fogQuad.material.uniforms.visibilityTexture.value = 
            this.game.fogOfWarSystem.fogRenderTarget.texture;

        if (this.terrainQuad && this.game.worldSystem?.groundTexture) {
            this.terrainQuad.material.map = this.game.worldSystem.groundTexture;
            this.terrainQuad.material.needsUpdate = true;
        }
    }

    updateUnitIcons() {
        const myTeam = this.game.state.mySide;
        if (!myTeam) return;
        
        const entities = this.game.getEntitiesWith(
            this.componentTypes.POSITION,
            this.componentTypes.TEAM
        );
        
        let friendlyUnitIndex = 0;
        let enemyUnitIndex = 0;
        let friendlyBuildingIndex = 0;
        let enemyBuildingIndex = 0;
        
        for (const entityId of entities) {
            const pos = this.game.getComponent(entityId, this.componentTypes.POSITION);
            const team = this.game.getComponent(entityId, this.componentTypes.TEAM);
            const projectile = this.game.getComponent(entityId, this.componentTypes.PROJECTILE);
            const unitType = this.game.getComponent(entityId, this.componentTypes.UNIT_TYPE);
            
            if (!pos || !team || projectile) continue;
            
            const isMyUnit = team.team === myTeam;
            const visible = this.game.fogOfWarSystem?.isVisibleAt(pos.x, pos.z);
            
            if (!isMyUnit && !visible) continue;
            
            this.tempMatrix.makeTranslation(pos.x, 0, pos.z);
            this.tempMatrix.multiply(this.rotationMatrix);
            
            if (unitType.collection == 'buildings') {
                // It's a building
                if (isMyUnit) {
                    this.friendlyBuildingMesh.setMatrixAt(friendlyBuildingIndex, this.tempMatrix);
                    friendlyBuildingIndex++;
                } else {
                    this.enemyBuildingMesh.setMatrixAt(enemyBuildingIndex, this.tempMatrix);
                    enemyBuildingIndex++;
                }
            } else {
                // It's a unit
                if (isMyUnit) {
                    this.friendlyInstancedMesh.setMatrixAt(friendlyUnitIndex, this.tempMatrix);
                    friendlyUnitIndex++;
                } else {
                    this.enemyInstancedMesh.setMatrixAt(enemyUnitIndex, this.tempMatrix);
                    enemyUnitIndex++;
                }
            }
        }
        
        this.friendlyInstancedMesh.count = friendlyUnitIndex;
        this.enemyInstancedMesh.count = enemyUnitIndex;
        this.friendlyBuildingMesh.count = friendlyBuildingIndex;
        this.enemyBuildingMesh.count = enemyBuildingIndex;
        
        if (friendlyUnitIndex > 0) {
            this.friendlyInstancedMesh.instanceMatrix.needsUpdate = true;
        }
        if (enemyUnitIndex > 0) {
            this.enemyInstancedMesh.instanceMatrix.needsUpdate = true;
        }
        if (friendlyBuildingIndex > 0) {
            this.friendlyBuildingMesh.instanceMatrix.needsUpdate = true;
        }
        if (enemyBuildingIndex > 0) {
            this.enemyBuildingMesh.instanceMatrix.needsUpdate = true;
        }
    }

    updateGoldVeinIcons() {
        if (!this.game.goldMineSystem?.goldVeinLocations) {
            return;
        }
        
        const goldVeins = this.game.goldMineSystem.goldVeinLocations;
        let goldIndex = 0;
        
        for (const vein of goldVeins) {
            // Skip if claimed (has a gold mine built on it)
            if (vein.claimed) continue;
            
            const explored = this.game.fogOfWarSystem?.isExploredAt(vein.worldX, vein.worldZ);
            if (!explored) continue;
            
            this.tempMatrix.makeTranslation(vein.worldX, 0, vein.worldZ);
            this.tempMatrix.multiply(this.rotationMatrix);
            this.goldVeinMesh.setMatrixAt(goldIndex, this.tempMatrix);
            goldIndex++;
        }
        
        this.goldVeinMesh.count = goldIndex;
        
        if (goldIndex > 0) {
            this.goldVeinMesh.instanceMatrix.needsUpdate = true;
        }
    }

    updateCameraView() {
        if (!this.game.camera) return;
        
        const camera = this.game.camera;
        const cameraPos = camera.position;
        
        if (!cameraPos || isNaN(cameraPos.x) || isNaN(cameraPos.y) || isNaN(cameraPos.z)) {
            return;
        }
        
        const fov = camera.fov * (Math.PI / 180);
        const aspect = camera.aspect;
        const distance = camera.position.y;
        
        if (isNaN(fov) || isNaN(aspect) || isNaN(distance) || distance <= 0) {
            return;
        }
        
        const viewHeight = 2 * Math.tan(fov / 2) * distance;
        const viewWidth = viewHeight * aspect;
        
        const halfWidth = viewWidth / 2;
        const halfHeight = viewHeight / 2;
        
        const points = [
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight),
            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z - halfHeight),
            new THREE.Vector3(cameraPos.x + halfWidth, 1, cameraPos.z + halfHeight),
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z + halfHeight),
            new THREE.Vector3(cameraPos.x - halfWidth, 1, cameraPos.z - halfHeight)
        ];
        
        if (this.cameraViewMesh) {
            this.cameraViewMesh.geometry.setFromPoints(points);
        } else {
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0xffffff,
                linewidth: 3,
                depthWrite: false,
                depthTest: false
            });
            this.cameraViewMesh = new THREE.Line(geometry, material);
            this.cameraViewMesh.renderOrder = 1000;
            this.minimapScene.add(this.cameraViewMesh);
        }
    }

    addTerrainBackground() {
        // Get the ground texture from the world system
        if (!this.game.worldSystem || !this.game.worldSystem.groundTexture) {
            console.warn('MiniMapSystem: Ground texture not available');
            return;
        }
        
        const terrainQuad = new THREE.Mesh(
            new THREE.PlaneGeometry(this.minimapWorldSize, this.minimapWorldSize),
            new THREE.MeshBasicMaterial({
                map: this.game.worldSystem.groundTexture,
                depthWrite: false,
                depthTest: false
            })
        );
        terrainQuad.rotation.x = -Math.PI / 2;
        terrainQuad.position.y = -2; // Below fog
        terrainQuad.renderOrder = -2000;
        
        this.minimapScene.add(terrainQuad);
        this.terrainQuad = terrainQuad;
    }

    renderMinimap() {
        this.game.renderer.setRenderTarget(this.minimapRenderTarget);
        this.game.renderer.render(this.minimapScene, this.minimapCamera);
        
        const pixels = new Uint8Array(this.MINIMAP_SIZE * this.MINIMAP_SIZE * 4);
        this.game.renderer.readRenderTargetPixels(
            this.minimapRenderTarget,
            0, 0,
            this.MINIMAP_SIZE, this.MINIMAP_SIZE,
            pixels
        );
        
        this.game.renderer.setRenderTarget(null);
        
        const imageData = this.ctx.createImageData(this.MINIMAP_SIZE, this.MINIMAP_SIZE);
        
        for (let y = 0; y < this.MINIMAP_SIZE; y++) {
            for (let x = 0; x < this.MINIMAP_SIZE; x++) {
                const srcIdx = (y * this.MINIMAP_SIZE + x) * 4;
                const dstIdx = ((this.MINIMAP_SIZE - 1 - y) * this.MINIMAP_SIZE + x) * 4;
                
                imageData.data[dstIdx + 0] = pixels[srcIdx + 0];
                imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
                imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
                imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
            }
        }
        
        this.ctx.putImageData(imageData, 0, 0);
        
        this.drawCameraOutline();
    }
        
    drawCameraOutline() {
        const camera = this.game.camera;
        if (!camera || !camera.isOrthographicCamera) return;

        // Frustum corners in NDC (CCW)
        const corners = [
            { x: -1, y: -1 }, // left-bottom
            { x:  1, y: -1 }, // right-bottom
            { x:  1, y:  1 }, // right-top
            { x: -1, y:  1 }, // left-top
        ];

        // Intersect each corner "ray" with the ground plane (y=0)
        const hits = [];
        for (const c of corners) {
            const hit = this.orthoCornerToGround(camera, c.x, c.y);
            if (!hit) return; // early out if any corner can't hit the ground
            hits.push(hit);
        }

        // Convert to canvas space
        const pts = hits.map(h => this.worldToCanvas(h.x, h.z));

        // Draw polygon overlay
        this.ctx.save();
        this.ctx.strokeStyle = '#ffffff';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        this.ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) this.ctx.lineTo(pts[i].x, pts[i].y);
        this.ctx.closePath();
        this.ctx.stroke();
        this.ctx.restore();
    }

    orthoCornerToGround(camera, ndcX, ndcY) {
        // Point on near plane in world space
        const p = new THREE.Vector3(ndcX, ndcY, -1).unproject(camera);

        // Camera forward (world)
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

        const EPS = 1e-6;
        if (Math.abs(forward.y) < EPS) return null; // looking exactly parallel to ground

        // Move along forward so y -> 0
        const t = -p.y / forward.y;
        if (t <= 0) return null;                    // corner ray goes upward/behind
        return p.addScaledVector(forward, t);       // world-space hit (x, 0, z)
    }
    
    worldToCanvas(x, z) {
        const half = this.minimapWorldSize / 2;
        const nx = (x + half) / this.minimapWorldSize;
        const nz = (z + half) / this.minimapWorldSize;
        const cx = nx * this.MINIMAP_SIZE;
        const cy = nz * this.MINIMAP_SIZE;
        return { x: cx, y: cy };
    }
    
    dispose() {
        if (this.container && this.container.parentNode) {
            this.container.parentNode.removeChild(this.container);
        }
        
        if (this.minimapRenderTarget) {
            this.minimapRenderTarget.dispose();
        }
        
        if (this.unitIconGeometry) {
            this.unitIconGeometry.dispose();
        }
        
        if (this.buildingIconGeometry) {
            this.buildingIconGeometry.dispose();
        }
        
        if (this.goldVeinIconGeometry) {
            this.goldVeinIconGeometry.dispose();
        }
        
        if (this.friendlyIconMaterial) {
            this.friendlyIconMaterial.dispose();
        }
        
        if (this.friendlyInstancedMesh) {
            this.minimapScene.remove(this.friendlyInstancedMesh);
            this.friendlyInstancedMesh.dispose();
        }
        
        if (this.enemyIconMaterial) {
            this.enemyIconMaterial.dispose();
        }
        
        if (this.enemyInstancedMesh) {
            this.minimapScene.remove(this.enemyInstancedMesh);
            this.enemyInstancedMesh.dispose();
        }
        
        if (this.friendlyBuildingMaterial) {
            this.friendlyBuildingMaterial.dispose();
        }
        
        if (this.friendlyBuildingMesh) {
            this.minimapScene.remove(this.friendlyBuildingMesh);
            this.friendlyBuildingMesh.dispose();
        }
        
        if (this.enemyBuildingMaterial) {
            this.enemyBuildingMaterial.dispose();
        }
        
        if (this.enemyBuildingMesh) {
            this.minimapScene.remove(this.enemyBuildingMesh);
            this.enemyBuildingMesh.dispose();
        }
        
        if (this.goldVeinMaterial) {
            this.goldVeinMaterial.dispose();
        }
        
        if (this.goldVeinMesh) {
            this.minimapScene.remove(this.goldVeinMesh);
            this.goldVeinMesh.dispose();
        }
        
        if (this.terrainQuad) {
            this.minimapScene.remove(this.terrainQuad);
            this.terrainQuad.geometry.dispose();
            this.terrainQuad.material.dispose();
        }
    }
};

// System: CameraControlSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['CameraControlSystem'] = class CameraControlSystem extends engine.BaseSystem {
  constructor(game) {
    super(game);
    this.game.cameraControlSystem = this;

    this.SPEED = 900; // world units per second

    // Mouse state
    this.mouseX = -1;
    this.mouseY = -1;
    this.inside = false;

    // When mouse leaves the window, keep panning in these directions
    this.holdDirX = 0; // -1 left, +1 right
    this.holdDirZ = 0; // +1 up/forward, -1 down/backward

    this.vertical_threshold = 10;

    // Reusable vectors
    this.right = new THREE.Vector3();
    this.fwd   = new THREE.Vector3();
    this.delta = new THREE.Vector3();
  }

  init() {
    this.onMove  = (e)=>this.onMouseMove(e);
    this.onEnter = ()=>{ this.inside = true; this.holdDirX = 0; this.holdDirZ = 0; };
    this.onLeave = ()=>this.onMouseLeave();
    this.onBlur  = ()=>{ this.inside = false; this.holdDirX = 0; this.holdDirZ = 0; };

    window.addEventListener('mousemove', this.onMove, { passive: true });
    window.addEventListener('mouseenter', this.onEnter);
    window.addEventListener('mouseleave', this.onLeave);
    window.addEventListener('blur',      this.onBlur);
    window.addEventListener('wheel', (e) => {
      let dy = e.deltaY;
      if(dy > 0){
        //scrolling down
        this.game.camera.zoom = this.game.camera.zoom * 0.9;
      } else {
        this.game.camera.zoom = this.game.camera.zoom * 1.1;
      }
      this.game.camera.zoom = Math.min(2, this.game.camera.zoom);
      this.game.camera.updateProjectionMatrix();
    });
  }

  dispose() {
    window.removeEventListener('mousemove', this.onMove);
    window.removeEventListener('mouseenter', this.onEnter);
    window.removeEventListener('mouseleave', this.onLeave);
    window.removeEventListener('blur',       this.onBlur);
  }

  onMouseMove(e) {
    this.mouseX = e.clientX;
    this.mouseY = e.clientY;
    this.inside = true;
  }

  onMouseLeave() {
    // Decide which edge we left from and “hold” that pan direction
    const w = window.innerWidth  || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;

    // X hold
    if (this.mouseX <= 0)            this.holdDirX = -1;
    else if (this.mouseX >= w - 1)   this.holdDirX =  1;
    else                              this.holdDirX =  0;

    // Z hold (reversed per your request: top = +forward, bottom = -backward)
    if (this.mouseY <= this.vertical_threshold)            this.holdDirZ =  1;  // went off top -> forward
    else if (this.mouseY >= h - this.vertical_threshold)   this.holdDirZ = -1;  // went off bottom -> backward
    else                              this.holdDirZ =  0;

    this.inside = false;
  }

  clampCamera(camera, padding = 0) {
    const half = this.game.worldSystem?.extendedSize ? this.game.worldSystem.extendedSize * 0.5 : 1000;
    camera.position.x = Math.max(-half + padding, Math.min(half - padding, camera.position.x));
    camera.position.z = Math.max(-half + padding, Math.min(half - padding, camera.position.z));

    if (camera.userData?.lookAt instanceof THREE.Vector3) {
      camera.userData.lookAt.x = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.x));
      camera.userData.lookAt.z = Math.max(-half + padding, Math.min(half - padding, camera.userData.lookAt.z));
    }
  }

  updateGroundBasis(camera) {
    this.right.set(1,0,0).applyQuaternion(camera.quaternion);
    this.fwd.set(0,0,-1).applyQuaternion(camera.quaternion);
    this.right.y = 0; this.fwd.y = 0;
    if (this.right.lengthSq() > 0) this.right.normalize();
    if (this.fwd.lengthSq() > 0) this.fwd.normalize();
  }

  lookAt(worldX, worldZ){
    const pitch = 35.264 * Math.PI / 180;
    const yaw = 135 * Math.PI / 180;
    const distance = 10240;

    const cdx = Math.sin(yaw) * Math.cos(pitch);
    const cdz = Math.cos(yaw) * Math.cos(pitch);

    const cameraPosition = {
        x: worldX - cdx * distance,
        y: distance,
        z: worldZ - cdz * distance
    };

    const lookAt = { x: worldX, y: 0, z: worldZ };

    this.game.camera.position.set(cameraPosition.x, cameraPosition.y, cameraPosition.z);
    this.game.camera.lookAt(lookAt.x, lookAt.y, lookAt.z);
  }


  moveCamera() {
    const cam = this.game.camera;
    if (!cam) return;

    const dt = this.game.state.deltaTime || 1/60;

    const w = window.innerWidth  || document.documentElement.clientWidth;
    const h = window.innerHeight || document.documentElement.clientHeight;

    // Compute directions from current mouse position (supports off-screen values too)
    let dirX = 0;
    let dirZ = 0;

    if (this.inside) {
      if (this.mouseX <= 0)           dirX = -1;
      else if (this.mouseX >= w - 1)  dirX =  1;

      // Z reversed: top edge -> +1 (forward), bottom -> -1 (backward)
      if (this.mouseY <= this.vertical_threshold)           dirZ =  1;
      else if (this.mouseY >= h - this.vertical_threshold)  dirZ = -1;

      // Clear holds while inside; we’ll recompute every frame
      this.holdDirX = 0;
      this.holdDirZ = 0;
    } else {
      // Outside window—keep moving in the last known edge direction
      dirX = this.holdDirX;
      dirZ = this.holdDirZ;
    }

    if (dirX === 0 && dirZ === 0) return;

    this.updateGroundBasis(cam);

    this.delta.set(0,0,0)
      .addScaledVector(this.right, dirX * this.SPEED * dt)
      .addScaledVector(this.fwd,   dirZ * this.SPEED * dt);

    cam.position.add(this.delta);

    if (cam.userData?.lookAt instanceof THREE.Vector3) {
      cam.userData.lookAt.add(this.delta);
      cam.lookAt(cam.userData.lookAt);
    }

    this.clampCamera(cam, 0);
  }
}
;

// System: ServerBattlePhaseSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ServerBattlePhaseSystem'] = class ServerBattlePhaseSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);
        this.engine = this.game.app;    
        this.game.serverBattlePhaseSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;
        
        // Battle configuration
        this.maxBattleDuration = 30; // 90 seconds max
        this.minBattleDuration = 29;
        this.currentBattleTime = 0;
        // Battle state tracking
        this.battleResults = new Map();
        this.createdSquads = new Map();
        this.maxRounds = 5;
        this.baseGoldPerRound = 50;
    }

    init(params) {
        this.params = params || {};
    }

    startBattle(room) {
        try {

            this.game.state.isPaused = false;
            // Change room phase
            this.game.state.phase = 'battle';
            
            return { success: true };
            
        } catch (error) {
            console.error('Error in startBattle:', error);
            return { success: false, error: error.message };
        }
    }
    spawnSquadFromPlacement(playerId, placement) {
        try {
            const player = this.game.room.getPlayer(playerId);
            
            if (!this.game.unitCreationManager) {
                throw new Error('Unit creation manager not available');
            }
            
            // Get placements from placement phase manager
            const placementManager = this.game.placementSystem;
            if (!placementManager) {
                throw new Error('Placement phase manager not available');
            }
            let createdSquad = null;
      
            // Create squads using unit creation manager
            createdSquad = this.game.unitCreationManager.createSquadFromPlacement(
                placement,
                player.stats.side,
                playerId
            );

            if(!createdSquad){
                console.log("Failed to create squads");
                return { success: false };
            } else {
                // Store created squads for tracking
                let playerSquads = this.createdSquads.get(playerId);
                if(playerSquads){
                    playerSquads.push(createdSquad);
                } else {
                    playerSquads = [createdSquad];                    
                }
                this.createdSquads.set(playerId, playerSquads);
                return { success: true, squad: createdSquad };
            }
            
        } catch (error) {
            console.error('Error spawning units from placements:', error);
            return { success: false, error: `Failed to spawn units: ${error.message}` };
        }
    }

    // Called by game update loop to check for battle end
    update() {
        if (this.game.state?.phase !== 'battle') {
            return;
        }
        this.currentBattleTime += this.game.state.deltaTime;
        // Check for battle end conditions
        this.checkForBattleEnd();
    }

    checkForBattleEnd() {
        if (!this.game.componentManager) return;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const allBattleEntities = this.game.getEntitiesWith(
            ComponentTypes.TEAM,
            ComponentTypes.HEALTH,
            ComponentTypes.UNIT_TYPE
        );

        const aliveEntities = allBattleEntities.filter(entityId => {
            const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
            const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
            return health && health.current > 0 && (!deathState || !deathState.isDying);
        });

        const teams = new Map();
        for (const entityId of aliveEntities) {
            const team = this.game.getComponent(entityId, ComponentTypes.TEAM);
            if (team) {
                if (!teams.has(team.team)) {
                    teams.set(team.team, []);
                }
                teams.get(team.team).push(entityId);
            }
        }
        const aliveTeams = Array.from(teams.keys());
           
        const noCombatActive = this.checkNoCombatActive(aliveEntities);
        const allUnitsAtTarget = this.checkAllUnitsAtTargetPosition(aliveEntities);
        
        if( this.currentBattleTime < this.minBattleDuration){
            return;
        }
        if( this.currentBattleTime > this.maxBattleDuration){
            this.endBattle(this.game.room, null);
            return;
        }

        if (aliveEntities.length === 0) {
            console.log('no alive entities');
            this.endBattle(this.game.room, null);
            return;
        }
        
        if (aliveTeams.length === 1 && allUnitsAtTarget) {
            console.log('aliveTeams length is 1', aliveTeams, aliveEntities);
            console.log('all entities', allBattleEntities);
            console.log('aliveEntities', aliveEntities);
            this.endBattle(this.game.room, aliveTeams[0]);
            return;
        }
     
        if (noCombatActive && allUnitsAtTarget) {
            console.log('no combat active and all units at target');
            this.endBattle(this.game.room, null);
        }
    }

    checkNoCombatActive(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        
        for (const entityId of aliveEntities) {
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
         //   console.log(entityId, 'currentTarget', aiState.target);
            if (aiState && aiState.target) {
                return false;
            }
        }
        
        return true;
    }

    checkAllUnitsAtTargetPosition(aliveEntities) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const TARGET_POSITION_THRESHOLD = 20;
        
        for (const entityId of aliveEntities) {
            const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
            const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
            const targetPos = aiState?.targetPosition;

            if (!pos || !targetPos) {
                continue;
            }
            const distance = Math.sqrt(
                Math.pow(targetPos.x - pos.x, 2) + 
                Math.pow(targetPos.z - pos.z, 2)
            );
  
            if (distance > TARGET_POSITION_THRESHOLD) {
                return false;
            }
        }
        
        return true;
    }

    endBattle(room, winner = null, reason = 'unknown') {

        this.game.triggerEvent('onBattleEnd');        
        const playerStats = this.getPlayerStats(room);
        let battleResult = {
            winner: winner,
            reason: reason,
            round: this.game.state.round,
            survivingUnits: this.getSurvivingUnits(),
            playerStats: playerStats
        };
        
        const entitySync = this.serializeAllEntities();
        // Broadcast with updated health values
        this.serverNetworkManager.broadcastToRoom(room.id, 'BATTLE_END', {
            result: battleResult,
            gameState: room.getGameState(), // This will also have updated player health
            entitySync: entitySync
        });
        // Check for game end or continue to next round
        if (this.shouldEndGame(room)) {
            this.endGame(room);
        } else {
            this.game.state.round += 1;
            // Transition back to placement phase
            this.game.state.phase = 'placement';
            // Reset placement ready states
            for (const [playerId, player] of room.players) {
                player.placementReady = false;
            }
            this.game.triggerEvent('onPlacementPhaseStart');
        }
    }


    serializeAllEntities() {
        const serialized = {};
        
        for (const [entityId, componentTypes] of this.game.entities) {
            serialized[entityId] = {};
            
            for (const componentType of componentTypes) {
                const component = this.game.getComponent(entityId, componentType);
                if (component) {
                    serialized[entityId][componentType] = JSON.parse(JSON.stringify(component));
                }
            }
        }
        
        return serialized;
    }
    calculateRoundGold(round) {
        return this.baseGoldPerRound + (round * this.baseGoldPerRound);
    }
    getSurvivingUnits() {
        const survivors = {};
        
        // Count surviving units from created squads
        for (const [playerId, squads] of this.createdSquads) {
            let survivingCount = 0;
            let sideSurvivors = [];
            for (const squad of squads) {
                if (squad.squadUnits && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    
                    for (const entityId of squad.squadUnits) {
                        const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                        const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                  
                        if (health && health.current > 0 && (!deathState || !deathState.isDying)) {
                            sideSurvivors.push(entityId);
                            survivingCount++;
                        }
                    }
                }
            }
            
            survivors[playerId] = sideSurvivors;
        }
        
        return survivors;
    }

    getPlayerStats(room) {
        const stats = {};
        for (const [playerId, player] of room.players) {
            stats[playerId] = {
                name: player.name,
                stats: player.stats
            };
        }
        return stats;
    }

    shouldEndGame(room) {
        const alivePlayers = Array.from(room.players.values()).filter(p => (p.stats.health) > 0);
        return alivePlayers.length <= 1;
    }

  
    addGoldForTeam(goldAmt, team){
        for (const [playerId, player] of room.players) {
            if(player.side == team){
                player.stats.gold = player.stats.gold + goldAmt;
                break;
            }
        }
    }

    endGame(room) {
        this.game.state.phase = 'ended';
        
        // Determine final winner
        let finalWinner = null;
        let maxHealth = -1;
        
        for (const [playerId, player] of room.players) {
            const health = player.stats.health;
            if (health > maxHealth) {
                maxHealth = health;
                finalWinner = playerId;
            }
        }
        
        const gameResult = {
            winner: finalWinner,
            finalStats: this.getPlayerStats(room),
            totalRounds: this.game.state.round
        };
        
        this.serverNetworkManager.broadcastToRoom(room.id, 'GAME_END', {
            result: gameResult,
            gameState: room.getGameState()
        });
        
        // Mark room as inactive after delay
        setTimeout(() => {
            room.isActive = false;
        }, 10000);
    }

    onBattleEnd() {

        if (!this.game.componentManager) return;
        
        this.currentBattleTime = 0;
        
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const entitiesToDestroy = new Set();
        
        // Collect battle entities (but not players)
        [
            ComponentTypes.CORPSE
        ].forEach(componentType => {
            const entities = this.game.getEntitiesWith(componentType);
            entities.forEach(id => {
                entitiesToDestroy.add(id);                
            });
        });
        
        // Destroy entities
        entitiesToDestroy.forEach(entityId => {
            try {
                this.game.destroyEntity(entityId);
            } catch (error) {
                console.warn(`Error destroying entity ${entityId}:`, error);
            }
        });
  
        // Clear squad references
        this.createdSquads.clear();
    }

};

// System: ServerPlacementSystem
window.COMPILED_GAME.classRegistry.systems = window.COMPILED_GAME.classRegistry.systems || {};
window.COMPILED_GAME.classRegistry.systems['ServerPlacementSystem'] = class ServerPlacementSystem extends engine.BaseSystem {
    constructor(game) {
        super(game);  
        this.game.placementSystem = this;
        this.serverNetworkManager = this.engine.serverNetworkManager;  
        this.playerPlacements = new Map();
        this.leftPlacements = [];
        this.rightPlacements = [];
        this.placementReadyStates = new Map();
        this.numPlayers = 2;
     }

    init(params) {
        this.params = params || {};
         this.subscribeToEvents();
    }
    subscribeToEvents() {
        if (!this.game.serverEventManager) {
            console.error('No event manager found on engine');
            return;
        }

        // Subscribe to room management events
        this.game.serverEventManager.subscribe('GET_STARTING_STATE', this.handleGetStartingState.bind(this));
        this.game.serverEventManager.subscribe('SUBMIT_PLACEMENT', this.handleSubmitPlacement.bind(this));
        this.game.serverEventManager.subscribe('PURCHASE_UPGRADE', this.handlePurchaseUpgrade.bind(this));
        this.game.serverEventManager.subscribe('READY_FOR_BATTLE', this.handleReadyForBattle.bind(this));
        this.game.serverEventManager.subscribe('LEVEL_SQUAD', this.handleLevelSquad.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGET', this.handleSetSquadTarget.bind(this));
        this.game.serverEventManager.subscribe('SET_SQUAD_TARGETS', this.handleSetSquadTargets.bind(this));
    
    }

    getPlacementById(placementId) {
        // Search in player placements first
        const leftPlacements = this.leftPlacements.find(placement => placement.placementId === placementId);
        if (leftPlacements) {
            return leftPlacements;
        }
        
        // Search in opponent placements
        const rightPlacements = this.rightPlacements.find(placement => placement.placementId === placementId);
        if (rightPlacements) {
            return rightPlacements;
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlayerIdByPlacementId(placementId) {
        // Iterate through all players and their placements
        for (const [playerId, placements] of this.playerPlacements) {
            // Check if any placement in this player's placements matches the placementId
            const foundPlacement = placements.find(placement => placement.placementId === placementId);
            if (foundPlacement) {
                return playerId;
            }
        }
        
        // Return null if no matching placement is found
        return null;
    }
    getPlacementsForSide(side){
        if(side == 'left'){
            return this.leftPlacements;
        } else {
            return this.rightPlacements;
        }
    }

    handleGetStartingState(eventData) {
        try {
            const { playerId, data } = eventData;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            if(player){
                this.serverNetworkManager.sendToPlayer(playerId, 'GOT_STARTING_STATE', this.getStartingState(player));
            }
            
        } catch (error) {
            console.error('Error getting starting state:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'GOT_STARTING_STATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data,
                success: false
            });
        }
    }

    async handleLevelSquad(eventData){
        const { playerId, data } = eventData;
        const { placementId, specializationId } = data;
        let playerGold = 0;
        if(playerId){
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);         
            if(roomId){
                const room = this.engine.getRoom(roomId);
                if(room){
                    const player = room.players.get(playerId);                    
                    playerGold = player.stats.gold;
                    console.log('got player gold', playerGold);
            
                    if (!this.game.squadExperienceSystem.canAffordLevelUp(placementId, playerGold)) {            
                        console.log("not enough gold to level up");
                        this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                            playerId: playerId,
                            error: "gold_low_error",
                            success: false
                        });
                        return false;
                    }
                    const success1 = specializationId ? this.game.squadExperienceSystem.applySpecialization(placementId, specializationId, playerId) : true;
       
                    await this.game.squadExperienceSystem.levelUpSquad(placementId, null, playerId, (success) => {
                        console.log('success?: ', success1, success);
                        if(success1 && success){
                            const levelUpCost = this.game.squadExperienceSystem.getLevelUpCost(placementId);        
                            
                            player.stats.gold -= levelUpCost;
                            console.log('leveled, new gold amt:', player.stats.gold);
                            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_LEVELED', {
                                playerId: playerId,
                                currentGold: player.stats.gold,
                                success: true
                            });
                        }
                    });
           
                }
            }
        } 
    }

    handleSubmitPlacement(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placement, ready } = data;
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'SUBMITTED_PLACEMENT', this.submitPlayerPlacement(playerId, player, placement, true));
            
        } catch (error) {
            console.error('Error submitting placements:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'READY_FOR_BATTLE_UPDATE', { 
                error: 'Server error while submitting placements',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handlePurchaseUpgrade(eventData) {
        try {
            const { playerId, data } = eventData;
            
  
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) { 
                this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', { 
                    error: 'Room not found'
                });
                return;
            }
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            // Broadcast ready state update to all players in room
            this.serverNetworkManager.sendToPlayer(playerId, 'PURCHASED_UPGRADE', this.purchaseUpgrade(playerId, player, data.data, true));
            
        } catch (error) {
            console.error('Error purchasing upgrades:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'PURCHASED_UPGRADE', { 
                error: 'Server error while purchasing upgrades',
                playerId: eventData.playerId,
                ready: false,
                received: data
            });
        }
    }

    handleSetSquadTarget(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementId, targetPosition } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            // Validate placement belongs to player            
            const placement = this.getPlacementById(placementId);
            
            if (!placement) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                    error: 'Placement not found'
                });
                return;
            }
            
            // Store target position in placement data
            placement.targetPosition = targetPosition;
            placement.squadUnits.forEach((unitId) => {
                const aiState = this.game.getComponent(unitId, this.game.componentManager.getComponentTypes().AI_STATE);
                if(aiState && targetPosition){
                    aiState.targetPosition = targetPosition;
                    aiState.currentAIController = "OrderSystemMove";
                }
            });
                    
               
            
            // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGET_SET', { 
                success: true,
                placementId,
                targetPosition
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGET_SET', {
                        placementId,
                        targetPosition
                    });
                }
            }
            
            console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGET_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }

    handleSetSquadTargets(eventData) {
        try {
            const { playerId, data } = eventData;
            const { placementIds, targetPositions } = data;
            if(this.game.state.phase != "placement") {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    success: false
                });
                return;
            };
            const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
            if (!roomId) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Room not found'
                });
                return;
            }
            
            const room = this.engine.getRoom(roomId);
            const player = room.getPlayer(playerId);
            
            if (!player) {
                this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                    error: 'Player not found'
                });
                return;
            }
            
            for(let i = 0; i < placementIds.length; i++){
                let placementId = placementIds[i];
                let targetPosition = targetPositions[i];
                // Validate placement belongs to player            
                const placement = this.getPlacementById(placementId);
                
                if (!placement) {
                    console.log(placementId, 'not found');
                    this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                        error: 'Placement not found'
                    });
                    return;
                }
                
                // Store target position in placement data
                placement.targetPosition = targetPosition;
                placement.squadUnits.forEach((unitId) => {
                    const aiState = this.game.getComponent(unitId, this.game.componentManager.getComponentTypes().AI_STATE);
                    if(aiState && targetPosition){
                        aiState.targetPosition = targetPosition;
                        aiState.currentAIController = "OrderSystemMove";
                    }
                });
                        

                
                console.log(`Player ${playerId} set target for squad ${placementId}:`, targetPosition);
            }

                        // Send success response to requesting player
            this.serverNetworkManager.sendToPlayer(playerId, 'SQUAD_TARGETS_SET', { 
                success: true
            });
            
            // Broadcast to other players in the room
            for (const [otherPlayerId, otherPlayer] of room.players) {
                if (otherPlayerId !== playerId) {
                    this.serverNetworkManager.sendToPlayer(otherPlayerId, 'OPPONENT_SQUAD_TARGETS_SET', {
                        placementIds,
                        targetPositions
                    });
                }
            }
            
        } catch (error) {
            console.error('Error setting squad target:', error);
            this.serverNetworkManager.sendToPlayer(eventData.playerId, 'SQUAD_TARGETS_SET', { 
                error: 'Server error while setting squad target'
            });
        }
    }


    handleReadyForBattle(eventData) {
        const { playerId, data } = eventData; 
        const roomId = this.serverNetworkManager.getPlayerRoom(playerId);
        if (!roomId) { 
            this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { 
                error: 'Room not found'
            });
            return;
        }
        const room = this.engine.getRoom(roomId);
          
        const player = room.getPlayer(playerId);
        // Update ready state
        player.placementReady = true;
        this.placementReadyStates.set(playerId, true);
        
        this.serverNetworkManager.sendToPlayer(playerId, 'READY_FOR_BATTLE_RESPONSE', { success: true });
            
        // Check if all players are ready and start battle if so
        if (this.areAllPlayersReady() && this.game.state.phase === 'placement') {

            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: true
            });
            this.placementReadyStates.clear();
            // Small delay to ensure clients receive the ready update

            this.game.resetCurrentTime();
            this.applyTargetPositions();
            this.game.desyncDebugger.enabled = true;    
            this.game.desyncDebugger.displaySync(true);
            this.resetAI();
            this.game.serverBattlePhaseSystem.startBattle(room);
        } else {
            const gameState = room.getGameState();
            this.serverNetworkManager.broadcastToRoom(roomId, 'READY_FOR_BATTLE_UPDATE', {                       
                gameState: gameState,
                allReady: false
            });
        }

    }
    
    resetAI() {
        const componentTypes = this.game.componentManager.getComponentTypes();            
        const AIEntities = this.game.getEntitiesWith(componentTypes.AI_STATE, componentTypes.COMBAT);      
        AIEntities.forEach((entityId) => {
            const aiState = this.game.getComponent(entityId, componentTypes.AI_STATE);
            const combat = this.game.getComponent(entityId, componentTypes.COMBAT);
            combat.lastAttack = 0;
            aiState.aiBehavior = {};
        });
    }

    applyTargetPositions() {
     //   console.log('APPLY TARGET POSITIONS');
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        for (const [playerId, placements] of this.playerPlacements) {
            placements.forEach((placement) => {     
                const targetPosition = placement.targetPosition;         
                placement.squadUnits.forEach(entityId => {
                    const aiState = this.game.getComponent(entityId, ComponentTypes.AI_STATE);
                    const position = this.game.getComponent(entityId, ComponentTypes.POSITION);
                    if (aiState && position) {
                        
                        if(targetPosition){
                            if(!aiState.currentAIController || aiState.currentAIController == "OrderSystemMove"){
                                const dx = position.x - targetPosition.x;
                                const dz = position.z - targetPosition.z;
                                const distSq = dx * dx + dz * dz;
                                const threshold = this.game.getCollections().configs.game.gridSize * 0.5;
                                
                                if (distSq <= threshold * threshold) {
                                    aiState.currentAIController = null;
                                    aiState.targetPosition = null;
                                    placement.targetPosition = null;
                                } else {
                                    aiState.targetPosition = { ...targetPosition };      
                                    aiState.currentAIController = "OrderSystemMove";
                                }
                            }
                        }
                    }
                });
            });
        }
    }

    areAllPlayersReady() {
        let states = [...this.placementReadyStates.values()]
        return states.length == this.numPlayers && states.every(ready => ready === true);
    }


    submitPlayerPlacement(playerId, player, placement) {
        // console.log(`=== SUBMIT PLACEMENT DEBUG ===`);
        // console.log(`Player ID: ${playerId}`);
        // console.log(`Room ID: ${this.game.room?.id || 'NO ROOM'}`);
        // console.log(`Game phase: ${this.game.state.phase}`);
        // console.log(`================================`);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }
        
        // Validate placements if provided
        if ( !this.validatePlacement(placement, player)) {
            return { success: false, error: 'Invalid placement' };
        }


        // Deduct gold only for new units
        if (placement.unitType?.value > 0 && !placement.isStartingState) {
            player.stats.gold -= placement.unitType?.value;
        }            
        
        
        // Store placements
        let playerPlacements = this.playerPlacements.get(playerId);
        if(playerPlacements){
            playerPlacements.push(placement);
        } else {
            playerPlacements = [placement];
        }
        this.playerPlacements.set(playerId, playerPlacements);

        if(player.stats.side == 'left'){
            this.leftPlacements = this.playerPlacements.get(playerId);
        } else {
            this.rightPlacements = this.playerPlacements.get(playerId);
        }
        
        const result = this.game.serverBattlePhaseSystem.spawnSquadFromPlacement(playerId, placement);

        if(result.success && result.squad){
            let squadUnits = [];
            result.squad.squadUnits.forEach((entityId) => {
                squadUnits.push(entityId);
            })
            placement.squadUnits = squadUnits;
            if (this.game.squadExperienceSystem && placement.placementId) {
                this.game.squadExperienceSystem.initializeSquad(
                    placement.placementId, 
                    placement.unitType,
                    placement.squadUnits, 
                    placement.team
                );
            }
            if (placement.peasantInfo && placement.collection === 'buildings') {
                const peasantInfo = placement.peasantInfo;
                const peasantId = peasantInfo.peasantId;
                const entityId = placement.squadUnits[0];
             
                // Get the build ability from the peasant's abilities
    
                const peasantAbilities = this.game.abilitySystem.entityAbilities.get(peasantId);
                if (peasantAbilities) {
                    //console.log("peasantAbilities", peasantAbilities);
                    const buildAbility = peasantAbilities.find(a => a.id === 'build');
                    if (buildAbility) {
                        buildAbility.assignToBuild(peasantId, entityId, peasantInfo);
                    }
                }
                
                
                // Clear the flag (only once for first building entity)
                this.game.state.peasantBuildingPlacement = null;
            }
        }


        return { success: result.success };
    }


    onBattleEnd() {        
        this.removeDeadSquadsAfterRound();
       // this.updateGridPositionsAfterRound();
       
        this.game.desyncDebugger.displaySync(true);
        this.game.desyncDebugger.enabled = false;
    }
    
    removeDeadSquadsAfterRound() {
        if (!this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();

        this.playerPlacements.forEach((placements, playerId) => {
            const survivingPlacements = placements.filter(placement => {
                if (!placement.experience?.unitIds || placement.experience.unitIds.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                const aliveUnits = placement.experience.unitIds.filter(entityId => {
                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                    const buildingState = this.game.getComponent(entityId, ComponentTypes.BUILDING_STATE);
                    if(buildingState) return true;
                    return health && health.current > 0 && (!deathState || !deathState.isDying);
                });

                if (aliveUnits.length === 0) {
                    this.cleanupDeadSquad(placement);
                    return false;
                }

                placement.experience.unitIds = aliveUnits;
                return true;
            });

            this.playerPlacements.set(playerId, survivingPlacements);
        });
    }

    cleanupDeadSquad(placement) {
        if (this.game.gridSystem && placement.placementId) {
            this.game.gridSystem.freeCells(placement.placementId);
        }

        if (this.game.squadExperienceSystem && placement.placementId) {
            this.game.squadExperienceSystem.removeSquad(placement.placementId);
        }

       // console.log(`Squad eliminated: ${placement.unitType?.title || placement.placementId}`);
    }

    updateGridPositionsAfterRound() {
        if (!this.game.gridSystem || !this.game.componentManager) return;

        const ComponentTypes = this.game.componentManager.getComponentTypes();
        this.game.gridSystem.clear();

        this.playerPlacements.forEach((placements, playerId) => {
            placements.forEach(placement => {
                if (!placement.experience?.unitIds || placement.experience.unitIds.length === 0) return;

                const aliveUnits = placement.experience.unitIds.filter(entityId => {
                    const health = this.game.getComponent(entityId, ComponentTypes.HEALTH);
                    const deathState = this.game.getComponent(entityId, ComponentTypes.DEATH_STATE);
                    return health && health.current > 0 && (!deathState || !deathState.isDying);
                });

                if (aliveUnits.length === 0) return;

                const positions = aliveUnits.map(entityId => {
                    const pos = this.game.getComponent(entityId, ComponentTypes.POSITION);
                    return pos ? { x: pos.x, z: pos.z } : null;
                }).filter(p => p !== null);

                if (positions.length === 0) return;

                const avgX = positions.reduce((sum, p) => sum + p.x, 0) / positions.length;
                const avgZ = positions.reduce((sum, p) => sum + p.z, 0) / positions.length;
                const newGridPos = this.game.gridSystem.worldToGrid(avgX, avgZ);

                if (this.game.gridSystem.isValidPosition(newGridPos)) {
                    placement.gridPosition = newGridPos;
                    placement.experience.unitIds = aliveUnits;

                    const squadData = this.game.squadManager?.getSquadData(placement.unitType);
                    if (squadData) {
                        const cells = this.game.squadManager.getSquadCells(newGridPos, squadData);
                        placement.cells = cells;
                        this.game.gridSystem.occupyCells(cells, placement.placementId);
                    }
                }
            });
        });
    }


    validatePlacement(placement, player) {
       

        // Calculate cost of only NEW units
        const newUnitCost =  placement.unitType?.value;
        
        
        if (newUnitCost > player.stats.gold) {
            console.log(`Player ${player.id} insufficient gold: ${newUnitCost} > ${player.stats.gold}`);
            return false;
        }
        
        // Check placement positions (basic validation)
    
        if (!placement.gridPosition || !placement.unitType) {
            console.log(`Player ${player.id} invalid placement data:`, placement);
            return false;
        }
        
        // Validate side placement - no mirroring, direct side enforcement
        const squadData = this.game.squadManager.getSquadData(placement.unitType);
        const cells = this.game.squadManager.getSquadCells(placement.gridPosition, squadData);
        if(!this.game.gridSystem.isValidPlacement(cells, player.stats.side)){
            console.log('Invalid Placement', placement);
            return false;
        }
    
        
        return true;
    }
    clearAllPlacements(){

        this.playerPlacements.keys().forEach((playerId) => {
            this.clearPlayerPlacements(playerId);
        });

        this.playerPlacements = new Map();
        this.leftPlacements = new Map();
        this.rightPlacements = new Map();
        this.placementReadyStates = new Map();  
    }
    clearPlayerPlacements(playerId) {
        try {
            // Get player's placements
            const placements = this.playerPlacements.get(playerId) || [];
            
            // Remove entities created by this player's placements
            placements.forEach(placement => {
                if (placement.unitIds) {
                    placement.unitIds.forEach(entityId => {
                        try {
                            if (this.game.destroyEntity) {
                                this.game.destroyEntity(entityId);
                            }
                        } catch (error) {
                            console.warn(`Error destroying entity ${entityId}:`, error);
                        }
                    });
                }
                
                // Free grid cells
                if (placement.placementId) {
                    this.game.gridSystem.freeCells(placement.placementId);
                }
            });
            
            // Clear from maps
            this.playerPlacements.delete(playerId);
            
            // Clear from undo stack if it's this player
            if (this.undoStack) {
                this.undoStack = this.undoStack.filter(undo => undo.playerId !== playerId);
            }
            
            console.log(`Cleared placements for player ${playerId}`);
            
        } catch (error) {
            console.error(`Error clearing placements for player ${playerId}:`, error);
        }
    }

    saveBuilding(entityId, team, gridPosition, unitType) {
        console.log(`=== Purchase Building DEBUG ===`);     
        console.log(`Data received:`, entityId, team, unitType);

        if (unitType.id === 'goldMine') {
            const gridWidth = unitType.placementGridWidth || 2;
            const gridHeight = unitType.placementGridHeight || 2;
            
            const result = this.game.goldMineSystem.buildGoldMine(entityId, team, gridPosition, gridWidth, gridHeight);
            if (!result.success) {
                return result;
            }
        }            
        console.log(`SUCCESS`);
        console.log(`================================`);
        return { success: true };
    }

    purchaseUpgrade(playerId, player, data) {
        console.log(`=== Purchase Upgrade DEBUG ===`);       
        console.log(`Data received:`, data);
    
        if (this.game.state.phase !== 'placement') {
            return { success: false, error: `Not in placement phase (${this.game.state.phase})` };
        }

        const upgrade = this.game.getCollections().upgrades[data.upgradeId];
        if(upgrade?.value <= player.stats.gold){
            player.stats.gold -= upgrade.value;
            if(!this.game.state.teams){
                this.game.state.teams = {};
            }
            if(!this.game.state.teams[player.stats.side]) {
                this.game.state.teams[player.stats.side] = {};
            } 
            if(!this.game.state.teams[player.stats.side].effects) {
                this.game.state.teams[player.stats.side].effects = {};
            }
            upgrade.effects.forEach((effectId) => {
                const effect = this.game.getCollections().effects[effectId];
                this.game.state.teams[player.stats.side].effects[effectId] = effect;
            })
            
            console.log(`SUCCESS`);
            console.log(`================================`);
            return { success: true };
        }

        console.log(`ERROR`);    
        console.log(`================================`);
        
        return { success: false, error: "Not enough gold." };
    }

    getStartingState(player){

        let startPosition = { x: 5, z: 5 };
        if(player.stats.side == 'right'){
            startPosition = { x: 58, z: 58 };
        }
        
        // Find nearest unclaimed gold vein
        let nearestGoldVeinLocation = null;
        let minDistance = Infinity;
        
        if (this.game.goldMineSystem && this.game.goldMineSystem.goldVeinLocations) {
            this.game.goldMineSystem.goldVeinLocations.forEach(vein => {
                // Skip if already claimed
                if (vein.claimed) return;
                
                // Calculate distance from start position to vein
                const dx = vein.gridPos.x - startPosition.x;
                const dz = vein.gridPos.z - startPosition.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestGoldVeinLocation = vein.gridPos;
                }
            });
        }
        
        
        // Calculate peasant positions on the same side as gold mine
        // TownHall is 2x2, so it occupies a 2x2 area centered at startPosition
        const dx = nearestGoldVeinLocation.x - startPosition.x;
        const dz = nearestGoldVeinLocation.z - startPosition.z;
        
        let peasantPositions = [];
        
        // Determine which side the gold mine is on and place peasants accordingly
        if (Math.abs(dx) > Math.abs(dz)) {
            // Gold mine is more to the east or west
            if (dx > 0) {
                // Gold mine is to the EAST, place peasants on east side
                // TownHall occupies x to x+1, so peasants start at x+2
                peasantPositions = [
                    { x: startPosition.x + 2, z: startPosition.z - 1 },
                    { x: startPosition.x + 2, z: startPosition.z },
                    { x: startPosition.x + 2, z: startPosition.z + 1 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the WEST, place peasants on west side
                // TownHall occupies x-1 to x, so peasants start at x-2
                peasantPositions = [
                    { x: startPosition.x - 2, z: startPosition.z - 1 },
                    { x: startPosition.x - 2, z: startPosition.z },
                    { x: startPosition.x - 2, z: startPosition.z + 1 },
                    { x: startPosition.x - 2, z: startPosition.z + 2 }
                ];
            }
        } else {
            // Gold mine is more to the north or south
            if (dz > 0) {
                // Gold mine is to the SOUTH, place peasants on south side
                // TownHall occupies z to z+1, so peasants start at z+2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z + 2 },
                    { x: startPosition.x, z: startPosition.z + 2 },
                    { x: startPosition.x + 1, z: startPosition.z + 2 },
                    { x: startPosition.x + 2, z: startPosition.z + 2 }
                ];
            } else {
                // Gold mine is to the NORTH, place peasants on north side
                // TownHall occupies z-1 to z, so peasants start at z-2
                peasantPositions = [
                    { x: startPosition.x - 1, z: startPosition.z - 2 },
                    { x: startPosition.x, z: startPosition.z - 2 },
                    { x: startPosition.x + 1, z: startPosition.z - 2 },
                    { x: startPosition.x + 2, z: startPosition.z - 2 }
                ];
            }
        }
        
        const startingUnits = [
            {
                type: "townHall",
                collection: "buildings",
                position: startPosition
            },
            {
                type: "goldMine",
                collection: "buildings",
                position: nearestGoldVeinLocation
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[0]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[1]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[2]
            },
            {
                type: "peasant",
                collection: "units",
                position: peasantPositions[3]
            }
        ];

        const pitch = 35.264 * Math.PI / 180;
        const yaw = 135 * Math.PI / 180;
        const distance = 10240;

        const cdx = Math.sin(yaw) * Math.cos(pitch);
        const cdz = Math.cos(yaw) * Math.cos(pitch);

        
            
        const worldPos = this.game.gridSystem.gridToWorld(startPosition.x, startPosition.z);

        const cameraPosition = {
            x: worldPos.x - cdx * distance,
            y: distance,
            z: worldPos.z - cdz * distance
        };

        const lookAt = {
            x: worldPos.x,
            y: 0, 
            z: worldPos.z
        };

        return {
            success: true,
            startingUnits,
            camera: {
                position: cameraPosition,
                lookAt
            }
        };
    }
}
;

// ========== MANAGERS ==========

// Manager: ComponentManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['ComponentManager'] = class ComponentManager {
    constructor(game) {
        this.game = game;
        this.game.componentManager = this;
        this.models = this.game.getCollections().models;

        //this.models.position == { x: 0, y: 0, z: 0 };
    }

    deepMerge(target, source) {
        const result = { ...target };
        
        for (const key in source) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else {
                result[key] = source[key] == 'null' ? null : source[key];
            }
        }
        
        return result;
    }

    getModels() {
        let components = {};
        Object.keys(this.models).forEach((modelId) => {
            const data = this.models[modelId];
            components[modelId] = (params = {}) => {
                return this.deepMerge(data, params);
            };        
        });
        return components;
    }
    getComponents(){
        return {
            Position: (x = 0, y = 0, z = 0) => ({ x, y, z }),
            Velocity: (vx = 0, vy = 0, vz = 0, maxSpeed = 100, affectedByGravity = true, anchored = false) => ({ vx, vy, vz, maxSpeed, affectedByGravity, anchored}),
            Facing: (angle) => ({ angle: angle || 0 }),
            Renderable: (objectType, spawnType) => ({ objectType, spawnType }),
            Collision: (radius = 1, height = 50) => ({ radius, height }),
            Health: (max = 100) => ({ max, current: max }),
            Building: (type) => ( { type }),
            
            // Enhanced Combat component with elemental damage and defenses
            Combat: (
                damage = 0, 
                range = 1, 
                attackSpeed = 1, 
                projectile = null, 
                lastAttack = 0,
                element = 'physical',
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                visionRange = 300
            ) => ({
                damage,
                range,
                attackSpeed,
                projectile,
                lastAttack,
                element,
                armor,
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                visionRange
            }),
            Placement: (placement = null) => (placement),
            Team: (team = 'neutral') => ({ team }),
            UnitType: (unitType) => ({ ...unitType }),
            AIState: (state = 'idle', targetPosition = null, target = null, lastStateChange = 0, currentAIController = null ) => 
                ({ state, targetPosition, target, lastStateChange, currentAIController }),
            Animation: (scale = 1, rotation = 0, flash = 0) => ({ scale, rotation, flash }),
            
            // Enhanced Projectile component with element support
            Projectile: (
                damage = 10, 
                speed = 200, 
                range = 100, 
                target = null, 
                source = null, 
                startTime = 0,
                element = 'physical'
            ) => ({
                damage,
                speed,
                range,
                target,
                source,
                startTime,
                element
            }),
            Lifetime: (duration = 5, startTime = 0) => ({ duration, startTime }),
            HomingTarget: (targetId = null, homingStrength = 0.5, lastKnownPosition = null) => 
                ({ targetId, homingStrength, lastKnownPosition }),
            
            // Enhanced Equipment component that can provide resistances
            Equipment: (slots = {}) => ({ 
                slots: {
                    mainHand: null,
                    offHand: null,
                    helmet: null,
                    chest: null,
                    legs: null,
                    feet: null,
                    back: null,
                    ...slots
                }
            }),
            
            EquipmentSlot: (slotType, itemId = null, attachmentPoint = null, offset = { x: 0, y: 0, z: 0 }, rotation = { x: 0, y: 0, z: 0 }) => ({
                slotType,
                itemId,
                attachmentPoint,
                offset,
                rotation
            }),
            
            // Enhanced EquipmentItem with defensive stats
            EquipmentItem: (
                itemType, 
                modelPath, 
                stats = {},
                armor = 0,
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                element = null  // Weapon element
            ) => ({
                itemType,
                modelPath,
                stats: {
                    ...stats,
                    armor,
                    fireResistance,
                    coldResistance,
                    lightningResistance,
                    poisonResistance,
                    element
                },
                attachmentData: {
                    mainHand: {
                        bone: 'Hand_R',
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    },
                    offHand: {
                        bone: 'Hand_L', 
                        offset: { x: 0, y: 0, z: 0 },
                        rotation: { x: 0, y: 0, z: 0 }
                    }
                }
            }),
            
            Corpse: (originalUnitType = null, deathTime = 0, teamAtDeath = 'neutral') => ({ 
                originalUnitType, 
                deathTime, 
                teamAtDeath,
                isCorpse: true 
            }),
            
            DeathState: (isDying = false, deathStartTime = 0, deathAnimationDuration = 2.0) => ({ 
                isDying, 
                deathStartTime, 
                deathAnimationDuration 
            }),

            // Status effect component for tracking temporary effects
            StatusEffect: (
                effectType = 'buff',
                element = null,
                duration = 0,
                startTime = 0,
                sourceId = null,
                stacks = 1,
                maxStacks = 1
            ) => ({
                effectType,  // 'buff', 'debuff', 'dot', 'immunity'
                element,
                duration,
                startTime,
                sourceId,
                stacks,
                maxStacks
            }),

            // Resistance component for temporary resistances/immunities
            ElementalResistance: (
                fireResistance = 0,
                coldResistance = 0,
                lightningResistance = 0,
                poisonResistance = 0,
                physicalResistance = 0,
                divineResistance = 0,
                duration = null,
                permanent = true
            ) => ({
                fireResistance,
                coldResistance,
                lightningResistance,
                poisonResistance,
                physicalResistance,
                divineResistance,
                duration,
                permanent
            }),

            // =============================================
            // TACTICAL ABILITY COMPONENTS (from original)
            // =============================================
            MiningState: (state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId) => ({
                state, targetMine, targetTownHall, hasGold, miningStartTime, depositStartTime, team, entityId
            }),
            BuildingState: (state, targetBuildingEntityId, targetBuildingPosition, constructionStartTime) => ({
                state, 
                targetBuildingEntityId, 
                targetBuildingPosition, 
                constructionStartTime                
            }),
            MindControlled: (originalTeam = 'neutral', controller = null, endTime = 0) => ({
                originalTeam,
                controller,
                endTime,
                isControlled: true
            }),
            
            MirrorImage: (originalEntity = null, isIllusion = true, createdTime = 0) => ({
                originalEntity,
                isIllusion,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Trap: (
                damage = 50, 
                radius = 80, 
                triggerRadius = 30, 
                element = 'physical', 
                caster = null, 
                triggered = false, 
                maxTriggers = 1
            ) => ({
                damage,
                radius,
                triggerRadius,
                element,
                caster,
                triggered,
                triggerCount: 0,
                maxTriggers
            }),
            
            Summoned: (summoner = null, summonType = 'generic', originalStats = null, createdTime = 0) => ({
                summoner,
                summonType,
                originalStats,
                createdTime: createdTime || (this.game.state.now || 0),
                isSummoned: true
            }),
            
            TemporaryEffect: (effectType = 'generic', data = {}, createdTime = 0) => ({
                effectType,
                data,
                createdTime: createdTime || (this.game.state.now || 0)
            }),
            
            Thorns: (reflectionPercent = 0.5, endTime = 0, totalReflected = 0) => ({
                reflectionPercent,
                endTime: endTime || (this.game.state.now || 0) + 20,
                totalReflected,
                isActive: true
            }),
            
            Taunt: (taunter = null, endTime = 0, radius = 0, isTaunted = true) => ({
                taunter,
                endTime: endTime || (this.game.state.now || 0) + 5,
                radius,
                isTaunted
            }),
            
            ShieldWall: (damageReduction = 0.75, endTime = 0, tauntRadius = 200, originalArmor = 0) => ({
                damageReduction,
                endTime: endTime || (this.game.state.now || 0) + 10,
                tauntRadius,
                originalArmor,
                isActive: true
            }),
            
            // =============================================
            // ENHANCED BUFF SYSTEM FOR NEW SPELLS
            // =============================================
            
            Buff: (
                buffType = 'generic', 
                modifiers = {}, 
                endTime = 0, 
                stackable = false, 
                stacks = 1, 
                appliedTime = 0
            ) => ({
                buffType,
                modifiers,
                endTime: endTime || (this.game.state.now || 0) + 30,
                stackable,
                stacks,
                appliedTime: appliedTime || (this.game.state.now || 0),
                isActive: true,
                
                // Specific buff properties based on type
                ...(buffType === 'rallied' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.3,
                    moralBoost: true,
                    fearImmunity: true
                }),
                
                ...(buffType === 'intimidated' && {
                    damageReduction: modifiers.damageReduction || 0.25,
                    accuracyReduction: modifiers.accuracyReduction || 0.2
                }),
                
                ...(buffType === 'phalanx' && {
                    armorMultiplier: modifiers.armorMultiplier || 1.0,
                    counterAttackChance: modifiers.counterAttackChance || 0.2,
                    formationSize: modifiers.formationSize || 1
                }),
                
                ...(buffType === 'marked' && {
                    damageTakenMultiplier: modifiers.damageTakenMultiplier || 1.25,
                    revealed: true,
                    markedBy: modifiers.markedBy || null
                }),
                
                ...(buffType === 'poison_weapon' && {
                    poisonDamage: modifiers.poisonDamage || 25,
                    poisonDuration: modifiers.poisonDuration || 6,
                    attacksRemaining: modifiers.attacksRemaining || 5
                }),
                
                ...(buffType === 'disrupted' && {
                    abilitiesDisabled: true,
                    accuracyReduction: modifiers.accuracyReduction || 0.4,
                    movementSlowed: modifiers.movementSlowed || 0.6
                }),
                
                ...(buffType === 'magic_weapon' && {
                    weaponElement: modifiers.weaponElement || 'fire',
                    elementalDamage: modifiers.elementalDamage || 15,
                    glowing: true
                }),
                
                ...(buffType === 'dark_empowerment' && {
                    damageMultiplier: modifiers.damageMultiplier,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier
                }),
                
                ...(buffType === 'ice_armor' && {
                    armorMultiplier: modifiers.armorMultiplier,
                }),
                
                ...(buffType === 'rage' && {
                    damageMultiplier: modifiers.damageMultiplier || 1.5,
                    attackSpeedMultiplier: modifiers.attackSpeedMultiplier || 1.3
                }),
                
                ...(buffType === 'bloodlust' && {
                    lifeSteal: modifiers.lifeSteal || 0.3,
                    damagePerKill: modifiers.damagePerKill || 5,
                    maxStacks: modifiers.maxStacks || 10
                }),
                
                ...(buffType === 'stunned' && {
                    movementDisabled: true,
                    attackDisabled: true
                })
            }),
            
            Whirlwind: (
                damage = 30, 
                radius = 80, 
                endTime = 0, 
                hitInterval = 0.3, 
                lastHitTime = 0, 
                totalHits = 0
            ) => ({
                damage,
                radius,
                endTime: endTime || (this.game.state.now || 0) + 2,
                hitInterval,
                lastHitTime,
                totalHits,
                isActive: true
            }),

            // =============================================
            // FORMATION AND SQUAD COMPONENTS
            // =============================================
            
            Formation: (
                formationType = 'none',
                formationSize = 1,
                formationLeader = null,
                formationMembers = [],
                formationBonuses = {},
                isActive = false
            ) => ({
                formationType, // 'phalanx', 'wedge', 'line', 'circle', etc.
                formationSize,
                formationLeader,
                formationMembers,
                formationBonuses,
                isActive,
                createdTime: (this.game.state.now || 0)
            }),
            
            SquadMember: (
                squadId = null,
                squadRole = 'member', // 'leader', 'member', 'specialist'
                squadPosition = { x: 0, z: 0 },
                squadBonuses = {}
            ) => ({
                squadId,
                squadRole,
                squadPosition,
                squadBonuses,
                joinedTime: (this.game.state.now || 0)
            }),

            // =============================================
            // ABILITY COOLDOWN AND RESOURCE COMPONENTS
            // =============================================
            
            AbilityCooldowns: (cooldowns = {}) => ({
                cooldowns, // Map of abilityId -> cooldownEndTime
                lastAbilityUsed: null,
                lastAbilityTime: 0
            }),
            
            ResourcePool: (
                mana = 100,
                maxMana = 100,
                manaRegen = 5,
                stamina = 100,
                maxStamina = 100,
                staminaRegen = 10,
                focus = 100,
                maxFocus = 100
            ) => ({
                mana,
                maxMana,
                manaRegen,
                stamina,
                maxStamina, 
                staminaRegen,
                focus,
                maxFocus,
                lastRegenTick: (this.game.state.now || 0)
            }),

            // =============================================
            // VISUAL EFFECT COMPONENTS
            // =============================================
            
            VisualEffect: (
                effectType = 'particle',
                effectData = {},
                duration = 1.0,
                startTime = 0,
                attachedTo = null
            ) => ({
                effectType,
                effectData,
                duration,
                startTime: startTime || (this.game.state.now || 0),
                attachedTo,
                isActive: true
            }),
            
            Aura: (
                auraType = 'generic',
                radius = 50,
                effects = {},
                visualEffect = null,
                persistent = true,
                pulseInterval = 1.0,
                lastPulse = 0
            ) => ({
                auraType,
                radius,
                effects,
                visualEffect,
                persistent,
                pulseInterval,
                lastPulse,
                createdTime: (this.game.state.now || 0)
            }),

            // =============================================
            // TARGETING AND AI COMPONENTS
            // =============================================
            
            TargetingPreference: (
                preferredTargets = [],
                avoidedTargets = [],
                targetPriority = 'nearest',
                maxTargetRange = 200,
                requiresLineOfSight = false
            ) => ({
                preferredTargets,
                avoidedTargets,
                targetPriority, // 'nearest', 'weakest', 'strongest', 'marked', 'leader'
                maxTargetRange,
                requiresLineOfSight,
                currentTarget: null,
                targetLockTime: 0
            }),
            
            Threat: (
                threatLevel = 0,
                maxThreat = 100,
                threatDecay = 1,
                lastThreatUpdate = 0,
                threatSources = new Map()
            ) => ({
                threatLevel,
                maxThreat,
                threatDecay,
                lastThreatUpdate,
                threatSources
            }),

            // =============================================
            // SPECIAL ABILITY STATE COMPONENTS
            // =============================================
            
            Charging: (
                target = null,
                chargeSpeed = 100,
                chargeDamage = 50,
                chargeStartTime = 0,
                chargeDistance = 0,
                maxChargeDistance = 150
            ) => ({
                target,
                chargeSpeed,
                chargeDamage,
                chargeStartTime,
                chargeDistance,
                maxChargeDistance,
                isCharging: true
            }),
            
            Channeling: (
                abilityId = null,
                channelDuration = 3.0,
                channelStartTime = 0,
                canBeInterrupted = true,
                interruptThreshold = 10
            ) => ({
                abilityId,
                channelDuration,
                channelStartTime,
                canBeInterrupted,
                interruptThreshold,
                isChanneling: true
            }),
            
            Stealthed: (
                stealthLevel = 1.0, // 0.0 = invisible, 1.0 = fully visible
                detectionRadius = 30,
                stealthStartTime = 0,
                canAttackWhileStealth = false,
                breaksOnAttack = true
            ) => ({
                stealthLevel,
                detectionRadius,
                stealthStartTime,
                canAttackWhileStealth,
                breaksOnAttack,
                isStealth: true
            }),

            // =============================================
            // ENVIRONMENTAL INTERACTION COMPONENTS  
            // =============================================
            
            EnvironmentalHazard: (
                hazardType = 'generic',
                damagePerTick = 10,
                tickInterval = 1.0,
                element = 'physical',
                affectsTeams = ['all'],
                lastTickTime = 0
            ) => ({
                hazardType, // 'fire', 'poison_cloud', 'ice_field', 'lightning_storm', etc.
                damagePerTick,
                tickInterval,
                element,
                affectsTeams,
                lastTickTime,
                createdTime: (this.game.state.now || 0)
            }),
            
            Consecrated: (
                consecrationLevel = 1.0,
                healPerTick = 5,
                damageToUndead = 10,
                tickInterval = 2.0,
                caster = null,
                lastTickTime = 0
            ) => ({
                consecrationLevel,
                healPerTick,
                damageToUndead,
                tickInterval,
                caster,
                lastTickTime,
                isConsecrated: true
            })
        };
    }

    getComponentTypes() {
        return {
            // Basic Components
            TRANSFORM: 'transform',
            POSITION: 'position',
            FACING: 'facing',
            VELOCITY: 'velocity',
            SCALE: 'scale',
            RENDERABLE: 'renderable',
            MAP_RENDERER: 'mapRenderer',
            SPRITE: 'sprite',
            MAP_MANAGER: 'mapManager',
            WORLD_OBJECT: 'worldObject',
            ENVIRONMENT_OBJECT: 'environmentObject',
            
            // Unit Components
            PLACEMENT: 'placement',
            TEAM: 'team',
            UNIT_TYPE: 'unitType',
            AI_STATE: 'aiState',
            ANIMATION: 'animation',
            HEALTH: 'health',
            COMBAT: 'combat',
            COLLISION: 'collision',
            BUILDING: 'building',
            
            // Projectile System
            PROJECTILE: 'projectile',
            LIFETIME: 'lifetime',
            HOMING_TARGET: 'homingTarget',
            
            // Entity System
            ENTITY_TYPE: 'entityType',
            LEVEL_DATA: 'levelData',
            
            // Equipment System
            EQUIPMENT: 'equipment',
            EQUIPMENT_SLOT: 'equipmentSlot',
            EQUIPMENT_ITEM: 'equipmentItem',
            
            // Death System
            CORPSE: 'corpse',
            DEATH_STATE: 'deathState',
            
            // Status Effects
            STATUS_EFFECT: 'statusEffect',
            ELEMENTAL_RESISTANCE: 'elementalResistance',

            // =============================================
            // TACTICAL ABILITY COMPONENT TYPES
            // =============================================
            MIND_CONTROLLED: 'mindControlled',
            MIRROR_IMAGE: 'mirrorImage',
            TRAP: 'trap',
            SUMMONED: 'summoned',
            TEMPORARY_EFFECT: 'temporaryEffect',
            THORNS: 'thorns',
            TAUNT: 'taunt',
            SHIELD_WALL: 'shieldWall',
            BUFF: 'buff',
            WHIRLWIND: 'whirlwind',

            // =============================================
            // NEW SPELL SUPPORT COMPONENT TYPES
            // =============================================
            
            // Formation and Squad
            FORMATION: 'formation',
            SQUAD_MEMBER: 'squadMember',
            
            // Ability Resources
            ABILITY_COOLDOWNS: 'abilityCooldowns',
            RESOURCE_POOL: 'resourcePool',
            
            // Visual Effects
            VISUAL_EFFECT: 'visualEffect',
            AURA: 'aura',
            MINING_STATE: 'miningState',
            BUILDING_STATE: 'buildingState',
            // AI and Targeting
            TARGETING_PREFERENCE: 'targetingPreference',
            THREAT: 'threat',
            
            // Special States
            CHARGING: 'charging',
            CHANNELING: 'channeling',
            STEALTHED: 'stealthed',
            
            // Environmental
            ENVIRONMENTAL_HAZARD: 'environmentalHazard',
            CONSECRATED: 'consecrated'
        };
    }
};

// Manager: EventManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['EventManager'] = class EventManager {
    constructor(app) {
        this.game = app;
        this.game.eventManager = this;
        this.events = {};
        this.reset();
    }

    on(event, callback) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        this.events[event].push(callback);
    }

    emit(event, ...args) {
        if (this.events[event]) {
            this.events[event].forEach(callback => callback(...args));
        }
    }

    off(event, callback) {
        if (this.events[event]) {
            this.events[event] = this.events[event].filter(cb => cb !== callback);
        }
    }

    
    reset() {
        this.currentScreen = 'mainMenu';
        this.selectedGameMode = null;
        this.gameStartTime = null;
        this.isPaused = false;
        this.stats = {
            round: 1,
            goldEarned: 0,
            unitsDeployed: 0,
            unitsLost: 0,
            totalPlayTime: 0
        };
        this.emit('stateChanged', this);
    }

    setScreen(screenId) {
        const previousScreen = this.currentScreen;
        this.currentScreen = screenId;
        this.emit('screenChanged', screenId, previousScreen);
    }

    setGameMode(mode) {
        this.selectedGameMode = mode;
        this.emit('gameModeChanged', mode);
    }

    startGame() {
        this.gameStartTime = Date.now();
        this.emit('gameStarted');
    }

    endGame(result, finalStats = {}) {
        if (this.gameStartTime) {
            this.stats.totalPlayTime = Date.now() - this.gameStartTime;
        }
        Object.assign(this.stats, finalStats);
        this.emit('gameEnded', result, this.stats);
    }

    updateStats(newStats) {
        Object.assign(this.stats, newStats);
        this.emit('statsUpdated', this.stats);
    }

    pause() {
        this.isPaused = true;
        this.emit('gamePaused');
    }

    resume() {
        this.isPaused = false;
        this.emit('gameResumed');
    }
};

// Manager: GameManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['GameManager'] = class GameManager {
    constructor(app) {
        this.game = app;
        this.game.gameManager = this;
        this.gameInstance = null;
    }

    startSelectedMode() {
        if (!this.game.eventManager.selectedGameMode) {
            alert('Please select a game mode first!');
            return;
        }

        this.game.screenManager.showLoadingScreen();
        
        // Update loading content based on selected mode
        const mode = this.game.gameModeManager.getSelectedMode();
        if (mode) {
            const loadingTip = document.querySelector('.loading-tip');
            if (loadingTip) {
                loadingTip.textContent = `Mode: ${mode.title} - ${mode.description}`;
            }
        }
        
        // Start loading process
        this.game.loadingManager.showLoadingWithProgress(() => {
            this.initializeGame();
        });
    }

    initializeGame() {
        this.game.eventManager.startGame();
        this.game.screenManager.showGameScreen();
        
        // Apply game mode configuration
        const mode = this.game.gameModeManager.getSelectedMode();
        if (mode && this.gameInstance) {
            this.applyModeConfiguration(mode);
        }
        this.game.state.isPaused = false;
        this.game.uiSystem.start();
    }

    applyModeConfiguration(mode) {
        if (this.gameInstance && this.gameInstance.state) {
            this.gameInstance.state.playerGold = mode.startingGold;
            console.log('set player gold 2', this.gameInstance.state.playerGold);
            this.gameInstance.state.gameMode = mode.id;
            this.gameInstance.state.maxRounds = mode.maxRounds;
            this.gameInstance.state.goldMultiplier = mode.goldMultiplier;
        }
    }

    pauseGame() {
        this.game.eventManager.pause();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'flex';
        }
    }

    resumeGame() {
        this.game.eventManager.resume();
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    restartGame() {
        const confirmRestart = this.game.eventManager.currentScreen === 'gameScreen' 
            ? confirm('Are you sure you want to restart? Your current progress will be lost.')
            : true;

        if (confirmRestart) {
            this.game.eventManager.reset();
            this.game.eventManager.setGameMode(this.game.eventManager.selectedGameMode); // Restore selected mode
            this.initializeGame();
        }
        
        // Hide pause menu if open
        const pauseMenu = document.getElementById('pauseMenu');
        if (pauseMenu) {
            pauseMenu.style.display = 'none';
        }
    }

    exitToMenu() {
        if (confirm('Are you sure you want to exit to the main menu? Your progress will be lost.')) {
            this.game.phaseSystem.reset();
            this.game.screenManager.showMainMenu();
            this.game.eventManager.reset();
        }
    }

    continueGame() {
        // Continue to next round/level
        this.game.eventManager.stats.round++;
        this.initializeGame();
    }



}
;

// Manager: GameModeManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['GameModeManager'] = class GameModeManager {
    constructor(app) {
        this.game = app;
        this.game.gameModeManager = this;        
        this.modes = this.initializeGameModes();
        this.setupUI();
    }

    initializeGameModes() {
        return {
            arena: {
                id: 'arena',
                title: 'Arena',
                icon: '⚔️',
                interfaceId: 'createOrJoinRoom',
                description: 'Battle against another player in real-time strategic combat',
                difficulty: 'Player vs Player',
                difficultyClass: 'pvp',
                isMultiplayer: true,
                maxPlayers: 2,
                startingGold: 100,
                onStart: (mode) => {
                    this.game.uiSystem.handleMultiplayerModeSelection(mode);
                }
            }
            // ,
            // campaign: {
            //     id: 'campaign',
            //     title: 'Campaign',
            //     icon: '🏆',
            //     description: 'Progress through increasingly difficult battles and unlock new units',
            //     startingGold: 100
            // },
            // survival: {
            //     id: 'survival',
            //     title: 'Survival',
            //     icon: '⚡',
            //     description: 'See how many waves you can survive with limited resources',
            //     startingGold: 150
            // },
            // arena: {
            //     id: 'arena',
            //     title: 'Arena',
            //     icon: '⚔️',
            //     description: 'Quick battles with balanced armies for testing strategies',
            //     startingGold: 200
            // },
            // challenge: {
            //     id: 'challenge',
            //     title: 'Challenge',
            //     icon: '💀',
            //     description: 'Face pre-built enemy compositions with specific constraints',
            //     startingGold: 100
            // },
            // endless: {
            //     id: 'endless',
            //     title: 'Endless',
            //     icon: '♾️',
            //     description: 'Battle continues until defeat with exponentially scaling enemies',
            //     startingGold: 100
            // },
            // tournament: {
            //     id: 'tournament',
            //     title: 'Tournament',
            //     icon: '🏅',
            //     description: 'Bracket-style competition against AI opponents',
            //     startingGold: 120
            // }
        };
    }

    setupUI() {
        const modeGrid = document.getElementById('modeGrid');
        if (!modeGrid) return;

        modeGrid.innerHTML = '';
        
        Object.values(this.modes).forEach(mode => {
            const card = this.createModeCard(mode);
            modeGrid.appendChild(card);
        });
    }

    createModeCard(mode) {
        const card = document.createElement('div');
        card.className = 'mode-card';
        card.dataset.mode = mode.id;
        
        card.innerHTML = `
            <div class="mode-icon">${mode.icon}</div>
            <div class="mode-title">${mode.title}</div>
            <div class="mode-description">${mode.description}</div>
            <div class="mode-difficulty ${mode.difficultyClass}">${mode.difficulty}</div>
        `;

        card.addEventListener('click', () => this.selectMode(mode.id));
        
        return card;
    }

    selectMode(modeId) {
        // Remove previous selection
        document.querySelectorAll('.mode-card').forEach(card => {
            card.classList.remove('selected');
        });
        
        // Add selection to clicked card
        const selectedCard = document.querySelector(`[data-mode="${modeId}"]`);
        if (selectedCard) {
            selectedCard.classList.add('selected');
            this.game.eventManager.setGameMode(modeId);
            const modeConfig = this.getModeConfig(modeId);
            modeConfig.onStart(modeConfig);
        }
    }

    getSelectedMode() {
        return this.modes[this.game.eventManager.selectedGameMode];
    }

    getModeConfig(modeId) {
        return this.modes[modeId];
    }
};

// Manager: KeyboardManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['KeyboardManager'] = class KeyboardManager {
    constructor(app) {
        this.game = app;
        this.game.keyboardManager = this;
    }
};

// Manager: LoadingManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['LoadingManager'] = class LoadingManager {
    constructor(app) {
        this.game = app;
        this.game.loadingManager = this;
        this.loadingSteps = [
            'Initializing game engine...',
            'Loading unit data...',
            'Preparing battlefield...',
            'Setting up AI opponents...',
            'Ready to battle!'
        ];
    }

    showLoadingWithProgress(onComplete) {
        let currentStep = 0;
        const loadingText = document.querySelector('.loading-text');
        
        const progressInterval = setInterval(() => {
            if (currentStep < this.loadingSteps.length) {
                if (loadingText) {
                    loadingText.textContent = this.loadingSteps[currentStep];
                }
                currentStep++;
            } else {
                clearInterval(progressInterval);
                onComplete();
            }
        }, 400);
    }
};

// Manager: ResultsManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['ResultsManager'] = class ResultsManager {
    constructor(app) {
        this.game = app;
        this.game.resultsManager = this;                
    }

    showVictory(stats) {
        this.populateStats('victoryStats', stats, 'victory');
        this.game.screenManager.showVictoryScreen();
    }

    showDefeat(stats) {
        this.populateStats('defeatStats', stats, 'defeat');
        this.game.screenManager.showDefeatScreen();
    }

    populateStats(containerId, stats, type) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.innerHTML = '';

        const statItems = type === 'victory' 
            ? this.getVictoryStats(stats)
            : this.getDefeatStats(stats);

        statItems.forEach(item => {
            const card = this.createStatCard(item.label, item.value);
            container.appendChild(card);
        });
    }

    getVictoryStats(stats) {
        return [
            { label: 'Round Reached', value: stats.round || 1 },
            { label: 'Gold Earned', value: stats.goldEarned || 0 },
            { label: 'Units Deployed', value: stats.unitsDeployed || 0 },
            { label: 'Time Played', value: this.formatTime(stats.totalPlayTime || 0) }
        ];
    }

    getDefeatStats(stats) {
        return [
            { label: 'Final Round', value: stats.round || 1 },
            { label: 'Total Gold', value: stats.goldEarned || 0 },
            { label: 'Units Lost', value: stats.unitsLost || 0 },
            { label: 'Survival Time', value: this.formatTime(stats.totalPlayTime || 0) }
        ];
    }

    createStatCard(label, value) {
        const card = document.createElement('div');
        card.className = 'stat-card';
        card.innerHTML = `
            <div class="stat-label">${label}</div>
            <div class="stat-value">${value}</div>
        `;
        return card;
    }

    formatTime(milliseconds) {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
    }
};

// Manager: SaveManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['SaveManager'] = class SaveManager {
    constructor(app) {
        this.game = app;
        this.game.saveManager = this;
        this.setupAutoSave();
    }

    setupAutoSave() {
        // Auto-save every 30 seconds
        setInterval(() => {
            this.saveGameState();
        }, 30000);
    }

    saveGameState() {
     
    }

    loadGameState() {
        // In a real implementation, you might load from localStorage here
        // const saved = localStorage.getItem('autoBattleArena_save');
        // return saved ? JSON.parse(saved) : null;
        return null;
    }
}
;

// Manager: ScreenManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['ScreenManager'] = class ScreenManager {
    constructor(app) {
        this.game = app;
        this.game.screenManager = this;
        this.setupEventListeners();
    }

    setupEventListeners() {
        this.game.eventManager.on('screenChanged', (screenId) => {
            this.showScreen(screenId);
        });
    }

    showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(screen => {
            screen.classList.remove('active');
        });
        
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
            targetScreen.classList.add('active');
        }
    }

    showMainMenu() {
        this.game.eventManager.setScreen('mainMenu');
    }

    showGameModeSelect() {
        this.game.eventManager.setScreen('gameModeSelect');
        // Reset selection
        document.querySelectorAll('.mode-card').forEach(card => {
            card.classList.remove('selected');
        });
        this.game.eventManager.selectedGameMode = null;
    }

    showLoadingScreen() {
        this.game.eventManager.setScreen('loadingScreen');
    }

    showGameScreen() {
        this.game.eventManager.setScreen('gameScreen');
    }

    showVictoryScreen() {
        this.game.eventManager.setScreen('victoryScreen');
    }

    showDefeatScreen() {
        this.game.eventManager.setScreen('defeatScreen');
    }
};

// Manager: UnitCreationManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['UnitCreationManager'] = class UnitCreationManager {
    constructor(game) {
        this.game = game;
        this.game.unitCreationManager = this;
        this.SPEED_MODIFIER = 20;
        // Default component values for missing unit data
        this.defaults = {
            hp: 100,
            damage: 10,
            range: 30,
            speed: 40,
            attackSpeed: 1.0,
            size: 5,
            height: 50,
            armor: 0,
            fireResistance: 0,
            coldResistance: 0,
            lightningResistance: 0,
            element: 'physical',
            projectile: null,
            value: 50
        };
        
        // Equipment slot priorities for auto-equipping
        this.equipmentPriority = [
            'weapon',
            'armor',
            'helmet',
            'boots',
            'gloves',
            'accessory'
        ];
        
        // Team-specific configurations
        this.teamConfigs = {
            left: {
                initialFacing: 0,
                aiState: 'idle',
                colorTint: null
            },
            right: {
                initialFacing: Math.PI,
                aiState: 'idle',
                colorTint: 0xff4444
            }
        };
        
        // Component creation cache for performance
        this.componentCache = new Map();
        
        // Unit creation statistics
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Create a new unit entity with all required components
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier ('left' or 'right')
     * @returns {number} Entity ID
     */
    create(worldX, worldY, worldZ, targetPosition, placement, team) {
        const unitType = placement.unitType;
        try {
            const entity = this.game.createEntity(`${unitType.id}_${worldX}_${worldZ}_${team}_${this.game.state.round}`);
            console.log('created unit', unitType.id, team, entity);
            const teamConfig = this.teamConfigs[team];
            // Add core components
            this.addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig);
            
            // Add combat components
            this.addCombatComponents(entity, unitType);
            
            // Add AI and behavior components
            this.addBehaviorComponents(entity, targetPosition, unitType);
            
            // Add visual and interaction components
            this.addVisualComponents(entity, unitType, teamConfig);
            
            // Schedule equipment and abilities (async to avoid blocking)
            this.schedulePostCreationSetup(entity, unitType);
            
            // Update statistics
            this.updateCreationStats(unitType, team);
            return entity;
        } catch (error) {
            console.error('Failed to create unit:', error);
            throw new Error(`Unit creation failed: ${error.message}`);
        }
    }


    /**
     * Create multiple squads efficiently from placement data
     * @param {Array} placements - Array of placement data from client
     * @param {string} team - Team identifier
     * @param {string|null} playerId - Optional player ID
     * @returns {Array} Array of created squad placement data
     */
    createSquadFromPlacement(placement, team, playerId = null) {

        const gridPosition = placement.gridPosition;
        const targetPosition = placement.targetPosition;
        const unitType = placement.unitType;

        try {
            // Get squad configuration
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                console.log("invalid squad config");
                return false;
            }

            // Calculate unit positions within the squad
            const unitPositions = this.game.squadManager.calculateUnitPositions(
                gridPosition,
                unitType
            );

            // Calculate cells occupied by the squad
            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);

            // Generate unique placement ID
            const placementId = `squad_${team}_${gridPosition.x}_${gridPosition.z}`;
            const squadUnits = [];

            
            // Create individual units for the squad
            for (const pos of unitPositions) {
                const terrainHeight = this.getTerrainHeight(pos.x, pos.z);
                const unitY = terrainHeight !== null ? terrainHeight : 0;

                const entityId = this.create(pos.x, unitY, pos.z, targetPosition, placement, team);

                // Add playerId to the team component if provided
                if (playerId && this.game.componentManager) {
                    const ComponentTypes = this.game.componentManager.getComponentTypes();
                    const teamComponent = this.game.getComponent(entityId, ComponentTypes.TEAM);
                    if (teamComponent) {
                        teamComponent.playerId = playerId;
                    }
                }
                if(unitType.collection == 'buildings'){
                    this.game.placementSystem.saveBuilding(entityId, team, gridPosition, unitType)
                }
                squadUnits.push(entityId);
            }

            // Occupy grid cells
            this.game.gridSystem.occupyCells(cells, placementId);
            // Update squad creation statistics
            this.stats.squadsCreated++;

            // Initialize squad in experience system if available
            if (this.game.squadExperienceSystem) {
                this.game.squadExperienceSystem.initializeSquad(placementId, unitType, squadUnits, team);
            }

            // const squadInfo = this.game.squadManager.getSquadInfo(unitType);
         
            return {
                placementId: placementId,
                gridPosition: gridPosition,
                unitType: unitType,
                squadUnits: squadUnits,
                cells: cells,
                isSquad: squadUnits.length > 1,
                team: team,
                playerId: playerId,
                timestamp: Date.now()
            };

        } catch (error) {
            console.error('Squad creation failed:', error);
            throw new Error(`Squad creation failed: ${error.message}`);
        }
    
    }

    /**
     * Clean up squads by destroying their units and freeing grid cells
     * @param {Array} squads - Array of squad placement data
     */
    cleanupSquads(squads) {
        for (const squad of squads) {
            try {
                // Destroy squad units
                for (const unit of squad.squadUnits || []) {
                    if (this.game.destroyEntity && unit) {
                        this.game.destroyEntity(unit);
                    }
                }

                // Free grid cells
                if (this.game.gridSystem && squad.placementId) {
                    this.game.gridSystem.freeCells(squad.placementId);
                }

                // Remove from experience system
                if (this.game.squadExperienceSystem && squad.placementId) {
                    this.game.squadExperienceSystem.removeSquad(squad.placementId);
                }

            } catch (error) {
                console.warn(`Failed to cleanup squad ${squad.placementId}:`, error);
            }
        }
    }

    /**
     * Get squad information for a unit type
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad information
     */
    getSquadInfo(unitType) {
        if (this.game.squadManager) {
            return this.game.squadManager.getSquadInfo(unitType);
        }
        
        // Fallback squad info
        return {
            unitName: unitType.title || unitType.id || 'Unknown',
            squadSize: 1,
            formationType: 'single',
            spacing: 1
        };
    }

    /**
     * Validate if a squad can be placed at the given position
     * @param {Object} gridPosition - Grid position {x, z}
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @returns {boolean} True if placement is valid
     */
    canPlaceSquad(gridPosition, unitType, team) {
        if (!this.game.squadManager || !this.game.gridSystem) {
            return this.game.gridSystem ? 
                this.game.gridSystem.isValidPosition(gridPosition) : true;
        }

        try {
            const squadData = this.game.squadManager.getSquadData(unitType);
            const validation = this.game.squadManager.validateSquadConfig(squadData);
            
            if (!validation.valid) {
                return false;
            }

            const cells = this.game.squadManager.getSquadCells(gridPosition, squadData);
            return this.game.gridSystem.isValidPlacement(cells, team);
            
        } catch (error) {
            console.warn('Squad placement validation failed:', error);
            return false;
        }
    }
    
    /**
     * Add core position and identity components
     * @param {number} entity - Entity ID
     * @param {number} worldX - World X coordinate
     * @param {number} worldY - World Y coordinate
     * @param {number} worldZ - World Z coordinate
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     * @param {Object} teamConfig - Team configuration
     */
    addCoreComponents(entity, worldX, worldY, worldZ, placement, team, teamConfig) {
        const unitType = placement.unitType;
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Position component
        this.game.addComponent(entity, ComponentTypes.POSITION, 
            Components.Position(worldX, worldY, worldZ));
        
        // Velocity component with movement capabilities
        const maxSpeed = (unitType.speed) * this.SPEED_MODIFIER;
        this.game.addComponent(entity, ComponentTypes.VELOCITY, 
            Components.Velocity(0, 0, 0, maxSpeed, true, unitType.collection == 'buildings' ? true : false));
        
        // Team identification
        this.game.addComponent(entity, ComponentTypes.TEAM, 
            Components.Team(team));
        
        this.game.addComponent(entity, ComponentTypes.PLACEMENT, 
            Components.Placement(placement));
        
        // Unit type information
        this.game.addComponent(entity, ComponentTypes.UNIT_TYPE, 
            Components.UnitType(
                unitType
            ));
        
        // Facing direction
        this.game.addComponent(entity, ComponentTypes.FACING, 
            Components.Facing(teamConfig.initialFacing));
    }
    
    /**
     * Add combat-related components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    addCombatComponents(entity, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // Health component
        const maxHP = unitType.hp || this.defaults.hp;
        this.game.addComponent(entity, ComponentTypes.HEALTH, 
            Components.Health(maxHP));
        
        // Combat component with all combat stats
        this.game.addComponent(entity, ComponentTypes.COMBAT, 
            Components.Combat(
                unitType.damage,
                unitType.range,
                unitType.attackSpeed,
                unitType.projectile,
                0, // Initial attack cooldown
                unitType.element,
                unitType.armor,
                unitType.fireResistance,
                unitType.coldResistance,
                unitType.lightningResistance
            ));
        
        // Collision component for physical interactions
        this.game.addComponent(entity, ComponentTypes.COLLISION, 
            Components.Collision(unitType.size || this.defaults.size, unitType.height));
    }
    
    /**
     * Add AI and behavior components
     * @param {number} entity - Entity ID
     */
    addBehaviorComponents(entity, targetPosition, unitType) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        // AI state for behavior control
        this.game.addComponent(entity, ComponentTypes.AI_STATE, 
            Components.AIState('idle', targetPosition));
        
        console.log(this.game.getComponent(entity, ComponentTypes.AI_STATE));
        // Animation state
        this.game.addComponent(entity, ComponentTypes.ANIMATION, 
            Components.Animation());
        
        // Equipment container
        this.game.addComponent(entity, ComponentTypes.EQUIPMENT, 
            Components.Equipment());
    }
    
    /**
     * Add visual and rendering components
     * @param {number} entity - Entity ID
     * @param {Object} unitType - Unit type definition
     * @param {Object} teamConfig - Team configuration
     */
    addVisualComponents(entity, unitType, teamConfig) {
        const ComponentTypes = this.game.componentManager.getComponentTypes();
        const Components = this.game.componentManager.getComponents();
        
        // Renderable component for visual representation
        this.game.addComponent(entity, ComponentTypes.RENDERABLE, 
            Components.Renderable(unitType.collection, unitType.id || 'default'));
        
        // Add team-specific visual modifications
        if (teamConfig.colorTint && this.game.addComponent) {
            // Optional: Add color tint component if available
            try {
                if (ComponentTypes.COLOR_TINT) {
                    this.game.addComponent(entity, ComponentTypes.COLOR_TINT,
                        Components.ColorTint(teamConfig.colorTint));
                }
            } catch (error) {
                // Color tint not available, continue without it
            }
        }
    }
    
    /**
     * Schedule post-creation setup (equipment and abilities)
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    schedulePostCreationSetup(entityId, unitType) {

        this.setupEquipment(entityId, unitType);
        this.setupAbilities(entityId, unitType);
    }
    
    /**
     * Equip unit with items from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    async setupEquipment(entityId, unitType) {

        if (!this.game.equipmentSystem || !unitType?.render?.equipment) {
            return;
        }
        
        try {
            // Sort equipment by priority for better equipping order
            const equipmentList = [...unitType.render.equipment].sort((a, b) => {
                const priorityA = this.equipmentPriority.indexOf(a.slot) || 999;
                const priorityB = this.equipmentPriority.indexOf(b.slot) || 999;
                return priorityA - priorityB;
            });
            
            // Equip each item
            for (const equippedItem of equipmentList) {
                const itemData = this.getItemFromCollection(equippedItem.item);
                if (itemData) {
                    try {
                        await this.game.equipmentSystem.equipItem(
                            entityId, 
                            equippedItem, 
                            itemData, 
                            equippedItem.item
                        );
                    } catch (equipError) {
                        console.warn(`Failed to equip ${equippedItem.item} on slot ${equippedItem.slot}:`, equipError);
                        this.stats.equipmentFailures++;
                    }
                } else {
                    console.warn(`Item ${equippedItem.item} not found in collections`);
                    this.stats.equipmentFailures++;
                }
            }
        } catch (error) {
            console.error(`Equipment setup failed for entity ${entityId}:`, error);
            this.stats.equipmentFailures++;
        }
    }
    
    /**
     * Add abilities to unit from unit definition
     * @param {number} entityId - Entity ID
     * @param {Object} unitType - Unit type definition
     */
    setupAbilities(entityId, unitType) {
        if (!this.game.abilitySystem || !unitType?.abilities) {
            return;
        }
        
        try {
            // Validate abilities exist before adding
            const validAbilities = unitType.abilities.filter(abilityId => {
                const abilityData = this.getAbilityFromCollection(abilityId);
                if (!abilityData) {
                    console.warn(`Ability ${abilityId} not found in collections`);
                    this.stats.abilityFailures++;
                    return false;
                }
                return true;
            });
            
            if (validAbilities.length > 0) {
                this.game.abilitySystem.addAbilitiesToUnit(entityId, validAbilities);
            }
        } catch (error) {
            console.error(`Ability setup failed for entity ${entityId}:`, error);
            this.stats.abilityFailures++;
        }
    }
    
    /**
     * Get item data from game collections
     * @param {string} itemId - Item identifier
     * @returns {Object|null} Item data or null if not found
     */
    getItemFromCollection(itemId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.items?.[itemId]) {
                return null;
            }
            return collections.items[itemId];
        } catch (error) {
            console.warn(`Error accessing item collection for ${itemId}:`, error);
            return null;
        }
    }
    
    /**
     * Get ability data from game collections
     * @param {string} abilityId - Ability identifier
     * @returns {Object|null} Ability data or null if not found
     */
    getAbilityFromCollection(abilityId) {
        try {
            const collections = this.game.getCollections();
            if (!collections?.abilities?.[abilityId]) {
                return null;
            }
            return collections.abilities[abilityId];
        } catch (error) {
            console.warn(`Error accessing ability collection for ${abilityId}:`, error);
            return null;
        }
    }
    
    /**
     * Get terrain height at world position
     * @param {number} worldX - World X coordinate
     * @param {number} worldZ - World Z coordinate
     * @returns {number} Terrain height
     */
    getTerrainHeight(worldX, worldZ) {
        try {
            if (this.game.terrainSystem?.getTerrainHeightAtPosition) {
                return this.game.terrainSystem.getTerrainHeightAtPosition(worldX, worldZ);
            }
        } catch (error) {
            console.warn(`Error getting terrain height at (${worldX}, ${worldZ}):`, error);
        }
        return 0; // Default to ground level
    }
    
    
    /**
     * Update creation statistics
     * @param {Object} unitType - Unit type definition
     * @param {string} team - Team identifier
     */
    updateCreationStats(unitType, team) {
        this.stats.totalCreated++;
        
        // Track by team
        const teamCount = this.stats.createdByTeam.get(team) || 0;
        this.stats.createdByTeam.set(team, teamCount + 1);
        
        // Track by unit type
        const unitTypeId = unitType.id || 'unknown';
        const typeCount = this.stats.createdByType.get(unitTypeId) || 0;
        this.stats.createdByType.set(unitTypeId, typeCount + 1);
    }
    
    /**
     * Get creation statistics
     * @returns {Object} Statistics summary
     */
    getStats() {
        return {
            totalCreated: this.stats.totalCreated,
            createdByTeam: Object.fromEntries(this.stats.createdByTeam),
            createdByType: Object.fromEntries(this.stats.createdByType),
            equipmentFailures: this.stats.equipmentFailures,
            abilityFailures: this.stats.abilityFailures,
            squadsCreated: this.stats.squadsCreated,
            successRate: {
                equipment: 1 - (this.stats.equipmentFailures / Math.max(1, this.stats.totalCreated)),
                abilities: 1 - (this.stats.abilityFailures / Math.max(1, this.stats.totalCreated))
            }
        };
    }
    
    /**
     * Reset creation statistics
     */
    resetStats() {
        this.stats = {
            totalCreated: 0,
            createdByTeam: new Map(),
            createdByType: new Map(),
            equipmentFailures: 0,
            abilityFailures: 0,
            squadsCreated: 0
        };
    }
    
    /**
     * Validate unit type definition
     * @param {Object} unitType - Unit type to validate
     * @returns {Object} Validation result
     */
    validateUnitType(unitType) {
        const errors = [];
        const warnings = [];
        
        if (!unitType) {
            errors.push('Unit type is required');
            return { valid: false, errors, warnings };
        }
        
        // Check required fields
        if (!unitType.id) warnings.push('Unit ID missing, using default');
        if (!unitType.title) warnings.push('Unit title missing, using ID or default');
        
        // Validate numeric stats
        const numericFields = ['hp', 'damage', 'range', 'speed', 'armor', 'value'];
        numericFields.forEach(field => {
            if (unitType[field] !== undefined && (isNaN(unitType[field]) || unitType[field] < 0)) {
                errors.push(`${field} must be a non-negative number`);
            }
        });
        
        // Check equipment references
        if (unitType.render?.equipment) {
            unitType.render.equipment.forEach((item, index) => {
                if (!item.item) {
                    warnings.push(`Equipment item ${index} missing item ID`);
                }
                if (!item.slot) {
                    warnings.push(`Equipment item ${index} missing slot`);
                }
            });
        }
        
        // Check ability references
        if (unitType.abilities && !Array.isArray(unitType.abilities)) {
            errors.push('Abilities must be an array');
        }
        
        return {
            valid: errors.length === 0,
            errors,
            warnings
        };
    }
    
    /**
     * Clean up resources and cache
     */
    dispose() {
        this.componentCache.clear();
        this.resetStats();
    }
};

// Manager: SquadManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['SquadManager'] = class SquadManager {
    constructor(app) {
        this.game = app;
        this.game.squadManager = this;
        this.ELEMENT_TYPES = {
            PHYSICAL: 'physical',
            FIRE: 'fire',
            COLD: 'cold',
            LIGHTNING: 'lightning',
            POISON: 'poison',
            DIVINE: 'divine'
        };
        
        this.DEFAULT_SQUAD_CONFIG = {
            squadWidth: 1,
            squadHeight: 1,
            placementGridWidth: 1,
            placementGridHeight: 1
        };
    }
    
    /**
     * Extract squad configuration from unit type definition
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Squad configuration with dimensions
     */
    getSquadData(unitType) {
        return {
            squadWidth: unitType.squadWidth || this.DEFAULT_SQUAD_CONFIG.squadWidth,
            squadHeight: unitType.squadHeight || this.DEFAULT_SQUAD_CONFIG.squadHeight,
            placementGridWidth: unitType.placementGridWidth || this.DEFAULT_SQUAD_CONFIG.placementGridWidth,
            placementGridHeight: unitType.placementGridHeight || this.DEFAULT_SQUAD_CONFIG.placementGridHeight
        };
    }
    
    /**
     * Calculate which grid cells a squad would occupy
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @returns {Array} Array of cell positions {x, z}
     */
    getSquadCells(gridPos, squadData) {
        const cells = [];
        const { placementGridWidth, placementGridHeight } = squadData;
        
        // Calculate starting position to center the formation
        const startX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startZ = gridPos.z - Math.floor(placementGridHeight / 2);
        
        for (let x = 0; x < placementGridWidth; x++) {
            for (let z = 0; z < placementGridHeight; z++) {
                cells.push({
                    x: startX + x,
                    z: startZ + z
                });
            }
        }
        
        return cells;
    }
        
    /**
     * Calculate world positions for individual units within a squad formation
     * @param {Object} gridPos - Center grid position {x, z}
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance for coordinate conversion
     * @returns {Array} Array of world positions {x, z}
     */
    calculateUnitPositions(gridPos, unitType) {
        const squadData = this.getSquadData(unitType);
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        const positions = [];
        const cellSize = this.game.gridSystem.dimensions.cellSize;

        // Compute the top-left (min) cell of the formation footprint
        const startCellX = gridPos.x - Math.floor(placementGridWidth / 2);
        const startCellZ = gridPos.z - Math.floor(placementGridHeight / 2);

        // Compute the true geometric center of the whole footprint, even for even sizes
        // Example: width=2 -> center at (start + 0.5); width=3 -> center at (start + 1)
        const centerCellX = startCellX + (placementGridWidth - 1) / 2;
        const centerCellZ = startCellZ + (placementGridHeight - 1) / 2;
        const centerWorldPos = this.game.gridSystem.gridToWorld(centerCellX, centerCellZ);

        // If squad footprint matches placement footprint, snap each unit to its cell center.
        if (squadWidth === placementGridWidth && squadHeight === placementGridHeight) {
            for (let row = 0; row < squadHeight; row++) {
                for (let col = 0; col < squadWidth; col++) {
                    const cellX = startCellX + col;
                    const cellZ = startCellZ + row;
                    const wp = this.game.gridSystem.gridToWorld(cellX, cellZ);
                    positions.push({ x: wp.x, z: wp.z });
                }
            }
            return positions;
        }

        // General case: distribute units evenly across the footprint bounds
        const formationWorldWidth  = placementGridWidth  * cellSize;
        const formationWorldHeight = placementGridHeight * cellSize;

        // Single unit: drop on the geometric center of the footprint
        if (squadWidth === 1 && squadHeight === 1) {
            positions.push({ x: centerWorldPos.x, z: centerWorldPos.z });
            return positions;
        }

        // Start from the top-left point of the unit grid *inside* the formation bounds
        const stepX = formationWorldWidth  / Math.max(1, squadWidth);
        const stepZ = formationWorldHeight / Math.max(1, squadHeight);

        const startX = centerWorldPos.x - (formationWorldWidth / 2) + (stepX / 2);
        const startZ = centerWorldPos.z - (formationWorldHeight / 2) + (stepZ / 2);

        console.log(stepX, formationWorldWidth, squadWidth, centerWorldPos, formationWorldWidth, stepX);

        for (let row = 0; row < squadHeight; row++) {
            for (let col = 0; col < squadWidth; col++) {
                const x = startX + col * stepX;
                const z = startZ + row * stepZ;
                positions.push({ x, z });
            }
        }

        return positions;
    }

    /**
     * Check if a squad can fit within given zone bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries {minX, maxX, minZ, maxZ}
     * @returns {boolean} True if squad can fit
     */
    canFitInZone(squadData, bounds) {
        const zoneWidth = bounds.maxX - bounds.minX + 1;
        const zoneHeight = bounds.maxZ - bounds.minZ + 1;
        
        return squadData.placementGridWidth <= zoneWidth && 
               squadData.placementGridHeight <= zoneHeight;
    }
    
    /**
     * Calculate the total number of units in a squad
     * @param {Object} squadData - Squad configuration
     * @returns {number} Total unit count
     */
    getSquadSize(squadData) {
        return squadData.squadWidth * squadData.squadHeight;
    }
    
    /**
     * Get formation type based on squad dimensions
     * @param {Object} squadData - Squad configuration
     * @returns {string} Formation type description
     */
    getFormationType(squadData) {
        const { squadWidth, squadHeight } = squadData;
        
        if (squadWidth === 1 && squadHeight === 1) {
            return 'single';
        } else if (squadWidth === 1) {
            return 'column';
        } else if (squadHeight === 1) {
            return 'line';
        } else if (squadWidth === squadHeight) {
            return 'square';
        } else {
            return 'rectangle';
        }
    }
    
    /**
     * Calculate formation density (units per grid cell)
     * @param {Object} squadData - Squad configuration
     * @returns {number} Units per grid cell ratio
     */
    getFormationDensity(squadData) {
        const totalUnits = this.getSquadSize(squadData);
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        return totalUnits / gridCells;
    }
    
    /**
     * Get optimal spacing between units in world coordinates
     * @param {Object} squadData - Squad configuration
     * @param {Object} gridSystem - GridSystem instance
     * @returns {Object} Spacing values {x, z}
     */
    getUnitSpacing(squadData, gridSystem) {
        const { squadWidth, squadHeight, placementGridWidth, placementGridHeight } = squadData;
        
        const formationWorldWidth = placementGridWidth * gridSystem.dimensions.cellSize;
        const formationWorldHeight = placementGridHeight * gridSystem.dimensions.cellSize;
        
        return {
            x: squadWidth > 1 ? formationWorldWidth / squadWidth : 0,
            z: squadHeight > 1 ? formationWorldHeight / squadHeight : 0
        };
    }
    
    /**
     * Validate squad configuration
     * @param {Object} squadData - Squad configuration to validate
     * @returns {Object} Validation result {valid, errors}
     */
    validateSquadConfig(squadData) {
        const errors = [];
        
        if (!squadData) {
            errors.push('Squad data is required');
            return { valid: false, errors };
        }
        
        const requiredFields = ['squadWidth', 'squadHeight', 'placementGridWidth', 'placementGridHeight'];
        for (const field of requiredFields) {
            if (typeof squadData[field] !== 'number' || squadData[field] < 1) {
                errors.push(`${field} must be a positive number`);
            }
        }
        
        // Logical validations
        if (squadData.squadWidth > squadData.placementGridWidth * 10) {
            errors.push('Squad width seems unreasonably large for grid size');
        }
        
        if (squadData.squadHeight > squadData.placementGridHeight * 10) {
            errors.push('Squad height seems unreasonably large for grid size');
        }
        
        // Check if formation makes sense
        const totalUnits = squadData.squadWidth * squadData.squadHeight;
        const gridCells = squadData.placementGridWidth * squadData.placementGridHeight;
        
        if (totalUnits > gridCells * 4) {
            errors.push('Too many units for the allocated grid space');
        }
        
        return {
            valid: errors.length === 0,
            errors
        };
    }
    
    /**
     * Generate squad info for display purposes
     * @param {Object} unitType - Unit type definition
     * @returns {Object} Formatted squad information
     */
    getSquadInfo(unitType) {
        const squadData = this.getSquadData(unitType);
        const validation = this.validateSquadConfig(squadData);
        
        return {
            unitName: unitType.title || unitType.id || 'Unknown Unit',
            squadSize: this.getSquadSize(squadData),
            formationType: this.getFormationType(squadData),
            density: this.getFormationDensity(squadData),
            gridFootprint: `${squadData.placementGridWidth}x${squadData.placementGridHeight}`,
            unitFormation: `${squadData.squadWidth}x${squadData.squadHeight}`,
            isValid: validation.valid,
            errors: validation.errors,
            cost: unitType.value || 0,
            totalValue: (unitType.value || 0) * this.getSquadSize(squadData)
        };
    }
    
    /**
     * Check if two squads would overlap
     * @param {Object} pos1 - First squad position
     * @param {Object} squad1 - First squad data
     * @param {Object} pos2 - Second squad position  
     * @param {Object} squad2 - Second squad data
     * @returns {boolean} True if squads overlap
     */
    wouldSquadsOverlap(pos1, squad1, pos2, squad2) {
        const cells1 = this.getSquadCells(pos1, squad1);
        const cells2 = this.getSquadCells(pos2, squad2);
        
        for (const cell1 of cells1) {
            for (const cell2 of cells2) {
                if (cell1.x === cell2.x && cell1.z === cell2.z) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Find all valid positions for a squad within bounds
     * @param {Object} squadData - Squad configuration
     * @param {Object} bounds - Zone boundaries
     * @param {Set} occupiedCells - Set of occupied cell keys "x,z"
     * @returns {Array} Array of valid grid positions
     */
    findValidPositions(squadData, bounds, occupiedCells = new Set()) {
        const validPositions = [];
        
        // Check each possible center position
        for (let x = bounds.minX; x <= bounds.maxX; x++) {
            for (let z = bounds.minZ; z <= bounds.maxZ; z++) {
                const gridPos = { x, z };
                const cells = this.getSquadCells(gridPos, squadData);
                
                // Check if all cells are within bounds and unoccupied
                const isValid = cells.every(cell => {
                    if (cell.x < bounds.minX || cell.x > bounds.maxX ||
                        cell.z < bounds.minZ || cell.z > bounds.maxZ) {
                        return false;
                    }
                    
                    const key = `${cell.x},${cell.z}`;
                    return !occupiedCells.has(key);
                });
                
                if (isValid) {
                    validPositions.push(gridPos);
                }
            }
        }
        
        return validPositions;
    }
};

// Manager: MultiplayerNetworkManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['MultiplayerNetworkManager'] = class MultiplayerNetworkManager {
    constructor(game) {
        this.game = game;
        this.game.networkManager = this;
        
        // State tracking
        this.roomId = null;
        this.isHost = false;
        this.gameState = null;
        // Store unsubscribe functions
        this.networkUnsubscribers = [];
    }

    // GUTS Manager Interface
    init(params) {
        this.params = params || {};
        this.connectToServer();        
        this.setupNetworkListeners();
    }

    async connectToServer() {
        try {
            await this.game.clientNetworkManager.connect();
            
            // Call server to get player ID
            this.game.clientNetworkManager.call(
                'CONNECT',
                null,
                'CONNECTED',
                (data, error) => {
                    if (error) {
                        console.error('Failed to get player ID:', error);
                        this.game.uiSystem.showNotification('Failed to get player ID from server', 'error');
                    } else if (data && data.playerId) {
                        this.game.clientNetworkManager.playerId = data.playerId;
                        this.game.state.playerId = data.playerId;
                    } else {
                        console.error('Server response missing player ID:', data);
                        this.game.uiSystem.showNotification('Server did not provide player ID', 'error');
                    }
                }
            );
            
        } catch (error) {
            console.error('Failed to connect to server:', error);
            this.game.uiSystem.showNotification('Failed to connect to server', 'error');
        }
    }

    setupNetworkListeners() {
        const nm = this.game.clientNetworkManager;
        if (!nm) {
            console.error('ClientNetworkManager not available');
            return;
        }

        // Listen to events that update the UI
        this.networkUnsubscribers.push(
            nm.listen('PLAYER_JOINED', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerJoined(data);
            }),

            nm.listen('PLAYER_LEFT', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerLeft(data);
            }),

            nm.listen('PLAYER_READY_UPDATE', (data) => {
                this.syncWithServerState(data);   
                this.handlePlayerReadyUpdate(data);
            }),

            nm.listen('GAME_STARTED', (data) => {
                this.syncWithServerState(data);   
                this.handleGameStarted(data);
            }),
            nm.listen('OPPONENT_SQUAD_TARGET_SET', (data) => {
                this.syncWithServerState(data);   
                this.handleOpponentSquadTarget(data);
            }),
            nm.listen('OPPONENT_SQUAD_TARGETS_SET', (data) => {
                this.syncWithServerState(data);   
                this.handleOpponentSquadTargets(data);
            }),
            nm.listen('READY_FOR_BATTLE_UPDATE', (data) => {
                this.syncWithServerState(data);   
                this.handleReadyForBattleUpdate(data);
            }),

            nm.listen('BATTLE_END', (data) => {
                this.syncWithServerState(data);   
                this.handleBattleEnd(data);
            }),

            nm.listen('GAME_END', (data) => {
                this.syncWithServerState(data);        
                this.handleGameEnd(data);
            })
        );
    }

    createRoom(playerName, maxPlayers = 2) {
        this.game.uiSystem.showNotification('Creating room...', 'info');
        
        this.game.clientNetworkManager.call(
            'CREATE_ROOM',
            { playerName, maxPlayers },
            'ROOM_CREATED',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Failed to create room: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Room created! Code: ${this.roomId}`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    joinRoom(roomId, playerName) {
        this.game.uiSystem.showNotification('Joining room...', 'info');
        
        this.game.clientNetworkManager.call(
            'JOIN_ROOM',
            { roomId, playerName },
            'ROOM_JOINED',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Failed to join room: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Joined room ${this.roomId}`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    startQuickMatch(playerName) {
        this.game.uiSystem.showNotification('Finding opponent...', 'info');
        
        this.game.clientNetworkManager.call(
            'QUICK_MATCH',
            { playerName },
            'QUICK_MATCH_FOUND',
            (data, error) => {
                if (error) {
                    this.game.uiSystem.showNotification(`Quick match failed: ${error.message}`, 'error');
                } else {
                    this.roomId = data.roomId;
                    this.isHost = data.isHost;
                    this.gameState = data.gameState;
                    this.game.uiSystem.showNotification(`Match found! Entering room...`, 'success');
                    this.game.uiSystem.showLobby(data.gameState, this.roomId);
                }
            }
        );
    }

    getStartingState(callback){
        this.game.clientNetworkManager.call(
            'GET_STARTING_STATE',
            {},
            'GOT_STARTING_STATE',
            (data, error) => {           
                if (data.error) {
                    console.log('getStartingState error:', data.error);
                    callback(false, error);
                } else {
                    console.log('getStartingState response:', data);
                    callback(true, data);
                }
            }
        );
    }

    submitPlacement(placement, callback){
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SUBMIT_PLACEMENT',
            { placement },
            'SUBMITTED_PLACEMENT',
            (data, error) => {           
                if (data.error) {
                    console.log('Placement error:', data.error);
                    callback(false, error);
                } else {
                    console.log('Placement response:', data);
                    callback(true, data);
                }
            }
        );
    }

    purchaseUpgrade(data, callback){
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'PURCHASE_UPGRADE',
            { data },
            'PURCHASED_UPGRADE',
            (data, error) => {           
                if (data.error) {
                    console.log('Purchase error:', data.error);
                    callback(false, error);
                } else {
                    console.log('Purchase response:', data);
                    callback(true, data);
                }
            }
        );
    }

    setSquadTarget(data, callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SET_SQUAD_TARGET',
            data,
            'SQUAD_TARGET_SET',
            (data, error) => {
                if (error || data.error) {
                    console.log('Set target error:', error || data.error);
                    callback(false, error || data.error);
                } else {
                    console.log('Set target response:', data);
                    callback(true, data);
                }
            }
        );
    }

    setSquadTargets(data, callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'SET_SQUAD_TARGETS',
            data,
            'SQUAD_TARGETS_SET',
            (data, error) => {
                if (error || data.error) {
                    console.log('Set target error:', error || data.error);
                    callback(false, error || data.error);
                } else {
                    console.log('Set target response:', data);
                    callback(true, data);
                }
            }
        );
    }

    toggleReadyForBattle(callback) {
        if(this.game.state.phase != "placement") {
            callback(false, 'Not in placement phase.');
        };
        this.game.clientNetworkManager.call(
            'READY_FOR_BATTLE',
            {},
            'READY_FOR_BATTLE_RESPONSE',
            (data, error) => {                                
                if (data.error) {
                    console.log('Battle ready state error:', data.error);
                    callback(false, data.error);
                } else {
                    console.log('Battle ready state updated:', data);
                    callback(true, data);
                }
            }
        );
    }

    toggleReady() {
        this.game.clientNetworkManager.call('TOGGLE_READY');
    }

    startGame() {
        if (!this.isHost) return;
        this.game.clientNetworkManager.call('START_GAME');
    }

    leaveRoom() {
        this.game.clientNetworkManager.call('LEAVE_ROOM');
    }

    handlePlayerJoined(data){

        this.game.uiSystem.showNotification(`${data.playerName} joined the room`, 'info');
        this.game.uiSystem.updateLobby(data.gameState);
    }

    handlePlayerLeft(data){

        this.game.uiSystem.showNotification('Player left the room', 'warning');
        this.game.uiSystem.updateLobby(data.gameState);
    }

    handlePlayerReadyUpdate(data){

        this.game.uiSystem.updateLobby(data.gameState);
        
        // Show notification for ready state changes
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.playerId === myPlayerId) {
            if(!data.ready){
                console.log("not ready", data);
            }
            this.game.uiSystem.showNotification(
                data.ready ? 'You are ready!' : 'Ready status removed',
                data.ready ? 'success' : 'info'
            );
        }
        
        if (data.allReady) {
            this.game.uiSystem.showNotification('All players ready! Game starting...', 'success');
        }
    }

    handleGameStarted(data){
        this.game.triggerEvent('onGameStarted', data);
    }

    handleReadyForBattleUpdate(data) {
        this.game.placementSystem.handleReadyForBattleUpdate(data);
    }

    handleBattleEnd(data) {
        
        if (data.entitySync) {
            this.resyncEntities(data.entitySync);
        }
        this.game.triggerEvent('onBattleEnd');        
        console.log('battle result', data);
        this.game.desyncDebugger.displaySync(true); 
        this.game.desyncDebugger.enabled = false;
        const myPlayerId = this.game.clientNetworkManager.playerId;
        data.gameState?.players?.forEach((player) => {
            if(player.id == myPlayerId) {
                this.game.state.playerGold = player.stats.gold;
            }
        })
        this.game.state.round += 1;
        // Transition back to placement phase
        this.game.state.phase = 'placement';
        this.game.triggerEvent('onPlacementPhaseStart');   
    }

    resyncEntities(entitySync) {

        for (const [entityId, components] of Object.entries(entitySync)) {
        
            
            for (const [componentType, componentData] of Object.entries(components)) {
                if (this.game.hasComponent(entityId, componentType)) {
                    const existing = this.game.getComponent(entityId, componentType);
                    Object.assign(existing, componentData);
                } 
            }
        }
        
    }

    handleGameEnd(data) {
        const myPlayerId = this.game.clientNetworkManager.playerId;
        if (data.result.winner === myPlayerId) {
            this.game.uiSystem.showNotification('GAME WON! Congratulations!', 'success');
        } else {
            this.game.uiSystem.showNotification('Game lost. Better luck next time!', 'warning');
        }
    }
 
    handleRoundResult(roundResult) {
        const state = this.game.state;
        state.phase = 'ended';      
    }

    handleOpponentSquadTarget(data) {
        const { placementId, targetPosition } = data;
        this.game.unitOrderSystem.applySquadTargetPosition(placementId, targetPosition);        
    }

    handleOpponentSquadTargets(data) {
        const { placementIds, targetPositions } = data;
        this.game.unitOrderSystem.applySquadsTargetPositions(placementIds, targetPositions);        
    }

    syncWithServerState(data) {
        if(!data.gameState) return;
        const gameState = data.gameState;
        if (!gameState.players) return;
        console.log('sync with server', gameState);
        const myPlayerId = this.game.clientNetworkManager.playerId;
        const myPlayer = gameState.players.find(p => p.id === myPlayerId);
        
        if (myPlayer) {
            // Sync squad count and side
            if (this.game.state) {
                this.game.state.mySide = myPlayer.stats.side;
                this.game.state.playerGold = myPlayer.stats.gold;
                this.game.state.playerHealth = myPlayer.stats.health;
                this.game.state.round = gameState.round;
                this.game.state.serverGameState = gameState;
            }
            
            // Set team sides in grid system
            const opponent = gameState.players.find(p => p.id !== myPlayerId);
            if (opponent && this.game.gridSystem) {
                this.game.gridSystem.setTeamSides({
                    player: myPlayer.stats.side,
                    enemy: opponent.stats.side
                });
            }
            
            // Also set sides in placement system
            if (this.game.placementSystem ) {
                if(this.game.placementSystem.setTeamSides) {
                
                    this.game.placementSystem.setTeamSides({
                        player: myPlayer.stats.side,
                        enemy: opponent.stats.side
                    });
                }

                this.game.placementSystem.setPlacementExperience(myPlayer.placements);
            }

                
            // Update UI to reflect synced experience data
            if (this.game.shopSystem && this.game.shopSystem.updateGoldDisplay) {
                this.game.shopSystem.updateGoldDisplay();
                this.game.shopSystem.createShop(); // Refresh experience panels
            }
            
        }
    }
 
    dispose() {
        this.networkUnsubscribers.forEach(unsubscribe => {
            if (typeof unsubscribe === 'function') {
                unsubscribe();
            }
        });
        this.networkUnsubscribers = [];
        
    }

         
};

// Manager: InputManager
window.COMPILED_GAME.classRegistry.managers = window.COMPILED_GAME.classRegistry.managers || {};
window.COMPILED_GAME.classRegistry.managers['InputManager'] = class InputManager {
    constructor(app) {
        this.game = app;
        this.game.inputManager = this;
        this.keyStates = {};
        this.mouseState = { x: 0, y: 0, pressed: false };
        this.shortcuts = new Map();
        
    }
    
    init() {
        this.setupCanvasEvents();
        this.setupButtonEvents();
        this.setupKeyboardEvents();
        this.setupMouseTracking();
        this.setupDefaultShortcuts();
    }
        
    setupCanvasEvents() {
        const canvas = document.getElementById('gameCanvas');
        if (!canvas) return;
        
        canvas.addEventListener('click', (event) => {
            this.game.placementSystem.handleCanvasClick(event);
        });
        
        canvas.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            this.handleRightClick(event);
        });
    }
    
    setupButtonEvents() {        
        const mainMenuPlayGameBtn = document.getElementById('mainMenu_PlayGameBtn');
        const mainMenuTutorialBtn = document.getElementById('mainMenu_TutorialBtn');
        const mainMenuSettingsBtn = document.getElementById('mainMenu_SettingsBtn');
        const mainMenuCreditsBtn = document.getElementById('mainMenu_CreditsBtn');

        const gameModeBackBtn = document.getElementById('gameMode_BackBtn');

        const gamePauseBtn = document.getElementById('game_PauseBtn');
        const gameExitBtn = document.getElementById('game_ExitBtn');
        
        
        const victoryNextRoundBtn = document.getElementById('victory_NextRoundBtn');
        const victoryRestartBtn = document.getElementById('victory_RestartBtn');
        const victoryMainMenuBtn = document.getElementById('victory_MainMenuBtn');

        
        const defeatRetryBtn = document.getElementById('defeat_RetryBtn');
        const defeatChangeModeBtn = document.getElementById('defeat_ChangeModeBtn');
        const defeatMainMenuBtn = document.getElementById('defeat_MainMenuBtn');

        
        const pausedResumeBtn = document.getElementById('paused_ResumeBtn');
        const pausedRestartBtn = document.getElementById('paused_RestartBtn');
        const pausedMainMenuBtn = document.getElementById('paused_MainMenuBtn');

        mainMenuPlayGameBtn?.addEventListener('click', () => {
            this.game.screenManager.showGameModeSelect();
        });
        mainMenuTutorialBtn?.addEventListener('click', () => {
            alert('Tutorial coming soon! Check the battle log for basic instructions when you start playing.');
        });
        mainMenuSettingsBtn?.addEventListener('click', () => {
            this.showSettingsModal();
        });
        mainMenuCreditsBtn?.addEventListener('click', () => {
            alert('Auto Battle Arena\nDeveloped with Claude AI\n\nA tactical auto-battler game featuring strategic unit placement and AI opponents.');
        });

        gameModeBackBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        gamePauseBtn?.addEventListener('click', () => {
            this.game.gameManager.pauseGame();
        });
        gameExitBtn?.addEventListener('click', () => {
            this.game.gameManager.exitToMenu();
        });

        victoryNextRoundBtn?.addEventListener('click', () => {
            this.game.gameManager.continueGame();
        });
        victoryRestartBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        victoryMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        defeatRetryBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        defeatChangeModeBtn?.addEventListener('click', () => {
            this.game.screenManager.showGameModeSelect();
        });
        defeatMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });

        pausedResumeBtn?.addEventListener('click', () => {
            this.game.gameManager.resumeGame();
        });
        pausedRestartBtn?.addEventListener('click', () => {
            this.game.gameManager.restartGame();
        });
        pausedMainMenuBtn?.addEventListener('click', () => {
            this.game.screenManager.showMainMenu();
        });



    }
    
    setupKeyboardEvents() {
        document.addEventListener('keydown', (event) => {
            this.keyStates[event.code] = true;
            this.handleKeyDown(event);
        });
        
        document.addEventListener('keyup', (event) => {
            this.keyStates[event.code] = false;
            this.handleKeyUp(event);
        });
        
        // Prevent default browser shortcuts that might interfere
        document.addEventListener('keydown', (event) => {
            if (this.shouldPreventDefault(event)) {
                event.preventDefault();
            }
        });
    }
        
    setupMouseTracking() {
        document.addEventListener('mousedown', (event) => {
            this.mouseState.pressed = true;
        });
        
        document.addEventListener('mouseup', (event) => {
            this.mouseState.pressed = false;
        });
        
        document.addEventListener('mousemove', (event) => {
            this.mouseState.x = event.clientX;
            this.mouseState.y = event.clientY;
        });
    }
    
    setupDefaultShortcuts() {
        // Define keyboard shortcuts
        this.shortcuts.set('Escape', () => this.handleEscapeKey());
        this.shortcuts.set('KeyH', () => this.showHelpModal());
        this.shortcuts.set('KeyP', () => this.game.phaseSystem.pauseGame());
        this.shortcuts.set('Space', () => this.handleSpaceKey());
        this.shortcuts.set('F1', () => this.showHelpModal());
    }
    
    handleKeyDown(event) {
        const shortcutKey = this.getShortcutKey(event);
        const shortcutHandler = this.shortcuts.get(shortcutKey);
        
        if (shortcutHandler) {
            event.preventDefault();
            shortcutHandler();
        }
        
        // Handle continuous key press actions
        this.handleContinuousKeys(event);
    }
    
    handleKeyUp(event) {
        // Handle key release actions if needed
        this.handleKeyRelease(event);
    }
    
    getShortcutKey(event) {
        let key = event.code;
        if (event.ctrlKey) key += '+Control';
        if (event.shiftKey) key += '+Shift';
        if (event.altKey) key += '+Alt';
        return key;
    }
    
    handleEscapeKey() {
        const pauseMenu = document.getElementById('pauseMenu');
        
        if (this.game.state.currentScreen === 'gameScreen') {
            this.game.phaseSystem.pauseGame();
        } else if (pauseMenu && pauseMenu.style.display === 'flex') {
            this.game.phaseSystem.resumeGame();
        }
        this.cancelSelectedUnit();
    }
    
    handleSpaceKey() {
        const state = this.game.state;
        if (state.phase === 'placement') {
            this.game.phaseSystem.toggleReady();
        }
    }
    
    handleSaveGame() {
        // Trigger save game functionality
        GUTS.NotificationSystem.show('Game saved!', 'success', 2000);
    }
    
    selectUnitShortcut(index) {
        const unitCards = document.querySelectorAll('.unit-card');
        if (unitCards[index] && !unitCards[index].classList.contains('disabled')) {
            unitCards[index].click();
        }
    }
    
    handleContinuousKeys(event) {
        // Handle keys that should trigger repeatedly while held
        if (this.keyStates['ArrowUp']) {
            this.scrollBattleLog(-1);
        }
        if (this.keyStates['ArrowDown']) {
            this.scrollBattleLog(1);
        }
    }
    
    handleKeyRelease(event) {
        // Handle specific key release events
        console.log(event.code);
        switch (event.code) {
            case 'Tab':
                this.cycleThroughUnits();
                break;
        }
    }
    
    shouldPreventDefault(event) {
        // Prevent certain browser shortcuts
        if (event.ctrlKey && event.code === 'KeyS') return true;
        if (event.code === 'F1') return true;
        return false;
    }
    
    handleRightClick(event) {
        // Handle right-click on canvas (e.g., cancel selection)

    }
        
    updateMousePosition(event) {
        this.mouseState.x = event.clientX;
        this.mouseState.y = event.clientY;
    }
   
    
    cancelSelectedUnit() {
        const state = this.game.state;
        if (state.selectedUnitType) {
            document.querySelectorAll('.selected').forEach(selected => {
                selected.classList.remove('selected');
            });
            state.selectedUnitType = null;
            this.game.placementSystem.handleUnitSelectionChange(null);
        }
    }
    cycleThroughUnits() {
        const unitCards = document.querySelectorAll('.unit-card:not(.disabled)');
        const currentSelected = document.querySelector('.unit-card.selected');
        
        if (unitCards.length === 0) return;
        
        let nextIndex = 0;
        if (currentSelected) {
            const currentIndex = Array.from(unitCards).indexOf(currentSelected);
            nextIndex = (currentIndex + 1) % unitCards.length;
        }
        
        unitCards[nextIndex].click();
    }
    
    scrollBattleLog(direction) {
        const battleLog = document.getElementById('battleLog');
        if (battleLog) {
            battleLog.scrollTop += direction * 20;
        }
    }
    
    handleMainMenuAction() {
        if (confirm('Return to main menu? Current progress will be lost.')) {
            // Trigger main menu navigation
            if (window.screenManager) {
                window.screenManager.showMainMenu();
            }
        }
    }
    
    showSettingsModal() {
        const settingsContent = `
            <h3>⚙️ GAME SETTINGS</h3>
            <div class="settings-section">
                <h4>Graphics</h4>
                <label><input type="checkbox" id="particles-enabled" checked> Particle Effects</label>
                <label><input type="checkbox" id="screen-shake" checked> Screen Shake</label>
                <label><input type="range" id="particle-density" min="0.5" max="2" step="0.1" value="1"> Particle Density</label>
            </div>
            <div class="settings-section">
                <h4>Audio</h4>
                <label><input type="checkbox" id="sound-effects" checked> Sound Effects</label>
                <label><input type="range" id="volume" min="0" max="1" step="0.1" value="0.7"> Volume</label>
            </div>
            <div class="settings-section">
                <h4>Controls</h4>
                <p><strong>ESC</strong> - Pause/Resume</p>
                <p><strong>H</strong> - Help</p>
                <p><strong>Space</strong> - Ready</p>
                <p><strong>1-4</strong> - Select Units</p>
                <p><strong>Ctrl+R</strong> - Restart</p>
            </div>
        `;
        
        this.showModal('Settings', settingsContent, () => {
            this.applySettings();
        });
    }
    
    applySettings() {
        // Apply settings from modal
        const particlesEnabled = document.getElementById('particles-enabled')?.checked ?? true;
        const screenShake = document.getElementById('screen-shake')?.checked ?? true;
        const particleDensity = document.getElementById('particle-density')?.value ?? 1;
        const soundEffects = document.getElementById('sound-effects')?.checked ?? true;
        const volume = document.getElementById('volume')?.value ?? 0.7;
        
        // Save to localStorage
        localStorage.setItem('gameSettings', JSON.stringify({
            particlesEnabled,
            screenShake,
            particleDensity,
            soundEffects,
            volume
        }));
        
        GUTS.NotificationSystem.show('Settings saved!', 'success');
    }
    
    showHelpModal() {
        const helpContent = `
            <h3>🎮 CONTROLS</h3>
            <div class="help-section">
                <p><strong>ESC</strong> - Pause/Resume game</p>
                <p><strong>H or F1</strong> - Show this help</p>
                <p><strong>P</strong> - Pause game</p>
                <p><strong>Space</strong> - Ready for battle</p>
                <p><strong>Ctrl+R</strong> - Restart game</p>
                <p><strong>Ctrl+S</strong> - Save game</p>
                <p><strong>1-4</strong> - Quick select units</p>
                <p><strong>Tab</strong> - Cycle through units</p>
                <p><strong>Right Click</strong> - Cancel selection</p>
            </div>
            
            <h3>📋 HOW TO PLAY</h3>
            <div class="help-section">
                <p>1. <strong>Select units</strong> from the shop by clicking or using number keys</p>
                <p>2. <strong>Place units</strong> on your side of the battlefield (left half)</p>
                <p>3. <strong>Ready up</strong> when your army is prepared</p>
                <p>4. <strong>Watch the battle</strong> unfold automatically</p>
                <p>5. <strong>Earn gold</strong> from victories to build stronger armies</p>
            </div>
            
            <h3>💡 STRATEGY TIPS</h3>
            <div class="help-section">
                <p>• Balance offense and defense in your army</p>
                <p>• Position tanks in front to absorb damage</p>
                <p>• Place ranged units behind melee fighters</p>
                <p>• Spread units to avoid area damage</p>
                <p>• Save some gold for emergency purchases</p>
                <p>• Adapt your strategy based on enemy composition</p>
            </div>
        `;
        
        this.showModal('Game Help', helpContent);
    }
    
    showModal(title, content, onClose = null) {
        const modal = document.createElement('div');
        modal.className = 'game-modal';
        modal.innerHTML = `
            <div class="modal-backdrop"></div>
            <div class="modal-content">
                <div class="modal-header">
                    <h2>${title}</h2>
                    <button class="modal-close" type="button">&times;</button>
                </div>
                <div class="modal-body">${content}</div>
            </div>
        `;
        
        const closeBtn = modal.querySelector('.modal-close');
        const backdrop = modal.querySelector('.modal-backdrop');
        
        const closeModal = () => {
            if (document.body.contains(modal)) {
                document.body.removeChild(modal);
                if (onClose) onClose();
            }
        };
        
        closeBtn.addEventListener('click', closeModal);
        backdrop.addEventListener('click', closeModal);
        
        // Close on ESC key
        const escHandler = (event) => {
            if (event.key === 'Escape') {
                closeModal();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        document.body.appendChild(modal);
        this.addModalCSS();
    }
    
    addModalCSS() {
        if (document.querySelector('#modal-styles')) return;
        
        const style = document.createElement('style');
        style.id = 'modal-styles';
        style.textContent = `
            .game-modal {
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                z-index: 2000; display: flex; justify-content: center; align-items: center;
            }
            
            .modal-backdrop {
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(3px);
            }
            
            .modal-content {
                position: relative; background: linear-gradient(145deg, #1a1a2e, #16213e);
                border: 2px solid #00ffff; border-radius: 10px; max-width: 600px;
                width: 90%; max-height: 80%; overflow-y: auto;
                animation: modalAppear 0.3s ease-out;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            }
            
            @keyframes modalAppear {
                from { transform: scale(0.9); opacity: 0; }
                to { transform: scale(1); opacity: 1; }
            }
            
            .modal-header {
                padding: 1rem; border-bottom: 1px solid #333;
                display: flex; justify-content: space-between; align-items: center;
                background: rgba(0, 255, 255, 0.1);
            }
            
            .modal-header h2 { color: #00ffff; margin: 0; }
            
            .modal-close {
                background: none; border: none; color: #ccc; font-size: 1.5rem;
                cursor: pointer; padding: 0; width: 30px; height: 30px;
                display: flex; align-items: center; justify-content: center;
                border-radius: 50%; transition: all 0.2s;
            }
            
            .modal-close:hover { 
                color: #ff4444; background: rgba(255, 68, 68, 0.1); 
            }
            .modal-body {
                padding: 1.5rem; color: #ccc; line-height: 1.6;
            }
            
            .modal-body h3 { 
                color: #00ffff; margin-top: 1.5rem; margin-bottom: 0.8rem;
                border-bottom: 1px solid #333; padding-bottom: 0.5rem;
            }
            
            .modal-body h4 {
                color: #ffff88; margin-top: 1rem; margin-bottom: 0.5rem;
            }
            
            .modal-body p { margin-bottom: 0.6rem; }
            .modal-body strong { color: #ffff00; }
            
            .help-section {
                margin-bottom: 1rem; padding-left: 1rem;
            }
            
            .settings-section {
                margin-bottom: 1.5rem; padding: 1rem;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 5px;
            }
            
            .settings-section label {
                display: block; margin-bottom: 0.8rem;
                color: #ccc; cursor: pointer;
            }
            
            .settings-section input[type="checkbox"] {
                margin-right: 0.5rem; accent-color: #00ffff;
            }
            
            .settings-section input[type="range"] {
                width: 100%; margin-top: 0.3rem;
                accent-color: #00ffff;
            }
        `;
        document.head.appendChild(style);
    }
    
    // Utility methods
    isKeyPressed(keyCode) {
        return this.keyStates[keyCode] || false;
    }
    
    getMousePosition() {
        return { ...this.mouseState };
    }
    
    addCustomShortcut(keyCombo, handler) {
        this.shortcuts.set(keyCombo, handler);
    }
    
    removeShortcut(keyCombo) {
        this.shortcuts.delete(keyCombo);
    }
}
;

// ========== CLASS REGISTRY ACCESSORS ==========

/**
 * Get a compiled class by name and type
 * This replaces the ModuleManager.getCompiledScript method for compiled bundles
 */
window.COMPILED_GAME.getClass = function(className, collectionType) {
    const collection = window.COMPILED_GAME.classRegistry[collectionType];
    if (!collection) {
        console.error(`Collection ${collectionType} not found in compiled bundle`);
        return null;
    }
    
    const ClassDef = collection[className];
    if (!ClassDef) {
        console.error(`Class ${className} not found in collection ${collectionType}`);
        return null;
    }
    
    return ClassDef;
};

/**
 * Check if a class exists in the compiled bundle
 */
window.COMPILED_GAME.hasClass = function(className, collectionType) {
    const collection = window.COMPILED_GAME.classRegistry[collectionType];
    return collection && collection[className] !== undefined;
};

// ========== INITIALIZATION ==========

/**
 * Initialize the compiled bundle - patches ModuleManager to prevent duplicate loading
 */
window.COMPILED_GAME.init = function(engine) {
    if (window.COMPILED_GAME.initialized) {
        console.log('Compiled game bundle already initialized');
        return;
    }
    
    console.log('Initializing compiled game bundle...');
    
    // Store original methods
    const originalGetCompiledScript = ModuleManager.prototype.getCompiledScript;
    const originalCompileScript = ModuleManager.prototype.compileScript;
    const originalCompileFunction = ModuleManager.prototype.compileFunction;
    
    // Patch getCompiledScript
    ModuleManager.prototype.getCompiledScript = function(typeName, collectionType) {
        if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
            return window.COMPILED_GAME.getClass(typeName, collectionType);
        }
        return originalGetCompiledScript.call(this, typeName, collectionType);
    };
    
    // Patch compileScript
    ModuleManager.prototype.compileScript = function(scriptText, typeName) {
        for (const collectionType in window.COMPILED_GAME.classRegistry) {
            if (window.COMPILED_GAME.hasClass(typeName, collectionType)) {
                return window.COMPILED_GAME.getClass(typeName, collectionType);
            }
        }
        return originalCompileScript.call(this, scriptText, typeName);
    };
    
    // Patch compileFunction
    ModuleManager.prototype.compileFunction = function(scriptText, typeName) {
        if (window.COMPILED_GAME.hasClass(typeName, 'functions')) {
            return window.COMPILED_GAME.getClass(typeName, 'functions');
        }
        return originalCompileFunction.call(this, scriptText, typeName);
    };
    
    // Make library classes available
    if (engine.moduleManager) {
        engine.moduleManager.libraryClasses = {
            ...engine.moduleManager.libraryClasses,
            ...window.COMPILED_GAME.libraryClasses
        };
        window.GUTS = engine.moduleManager.libraryClasses;
    }
    
    window.COMPILED_GAME.initialized = true;
    console.log('Compiled game bundle initialized successfully');
};

// Wait for external libraries to load before allowing engine init
window.COMPILED_GAME.ready = new Promise((resolve) => {
    if (window.COMPILED_GAME.externalLibraries && window.COMPILED_GAME.externalLibraries.length > 0) {
        window.addEventListener('compiled-libraries-ready', () => {
            console.log('🎮 Compiled game ready');
            resolve();
        });
    } else {
        // No external libraries, ready immediately
        resolve();
    }
});